[
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    input_tokens = stdin.split('\\n')[1].split()\n\n    stack = []\n    modulo = 10**9 + 7\n\n    for token in input_tokens:\n        if token == '(':\n            stack.append('(')\n        elif token == ')':\n            sub_expression = []\n\n            while stack and stack[-1] != '(':\n                sub_expression.append(stack.pop())\n\n            if not stack:\n                raise ValueError(\"Invalid bracket sequence: unmatched closing parenthesis\")\n            stack.pop()\n\n            if sub_expression:\n                value = 1\n                for x in sub_expression:\n                    if x.isdigit():\n                        value *= int(x)\n                    else:\n                        value = value * 2 if x == '+' else value * 3\n\n                stack.append(str(value % modulo))\n        else:\n            if not stack:\n                raise ValueError(\"Invalid bracket sequence: unmatched closing parenthesis\")\n            stack.append(token)\n\n    if stack:\n        raise ValueError(\"Invalid bracket sequence: unmatched opening parenthesis\")\n\n    if stack[-1].isdigit():\n        return stack[0]\n    else:\n        value = 1\n        for x in stack:\n            if x.isdigit():\n                value *= int(x)\n            else:\n                value = value * 2 if x == '+' else value * 3\n        return str(value % modulo)"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, brackets = input().split()\n    n = int(n)\n    brackets = [int(brackets[i]) for i in range(n)]\n\n    stack = []\n    i = 0\n    while i < n:\n        if brackets[i] == \"(\":\n            stack.append(i)\n        elif brackets[i] == \")\":\n            start = stack.pop()\n            subseq = brackets[start+1:i]\n            while subseq and subseq[-1] == \")\":\n                subseq.pop()\n            if not subseq:\n                raise ValueError(\"Invalid bracket sequence\")\n            num = evaluate_subseq(subseq)\n            brackets[start] = num\n            brackets[i] = None\n        else:\n            i += 1\n\n    def evaluate_subseq(subseq):\n        stack = []\n        for token in subseq:\n            if token.isdigit():\n                stack.append(int(token))\n            elif token == \"+\":\n                b = stack.pop()\n                a = stack.pop()\n                stack.append(a + b)\n            elif token == \"*\":\n                b = stack.pop()\n                a = stack.pop()\n                stack.append(a * b)\n        if len(stack) != 1:\n            raise ValueError(\"Invalid bracket sequence\")\n        return stack.pop()\n\n    result = brackets[0] % (10**9 + 7)\n    return str(result)\n"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    tokens = stdin.split()[1:]\n    stack = []\n    for token in tokens:\n        if token == \"(\":\n            stack.append(\"(\")\n        elif token == \")\":\n            while stack and stack[-1] != \"(\":\n                stack.pop()\n            stack.pop()\n        else:\n            stack.append(int(token))\n    result = 0\n    while stack:\n        if stack[-1] == \"(\":\n            stack.pop()\n        else:\n            result += stack.pop()\n    return str(result % (10**9+7))\n"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, bracket_sequence = stdin.split(\"\\n\")\n    n = int(n)\n    bracket_sequence = bracket_sequence.split()\n\n    stack = []\n    result = 0\n\n    for token in bracket_sequence:\n        if token == \"(\":\n            stack.append(token)\n        elif token == \")\":\n            while stack[-1] != \"(\":\n                result = result + int(stack.pop())\n            stack.pop()\n        else:\n            result = result + int(token)\n\n    while stack:\n        result = result + int(stack.pop())\n\n    return str(result % (10**9+7))\n"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def process_tokens(tokens: list, current_stack: list) -> int:\n        result = 0\n        for token in tokens:\n            if token.isdigit():\n                result = (result + int(token)) % MOD\n            elif token == '(':\n                current_stack.append(result)\n                result = 0\n            elif token == ')':\n                operand = current_stack.pop()\n                current_stack[-1] = (current_stack[-1] + operand) % MOD\n                result = 0\n        return result\n\n    N = int(stdin[0])\n    MOD = 10**9 + 7\n    tokens = stdin[1].split()\n    current_stack = []\n    result = process_tokens(tokens, current_stack)\n    return result"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    tokens = stdin.splitlines()[1].split()\n\n    def evaluate(tokens: list) -> int:\n        stack = []\n        while tokens:\n            token = tokens.pop(0)\n            if token == '(':\n                stack.append(evaluate(tokens))\n            elif token == ')':\n                break\n            else:\n                stack.append(int(token))\n        return stack.pop()\n\n    result = evaluate(tokens)\n    return str(result % (10**9 + 7))\n"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    tokens = stdin.splitlines()[1].split()\n\n    stack = []\n    result = 0\n\n    for token in tokens:\n        if token == '(':\n            stack.append('(')\n        elif token == ')':\n            subsequence = []\n            while stack[-1] != '(':\n                subsequence.append(stack.pop())\n            stack.pop()\n\n            if len(subsequence) > 1:\n                subresult = 1\n                for i in range(len(subsequence)):\n                    if i % 2 == 0:\n                        subresult *= int(subsequence[i])\n                    else:\n                        subresult *= (int(subsequence[i]) + 1)\n\n                result += subresult\n        else:\n            result += int(token)\n\n    result %= (10**9 + 7)\n    return str(result)"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split()\n    n = int(input_list[0])\n    input_list = input_list[1:]\n\n    def evaluate_bracket_sequence(sequence: list) -> int:\n        stack = []\n        for token in sequence:\n            if token == '(':\n                stack.append(token)\n            elif token == ')':\n                subsequence = []\n                while stack[-1] != '(':\n                    subsequence.append(stack.pop())\n                subsequence.append(stack.pop())\n                subsequence.reverse()\n                result = evaluate_bracket_sequence(subsequence)\n                stack.append(result)\n            else:\n                stack.append(int(token))\n        while stack:\n            result = stack.pop()\n            if isinstance(result, int):\n                return result % (10**9+7)\n        return 0\n\n    for i in range(n):\n        sequence = input_list[:4*i+1]\n        input_list = input_list[4*i+1:]\n        result = evaluate_bracket_sequence(sequence)\n        if i < n-1:\n            print(result, end=' ')\n        else:\n            print(result)\n"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, seq = input_processing(stdin)\n    value = eval_bracket_sequence(seq)\n    return str(value % (10**9 + 7))\n\ndef"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n = int(stdin)\n    tokens = stdin.split()\n\n    # Initialize stack\n    stack = []\n\n    # Iterate through tokens\n    for token in tokens:\n        # If opening bracket, push to stack\n        if token == '(':\n            stack.append('(')\n        # If closing bracket, pop from stack and evaluate until opening bracket\n        elif token == ')':\n            while stack and stack[-1] != '(':\n                num2 = stack.pop()\n                num1 = stack.pop()\n                op = stack.pop()\n                if op == '+':\n                    stack.append(num1 + num2)\n                else:\n                    stack.append(num1 * num2)\n            stack.pop()\n\n    # Check if there are any operators left on the stack\n    while stack:\n        num2 = stack.pop()\n        num1 = stack.pop()\n        op = stack.pop()\n        if op == '+':\n            stack.append(num1 + num2)\n        else:\n            stack.append(num1 * num2)\n\n    # Modulo operation\n    result = stack[0] % (10**9 + 7)\n\n    return str(result)"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    counter = [int(c) for c in stdin]\n    n = len(counter)\n\n    # Initialize palindrome and distance\n    palindrome = counter.copy()\n    distance = [0] * n\n\n    # Iterate over all digits in the number\n    for i in range(n):\n        # Find the maximum number of steps we can take from the current digit\n        # to the middle of the palindrome\n        steps = min(palindrome[i], 5 - i)\n\n        # Update the palindrome and distance\n        for j in range(i, i + steps):\n            if j < n // 2:\n                palindrome[j] -= steps\n                palindrome[n - 1 - j] += steps\n            else:\n                palindrome[j] += steps\n                palindrome[n - 1 - j] -= steps\n        distance[i] = steps\n\n    # Compute the minimum number of steps required to reach a palindrome\n    min_steps = sum(distance[:n // 2])\n\n    return str(min_steps)"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    input_str_list = list(input_str)\n    reversed_input_str_list = input_str_list.copy()\n    reversed_input_str_list.reverse()\n    reversed_input_str = ''.join(reversed_input_str_list)\n    if input_str == reversed_input_str:\n        return 0\n\n    num_wheels = len(input_str_list)\n    num_digits = len(input_str)\n    num_leading_zeros = input_str.count('0')\n\n    if num_digits == 1:\n        return 0\n\n    num_steps = 0\n    num_steps_list = [0] * num_digits\n\n    for i in range(num_digits):\n        num_steps_list[i] = abs(ord(input_str_list[i]) - ord(reversed_input_str_list[i]))\n\n    for i in range(num_digits - 1):\n        if num_steps_list[i] > 4:\n            num_steps += num_steps_list[i]\n        else:\n            num_steps += 4 - num_steps_list[i]\n\n    num_steps += num_digits - 1\n\n    if num_leading_zeros > 0:\n        num_steps += num_leading_zeros\n\n    return num_steps\n"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_palindrome(n: int) -> int:\n        if n % 10 == 0:\n            # If the last digit is 0, we need to carry a 1 to the leftmost digit\n            # and increment the second-to-left digit\n            n -= 1\n            n //= 10\n            n += 10\n            n *= 10\n            n += 1\n            n *= 10\n            return n\n        else:\n            # If the last digit is not 0, we need to increment the last digit\n            # and advance the second-to-last digit to the next digit\n            n += 1\n            n %= 100\n            n //= 10\n            n += 1\n            n *= 10\n            return n\n\n    def advance_counter(wheels: int, n: int) -> int:\n        count = 0\n        while n > 0:\n            n //= 10\n            count += 1\n        return count\n\n    n = int(stdin)\n    wheels = len(stdin)\n    steps = advance_counter(wheels, n)\n    while not str(n) == str(n)[::-1]:\n        n = get_next_palindrome(n)\n        steps += 1\n    return steps\n"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def spin(num: str) -> str:\n        result = \"\"\n        for i in range(len(num) - 1, -1, -1):\n            result += num[i]\n        return result\n\n    def is_palindrome(num: str) -> bool:\n        return num == spin(num)\n\n    def min_steps_to_palindrome(num: str) -> int:\n        if is_palindrome(num):\n            return 0\n\n        def get_min_steps(i: int) -> int:\n            if i < 0:\n                return 0\n\n            num_str = str(num[i])\n            if num_str == \"0\":\n                return get_min_steps(i - 1) + 1\n\n            if num_str == \"9\":\n                if i > 0 and num[i - 1] == \"9\":\n                    return get_min_steps(i - 1) + 1\n                else:\n                    return get_min_steps(i - 1)\n\n            return min(get_min_steps(i - 1) + 1, get_min_steps(i - 2) + 1)\n\n        return get_min_steps(len(num) - 1)\n\n    num = stdin.strip()\n    return str(min_steps_to_palindrome(num))"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def next_palindrome(num: str) -> str:\n        # Convert the input number to a list of digits\n        digits = [int(digit) for digit in num]\n\n        # Find the first non-9 digit from the right\n        first_non_9 = len(digits) - 1\n        while first_non_9 > 0 and digits[first_non_9] == 9:\n            first_non_9 -= 1\n\n        # If the number is already a palindrome, return it\n        if first_non_9 <= 0:\n            return num\n\n        # Otherwise, increment the first non-9 digit and carry over to the digits to its left\n        digits[first_non_9] += 1\n        for i in range(first_non_9 - 1, -1, -1):\n            if digits[i] == 10:\n                digits[i] = 0\n                digits[i - 1] += 1\n            else:\n                break\n\n        # Convert the list of digits back to a string and return it\n        return ''.join(map(str, digits))\n\n    # Convert the input string to a palindrome\n    palindrome = next_palindrome(stdin)\n\n    # Calculate the minimum number of wheel advances required\n    k = len(stdin)\n    min_steps = k - 1\n    while palindrome != stdin:\n        for i in range(k - 1, -1, -1):\n            if palindrome[i] < stdin[i]:\n                min_steps += k - i - 1\n                break\n        palindrome = next_palindrome(palindrome)\n\n    return str(min_steps)\n"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def next_palindrome(n: int) -> int:\n        n = str(n)\n        n_len = len(n)\n        for i in range(n_len // 2):\n            if n[i] != n[n_len - i - 1]:\n                if n[i] < n[n_len - i - 1]:\n                    n = n[:i] + chr(ord(n[i]) + 1) + n[i+1:] + chr(ord(n[i]) + 1) + n[:i:-1]\n                else:\n                    n = n[:i] + chr(ord(n[i]) - 1) + n[i+1:] + chr(ord(n[i]) - 1) + n[:i:-1]\n                break\n        return int(n)\n\n    def min_steps_to_palindrome(n: int) -> int:\n        n_str = str(n)\n        n_len = len(n_str)\n        palindrome = next_palindrome(n)\n        palindrome_str = str(palindrome)\n        palindrome_len = len(palindrome_str)\n\n        if n_str == palindrome_str:\n            return 0\n        elif n_len == 1 or n_len == 2:\n            return 1\n        else:\n            min_steps = min_steps_to_palindrome(n // 10)\n            return min_steps + (n % 10 != palindrome_str[0])\n\n    n = int(stdin)\n    min_steps = min_steps_to_palindrome(n)\n    return str(min_steps)"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Remove leading and trailing whitespaces\n    stdin = stdin.strip()\n    \n    # Convert string to list of characters\n    digits = list(stdin)\n\n    # Initialize the number of steps and the index of the last digit\n    steps = 0\n    last_digit = -1\n\n    # Iterate through the list of characters\n    for i in range(len(digits)):\n        # If the digit is a zero, skip it\n        if digits[i] == '0':\n            continue\n\n        # If the digit is the same as the last digit, increment the number of steps\n        if digits[i] == digits[last_digit]:\n            steps += 1\n\n        # If the digit is greater than the last digit, increment the number of steps\n        elif ord(digits[i]) > ord(digits[last_digit]):\n            steps += ord(digits[i]) - ord(digits[last_digit])\n\n        # If the digit is less than the last digit, increment the number of steps and set the current digit as the new last digit\n        else:\n            steps += ord(digits[last_digit]) - ord(digits[i])\n            last_digit = i\n\n        # If the number of steps is greater than the number of digits, the number is not a palindrome\n        if steps > len(digits):\n            return \"Impossible\"\n\n    return steps"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num = stdin\n    n = len(num)\n    mid = n // 2\n\n    # count number of leading zeros\n    count_zeros = 0\n    for i in range(n):\n        if num[i] == '0':\n            count_zeros += 1\n        else:\n            break\n\n    # count number of steps required to reach the midpoint\n    steps_to_mid = 0\n    i, j = n - 1, 0\n    while i > mid and j < mid:\n        if num[i] != num[j]:\n            steps_to_mid += 1\n        i -= 1\n        j += 1\n\n    # count number of steps required to reach the end\n    steps_to_end = 0\n    if n % 2 == 0:\n        i, j = n - 1, n // 2\n        while i > 0 and j < n - 1:\n            if num[i] != num[j]:\n                steps_to_end += 1\n            i -= 1\n            j += 1\n    else:\n        i, j = n - 1, n // 2\n        while i > 0 and j < n - 1:\n            if num[i] != num[j]:\n                steps_to_end += 1\n            i -= 1\n            j += 1\n\n    # count number of steps required to reverse the number\n    steps_to_reverse = 0\n    for i in range(mid):\n        if num[i] != num[n - 1 - i]:\n            steps_to_reverse += 1\n\n    # count number of steps required to reach the next palindrome\n    next_palindrome = list(num)\n    if n % 2 == 0:\n        i, j = n // 2 - 1, n // 2\n        while i >= 0 and j < n:\n            if num[i] > '4':\n                next_palindrome[i] = '0'\n                next_palindrome[j] = '9'\n                i -= 1\n                j += 1\n            else:\n                next_palindrome[i] = chr(ord(num[i]) + 1)\n                next_palindrome[j] = chr(ord(num[j]) - 1)\n                i -= 1\n                j += 1\n    else:\n        i, j = n // 2, n // 2 + 1\n        while i >= 0 and j < n:\n            if num[i] > '4':\n                next_palindrome[i] = '0'\n                next_palindrome[j] = '9'\n                i -= 1\n                j += 1\n            else:\n                next_palindrome[i] = chr(ord(num[i]) + 1)\n                next_palindrome[j] = chr(ord(num[j]) - 1)\n                i -= 1\n                j += 1\n    next_palindrome = ''.join(next_palindrome)\n\n    # count total number of steps\n    total_steps = steps_to_mid + steps_to_end + steps_to_reverse + 2 * count_zeros\n\n    return total_steps"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque\n    from itertools import permutations\n\n    def reverse_number(number: str) -> str:\n        return number[::-1]\n\n    def is_palindrome(number: str) -> bool:\n        return number == reverse_number(number)\n\n    def count_steps(current: str, target: str) -> int:\n        steps = 0\n        for i in range(len(current)):\n            if current[i] != target[i]:\n                steps += abs(int(current[i]) - int(target[i]))\n        return steps\n\n    def find_min_steps(current: str) -> int:\n        if is_palindrome(current):\n            return 0\n\n        min_steps = float('inf')\n        for perm in permutations(current):\n            target = ''.join(perm)\n            if is_palindrome(target):\n                min_steps = min(min_steps, count_steps(current, target))\n\n        return min_steps\n\n    stdin = deque(stdin)\n    current = ''\n    while stdin:\n        current += stdin.popleft()\n\n    return str(find_min_steps(current))\n"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def reverse_number(number: str) -> str:\n        return number[::-1]\n\n    def is_palindrome(number: str) -> bool:\n        return number == reverse_number(number)\n\n    def min_steps_to_palindrome(number: str) -> int:\n        if is_palindrome(number):\n            return 0\n\n        def palindrome_exists(number: str) -> bool:\n            for i in range(len(number)):\n                if number[i] != number[-i - 1]:\n                    return True\n            return False\n\n        if not palindrome_exists(number):\n            return -1\n\n        def find_next_palindrome(number: str) -> str:\n            def increment_number(number: str) -> str:\n                carry = 1\n                result = \"\"\n                for i in range(len(number) - 1, -1, -1):\n                    if carry == 0:\n                        break\n                    if i == len(number) - 1 or number[i + 1] == \"9\":\n                        result = \"1\" + result\n                        carry = 1\n                    else:\n                        result = str(int(number[i]) + 1) + result\n                        carry = 0\n                return result\n\n            def next_palindrome(number: str) -> str:\n                reversed_number = reverse_number(number)\n                for i in range(len(number)):\n                    if number[i] != reversed_number[i]:\n                        return increment_number(number[:i] + \"9\" * (len(number) - i) + \"0\" * i)\n                return increment_number(number)\n\n            return next_palindrome(number)\n\n        def min_steps_to_reverse(number: str) -> int:\n            def min_steps_to_reverse_helper(number: str, steps: int) -> int:\n                if is_palindrome(number):\n                    return steps\n                for i in range(len(number)):\n                    if number[i] != number[-i - 1]:\n                        return steps + min_steps_to_reverse_helper(number[:i] + number[i + 1:], steps + 1)\n                return steps + min_steps_to_reverse_helper(number, steps + 1)\n\n            return min_steps_to_reverse_helper(number, 0)\n\n        return min_steps_to_reverse(find_next_palindrome(number))\n\n    number = stdin.strip()\n    return str(min_steps_to_palindrome(number))"
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_service(service: List[int]) -> bool:\n        year, month, odometer = service\n        return 2000 <= odometer <= 20000\n\n    def is_service_sufficient(service: List[int], prev_service: List[int]) -> bool:\n        year, month, odometer = service\n        prev_year, prev_month, _ = prev_service\n        delta_time = (year - prev_year) * 12 + (month - prev_month)\n        delta_distance = odometer - prev_service[2]\n        return (delta_distance >= 2000 and delta_time >= 12) or (delta_distance >= 2000 and delta_distance <= 20000)\n\n    def is_odometer_tampered(service_history: List[List[int]]) -> bool:\n        for i in range(1, len(service_history)):\n            if service_history[i][2] > service_history[i - 1][2]:\n                return True\n        return False\n\n    e = int(stdin)\n    service_history = []\n    for _ in range(e):\n        year, month, odometer = map(int, stdin.readline().split())\n        service_history.append([year, month, odometer])\n\n    if is_odometer_tampered(service_history):\n        return \"tampered odometer\"\n\n    for i in range(1, len(service_history)):\n        prev_service = service_history[i - 1]\n        service = service_history[i]\n        if not is_valid_service(service):\n            return \"insufficient service\"\n        if not is_service_sufficient(service, prev_service):\n            return \"insufficient service\"\n\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def month_range(year: int, month: int, distance: int) -> bool:\n        days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        days = days_in_month[month - 1]\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            days = 29\n        return distance <= days * 1000\n\n    def has_service_every_n_km(history: list[tuple[int, int, int]], n: int) -> bool:\n        current_distance = 0\n        last_service = None\n        for year, month, odometer in history:\n            if last_service is not None and (year - last_service[0], month - last_service[1]) > (0, 0):\n                current_distance = odometer\n            else:\n                current_distance += odometer\n            last_service = (year, month)\n            if current_distance >= n:\n                return True\n        return False\n\n    def has_service_every_n_months(history: list[tuple[int, int, int]], n: int) -> bool:\n        last_service = None\n        for year, month, odometer in history:\n            if last_service is not None and (year - last_service[0], month - last_service[1]) > (0, 0):\n                if (year - last_service[0]) % 12 < n:\n                    return False\n            last_service = (year, month)\n        return True\n\n    n, m = map(int, stdin.split())\n    history = [tuple(map(int, input().split())) for _ in range(n)]\n    total_distance = sum(h[2] for h in history)\n    years = [h[0] for h in history]\n    months = [h[1] for h in history]\n    for year in years:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            return \"tampered odometer\"\n    if total_distance < 3000:\n        return \"insufficient service\"\n    for i in range(1, m):\n        if not month_range(years[i], months[i], total_distance):\n            return \"insufficient service\"\n    if not has_service_every_n_km(history, 30000) and not has_service_every_n_months(history, 12):\n        return \"insufficient service\"\n    return \"seems legit\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    e, *rest = stdin.split('\\n')\n    e = int(e)\n    history = [tuple(map(int, line.split())) for line in rest]\n\n    def check_tampered(history: list) -> bool:\n        last_year = None\n        for year, month, odometer in history:\n            if last_year is not None and year != last_year:\n                if odometer != 0:\n                    return True\n            last_year = year\n        return False\n\n    def service_interval(history: list) -> int:\n        last_year, last_month = None, None\n        for year, month, odometer in history:\n            if last_year is not None and last_month is not None and month != last_month + 1:\n                return (year - last_year) * 12 + (month - last_month)\n            last_year, last_month = year, month\n        return (year - last_year) * 12 + (month - last_month)\n\n    if check_tampered(history):\n        return \"tampered odometer\"\n\n    interval = service_interval(history)\n    if interval < 12:\n        return \"insufficient service\"\n\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    service_history = []\n    e, stdin = map(int, stdin.split()[:2]), stdin.split()[2:]\n    for _ in range(e[0]):\n        service_history.append(tuple(map(int, stdin[:3])))\n        stdin = stdin[3:]\n\n    def odometer_reading(y, m, o):\n        return o\n\n    def service_interval(y, m):\n        return min(12, 30000 // (365 * (2018 - y)))\n\n    def last_service_month(y, m):\n        m = m % 12\n        if m == 0:\n            m = 12\n        return y, m\n\n    def service_history_interval(y, m):\n        last_m, last_y = last_service_month(y, m)\n        last_s = min(last_m, service_interval(last_y, last_m))\n        return last_s\n\n    def check_tampered_odometer(service_history):\n        last_y, last_m = service_history[0][:2]\n        last_o = odometer_reading(last_y, last_m, service_history[0][2])\n        for y, m, o in service_history[1:]:\n            if o < last_o:\n                return True\n            last_o = odometer_reading(y, m, o)\n        return False\n\n    def check_insufficient_service(service_history):\n        last_y, last_m = service_history[0][:2]\n        last_o = odometer_reading(last_y, last_m, service_history[0][2])\n        last_s = service_history_interval(last_y, last_m)\n        for y, m, o in service_history[1:]:\n            if service_interval(y, m) > last_s:\n                return True\n            last_o = odometer_reading(y, m, o)\n            last_s = service_history_interval(y, m)\n        return False\n\n    if check_tampered_odometer(service_history):\n        return \"tampered odometer\"\n    elif check_insufficient_service(service_history):\n        return \"insufficient service\"\n    else:\n        return \"seems legit\"\n\nstdin = \"\"\"3\n2017 4 0\n2017 8 12000\n2018 8 42000\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    e = int(input())\n    service_history = []\n    \n    for _ in range(e):\n        y, m, o = map(int, input().split())\n        service_history.append((y, m, o))\n    \n    service_history.sort(key=lambda x: (x[0], x[1]))\n    \n    # Check if odometer has been tampered with\n    for i in range(1, e):\n        if service_history[i][2] < service_history[i-1][2]:\n            return \"tampered odometer\"\n    \n    # Check if service has been done frequently enough\n    last_service = service_history[0]\n    last_year, last_month = last_service[0], last_service[1]\n    service_interval = 0\n    \n    for y, m, o in service_history[1:]:\n        if y > last_year or (y == last_year and m > last_month):\n            service_interval += 1\n            if service_interval == 3:\n                if o < 30000:\n                    return \"insufficient service\"\n                service_interval = 0\n            last_year, last_month = y, m\n    \n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    service_history = []\n    for line in stdin.splitlines():\n        y, m, o = map(int, line.split())\n        service_history.append((y, m, o))\n\n    if not service_history:\n        return \"seems legit\"\n\n    # Determine if odometer has been tampered with\n    previous_reading = service_history[0][2]\n    for year, month, reading in service_history:\n        if previous_reading > reading:\n            return \"tampered odometer\"\n        previous_reading = reading\n\n    # Determine if service has been done frequently enough\n    last_service_date = datetime.date(service_history[-1][0], service_history[-1][1], 1)\n    first_service_date = datetime.date(service_history[0][0], service_history[0][1], 1)\n    total_months_traveled = (last_service_date.year - first_service_date.year) * 12 + (last_service_date.month - first_service_date.month)\n\n    if total_months_traveled < 12:\n        return \"insufficient service\"\n\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    e = int(input_data[0])\n    service_history = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def is_tampered_odometer(service_history: list) -> bool:\n        current_km = 0\n        for year, month, km in service_history:\n            if current_km > km:\n                return True\n            current_km = km\n        return False\n\n    def is_sufficient_service(service_history: list) -> bool:\n        months = set(entry[1] for entry in service_history)\n        if len(months) < 12:\n            return False\n\n        current_km = 0\n        last_service_month = None\n        for year, month, km in service_history:\n            if last_service_month is None or last_service_month // 100 != year:\n                last_service_month = month\n                current_km = 0\n\n            current_km += km - current_km\n            if current_km > 30000:\n                return True\n\n        return False\n\n    if is_tampered_odometer(service_history):\n        return \"tampered odometer\"\n    elif is_sufficient_service(service_history):\n        return \"seems legit\"\n    else:\n        return \"insufficient service\" "
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    service_history = []\n    for i in range(1, n + 1):\n        year, month, odometer = map(int, input_data[i].split())\n        service_history.append((year, month, odometer))\n\n    # check if the odometer was tampered with\n    last_odometer = 0\n    for year, month, odometer in service_history:\n        if last_odometer > odometer:\n            return \"tampered odometer\"\n        last_odometer = odometer\n\n    # check if the car has been serviced sufficiently often\n    service_count = 0\n    last_year, last_month = service_history[0][:2]\n    for year, month, _ in service_history:\n        if year > last_year + 1 or (year == last_year and month > last_month):\n            service_count += 1\n            last_year, last_month = year, month\n\n    if service_count < 12:\n        return \"insufficient service\"\n\n    return \"seems legit\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered(history: list) -> bool:\n        prev_odometer = 0\n        for entry in history:\n            if entry[2] < prev_odometer:\n                return True\n            prev_odometer = entry[2]\n        return False\n\n    def is_service_sufficient(history: list, max_distance: int, min_service_period: int) -> bool:\n        last_service = None\n        service_distance = 0\n        for entry in history:\n            if last_service:\n                service_months = (entry[0] - last_service[0]) * 12 + (entry[1] - last_service[1])\n                if service_months >= min_service_period and service_distance >= max_distance:\n                    return True\n            service_distance += entry[2]\n            last_service = (entry[0], entry[1])\n\n        service_months = (entry[0] - history[-1][0]) * 12 + (entry[1] - history[-1][1])\n        if service_months >= min_service_period and service_distance >= max_distance:\n            return True\n\n        return False\n\n    entries = [tuple(map(int, input().split())) for _ in range(int(stdin))]\n    history = sorted(entries, key=lambda x: (x[0], x[1]))\n\n    if is_tampered(history):\n        return \"tampered odometer\"\n    elif is_service_sufficient(history, 30000, 12):\n        return \"seems legit\"\n    else:\n        return \"insufficient service\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    e, *lines = stdin.split('\\n')\n    entries = [tuple(map(int, line.split())) for line in lines]\n    \n    # Helper functions\n    def year_month_to_days(year: int, month: int) -> int:\n        days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        days_in_month_leap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            days_in_month = days_in_month_leap\n        return days_in_month[month - 1]\n    \n    def service_interval(year: int, month: int) -> int:\n        if year >= 2017:\n            return 30000\n        else:\n            return 12\n    \n    def odometer_reset(year: int, month: int) -> int:\n        if year >= 2017:\n            return 0\n        else:\n            return 100000\n    \n    # Process entries\n    first_entry = entries[0]\n    current_year = first_entry[0]\n    current_month = first_entry[1]\n    current_days = year_month_to_days(current_year, current_month)\n    current_service = 0\n    current_distance = 0\n    for year, month, odometer in entries:\n        days = year_month_to_days(year, month)\n        current_days += days\n        current_distance += odometer\n        if current_days >= service_interval(current_year, current_month):\n            current_service += 1\n            current_days -= service_interval(current_year, current_month)\n        if current_days >= 100000:\n            current_distance = 0\n            current_year = year\n            current_month = month\n            current_days = days\n    \n    # Check if odometer has been tampered with\n    if current_distance > 99999:\n        return \"tampered odometer\"\n    \n    # Check if service has been performed often enough\n    if current_service >= 3:\n        return \"seems legit\"\n    else:\n        return \"insufficient service\""
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    graph = [[] for _ in range(N)]\n\n    for i in range(1, N):\n        vertices = list(map(int, input_list[i].split()))\n        for v in vertices:\n            graph[i].append(v)\n            graph[v].append(i)\n\n    colors = [0] * N\n    num_colors = 0\n\n    def dfs(v: int) -> None:\n        nonlocal colors, num_colors\n        for neighbor in graph[v]:\n            if colors[neighbor] == colors[v]:\n                colors[neighbor] = (colors[neighbor] + 1) % num_colors + 1\n            dfs(neighbor)\n\n    for i in range(N):\n        if colors[i] == 0:\n            dfs(i)\n            num_colors = max(num_colors, colors.count(0))\n            colors = [0] * N\n\n    return num_colors\n\ninput_1 = \"4\\n1 2\\n0 2 3\\n0 1\\n1\\n\"\ninput_2 = \"5\\n2 3 4\\n2 3 4\\n0 1\\n0 1\\n0 1\\n\"\ninput_3 = \"6\\n1 3\\n0 2 4\\n1 5\\n0 4\\n1 3 5\\n2 4\\n\"\ninput_4 = \"4\\n1 2 3\\n0 2 3\\n0 1 3\\n0 1 2\\n\"\n\nprint(solution(input_1))  # Output: 3\nprint(solution(input_2))  # Output: 2\nprint(solution(input_3))  # Output: 2\nprint(solution(input_4))  # Output: 4 "
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    N = int(input_lines[0])\n    edges = [[] for _ in range(N)]\n    for i in range(1, N):\n        edge_list = list(map(int, input_lines[i].split()))\n        for j in range(len(edge_list)):\n            edges[i].append(edge_list[j])\n\n    # Compute the minimum number of colors required\n    def dfs(v: int, color: int, used_colors: set):\n        used_colors.add(color)\n        for u in edges[v]:\n            dfs(u, (color + 1) % 3, used_colors)\n\n    used_colors = set()\n    dfs(0, 0, used_colors)\n    return len(used_colors)\n"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    graph = {}\n    N = int(stdin.split(\"\\n\")[0])\n    for i in range(1, N+1):\n        graph[i] = set(map(int, stdin.split(\"\\n\")[i].split()))\n\n    def dfs(node: int, visited: set[int]) -> int:\n        visited.add(node)\n        color = 0\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                color = max(color, dfs(neighbor, visited))\n        return color + 1\n\n    max_color = 0\n    for vertex in graph:\n        visited = set()\n        max_color = max(max_color, dfs(vertex, visited))\n\n    return max_color\n"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import combinations\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    edges = [set(map(int, line.split())) for line in lines[1:]]\n    adj_list = [[] for _ in range(N)]\n    for i, edge_set in enumerate(edges):\n        for v in edge_set:\n            adj_list[v].append(i)\n\n    def dfs(graph, visited, color, node, colors):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                for c in colors:\n                    if c not in color[neighbor]:\n                        color[neighbor].add(c)\n                        if not dfs(graph, visited, color, neighbor, colors):\n                            color[neighbor].remove(c)\n                        else:\n                            break\n                else:\n                    return False\n        return True\n\n    colors = set()\n    for _ in range(N):\n        colors.add(chr(ord('A') + len(colors)))\n\n    color = [{c} for c in colors]\n    visited = [False] * N\n    for i in range(N):\n        if not visited[i]:\n            if not dfs(adj_list, visited, color, i, colors):\n                return \"Impossible\"\n\n    num_colors = len(set().union(*color))\n    return num_colors"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n = int(stdin.splitlines()[0])\n    edges = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Compute the number of colors required to color the vertices\n    def min_colors(edges: list) -> int:\n        colors = set()\n        for edge in edges:\n            for vertex in edge:\n                colors.add(vertex)\n        return len(colors)\n\n    num_colors = min_colors(edges)\n\n    return str(num_colors)"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n\n    def dfs(graph, visited, colors, vertex, color):\n        visited[vertex] = True\n        colors[vertex] = color\n        for neighbor in graph[vertex]:\n            if not visited[neighbor]:\n                for c in range(1, len(colors)+1):\n                    if c not in colors.values():\n                        dfs(graph, visited, colors, neighbor, c)\n\n    def color_graph(graph):\n        visited = defaultdict(bool)\n        colors = defaultdict(int)\n        for vertex in range(len(graph)):\n            if not visited[vertex]:\n                dfs(graph, visited, colors, vertex, 1)\n        return colors\n\n    def count_colors(colors):\n        return len(set(colors.values()))\n\n    N, *edges = stdin.splitlines()\n    N = int(N)\n    graph = [[] for _ in range(N)]\n    for edge in edges:\n        u, *v = map(int, edge.split())\n        for neighbor in v:\n            graph[u].append(neighbor)\n            graph[neighbor].append(u)\n\n    colors = color_graph(graph)\n    return count_colors(colors)\n"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited, colors):\n        visited[start] = True\n        for vertex in graph[start]:\n            if not visited[vertex]:\n                for i in range(len(colors)):\n                    if colors[i] not in used_colors:\n                        colors[start] = i\n                        used_colors.add(colors[start])\n                        colors[vertex] = i\n                        used_colors.add(colors[vertex])\n                        dfs(graph, vertex, visited, colors)\n                        colors[vertex] = -1\n                        used_colors.remove(colors[vertex])\n                        colors[start] = -1\n                        used_colors.remove(colors[start])\n                        break\n                if colors[vertex] == -1:\n                    return False\n        return True\n\n    N, *edges = stdin.split('\\n')\n    N = int(N)\n    graph = [[] for _ in range(N)]\n    for edge in edges:\n        u, *v = map(int, edge.split())\n        for vertex in v:\n            graph[u].append(vertex)\n            graph[vertex].append(u)\n    colors = [-1] * N\n    used_colors = set()\n    visited = [False] * N\n    for i in range(N):\n        if not visited[i]:\n            for j in range(N):\n                if colors[j] not in used_colors:\n                    colors[i] = j\n                    used_colors.add(colors[i])\n                    visited[i] = True\n                    dfs(graph, i, visited, colors)\n                    colors[i] = -1\n                    used_colors.remove(colors[i])\n                    break\n    return len(used_colors)\n"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, color, node, visited, vertex_count, colors):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if visited[neighbor] == False:\n                if colors[neighbor] == color:\n                    return False\n                result = dfs(graph, color, neighbor, visited, vertex_count, colors)\n                if result == False:\n                    return False\n        return True\n\n    def chromatic_number(graph, vertex_count):\n        colors = [None] * vertex_count\n        colors[0] = 0\n        for i in range(1, vertex_count):\n            colors[i] = i\n        min_colors = 1\n        while True:\n            uncolored_graph = [[] for _ in range(vertex_count)]\n            color_used = [False] * vertex_count\n            for i in range(vertex_count):\n                for j in graph[i]:\n                    uncolored_graph[i].append(colors[j])\n                    color_used[colors[j]] = True\n            used_colors = [i for i in range(vertex_count) if color_used[i] == False]\n            new_color = min(used_colors)\n            for i in range(vertex_count):\n                if colors[i] in uncolored_graph[i]:\n                    colors[i] = new_color\n            min_colors += 1\n            if not any(colors[i] == colors[j] for i in range(vertex_count) for j in graph[i]):\n                break\n        return min_colors\n\n    lines = stdin.splitlines()\n    vertex_count = int(lines[0])\n    graph = [[] for _ in range(vertex_count)]\n    for i in range(1, vertex_count):\n        for j in map(int, lines[i].split()):\n            graph[i].append(j)\n            graph[j].append(i)\n    visited = [False] * vertex_count\n    vertex_colors = [None] * vertex_count\n    vertex_colors[0] = 0\n    for i in range(1, vertex_count):\n        for j in range(vertex_count):\n            if vertex_colors[j] is not None:\n                continue\n            result = dfs(graph, i, j, visited, vertex_count, vertex_colors)\n            if result:\n                vertex_colors[j] = i\n                break\n    return chromatic_number(graph, vertex_count)"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n = int(stdin.split(\"\\n\")[0])\n    adj_list = [[] for _ in range(n)]\n    colors = [0] * n\n    \n    for i in range(1, n):\n        line = stdin.split(\"\\n\")[i]\n        neighbors = [int(x) for x in line.split()]\n        adj_list[i - 1] = neighbors\n    \n    # compute minimum number of colors\n    def dfs(u, color):\n        colors[u] = color\n        for v in adj_list[u]:\n            if colors[v] == color:\n                return False\n            if not dfs(v, (color + 1) % 2):\n                return False\n        return True\n    \n    for color in range(2):\n        for i in range(n):\n            if not dfs(i, color):\n                break\n        else:\n            break\n    \n    return colors.count(0) + 1"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    edges = [list(map(int, line.split())) for line in lines[1:]]\n    \n    # create adjacency list\n    adj = [[] for _ in range(n)]\n    for e in edges:\n        for u, v in zip(e, e[1:]):\n            adj[u].append(v)\n            adj[v].append(u)\n    \n    # color vertices using depth-first search\n    color = [-1] * n\n    stack = []\n    for v in range(n):\n        if color[v] == -1:\n            stack.append(v)\n            color[v] = 0\n            while stack:\n                u = stack.pop()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = (color[u] + 1) % 2\n                        stack.append(v)\n    \n    # count number of colors\n    color_count = len(set(color))\n    \n    return color_count"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    offers = []\n    n = int(stdin.split('\\n')[0])\n    \n    for i in range(1, n + 1):\n        c, a, b = stdin.split('\\n')[i].split()\n        offers.append((c, int(a), int(b)))\n    \n    offers.sort(key=lambda x: x[2], reverse=True)\n    \n    # Initialize a dictionary to store the sections painted by each color\n    painted_sections = {}\n    # Initialize a set to store the used colors\n    used_colors = set()\n    \n    for offer in offers:\n        c, a, b = offer\n        # If the offer uses at most 3 colors\n        if len(used_colors) < 3:\n            # If the offer is valid\n            if a <= b <= 10000:\n                # If the offer covers an unpainted section\n                if all(not any(x for x in painted_sections[y] if x >= a and x <= b) for y in painted_sections if a <= y <= b):\n                    # If the color is not already used\n                    if c not in used_colors:\n                        # Update the painted sections and used colors\n                        for i in range(a, b + 1):\n                            painted_sections[i] = painted_sections.get(i, []) + [c]\n                        used_colors.add(c)\n                        # Check if the fence is fully painted\n                        if all(any(x for x in painted_sections[y] if x <= 10000) for y in range(1, 10001)):\n                            return n\n                    else:\n                        # If the offer uses an already used color, remove it\n                        for i in range(a, b + 1):\n                            if c in painted_sections[i]:\n                                painted_sections[i].remove(c)\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    offers = []\n    n = int(stdin)\n    for _ in range(n):\n        offer = input().split()\n        color = offer[0]\n        start = int(offer[1])\n        end = int(offer[2])\n        offers.append((color, start, end))\n\n    # Helper function to count the number of colors used\n    def count_colors(offer: tuple) -> int:\n        colors = set()\n        for color, start, end in offers:\n            if start <= offer[1] <= end:\n                colors.add(color)\n        return len(colors)\n\n    # Find the minimum number of offers that need to be accepted\n    min_offers = float('inf')\n    for start in range(1, 10001):\n        end = start + 299\n        if end > 10000:\n            break\n        offer = (start, end)\n        if count_colors(offer) <= 3:\n            min_offers = min(min_offers, count_colors(offer))\n\n    # Check if the minimum number of offers can be accepted\n    for start in range(1, 10001):\n        end = start + min_offers - 1\n        if end > 10000:\n            break\n        offer = (start, end)\n        if count_colors(offer) > 3:\n            return \"IMPOSSIBLE\"\n\n    return min_offers"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_colors(offers: list) -> int:\n        colors = set()\n        for offer in offers:\n            colors.add(offer[0])\n        return len(colors)\n\n    def is_valid(offers: list) -> bool:\n        sections = set()\n        for offer in offers:\n            for i in range(offer[1], offer[2] + 1):\n                if i in sections:\n                    return False\n                sections.add(i)\n        return True\n\n    N = int(stdin.splitlines()[0])\n    offers = [line.split() for line in stdin.splitlines()[1:]]\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if count_colors([offers[i], offers[j], offers[k]]) <= 3 and is_valid([offers[i], offers[j], offers[k]]):\n                    return 3\n\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_minimum_offers(offers):\n        # Check if it's possible to paint the fence with at most 3 colors\n        colors = set(offer[0] for offer in offers)\n        if len(colors) > 3:\n            return \"IMPOSSIBLE\"\n\n        # Sort the offers by the first section number\n        offers.sort(key=lambda offer: offer[1])\n\n        # Initialize the minimum number of offers to accept\n        min_offers = 0\n        current_color = None\n        current_sections = []\n\n        for offer in offers:\n            color, start, end = offer\n\n            # If the current offer is the same color as the previous offer, merge the sections\n            if current_color == color:\n                current_sections.append((start, end))\n            # If the current offer is a different color or the first offer, start a new set of sections\n            else:\n                if current_color is not None:\n                    min_offers += 1\n                current_color = color\n                current_sections = [(start, end)]\n\n            # If the current set of sections covers all the fence sections, accept the offer\n            if start == 1 and end == 10000:\n                min_offers += 1\n                current_color = None\n                current_sections = []\n\n        # If the last offer covers all the fence sections, accept the offer\n        if current_sections and current_sections[0][0] == 1 and current_sections[0][1] == 10000:\n            min_offers += 1\n\n        return min_offers\n\n    # Read the input\n    n = int(stdin.readline())\n    offers = [tuple(line.strip().split()) for line in stdin.readlines()]\n\n    # Find the minimum number of offers that need to be accepted\n    min_offers = find_minimum_offers(offers)\n\n    return str(min_offers)"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, stdin = int(stdin.pop(0)), stdin\n    offers = []\n    for _ in range(N):\n        color, start, end = stdin.pop(0).split()\n        start, end = int(start), int(end)\n        offers.append((color, start, end))\n\n    # Sort the offers by the end of each section\n    offers.sort(key=lambda x: x[2])\n\n    # Initialize an array to keep track of the sections that have been painted\n    painted_sections = [False] * 10001\n\n    # Initialize the number of accepted offers\n    num_accepted = 0\n\n    # Loop through each offer\n    for offer in offers:\n        # Check if the color can be added without violating the color limit\n        if sum(1 for color, _, _ in offers if color == offer[0]) <= 3:\n            # Check if the sections can be painted without violating the previous offers\n            paintable_sections = [i for i in range(offer[1], offer[2] + 1) if not painted_sections[i]]\n            if len(paintable_sections) > 0:\n                # Mark the painted sections and increase the number of accepted offers\n                for section in paintable_sections:\n                    painted_sections[section] = True\n                num_accepted += 1\n\n    # Check if the fence is completely painted\n    if all(painted_sections):\n        return str(num_accepted)\n    else:\n        return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def paint(start, end, color):\n        nonlocal sections, painted\n        for i in range(start, end + 1):\n            sections[i][color - 1] = True\n            if all(sections[i]):\n                painted.add(i)\n\n    def find_painting_order():\n        nonlocal offers, sections, painted\n        min_painting_order = float('inf')\n        for i, offer in enumerate(offers):\n            color, start, end = offer\n            paint(start, end, color)\n            if len(painted) == 10000:\n                return i + 1\n            else:\n                min_painting_order = min(min_painting_order, i + 1)\n            painted.clear()\n            for j, section in enumerate(sections):\n                if all(section):\n                    painted.add(j)\n            sections = [[False] * 3 for _ in range(10001)]\n        return min_painting_order\n\n    N = int(stdin.readline())\n    offers = []\n    sections = [[False] * 3 for _ in range(10001)]\n    painted = set()\n    for _ in range(N):\n        color, start, end = stdin.readline().split()\n        offers.append((int(color), int(start), int(end)))\n\n    min_painting_order = find_painting_order()\n    return \"IMPOSSIBLE\" if min_painting_order == float('inf') else min_painting_order\n"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    offers = []\n    for i in range(int(input())):\n        color, a, b = input().split()\n        a, b = int(a), int(b)\n        offers.append((color, a, b))\n\n    colors = set(offer[0] for offer in offers)\n    if len(colors) > 3:\n        return \"IMPOSSIBLE\"\n\n    painted_sections = set()\n    for offer in offers:\n        color, a, b = offer\n        if a == 1:\n            painted_sections.add(offer)\n        else:\n            for section in painted_sections.copy():\n                if a <= section[2] + 1:\n                    painted_sections.add((section[0], section[1], max(b, section[2])))\n                    painted_sections.remove(section)\n\n    if len(painted_sections) == 10000:\n        return len(offers)\n    else:\n        return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    offers = []\n    colors = set()\n\n    n = int(stdin.splitlines()[0])\n    for i in range(1, n + 1):\n        line = stdin.splitlines()[i].split()\n        color, a, b = line[0], int(line[1]), int(line[2])\n        offers.append((color, a, b))\n        colors.add(color)\n\n    if len(colors) > 3:\n        return \"IMPOSSIBLE\"\n\n    for i in range(1, 10001):\n        for j in range(i, 10001):\n            painted = set()\n            for color, a, b in offers:\n                if a <= i <= b <= j and color not in painted:\n                    painted.add(color)\n                    if len(painted) == 3:\n                        break\n            if len(painted) == 3 and i != 1:\n                return \"IMPOSSIBLE\"\n            if len(painted) == 3 and i == 1 and j == 10000:\n                return \"IMPOSSIBLE\"\n\n    return n\n"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_painters_colors(offers: list) -> set:\n        painters_colors = set()\n        for offer in offers:\n            painters_colors.add(offer[0])\n        return painters_colors\n\n    def is_painter_offer_valid(offer: list) -> bool:\n        start, end = offer[1], offer[2]\n        if start > end:\n            return False\n        return True\n\n    def is_painting_possible(offers: list) -> bool:\n        painters_colors = get_painters_colors(offers)\n        if len(painters_colors) > 3:\n            return False\n        return True\n\n    def find_minimum_offers(offers: list) -> int:\n        min_offers = float('inf')\n        for offer in offers:\n            if is_painter_offer_valid(offer):\n                painters_colors = get_painters_colors([offer])\n                if is_painting_possible([offer]):\n                    min_offers = 1\n                    break\n                for offer2 in offers:\n                    if offer2[0] in painters_colors and offer2 != offer and is_painter_offer_valid(offer2):\n                        painters_colors.add(offer2[0])\n                        if len(painters_colors) <= 3 and is_painting_possible([offer, offer2]):\n                            min_offers = 2\n                            break\n                for offer3 in offers:\n                    if offer3[0] in painters_colors and offer3 != offer and offer3 != offer2 and is_painter_offer_valid(offer3):\n                        painters_colors.add(offer3[0])\n                        if len(painters_colors) <= 3 and is_painting_possible([offer, offer2, offer3]):\n                            min_offers = 3\n                            break\n        return min_offers\n\n    # Read the input\n    offers = []\n    for i in range(int(stdin)):\n        color, start, end = stdin.split()[i].split()\n        offers.append([color, int(start), int(end)])\n\n    # Calculate the minimum number of offers needed\n    min_offers = find_minimum_offers(offers)\n\n    # Return the result\n    if min_offers == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return str(min_offers)"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    offers = [offer.split() for offer in stdin.split(\"\\n\")[1:]]\n\n    colors = set()\n    sections = set(range(1, 10001))\n\n    for color, a, b in offers:\n        if a == b:\n            if a in sections:\n                sections.remove(a)\n            colors.add(color)\n        elif a < b:\n            if b - a <= 2:\n                for section in range(a, b + 1):\n                    if section in sections:\n                        sections.remove(section)\n                    colors.add(color)\n            else:\n                return \"IMPOSSIBLE\"\n        else:\n            return \"IMPOSSIBLE\"\n\n    if not sections:\n        return len(offers)\n    else:\n        return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def factorize(s: str) -> int:\n        max_weight = 0\n        for i in range(1, len(s) // 2 + 1):\n            if s[:i] * (len(s) // i) == s:\n                max_weight = max(max_weight, (i * (len(s) // i)) + 1)\n        return max_weight\n\n    def find_max_factoring(s: str) -> int:\n        max_weight = factorize(s)\n        return max_weight\n\n    input_string = stdin.strip()\n    max_factoring_weight = find_max_factoring(input_string)\n    return str(max_factoring_weight)\n"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def factoring(string: str) -> str:\n        factor_list = []\n        for i in range(len(string)):\n            for j in range(i + 1, len(string)):\n                if string[i:j] == string[i:j][::-1]:\n                    factor_list.append((string[i:j], len(string[i:j])))\n        factor_list.sort(key=lambda x: x[1], reverse=True)\n        return factor_list\n\n    def weight(factoring: list) -> int:\n        weight = 0\n        for factor, power in factoring:\n            weight += len(factor) + 2 + power - 1\n        return weight\n\n    stdin = stdin.upper()\n    factor_list = factoring(stdin)\n    return weight(factor_list)"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def factoring(s: str) -> str:\n        i, j = 0, 1\n        while j <= len(s):\n            if s[i:j] * (len(s) // len(s[i:j])) == s:\n                return f\"({s[i:j]})^{len(s) // len(s[i:j])}\"\n            j += 1\n        return s\n\n    def weight(factoring: str) -> int:\n        return len(factoring) - 3 - factoring.count(\"^\")\n\n    def max_factoring(s: str) -> str:\n        return max(factoring(s), key=weight)\n\n    return weight(max_factoring(stdin))\n"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Find all irreducible factorings\n    def find_factorings(s: str) -> list:\n        factorings = []\n        n = len(s)\n        for i in range(1, n):\n            if s[:i] * (n // i) == s:\n                factorings.append((s[:i], n // i))\n        return factorings\n\n    # Find a maximal factoring\n    def find_maximal_factoring(factorings: list) -> str:\n        max_factoring = \"\"\n        max_weight = float(\"inf\")\n        for f in factorings:\n            weight = sum(f) + len(f[0])\n            if weight < max_weight:\n                max_factoring = f\n                max_weight = weight\n        return max_factoring\n\n    # Compute the weight of a factoring\n    def factoring_weight(factoring: tuple) -> int:\n        return sum(factoring) + len(factoring[0])\n\n    # Parse input\n    s = stdin.strip()\n\n    # Find all irreducible factorings\n    factorings = find_factorings(s)\n\n    # Find a maximal factoring\n    max_factoring = find_maximal_factoring(factorings)\n\n    # Compute the weight of the maximal factoring\n    max_weight = factoring_weight(max_factoring)\n\n    return str(max_weight)"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_irreducible(s: str) -> bool:\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                return False\n        return True\n\n    def factor(s: str) -> str:\n        if len(s) == 1:\n            return s\n        for i in range(1, len(s)):\n            if is_irreducible(s[i:]):\n                return s[i] + \"(\" + factor(s[:i]) + \")^\" + str(len(s) // i)\n\n    factoring = factor(stdin)\n    weight = len(factoring) - factoring.count(\"(\") - factoring.count(\")\") - factoring.count(\"^\")\n    return str(weight)\n"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def factorize(s: str) -> str:\n        if len(s) <= 1:\n            return s\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                return f\"({s[:i]})^2\" + factorize(s[i:])\n        return s\n\n    def weight(s: str) -> int:\n        return len(s) if s.isdigit() else len(s) + 2\n\n    def maximal_factoring(s: str) -> str:\n        if len(s) <= 1:\n            return s\n        max_factoring = factorize(s)\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                factoring = factorize(s[i:])\n                if weight(factoring) < weight(max_factoring):\n                    max_factoring = s[:i] + factoring\n        return max_factoring\n\n    return weight(maximal_factoring(stdin))\n"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def factorize(s: str) -> str:\n        i = 0\n        while i < len(s):\n            j = i + 1\n            while j < len(s) and s[j] == s[i]:\n                j += 1\n            s = s[:i] + s[i:j] + \"(\" + s[i] + \")\" + \"^\" + str(j - i) + s[j:]\n            i = j\n        return s\n    \n    def find_max_factoring(s: str) -> str:\n        s = factorize(s)\n        m = s.find(\"(\")\n        while m != -1:\n            n = s.find(\"(\", m + 1)\n            if n == -1 or s[m + 1] <= s[n + 1]:\n                break\n            s = s[:m] + \"(\" + s[m + 2:n] + \")\" + s[n + 1:]\n            m = s.find(\"(\", m + 1)\n        return s\n    \n    def count_weight(s: str) -> int:\n        return sum(len(part) + 2 for part in s.split(\")\"))\n    \n    return count_weight(find_max_factoring(stdin))"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.upper()\n    max_weight = float('inf')\n    for i in range(1, len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = stdin[i:j]\n            factoring = f\"({substring})\"\n            weight = len(factoring)\n            if substring * (len(stdin) // len(substring)) == stdin:\n                max_weight = min(max_weight, weight)\n    return max_weight\n\ndef"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Remove spaces from the input string\n    stdin = stdin.replace(\" \", \"\")\n\n    # Find the longest common prefix among all substrings of the input string\n    lcp = \"\"\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            prefix = stdin[i:j]\n            lcp = longest_common_prefix(lcp, prefix)\n\n    # Factor the input string by removing the longest common prefix\n    stdin = stdin[len(lcp):]\n\n    # Find the weight of the maximal factoring of the input string\n    weight = float('inf')\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            factoring = (stdin[:i] + '(' + stdin[i:j] + ')' + stdin[j:])\n            weight = min(weight, len(factoring))\n\n    return str(weight)\n\n\ndef"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    import re\n\n    # Remove all non-capital letters and count the weight of the string\n    weight = len(re.sub(r'[^A-Z]', '', stdin))\n\n    # Initialize a list to store the factorings\n    factorings = []\n\n    # Find all the factorings using a regular expression\n    for match in re.finditer(r'(?=([A-Z]+))', stdin):\n        factor = match.group(1)\n        count = stdin.count(factor)\n\n        # Check if the factoring is irreducible\n        if count == 1:\n            factorings.append(factor)\n        else:\n            factorings.append(f\"({factor})^{count}\")\n\n    # Sort the factorings by length\n    factorings.sort(key=len)\n\n    # Find the weight of the maximal factoring\n    max_weight = weight\n    for factoring in factorings:\n        max_weight = min(max_weight, len(factoring))\n\n    return max_weight\n"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_operation(operation: str) -> str:\n        if operation[0] == 'D':\n            return f\"Del({operation[2:]})\"\n        elif operation[0] == 'I':\n            return f\"Ins({operation[2:]}, '{operation[4]}')\"\n        else:\n            raise ValueError(\"Invalid operation\")\n\n    programs = [[]]\n    for line in stdin.split('\\n'):\n        if line.startswith('E'):\n            programs.append([])\n        else:\n            programs[-1].append(parse_operation(line))\n\n    if programs[0] == programs[1]:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def apply_editing_program(s: str, program: list) -> str:\n        for op in program:\n            if op[0] == 'D':\n                s = s[:op[1]-1] + s[op[1]:]\n            elif op[0] == 'I':\n                s = s[:op[1]] + op[2] + s[op[1]:]\n        return s\n\n    def are_programs_identical(program1: list, program2: list) -> bool:\n        s = 'A' * 10**9\n        s1 = apply_editing_program(s, program1)\n        s2 = apply_editing_program(s, program2)\n        return s1 == s2\n\n    stdin = stdin.split('\\n')\n    program1 = []\n    program2 = []\n    for line in stdin:\n        if line[0] == 'D':\n            program1.append(('D', int(line[2:])))\n        elif line[0] == 'I':\n            program1.append(('I', int(line[2]), line[4]))\n        elif line[0] == 'E':\n            pass\n        else:\n            raise ValueError(\"Invalid operation: \" + line[0])\n\n    return '1' if are_programs_identical(program1, program2) else '0'"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    operations = []\n    for line in stdin.split('\\n'):\n        if line.startswith('E'):\n            break\n        operations.append(line)\n\n    def process_operation(operation: str, sequence: str) -> str:\n        if operation.startswith('D'):\n            pos = int(operation.split()[1])\n            return sequence[:pos - 1] + sequence[pos:]\n        elif operation.startswith('I'):\n            pos, char = map(int, operation.split()[1:])\n            return sequence[:pos] + chr(char) + sequence[pos:]\n        else:\n            raise ValueError(f'Unknown operation: {operation}')\n\n    def apply_operations(operations: List[str], sequence: str) -> str:\n        for operation in operations:\n            sequence = process_operation(operation, sequence)\n        return sequence\n\n    def compare_sequences(seq1: str, seq2: str) -> bool:\n        if len(seq1) != len(seq2):\n            return False\n        for i in range(len(seq1)):\n            if seq1[i] != seq2[i]:\n                return False\n        return True\n\n    stdin_operations = operations\n    stdin_sequence = ''\n    for operation in stdin_operations:\n        stdin_sequence = process_operation(operation, stdin_sequence)\n\n    print('Testing input...')\n    for i in range(len(stdin_operations)):\n        for j in range(i + 1, len(stdin_operations)):\n            test_operations = stdin_operations[:i] + stdin_operations[j:]\n            test_sequence = apply_operations(test_operations, stdin_sequence)\n            if not compare_sequences(stdin_sequence, test_sequence):\n                print('0')\n                return\n\n    print('0')"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def parse_operation(operation: str) -> str:\n        if operation.startswith(\"D\"):\n            return \"del\", int(operation.split()[1])\n        elif operation.startswith(\"I\"):\n            index, char = operation.split()[1:]\n            return \"ins\", int(index), char\n        else:\n            raise ValueError(\"Invalid operation\")\n\n    programs = stdin.strip().split(\"\\n\")\n    operations1 = [parse_operation(operation) for operation in programs[0].split(\"E\")]\n    operations2 = [parse_operation(operation) for operation in programs[1].split(\"E\")]\n\n    if len(operations1) != len(operations2):\n        return \"1\"\n\n    long_string = \"\"\n    for operation in operations1:\n        operation_type, index, char = operation\n        if operation_type == \"ins\":\n            long_string = long_string[:index] + char + long_string[index:]\n        elif operation_type == \"del\":\n            long_string = long_string[:index] + long_string[index + 1:]\n\n    for operation in operations2:\n        operation_type, index, char = operation\n        if operation_type == \"ins\":\n            long_string = long_string[:index] + char + long_string[index:]\n        elif operation_type == \"del\":\n            long_string = long_string[:index] + long_string[index + 1:]\n\n    if long_string == \"\":\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def apply_edit(dna: str, edit: str):\n        op, pos, *rest = edit.split()\n        pos = int(pos)\n        if op == 'D':\n            return dna[:pos - 1] + dna[pos:]\n        elif op == 'I':\n            char = rest[0]\n            return dna[:pos - 1] + char + dna[pos - 1:]\n        else:\n            raise ValueError(\"Invalid operation\")\n\n    def compare_programs(prog1: str, prog2: str) -> bool:\n        dna = ''\n        i = 0\n        while i < len(prog1) and i < len(prog2):\n            op1, op2 = prog1[i], prog2[i]\n            if op1 == op2:\n                i += 1\n                continue\n            elif op1 == 'E' or op2 == 'E':\n                i += 1\n                continue\n            elif op1 == 'D' or op2 == 'D':\n                return False\n            else:\n                try:\n                    dna = apply_edit(dna, op1)\n                    dna = apply_edit(dna, op2)\n                except ValueError:\n                    return False\n            i += 1\n        while i < len(prog1):\n            op1 = prog1[i]\n            if op1 == 'E':\n                i += 1\n                continue\n            elif op1 == 'D':\n                return False\n            else:\n                try:\n                    dna = apply_edit(dna, op1)\n                except ValueError:\n                    return False\n            i += 1\n        while i < len(prog2):\n            op2 = prog2[i]\n            if op2 == 'E':\n                i += 1\n                continue\n            elif op2 == 'D':\n                return False\n            else:\n                try:\n                    dna = apply_edit(dna, op2)\n                except ValueError:\n                    return False\n            i += 1\n        return True\n\n    progs = stdin.split('\\n')\n    prog1 = [line for line in progs if line[0] != 'E']\n    prog2 = [line for line in progs if line[0] != 'I']\n    if compare_programs(prog1, prog2):\n        return \"0\"\n    else:\n        return \"1\"\n"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def parse_operation(line: str) -> tuple:\n        op, pos = line[0], int(line[2:])\n        return (op, pos)\n\n    def apply_operation(program: list, op: tuple) -> None:\n        op_type, op_pos = op\n        if op_type == 'D':\n            program.pop(op_pos - 1)\n        elif op_type == 'I':\n            program.insert(op_pos - 1, op_pos)\n\n    def compare_programs(prog1: list, prog2: list) -> bool:\n        if len(prog1) != len(prog2):\n            return False\n        for i in range(len(prog1)):\n            if prog1[i] != prog2[i]:\n                return False\n        return True\n\n    programs = stdin.split('\\n')[:-1]\n    prog1 = []\n    prog2 = []\n    for line in programs:\n        op = parse_operation(line)\n        apply_operation(prog1, op)\n        apply_operation(prog2, op)\n\n    return '0' if compare_programs(prog1, prog2) else '1'\n"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def execute_program(program: list) -> str:\n        long_string = [chr(i) for i in range(ord('A'), ord('Z') + 1)]\n        for operation in program:\n            if operation[0] == 'D':\n                long_string.insert(int(operation[2]) - 1, '')\n            elif operation[0] == 'I':\n                long_string.insert(int(operation[2]) - 1, operation[4])\n        return ''.join(long_string)\n\n    program1 = []\n    program2 = []\n    for line in stdin.split('\\n'):\n        if line == 'E':\n            break\n        if line[0] == 'D':\n            program1.append(line)\n            program2.append(line)\n        elif line[0] == 'I':\n            program1.append(line)\n            program2.append(line)\n\n    result1 = execute_program(program1)\n    result2 = execute_program(program2)\n\n    return '1' if result1 != result2 else '0'\n\nstdin = '''D 1\nD 2\nE\nD 3\nD 1\nE\n'''\n\nprint(solution(stdin)) "
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    class LongLongString:\n        def __init__(self, s: str = \"\"):\n            self.s = s\n\n        def ins(self, p: int, c: str):\n            self.s = self.s[:p] + c + self.s[p:]\n\n        def del_(self, p: int):\n            self.s = self.s[:p] + self.s[p+1:]\n\n    def apply_program(s: LongLongString, program: str) -> LongLongString:\n        for line in program.split(\"\\n\"):\n            if line.startswith(\"D \"):\n                p = int(line[2:])\n                s.del_(p)\n            elif line.startswith(\"I \"):\n                p, c = map(int, line[2:].split(\" \"))\n                s.ins(p, chr(c))\n        return s\n\n    def compare_programs(prog1: str, prog2: str) -> bool:\n        s = LongLongString()\n        s1 = apply_program(s.copy(), prog1)\n        s2 = apply_program(s.copy(), prog2)\n        return s1.s == s2.s\n\n    progs = stdin.strip().split(\"\\nE\\n\")\n    if len(progs) == 1:\n        return \"0\"\n    for i in range(len(progs) - 1):\n        if not compare_programs(progs[i], progs[i+1]):\n            return \"1\"\n    return \"0\"\n"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def apply_operation(operations, index):\n        for op in operations:\n            if op[0] == 'D':\n                index -= 1\n            elif op[0] == 'I':\n                index += 1\n                if index < 0:\n                    index = 0\n        return index\n\n    operations1 = []\n    operations2 = []\n    stdin_lines = stdin.split(\"\\n\")\n    for line in stdin_lines:\n        if line.startswith(\"D\"):\n            operations1.append(line.strip())\n        elif line.startswith(\"I\"):\n            operations2.append(line.strip())\n        else:\n            break\n\n    if len(operations1) != len(operations2):\n        return \"1\"\n\n    index1 = 0\n    index2 = 0\n\n    for i in range(len(operations1)):\n        index1 = apply_operation(operations1[:i], index1)\n        index2 = apply_operation(operations2[:i], index2)\n        if index1 != index2:\n            return \"1\"\n\n    return \"0\""
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def process_operation(operation: str, sequence: str) -> str:\n        if operation[0] == 'D':\n            index = int(operation[2:])\n            if index > 10**10:\n                raise ValueError(\"Invalid index\")\n            return sequence[:index-1] + sequence[index:]\n        elif operation[0] == 'I':\n            index, char = operation[2:].split()\n            index = int(index)\n            if index > 10**10:\n                raise ValueError(\"Invalid index\")\n            return sequence[:index] + char + sequence[index:]\n        else:\n            raise ValueError(\"Invalid operation\")\n\n    def compare_programs(prog1: str, prog2: str) -> bool:\n        sequence = \"\"\n        for operation in prog1.splitlines():\n            sequence = process_operation(operation, sequence)\n        for operation in prog2.splitlines():\n            sequence = process_operation(operation, sequence)\n        return sequence == \"\"\n\n    operations = stdin.splitlines()\n    prog1 = \"\"\n    prog2 = \"\"\n    for operation in operations:\n        if operation == \"E\":\n            if prog1 and prog2:\n                if compare_programs(prog1, prog2):\n                    return \"0\"\n                else:\n                    return \"1\"\n            else:\n                raise ValueError(\"Invalid program\")\n        else:\n            if prog1:\n                prog1 += \"\\n\" + operation\n            else:\n                prog1 = operation\n\n    raise ValueError(\"Invalid program\")\n"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Maximum amount of Bling that can be achieved in a single day\n    def max_bling_per_day(day: int) -> int:\n        if day % 3 == 0:\n            return 3 * f\n        else:\n            return f\n\n    # Maximum amount of Bling that can be achieved in a single day, considering exotic fruit\n    def max_bling_per_day_exotic(day: int) -> int:\n        if day % 3 == 0:\n            return 3 * (f + b // 400)\n        else:\n            return f + b // 400\n\n    # Maximum amount of Bling that can be achieved in a single day, considering exotic fruit trees\n    def max_bling_per_day_exotic_trees(day: int) -> int:\n        if day % 3 == 0:\n            return 3 * (f + 3 * b // 500)\n        else:\n            return f + 3 * b // 500\n\n    # Maximum amount of Bling that can be achieved in a single day, considering exotic fruit trees and exotic fruit\n    def max_bling_per_day_exotic_trees_exotic(day: int) -> int:\n        if day % 3 == 0:\n            return 3 * (f + 3 * b // 500 + b // 400)\n        else:\n            return f + 3 * b // 500 + b // 400\n\n    if d == 1:\n        if t0 == 0 and t1 == 0 and t2 == 0:\n            return max_bling_per_day(0)\n        else:\n            return max_bling_per_day_exotic(0)\n    elif d == 2:\n        if t0 == 0 and t1 == 0 and t2 == 0:\n            return max_bling_per_day(1)\n        else:\n            return max_bling_per_day_exotic(1)\n    elif d == 3:\n        if t0 == 0 and t1 == 0 and t2 == 0:\n            return max_bling_per_day(2)\n        else:\n            return max_bling_per_day_exotic(2)\n    elif d == 4:\n        if t0 == 0 and t1 == 0 and t2 == 0:\n            return max_bling_per_day(3)\n        else:\n            return max_bling_per_day_exotic(3)\n    elif d == 5:\n        if t0 == 0 and t1 == 0 and t2 == 0:\n            return max_bling_per_day(4)\n        else:\n            return max_bling_per_day_exotic(4)\n    elif d == 6:\n        if t0 == 0 and t1 == 0 and t2 == 0:\n            return max_bling_per_day(5)\n        else:\n            return max_bling_per_day_exotic(5)\n    elif d == 7:\n        if t0 == 0 and t1 == 0 and t2 == 0:\n            return max_bling_per_day(6)\n        else:\n            return max_bling_per_day_exotic(6)\n    elif d == 8:\n        if t0 == 0 and t1 == 0 and t2 == 0:\n            return max_bling_per_day(7)\n        else:\n            return max_bling_per_day_exotic(7)\n    elif d == 9:\n        if t0 == 0 and t1 == 0 and t2 == 0:\n            return max_bling_per_day(8)\n        else:\n            return max_bling_per_day_exotic(8)\n    elif d == 10:\n        if t0 == 0 and t1 == 0 and t2 == 0:\n            return max_bling_per_day(9)\n        else:\n            return max_bling_per_day_exotic(9)\n    elif d == 11:\n        if t0 == 0"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    # Implement your solution here\n    max_bling = 0\n    if d >= 2:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 5:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 8:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 11:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 14:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 17:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 20:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 23:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 26:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 29:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 32:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 35:\n        max_bling += 100 * (f + 3 * t0 + 9 * t1)\n    if d >= 38:\n        max_bling += 500 * f\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Implement the rules of the game\n    def generate_fruits(day):\n        if day % 3 == 0:\n            return 3\n        else:\n            return 0\n\n    def can_buy_exotic_fruit(day):\n        return day % 2 == 0\n\n    def sell_fruit(b, f, price):\n        if f > 0:\n            b += f * price\n            f = 0\n        return b, f\n\n    def buy_exotic_fruit(b, f, price):\n        if b >= price and f < 100:\n            b -= price\n            f += 1\n        return b, f\n\n    def plant_tree(t):\n        if t < 100:\n            t += 1\n        return t\n\n    # Calculate the maximum Bling\n    max_bling = 0\n    for day in range(1, d+1):\n        # Generate fruits\n        new_fruits = generate_fruits(day)\n        f += new_fruits\n\n        # Buy exotic fruit (if possible)\n        if can_buy_exotic_fruit(day):\n            b, f = buy_exotic_fruit(b, f, 500)\n\n        # Sell fruits\n        b, f = sell_fruit(b, f, 100)\n\n        # Plant fruit trees\n        t0 = plant_tree(t0)\n        t1 = plant_tree(t1)\n        t2 = plant_tree(t2)\n\n        # Update max_bling\n        max_bling = max(max_bling, b)\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    \n    # Calculate the total number of fruits that can be harvested\n    total_fruits = f + 3 * t0 + 9 * t1 + 27 * t2\n    \n    # Calculate the total amount of Bling that can be earned from selling fruits\n    total_bling = 100 * total_fruits\n    \n    # If there are more than 100 fruits, the maximum achievable Bling is 1000\n    if total_fruits > 100:\n        return \"1000\"\n    else:\n        return str(total_bling)\n\ninput_data = \"4 0 1 0 0 0\"\nprint(solution(input_data)) "
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    max_bling = b + f * 100 + 3 * t0 * 100 + 3 * t1 * 100 + 3 * t2 * 100\n\n    return str(max_bling)\n"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = map(int, stdin.split())\n\n    def fruit_sell_value(days):\n        return days * 100\n\n    def exotic_fruit_sell_value(days):\n        return days * 500\n\n    def fruit_tree_yield(days):\n        return days * 3\n\n    def exotic_fruit_tree_yield(days):\n        return days * 3\n\n    def can_plant_exotic_fruit(day):\n        return day % 2 == 0\n\n    def can_buy_exotic_fruit(day):\n        return day % 40 == 0\n\n    def can_travel(day):\n        return day % 40 == 0\n\n    def can_plant(day):\n        return day % 3 == 0\n\n    def can_harvest(day):\n        return day % 3 == 0\n\n    def can_sell(day):\n        return day % 3 == 0\n\n    def can_buy_exotic_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_plant_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_harvest_fruit(day):\n        return day % 2 == 0\n\n    def can_harvest_exotic_fruit(day):\n        return day % 2 == 0\n\n    def can_sell_fruit(day):\n        return day % 2 == 0\n\n    def can_buy_exotic_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_plant_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_harvest_fruit(day):\n        return day % 2 == 0\n\n    def can_harvest_exotic_fruit(day):\n        return day % 2 == 0\n\n    def can_sell_fruit(day):\n        return day % 2 == 0\n\n    def can_buy_exotic_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_plant_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_harvest_fruit(day):\n        return day % 2 == 0\n\n    def can_harvest_exotic_fruit(day):\n        return day % 2 == 0\n\n    def can_sell_fruit(day):\n        return day % 2 == 0\n\n    def can_buy_exotic_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_plant_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_harvest_fruit(day):\n        return day % 2 == 0\n\n    def can_harvest_exotic_fruit(day):\n        return day % 2 == 0\n\n    def can_sell_fruit(day):\n        return day % 2 == 0\n\n    def can_buy_exotic_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_plant_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_harvest_fruit(day):\n        return day % 2 == 0\n\n    def can_harvest_exotic_fruit(day):\n        return day % 2 == 0\n\n    def can_sell_fruit(day):\n        return day % 2 == 0\n\n    def can_buy_exotic_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_plant_fruit_tree(day):\n        return day % 2 == 0\n\n    def can_harvest_fruit(day):\n        return day % 2 == 0\n\n    def can_harvest_exotic_fruit(day):\n        return day % 2 == 0\n\n    def can_sell_fruit(day):\n"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input line into the six integers\n    d, b, f, t_0, t_1, t_2 = map(int, stdin.split())\n\n    # Calculate the maximum amount of Bling Johan can have after playing d days\n    max_bling = b + f * 100 + 3 * t_0 * 100 + 9 * t_1 * 100 + 27 * t_2 * 100\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    \n    # Calculate the maximum amount of Bling he can achieve in the remaining time\n    max_bling = b + 3 * f + 9 * t0 + 27 * t1 + 81 * t2 + (d - 1) * 500 - d * 400\n    \n    return str(max_bling)\n"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    days, bling, fruits, tree0, tree1, tree2 = map(int, stdin.split())\n\n    def cost(f):\n        if f <= 100:\n            return 100\n        else:\n            return 500\n\n    def income(f):\n        if f <= 100:\n            return 100\n        else:\n            return 500\n\n    def yield_rate(tree):\n        if tree <= 0:\n            return 0\n        elif tree == 1:\n            return 1\n        else:\n            return 3\n\n    def max_income(f):\n        return f * income(f)\n\n    def max_cost(f):\n        return f * cost(f)\n\n    def max_fruits(bling, tree0, tree1, tree2):\n        max_f = 0\n        max_f += tree0 * yield_rate(tree0)\n        max_f += tree1 * yield_rate(tree1)\n        max_f += tree2 * yield_rate(tree2)\n        return min(max_f, bling // cost(100))\n\n    max_f = max_fruits(bling, tree0, tree1, tree2)\n    max_bling = max_income(max_f)\n\n    return str(max_bling)\n"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    if d <= 0 or b < 0 or f < 0 or t0 < 0 or t1 < 0 or t2 < 0:\n        return \"Invalid input\"\n\n    max_bling = b + 100 * f + 500 * min(t0, t1, t2)\n\n    if d >= 2:\n        max_bling += 100 * f + 500 * (min(t0, t1, t2) + 1)\n\n    if d >= 3:\n        max_bling += 100 * f + 500 * (min(t0, t1, t2) + 2)\n\n    return str(max_bling)\n"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:N*2:2]))\n    b = list(map(int, stdin.split()[3:N*2+1:2]))\n\n    def rank(i, j):\n        return max(a[i] + K, a[j] + K)\n\n    def count_ranks(ranks):\n        return len(set(ranks))\n\n    n_ranks = [0] * N\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            if rank(i, j) > rank(j, i):\n                n_ranks[i] = max(n_ranks[i], n_ranks[j] + 1)\n\n    return max(n_ranks)"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    M = 1000000000\n    min_a = min(a)\n    max_b = max(b)\n\n    # Binary search for maximum number of ranks\n    lo, hi = 1, N\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if mid * (2 * min_a + K) > (mid - 1) * max_b + K:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return lo"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.splitlines()[0].split())\n    assistants = [list(map(int, stdin.splitlines()[i].split())) for i in range(1, N + 1)]\n    \n    # Sort the assistants based on their jokes and compliments\n    assistants = sorted(assistants, key=lambda x: (x[0], -x[1]))\n    \n    # Initialize the max rank to 1\n    max_rank = 1\n    \n    # Iterate through the sorted assistants\n    for i in range(N):\n        # Check if the current assistant is better than the next N-i assistants\n        better_than_next = all(assistants[i][0] + K < assistants[j][0] or assistants[i][1] + K < assistants[j][1] for j in range(i + 1, N))\n        \n        # If the current assistant is better than all the next N-i assistants, increment the max rank\n        if better_than_next:\n            max_rank += 1\n    \n    return str(max_rank)\n"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    max_ranks = 1\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                if a[i] + K < a[j] or b[i] + K < b[j]:\n                    max_ranks += 1\n                    break\n\n    return str(max_ranks)\n\ninput_data = \"\"\"2 10\n1 12\n1 13\n\"\"\"\nprint(solution(input_data))  # Output: 2 "
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2 * N:2]))\n    b = list(map(int, stdin.split()[3:2 * N:2]))\n\n    def count_ranks(stdin: str) -> int:\n        N, K = map(int, stdin.split()[:2])\n        a = list(map(int, stdin.split()[2:2 * N:2]))\n        b = list(map(int, stdin.split()[3:2 * N:2]))\n\n        def rank(i: int) -> int:\n            return a[i] + b[i]\n\n        ranks = sorted(range(N), key=rank)\n        unique_ranks = set()\n        for i in range(N):\n            unique_ranks.add(rank(ranks[i]))\n            for j in range(i + 1, N):\n                if a[ranks[i]] + K < a[ranks[j]] or b[ranks[i]] + K < b[ranks[j]]:\n                    unique_ranks.remove(rank(ranks[j]))\n        return len(unique_ranks)\n\n    return str(max(count_ranks(stdin), count_ranks(stdin.replace(str(K), str(K - 1)))))\n"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    ai = list(map(int, input_list[1].split()))\n    bi = list(map(int, input_list[2].split()))\n\n    distinct_ranks = 1\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if ai[i] + k < ai[j] or bi[i] + k < bi[j]:\n                    distinct_ranks += 1\n                    break\n\n    return distinct_ranks"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2 * N:2]))\n    b = list(map(int, stdin.split()[3:3 * N:2]))\n    \n    def count_ranks(N: int, a: list, b: list) -> int:\n        def rank(i: int) -> int:\n            return a[i] + b[i]\n        \n        rankings = [rank(i) for i in range(N)]\n        rankings.sort()\n        distinct_ranks = 1\n        \n        for i in range(1, N):\n            if rankings[i] > rankings[i - 1] + K:\n                distinct_ranks += 1\n        \n        return distinct_ranks\n    \n    result = count_ranks(N, a, b)\n    return str(result)\n"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(a: int, b: int, n: int, k: int) -> int:\n        left, right = 0, 1\n        while left <= right:\n            mid = (left + right) // 2\n            if sum_quality(mid, n, k) >= a:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    def sum_quality(r: int, n: int, k: int) -> int:\n        return sum(a[i] + min(b[j], a[j] + k) for i in range(n) for j in range(n) if i != j) // r\n\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:N+2]))\n    b = list(map(int, stdin.split()[N+2:]))\n\n    max_rank = 0\n    for i in range(1, N + 1):\n        max_rank = max(max_rank, binary_search(i, N, N, K))\n\n    return max_rank"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:N+2]))\n    b = list(map(int, stdin.split()[N+2:]))\n\n    # Calculate the maximum number of distinct ranks\n    max_distinct_ranks = 1\n    for i in range(N):\n        for j in range(N):\n            if a[i] + K < a[j] or b[i] + K < b[j]:\n                max_distinct_ranks = max(max_distinct_ranks, j+1)\n                break\n\n    return str(max_distinct_ranks)\n"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:N+2]))\n    b = list(map(int, stdin.split()[N+2:N+2+N]))\n    \n    def rank_assistants(a, b):\n        return sorted(range(len(a)), key=lambda i: a[i] + b[i])\n    \n    sorted_assistants = rank_assistants(a, b)\n    \n    distinct_ranks = 1\n    for i in range(1, len(sorted_assistants)):\n        if a[sorted_assistants[i]] + b[sorted_assistants[i]] <= a[sorted_assistants[i-1]] + b[sorted_assistants[i-1]] + K:\n            distinct_ranks += 1\n    \n    return distinct_ranks\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def is_inside_line(x, y, x1, y1, x2, y2):\n        return (x1 <= x <= x2) or (x2 <= x <= x1)\n\n    def is_inside_circle(x, y, cx, cy, r):\n        return (cx - x) ** 2 + (cy - y) ** 2 <= r ** 2\n\n    def count_energy(lamps):\n        energy = 0\n        for lamp in lamps:\n            energy += lamp[2]\n        return energy\n\n    def shortest_line(lamps):\n        shortest_line = float('inf')\n        for i in range(len(lamps)):\n            for j in range(i + 1, len(lamps)):\n                x1, y1, e1 = lamps[i]\n                x2, y2, e2 = lamps[j]\n                if e1 * e2 == 0:\n                    continue\n\n                # Check if the line intersects any lamp\n                for k in range(len(lamps)):\n                    if k in (i, j):\n                        continue\n                    xk, yk, ek = lamps[k]\n                    if ek * (y2 - y1) == (x2 - x1):\n                        break\n                else:\n                    # Find the length of the shortest line dividing the positive and negative energy sources\n                    line_length = distance(x1, y1, x2, y2)\n                    if e1 > 0 and e2 > 0:\n                        shortest_line = min(shortest_line, line_length)\n                    elif e1 < 0 and e2 < 0:\n                        shortest_line = min(shortest_line, line_length)\n                    else:\n                        shortest_line = min(shortest_line, line_length / 2)\n\n        return shortest_line\n\n    # Read input\n    N = int(stdin)\n    lamps = []\n    for i in range(N):\n        x, y, e = map(int, stdin.split())\n        lamps.append((x, y, e))\n\n    # Check if there is a balancing line\n    if count_energy(lamps) == 0:\n        return \"IMPOSSIBLE\"\n    else:\n        return shortest_line(lamps)"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def calculate_distance(x, y, x_0, y_0, e):\n        return distance(x, y, x_0, y_0) + abs(e)\n\n    def is_positive(e):\n        return e > 0\n\n    def get_positive_and_negative_energy(lamp_coordinates):\n        positive_energy = 0\n        negative_energy = 0\n        for lamp_coordinate in lamp_coordinates:\n            x, y, e = lamp_coordinate\n            if is_positive(e):\n                positive_energy += calculate_distance(x, y, x_0, y_0, e)\n            else:\n                negative_energy += calculate_distance(x, y, x_0, y_0, e)\n        return positive_energy, negative_energy\n\n    def is_valid_line(lamp_coordinates, x_0, y_0):\n        positive_energy, negative_energy = get_positive_and_negative_energy(lamp_coordinates)\n        return abs(positive_energy - negative_energy) <= 1e-6\n\n    def get_shortest_continuous_line(lamp_coordinates):\n        min_distance = float('inf')\n        min_x, min_y = 0, 0\n        for i in range(len(lamp_coordinates)):\n            x1, y1, e1 = lamp_coordinates[i]\n            for j in range(i + 1, len(lamp_coordinates)):\n                x2, y2, e2 = lamp_coordinates[j]\n                for x_0, y_0 in [(x1 + x2) // 2, (x2 + x1 + 1) // 2]:\n                    if is_valid_line(lamp_coordinates, x_0, y_0):\n                        distance_sum = sum(calculate_distance(x, y, x_0, y_0, e) for x, y, e in lamp_coordinates)\n                        if distance_sum < min_distance:\n                            min_distance = distance_sum\n                            min_x, min_y = x_0, y_0\n        return min_distance\n\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    lamp_coordinates = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    if get_shortest_continuous_line(lamp_coordinates) == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return round(get_shortest_continuous_line(lamp_coordinates), 6)\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    N = int(input_lines[0])\n    lamps = []\n    for i in range(1, N+1):\n        x, y, e = map(int, input_lines[i].split())\n        lamps.append((x, y, e))\n\n    def min_distance(x, y, energy):\n        min_dist = float('inf')\n        for lamp in lamps:\n            if lamp[2] * energy < 0:\n                dx = abs(x - lamp[0])\n                dy = abs(y - lamp[1])\n                dist = dx + dy\n                min_dist = min(min_dist, dist)\n        return min_dist\n\n    min_dist = float('inf')\n    for lamp in lamps:\n        if lamp[2] > 0:\n            min_dist = min(min_dist, min_distance(lamp[0], lamp[1], -lamp[2]))\n        elif lamp[2] < 0:\n            min_dist = min(min_dist, min_distance(lamp[0], lamp[1], lamp[2]))\n\n    if min_dist == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return round(min_dist, 6)\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    lamps = [tuple(map(int, input_list[i+1].split())) for i in range(N)]\n    \n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n    \n    def is_inside(p, lamp):\n        return distance(p, lamp[:2]) <= 1\n    \n    def is_valid(p1, p2, e1, e2):\n        if e1 == e2:\n            return False\n        return distance(p1, p2) == abs(e1 + e2)\n    \n    def shortest_line():\n        shortest = float('inf')\n        for i in range(N):\n            for j in range(i+1, N):\n                p1, p2 = lamps[i], lamps[j]\n                if is_valid(p1, p2, p1[2], p2[2]) and is_inside(p1, p2):\n                    shortest = min(shortest, distance(p1, p2))\n        if shortest == float('inf'):\n            return \"IMPOSSIBLE\"\n        return shortest\n    \n    return shortest_line()"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    N = int(input_list[0])\n    lamps = [list(map(int, line.strip().split())) for line in input_list[1:N+1]]\n    energies = [int(line.strip().split()[-1]) for line in input_list[N+1:]]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def is_valid(lamps, energies, p, q, line_length):\n        for lamp in lamps:\n            dist = distance(p, lamp) + distance(q, lamp)\n            if dist <= line_length:\n                energy = energies[lamp[2]]\n                if energy > 0:\n                    return False\n        return True\n\n    def shortest_line(lamps, energies):\n        shortest_length = float('inf')\n        for i in range(len(lamps)):\n            for j in range(i+1, len(lamps)):\n                p, q = lamps[i], lamps[j]\n                dist = distance(p, q)\n                if dist == 0:\n                    continue\n                line_length = dist / 2\n                if is_valid(lamps, energies, p, q, line_length):\n                    shortest_length = min(shortest_length, line_length)\n        return shortest_length\n\n    shortest_length = shortest_line(lamps, energies)\n    if shortest_length == float('inf'):\n        return \"IMPOSSIBLE\"\n    return round(shortest_length, 6)"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def min_distance(lamps):\n        min_dist = float('inf')\n        for i in range(len(lamps)):\n            for j in range(i + 1, len(lamps)):\n                dist = distance(lamps[i], lamps[j])\n                if dist < min_dist:\n                    min_dist = dist\n        return min_dist\n\n    def balance_line(lamps):\n        min_x = min(lamp[0] for lamp in lamps)\n        max_x = max(lamp[0] for lamp in lamps)\n        min_y = min(lamp[1] for lamp in lamps)\n        max_y = max(lamp[1] for lamp in lamps)\n\n        for x in range(min_x, max_x + 1):\n            for y in range(min_y, max_y + 1):\n                energy = sum(lamp[2] for lamp in lamps if distance(lamp[:2], (x, y)) <= min_distance(lamps))\n                if energy < 0:\n                    continue\n                if energy == 0 and (x == min_x or x == max_x or y == min_y or y == max_y):\n                    return x, y\n        return None\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    lamps = [tuple(map(int, lines[i].split())) for i in range(1, n * 3, 3)]\n\n    min_dist = min_distance(lamps)\n    if min_dist == 0:\n        return \"IMPOSSIBLE\"\n\n    line = balance_line(lamps)\n    if line is None:\n        return \"IMPOSSIBLE\"\n\n    return round(min_dist * 2, 6)"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def count_inside(x, y, e):\n        count = 0\n        for i in range(N):\n            if x - 1 <= lamps[i][0] <= x + 1 and y - 1 <= lamps[i][1] <= y + 1:\n                count += e[i]\n        return count\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    lamps = []\n    e = []\n    for i in range(1, N + 1):\n        x, y, e_i = map(int, lines[i].split())\n        lamps.append((x, y))\n        e.append(e_i)\n\n    min_dist = float(\"inf\")\n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = distance(lamps[i][0], lamps[i][1], lamps[j][0], lamps[j][1])\n            inside_i = count_inside(lamps[i][0], lamps[i][1], e)\n            inside_j = count_inside(lamps[j][0], lamps[j][1], e)\n            if abs(inside_i + inside_j) <= 1:\n                if dist < min_dist:\n                    min_dist = dist\n\n    if min_dist == float(\"inf\"):\n        return \"IMPOSSIBLE\"\n    else:\n        return round(min_dist, 6)\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N = int(stdin.splitlines()[0])\n    lamps = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Calculate the coordinates of the room corners\n    x_min, x_max, y_min, y_max = 0, 100, 0, 100\n    for lamp in lamps:\n        x_min, x_max = min(x_min, lamp[0]), max(x_max, lamp[0])\n        y_min, y_max = min(y_min, lamp[1]), max(y_max, lamp[1])\n\n    # Initialize the energy grid\n    energy_grid = [[0 for _ in range(y_max - y_min + 1)] for _ in range(x_max - x_min + 1)]\n\n    # Calculate the energy contribution of each lamp to the energy grid\n    for lamp in lamps:\n        x, y, e = lamp[0] - x_min, lamp[1] - y_min, lamp[2]\n        if e < 0:  # Negative energy lamp\n            for i in range(x - 1, x + 2):\n                for j in range(y - 1, y + 2):\n                    if 0 <= i < x_max - x_min + 1 and 0 <= j < y_max - y_min + 1:\n                        energy_grid[i][j] += e\n        else:  # Positive energy lamp\n            energy_grid[x][y] = e\n\n    # Calculate the energy balance around each axis\n    x_balance, y_balance = 0, 0\n    for i in range(x_max - x_min + 1):\n        x_balance += energy_grid[i][y_max - y_min] - energy_grid[i][0]\n    for j in range(y_max - y_min + 1):\n        y_balance += energy_grid[x_max - x_min][j] - energy_grid[0][j]\n\n    # Check if the energy balance is zero\n    if x_balance == 0 and y_balance == 0:\n        return \"IMPOSSIBLE\"\n\n    # Calculate the length of the shortest continuous line\n    shortest_line_length = float('inf')\n    for i in range(x_min, x_max - 1):\n        for j in range(y_min, y_max - 1):\n            if energy_grid[i][j] == energy_grid[i + 1][j] and energy_grid[i][j] == energy_grid[i][j + 1] and energy_grid[i][j] == energy_grid[i + 1][j + 1]:\n                shortest_line_length = min(shortest_line_length, ((i - x_min) ** 2 + (j - y_min) ** 2) ** 0.5)\n    for i in range(x_max - 1):\n        for j in range(y_min, y_max - 1):\n            if energy_grid[i][j] == energy_grid[i + 1][j] and energy_grid[i][j] == energy_grid[i][j + 1] and energy_grid[i][j] == energy_grid[i + 1][j + 1]:\n                shortest_line_length = min(shortest_line_length, ((i - x_min + 1) ** 2 + (j - y_min) ** 2) ** 0.5)\n    for i in range(x_min, x_max - 1):\n        for j in range(y_max - 1):\n            if energy_grid[i][j] == energy_grid[i + 1][j] and energy_grid[i][j] == energy_grid[i][j + 1] and energy_grid[i][j] == energy_grid[i + 1][j + 1]:\n                shortest_line_length = min(shortest_line_length, ((i - x_min) ** 2 + (j - y_min + 1) ** 2) ** 0.5)"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_positive(x: int, y: int, lamps: List[List[int]]) -> bool:\n        for lamp in lamps:\n            if lamp[0] == x and lamp[1] == y:\n                return lamp[2] > 0\n        return False\n\n    def get_distance(x1: int, y1: int, x2: int, y2: int) -> float:\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def get_line(lamps: List[List[int]]) -> List[Tuple[int, int]]:\n        min_length = float('inf')\n        min_line = []\n        for i in range(len(lamps)):\n            for j in range(i + 1, len(lamps)):\n                x1, y1, _ = lamps[i]\n                x2, y2, _ = lamps[j]\n                if is_positive(x1, y1, lamps) == is_positive(x2, y2, lamps):\n                    length = get_distance(x1, y1, x2, y2)\n                    if length < min_length:\n                        min_length = length\n                        min_line = [(x1, y1), (x2, y2)]\n        return min_line\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    lamps = [list(map(int, line.split())) for line in input_data[1:]]\n\n    if N < 2 or N > 12:\n        return \"IMPOSSIBLE\"\n\n    line = get_line(lamps)\n    if not line:\n        return \"IMPOSSIBLE\"\n\n    x1, y1 = line[0]\n    x2, y2 = line[1]\n    length = get_distance(x1, y1, x2, y2)\n\n    return round(length, 6)\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    lamps = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    lamps_x = [lamp[0] for lamp in lamps]\n    lamps_y = [lamp[1] for lamp in lamps]\n    lamps_e = [lamp[2] for lamp in lamps]\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def get_square(x, y):\n        return [(x - 1, y - 1), (x - 1, y + 1), (x + 1, y - 1), (x + 1, y + 1)]\n\n    def is_overlap(x1, y1, x2, y2, x3, y3, x4, y4):\n        square1 = get_square(x1, y1)\n        square2 = get_square(x2, y2)\n        square3 = get_square(x3, y3)\n        square4 = get_square(x4, y4)\n        return any((x, y) in square1 for x, y in square2) or any((x, y) in square1 for x, y in square3) or any((x, y) in square1 for x, y in square4)\n\n    def is_positive_energy(x, y, energy):\n        if energy > 0:\n            return True\n        return False\n\n    def get_shortest_line(lamps_x, lamps_y, lamps_e):\n        min_length = float('inf')\n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    dist = distance(lamps_x[i], lamps_y[i], lamps_x[j], lamps_y[j])\n                    if dist < min_length:\n                        min_length = dist\n        return min_length\n\n    shortest_line = get_shortest_line(lamps_x, lamps_y, lamps_e)\n\n    if shortest_line == float('inf'):\n        return \"IMPOSSIBLE\"\n\n    return round(shortest_line, 6)"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    points = set()\n    for line in lines[1:]:\n        x0, y0, x1, y1 = map(int, line.split())\n        if x0 == x1 and y0 == y1:\n            continue\n        if x0 == x1:\n            for y in range(min(y0, y1), max(y0, y1) + 1):\n                points.add((x0, y))\n        elif y0 == y1:\n            for x in range(min(x0, x1), max(x0, x1) + 1):\n                points.add((x, y0))\n        else:\n            slope = (x1 - x0) / (y1 - y0)\n            for x in range(min(x0, x1), max(x0, x1) + 1):\n                y = y0 + (x - x0) / slope\n                points.add((x, int(y)))\n    if len(points) == float('inf'):\n        return \"-1\"\n    return str(len(points))\n\ndef"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_intersect(p1, p2, p3, p4):\n        denominator = (p2[0] - p1[0]) * (p4[1] - p3[1]) - (p2[1] - p1[1]) * (p4[0] - p3[0])\n        if denominator == 0:\n            return False\n        ua = ((p1[0] * p2[1] - p1[1] * p2[0]) * (p4[0] - p3[0]) + (p2[0] - p1[0]) * (p3[0] * p4[1] - p3[1] * p4[0])) / denominator\n        ub = ((p1[0] * p2[1] - p1[1] * p2[0]) * (p3[0] * p4[1] - p3[1] * p4[0]) + (p2[0] - p1[0]) * (p1[1] * p4[0] - p1[0] * p4[1])) / denominator\n        return 0 <= ua <= 1 and 0 <= ub <= 1\n\n    def count_intersections(lines):\n        intersections = set()\n        for i in range(len(lines)):\n            for j in range(i + 1, len(lines)):\n                if is_intersect(lines[i][:2], lines[i][2:], lines[j][:2], lines[j][2:]):\n                    intersection = tuple(sorted([lines[i][:2], lines[i][2:], lines[j][:2], lines[j][2:]]))\n                    intersections.add(intersection)\n        return len(intersections)\n\n    def process_input(lines):\n        points = set()\n        for line in lines:\n            for i in range(4):\n                points.add((line[i], line[i + 2]))\n        return len(points)\n\n    lines = [tuple(map(int, input().split())) for _ in range(int(stdin.splitlines()[0]))]\n    intersections = count_intersections(lines)\n    points = process_input(lines)\n    if points == 0 or intersections == 0:\n        return -1\n    else:\n        return intersections\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    points = set()\n    for i in range(1, n + 1):\n        x0, y0, x1, y1 = map(int, input_data[i].split())\n        points.add((x0, y0))\n        points.add((x1, y1))\n    if len(points) == n * 2:\n        return -1\n    return len(points)\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    points = set()\n\n    for i in range(1, n+1):\n        x0, y0, x1, y1 = map(int, input_data[i].split())\n        points.add((x0, y0))\n        points.add((x1, y1))\n\n    if len(points) == 2:\n        return 1\n    elif len(points) == 3:\n        return 1\n    elif len(points) == 4:\n        return 2\n    elif len(points) == 5:\n        return 3\n    elif len(points) == 6:\n        return 5\n    elif len(points) == 7:\n        return 10\n    elif len(points) == 8:\n        return 21\n    elif len(points) == 9:\n        return 35\n    elif len(points) == 10:\n        return 57\n    elif len(points) == 11:\n        return 92\n    elif len(points) == 12:\n        return 149\n    elif len(points) == 13:\n        return 241\n    elif len(points) == 14:\n        return 390\n    elif len(points) == 15:\n        return 641\n    elif len(points) == 16:\n        return 1035\n    elif len(points) == 17:\n        return 1754\n    elif len(points) == 18:\n        return 2865\n    elif len(points) == 19:\n        return 4338\n    elif len(points) == 20:\n        return 6791\n    elif len(points) == 21:\n        return 106106\n    else:\n        return -1\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    points = set()\n    for i in range(1, n + 1):\n        x0, y0, x1, y1 = map(int, input_data[i].split())\n        for j in range(i + 1, n + 1):\n            x2, y2, x3, y3 = map(int, input_data[j].split())\n            if (x0, y0, x1, y1) != (x2, y2, x3, y3) and (x0, y0) != (x1, y1):\n                if ((x0, y0) == (x2, y2) or (x0, y0) == (x3, y3) or (x1, y1) == (x2, y2) or (x1, y1) == (x3, y3)):\n                    points.add((x0, y0))\n                else:\n                    if (x0 == x2 and y0 <= max(y2, y3) and y0 >= min(y2, y3)) or (x1 == x2 and y1 <= max(y2, y3) and y1 >= min(y2, y3)):\n                        points.add((x0, y0))\n                    elif (x0 == x3 and y0 <= max(y2, y3) and y0 >= min(y2, y3)) or (x1 == x3 and y1 <= max(y2, y3) and y1 >= min(y2, y3)):\n                        points.add((x0, y0))\n                    elif (y0 == y2 and x0 <= max(x2, x3) and x0 >= min(x2, x3)) or (y1 == y2 and x1 <= max(x2, x3) and x1 >= min(x2, x3)):\n                        points.add((x0, y0))\n                    elif (y0 == y3 and x0 <= max(x2, x3) and x0 >= min(x2, x3)) or (y1 == y3 and x1 <= max(x2, x3) and x1 >= min(x2, x3)):\n                        points.add((x0, y0))\n    if len(points) == float('inf'):\n        return -1\n    else:\n        return len(points)\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def are_parallel(s1, s2):\n        return s1[0] * s2[1] == s1[1] * s2[0]\n\n    def intersect_or_touch(s1, s2):\n        s1_start, s1_end = sorted([s1[:2], s1[2:]])\n        s2_start, s2_end = sorted([s2[:2], s2[2:]])\n\n        if s1_start == s2_start or s1_end == s2_end:\n            return True\n\n        if s1_start[0] < s2_start[0] < s1_end[0] < s2_end[0] or \\\n           s2_start[0] < s1_start[0] < s2_end[0] < s1_end[0]:\n            if s1_start[1] < s2_start[1] < s1_end[1] < s2_end[1] or \\\n                   s2_start[1] < s1_start[1] < s2_end[1] < s1_end[1]:\n                return True\n\n        if s1_start[1] == s2_start[1] or s1_end[1] == s2_end[1]:\n            return True\n\n        return False\n\n    n, *lines = stdin.splitlines()\n    lines = [tuple(map(int, line.split())) for line in lines]\n    points = set()\n\n    for i in range(len(lines)):\n        for j in range(i + 1, len(lines)):\n            if intersect_or_touch(lines[i], lines[j]):\n                x = gcd(lines[i][2] - lines[i][0], lines[j][2] - lines[j][0])\n                y = gcd(lines[i][3] - lines[i][1], lines[j][3] - lines[j][1])\n                points.add((x, y))\n\n    if len(points) == float('inf'):\n        return -1\n    else:\n        return len(points)"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_touching(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        if (x1 == x2 and x3 == x4) or (y1 == y2 and y3 == y4):\n            return False\n        return ((x1 == x2 and x3 == x4 and min(y1, y2) <= y3 <= max(y1, y2) and min(y3, y4) <= y2 <= max(y3, y4)) or\n                (y1 == y2 and y3 == y4 and min(x1, x2) <= x3 <= max(x1, x2) and min(x3, x4) <= x2 <= max(x3, x4)))\n\n    def is_intersecting(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        if (x1 == x2 and x3 == x4) or (y1 == y2 and y3 == y4):\n            return False\n        d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if d == 0:\n            return False\n        t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / d\n        u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / d\n        return 0 <= t <= 1 and 0 <= u <= 1\n\n    n = int(input())\n    lines = []\n    for _ in range(n):\n        line = list(map(int, input().split()))\n        lines.append(line)\n\n    points = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_touching(lines[i], lines[j]) or is_intersecting(lines[i], lines[j]):\n                points.add(tuple(sorted((lines[i][0], lines[i][1]), (lines[j][0], lines[j][1]))))\n\n    if not points:\n        return \"1\"\n    elif len(points) == float('inf'):\n        return \"-1\"\n    else:\n        return str(len(points))\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    lines = stdin.splitlines()[1:]\n\n    points = set()\n    for line in lines:\n        x0, y0, x1, y1 = map(int, line.split())\n        # Add all points on the line segment\n        dx = x1 - x0\n        dy = y1 - y0\n        if dx != 0:\n            m = dy / dx\n            x = x0\n            y = y0\n            while x <= x1:\n                points.add((x, y))\n                x += 1\n                y = y + m\n        else:\n            y = y0\n            while y <= y1:\n                points.add((x0, y))\n                y += 1\n\n    # Count the number of distinct points that intersect or touch at least one pair of line segments\n    count = 0\n    for point in points:\n        x, y = point\n        if any(x == p[0] or y == p[1] for p in points):\n            count += 1\n\n    if count == 0:\n        return \"0\"\n    elif count == len(points) - 1:\n        return \"1\"\n    else:\n        return \"2\"\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    points = set()\n\n    for i in range(1, n + 1):\n        x0, y0, x1, y1 = [int(x) for x in input_list[i].split()]\n        points.add((x0, y0))\n        points.add((x1, y1))\n\n    if len(points) == 2:\n        return 1\n    elif len(points) == 3:\n        return 3\n    else:\n        return -1\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    lines = stdin.splitlines()[1:]\n    points = set()\n\n    for line in lines:\n        x0, y0, x1, y1 = map(int, line.split())\n        # if the lines are parallel, there is no intersection\n        if x0 == x1 or y0 == y1:\n            continue\n        # calculate the slope of the line segments\n        slope1 = (y1 - y0) / (x1 - x0)\n        slope2 = -1 / slope1\n\n        def find_intersection(slope1, slope2, x0, y0, x1, y1):\n            # find the intersection point using the formula for a line-line intersection\n            x = (x1 - x0 + slope1 * y0 - slope2 * y1) / (slope1 - slope2)\n            y = y0 + slope1 * (x - x0)\n            return x, y\n\n        # calculate the intersection point\n        x, y = find_intersection(slope1, slope2, x0, y0, x1, y1)\n        # add the intersection point to the set of distinct points\n        points.add((x, y))\n\n    # check if there are infinitely many distinct points\n    if len(points) == float('inf'):\n        return -1\n    return len(points)"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    if n < 10:\n        return -1\n    for i in range(1, n+1):\n        if is_hill_number(i):\n            count += 1\n    return count\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    hill_number = str(n)\n    hill_numbers = []\n    for i in range(len(hill_number)):\n        if i == 0 or (hill_number[i] == '2' and hill_number[i-1] < '3'):\n            count += 1\n        else:\n            break\n    if count % 2 == 0:\n        for i in range(2, len(hill_number)+1, 2):\n            if hill_number[:i].count('2') == i // 2:\n                count += 1\n            else:\n                break\n    else:\n        for i in range(2, len(hill_number)+1, 2):\n            if hill_number[:i].count('2') == (i // 2) and hill_number[i-1] < '3':\n                count += 1\n            else:\n                break\n    return str(count) if count <= n else str(-1)\n\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    if n < 10:\n        return -1\n    for i in range(n+1):\n        if hill_number(i):\n            count += 1\n    return count\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    if n < 1000000000:  # optimized for performance\n        for i in range(1, n + 1):\n            num = str(i)\n            if len(num) % 2 == 0:  # if the length is even\n                left = num[:len(num) // 2]\n                right = num[len(num) // 2:]\n                if left == right:  # if the left and right halves are equal\n                    count += 1\n            else:  # if the length is odd\n                left = num[:len(num) // 2 + 1]\n                right = num[len(num) // 2 + 1:]\n                if left == right:  # if the left and right halves are equal\n                    count += 1\n        if count == 0:\n            count = -1\n    else:\n        count = -1  # hill numbers are limited to 9 digits\n    return str(count)\n"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_numbers = 0\n    \n    if n == 1:\n        return \"1\"\n\n    for i in range(2, n+1):\n        if hill_check(i):\n            hill_numbers += 1\n\n    return str(hill_numbers)\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    \n    for num in range(1, n+1):\n        num_str = str(num)\n        prev = None\n        increasing = True\n        decreasing = False\n        \n        for digit in num_str:\n            if prev is not None and int(digit) > prev:\n                increasing = True\n            elif prev is not None and int(digit) < prev:\n                increasing = False\n                decreasing = True\n                break\n            prev = int(digit)\n        \n        if decreasing:\n            continue\n        \n        if increasing:\n            count += 1\n            \n    return count if count <= n else -1\n"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_hill_number(num: str) -> bool:\n        digits = list(num)\n        for i in range(len(digits) - 1):\n            if digits[i] > digits[i + 1]:\n                digits[i + 1] = '9'\n            elif digits[i] < digits[i + 1]:\n                digits[i] = '0'\n        return num == ''.join(digits)\n\n    n = int(stdin)\n    hill_numbers = 0\n\n    for i in range(1, n + 1):\n        if is_hill_number(str(i)):\n            hill_numbers += 1\n\n    return str(hill_numbers) if hill_numbers <= n else \"-1\"\n"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_hill_number(n: int) -> bool:\n        digits = [int(d) for d in str(n)]\n        for i in range(len(digits) - 1):\n            if digits[i] < digits[i + 1]:\n                if not all(digits[i] < digits[j] for j in range(i + 1, len(digits))):\n                    return False\n            elif digits[i] > digits[i + 1]:\n                if not all(digits[i] > digits[j] for j in range(i + 1, len(digits))):\n                    return False\n        return True\n\n    def count_hill_numbers(n: int) -> int:\n        total = 0\n        for i in range(1, n + 1):\n            if is_hill_number(i):\n                total += 1\n        return total\n\n    n = int(stdin)\n    if is_hill_number(n):\n        result = count_hill_numbers(n)\n    else:\n        result = -1\n    return str(result)\n"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_count = 0\n    digit_count = len(str(n))\n    \n    for i in range(1, n+1):\n        if hill_check(str(i)):\n            hill_count += 1\n    \n    if hill_count_check(n, digit_count, hill_count):\n        return str(hill_count)\n    else:\n        return \"-1\"\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_numbers = []\n    \n    def is_hill_number(number: int) -> bool:\n        number_str = str(number)\n        rising = True\n        for i in range(len(number_str) - 1):\n            if number_str[i] > number_str[i + 1]:\n                if not rising:\n                    return False\n                rising = False\n            if number_str[i] < number_str[i + 1]:\n                if rising:\n                    return False\n                rising = True\n        return True\n    \n    for i in range(1, n + 1):\n        if is_hill_number(i):\n            hill_numbers.append(i)\n    \n    if not hill_numbers:\n        return str(-1)\n    else:\n        return str(len(hill_numbers)) "
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    def count_sequences(a11, a12, a21, a22):\n        total = 1\n        for i in range(1, N+1):\n            total *= (a11 + a12 + a21 + a22 - i + 1)\n            total %= 1000000007\n        return total\n\n    if N == 1:\n        return count_sequences(a11, a12, a21, a22)\n\n    total = 0\n    for i in range(1, N+1):\n        total += count_sequences(a11, a12, a21, a22-i)\n        total %= 1000000007\n\n    return total\n\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    def find_attackers(A, B, C):\n        attackers = [A, B, C]\n        for i in range(len(attackers)):\n            for j in range(len(attackers)):\n                if i != j:\n                    yield (attackers[i], attackers[j])\n\n    def find_defenders(A, B, C):\n        defenders = [A, B, C]\n        for i in range(len(defenders)):\n            for j in range(len(defenders)):\n                if i != j:\n                    yield (defenders[j], defenders[i])\n\n    count = 0\n    for A, B in find_attackers(a11, a12, a21):\n        for C, D in find_defenders(a11, a12, a21):\n            if C == A or D == B:\n                continue\n            count += 1\n\n    for A, B in find_attackers(a11, a12, a21):\n        for C, D in find_defenders(a11, a12, a21):\n            if C == A or D == B:\n                continue\n            count += 1\n\n    for A, B in find_attackers(a12, a21, a22):\n        for C, D in find_defenders(a12, a21, a22):\n            if C == A or D == B:\n                continue\n            count += 1\n\n    for A, B in find_attackers(a12, a21, a22):\n        for C, D in find_defenders(a12, a21, a22):\n            if C == A or D == B:\n                continue\n            count += 1\n\n    for A, B in find_attackers(a21, a22, a11):\n        for C, D in find_defenders(a21, a22, a11):\n            if C == A or D == B:\n                continue\n            count += 1\n\n    for A, B in find_attackers(a21, a22, a11):\n        for C, D in find_defenders(a21, a22, a11):\n            if C == A or D == B:\n                continue\n            count += 1\n\n    return str(count % 1000000007)\n"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    mod = 1000000007\n\n    def count_sequences(a11, a12, a21, a22, N):\n        if N == 1:\n            return 6\n\n        a1_attack = a11 + a12\n        a1_defend = a21 + a22\n        a2_attack = a21 + a22\n        a2_defend = a11 + a12\n\n        if N % 3 == 0:\n            return count_sequences(a1_attack, a1_defend, a2_attack, a2_defend, N // 3) * 6\n        elif N % 3 == 1:\n            return count_sequences(a1_attack, a1_defend, a2_attack, a2_defend, N // 3) * 3 * 2\n        else:\n            return count_sequences(a1_attack, a1_defend, a2_attack, a2_defend, N // 3) * 2 * 3\n\n    return str(count_sequences(a11, a12, a21, a22, N) % mod)\n"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, n = map(int, stdin.split())\n    \n    def count_sequences(n: int) -> int:\n        if n == 1:\n            return a + b\n        elif n == 2:\n            return (a * b) + (b * c) + (c * d)\n        else:\n            prev_seq_count = count_sequences(n - 1)\n            current_seq_count = 0\n            for i in range(1, a + 1):\n                for j in range(1, b + 1):\n                    for k in range(1, c + 1):\n                        for l in range(1, d + 1):\n                            if (i != j and i != k and i != l) and (j != i and j != k and j != l) and (k != i and k != j and k != l) and (l != i and l != j and l != k):\n                                current_seq_count += prev_seq_count\n            return current_seq_count % 1000000007\n\n    result = count_sequences(n)\n    return str(result)\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    if N == 1:\n        return 1\n    elif N == 2:\n        return (a11 + a12 + a21 + a22) * 4\n    else:\n        mod = 1000000007\n        MOD = mod * 10**18\n        M = 10**18\n        dp = [[0] * M for _ in range(4)]\n        dp[0][0] = 1\n        for i in range(1, M):\n            for j in range(4):\n                for k in range(4):\n                    if j == k:\n                        continue\n                    dp[j][i] += dp[k][i - 1]\n                    dp[j][i] %= mod\n\n        result = sum(dp[0]) % mod\n        return result\n"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    def is_valid_move(attacker, defender):\n        if attacker == defender:\n            return False\n        if (attacker, defender) in seen:\n            return False\n        seen.add((attacker, defender))\n        return True\n\n    def count_sequences(current_move, depth):\n        if depth == N:\n            return 1\n        attackers = [i for i in range(a11 + a12 + a21 + a22) if i not in current_move]\n        result = 0\n        for attacker in attackers:\n            defenders = [i for i in range(a11 + a12 + a21 + a22) if i not in current_move and is_valid_move(attacker, i)]\n            for defender in defenders:\n                if depth < 2 or (depth == 2 and (current_move + (attacker, defender) not in seen_sequences)):\n                    result += count_sequences(current_move + (attacker, defender), depth + 1)\n        return result % MOD\n\n    seen = set()\n    seen_sequences = set()\n    MOD = 1000000007\n    a11, a12, a21, a22 = a11 + a12, a11 + a12, a21 + a22, a21 + a22\n    result = count_sequences((), 1)\n    return result % MOD\n"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    def count_moves(a11, a12, a21, a22, N):\n        def count_attack_defend(i, n, attackers, defenders):\n            if n == 1:\n                return 1\n            if n % 3 == 2:\n                return 1\n            else:\n                return count_attack_defend(i, n - 1, attackers, defenders) + count_attack_defend(i, n - 1, defenders, attackers) + count_attack_defend(i, n - 1, defenders, defenders)\n\n        return (count_attack_defend(0, N, [i for i in range(a11 + a12)], [j for j in range(a21 + a22)]) +\n                count_attack_defend(1, N, [i for i in range(a11 + a12)], [j for j in range(a21 + a22)]) +\n                count_attack_defend(2, N, [i for i in range(a11 + a12)], [j for j in range(a21 + a22)])) % 1000000007\n\n    return str(count_moves(a11, a12, a21, a22, N))"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    \n    result = 0\n    \n    def backtrack(curr_move, count):\n        nonlocal result\n        if count == N:\n            result += 1\n            return\n        \n        for i in range(1, 3):\n            for j in range(1, 3):\n                if i == j:\n                    continue\n                if (i == 1 and j == 2 and a11 > 0) or (i == 2 and j == 1 and a12 > 0) or (i == 1 and j == 2 and a21 > 0) or (i == 2 and j == 1 and a22 > 0):\n                    continue\n                \n                if count == 1:\n                    result += 1\n                elif count == 2 and i == 1:\n                    if a11 > 0:\n                        result += 1\n                elif count == 2 and i == 2:\n                    if a12 > 0:\n                        result += 1\n                elif count == 3 and i == 1:\n                    if a21 > 0:\n                        result += 1\n                elif count == 3 and i == 2:\n                    if a22 > 0:\n                        result += 1\n                \n                backtrack((i, j), count + 1)\n        \n    backtrack((1, 1), 1)\n    \n    result %= 1000000007\n    \n    return str(result)"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    mod = 1000000007\n\n    def count_sequences(a11, a12, a21, a22, N):\n        if N == 0:\n            return 1\n        if N > 1:\n            if a11 + a12 + a21 + a22 == 0:\n                return 0\n\n        # a11, a12, a21, a22 can be 0, 1, 2, or 3\n        # a11 or a12 can be 0 or 1\n        # a21 or a22 can be 0 or 2\n        # so total possibilities = 4 * 4 * 3 * 3\n        total = 4 * 4 * 3 * 3\n        total %= mod\n\n        # a11 and a12 cannot be 3, so remove those possibilities\n        total -= (3 * 3 * 2 * 2)\n        total %= mod\n\n        # a21 and a22 cannot be 1, so remove those possibilities\n        total -= (2 * 2 * 1 * 1)\n        total %= mod\n\n        # a11 and a21 cannot be 2, so remove those possibilities\n        total -= (2 * 2 * 2 * 1)\n        total %= mod\n\n        # a12 and a22 cannot be 3, so remove those possibilities\n        total -= (3 * 3 * 1 * 1)\n        total %= mod\n\n        # a11 and a12 cannot be 1 and a21 and a22 cannot be 2, so remove those possibilities\n        total -= (1 * 1 * 2 * 2)\n        total %= mod\n\n        return total\n\n    return str(count_sequences(a11, a12, a21, a22, N))\n"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, N = map(int, stdin.split())\n    return \"0\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    t = (tx, ty)\n\n    def f(phi):\n        return b * phi\n\n    def df(phi):\n        return b\n\n    def binary_search(f, t):\n        lo, hi = 0, 1\n        while lo <= hi:\n            mid = (lo + hi) / 2\n            y = f(mid)\n            if y < t[1]:\n                lo = mid + 1e-8\n            elif y > t[1]:\n                hi = mid - 1e-8\n            else:\n                return mid\n        return mid\n\n    def sign(x):\n        return 1 if x >= 0 else -1\n\n    def intersection(f, t, phi):\n        y = f(phi)\n        dx = t[0] - phi\n        dy = t[1] - y\n        if dy == 0:\n            return (phi, y)\n        slope = dx / dy\n        x_intersect = phi + (t[1] - y) * slope\n        return (x_intersect, t[1])\n\n    def angle(p1, p2):\n        return atan2(p2[1] - p1[1], p2[0] - p1[0])\n\n    def spiral_point(phi, t):\n        return (f(phi), t)\n\n    target_phi = binary_search(f, t)\n    target_point = (f(target_phi), t[1])\n\n    # Reverse the direction of the spiral before the target point\n    spiral_phi = target_phi\n    while f(spiral_phi) > t[1]:\n        spiral_phi -= df(spiral_phi) / df(target_phi) * 1e-6\n\n    # Find the point on the spiral where the avatar should leave the spiral\n    intersection_point = intersection(f, t, spiral_phi)\n\n    # Determine the direction of the spiral at the intersection point\n    direction = sign(intersection_point[0] - f(spiral_phi))\n\n    # Compute the point where the avatar should leave the spiral\n    theta = angle(target_point, intersection_point)\n    phi = atan2(intersection_point[1], intersection_point[0])\n    detached_point = (f(spiral_phi) + direction * f(spiral_phi) * cos(theta), f(spiral_phi) + direction * f(spiral_phi) * sin(theta))\n\n    # Return the $x, y$ coordinates of the point on the spiral where the avatar should leave the spiral, continue in the direction it is moving, and hit the target without intersecting the spiral\n    return f\"{detached_point[0]:.6f} {detached_point[1]:.6f}\"\n\ndef"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    b, tx, ty = map(float, input_data)\n    r = lambda theta: b * theta\n    spiral = lambda x, y: (r(np.arctan2(y, x)), np.arctan2(y, x))\n\n    # Find the closest point on the spiral to the target\n    theta = 0\n    while spiral(tx, ty) > (0, theta):\n        theta += 0.001\n    closest_spiral = spiral(tx, ty)\n\n    # Find the angle at which the avatar would need to detach\n    detach_angle = closest_spiral[1]\n\n    # Find the point on the spiral where the avatar should detach\n    detach_spiral = (r(detach_angle), detach_angle)\n\n    # Find the direction the avatar would be moving when detaching\n    detach_dir = (np.cos(detach_angle), np.sin(detach_angle))\n\n    # Calculate the point where the avatar would hit the target\n    target_spiral = (r(np.arctan2(ty, tx)), np.arctan2(ty, tx))\n    hit_spiral = (target_spiral[0], target_spiral[1] + np.sign(tx) * np.arcsin(tx / r(np.arctan2(ty, tx))))\n\n    # Check if the point where the avatar would hit the target is safe\n    if not is_safe(hit_spiral, closest_spiral, detach_spiral):\n        # If not, find the point where the avatar would need to detach to hit the target\n        while not is_safe(hit_spiral, closest_spiral, detach_spiral):\n            detach_angle -= 0.001\n            detach_spiral = (r(detach_angle), detach_angle)\n            hit_spiral = (target_spiral[0], target_spiral[1] + np.sign(tx) * np.arcsin(tx / r(np.arctan2(ty, tx))))\n\n    # Convert the result to the required format\n    hit_x, hit_y = hit_spiral\n    detach_x, detach_y = detach_spiral\n\n    return f\"{detach_x:.7f} {detach_y:.7f}\"\n\ndef"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    r = lambda theta: b * theta\n    theta = lambda x, y: np.arctan2(y, x)\n    alpha = lambda theta: theta / (2 * np.pi) * 360\n\n    def point_on_spiral(theta):\n        return r(theta) * np.array([np.cos(theta), np.sin(theta)])\n\n    def distance(x1, y1, x2, y2):\n        return np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n    def find_theta(x, y):\n        return theta(x, y)\n\n    def find_alpha(x, y):\n        theta = find_theta(x, y)\n        return alpha(theta)\n\n    def is_on_spiral(x, y):\n        theta = find_theta(x, y)\n        p = point_on_spiral(theta)\n        return distance(x, y, p[0], p[1]) < 1e-3\n\n    def find_release_angle(x, y):\n        d = distance(tx, ty, x, y)\n        theta = find_theta(tx, ty)\n        a = find_alpha(tx, ty)\n\n        while True:\n            theta += np.pi / 180\n            p = point_on_spiral(theta)\n            dp = distance(x, y, p[0], p[1])\n            ap = find_alpha(p[0], p[1])\n\n            if dp > d or np.abs(ap - a) >= 360:\n                return theta\n\n    px, py = point_on_spiral(find_release_angle(tx, ty))\n\n    return f\"{px:.5f} {py:.5f}\""
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inputs = list(map(float, stdin.split()))\n    b, tx, ty = inputs[0], inputs[1], inputs[2]\n    target = (tx, ty)\n\n    def polar_to_cartesian(r, phi):\n        return r * math.cos(phi), r * math.sin(phi)\n\n    def archimedean_spiral(t, b):\n        r = b * t\n        phi = t\n        return polar_to_cartesian(r, phi)\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def closest_point_on_spiral(x, y, b):\n        t = math.acos(x / math.sqrt(x**2 + y**2))\n        p = archimedean_spiral(t, b)\n        return p\n\n    def cross_product(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    def projection(a, b):\n        return (a[0] * b[0] + a[1] * b[1]) / (b[0]**2 + b[1]**2)\n\n    def point_on_line(p1, p2, t):\n        return p1[0] + (p2[0] - p1[0]) * t, p1[1] + (p2[1] - p1[1]) * t\n\n    def find_intersection(p1, p2, p3, p4):\n        d = cross_product(p4[0] - p3[0], p1 - p3) * cross_product(p4[0] - p3[0], p2 - p3)\n        if abs(d) < 1e-5:\n            return None\n        t = (cross_product(p1 - p3, p4[0] - p3) + cross_product(p1 - p3, p2 - p3)) / d\n        return point_on_line(p1, p2, t)\n\n    def find_angle(p1, p2):\n        return math.acos(p1[0] / math.sqrt(p1[0]**2 + p1[1]**2))\n\n    p1 = closest_point_on_spiral(tx, ty, b)\n    v1 = archimedean_spiral(0.01, b)\n    angle = find_angle(v1, (target[0] - p1[0], target[1] - p1[1]))\n    p2 = point_on_line(p1, v1, angle)\n\n    for t in numpy.arange(0.01, 360, 0.01):\n        p3 = archimedean_spiral(t, b)\n        p4 = closest_point_on_spiral(target[0], target[1], b)\n        intersection = find_intersection(p3, p4, p1, p2)\n        if intersection and distance(intersection, p3) < 1e-3:\n            return f\"{intersection[0]:.6f} {intersection[1]:.6f}\"\n\n    return \"No solution found\"\n\n\ndef"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(float, stdin.split()))\n    b, tx, ty = input_data[0], input_data[1], input_data[2]\n    t_dist = sqrt(tx**2 + ty**2)\n\n    def distance_to_point(phi):\n        r = b * phi\n        x = r * cos(phi)\n        y = r * sin(phi)\n        return sqrt((x - tx)**2 + (y - ty)**2)\n\n    def min_distance(phi, step):\n        min_dist = float('inf')\n        min_phi = phi\n        for i in range(step):\n            new_phi = phi + (i + 1) * 2 * pi / step\n            dist = distance_to_point(new_phi)\n            if dist < min_dist:\n                min_dist = dist\n                min_phi = new_phi\n        return min_phi\n\n    step = 100\n    min_phi = min_distance(0, step)\n    phi_best = min_phi\n\n    for i in range(step):\n        new_phi = min_phi + (i + 1) * 2 * pi / step\n        dist = distance_to_point(new_phi)\n        if dist < t_dist / 2:\n            phi_best = new_phi\n\n    r_best = b * phi_best\n    x_best = r_best * cos(phi_best)\n    y_best = r_best * sin(phi_best)\n\n    return f\"{x_best:.6f} {y_best:.6f}\"\n\ndef"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = list(map(float, stdin.split()))\n\n    def get_angle_at_distance(distance: float) -> float:\n        return 2 * math.pi * distance / b\n\n    def get_distance_at_angle(angle: float) -> float:\n        return b * angle\n\n    def get_coordinates_at_angle(angle: float) -> Tuple[float, float]:\n        r = get_distance_at_angle(angle)\n        x = r * math.sin(angle)\n        y = r * math.cos(angle)\n        return x, y\n\n    target_angle = math.atan2(t_y, t_x)\n    target_distance = math.sqrt(t_x ** 2 + t_y ** 2)\n\n    target_angle_distance = get_distance_at_angle(target_angle)\n    spiral_angle_distance = target_angle_distance - target_distance\n    spiral_angle = get_angle_at_distance(spiral_angle_distance)\n\n    if spiral_angle < 0:\n        spiral_angle += 2 * math.pi\n\n    avatar_angle = math.atan2(t_y, t_x) - spiral_angle\n\n    x, y = get_coordinates_at_angle(avatar_angle)\n\n    return f\"{x:.6f} {y:.6f}\""
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = [float(x) for x in stdin.split()]\n    t_x, t_y = tx, ty\n\n    def archimedean_spiral(theta):\n        return b * theta\n\n    def distance(x, y):\n        return math.sqrt(x ** 2 + y ** 2)\n\n    def is_inside_spiral(x, y):\n        theta = math.atan2(y, x)\n        r = archimedean_spiral(theta)\n        return distance(x, y) <= r\n\n    def find_theta_to_leave_spiral(x, y):\n        def f(theta):\n            r = archimedean_spiral(theta)\n            return distance(x, y) - r\n\n        # Find the largest theta such that the distance to the target is smaller than the distance to the spiral\n        left, right = 0, 2 * math.pi\n        while abs(right - left) > 1e-6:\n            mid = (left + right) / 2\n            if f(mid) < 0:\n                right = mid\n            else:\n                left = mid\n        return left\n\n    theta_leave_spiral = find_theta_to_leave_spiral(t_x, t_y)\n    x_leave_spiral, y_leave_spiral = archimedean_spiral(theta_leave_spiral), 0\n\n    # Check if the point is inside the spiral\n    while is_inside_spiral(x_leave_spiral, y_leave_spiral):\n        # Continue in the direction it is moving\n        x_leave_spiral += math.cos(theta_leave_spiral)\n        y_leave_spiral += math.sin(theta_leave_spiral)\n\n    # Return the result\n    return f\"{x_leave_spiral:.7f} {y_leave_spiral:.7f}\"\n\n\nimport math\nimport sys"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    r = b * np.pi / 180\n    theta = np.arctan2(ty, tx)\n    x = r * np.cos(theta)\n    y = r * np.sin(theta)\n    return f\"{x:.6f} {y:.6f}\"\n\nfrom math import atan2, pi\nimport numpy as np"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    b, tx, ty = map(float, stdin.split())\n    t_x, t_y = tx, ty\n    target = (t_x, t_y)\n\n    # Calculate spiral parameters\n    R = b * np.pi\n    r0 = R / 2\n    theta0 = 0\n\n    # Calculate position of spiral at theta0\n    x0, y0 = r0 * np.cos(theta0), r0 * np.sin(theta0)\n\n    # Calculate position of target on the spiral\n    theta_t = np.arctan2(t_y, t_x)\n    r_t = np.sqrt(t_x ** 2 + t_y ** 2)\n    x_t, y_t = r_t * np.cos(theta_t), r_t * np.sin(theta_t)\n\n    # Calculate angle between spiral and target\n    theta = np.arccos(np.dot([np.cos(theta0), np.sin(theta0)], [x_t - x0, y_t - y0]) / (np.sqrt((x_t - x0) ** 2 + (y_t - y0) ** 2) * np.sqrt(x0 ** 2 + y0 ** 2)))\n\n    # Calculate new theta\n    theta_new = np.pi + theta\n\n    # Calculate new position on the spiral\n    r_new = np.sqrt(R ** 2 - (R - r0) ** 2 * np.cos(theta) ** 2)\n    x_new = r_new * np.cos(theta_new)\n    y_new = r_new * np.sin(theta_new)\n\n    return f\"{x_new:.5f} {y_new:.5f}\"\n\nimport numpy as np\nimport math\nimport sys"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    b, tx, ty = map(float, inputs)\n    target = (tx, ty)\n\n    # Compute the angle at which the spiral crosses the target\n    alpha = 2 * np.pi * b * np.sqrt((tx ** 2 + ty ** 2) / (b ** 2 + b ** 2))\n\n    # Compute the point on the spiral where the avatar should leave the spiral\n    theta = np.arccos(tx / np.sqrt(tx ** 2 + ty ** 2))\n    x, y = b * theta, 0\n\n    # Determine the angle at which to release the avatar\n    phi = np.arcsin((x - tx) / np.sqrt((x - tx) ** 2 + (y - ty) ** 2))\n    if tx < 0:\n        phi = np.pi - phi\n\n    # Compute the new point on the spiral\n    x, y = b * (alpha + phi), 0\n\n    # Compute the direction of the avatar's movement\n    dx, dy = x - tx, y - ty\n\n    # Compute the angle between the new direction and the x-axis\n    if dx < 0:\n        beta = np.pi + np.arccos(abs(dy / np.sqrt(dx ** 2 + dy ** 2)))\n    else:\n        beta = np.arccos(abs(dy / np.sqrt(dx ** 2 + dy ** 2)))\n\n    # Compute the final position of the avatar\n    fx, fy = x + b * beta, y\n\n    return f\"{fx:.7f} {fy:.7f}\""
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    corridors = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n\n    def is_cycle(rooms: list, u: int, v: int) -> bool:\n        if u == v:\n            return False\n        visited = set()\n        stack = [u]\n        while stack:\n            node = stack.pop()\n            if node == v:\n                return True\n            visited.add(node)\n            for neighbor in rooms[node]:\n                if neighbor not in visited and neighbor not in stack:\n                    stack.append(neighbor)\n        return False\n\n    rooms = [[] for _ in range(n + 1)]\n    for u, v in corridors:\n        rooms[u].append(v)\n        rooms[v].append(u)\n\n    count = 0\n    for i, u in enumerate(rooms):\n        for v in u:\n            if is_cycle(rooms, i, v):\n                count += 1\n                rooms[i].remove(v)\n                rooms[v].remove(i)\n                if count == m / 2:\n                    break\n\n    return count"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v = map(int, stdin.split()[2 * i + 2: 2 * i + 4])\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * (n + 1)\n    stack = []\n    cycles = []\n\n    def dfs(node: int) -> None:\n        visited[node] = True\n        stack.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n            elif neighbor != stack[-2]:\n                cycles.append((node, neighbor))\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i)\n\n    if not cycles:\n        return \"0\\n\"\n\n    to_remove = min(m // 2, len(cycles))\n    result = sorted(cycles[:to_remove], key=lambda x: x[0])\n\n    return f\"{to_remove}\\n\" + \"\\n\".join(f\"{u} {v}\" for u, v in result) + \"\\n\"\n\ndef"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    corridors = [tuple(map(int, input_list[i+1].split())) for i in range(m)]\n\n    # Find all the paths between the rooms\n    paths = {}\n    for u, v in corridors:\n        if u not in paths:\n            paths[u] = []\n        if v not in paths:\n            paths[v] = []\n        paths[u].append(v)\n        paths[v].append(u)\n\n    # Find all the cycles in the graph\n    cycles = []\n    for u in paths:\n        visited = set()\n        stack = [u]\n        while stack:\n            v = stack[-1]\n            if v in visited:\n                if len(stack) > 1:\n                    cycle = stack[stack.index(v):]\n                    cycle.append(cycle[0])\n                    cycles.append(cycle)\n                stack.pop()\n            else:\n                visited.add(v)\n                stack.extend(paths[v])\n\n    # Calculate the number of cycles and remove the necessary corridors\n    num_cycles = len(cycles)\n    removed_corridors = []\n    if num_cycles > m//2:\n        for cycle in cycles:\n            for i in range(len(cycle)-1):\n                for j in range(i+2, len(cycle)):\n                    if (cycle[i], cycle[j]) in corridors:\n                        removed_corridors.append(corridors.index((cycle[i], cycle[j])))\n\n    return f\"{len(removed_corridors)}\\n\" + \"\\n\".join(map(str, removed_corridors))"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m = map(int, input_data[0].split())\n    corridors = [(int(u), int(v)) for u, v in map(lambda x: x.split(), input_data[1:])]\n\n    def dfs(u: int, visited: set, parent: int) -> int:\n        visited.add(u)\n        for v, room in enumerate(rooms):\n            if room == u and v != parent and v not in visited:\n                return dfs(v, visited, u) + 1\n        return 0\n\n    rooms = [corridor[1] for corridor in corridors]\n    cycles = 0\n    for i in range(n):\n        cycles += dfs(i, set(), -1)\n\n    removed_corridors = min(m // 2, cycles)\n    removed_indexes = set()\n\n    for corridor in corridors:\n        if corridor[0] == corridor[1]:\n            continue\n        if (corridor[0], corridor[1]) not in removed_indexes and (corridor[1], corridor[0]) not in removed_indexes:\n            removed_indexes.add((corridor[0], corridor[1]))\n            removed_indexes.add((corridor[1], corridor[0]))\n            removed_corridors -= 1\n            if removed_corridors == 0:\n                break\n\n    return str(len(removed_indexes)) + \"\\n\" + \"\\n\".join(map(lambda x: str(x[0]) + \" \" + str(x[1]), removed_indexes))\n"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    corridors = set()\n    visited = set()\n\n    for i in range(1, m+1):\n        u, v = map(int, input_data[i].split())\n        corridors.add((u, v))\n\n    def dfs(start, end, path=None):\n        if path is None:\n            path = []\n        if start == end:\n            return path\n        path.append(start)\n        visited.add(start)\n        for neighbor in corridors:\n            if neighbor[0] == start and neighbor[1] not in visited:\n                path_copy = path.copy()\n                dfs(neighbor[1], end, path_copy)\n                if path_copy[-1] == end:\n                    return path_copy\n        return None\n\n    cycles = 0\n    removed_corridors = []\n    for room in range(1, n+1):\n        cycle = dfs(room, room)\n        if cycle:\n            cycles += 1\n            removed_corridors.append(cycle[0])\n            if len(removed_corridors) >= m//2:\n                break\n\n    return str(cycles) + '\\n' + '\\n'.join(map(str, removed_corridors)) + '\\n'"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m = map(int, stdin.split()[:2])\n    corridors = []\n    for _ in range(m):\n        u, v = map(int, stdin.split()[2:4])\n        corridors.append((u-1, v-1))\n\n    # Build the adjacency matrix\n    adj = [[] for _ in range(n)]\n    for u, v in corridors:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Run BFS to find cycles\n    visited = [False] * n\n    cycle_count = 0\n    for i in range(n):\n        if not visited[i]:\n            queue = [i]\n            visited[i] = True\n            while queue:\n                u = queue.pop(0)\n                for v in adj[u]:\n                    if not visited[v]:\n                        queue.append(v)\n                        visited[v] = True\n                    elif v != u:\n                        cycle_count += 1\n\n    # Calculate the number of corridors to remove\n    if cycle_count <= m / 2:\n        return \"0\\n\" + \"\\n\".join(map(str, range(cycle_count, m)))\n    else:\n        return str((m + cycle_count) // 2) + \"\\n\" + \"\\n\".join(map(str, range(cycle_count)))"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.splitlines()\n    n, m = map(int, input_str[0].split())\n    corridors = [tuple(map(int, line.split())) for line in input_str[1:]]\n    \n    # Build the graph using adjacency list\n    graph = [[] for _ in range(n+1)]\n    for u, v in corridors:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # BFS to find cycles\n    visited = [False] * (n+1)\n    cycle_found = False\n    for i in range(1, n+1):\n        if visited[i]:\n            continue\n        queue = [i]\n        visited[i] = True\n        while queue:\n            current = queue.pop(0)\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n                elif neighbor != current:\n                    cycle_found = True\n                    break\n            if cycle_found:\n                break\n\n    # If a cycle is found, find the shortest cycle\n    if cycle_found:\n        # Calculate the distance to each vertex from the starting vertex\n        dist = [float('inf')] * (n+1)\n        dist[1] = 0\n        queue = [1]\n        while queue:\n            current = queue.pop(0)\n            for neighbor in graph[current]:\n                if dist[neighbor] == float('inf'):\n                    dist[neighbor] = dist[current] + 1\n                    queue.append(neighbor)\n\n        # Find the shortest cycle\n        min_len = float('inf')\n        min_cycle = None\n        for u, v in corridors:\n            if dist[u] + dist[v] + 2 == float('inf'):\n                continue\n            cycle_len = dist[u] + dist[v] + 2\n            if cycle_len < min_len:\n                min_len = cycle_len\n                min_cycle = (u, v)\n\n        # Remove the corridors that form the shortest cycle\n        corridors_to_remove = []\n        for u, v in corridors:\n            if u == min_cycle[0] and v == min_cycle[1]:\n                corridors_to_remove.append((u, v))\n\n        # Calculate the remaining number of corridors to be removed\n        r = min(m-len(corridors_to_remove), len(corridors_to_remove))\n    else:\n        # If no cycle is found, remove at most half of the corridors\n        r = min(m//2, n-1)\n        corridors_to_remove = corridors[:r]\n\n    # Output the result\n    output = str(r) + '\\n'\n    for u, v in corridors_to_remove:\n        output += str(u) + ' ' + str(v) + '\\n'\n\n    return output"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip().split('\\n')\n    n, m = map(int, input_str[0].split())\n    corridors = [tuple(map(int, line.split())) for line in input_str[1:]]\n\n    # Create adjacency list\n    adj_list = {i + 1: set() for i in range(n)}\n    for u, v in corridors:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    # Perform depth-first search to find cycles\n    visited = [False] * (n + 1)\n    stack = [1]\n    cycle = []\n\n    while stack:\n        u = stack[-1]\n        if not visited[u]:\n            visited[u] = True\n            stack.append(u)\n            continue\n\n        # If u is visited and on the stack, u is part of a cycle\n        if u in stack:\n            cycle.append(u)\n            stack.remove(u)\n\n        # If u is not on the stack, continue the search\n        else:\n            for v in adj_list[u]:\n                stack.append(v)\n\n    # Remove at most half of the corridors\n    removed = min(len(cycle) // 2, m // 2)\n    result = [i + 1 for i in range(m) if i not in cycle[:removed]]\n\n    output_str = f'{removed}\\n' + '\\n'.join(map(str, result))\n    return output_str"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    corridors = [tuple(map(int, input_list[i+1].split())) for i in range(m)]\n    corridors.sort(key=lambda x: x[0])\n\n    def bfs(start, visited, adj_list):\n        queue = [(start, 0)]\n        visited[start] = True\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, dist+1))\n        return visited\n\n    adj_list = [set() for _ in range(n+1)]\n    for u, v in corridors:\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n\n    visited = [False] * (n+1)\n    bfs(1, visited, adj_list)\n\n    if all(visited):\n        return \"0\\n\"\n\n    removed = 0\n    for i in range(m):\n        if not visited[corridors[i][0]]:\n            removed += 1\n            if removed > m/2:\n                return f\"{m/2}\\n\"\n\n    return f\"{removed}\\n\" + \"\\n\".join([str(i+1) for i in range(m-removed, m)]) + \"\\n\"\n"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    rooms, corridors = map(int, input_list[0].split())\n    corridors_dict = {}\n\n    for i in range(1, len(input_list), 2):\n        u, v = map(int, input_list[i].split())\n        corridors_dict[(u, v)] = True\n\n    def bfs(start, end):\n        visited = {start}\n        queue = [(start, [])]\n        while queue:\n            node, path = queue.pop(0)\n            if node == end:\n                return path\n            for neighbor in corridors_dict.keys():\n                if neighbor[0] == node and neighbor not in visited:\n                    queue.append((neighbor[1], path + [neighbor]))\n                    visited.add(neighbor)\n        return None\n\n    cycles = 0\n    for i in range(1, rooms + 1):\n        for j in range(1, rooms + 1):\n            if i != j:\n                path = bfs(i, j)\n                if path is not None:\n                    cycles += len(path)\n\n    max_corridors_to_remove = min(corridors // 2, cycles)\n    corridors_to_remove = []\n    for i in range(1, rooms + 1):\n        for j in range(1, rooms + 1):\n            if i != j and (i, j) in corridors_dict:\n                corridors_dict[(i, j)] = False\n                path = bfs(i, j)\n                if path is None:\n                    corridors_to_remove.append((i, j))\n                    max_corridors_to_remove -= 1\n                    if max_corridors_to_remove == 0:\n                        break\n                corridors_dict[(i, j)] = True\n        if max_corridors_to_remove == 0:\n            break\n\n    output = str(len(corridors_to_remove)) + '\\n'\n    for corridor in corridors_to_remove:\n        output += str(corridor[0]) + ' ' + str(corridor[1]) + '\\n'\n\n    return output"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def heuristic(ball, goal, time, memo, visited, current_time):\n        if ball == goal:\n            return current_time\n        if memo[ball] is not None:\n            return memo[ball]\n        if ball in visited:\n            return float('inf')\n        visited.add(ball)\n        memo[ball] = float('inf')\n        for tube in tubes[ball]:\n            next_ball = tube[0]\n            next_time = current_time + tube[1]\n            if next_time >= time:\n                continue\n            next_heuristic = heuristic(next_ball, goal, time, memo, visited, next_time)\n            if next_heuristic < memo[ball]:\n                memo[ball] = next_heuristic\n        visited.remove(ball)\n        return memo[ball]\n\n    def relax(u, v, time):\n        if not visited[v] and dist[u] + graph[u][v] < dist[v]:\n            dist[v] = dist[u] + graph[u][v]\n            if time[v] <= end_time:\n                if time[v] < end_time:\n                    end_time = time[v]\n                    relax_end_ball = v\n            queue.put(v)\n            visited[v] = True\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [[] for _ in range(n)]\n    graph = [{} for _ in range(n)]\n    time = [float('inf')] * n\n    memo = [None] * n\n    visited = set()\n    queue = queue.Queue()\n    queue.put(s)\n    visited.add(s)\n    time[s] = 0\n    for _ in range(m):\n        a, b, w = map(int, stdin.split()[4:7])\n        tubes[a].append((b, w))\n        graph[a][b] = w\n    end_time = time[t]\n    relax_end_ball = t\n    while not queue.empty():\n        ball = queue.get()\n        if time[ball] > end_time:\n            continue\n        if ball == relax_end_ball:\n            return end_time\n        for next_ball, w in tubes[ball]:\n            relax(ball, next_ball, time)\n    return 'infinity'\n\nstdin = \"\"\"\n4 5 0 3\n0 1 1\n1 2 2\n2 0 4\n2 3 1\n2 3 3\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n5 5 0 4\n0 1 1\n1 2 1\n2 3 1\n3 0 1\n2 4 1\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n2 1 0 1\n0 1 2\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n3 3 1 2\n0 1 1\n1 0 1\n1 2 1\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    tubes = []\n\n    for _ in range(m):\n        start, end, time = map(int, input().split())\n        tubes.append((start, end, time))\n\n    def traverse(start, end, tubes, visited):\n        if start == end:\n            return visited + 1\n\n        visited += 1\n        for tube in tubes:\n            if tube[0] == start and tube[1] not in visited:\n                visited = traverse(tube[1], end, tubes, visited)\n\n                if visited is not None:\n                    return visited\n\n        return None\n\n    time = traverse(s, t, tubes, [])\n    return \"infinity\" if time is None else time\n"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, s, t = map(int, input_data[0].split())\n    tubes = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def bfs(start, end, tubes, time):\n        visited = set()\n        queue = [(start, time, time)]\n        while queue:\n            node, node_time, total_time = queue.pop(0)\n            if node == end:\n                return total_time\n            if node not in visited:\n                visited.add(node)\n                for a, b, w in tubes:\n                    if a == node:\n                        queue.append((b, node_time + w, total_time + node_time + w))\n        return -1\n\n    left_time = bfs(s, t, tubes, 0)\n    right_time = bfs(t, s, tubes, 0)\n    if left_time == -1 or right_time == -1:\n        return \"infinity\"\n    else:\n        return left_time + right_time"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, s, t = map(int, input_data[0].split())\n    tubes = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def dfs(current_ball: int, time_spent: int, left_hemisphere_turn: bool):\n        if current_ball == t:\n            return time_spent\n        if current_ball in visited:\n            return float('inf') if left_hemisphere_turn else -float('inf')\n        visited.add(current_ball)\n\n        if left_hemisphere_turn:\n            left_turn_tubes = [(a, b) for a, b, w in tubes if a == current_ball]\n            for a, b in left_turn_tubes:\n                result = dfs(b, time_spent + w, not left_hemisphere_turn)\n                if result != float('inf'):\n                    return result\n        else:\n            right_turn_tubes = [(a, b) for a, b, w in tubes if b == current_ball]\n            for a, b in right_turn_tubes:\n                result = dfs(a, time_spent + w, not left_hemisphere_turn)\n                if result != -float('inf'):\n                    return result\n        return float('inf') if left_hemisphere_turn else -float('inf')\n\n    visited = set()\n    result = dfs(s, 0, True)\n    if result == float('inf'):\n        return \"infinity\"\n    return result"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, s, t = map(int, input_list[0].split())\n    tubes = [tuple(map(int, line.split())) for line in input_list[1:]]\n\n    # Create a graph using the tubes\n    graph = {i: [] for i in range(n)}\n    for a, b, w in tubes:\n        graph[a].append((b, w))\n\n    # Find the shortest path from s to t using Dijkstra's algorithm\n    dist = [float('inf')] * n\n    dist[s] = 0\n    visited = set()\n    queue = [(0, s)]\n    while queue:\n        d, u = heapq.heappop(queue)\n        if u in visited:\n            continue\n        visited.add(u)\n        if u == t:\n            return d\n        for v, w in graph[u]:\n            if v not in visited:\n                d_new = d + w\n                if d_new < dist[v]:\n                    dist[v] = d_new\n                    heapq.heappush(queue, (dist[v], v))\n\n    return \"infinity\"\n"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, s, t = map(int, input_list[0].split())\n    tubes = [tuple(map(int, input_list[i].split())) for i in range(1, m+1)]\n    \n    # Initialize the time it takes to reach each ball\n    time_to_reach = [float('inf')] * (n+1)\n    time_to_reach[s] = 0\n    \n    # DP: Update the time_to_reach array for each ball\n    for i in range(m):\n        a, b, w = tubes[i]\n        time_to_reach[b] = min(time_to_reach[b], time_to_reach[a] + w)\n    \n    # Check if there's a path from s to t\n    if time_to_reach[t] == float('inf'):\n        return \"infinity\"\n    else:\n        return time_to_reach[t]\n"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n\n    def dfs(start, time, visited):\n        if start == t:\n            return time\n        if start in visited:\n            return float('inf')\n        visited.add(start)\n        min_time = float('inf')\n        for a, b, w in tubes:\n            if a == start:\n                min_time = min(min_time, dfs(b, time + w, visited.copy()))\n        return min_time\n\n    return \"infinity\" if dfs(s, 0, set()) == float('inf') else dfs(s, 0, set())"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_time(balls: int, tubes: int, source: int, target: int) -> int:\n        tubes = [tuple(map(int, line.strip().split())) for line in stdin.split('\\n')[1:]]\n        tubes.sort(key=lambda x: x[2], reverse=True)\n        visited = [False] * balls\n        visited[source] = True\n        max_time = 0\n        while not visited[target]:\n            for i in range(balls):\n                if visited[i]:\n                    continue\n                for tube in tubes:\n                    if tube[0] == i and visited[tube[1]]:\n                        max_time = max(max_time, tube[2])\n            visited[i] = True\n        return max_time\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    if s == t:\n        return 0\n    if m == 0:\n        return \"infinity\"\n    time_left = get_max_time(n, m, s, t)\n    time_right = get_max_time(n, m, t, s)\n    if time_left == 0 or time_right == 0:\n        return \"infinity\"\n    return time_left + time_right"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    n, m, s, t = map(int, inputs[0].split())\n    tubes = [tuple(map(int, inputs[i+1].split())) for i in range(m)]\n\n    def dfs(ball, time, visited):\n        if ball in visited or time > 10000:\n            return float(\"inf\")\n        if ball == t:\n            return time\n        visited.add(ball)\n        min_time = float(\"inf\")\n        for a, b, w in tubes:\n            if a == ball:\n                min_time = min(min_time, dfs(b, time + w, visited))\n        return min_time\n\n    return \"infinity\" if dfs(s, 0, set()) == float(\"inf\") else dfs(s, 0, set())\n"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, s, t = map(int, input_data[0].split())\n    tubes = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    # Helper function to find the ball reachable from start in given time\n    def reachable_in_time(start: int, time: int) -> int:\n        visited = [False] * n\n        queue = [start]\n        visited[start] = True\n        while queue:\n            current = queue.pop(0)\n            for a, b, w in tubes:\n                if a == current and w <= time and not visited[b]:\n                    queue.append(b)\n                    visited[b] = True\n        return visited[t]\n\n    # Check if there is a path from start to bed\n    if reachable_in_time(s, 0):\n        time = 0\n        # Alternate left and right hemispheres\n        for _ in range(n):\n            time += 1\n            if not reachable_in_time(s, time):\n                time -= 1\n                break\n        return time if time != n else 'infinity'\n    else:\n        return 'infinity'"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0].split()[0])\n    colors_count = [int(x) for x in input_list[0].split()[1:]]\n    no_next_to_colors = [int(x) for x in input_list[1].split()[1:]]\n    favorite_sequence = [int(x) for x in input_list[2].split()[1:]]\n\n    def count_permutations(colors_count: list, no_next_to_colors: list, favorite_sequence: list) -> int:\n        def is_valid_permutation(colors_count: list, no_next_to_colors: list, favorite_sequence: list) -> bool:\n            for i in range(len(no_next_to_colors)):\n                if no_next_to_colors[i] in colors_count:\n                    if i == 0 and colors_count.count(no_next_to_colors[i]) > 1:\n                        return False\n                    if i != 0 and colors_count[i - 1] != no_next_to_colors[i] and colors_count.count(no_next_to_colors[i]) > 1:\n                        return False\n            for color in favorite_sequence:\n                if colors_count.count(color) < favorite_sequence.count(color):\n                    return False\n            return True\n\n        def generate_permutations(colors_count: list, no_next_to_colors: list, favorite_sequence: list, current_permutation: list, result: list) -> None:\n            if len(current_permutation) == len(colors_count):\n                result.append(current_permutation.copy())\n                return\n            for i in range(len(colors_count)):\n                if colors_count[i] > 0 and (current_permutation == [] or current_permutation[-1] != no_next_to_colors[i - 1]):\n                    current_permutation.append(colors_count[i])\n                    colors_count[i] -= 1\n                    if is_valid_permutation(colors_count, no_next_to_colors, favorite_sequence):\n                        generate_permutations(colors_count, no_next_to_colors, favorite_sequence, current_permutation, result)\n                    current_permutation.pop()\n                    colors_count[i] += 1\n\n        result = []\n        generate_permutations(colors_count, no_next_to_colors, favorite_sequence, [], result)\n        return len(result)\n\n    return str(count_permutations(colors_count, no_next_to_colors, favorite_sequence) % 1000000007)\n\nprint(solution(input())) "
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(n: int, colors: list, not_allowed: list, favorite: list) -> int:\n        if not colors:\n            return 1\n        total = 0\n        for i in range(n):\n            if i not in not_allowed:\n                if colors[0] in favorite:\n                    total += count_ways(n, colors[1:], not_allowed, favorite)\n                else:\n                    total += count_ways(n, colors[1:], not_allowed + [i], favorite)\n        return total % MOD\n\n    # Read input\n    lines = stdin.split('\\n')\n    n, k, l = map(int, lines[0].split())\n    colors = list(map(int, lines[1].split()))\n    not_allowed = list(map(int, lines[2].split()))\n    favorite = list(map(int, lines[3].split()))\n\n    MOD = 1000000007\n    return count_ways(n, colors, not_allowed, favorite)\n"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, input().split())\n    if k > n or l > n:\n        return \"0\"\n    c = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    c.sort()\n    s.sort()\n    if len(set(c)) != k:\n        return \"0\"\n    if len(set(s)) != l:\n        return \"0\"\n    if not all(c[i] < c[i+1] for i in range(k-1)):\n        return \"0\"\n    if not all(s[i] < s[i+1] for i in range(l-1)):\n        return \"0\"\n    dp = [[[0] * 2 for _ in range(n+1)] for _ in range(n+1)]\n    for i in range(n+1):\n        dp[i][0][0] = 1\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if j in c:\n                dp[i][j][1] = dp[i-1][j][1]\n            else:\n                dp[i][j][1] = dp[i-1][j][1] + dp[i-1][j-1][1]\n            if j in s:\n                dp[i][j][0] = dp[i-1][j][0]\n            else:\n                dp[i][j][0] = dp[i-1][j][0] + dp[i-1][j-1][0]\n    result = (dp[n][n][0] + dp[n][n][1]) % 1000000007\n    return str(result)\n"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(balls, index, last, sequence, used, memo):\n        if index == len(balls):\n            return 1\n        if used in memo:\n            return memo[used]\n        result = 0\n        for i in range(len(sequence)):\n            if sequence[i] in balls and balls[sequence[i]] > 0 and (last == -1 or balls[i] != last):\n                balls[i] -= 1\n                result += dfs(balls, index + 1, i, sequence, used + str(i), memo)\n                balls[i] += 1\n        memo[used] = result % MOD\n        return result % MOD\n\n    def check(balls, sequence):\n        for i in range(len(sequence)):\n            if sequence[i] in balls and balls[sequence[i]] > 0:\n                return True\n        return False\n\n    n, k = map(int, input().split())\n    balls = list(map(int, input().split()))\n    forbidden = set(map(int, input().split())[1:])\n    sequence = list(map(int, input().split())[1:])\n    MOD = 1000000007\n    memo = {}\n\n    result = 0\n    for i in range(1, len(balls) + 1):\n        if check(balls[:i], sequence):\n            result += dfs(balls, 1, -1, sequence, str(i), {})\n            result %= MOD\n    return result\n"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0].split()[0])\n    balls_colors = list(map(int, input_list[0].split()[1:]))\n    forbidden_colors = list(map(int, input_list[1].split()[1:]))\n    favorite_sequence = list(map(int, input_list[2].split()[1:]))\n\n    def count_permutations(balls_colors, forbidden_colors, favorite_sequence):\n        if len(favorite_sequence) == 0:\n            return 1\n        if len(favorite_sequence) > len(balls_colors):\n            return 0\n\n        counts = [0] * n\n        for ball_color in balls_colors:\n            if ball_color in favorite_sequence:\n                counts[ball_color - 1] += 1\n\n        result = 1\n        for count in counts:\n            if count == 0:\n                return 0\n            result *= count\n\n        for forbidden_color in forbidden_colors:\n            if forbidden_color in favorite_sequence:\n                return 0\n\n        return result\n\n    return str(count_permutations(balls_colors, forbidden_colors, favorite_sequence) % 1000000007)\n"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    colors = list(map(int, input_list[1].split()))\n    not_next_colors = list(map(int, input_list[2].split()))\n    fav_sequence = list(map(int, input_list[3].split()))\n\n    def count_combinations(colors, not_next_colors, fav_sequence):\n        def count_combinations_helper(colors, not_next_colors, fav_sequence, index):\n            if index == len(fav_sequence):\n                return 1\n            count = 0\n            for color in colors:\n                if color in not_next_colors:\n                    continue\n                if color == fav_sequence[index]:\n                    count += count_combinations_helper(colors, not_next_colors, fav_sequence, index + 1)\n                else:\n                    count += count_combinations_helper(colors, not_next_colors, fav_sequence, index)\n            return count % (1000000007)\n        return count_combinations_helper(colors, not_next_colors, fav_sequence, 0)\n\n    return str(count_combinations(colors, not_next_colors, fav_sequence))\n"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import permutations\n\n    input_list = stdin.split(\"\\n\")\n    n, k, l = map(int, input_list[0].split())\n    c_list = list(map(int, input_list[1].split()))\n    s_list = list(map(int, input_list[2].split()))\n\n    def is_valid(perm):\n        for i in range(1, len(perm)):\n            if perm[i] in c_list:\n                if i - 1 in c_list and perm[i - 1] in s_list:\n                    return False\n                if i + 1 in c_list and perm[i + 1] in s_list:\n                    return False\n        return True\n\n    def count_arrangements(perm):\n        count = 0\n        for i in range(len(perm)):\n            if perm[i] in s_list:\n                count += 1\n                break\n        return count\n\n    valid_permutations = [perm for perm in permutations(range(1, n + 1)) if is_valid(perm)]\n    arrangements = [count_arrangements(perm) for perm in valid_permutations]\n    result = sum(arrangements) % 1000000007\n\n    return str(result)"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, red, yellow, green, blue = map(int, input_list[0].split())\n    k, *c = map(int, input_list[1].split())\n    l, *s = map(int, input_list[2].split())\n\n    def count_ways(colors, forbidden_colors, seq_len, seq_colors):\n        if not colors or not seq_colors:\n            return 0\n\n        count = 0\n        seq_count = 0\n        for i, color in enumerate(colors):\n            if color in forbidden_colors:\n                continue\n\n            if color in seq_colors:\n                seq_count += 1\n                if seq_count == seq_len:\n                    count += 1\n            else:\n                count += count_ways(colors[i+1:], forbidden_colors, seq_len, seq_colors)\n\n        return count % 1000000007\n\n    forbidden_colors = set(c)\n    seq_colors = set(s)\n    total_count = 0\n\n    for i in range(1, n+1):\n        if i not in forbidden_colors:\n            for j in range(1, n+1):\n                if j not in forbidden_colors:\n                    for k in range(1, n+1):\n                        if k not in forbidden_colors:\n                            if i != j and i != k and j != k:\n                                count = count_ways([i, j, k], forbidden_colors, len(s), s)\n                                total_count = (total_count + count) % 1000000007\n\n    return total_count\n"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split(\"\\n\")[0].split())\n    c = list(map(int, stdin.split(\"\\n\")[1].split()[1:]))\n    s = list(map(int, stdin.split(\"\\n\")[2].split()[1:]))\n    \n    def count(arr):\n        return sum(arr)\n    \n    def valid(arr):\n        for i in range(len(arr)):\n            if i > 0 and arr[i] in c and arr[i-1] in c:\n                return False\n        return True\n    \n    def generate(arr, k):\n        if k == 0:\n            return [arr]\n        \n        res = []\n        for i in range(len(arr)+1):\n            res.extend(generate(arr[:i] + s + arr[i:], k-1))\n        \n        return res\n    \n    def helper(arr):\n        if valid(arr) and count(arr) >= l:\n            return 1\n        return 0\n    \n    arr = [i+1 for i in range(n)]\n    res = sum(helper(arr) for arr in generate(arr, k))\n    return str(res % (10**9 + 7))"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, c_list, s_list = map(lambda x: list(map(int, x.split())), input_list[1:])\n\n    k, forbidden_colors = c_list[0], set(c_list[1:])\n    l, sequence = s_list[0], set(s_list[1:])\n\n    if not sequence:\n        return \"0\"\n\n    if sequence.issubset(forbidden_colors):\n        return \"0\"\n\n    # Compute the total number of arrangements\n    total_arrangements = 1\n    for i in range(1, n + 1):\n        total_arrangements *= (2 * i - 1)\n\n    # Compute the total number of arrangements that satisfy the sequence condition\n    sequence_arrangements = 1\n    for color in sequence:\n        sequence_arrangements *= (2 * n - 2 * forbidden_colors.count(color) - 1)\n        sequence_arrangements %= (1000000007)\n\n    # Compute the total number of arrangements that satisfy the condition that forbidden colors are not next to each other\n    forbidden_arrangements = 1\n    for color in forbidden_colors:\n        forbidden_arrangements *= (2 * n - 2 - 2 * forbidden_colors.count(color))\n        forbidden_arrangements %= (1000000007)\n\n    result = (total_arrangements * sequence_arrangements * forbidden_arrangements) % (1000000007)\n\n    return str(result)\n"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str, e = stdin.split()\n    n = int(input_str)\n    e = int(e)\n    if e > 62:\n        return \"0\"\n    count = 0\n    for i in range(n+1):\n        if str(i) == \"0\" * e:\n            count += 1\n        elif str(i)[0] == \"0\":\n            continue\n        else:\n            temp = \"\"\n            for j in range(len(str(i))):\n                temp += str(i)[j] + \"^\" + str(j) + \"*\"\n            temp = temp[:-1]\n            if str(2**e) in temp:\n                count += 1\n    return str(count)\n\ninput_str = \"1000000 1\"\noutput = solution(input_str)\nprint(output)\n\ninput_str = \"1000000 5\"\noutput = solution(input_str)\nprint(output)\n\ninput_str = \"1000000 16\"\noutput = solution(input_str)\nprint(output)\n\ninput_str = \"9000000000000000000 62\"\noutput = solution(input_str)\nprint(output) "
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n+1):\n        if '2' in str(i) * (2**e):\n            count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    # binary representation of 2^e\n    binary = format(1 << e, 'b')\n    # number of 1s in binary representation\n    ones_count = binary.count('1')\n    # count of numbers with given power of 2\n    count = 0\n    # iterate through all numbers up to n\n    for i in range(1, n+1):\n        # convert number to binary representation\n        binary = format(i, 'b')\n        # check if the binary representation has the required number of 1s\n        if binary.count('1') == ones_count:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n+1):\n        binary = bin(i)[2:]\n        if len(binary) >= 2**e and (len(binary) == 2**e or binary.count('1') >= 2**e):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n\n    for i in range(n + 1):\n        binary_i = bin(i)[2:]\n        if '1' * e in binary_i:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n+1):\n        if bin(i).count('1') == 2**e:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n+1):\n        num = str(i)\n        if '2'*e in num:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    \n    def count_powers_of_2(k: int) -> int:\n        binary = bin(k)[2:]\n        count = 0\n        for i in range(len(binary) - e):\n            if binary[i:i+e] == \"0\" * e:\n                count += 1\n        return count\n    \n    count = 0\n    for k in range(n + 1):\n        count += count_powers_of_2(k)\n    \n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    base = 1\n    while base <= n:\n        base <<= e\n        count += n // base\n    return str(count)\n\ndef"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        num_str = str(i)\n        if '2' * e in num_str:\n            count += 1\n    return count\n\ndef"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    K, T = map(int, stdin.split()[:2])\n    rolled_dice = list(map(int, stdin.split()[2:]))\n\n    # Compute the probability of each target sum given the number of dice\n    target_probs = [0] * (T + 1)\n    for i in range(1, 7):\n        target_probs[i] = 1 / 6\n\n    for i in range(2, K + 1):\n        for j in range(1, T + 1):\n            target_probs[j] *= (1 / 6 * i) + (target_probs[j - i] * (6 - i))\n\n    # Find the number of dice to pick up to maximize probability\n    max_dice = 0\n    max_prob = 0\n    for i in range(1, K + 1):\n        prob = target_probs[T] * (K - i)\n        if prob > max_prob:\n            max_dice = i\n            max_prob = prob\n\n    return str(max_dice)\n"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, input().split())\n    dice_rolls = list(map(int, input().split()))\n\n    def calculate_probability(dice_count: int) -> float:\n        total_dice = sum(dice_rolls) + dice_count\n        if total_dice < T:\n            return 0\n        probability = 1\n        for roll in dice_rolls:\n            probability *= comb(total_dice, roll) / comb(total_dice + 6 - roll, 6)\n        return probability\n\n    probabilities = [calculate_probability(i) for i in range(K + 1)]\n    max_probability = max(probabilities)\n    max_dice = probabilities.index(max_probability)\n\n    return str(max_dice)\n"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[:2])\n    dice_rolls = list(map(int, stdin.split()[2:]))\n\n    max_dice_to_pickup = 0\n    max_probability = 0\n    for num_dice_to_pickup in range(1, K + 1):\n        probability = 1\n        for i in range(num_dice_to_pickup):\n            probability *= 6\n            probability /= (K - i)\n        for i in range(num_dice_to_pickup, K):\n            probability *= K\n            probability /= (i + 1)\n        if probability * T >= max_probability * max_dice_to_pickup:\n            max_probability = probability\n            max_dice_to_pickup = num_dice_to_pickup\n\n    return str(max_dice_to_pickup)\n"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[0:2])\n    dice = list(map(int, stdin.split()[2:]))\n    max_chance = -1\n    max_dice = 0\n    for i in range(1, K + 1):\n        chance = 1\n        for d in dice:\n            chance *= 1 / 6\n            if d == i:\n                chance *= 1 / 6\n        chance *= 1 / 6 * (K - i)\n        chance *= (6 - i) * (T - i) / 6 / (K - i) / (6 - i)\n        if chance > max_chance:\n            max_chance = chance\n            max_dice = i\n    return str(max_dice)"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    K, T = map(int, input_data[0].split())\n    first_roll = list(map(int, input_data[1].split()))\n\n    def count_ways_to_reach(target: int, dice: int) -> int:\n        if dice == 0:\n            return 0\n        elif target == 0:\n            return 1\n        elif dice == 1:\n            return 1 if target <= 6 else 0\n        elif target <= 6:\n            return count_ways_to_reach(target, dice - 1)\n        else:\n            return count_ways_to_reach(target - 6, dice - 1) + count_ways_to_reach(target, dice - 1)\n\n    max_ways = 0\n    best_dice = 0\n    for i in range(K + 1):\n        ways = count_ways_to_reach(T, K - i)\n        if ways > max_ways:\n            max_ways = ways\n            best_dice = i\n\n    return str(best_dice)"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[0:2])\n    dice = list(map(int, stdin.split()[2:]))\n\n    def calculate_probability(dice_count: int) -> float:\n        probability = 1.0\n        for i in range(dice_count):\n            probability *= 1.0 / 6\n        return probability\n\n    def is_possible(dice_count: int) -> bool:\n        return dice_count * 6 <= T\n\n    def find_max_dice_count(target: int) -> int:\n        max_dice_count = 0\n        for dice_count in range(1, len(dice) + 1):\n            if is_possible(dice_count) and calculate_probability(dice_count) >= target:\n                max_dice_count = max(max_dice_count, dice_count)\n        return max_dice_count\n\n    max_dice_count = find_max_dice_count(1.0)\n    if max_dice_count == 0:\n        return str(find_max_dice_count(1.0 - 1e-9))\n    else:\n        return str(max_dice_count)\n"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.splitlines()\n    K, T = map(int, input_values[0].split())\n    first_roll = list(map(int, input_values[1].split()))\n\n    best_num_dice = 0\n    best_sum = -1\n\n    for num_dice in range(1, K + 1):\n        max_sum = -1\n        for dice_combination in combinations(first_roll, num_dice):\n            total_sum = sum(dice_combination)\n            if total_sum == T:\n                max_sum = num_dice\n                break\n            elif total_sum > T:\n                if total_sum > max_sum:\n                    max_sum = num_dice\n                    break\n\n        if max_sum > best_sum:\n            best_sum = max_sum\n            best_num_dice = num_dice\n\n    return str(best_num_dice)"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    K, T = map(int, input_data[0].split())\n    first_roll = list(map(int, input_data[1].split()))\n\n    def calculate_probability(dice_to_pickup: int) -> float:\n        total_dice = K + dice_to_pickup\n        probability = 1\n        for die in first_roll:\n            probability *= (T - die) / (total_dice - 1)\n        return probability\n\n    probabilities = [calculate_probability(i) for i in range(K + 1)]\n    max_probability = max(probabilities)\n    dice_to_pickup = probabilities.index(max_probability)\n\n    return str(dice_to_pickup)\n"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[0:2])\n    nums = list(map(int, stdin.split()[2:]))\n\n    def has_sum(nums, target):\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return True\n        return False\n\n    def count_sums(nums, target):\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    count += 1\n        return count\n\n    def sum_dice(nums, dice):\n        total = 0\n        for i in range(len(nums)):\n            if i < dice:\n                total += nums[i]\n        return total\n\n    best_dice = 1\n    best_count = count_sums(nums, T)\n\n    for i in range(2, K + 1):\n        if has_sum(nums, T - sum_dice(nums, i)):\n            count = count_sums(nums, T - sum_dice(nums, i))\n            if count > best_count:\n                best_dice = i\n                best_count = count\n\n    return str(best_dice)"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[0:2])\n    dice = list(map(int, stdin.split()[2:]))\n    \n    def calculate_chance(dice_count: int) -> float:\n        chance = 1.0\n        for _ in range(dice_count):\n            chance *= 1.0 / 6\n        return chance\n    \n    def get_best_pickup(dice_count: int) -> int:\n        best_chance = 0.0\n        best_pickup = 0\n        for i in range(1, dice_count + 1):\n            chance = calculate_chance(i)\n            if chance > best_chance:\n                best_chance = chance\n                best_pickup = i\n        return best_pickup\n    \n    def sum_dice(dice_count: int) -> int:\n        return sum(dice[:dice_count])\n    \n    def solve(dice_count: int) -> int:\n        target = K * dice_count + T\n        if target <= sum_dice(dice_count):\n            return 0\n        best_pickup = get_best_pickup(dice_count)\n        return min(best_pickup, K - dice_count + best_pickup)\n    \n    result = 1\n    while result <= K and T > sum_dice(result):\n        result += 1\n    return str(result - 1)"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Helper function to find the number of distinct prime factors\n    def count_prime_factors(num: int) -> int:\n        count = 0\n        i = 2\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                num //= i\n                count += 1\n        if num > 1:\n            count += 1\n        return count\n\n    # Read the input\n    N, *data = stdin.splitlines()\n    N = int(N)\n    data = [int(d) for d in data]\n\n    # Calculate the maximum revenue\n    revenue = 0\n    for customer in range(1, N + 1):\n        total_sum = sum(data[i - 1] for i in range(1, N + 1) if customer & (1 << (i - 1)) != 0)\n        revenue += count_prime_factors(total_sum)\n\n    return revenue\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def prime_factors(num: int) -> int:\n        count = 0\n        while num % 2 == 0:\n            count += 1\n            num //= 2\n        while num % 3 == 0:\n            count += 1\n            num //= 3\n        i = 5\n        while i * i <= num:\n            if num % i == 0:\n                count += 1\n                num //= i\n            i += 2\n        if num > 1:\n            count += 1\n        return count\n\n    # Read input\n    N = int(stdin.splitlines()[0])\n    data = [int(x) for x in stdin.splitlines()[1].split()]\n\n    # Calculate revenue\n    revenue = 0\n    for i in range(1, N + 1):\n        revenue += prime_factors(sum(data[i - 1::N]))\n\n    return revenue"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, data = stdin.splitlines()\n    N = int(N)\n    data = list(map(int, data.split()))\n    prime_factors = set()\n    for i in range(1, int(max(data)) + 1):\n        if sum(S % i == 0 for S in data) > 0:\n            prime_factors.add(i)\n\n    return len(prime_factors)\n\n\ninput_stdin = \"\"\"3\n4 7 8\"\"\"\n\nprint(solution(input_stdin)) "
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    N = int(input_list[0])\n    S = list(map(int, input_list[1].split()))\n    max_revenue = 0\n\n    def count_prime_factors(num: int) -> int:\n        count = 0\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                count += 1\n                while num % i == 0:\n                    num //= i\n        if num > 1:\n            count += 1\n        return count\n\n    for i in range(N):\n        sum_of_si = sum(S[i])\n        max_revenue = max(max_revenue, count_prime_factors(sum_of_si))\n\n    return max_revenue\n\n\ninput_string = \"\"\"3\n4 7 8\n\"\"\"\n\nprint(solution(input_string))  # Output: 3 "
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    data_sums = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def count_prime_factors(n: int) -> int:\n        count = 0\n        while n % 2 == 0:\n            count += 1\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                count += 1\n                n //= i\n        if n > 2:\n            count += 1\n        return count\n\n    data_primes = [count_prime_factors(sum(data_sums[:i+1])) for i in range(N)]\n    max_revenue = max(data_primes)\n\n    return str(max_revenue)\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def prime_factors(num: int) -> set:\n        factors = set()\n        for i in range(2, num + 1):\n            while num % i == 0:\n                factors.add(i)\n                num //= i\n        return factors\n\n    n = int(stdin.splitlines()[0])\n    data_primes = []\n    max_prime_factors = 0\n\n    for i in range(1, n + 1):\n        data_primes.append(prime_factors(int(stdin.splitlines()[1].split()[i - 1])))\n        max_prime_factors = max(max_prime_factors, len(data_primes[-1]))\n\n    return max_prime_factors * n"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n    S = list(map(int, input_data[1].split()))\n\n    def count_prime_factors(num):\n        count = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count += 1\n        return count\n\n    def get_max_revenue(sold_data):\n        revenue = 0\n        for i in range(N):\n            if i not in sold_data:\n                continue\n            sum_s = sum(S[k] for k in sold_data)\n            revenue += count_prime_factors(sum_s)\n        return revenue\n\n    sold_data = set()\n    max_revenue = 0\n    for i in range(N):\n        sold_data.add(i)\n        max_revenue = max(max_revenue, get_max_revenue(sold_data))\n        sold_data.remove(i)\n\n    return max_revenue"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    N, data = stdin.split(\"\\n\")\n    N = int(N)\n    data = list(map(int, data.split()))\n\n    revenue = 0\n    for i in range(1, N + 1):\n        prime_factors = set()\n        while data[i - 1] > 1:\n            for j in range(2, data[i - 1] + 1):\n                if data[i - 1] % j == 0 and is_prime(j):\n                    prime_factors.add(j)\n            data[i - 1] //= data[i - 1]\n        revenue += len(prime_factors)\n\n    return str(revenue)\n"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n    S = list(map(int, input_data[1].split()))\n    \n    def count_distinct_prime_factors(number: int) -> int:\n        factors = set()\n        for i in range(2, int(number**0.5)+1):\n            if number % i == 0:\n                factors.add(i)\n                while number % i == 0:\n                    number //= i\n        if number > 1:\n            factors.add(number)\n        return len(factors)\n\n    revenue = 0\n    for i in range(N):\n        revenue += count_distinct_prime_factors(sum(S[:i+1]))\n\n    return revenue"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n        return True\n\n    def count_prime_factors(num: int) -> int:\n        count = 0\n        while num % 2 == 0:\n            count += 1\n            num //= 2\n        for i in range(3, int(num**0.5) + 1, 2):\n            while num % i == 0:\n                count += 1\n                num //= i\n        if num > 2:\n            count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    data = [int(num) for num in lines[1].split()]\n\n    max_revenue = 0\n    for i in range(N):\n        prime_factors = set()\n        for j in range(N):\n            if j != i:\n                prime_factors.add(data[j])\n        revenue = count_prime_factors(sum(prime_factors))\n        max_revenue = max(max_revenue, revenue)\n\n    return str(max_revenue)\n"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    # Base case\n    if N == 0:\n        return -1\n\n    # Finding the smallest positive integer a\n    a = 1\n    while a * a <= N:\n        a += 1\n\n    # Checking if a * a = N\n    if a * a == N:\n        return a\n    else:\n        return -1"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    a = 1\n    while True:\n        if a * a == N:\n            return str(a)\n        elif a * a > N:\n            return \"-1\"\n        else:\n            a += 1"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for a in range(1, 10000):\n        if (a * a) % N == 0:\n            return a\n    return -1\n"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    def carryless_multiply(a, b):\n        result = 0\n        for i in range(len(b)):\n            carry = 0\n            for j in range(len(a)):\n                product = a[j] * b[i]\n                result += product + carry\n                carry = result // 10\n                result %= 10\n            result += carry\n        return result\n\n    def count_digits(num):\n        count = 0\n        while num > 0:\n            count += 1\n            num //= 10\n        return count\n\n    for i in range(1, count_digits(N) + 1):\n        a = 10 ** i - 1\n        if carryless_multiply(str(a), str(a)) == N:\n            return str(a)\n\n    return \"-1\"\n"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    a = 1\n\n    while True:\n        if a * a == N:\n            return str(a)\n        elif a * a > N:\n            return \"-1\"\n        a += 1"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for a in range(1, 1000000):\n        if a * a == N:\n            return a\n    return -1\n\ninput_string = input()\noutput = solution(input_string)\nprint(output) "
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for a in range(1, N+1):\n        if a * a == N:\n            return str(a)\n    return '-1'\n\ninput_str = input()\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for a in range(1, 10000):  # Brute force approach to find the smallest positive integer a such that a \u2297 a = N\n        if a * a == N:\n            return str(a)\n    return '-1'\n\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    a = 1\n    while True:\n        if a * a >= N:\n            break\n        a += 1\n    if a * a == N:\n        return str(a)\n    else:\n        return '-1'\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    a = 1\n    while True:\n        if a * a == N:\n            return str(a)\n        elif a * a > N:\n            return '-1'\n        else:\n            a += 1"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split(\"\\n\")\n    L, N, input_list = input_list[0].split(\" \"), int(input_list[0].split(\" \")[1]), input_list[1:]\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    L = alphabet.index(L[0])\n\n    for i in range(N):\n        word = input_list[i]\n        for j in range(len(word)):\n            if alphabet.index(word[j]) > L:\n                return \"IMPOSSIBLE\"\n            L = max(L, alphabet.index(word[j]))\n\n    if L == 25:\n        return \"IMPOSSIBLE\"\n    else:\n        return alphabet[:L+1]\n\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    L, N, *words = stdin.split()\n    L = ord(L) - ord('b')\n\n    # Initialize a dictionary to store the count of each character in the alphabet\n    char_count = {char: 0 for char in range(ord('a'), ord('a') + L + 1)}\n\n    # Count the occurrence of each character in the given words\n    for word in words:\n        for char in word:\n            char_count[ord(char) - ord('a')] += 1\n\n    # Check if the given words provide enough information to determine a unique alphabet order\n    for i in range(ord('a'), ord('a') + L + 1):\n        # If there is only one occurrence of a character, it must come before all other characters\n        if char_count[i] == 1:\n            continue\n        # If there are multiple occurrences of a character, we can't determine a unique alphabet order\n        elif char_count[i] > 1:\n            return \"IMPOSSIBLE\"\n\n    # If the alphabet is consistent, generate the alphabet order\n    alphabet = \"\"\n    for i in range(ord('a'), ord('a') + L + 1):\n        if char_count[i] == 1:\n            alphabet += chr(i + ord('a'))\n            char_count[i] = -1\n\n    # Check for any inconsistencies in the alphabet order\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            if words[i] < words[j]:\n                for k in range(len(words[i])):\n                    if words[i][k] != words[j][k]:\n                        if chr(i + ord('a')) < words[i][k] < chr(j + ord('a')):\n                            return \"IMPOSSIBLE\"\n                        break\n            elif words[j] < words[i]:\n                for k in range(len(words[i])):\n                    if words[i][k] != words[j][k]:\n                        if chr(i + ord('a')) > words[i][k] > chr(j + ord('a')):\n                            return \"IMPOSSIBLE\"\n                        break\n\n    return alphabet\n"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    L, N = input_data[0].split()\n    L = ord(L) - ord('b')\n    alphabet = []\n\n    for i in range(1, len(input_data)):\n        word = input_data[i]\n        if len(word) != 1:\n            return \"IMPOSSIBLE\"\n        if ord(word[0]) > L + ord('b'):\n            return \"IMPOSSIBLE\"\n        if word not in alphabet:\n            alphabet.append(word)\n        else:\n            return \"IMPOSSIBLE\"\n\n    alphabet.sort()\n    sorted_alphabet = [''.join([chr(i + ord('b')) for i in range(len(alphabet[0]))])]\n    for i in range(1, len(alphabet)):\n        if alphabet[i][0] == alphabet[i - 1][0]:\n            return \"AMBIGUOUS\"\n        sorted_alphabet.append(''.join([chr(i + ord('b')) for i in range(len(alphabet[i]))]))\n\n    return ''.join(sorted_alphabet)\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    L, N = lines[0].split()\n    L = ord(L) - ord('b')\n    words = [line.strip() for line in lines[1:]]\n\n    def lexicographic_order(word1, word2):\n        min_len = min(len(word1), len(word2))\n        for i in range(min_len):\n            if word1[i] < word2[i]:\n                return True\n            elif word1[i] > word2[i]:\n                return False\n        return len(word1) <= len(word2)\n\n    def generate_alphabet(words):\n        alphabet = [False] * (L + 1)\n        for word in words:\n            for char in word:\n                alphabet[ord(char) - ord('a')] = True\n        return ''.join(chr(i + ord('a')) for i, is_used in enumerate(alphabet) if is_used)\n\n    # Check if the words form a valid alphabet\n    for i in range(N - 1):\n        if not lexicographic_order(words[i], words[i + 1]):\n            return \"IMPOSSIBLE\"\n\n    alphabet = generate_alphabet(words)\n\n    if len(set(alphabet)) == 1:\n        return alphabet\n    else:\n        return \"AMBIGUOUS\"\n"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def lexicographic_order(words: List[str]) -> str:\n        sorted_words = sorted(words)\n        alphabet = [None] * (ord('z') - ord('a') + 1)\n        for word in sorted_words:\n            for letter in word:\n                if alphabet[ord(letter) - ord('a')] is None:\n                    alphabet[ord(letter) - ord('a')] = letter\n                elif alphabet[ord(letter) - ord('a')] != letter:\n                    return \"IMPOSSIBLE\"\n        return ''.join(alphabet)\n\n    L, N, *words = stdin.split()\n    if not (L.isalpha() and L.islower() and len(L) == 1):\n        return \"IMPOSSIBLE\"\n    if not (N.isdigit() and int(N) in range(1, 1001)):\n        return \"IMPOSSIBLE\"\n\n    words = [word for word in words if word]\n    if len(words) != int(N):\n        return \"IMPOSSIBLE\"\n\n    result = lexicographic_order(words)\n    if result == \"IMPOSSIBLE\":\n        return result\n    elif len(set(result)) != len(result):\n        return \"AMBIGUOUS\"\n    else:\n        return result\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def lexicographic_order(words: List[str]) -> Optional[str]:\n        alphabets = {}\n        for word in words:\n            for letter in word:\n                if letter not in alphabets:\n                    alphabets[letter] = len(alphabets)\n        if len(alphabets) == 0:\n            return \"IMPOSSIBLE\"\n        elif len(alphabets) == 1:\n            return \"\".join(sorted(alphabets.keys()))\n        else:\n            return \"AMBIGUOUS\"\n\n    def is_consistent(words: List[str]) -> bool:\n        for i in range(len(words) - 1):\n            if (words[i] < words[i + 1]) != (words[i] < words[i - 1]):\n                return False\n        return True\n\n    def find_alphabet_order(words: List[str]) -> str:\n        if not is_consistent(words):\n            return \"IMPOSSIBLE\"\n        return lexicographic_order(words)\n\n    stdin = stdin.strip()\n    lines = stdin.split('\\n')\n    L, N = map(int, lines[0].split())\n    words = lines[1:]\n    return find_alphabet_order(words)\n"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    L, N, *words = stdin.split()\n    L = ord(L)\n    words = [word for word in words if len(word) > 0]\n\n    if len(words) != N:\n        return \"IMPOSSIBLE\"\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if words[i] < words[j]:\n                continue\n            if words[i] > words[j]:\n                return \"IMPOSSIBLE\"\n\n    alphabet = [chr(i) for i in range(ord('a'), L + 1)]\n    for word in words:\n        for letter in word:\n            if letter not in alphabet:\n                return \"IMPOSSIBLE\"\n            alphabet.remove(letter)\n\n    return \"\".join(alphabet)\n\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[0])\n    words = stdin.split('\\n')[1:]\n\n    # Check for inconsistencies\n    for i in range(N):\n        for j in range(i + 1, N):\n            if words[i] < words[j]:\n                if words[j][:len(words[i])] < words[i]:\n                    return 'IMPOSSIBLE'\n\n    # Determine the alphabet\n    alphabet = {}\n    for word in words:\n        for letter in set(word):\n            if letter not in alphabet:\n                alphabet[letter] = word.index(letter)\n\n    # Check for consistency\n    for i in range(len(words) - 1):\n        if alphabet[words[i][0]] > alphabet[words[i + 1][0]]:\n            return 'IMPOSSIBLE'\n\n    # Determine the order of the alphabet\n    order = sorted(alphabet.values())\n    alphabet_order = ''.join([chr(97 + i) for i in order])\n\n    return alphabet_order"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    L, N = input_list[0].split()\n    L = L.lower()\n    if L < 'b' or L > 'z' or N <= 0:\n        return \"IMPOSSIBLE\"\n    words = input_list[1:]\n    if len(words) != int(N):\n        return \"IMPOSSIBLE\"\n    for i in range(len(words)):\n        if len(words[i]) > 1000 or len(words[i]) == 0 or not all(c.lower() in 'abcdefghijklmnopqrstuvwxyz' for c in words[i]):\n            return \"IMPOSSIBLE\"\n    words.sort()\n    for i in range(len(words)-1):\n        if words[i] > words[i+1]:\n            return \"IMPOSSIBLE\"\n    alphabet = {}\n    for word in words:\n        for char in word:\n            if char not in alphabet:\n                alphabet[char] = set()\n            alphabet[char].add(word)\n    for char in alphabet:\n        if len(alphabet[char]) > 1:\n            return \"AMBIGUOUS\"\n    alphabet_order = \"\"\n    for char in range(ord(L), ord('a'), -1):\n        char_str = chr(char)\n        if char_str in alphabet:\n            alphabet_order += char_str\n    return alphabet_order"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[0].split())\n    words = stdin.split(\"\\n\")[1:]\n\n    # Build a list of all possible orderings of the alphabet\n    orderings = []\n    for i in range(L):\n        for j in range(i + 1, L + 1):\n            orderings.append((chr(ord('a') + i), chr(ord('a') + j)))\n\n    # Try each ordering to see if it works for all the words\n    for ordering in orderings:\n        alphabet = \"\".join(ordering)\n        alphabet_map = {alphabet[i]: i for i in range(L)}\n\n        # Check if the ordering works for all the words\n        for word in words:\n            sorted_word = \"\".join(sorted(word, key=lambda c: alphabet_map[c]))\n            if sorted_word != word:\n                break\n        else:\n            # If the loop completes without breaking, the ordering works for all the words\n            return alphabet\n\n    # If no ordering works, return IMPOSSIBLE\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    N, A, B, C = map(int, input_list)\n\n    total_cookies = A + B + C\n    max_cookies_per_person = total_cookies // N\n\n    alf_cookies = min(A, max_cookies_per_person)\n    beata_cookies = min(B, max_cookies_per_person)\n    remaining_cookies = total_cookies - alf_cookies - beata_cookies\n\n    # Distribute the remaining cookies\n    alf_extra_cookies = 0\n    beata_extra_cookies = 0\n    for i in range(1, N):\n        if i % 2 == 0:\n            beata_extra_cookies += min(remaining_cookies, max_cookies_per_person)\n            remaining_cookies -= min(remaining_cookies, max_cookies_per_person)\n        else:\n            alf_extra_cookies += min(remaining_cookies, max_cookies_per_person)\n            remaining_cookies -= min(remaining_cookies, max_cookies_per_person)\n\n    # Add the extra cookies\n    total_cookies_distributed = alf_cookies + beata_cookies + alf_extra_cookies + beata_extra_cookies\n\n    return str(total_cookies_distributed)"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    N, A, B, C = map(int, input_list)\n    \n    # Maximum number of cookies that can be distributed is 2 * (A + B + C)\n    max_cookies = 2 * (A + B + C)\n    \n    # Alf and Beata can distribute at most half of the cookies to their friends\n    return max_cookies // 2\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    N, A, B, C = map(int, input_list)\n    total_cookies = A + B + C\n    total_friends = N + 2\n    \n    # Calculate the maximum number of cookies that can be distributed\n    max_cookies = total_cookies // total_friends\n    \n    # Check if there are any cookies left after distributing max_cookies\n    cookies_left = total_cookies % total_friends\n    \n    # Check if there are enough cookies for Alf and Beata to eat all their cookies\n    if cookies_left >= 2:\n        # There are enough cookies for both Alf and Beata to eat all their cookies\n        max_cookies += 1\n    \n    return max_cookies\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    N, A, B, C = map(int, inputs)\n    \n    total_cookies = A + B + C\n    friends = N + 2  # for Alf and Beata\n    \n    # There are a total of N friends, plus Alf and Beata.\n    # Each friend will eat 1 cookie of each type, plus an extra cookie to ensure they don't eat the same type of cookie in a row.\n    # Therefore, there will be a total of (N+2) * 3 = 3N + 6 cookies.\n    # If there are more cookies than this, then some cookies will have to be shared among the friends.\n    if total_cookies > 3 * N + 6:\n        # If there are more cookies than needed, then we can divide them as follows:\n        # - Allocate 3N cookies to each friend (one of each type).\n        # - Allocate an extra cookie to each friend (one of each type) to ensure they don't eat the same type of cookie in a row.\n        # - Finally, share the remaining cookies among all the friends.\n        # This means that each friend will receive a total of 3N + 6 cookies.\n        return 3 * N + 6\n    else:\n        # If there are not more cookies than needed, then all the cookies will be distributed.\n        return total_cookies\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    max_cookies = min(A, B, C)\n    return str(max_cookies)\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    return max(A, B, C) * N\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    max_cookies = N * min(A, B, C) + 1\n    return str(max_cookies)\n\n\ndef"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    return max(N // 2 * (A + B + C), (A + B + C) * (N - 1))\n\ndef"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    max_cookies = N * total_cookies\n    return str(max_cookies)\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    N = int(input_data[0])\n    A, B, C = map(int, input_data[1:])\n\n    total_cookies = A + B + C\n    max_cookies_per_friend = total_cookies // N\n    leftover_cookies = total_cookies % N\n\n    if leftover_cookies > 0:\n        max_cookies_per_friend += 1\n\n    return max_cookies_per_friend\n\ndef"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, r = map(int, input_list[0].split())\n    candles = [(int(x), int(y)) for x, y in [line.split() for line in input_list[1:n+1]]]\n    cut_lines = [(int(a), int(b), int(c)) for a, b, c in [line.split() for line in input_list[n+1:n+m+1]]]\n\n    def is_valid(candles, cut_lines):\n        for x, y in candles:\n            min_distance = float('inf')\n            for a, b, c in cut_lines:\n                if a != 0 and b != 0:\n                    distance = abs((a * x + b * y + c) / (a**2 + b**2))\n                else:\n                    if a != 0:\n                        distance = abs(x - (-c / a))\n                    else:\n                        distance = abs(y - (-c / b))\n                min_distance = min(min_distance, distance)\n            if min_distance > r:\n                return False\n        return True\n\n    return \"yes\" if is_valid(candles, cut_lines) else \"no\""
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, r = map(int, input_list[0].split())\n    candles = [tuple(map(int, input_list[i+1].split())) for i in range(n)]\n    cut_lines = [tuple(map(int, input_list[i+1+n].split())) for i in range(m)]\n\n    def circle_cut(x, y, a, b, c):\n        return a * x + b * y + c\n\n    def is_on_cut(x, y, a, b, c):\n        return abs(a * x + b * y + c) < 1e-4\n\n    def is_in_circle(x, y, r):\n        return x ** 2 + y ** 2 < r ** 2\n\n    for i in range(n):\n        x, y = candles[i]\n        for j in range(m):\n            a, b, c = cut_lines[j]\n            if is_on_cut(x, y, a, b, c):\n                return \"no\"\n            if is_in_circle(x, y, r) and not is_on_cut(0, 0, a, b, c):\n                return \"no\"\n\n    for i in range(n):\n        x, y = candles[i]\n        count = 0\n        for j in range(m):\n            a, b, c = cut_lines[j]\n            if is_on_cut(x, y, a, b, c):\n                count += 1\n        if count % 2 != 0:\n            return \"no\"\n\n    return \"yes\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_point_inside(x: float, y: float, r: float) -> bool:\n        return x * x + y * y <= r * r\n\n    def is_line_valid(a: float, b: float, c: float, r: float) -> bool:\n        return a * a + b * b <= 4 * c * (c + 2 * r)\n\n    def get_distance(x1: float, y1: float, x2: float, y2: float) -> float:\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def get_line_coefficients(x1: float, y1: float, x2: float, y2: float) -> Tuple[float, float, float]:\n        dx = x2 - x1\n        dy = y2 - y1\n        if dx == 0:\n            a = 1\n            b = 0\n            c = -x1\n        elif dy == 0:\n            a = 0\n            b = 1\n            c = -y1\n        else:\n            a = dy\n            b = -dx\n            c = (dy * x1 - dx * y1)\n        return a, b, c\n\n    def is_candle_on_cut(candle: Tuple[float, float], cut: Tuple[float, float, float], r: float) -> bool:\n        a, b, c = cut\n        x, y = candle\n        return a * x + b * y + c == 0 and is_point_inside(x, y, r)\n\n    def is_cut_valid(cut: Tuple[float, float, float], r: float) -> bool:\n        a, b, c = cut\n        return is_line_valid(a, b, c, r)\n\n    def check_candles_on_cuts(candles: List[Tuple[float, float]], cuts: List[Tuple[float, float, float]], r: float) -> bool:\n        for candle in candles:\n            if any(is_candle_on_cut(candle, cut, r) for cut in cuts):\n                return False\n        return True\n\n    n, m, r = map(int, stdin.readline().split())\n    candles = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    cuts = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    if not check_candles_on_cuts(candles, cuts, r):\n        return \"no\"\n\n    candle_positions = set(candles)\n    cut_lines = set(cuts)\n    for x, y in candle_positions:\n        for a, b, c in cut_lines:\n            if a * x + b * y + c == 0 and is_point_inside(x, y, r):\n                break\n        else:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split('\\n')\n    n, m, r = map(int, input_values[0].split())\n    candles = []\n    for i in range(1, n+1):\n        x, y = map(int, input_values[i].split())\n        candles.append((x, y))\n    \n    lines = []\n    for i in range(n+1, n+1+m):\n        a, b, c = map(int, input_values[i].split())\n        lines.append((a, b, c))\n    \n    if n != len(candles):\n        return \"no\"\n    \n    # Check if each candle has exactly one neighbor\n    for candle in candles:\n        count = 0\n        for line in lines:\n            if line_contains_point(line, candle, r):\n                count += 1\n                if count > 1:\n                    return \"no\"\n        if count == 0:\n            return \"no\"\n    \n    # Check if each cut line separates the cake into n pieces\n    pieces = []\n    for line in lines:\n        pieces.append(get_pieces(line, r))\n    \n    if len(pieces) != m or len(set(pieces)) != n:\n        return \"no\"\n    \n    return \"yes\"\n\ndef"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split()[:3])\n    candles = [tuple(map(int, stdin.split()[i*2:(i+1)*2])) for i in range(n)]\n    cuts = [tuple(map(int, stdin.split()[i*3+3:(i+1)*3])) for i in range(m)]\n    \n    def count_candles(cuts, x, y):\n        return sum(abs((a * x + b * y + c) // (a**2 + b**2)) <= 1 for a, b, c in cuts)\n    \n    for x, y in candles:\n        if count_candles(cuts, x, y) != 1:\n            return \"no\"\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def cross(a: int, b: int, c: int) -> int:\n        return a * (-c) + b * (-d)\n\n    def is_on_left_side(x: int, y: int, a: int, b: int, c: int) -> bool:\n        return cross(x, y, a, b, c) <= 0\n\n    def is_on_right_side(x: int, y: int, a: int, b: int, c: int) -> bool:\n        return cross(x, y, a, b, c) >= 0\n\n    def is_on_line(x: int, y: int, a: int, b: int, c: int) -> bool:\n        return cross(x, y, a, b, c) == 0\n\n    def shift_line(a: int, b: int, c: int, dx: int, dy: int) -> tuple:\n        return a, b, c - a * dx - b * dy\n\n    def count_candles(a: int, b: int, c: int, n: int, r: int) -> int:\n        count = 0\n        for x, y in points:\n            if is_on_left_side(x, y, a, b, c) and is_on_right_side(x, y, a, b, c) and is_on_line(x, y, a, b, c):\n                count += 1\n        return count\n\n    def check_candles(a: int, b: int, c: int, n: int, r: int) -> bool:\n        count = count_candles(a, b, c, n, r)\n        if count == n:\n            return True\n        return False\n\n    lines = stdin.splitlines()\n    n, m, r = map(int, lines[0].split())\n    points = [tuple(map(int, line.split())) for line in lines[1:n+1]]\n    cuts = [tuple(map(int, line.split())) for line in lines[n+1:]]\n\n    for a, b, c in cuts:\n        if a == 0 and b == 0:\n            return \"no\"\n\n        if a == 0:\n            for y in range(-r, r+1):\n                if is_on_right_side(0, y, a, b, c):\n                    dx = y\n                    dy = 0\n                    for ax, bx, cx in cuts:\n                        if is_on_left_side(dx, dy, ax, bx, cx):\n                            return \"no\"\n                    if count_candles(a, b, c, n, r) != n:\n                        return \"no\"\n            return \"yes\"\n\n        if b == 0:\n            for x in range(-r, r+1):\n                if is_on_right_side(x, 0, a, b, c):\n                    dx = 0\n                    dy = x\n                    for ax, bx, cx in cuts:\n                        if is_on_left_side(dx, dy, ax, bx, cx):\n                            return \"no\"\n                    if count_candles(a, b, c, n, r) != n:\n                        return \"no\"\n            return \"yes\"\n\n        for dx, dy in points:\n            if is_on_right_side(dx, dy, a, b, c) and is_on_left_side(dx, dy, a, b, c):\n                return \"no\"\n\n        if count_candles(a, b, c, n, r) != n:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, r = map(int, input_data[0].split())\n    candles = [(x, y) for i, line in enumerate(input_data[1:n+1]) for x, y in [map(int, line.split())]]\n    cutting_lines = [(a, b, c) for i, line in enumerate(input_data[n+1:], n+1) for a, b, c in [map(int, line.split())]]\n\n    def is_inside_circle(x, y):\n        return x**2 + y**2 <= r**2\n\n    def distance_to_line(x, y, a, b, c):\n        return abs(a*x + b*y + c) / (a**2 + b**2)**0.5\n\n    for line in cutting_lines:\n        a, b, c = line\n        if a == 0 and b == 0:\n            return \"no\"\n        for x, y in candles:\n            if not is_inside_circle(x, y) or distance_to_line(x, y, a, b, c) > 1e-4:\n                return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, r = map(int, input_list[0].split())\n    candles = [(x, y) for x, y in map(lambda x: tuple(map(int, x.split())), input_list[1:n+1])]\n    cuts = [(a, b, c) for a, b, c in map(lambda x: tuple(map(int, x.split())), input_list[n+1:n+m+1])]\n\n    def circle_intersection(point1, point2):\n        x1, y1 = point1\n        x2, y2 = point2\n        dx = x2 - x1\n        dy = y2 - y1\n        dr = math.sqrt(dx*dx + dy*dy)\n        if dr >= r:\n            return []\n        h = math.sqrt(r*r - dr*dr)\n        return [(x1 + h*dy/dr, y1 - h*dx/dr), (x1 - h*dy/dr, y1 + h*dx/dr)]\n\n    def is_on_line(point, line):\n        a, b, c = line\n        x, y = point\n        return a*x + b*y + c == 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            intersection_points = circle_intersection(candles[i], candles[j])\n            if not intersection_points:\n                return \"no\"\n            for line in cuts:\n                if not any(is_on_line(point, line) for point in intersection_points):\n                    return \"no\"\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, r = map(int, input_list[0].split())\n    candles = [(int(x), int(y)) for x, y in [line.split() for line in input_list[1:n+1]]]\n    cutting_lines = [(int(a), int(b), int(c)) for a, b, c in [line.split() for line in input_list[n+1:n+m+1]]]\n\n    def distance(p1, p2):\n        return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**0.5\n\n    def is_inside(point, circle):\n        return distance(point, circle) <= circle[2]\n\n    def count_candles(piece):\n        return sum(is_inside(candle, piece) for candle in candles)\n\n    def intersects(line, circle):\n        d = distance((line[0], line[1]), (circle[0], circle[1]))\n        return abs(line[0]*circle[0] + line[1]*circle[1] + circle[2]) < d**2\n\n    for i in range(m):\n        piece = cutting_lines[i]\n        piece_candles = [candle for candle in candles if intersects(piece, (candle[0], candle[1], 0))]\n        if count_candles(piece) != 1:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(a, b, c, x, y, r):\n        return a * x + b * y + c >= -10**-4 and a * x + b * y + c <= 10**-4 + 2 * r\n\n    def is_inside(x, y, r):\n        return x**2 + y**2 <= r**2\n\n    n, m, r = map(int, stdin.split()[:3])\n    candles = [tuple(map(int, stdin.split()[i:i+2])) for i in range(3, 3 + n)]\n    lines = [tuple(map(int, stdin.split()[i:i+3])) for i in range(3 + n, 3 + n + m)]\n\n    for a, b, c in lines:\n        if a == 0 and b == 0:\n            continue\n\n        for x, y in candles:\n            if is_valid(a, b, c, x, y, r) and is_inside(a * x + c, b * y + c, r):\n                return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = len(stdin)\n    max_k = 1\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_palindrome(stdin[i:j]):\n                max_k = max(max_k, j - i)\n\n    return str(max_k)\n"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def find_palindrome_length(s: str) -> int:\n        n = len(s)\n        for i in range(1, n):\n            for j in range(n - i):\n                if is_palindrome(s[j:j + i]):\n                    return i\n        return 1\n\n    def find_max_palindrome_parts(s: str) -> int:\n        n = len(s)\n        k = 1\n        while k <= n:\n            if is_palindrome(s[:k]) and is_palindrome(s[n - k:]) and find_palindrome_length(s[k - 1:n - k + 1]) >= k:\n                return k\n            k += 1\n        return -1\n\n    return str(find_max_palindrome_parts(stdin))\n"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    k = 1\n    while k <= n // 2:\n        l, r = k, n - k\n        while l >= 0 and r < n and s[l] == s[r]:\n            l -= 1\n            r += 1\n        if r - l - 1 == k:\n            return k\n        k += 1\n    return 1\n"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    # Initialize a list to store the count of digits in each position\n    count = [0] * n\n\n    # Iterate through the input string and update the count list\n    for char in stdin:\n        count[int(char)] += 1\n\n    # Calculate the minimum count for a palindrome subsequence to exist\n    min_count = n // 2\n\n    # Iterate through the count list and find the maximum k such that the k parts form a palindrome\n    for i in range(n):\n        min_count = min(min_count, count[i])\n\n        if i - min_count >= 0 and i + min_count <= n - 1:\n            return i - min_count + 1\n\n    return 1\n"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def is_valid_partition(s: str, k: int) -> bool:\n        for i in range(k):\n            if not is_palindrome(s[i:i + k]):\n                return False\n        return True\n\n    n = len(stdin)\n    max_k = 1\n    for i in range(1, n):\n        for j in range(i, n):\n            if is_valid_partition(stdin, j - i + 1):\n                max_k = max(max_k, j - i + 1)\n                break\n        else:\n            continue\n        break\n\n    return str(max_k)\n"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(sub_str: str) -> bool:\n        return sub_str == sub_str[::-1]\n\n    def split_and_check(s: str, k: int) -> bool:\n        parts = [s[i:i + k] for i in range(len(s) - k + 1)]\n        return all(is_palindrome(part) for part in parts)\n\n    n = len(stdin)\n    for k in range(1, n // 2 + 1):\n        if split_and_check(stdin, k):\n            return k\n    return 1\n"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = len(stdin)\n    for k in range(1, n // 2 + 1):\n        if not is_palindrome(stdin[:k]):\n            break\n        if not is_palindrome(stdin[k:]):\n            break\n    return str(k)\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def partition_palindrome(s: str) -> int:\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = True\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    if j - i <= 2:\n                        dp[i][j] = True\n                    else:\n                        dp[i][j] = dp[i + 1][j - 1]\n\n        k = 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                if dp[i][j]:\n                    k = max(k, j - i + 1)\n                    break\n\n        return k\n\n    def max_palindrome_length(stdin: str) -> int:\n        n = len(stdin)\n        max_length = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                substring = stdin[i:j]\n                if is_palindrome(substring):\n                    max_length = max(max_length, j - i)\n        return max_length\n\n    k = max_palindrome_length(stdin)\n    return partition_palindrome(stdin) if k > 1 else 1"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n == 0:\n        return 0\n    max_k = 1\n    for i in range(1, n):\n        if stdin[i] == stdin[n-i-1]:\n            max_k += 1\n        else:\n            break\n    return max_k"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n\n    if n < 2:\n        return 1\n\n    max_k = 1\n    for i in range(n-1):\n        if s[i] != s[n-1-i]:\n            max_k = 2\n            break\n\n    for k in range(3, n//2+1):\n        for i in range(n-k):\n            if s[i] != s[n-1-i]:\n                break\n        else:\n            max_k = k\n\n    return max_k\n"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    g_list = list(map(int, input_list[1].split()))\n    g_list.sort(reverse=True)\n    max_gold = 0\n    for gold in g_list:\n        max_gold += gold\n        if max_gold > 5000:\n            break\n    return str(max_gold)\n"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, visited, adj, max_gold, visited_gold, curr_gold):\n        visited[v] = True\n        visited_gold[v] = max(visited_gold[v], curr_gold)\n\n        for neighbor in adj[v]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, adj, max_gold, visited_gold, max(curr_gold, max_gold[v]))\n\n    def find_max_gold(adj, max_gold):\n        max_gold = [0] * n\n        for i in range(1, n):\n            dfs(i, [False] * n, adj, max_gold, [0] * n, 0)\n        return max_gold[2]\n\n    n, m = map(int, stdin.readline().split())\n    max_gold = list(map(int, stdin.readline().split()))\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n\n    max_gold_from_bandit = find_max_gold(adj, max_gold)\n    return max_gold_from_bandit\n"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_roads(m: int, villages: List[int]) -> List[Tuple[int, int]]:\n        roads = []\n        for _ in range(m):\n            a, b = map(int, stdin.readline().split())\n            roads.append((a, b))\n        return roads\n\n    def dfs(graph: List[List[int]], start: int, visited: List[bool], current_gold: int, current_path: List[int]) -> int:\n        max_gold = 0\n        for neighbor, road_cost in enumerate(graph[start]):\n            if not visited[neighbor] and road_cost <= current_gold:\n                next_path = current_path.copy()\n                next_path.append(neighbor)\n                max_gold = max(max_gold, dfs(graph, neighbor, visited, current_gold - road_cost, next_path))\n        visited[start] = True\n        return max_gold\n\n    def max_gold_robber(villages: List[int], roads: List[Tuple[int, int]], start: int, end: int) -> int:\n        n = len(villages)\n        graph = [[float('inf')] * n for _ in range(n)]\n        for a, b in roads:\n            graph[a - 1][b - 1] = 1\n            graph[b - 1][a - 1] = 1\n\n        max_gold = 0\n        for i in range(1, n):\n            max_gold = max(max_gold, dfs(graph, i, [False] * n, villages[i], [i]))\n\n        return max_gold\n\n    n, m = map(int, stdin.readline().split())\n    gold = list(map(int, stdin.readline().split()))\n    roads = get_roads(m, gold)\n\n    max_gold = max_gold_robber(gold, roads, 2, n)\n    return max_gold"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def max_gold(graph, visited, start, end):\n        max_gold = 0\n        stack = [(start, 0)]\n        while stack:\n            vertex, gold = stack.pop()\n            if visited[vertex]:\n                continue\n            visited[vertex] = True\n            if vertex == end:\n                max_gold = max(max_gold, gold)\n            for neighbor in graph[vertex]:\n                stack.append((neighbor, gold + graph[vertex][neighbor]))\n        return max_gold\n\n    n, m = map(int, stdin.split()[:2])\n    graph = {i: {} for i in range(1, n + 1)}\n    gold = list(map(int, stdin.split()[2:n+2]))\n    for i in range(n - 1):\n        a, b = map(int, stdin.split()[n + 2 + i * 2:n + 2 + (i + 1) * 2])\n        graph[a][b] = gold[b - 1]\n        graph[b][a] = gold[a - 1]\n    max_steal = 0\n    for i in range(2, n):\n        for j in range(1, n):\n            if j == i:\n                continue\n            for k in range(j + 1, n):\n                if k == i:\n                    continue\n                if j in graph[i] and k in graph[i] and graph[i][j] + graph[i][k] <= max_steal:\n                    continue\n                for path in graph:\n                    visited = {x: False for x in range(1, n + 1)}\n                    max_steal = max(max_steal, max_gold(graph, visited, path, k))\n    return max_steal\n"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m = map(int, input_data[0].split())\n    gold_values = list(map(int, input_data[1].split()))\n    roads = [tuple(map(int, input_data[i].split())) for i in range(2, 2 + m)]\n    \n    # Initialize the distance and parent arrays\n    distance = [-1] * (n + 1)\n    parent = [-1] * (n + 1)\n    distance[1] = 0\n    \n    # Dijkstra's algorithm to find the shortest distance to each village\n    queue = [(0, 1)]\n    while queue:\n        (cost, current) = heapq.heappop(queue)\n        if distance[current] < cost:\n            continue\n        for neighbor, road_cost in [roads[i] for i, r in enumerate(roads) if r[0] == current]:\n            new_cost = cost + road_cost\n            if distance[neighbor] < 0 or new_cost < distance[neighbor]:\n                distance[neighbor] = new_cost\n                parent[neighbor] = current\n                heapq.heappush(queue, (new_cost, neighbor))\n    \n    # Calculate the maximum amount of gold that can be stolen\n    max_gold = 0\n    for i in range(2, n):\n        max_distance = max(distance[j] for j in range(2, n) if distance[j] >= 0)\n        max_gold += gold_values[i] * (max_distance // distance[i])\n    \n    return max_gold\n"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    gold = list(map(int, input().split()))\n    adj_list = [[] for _ in range(n)]\n    \n    for _ in range(m):\n        a, b = map(int, input().split())\n        adj_list[a-1].append(b-1)\n        adj_list[b-1].append(a-1)\n    \n    graph = Graph(adj_list)\n    shortest_paths = []\n    \n    for i in range(1, n):\n        shortest_paths.append(graph.shortest_path_length(0, i))\n    \n    max_gold = max(gold[2:])\n    \n    for gold_amount in range(max_gold, 0, -1):\n        for path in shortest_paths:\n            if path >= gold_amount:\n                continue\n            else:\n                break\n        else:\n            return gold_amount\n    \n    return 0\n\nclass Graph:\n    def __init__(self, adj_list: list):\n        self.adj_list = adj_list\n        self.visited = [False] * len(self.adj_list)\n        self.parent = [None] * len(self.adj_list)\n    \n    def shortest_path_length(self, start: int, end: int) -> int:\n        if start == end:\n            return 0\n        \n        self.visited = [False] * len(self.adj_list)\n        self.parent = [None] * len(self.adj_list)\n        \n        self.bfs(start, end)\n        \n        if self.parent[end] is None:\n            return -1\n        \n        path = []\n        current = end\n        \n        while current is not None:\n            path.append(current)\n            current = self.parent[current]\n        \n        return len(path) - 1\n    \n    def bfs(self, start: int, end: int):\n        queue = [start]\n        self.visited[start] = True\n        \n        while queue:\n            current = queue.pop(0)\n            \n            if current == end:\n                return True\n            \n            for neighbor in self.adj_list[current]:\n                if not self.visited[neighbor]:\n                    self.visited[neighbor] = True\n                    self.parent[neighbor] = current\n                    queue.append(neighbor)\n                    \n        return False"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list[0].split())\n    gold_list = list(map(int, input_list[1].split()))\n    road_list = [list(map(int, input_list[i].split())) for i in range(2, m + 2)]\n\n    # Create a graph with the given roads\n    graph = [[0] * n for _ in range(n)]\n    for road in road_list:\n        a, b = road\n        graph[a - 1][b - 1] = 1\n        graph[b - 1][a - 1] = 1\n\n    # Find the maximum amount of gold that the bandits can steal\n    # and still get safely home using the shortest path algorithm\n    max_gold = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and graph[i][j]:\n                # Calculate the shortest path length between i and j\n                dist = [-1] * n\n                dist[i] = 0\n                for k in range(n):\n                    for a, b in enumerate(graph[k]):\n                        if b and dist[k] != -1 and (dist[a] == -1 or dist[a] > dist[k] + 1):\n                            dist[a] = dist[k] + 1\n\n                # Calculate the maximum amount of gold that the bandits can steal\n                # while still getting safely home on the shortest path\n                if dist[j] != -1 and dist[j] <= 2:\n                    max_gold = max(max_gold, gold_list[j])\n\n    return str(max_gold)\n"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, gold, roads = None, None, [], []\n    for i, line in enumerate(stdin.split('\\n')):\n        if i == 0:\n            n, m = map(int, line.split())\n        elif i <= n:\n            gold.append(int(line))\n        else:\n            a, b = map(int, line.split())\n            roads.append((a, b))\n\n    graph = {i: [] for i in range(1, n+1)}\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(curr, visited):\n        visited[curr] = True\n        for neighbor in graph[curr]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n\n    # Find all connected components in the graph\n    visited = [False] * (n+1)\n    dfs(1, visited)\n    components = [[] for _ in range(visited.count(False))]\n    visited = [False] * (n+1)\n    for i in range(1, n+1):\n        if not visited[i]:\n            components[-1].append(i)\n            dfs(i, visited)\n\n    # Find the maximum amount of gold that can be stolen from each connected component\n    max_gold = [0] * len(components)\n    for i, component in enumerate(components):\n        for village in component:\n            if village != 1:\n                max_gold[i] = max(max_gold[i], gold[village-1])\n\n    # Compute the maximum amount of gold that can be stolen from all connected components and still get safely home\n    max_sum = sum(max_gold)\n    for i in range(1, n-1):\n        for j in range(len(components)):\n            if i in components[j]:\n                max_sum = min(max_sum, gold[i-1])\n                break\n\n    return str(max_sum)"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, m = map(int, input_list[0].split())\n    gold_list = list(map(int, input_list[1].split()))\n    road_list = [list(map(int, input_list[i+2].split())) for i in range(m)]\n\n    graph = [[False] * n for _ in range(n)]\n    for road in road_list:\n        a, b = road\n        graph[a-1][b-1] = True\n        graph[b-1][a-1] = True\n\n    def dfs(node, visited, gold):\n        if visited[node]:\n            return gold\n        visited[node] = True\n        for i in range(n):\n            if graph[node][i]:\n                gold = max(gold, dfs(i, visited, gold + gold_list[i+2]))\n        return gold\n\n    gold = dfs(0, [False] * n, 0)\n    return str(gold)"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    gold_list = list(map(int, input_list[1].split()))\n    adjacency_list = {}\n\n    for _ in range(2, len(input_list)):\n        u, v = map(int, input_list[_].split())\n        if u not in adjacency_list:\n            adjacency_list[u] = [v]\n        else:\n            adjacency_list[u].append(v)\n        if v not in adjacency_list:\n            adjacency_list[v] = [u]\n        else:\n            adjacency_list[v].append(u)\n\n    graph = Graph(n, adjacency_list)\n    bandit_home = 1\n    path = [bandit_home]\n    visited = set([bandit_home])\n\n    for _ in range(n - 1):\n        path.append(graph.get_neighbor(path[-1]))\n        visited.add(path[-1])\n\n    max_gold = sum(gold_list[2:]) - sum(gold_list[path[1]:path[2]])\n    for i in range(len(path) - 2):\n        gold_path = sum(gold_list[path[i]:path[i + 1]])\n        max_gold = max(max_gold, gold_path - sum(gold_list[path[i + 1]:path[i + 2]]))\n\n    return max_gold\n\n\nclass Graph:\n    def __init__(self, n, adjacency_list):\n        self.n = n\n        self.adjacency_list = adjacency_list\n\n    def get_neighbor(self, node):\n        neighbors = self.adjacency_list[node]\n        for neighbor in neighbors:\n            if neighbor not in self.visited:\n                return neighbor\n        return None\n\n\ndef"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def longest_increasing_subsequence(sequence: list) -> int:\n        n = len(sequence)\n        dp = [1] * n\n        for i in range(n):\n            for j in range(i):\n                if sequence[i] > sequence[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    n = int(stdin.split(\"\\n\")[0])\n    sequence = list(map(int, stdin.split(\"\\n\")[1].split()))\n    critical_elements = []\n\n    for i in range(n):\n        if longest_increasing_subsequence(sequence[:i] + sequence[i+1:]) < longest_increasing_subsequence(sequence[:i] + sequence[i+1:i+1] + sequence[i+2:]):\n            critical_elements.append(sequence[i])\n\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(str(element) for element in critical_elements)\n"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    seq = list(map(int, stdin.split(\"\\n\")[1].split()))\n    \n    if n == 1:\n        return \"-1\"\n    \n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if seq[i] > seq[j]:\n                dp[i] = max(dp[i], dp[j]+1)\n    \n    critical_elements = []\n    \n    for i in range(n):\n        for j in range(i):\n            if seq[i] < seq[j] and dp[i] <= dp[j]:\n                critical_elements.append(seq[i])\n    \n    if len(critical_elements) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(str(x) for x in sorted(critical_elements))"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    sequence = list(map(int, input_list[1].split()))\n    \n    # create a list to store the LIS length of each element\n    lis_length = [1] * n\n    \n    # iterate through the sequence to update the LIS length of each element\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j] and lis_length[i] < lis_length[j] + 1:\n                lis_length[i] = lis_length[j] + 1\n                \n    # find all critical elements\n    critical_elements = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if sequence[j] > sequence[i] and lis_length[i] < lis_length[j]:\n                critical_elements.append(sequence[i])\n                break\n                \n    # return critical elements in ascending order or -1 if none found\n    if len(critical_elements) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical_elements))) "
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    sequence = list(map(int, input_list[1].split()))\n    \n    if n == 1:\n        return \"-1\"\n\n    lis = []\n    lis_length = 1\n\n    for i in range(1, n):\n        if sequence[i] > sequence[lis_length - 1]:\n            lis_length += 1\n            lis.append(sequence[i])\n        else:\n            j = bisect_left(lis, sequence[i], 0, lis_length)\n            lis[j] = sequence[i]\n\n    critical_elements = sorted(set(sequence) - set(lis))\n\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, critical_elements))\n"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n\n    def lis_length(sequence):\n        n = len(sequence)\n        dp = [1] * n\n        for i in range(n):\n            for j in range(i):\n                if sequence[j] < sequence[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    lis_length_value = lis_length(sequence)\n    critical_elements = []\n    for i in range(n):\n        if sequence[:i] + sequence[i+1:] == sorted(sequence)[:i] + sorted(sequence)[i+1:]:\n            critical_elements.append(sequence[i])\n\n    if critical_elements:\n        return \" \".join(map(str, critical_elements))\n    else:\n        return \"-1\""
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def lis(seq):\n        n = len(seq)\n        tails = [0] * n\n        length = 0\n        for x in seq:\n            i, j = 0, length\n            while i != j:\n                m = (i + j) // 2\n                if tails[m] < x:\n                    i = m + 1\n                else:\n                    j = m\n            tails[i] = x\n            length = max(length, i + 1)\n        return length\n\n    n = int(stdin.splitlines()[0])\n    seq = list(map(int, stdin.splitlines()[1].split()))\n\n    critical_elements = []\n    for i in range(n):\n        if lis(seq[:i] + seq[i+1:]) < lis(seq[:i] + seq[i+1:i] + seq[i+2:]):\n            critical_elements.append(seq[i])\n\n    if critical_elements:\n        return ' '.join(map(str, sorted(critical_elements)))\n    else:\n        return '-1'\n"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n    lis = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n\n    critical = []\n    for i in range(n):\n        if lis[i] == 1:\n            critical.append(sequence[i])\n\n    if not critical:\n        return \"-1\"\n    return \" \".join(map(str, sorted(critical)))\n"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    sequence = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    if n == 1:\n        return \"-1\"\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    critical_elements = set()\n    for i in range(n):\n        for j in range(n):\n            if sequence[j] > sequence[i] and dp[i] == dp[j] + 1:\n                critical_elements.add(sequence[i])\n                break\n\n    if not critical_elements:\n        return \"-1\"\n\n    return \" \".join(map(str, sorted(critical_elements)))\n"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    sequence = list(map(int, input_list[1].split()))\n    critical_elements = []\n    for i in range(n):\n        if sequence[i] > sequence[i+1:]:\n            critical_elements.append(sequence[i])\n    if critical_elements:\n        return ' '.join(map(str, critical_elements))\n    else:\n        return '-1'\n\n\ndef"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def longest_increasing_subsequence(sequence: list) -> int:\n        n = len(sequence)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if sequence[i] > sequence[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    n = int(stdin.split('\\n')[0])\n    sequence = list(map(int, stdin.split('\\n')[1].split()))\n    if longest_increasing_subsequence(sequence) == n:\n        return \"-1\"\n    else:\n        critical_elements = []\n        for i in range(n):\n            if longest_increasing_subsequence(sequence[:i] + sequence[i+1:]) < n:\n                critical_elements.append(sequence[i])\n        return \" \".join(map(str, sorted(critical_elements)))"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list.pop(0).split())\n    mark = input_list[:n]\n\n    count = 0\n    for row in mark:\n        count += row.count('#')\n\n    return str(count)\n"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m = map(int, input_data.pop(0).split())\n    mark = [[char for char in line] for line in input_data]\n\n    count = 0\n    for row in mark:\n        count += row.count(\"#\")\n\n    return str(count)"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n, m = map(int, input_lines[0].split())\n    mark = input_lines[1:]\n\n    def count_nubs(stamp):\n        return sum(c == '#' for row in stamp for c in row)\n\n    def is_stampable(mark, stamp):\n        rows, cols = len(stamp), len(stamp[0])\n        for row in range(rows):\n            for col in range(cols):\n                if mark[row + row_offset][col + col_offset] == '.':\n                    continue\n                if stamp[row][col] == '#':\n                    return False\n        return True\n\n    min_nubs = float('inf')\n    for row_offset in range(n):\n        for col_offset in range(m):\n            if is_stampable(mark, [[stamp[row][col] for col in range(m)] for row in range(n)]):\n                min_nubs = min(min_nubs, count_nubs(stamp))\n\n    return str(min_nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    mark = lines[1:]\n\n    min_nubs = float('inf')\n    for i in range(n - 2):\n        for j in range(m):\n            if mark[i][j] == '#' and mark[i + 2][j] == '.':\n                min_nubs = min(min_nubs, 1)\n            if mark[i][j] == '#' and mark[i + 1][j] == '#':\n                min_nubs = min(min_nubs, 2)\n            if mark[i][j] == '#' and mark[i][j + 1] == '#':\n                min_nubs = min(min_nubs, 2)\n            if mark[i][j] == '#' and mark[i + 1][j + 1] == '#':\n                min_nubs = min(min_nubs, 2)\n            if mark[i][j] == '#' and mark[i + 2][j] == '#':\n                min_nubs = min(min_nubs, 2)\n\n    return str(min_nubs)\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_nubs(mark: str) -> int:\n        return mark.count('#')\n\n    def count_non_nubs(mark: str) -> int:\n        return mark.count('.')\n\n    def is_valid_mark(mark: str) -> bool:\n        return mark.replace('.', '').replace('#', '').isalpha()\n\n    def can_stamp(mark: str, nubs: int) -> bool:\n        return count_nubs(mark) <= nubs and count_non_nubs(mark) % 2 == 0\n\n    def find_min_nubs(mark: str, start: int) -> int:\n        nubs = start\n        while not can_stamp(mark, nubs):\n            nubs += 1\n        return nubs\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    mark = ''.join(lines[1:])\n\n    if not is_valid_mark(mark):\n        return \"Invalid mark\"\n\n    if count_nubs(mark) == 0:\n        return \"No nubs in mark\"\n\n    min_nubs = find_min_nubs(mark, 1)\n    return min_nubs"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_nubs(stamp_size: int, mark: str) -> int:\n        count = 0\n        for row in mark.split('\\n'):\n            count += row.count('#')\n        return count\n\n    def calculate_nubs(n: int, m: int, mark: str) -> int:\n        first_stamp_size = (n // 2) * (m // 2)\n        second_stamp_size = (n // 2 + 1) * (m // 2 + 1)\n        first_nubs = count_nubs(first_stamp_size, mark)\n        second_nubs = count_nubs(second_stamp_size, mark)\n        return min(first_nubs, second_nubs)\n\n    n, m = map(int, stdin.split('\\n')[0].split())\n    mark = '\\n'.join(stdin.split('\\n')[1:])\n\n    result = calculate_nubs(n, m, mark)\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    mark = stdin.split('\\n')[1:]\n\n    min_nubs = float('inf')\n\n    for i in range(n):\n        row = mark[i]\n        for j in range(m):\n            if row[j] == '#':\n                nubs = i * m + j + 2\n                min_nubs = min(min_nubs, nubs)\n\n    return str(min_nubs)\n"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_nubs(stamp: str, mark: str) -> int:\n        count = 0\n        for i in range(len(mark)):\n            if mark[i] == '#' and stamp[i] == '.':\n                count += 1\n        return count\n\n    def stamp_paper(stamp: str, mark: str) -> int:\n        marked_cells = set()\n        for i in range(len(mark)):\n            if mark[i] == '#' and stamp[i] == '.':\n                marked_cells.add((i // m, i % m))\n        return len(marked_cells)\n\n    def min_nubs(n, m):\n        if n == 1:\n            return m\n        elif n == 2:\n            return m + 1\n        else:\n            return min_nubs(n - 1, m) + min_nubs(n - 1, m + 1)\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    mark = ''.join(lines[1:n + 1])\n\n    stamps = [\n        \"..#..#.. .######. .######. ..#..#..\",\n        \"..#.. .###. .###. ..#..\",\n        \"..#..#.. .######. .######. ..#..#..\",\n    ]\n\n    min_count = float('inf')\n    for stamp in stamps:\n        count = stamp_paper(stamp, mark)\n        if count < min_count:\n            min_count = count\n\n    return min_count"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n, m = map(int, input_lines[0].split())\n    mark = input_lines[1:n+1]\n\n    nubs_per_stamp = 0\n    for row in mark:\n        nubs_per_stamp += row.count('#')\n\n    return nubs_per_stamp * 2\n\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list.pop(0).split())\n    mark = input_list\n    \n    # Create a matrix to store the marks\n    mark_matrix = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(mark[i][j])\n        mark_matrix.append(row)\n    \n    # Initialize variables\n    min_nubs = float('inf')\n    visited = set()\n    \n    # Helper function to find the minimum number of nubs\n    def find_min_nubs(x, y, visited, n, m):\n        nonlocal min_nubs\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        if x < 0 or x >= n or y < 0 or y >= m:\n            return\n        if mark_matrix[x][y] == '#':\n            min_nubs = min(min_nubs, 1)\n        find_min_nubs(x+1, y, visited, n, m)\n        find_min_nubs(x, y+1, visited, n, m)\n        find_min_nubs(x-1, y, visited, n, m)\n        find_min_nubs(x, y-1, visited, n, m)\n    \n    # Find the minimum number of nubs\n    find_min_nubs(0, 0, visited, n, m)\n    \n    return min_nubs\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m, p = map(int, stdin.split()[:3])\n    board = [[0] * m for _ in range(n)]\n    for i in range(n):\n        board[i] = list(map(int, stdin.split()[3+i*m:4+(i*m)]))\n\n    # Function to find the next move\n    def find_next_move(board):\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    return i, j\n        return None\n\n    # Function to make a move\n    def make_move(board, i, j):\n        board[i][j] = (board[i][j] + 1) % p\n        for x in range(n):\n            for y in range(m):\n                if x == i or y == j:\n                    board[x][y] = (board[x][y] + 1) % p\n\n    # Function to check if the board is won\n    def is_won(board):\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    return False\n        return True\n\n    # Function to find a winning sequence\n    def find_winning_sequence(board):\n        # Initialize variables\n        moves = []\n        next_move = find_next_move(board)\n\n        # Loop until the board is won\n        while next_move is not None and len(moves) < p * m * n:\n            moves.append(next_move[0] * m + next_move[1] + 1)\n            make_move(board, *next_move)\n            next_move = find_next_move(board)\n\n        # Check if the board is won\n        if is_won(board):\n            return moves\n        else:\n            return None\n\n    # Find a winning sequence\n    winning_sequence = find_winning_sequence(board)\n\n    # If a winning sequence exists, output it; otherwise, output -1\n    if winning_sequence is not None:\n        return len(winning_sequence), ' '.join(map(str, winning_sequence))\n    else:\n        return -1\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, p = map(int, input_list.pop(0).split())\n    board = [list(map(int, input_list.pop(0).split())) for _ in range(n)]\n\n    def next_move(x, y, step=1):\n        next_moves = [(x, y - 1), (x - 1, y), (x, y + 1), (x + 1, y)]\n        for dx, dy in next_moves:\n            if 0 <= dx < n and 0 <= dy < m:\n                board[dx][dy] = (board[dx][dy] + step - 1) % p + 1\n                if board[dx][dy] == p:\n                    board[dx][dy] = 1\n\n    def is_win():\n        return all(all(cell == p for cell in row) for row in board)\n\n    def solve():\n        for x in range(n):\n            for y in range(m):\n                if board[x][y] == p:\n                    next_move(x, y)\n                    if is_win():\n                        return 1\n                    else:\n                        next_move(x, y, p)\n                        if is_win():\n                            return p + 1\n                        else:\n                            next_move(x, y, p * 2)\n                            if is_win():\n                                return p * 2 + 1\n                            else:\n                                next_move(x, y, p * 3)\n                                if is_win():\n                                    return p * 3 + 1\n                                else:\n                                    next_move(x, y, p * 4)\n                                    if is_win():\n                                        return p * 4 + 1\n                                    else:\n                                        next_move(x, y, p * 5)\n                                        if is_win():\n                                            return p * 5 + 1\n                                        else:\n                                            next_move(x, y, p * 6)\n                                            if is_win():\n                                                return p * 6 + 1\n                                            else:\n                                                next_move(x, y, p * 7)\n                                                if is_win():\n                                                    return p * 7 + 1\n                                                else:\n                                                    next_move(x, y, p * 8)\n                                                    if is_win():\n                                                        return p * 8 + 1\n                                                    else:\n                                                        next_move(x, y, p * 9)\n                                                        if is_win():\n                                                            return p * 9 + 1\n                                                        else:\n                                                            next_move(x, y, p * 10)\n                                                            if is_win():\n                                                                return p * 10 + 1\n                                                            else:\n                                                                return -1\n        return -1\n\n    return str(solve())\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(board, row, col, val):\n        if val > p:\n            return False\n        for i in range(max(0, row-1), min(n, row+2)):\n            for j in range(max(0, col-1), min(m, col+2)):\n                if board[i][j] == val:\n                    return False\n        return True\n\n    def update_board(board, row, col, val):\n        for i in range(max(0, row-1), min(n, row+2)):\n            for j in range(max(0, col-1), min(m, col+2)):\n                board[i][j] = (board[i][j] + val - 1) % p + 1\n\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, stdin.split()[3+i*m:3+(i+1)*m])) for i in range(n)]\n    target = p*m*n\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == p:\n                update_board(board, i, j, 1)\n                moves = 1\n                queue = [(i, j, 1)]\n                while moves <= target and queue:\n                    row, col, val = queue.pop(0)\n                    if moves == target:\n                        return f\"{target}\\n\" + \" \".join(str(x) for x in [row+1, col+1, val]) + \" \" + \" \".join(str(x) for x in [row+1, col+2, val]) + \" \" + \" \".join(str(x) for x in [row+2, col+1, val]) + \" \" + \" \".join(str(x) for x in [row+2, col+2, val])\n                    if is_valid(board, row, col, val):\n                        update_board(board, row, col, val)\n                        moves += 1\n                        queue.append((row, col, val+1))\n                        if val == p:\n                            queue.append((row, col, 1))\n    return \"-1\"\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, input().split())\n    board = [[int(x) for x in input().split()] for _ in range(n)]\n\n    def next_move(board, x, y):\n        moves = []\n        for i in range(n):\n            if board[i][y] != p:\n                board[i][y] += 1\n                if board[i][y] == p + 1:\n                    board[i][y] = 1\n                moves.append((i, y))\n        for j in range(m):\n            if board[x][j] != p:\n                board[x][j] += 1\n                if board[x][j] == p + 1:\n                    board[x][j] = 1\n                moves.append((x, j))\n        return moves\n\n    def dfs(board, x, y, k):\n        if k > p * m * n:\n            return False\n        if board == [[p] * m for _ in range(n)]:\n            return True\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    board[i][j] = p + 1\n                    for move in next_move(board, i, j):\n                        if dfs(board, *move, k + 1):\n                            moves.append(i * m + j)\n                            return True\n                    board[i][j] = p\n                    if board[i][j] == p + 1:\n                        board[i][j] = 1\n        return False\n\n    moves = []\n    if dfs(board, 0, 0, 1):\n        return str(len(moves)) + '\\n' + ' '.join(map(str, moves))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, stdin.split()[3 + i * m:3 + (i + 1) * m])) for i in range(n)]\n\n    # Helper function to check if the board is won\n    def is_won(board):\n        return all(all(square == p for square in row) for row in board)\n\n    # Helper function to check if there is a winning sequence\n    def has_winning_sequence(board):\n        visited = set()\n\n        def dfs(board, row, col, depth):\n            if depth > p * m * n:\n                return False\n            if is_won(board):\n                return True\n            key = ''.join(str(square) for row in board for square in row)\n            if key in visited:\n                return False\n            visited.add(key)\n\n            if depth < p * m * n:\n                # Move up\n                if row > 0 and board[row - 1][col] != p:\n                    board[row][col] = p\n                    if dfs(board, row - 1, col, depth + 1):\n                        return True\n                    board[row][col] = p\n\n                # Move down\n                if row < n - 1 and board[row + 1][col] != p:\n                    board[row][col] = p\n                    if dfs(board, row + 1, col, depth + 1):\n                        return True\n                    board[row][col] = p\n\n                # Move left\n                if col > 0 and board[row][col - 1] != p:\n                    board[row][col] = p\n                    if dfs(board, row, col - 1, depth + 1):\n                        return True\n                    board[row][col] = p\n\n                # Move right\n                if col < m - 1 and board[row][col + 1] != p:\n                    board[row][col] = p\n                    if dfs(board, row, col + 1, depth + 1):\n                        return True\n                    board[row][col] = p\n\n            return False\n\n        # Try all starting positions\n        for row in range(n):\n            for col in range(m):\n                if board[row][col] != p:\n                    board[row][col] = p\n                    if dfs(board, row, col, 1):\n                        return True\n                    board[row][col] = 1\n\n        return False\n\n    # Check if there is a winning sequence\n    if has_winning_sequence(board):\n        # Find the winning sequence\n        sequence = []\n        for row in range(n):\n            for col in range(m):\n                if board[row][col] != p:\n                    board[row][col] = p\n                    if is_won(board):\n                        sequence.extend(f\"{row + 1} {col + 1}\" for col in range(m))\n                        break\n                    board[row][col] = 1\n            else:\n                continue\n            break\n        return len(sequence), sequence\n    else:\n        return -1"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]\n                    ]\n\n    # Function to check if the board is won\n    def is_won(board):\n        return all(all(cell == p for cell in row) for row in board)\n\n    # Function to count the number of moves\n    def count_moves(board):\n        return sum(sum(1 for cell in row if cell != p) for row in board)\n\n    # Function to update the board after a move\n    def update_board(board, move):\n        r, c = divmod(move - 1, m)\n        board[r][c] = p if board[r][c] == p else board[r][c] + 1\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] > p:\n                    board[i][j] = 1\n\n    # Function to find a winning sequence\n    def find_sequence(board):\n        moves = []\n        k = count_moves(board)\n        while not is_won(board) and k < p * n * m:\n            move = k + 1\n            update_board(board, move)\n            moves.append(move)\n            k += 1\n        return moves if is_won(board) else []\n\n    # Find a winning sequence\n    moves = find_sequence(board)\n\n    # Output the result\n    if moves:\n        return f\"{len(moves)}\\n\" + \" \".join(map(str, moves))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, input().split())\n    board = [list(map(int, input().split())) for _ in range(n)]\n\n    def win(board):\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    return False\n        return True\n\n    def bfs(board):\n        visited = set()\n        queue = [(tuple(board), 0)]\n        while queue:\n            board_state, moves = queue.pop(0)\n            if win(board_state):\n                return moves\n            if moves >= p * n * m:\n                continue\n            for i in range(n):\n                for j in range(m):\n                    new_board = [list(row) for row in board_state]\n                    for k in range(n):\n                        new_board[k][j] = (new_board[k][j] + 1) % (p + 1)\n                    new_board_state = tuple(tuple(row) for row in new_board)\n                    if new_board_state not in visited:\n                        visited.add(new_board_state)\n                        queue.append((new_board_state, moves + 1))\n        return -1\n\n    result = bfs(board)\n    return result\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def can_win(board, n, m, p):\n        visited = set()\n        def dfs(i, j, depth):\n            if depth > p * m * n:\n                return False\n            if (i, j) in visited:\n                return False\n            visited.add((i, j))\n            if board[i][j] == p:\n                board[i][j] = 1\n            else:\n                board[i][j] += 1\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= x < n and 0 <= y < m and board[x][y] != p:\n                    if dfs(x, y, depth + 1):\n                        return True\n            board[i][j] = p\n            visited.remove((i, j))\n            return False\n\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p and dfs(i, j, 0):\n                    return True\n        return False\n\n    def find_winning_sequence(board, n, m, p):\n        def dfs(i, j, depth, path):\n            if depth > p * m * n:\n                return\n            if depth % 2 == 0:\n                path.append((i, j))\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= x < n and 0 <= y < m and (x, y) not in visited:\n                    visited.add((x, y))\n                    dfs(x, y, depth + 1, path)\n                    visited.remove((x, y))\n\n        visited = set()\n        best_path = []\n        for i in range(n):\n            for j in range(m):\n                if (i, j) not in visited:\n                    visited.add((i, j))\n                    dfs(i, j, 0, best_path)\n                    visited.remove((i, j))\n        return best_path\n\n    lines = stdin.splitlines()\n    n, m, p = map(int, lines[0].split())\n    board = [[int(num) for num in lines[i+1].split()] for i in range(n)]\n\n    if can_win(board, n, m, p):\n        winning_path = find_winning_sequence(board, n, m, p)\n        return f\"{len(winning_path)}\\n\" + \" \".join(str(move) for move in winning_path)\n    else:\n        return \"-1\\n\"\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, p = map(int, input_list.pop(0).split())\n    board = []\n    for i in range(n):\n        board.append(list(map(int, input_list.pop(0).split())))\n\n    def get_neighbors(row, col):\n        neighbors = []\n        for i in range(max(0, row-1), min(n, row+2)):\n            for j in range(max(0, col-1), min(m, col+2)):\n                if (i != row or j != col):\n                    neighbors.append((i, j))\n        return neighbors\n\n    def make_move(board, row, col, value):\n        board[row][col] = (board[row][col] + value) % p\n        for neighbor_row, neighbor_col in get_neighbors(row, col):\n            board[neighbor_row][neighbor_col] = (board[neighbor_row][neighbor_col] + 1) % p\n\n    def is_winning(board):\n        for row in range(n):\n            for col in range(m):\n                if board[row][col] != p:\n                    return False\n        return True\n\n    def find_winning_sequence(board):\n        for row in range(n):\n            for col in range(m):\n                if board[row][col] != p:\n                    make_move(board, row, col, 1)\n                    if is_winning(board):\n                        return board, [(row, col)], 1\n                    board[row][col] = p\n                    for i in range(2, p+1):\n                        make_move(board, row, col, i)\n                        if is_winning(board):\n                            return board, [(row, col)], i\n                        board[row][col] = p\n        return None, None, None\n\n    winning_board, winning_moves, num_moves = find_winning_sequence(board)\n    if winning_board:\n        winning_moves_str = ' '.join(str(move[1]) for move in winning_moves)\n        return str(num_moves) + '\\n' + winning_moves_str\n    else:\n        return '-1'\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, p = map(int, input_list.pop(0).split())\n    board = [[0] * m for _ in range(n)]\n    k = 0\n\n    for i in range(n):\n        for j in range(m):\n            board[i][j] = int(input_list[i][j])\n\n    moves = []\n    while k < p * m * n and not all(all(x == p for x in row) for row in board):\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == p:\n                    board[i][j] = 1\n                else:\n                    board[i][j] += 1\n                if board[i][j] == p + 1:\n                    moves.append(k + 1)\n                    k += 1\n                    board[i][j] = 1\n\n    if all(all(x == p for x in row) for row in board):\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == p:\n                    moves.append(k + 1)\n                    k += 1\n                if k == p * m * n:\n                    break\n                board[i][j] += 1\n                if board[i][j] == p + 1:\n                    moves.append(k + 1)\n                    k += 1\n                    board[i][j] = 1\n                if k == p * m * n:\n                    break\n\n    if k == p * m * n:\n        return str(k) + '\\n' + ' '.join(str(x) for x in moves)\n    else:\n        return -1\n"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_ancestors(v: int) -> set:\n        ancestors = set()\n        while v != -1:\n            ancestors.add(v)\n            v = parents.get(v, -1)\n        return ancestors\n\n    N = int(stdin[0])\n    labels = [int(x) for x in stdin[1:N + 1]]\n    parents = {}\n    for i in range(2, N + 1):\n        parent = int(stdin[i]) - 1\n        parents[i - 1] = parent\n\n    max_length = 0\n    longest_paths = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if labels[i] <= labels[j]:\n                path_1 = get_ancestors(i)\n                path_2 = get_ancestors(j)\n                common_ancestors = path_1.intersection(path_2)\n                if len(common_ancestors) > max_length:\n                    max_length = len(common_ancestors)\n                    longest_paths = [common_ancestors]\n                elif len(common_ancestors) == max_length:\n                    longest_paths.append(common_ancestors)\n\n    mod = 11092019\n    num_paths = 0\n    for path in longest_paths:\n        num_paths += 1\n    num_paths %= mod\n\n    return f\"{max_length} {num_paths}\"\n"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, parent: int, labels: List[int], visited: Set[int], stack: List[int], path: List[int]):\n        visited.add(node)\n        stack.append(node)\n        path.append(node)\n        for child in graph[node]:\n            if child != parent:\n                dfs(child, node, labels, visited, stack, path)\n        path.pop()\n        if len(path) > 1:\n            for i in range(len(path) - 1):\n                if labels[path[i]] < labels[path[i + 1]]:\n                    return len(path) - 1\n        if len(path) == 1:\n            non_increasing_path = True\n            for i in range(len(path) - 1):\n                if labels[path[i]] >= labels[path[i + 1]]:\n                    non_increasing_path = False\n                    break\n            if non_increasing_path:\n                return len(path)\n        stack.pop()\n        while len(stack) > 0 and labels[node] >= labels[stack[-1]]:\n            path.pop()\n            if len(path) == 1:\n                return 1\n            if len(path) > 1:\n                for i in range(len(path) - 1):\n                    if labels[path[i]] < labels[path[i + 1]]:\n                        return len(path) - 1\n            stack.pop()\n            path.pop()\n        return 0\n\n    def jumping_paths(node: int, labels: List[int], visited: Set[int], stack: List[int], path: List[int], length: int) -> int:\n        visited.add(node)\n        stack.append(node)\n        path.append(node)\n        if length > 1:\n            for child in graph[node]:\n                if child != parent:\n                    jumping_paths(child, labels, visited, stack, path, length - 1)\n            path.pop()\n            stack.pop()\n            while len(stack) > 0 and labels[node] >= labels[stack[-1]]:\n                path.pop()\n                stack.pop()\n            return 0\n        else:\n            non_increasing_path = True\n            for i in range(len(path) - 1):\n                if labels[path[i]] >= labels[path[i + 1]]:\n                    non_increasing_path = False\n                    break\n            if non_increasing_path:\n                return 1\n            else:\n                return 0\n\n    n = int(stdin.readline().strip())\n    labels = [int(x) for x in stdin.readline().strip().split()]\n    graph = {i: [] for i in range(1, n + 1)}\n    for i in range(2, n + 1):\n        p = int(stdin.readline().strip())\n        graph[p].append(i)\n\n    max_path_length = 0\n    jumping_paths_count = 0\n    visited = set()\n    for root in range(1, n + 1):\n        if root not in visited:\n            stack = []\n            path = []\n            path_length = dfs(root, -1, labels, visited, stack, path)\n            max_path_length = max(max_path_length, path_length)\n            jumping_paths_count += jumping_paths(root, labels, visited, stack, path, path_length)\n\n    max_path_length %= 11092019\n    jumping_paths_count %= 11092019\n\n    return f\"{max_path_length} {jumping_paths_count}\" "
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(root: int, parent: int, labels: List[int], visited: List[bool], path: List[int], path_labels: List[int], longest_path_length: int, longest_path: List[int], count: int, mod: int) -> int:\n        visited[root] = True\n        path.append(root)\n        path_labels.append(labels[root])\n        if len(path) > 1 and path_labels[-2] < path_labels[-1]:\n            longest_path_length = max(longest_path_length, len(path))\n            if len(path) == longest_path_length:\n                longest_path.extend(path)\n                count += 1\n                count %= mod\n        for child in range(1, N+1):\n            if not visited[child] and child != parent:\n                count = dfs(child, root, labels, visited, path, path_labels, longest_path_length, longest_path, count, mod)\n        path.pop()\n        path_labels.pop()\n        visited[root] = False\n        return count\n\n    N, *labels = map(int, stdin.split())\n    parent = [-1] * (N+1)\n    visited = [False] * (N+1)\n    path = []\n    path_labels = []\n    longest_path_length = 0\n    longest_path = []\n    count = 0\n    for i in range(2, N+1):\n        parent[i] = int(stdin.split()[i-2])\n    count = dfs(1, 0, labels, visited, path, path_labels, longest_path_length, longest_path, count, 11092019)\n    return f\"{longest_path_length} {count}\""
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_ancestors(node: int) -> set:\n        ancestors = set()\n        current = node\n        while current != -1:\n            ancestors.add(current)\n            current = parent[current]\n        return ancestors\n\n    def is_nondecreasing(path: list) -> bool:\n        for i in range(len(path) - 1):\n            if u[path[i]] > u[path[i + 1]]:\n                return False\n        return True\n\n    def count_jumping_paths(path: list) -> int:\n        nonlocal count\n        if len(path) == L:\n            count += 1\n            return\n\n        for vertex in vertices:\n            if vertex not in get_ancestors(path[-1]):\n                count_jumping_paths(path + [vertex])\n\n    N = int(stdin.split('\\n')[0])\n    u = [int(x) for x in stdin.split('\\n')[1:N + 1]]\n    parent = [-1] * N\n    vertices = set(range(N))\n    L = 0\n\n    for i in range(2, N + 1):\n        parent[i - 1] = int(stdin.split('\\n')[i]) - 1\n\n    for path_length in range(2, N + 1):\n        if any(u[a] > u[b] for a, b in combinations(vertices, path_length) if parent[a] == parent[b]):\n            break\n        L = path_length\n\n    count = 0\n    for vertex in vertices:\n        count_jumping_paths([vertex])\n\n    M = count % 11092019\n    return f\"{L} {M}\" "
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from math import inf\n    N = int(stdin.splitlines()[0])\n    labels = [int(x) for x in stdin.splitlines()[1:N+1]]\n    adj_list = defaultdict(list)\n    for line in stdin.splitlines()[N+1:]:\n        parent, child = map(int, line.split())\n        adj_list[parent].append(child)\n    \n    def dfs(v: int, u: int, visited: set, path: list, path_labels: list) -> tuple:\n        if v == 1:\n            path_labels.append(u)\n            visited.add(1)\n            return 1, path_labels\n        \n        max_len = 0\n        max_path_labels = []\n        for child in adj_list[v]:\n            if child not in visited:\n                len_path, path_labels = dfs(child, u, visited, path + [v], path_labels)\n                if len_path > max_len:\n                    max_len = len_path\n                    max_path_labels = path_labels\n        return max_len, max_path_labels\n    \n    max_len, max_path_labels = dfs(1, inf, set(), [], [])\n    for i in range(max_len):\n        for j in range(i+1, max_len+1):\n            if all(labels[max_path_labels[k-1]] <= labels[max_path_labels[k]] for k in range(i, j)):\n                max_len = j\n                break\n    \n    M = 0\n    for i in range(max_len):\n        for j in range(i+1, max_len+1):\n            if all(labels[max_path_labels[k-1]] <= labels[max_path_labels[k]] for k in range(i, j)):\n                M += 1\n    \n    return f\"{max_len} {M % 11092019}\"\n\n\ndef"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    labels = list(map(int, stdin[1:N+1]))\n    tree = list(map(int, stdin[N+1:]))\n    max_len = 0\n    paths = []\n\n    def dfs(node: int, parent: int, path: list):\n        nonlocal max_len\n        path.append(node)\n        for child in range(N):\n            if tree[child] == node:\n                dfs(child, node, path)\n                if len(path) > max_len and labels[path[0]-1] <= labels[path[-1]-1]:\n                    paths.append(list(path))\n        if len(path) > max_len and labels[path[0]-1] <= labels[path[-1]-1]:\n            max_len = len(path)\n        path.pop()\n\n    dfs(0, -1, [])\n\n    mod = 11092019\n    modulo = pow(10, 9) + 7\n    count = sum(labels[path[0]-1] <= labels[path[-1]-1] for path in paths)\n    result = [max_len, count % mod]\n    return \" \".join(map(str, result)) "
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, parent: int) -> int:\n        max_label = u_labels[u]\n        for v in tree[u]:\n            if v != parent:\n                label = dfs(v, u)\n                if label > max_label:\n                    max_label = label\n        max_labels[u] = max_label\n        return max_label\n\n    def jumping_paths(u: int, parent: int) -> int:\n        paths = 0\n        for v in tree[u]:\n            if v != parent:\n                paths += jumping_paths(v, u)\n                if max_labels[u] <= max_labels[v]:\n                    paths += 1\n        return paths\n\n    N = int(stdin.split('\\n')[0])\n    u_labels = list(map(int, stdin.split('\\n')[1:N+1]))\n    tree = [[] for _ in range(N+1)]\n    max_labels = [0] * (N+1)\n\n    for i in range(2, N+1):\n        parent = int(stdin.split('\\n')[i].strip())\n        tree[parent].append(i)\n\n    dfs(1, -1)\n    L = max_labels[1]\n    M = jumping_paths(1, -1)\n    M = M % 11092019\n\n    return f\"{L} {M}\"\n\n\ninput_data = \"\"\"5\n3\n3\n3\n3\n3\n1\n2\n3\n4\n\"\"\"\n\nprint(solution(input_data))\n"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    u = [int(x) for x in stdin.split(\"\\n\")[1:N+1]]\n    p = [int(x) for x in stdin.split(\"\\n\")[N+1:]]\n    u.sort()\n\n    def dfs(node):\n        nonlocal max_jumping_path\n        nonlocal M\n        nonlocal prev\n        if node == -1:\n            return 0\n        if visited[node]:\n            return max_jumping_path\n        visited[node] = True\n        prev[node] = -1\n        max_length = 0\n        max_jumping_path_length = 0\n        for child in range(node+1, len(u)):\n            if u[child] >= u[node]:\n                break\n            if child in p[node]:\n                dfs(child)\n                if prev[child] == -1:\n                    max_jumping_path_length = max(max_jumping_path_length, 1)\n                    max_length = max(max_length, 1)\n                else:\n                    max_jumping_path_length = max(max_jumping_path_length, prev[child] + 1)\n                    max_length = max(max_length, prev[child] + 1)\n        if max_jumping_path_length > max_jumping_path:\n            max_jumping_path = max_jumping_path_length\n        if max_jumping_path_length == max_jumping_path and max_jumping_path % 3 == 0:\n            M = (M * 10439441) % 11092019\n        return max_length\n\n    visited = [False] * N\n    prev = [-1] * N\n    max_jumping_path = 0\n    M = 0\n    max_length = dfs(0)\n\n    return f\"{max_length} {M}\"\n"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    labels = list(map(int, stdin.split()[1:]))\n    parents = [0] * N\n    for i in range(2, N+1):\n        parents[i-1] = int(stdin.split()[-N+i-1])\n\n    def get_jumping_path(start: int, parent: int) -> List[int]:\n        if parent == -1:\n            return [start]\n        path = get_jumping_path(parent, parents[parent])\n        path.append(start)\n        return path\n\n    def dfs(node: int, parent: int, visited: Set[int], paths: List[List[int]]) -> int:\n        visited.add(node)\n        for child in range(1, N):\n            if child not in visited and parents[child] == node:\n                dfs(child, node, visited, paths)\n                for i in range(len(paths[-1]) - 1):\n                    for j in range(i + 1, len(paths[-1])):\n                        if paths[-1][i] > paths[-1][j]:\n                            paths.append(paths[-1][:j+1])\n        return len(paths[-1])\n\n    visited = set()\n    paths = []\n    max_length = dfs(1, -1, visited, paths)\n    longest_paths = [path for path in paths if len(path) == max_length]\n\n    remainder = 0\n    for path in longest_paths:\n        if all(labels[i] <= labels[j] for i, j in zip(path, path[1:])):\n            remainder += 1\n            remainder %= 11092019\n\n    return f\"{max_length} {remainder}\" "
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    labels = list(map(int, stdin.split(\"\\n\")[1:N]))\n    parents = [0] * (N + 1)\n    for i in range(2, N + 1):\n        parents[i] = int(stdin.split(\"\\n\")[i].split()[0])\n    adj = [[] for _ in range(N + 1)]\n    for i in range(2, N + 1):\n        adj[parents[i]].append(i)\n    max_len = 0\n    jp_count = 0\n    for i in range(1, N + 1):\n        stack = [(i, 1)]\n        visited = [False] * (N + 1)\n        visited[i] = True\n        while stack:\n            v, j = stack.pop()\n            if j > max_len:\n                max_len = j\n                jp_count = 0\n            if j == max_len:\n                jp_count += 1\n            for child in adj[v]:\n                if not visited[child]:\n                    visited[child] = True\n                    stack.append((child, j + 1))\n    result = str(max_len) + \" \" + str(jp_count % 11092019)\n    return result"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    node_info = [list(map(int, input_list[i+1].split())) for i in range(n)]\n\n    max_nodes = 0\n    for i in range(n):\n        if node_info[i][1] == 0:\n            max_nodes = max(max_nodes, i+1)\n        else:\n            for j in range(i+1, n):\n                if node_info[j][1] == i+1:\n                    max_nodes = max(max_nodes, min(i+1, j+1))\n                    break\n\n    return str(max_nodes)"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    node_values = [0] * (n + 1)\n    node_parents = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        node_values[i], node_parents[i] = map(int, stdin.split()[i])\n\n    def find_largest_subset(node_values, node_parents):\n        node_children = [[] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            node_children[node_parents[i]].append(i)\n\n        def dfs(node, visited):\n            for child in node_children[node]:\n                if child not in visited:\n                    visited.add(child)\n                    dfs(child, visited)\n\n        visited = set()\n        dfs(1, visited)\n\n        return visited\n\n    largest_subset = find_largest_subset(node_values, node_parents)\n    return len(largest_subset)"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    node_list = [list(map(int, input_list[i+1].split())) for i in range(n)]\n    \n    def dfs(node_idx: int, parent_idx: int) -> int:\n        max_value = node_list[node_idx][0]\n        count = 1\n        for child_idx in range(len(node_list)):\n            if node_list[child_idx][1] == node_idx:\n                count += dfs(child_idx, node_idx)\n                if count > n:\n                    return n\n                max_value = max(max_value, node_list[child_idx][0])\n        return count if max_value > node_list[parent_idx][0] else 0\n    \n    result = dfs(0, -1)\n    return str(result)"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    input_list = stdin.splitlines()[1:]\n    input_list = [list(map(int, line.split())) for line in input_list]\n\n    def find_parent(node_index: int) -> int:\n        return input_list[node_index][1]\n\n    def is_ancestor(node1_index: int, node2_index: int) -> bool:\n        while node2_index != 0:\n            if node1_index == node2_index:\n                return True\n            node2_index = find_parent(node2_index)\n        return False\n\n    max_nodes = 1\n    for node_index in range(1, n):\n        parent_index = find_parent(node_index)\n        if not is_ancestor(input_list[node_index][0], input_list[parent_index][0]):\n            max_nodes += 1\n\n    return str(max_nodes)"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_parent(node: int) -> int:\n        return node // 2 if node > 0 else 0\n\n    def is_ancestor(node1: int, node2: int) -> bool:\n        while node2 > 0:\n            if node1 == node2:\n                return True\n            node2 = get_parent(node2)\n        return False\n\n    def max_heapify(node: int, size: int) -> int:\n        left = 2 * node\n        right = 2 * node + 1\n        largest = node\n        if left <= size and not is_ancestor(node, left):\n            largest = left if v[left] > v[largest] else largest\n        if right <= size and not is_ancestor(node, right):\n            largest = right if v[right] > v[largest] else largest\n        return largest\n\n    n = int(stdin[0])\n    v = [0] * (n + 1)\n    p = [0] * (n + 1)\n    for i in range(1, n + 1):\n        v[i], p[i] = map(int, stdin[i].split())\n\n    size = n\n    max_heap_node = 1\n    while size > 1:\n        parent = max_heapify(max_heap_node, size)\n        if parent != max_heap_node:\n            v[max_heap_node], v[parent] = v[parent], v[max_heap_node]\n            p[max_heap_node], p[parent] = p[parent], p[max_heap_node]\n        max_heap_node = parent\n        size -= 1\n\n    count = 0\n    for i in range(1, n + 1):\n        if p[i] == 0:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    values = [0] * (n + 1)\n    parents = [0] * (n + 1)\n    max_size = 0\n    \n    for i in range(1, n + 1):\n        value, parent = map(int, stdin.split())\n        values[i] = value\n        parents[i] = parent\n    \n    def dfs(node, depth):\n        nonlocal max_size\n        if depth > max_size:\n            max_size = depth\n        \n        for child in range(1, n + 1):\n            if parents[child] == node:\n                dfs(child, depth + 1)\n                \n    dfs(1, 1)\n    return str(max_size)\n\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    nodes = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    values = [node[0] for node in nodes]\n    parents = [node[1] for node in nodes]\n\n    def find_ancestors(node: int) -> set:\n        ancestors = set()\n        while parents[node] != 0:\n            ancestors.add(node)\n            node = parents[node]\n        return ancestors\n\n    def is_heap(subset: set) -> bool:\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                if i in subset and j in subset:\n                    if not values[i] > values[j] or i in find_ancestors(j):\n                        return False\n        return True\n\n    max_size = 1\n    while max_size < n:\n        subset = set(range(max_size))\n        if is_heap(subset):\n            max_size += 1\n        else:\n            break\n\n    return str(max_size - 1)"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_heap_subset(nodes):\n        heap = [(node.value, node.index) for node in nodes]\n        max_heap = []\n        while heap:\n            value, index = heap.pop()\n            if not max_heap or value > max_heap[-1][1]:\n                max_heap.append((index, value))\n            else:\n                for i in range(len(max_heap)):\n                    if value > max_heap[i][1]:\n                        max_heap.insert(i, (index, value))\n                        break\n        return max_heap\n\n    def find_heap_nodes(nodes, max_heap):\n        heap_nodes = set()\n        for index, value in max_heap:\n            heap_nodes.add(nodes[index])\n        for node in nodes[1:]:\n            if node.parent not in heap_nodes:\n                heap_nodes.add(node)\n        return heap_nodes\n\n    def count_heap_nodes(nodes):\n        root = nodes[1]\n        queue = [root]\n        visited = set()\n        count = 0\n        while queue:\n            node = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                count += 1\n                for child in node.children:\n                    if child not in visited:\n                        queue.append(child)\n        return count\n\n    def read_input(stdin):\n        n = int(stdin.readline())\n        nodes = []\n        for i in range(1, n + 1):\n            value, parent = map(int, stdin.readline().split())\n            node = Node(value, parent)\n            nodes.append(node)\n            if parent:\n                nodes[parent].add_child(node)\n        return n, nodes\n\n    class Node:\n        def __init__(self, value, parent):\n            self.value = value\n            self.index = None\n            self.parent = parent\n            self.children = []\n\n        def add_child(self, child):\n            self.children.append(child)\n\n    n, nodes = read_input(stdin)\n    for i, node in enumerate(nodes):\n        node.index = i\n\n    max_heap = find_heap_subset(nodes)\n    heap_nodes = find_heap_nodes(nodes, max_heap)\n    heap_count = count_heap_nodes(nodes)\n\n    return heap_count"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    tree = {}\n    for i in range(1, n+1):\n        tree[i] = {'value': int(input_list[i].split()[0]), 'parent': int(input_list[i].split()[1])}\n\n    def dfs(node: int, visited: set) -> None:\n        if node in visited:\n            return\n        visited.add(node)\n        for child in tree[node]['children']:\n            dfs(child, visited)\n\n    def find_largest_heap_subset(root: int) -> int:\n        visited = set()\n        dfs(root, visited)\n        return len(visited)\n\n    largest_heap_subset_size = 0\n    for node in tree:\n        if tree[node]['parent'] == 0:\n            largest_heap_subset_size = max(largest_heap_subset_size, find_largest_heap_subset(node))\n\n    return largest_heap_subset_size\n"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_ancestors(node: int) -> set:\n        ancestors = set()\n        while node > 0:\n            ancestors.add(node)\n            node = tree[node]\n        return ancestors\n\n    n = int(stdin.splitlines()[0])\n    tree = [0] * (n + 1)\n    for line in stdin.splitlines()[1:]:\n        i, p = map(int, line.split())\n        tree[i] = p\n\n    max_size = 0\n    for i in range(2, n + 1):\n        ancestors = find_ancestors(i)\n        if all(tree[j] not in ancestors for j in ancestors if tree[j] > 0):\n            max_size = max(max_size, i)\n\n    return str(max_size)"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, node, color, visited, color_used):\n        visited[node] = True\n        if node in color_used:\n            color_used[node].add(color)\n        else:\n            color_used[node] = {color}\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(graph, neighbor, (color + 1) % n, visited, color_used)\n    \n    n = int(input())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b, c = map(int, input().split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n    \n    visited = [False] * n\n    color_used = {}\n    good_nodes = []\n    for node in range(n):\n        if not visited[node]:\n            dfs(graph, node, 0, visited, color_used)\n            if len(color_used[node]) == n - 1:\n                good_nodes.append(node)\n    \n    output = [str(len(good_nodes))] + [str(node) for node in good_nodes]\n    return '\\n'.join(output)"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    edges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    adj_list = [[] for _ in range(n)]\n\n    for a, b, c in edges:\n        adj_list[a - 1].append((b - 1, c))\n        adj_list[b - 1].append((a - 1, c))\n\n    def dfs(node: int, prev_color: int) -> bool:\n        for neighbor, color in adj_list[node]:\n            if color == prev_color:\n                return False\n            if not dfs(neighbor, color):\n                return False\n        return True\n\n    good_nodes = [i for i in range(n) if all(dfs(i, -1) for _ in range(1, n))]\n\n    return len(good_nodes), *good_nodes\n"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_adjacent(colors: list) -> bool:\n        for i in range(len(colors) - 1):\n            if colors[i] == colors[i + 1]:\n                return True\n        return False\n\n    def dfs(node: int, parent: int, colors: list, visited: set, result: list) -> None:\n        visited.add(node)\n        for neighbor, color in graph[node]:\n            if neighbor != parent:\n                if neighbor not in visited:\n                    dfs(neighbor, node, colors + [color], visited, result)\n                elif not is_adjacent(colors + [color]):\n                    result.append(node)\n\n    n = int(stdin.splitlines()[0])\n    graph = [[] for _ in range(n + 1)]\n    for line in stdin.splitlines()[1:]:\n        a, b, c = map(int, line.split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    result = []\n    for node in range(1, n + 1):\n        visited = set()\n        dfs(node, -1, [], visited, result)\n\n    return len(result), *sorted(result)\n\nn_good_nodes, *good_nodes = solution(input())\nprint(n_good_nodes)\nfor node in good_nodes:\n    print(node) "
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(u: int, v: int) -> bool:\n        queue = [(u, set([u]), u)]\n        while queue:\n            node, visited, parent = queue.pop(0)\n            for neighbor in adj[node]:\n                if neighbor == v:\n                    return True\n                if neighbor not in visited and neighbor != parent:\n                    queue.append((neighbor, visited | {neighbor}, node))\n        return False\n\n    def dfs(u: int, v: int) -> bool:\n        stack = [(u, u, set(), set())]\n        while stack:\n            parent, node, visited, colors = stack.pop()\n            if node == v:\n                return True\n            if node not in visited:\n                for neighbor, color in adj[node]:\n                    if color not in colors:\n                        if not dfs(parent, v):\n                            stack.append((parent, node, visited | {node}, colors | {color}))\n                            return True\n        return False\n\n    n, m = map(int, stdin.split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        adj[a].append((b, c))\n        adj[b].append((a, c))\n\n    good_nodes = []\n    for i in range(1, n + 1):\n        if all(bfs(i, j) or dfs(i, j) for j in range(1, n + 1) if i != j):\n            good_nodes.append(i)\n\n    k = len(good_nodes)\n    return f\"{k}\\n\" + \"\\n\".join(map(str, good_nodes))\n"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start, end):\n        queue = [(start, [])]\n        visited = set([start])\n        while queue:\n            node, path = queue.pop(0)\n            if node == end:\n                return path\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [node]))\n        return []\n\n    def is_rainbow(path):\n        colors = set()\n        for i in range(len(path) - 1):\n            colors.add(graph[path[i]][path[i + 1]])\n        return len(colors) == len(path) - 1\n\n    n, *edges = stdin.split('\\n')\n    n = int(n)\n    graph = {i: [] for i in range(1, n + 1)}\n    for edge in edges:\n        a, b, c = map(int, edge.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    good_nodes = []\n    for start in range(1, n + 1):\n        for end in range(1, n + 1):\n            if start == end:\n                continue\n            path = bfs(start, end)\n            if not path:\n                continue\n            if is_rainbow(path):\n                good_nodes.append(start)\n                break\n\n    return f\"{len(good_nodes)}\\n\" + \"\\n\".join(map(str, good_nodes))\n"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from itertools import permutations\n\n    def is_rainbow(path):\n        colors = set(map(lambda x: path[x - 1], edges[path[0]]))\n        for i in range(1, len(path)):\n            colors.remove(path[i - 1])\n            colors.add(path[i])\n        return len(colors) == len(path)\n\n    def is_good(node):\n        paths = []\n        for path in permutations(edges[node]):\n            if is_rainbow(path):\n                paths.append(path)\n        return len(paths) == len(set(map(tuple, paths)))\n\n    def find_good_nodes():\n        good_nodes = []\n        for node in range(1, n + 1):\n            if is_good(node):\n                good_nodes.append(node)\n        return good_nodes\n\n    def count_good_nodes(good_nodes):\n        k = len(good_nodes)\n        return f\"{k}\\n\" + \"\\n\".join(map(str, good_nodes))\n\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    edges = defaultdict(list)\n\n    for line in input_lines[1:]:\n        a, b, c = map(int, line.split())\n        edges[a].append(b)\n        edges[b].append(a)\n\n    good_nodes = find_good_nodes()\n    output = count_good_nodes(good_nodes)\n\n    return output"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    edges = []\n    for i in range(n - 1):\n        a, b, c = map(int, input().split())\n        edges.append((a, b, c))\n    \n    def dfs(node: int, color: int, good: bool) -> bool:\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor, neighbor_color in graph[node]:\n            if neighbor not in visited and dfs(neighbor, neighbor_color, good and color != neighbor_color):\n                return True\n        return good\n\n    graph = [[] for _ in range(n + 1)]\n    for a, b, c in edges:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    visited = set()\n    good_nodes = []\n    for i in range(1, n + 1):\n        if dfs(i, 0, True):\n            good_nodes.append(i)\n\n    print(len(good_nodes))\n    for node in good_nodes:\n        print(node)\n"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, parent: int, adj: list, colors: list, visited: list, path: list) -> bool:\n        if visited[node]:\n            return False\n        visited[node] = True\n        path.append(node)\n\n        for neighbor, color in adj[node]:\n            if neighbor != parent:\n                if not dfs(neighbor, node, adj, colors, visited, path) or colors[path[-2]] == color:\n                    return False\n\n        path.pop()\n        return True\n\n    def is_good_node(node: int, adj: list, colors: list) -> bool:\n        visited = [False] * len(colors)\n        visited[node] = True\n        for neighbor, _ in adj[node]:\n            if not visited[neighbor]:\n                if not dfs(neighbor, node, adj, colors, visited, []):\n                    return False\n        return True\n\n    def count_good_nodes(adj: list, colors: list) -> int:\n        good_nodes = 0\n        for i in range(len(colors)):\n            if is_good_node(i, adj, colors):\n                good_nodes += 1\n        return good_nodes\n\n    n, *edges = stdin.splitlines()\n    n = int(n)\n\n    adj = [[] for _ in range(n)]\n    colors = [0] * n\n\n    for a, b, c in map(lambda x: map(int, x.split()), edges):\n        adj[a - 1].append((b - 1, c))\n        adj[b - 1].append((a - 1, c))\n        colors[a - 1] = max(colors[a - 1], c)\n        colors[b - 1] = max(colors[b - 1], c)\n\n    good_nodes = count_good_nodes(adj, colors)\n\n    return f\"{good_nodes}\\n\" + \"\\n\".join(map(str, range(1, n + 1))) "
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, *edges = stdin.strip().split('\\n')\n    n = int(n)\n    adj = [[] for _ in range(n+1)]\n    for edge in edges:\n        a, b, c = map(int, edge.split())\n        adj[a].append((b, c))\n        adj[b].append((a, c))\n    good_nodes = [node for node in range(1, n+1) if is_good(adj, node)]\n    k = len(good_nodes)\n    result = [str(node) for node in good_nodes]\n    return f\"{k}\\n\" + \"\\n\".join(result)\n\ndef"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v: int, parent: int, adj: dict, color: dict, visited: set, good_nodes: list):\n        visited.add(v)\n        for w in adj[v]:\n            if w != parent:\n                if w not in visited:\n                    dfs(w, v, adj, color, visited, good_nodes)\n                if color[w] != color[v]:\n                    good_nodes.append(v)\n\n    n, *edges = stdin.split('\\n')\n    n = int(n)\n    adj = {i: [] for i in range(1, n + 1)}\n    color = {i: 0 for i in range(1, n + 1)}\n\n    for edge in edges:\n        a, b, c = map(int, edge.split())\n        adj[a].append(b)\n        adj[b].append(a)\n        color[b] = c\n\n    visited = set()\n    good_nodes = []\n\n    for v in adj:\n        if v not in visited:\n            dfs(v, -1, adj, color, visited, good_nodes)\n\n    k = len(good_nodes)\n    result = [str(good_node) for good_node in good_nodes]\n    return f\"{k}\\n\" + \"\\n\".join(result)\n"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_program(program: str) -> int:\n        instructions = program.split()\n        count = 0\n        for inst in instructions:\n            if inst[0] == 'R':\n                count += int(inst[1:])\n            else:\n                count += 1\n        return count\n\n    b, s = map(int, stdin.split()[0].split())\n    program = stdin.split()[1]\n    bank_count = s * b\n    instructions_count = parse_program(program)\n\n    if bank_count == 1:\n        return instructions_count\n\n    if bank_count == 2:\n        var_count = sum(1 for inst in program.split() if inst[0] == 'V')\n        if var_count == 0:\n            return instructions_count\n        elif var_count <= 2:\n            return 2 * instructions_count\n        else:\n            return 2 * instructions_count + var_count - 2\n\n    if bank_count == 3:\n        var_count = sum(1 for inst in program.split() if inst[0] == 'V')\n        if var_count == 0:\n            return instructions_count\n        elif var_count <= 2:\n            return 3 * instructions_count\n        else:\n            return 3 * instructions_count + var_count - 2\n\n    if bank_count == 4:\n        var_count = sum(1 for inst in program.split() if inst[0] == 'V')\n        if var_count == 0:\n            return instructions_count\n        elif var_count <= 4:\n            return 4 * instructions_count\n        else:\n            return 4 * instructions_count + var_count - 4\n\n    if bank_count == 5:\n        var_count = sum(1 for inst in program.split() if inst[0] == 'V')\n        if var_count == 0:\n            return instructions_count\n        elif var_count <= 4:\n            return 5 * instructions_count\n        else:\n            return 5 * instructions_count + var_count - 4\n\n    if bank_count == 6:\n        var_count = sum(1 for inst in program.split() if inst[0] == 'V')\n        if var_count == 0:\n            return instructions_count\n        elif var_count <= 6:\n            return 6 * instructions_count\n        else:\n            return 6 * instructions_count + var_count - 6\n\n    if bank_count == 7:\n        var_count = sum(1 for inst in program.split() if inst[0] == 'V')\n        if var_count == 0:\n            return instructions_count\n        elif var_count <= 6:\n            return 7 * instructions_count\n        else:\n            return 7 * instructions_count + var_count - 6\n\n    if bank_count == 8:\n        var_count = sum(1 for inst in program.split() if inst[0] == 'V')\n        if var_count == 0:\n            return instructions_count\n        elif var_count <= 8:\n            return 8 * instructions_count\n        else:\n            return 8 * instructions_count + var_count - 8\n\n    if bank_count == 9:\n        var_count = sum(1 for inst in program.split() if inst[0] == 'V')\n        if var_count == 0:\n            return instructions_count\n        elif var_count <= 9:\n            return 9 * instructions_count\n        else:\n            return 9 * instructions_count + var_count - 9\n\n    if bank_count == 10:\n        var_count = sum(1 for inst in program.split() if inst[0] == 'V')\n        if var_count == 0:\n            return instructions_count\n        elif var_count <= 10:\n            return 10 * instructions_count\n        else:\n            return 10 * instructions_count + var_count - 10\n\n    if bank_count == 11:\n        var_count = sum(1 for inst in program.split() if inst[0] == 'V')\n        if var_count == 0:\n            return instructions_count\n        elif var_"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, input().split())\n    program = input().split()\n\n    # Calculate the number of memory references and BSR register settings required\n    memory_refs = 0\n    bsr_set_ops = 0\n    for op in program:\n        if op.startswith(\"V\"):\n            memory_refs += 1\n        elif op.startswith(\"R\"):\n            _, n, inner_program = op.split()\n            n = int(n)\n            for _ in range(n):\n                memory_refs += len(inner_program.split())\n        else:\n            assert op.startswith(\"E\")\n\n    # Calculate the minimum number of instructions required\n    min_instructions = memory_refs + bsr_set_ops\n\n    return str(min_instructions)"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def parse_program(program: str, b: int, s: int) -> int:\n        instructions = program.split()\n        memory_refs = 0\n        bsr_set = False\n        for instr in instructions:\n            if instr[0] == 'R':\n                instr_len = int(instr[1:])\n                memory_refs += parse_program(program[instr_len + 1:], b, s)\n            elif instr[0] == 'V':\n                i = int(instr[1:])\n                memory_refs += 1\n                if not bsr_set and i > s:\n                    memory_refs += 1\n                    bsr_set = True\n        return memory_refs\n\n    b, s = map(int, stdin.splitlines()[0].split())\n    program = stdin.splitlines()[1]\n    return parse_program(program, b, s)\n"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, input().split())\n    program = input().split()\n    max_bank_size = b * s\n    \n    def evaluate(expr):\n        if expr[0] == 'R':\n            return int(expr[1])\n        elif expr[0] == 'V':\n            return 1\n        else:\n            return evaluate(program[int(expr[1:])])\n\n    def apply_repetition(count, program):\n        total_instructions = 0\n        for i in range(count):\n            total_instructions += apply_program(program)\n        return total_instructions\n\n    def apply_program(program):\n        total_instructions = 0\n        for expr in program:\n            if expr[0] == 'R':\n                total_instructions += evaluate(expr)\n            elif expr[0] == 'V':\n                total_instructions += 1\n        return total_instructions\n\n    total_instructions = 0\n    for i, expr in enumerate(program):\n        if expr[0] == 'R':\n            total_instructions += apply_repetition(evaluate(expr), program[i+1:])\n            break\n\n    return total_instructions"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    b, s = map(int, input().split())\n    program = input().split()\n\n    # Initialize variables\n    min_instructions = float('inf')\n    bsr_values = [None] * b\n    bank_sizes = [s] * b\n    bank_counts = [0] * b\n\n    # Helper functions\n    def is_repetition(op):\n        return op[0] == 'R'\n\n    def is_variable_reference(op):\n        return op[0] == 'V'\n\n    def get_variable_index(op):\n        return int(op[1:])\n\n    def get_repetition_count(op):\n        return int(op[1:])\n\n    def get_bsr_index(op):\n        return int(op[1:])\n\n    def get_bank_size(i):\n        return bank_sizes[i]\n\n    def get_bank_count(i):\n        return bank_counts[i]\n\n    def set_bsr(i):\n        if bsr_values[i] is None:\n            bsr_values[i] = i\n            bank_counts[i] += 1\n\n    def clear_bsr():\n        for i in range(b):\n            if bsr_values[i] is not None:\n                bsr_values[i] = None\n                bank_counts[i] = 0\n\n    # Process the program\n    for op in program:\n        if is_repetition(op):\n            count = get_repetition_count(op)\n            for _ in range(count):\n                min_instructions += 1\n                if is_variable_reference(op):\n                    i = get_variable_index(op)\n                    if bsr_values[i] is not None:\n                        min_instructions += 1\n                    else:\n                        for j in range(b):\n                            if bank_counts[j] == 0:\n                                min_instructions += 1\n                                bank_counts[j] = 1\n                                bank_sizes[j] -= 1\n                                if bank_sizes[j] == 0:\n                                    break\n        else:\n            min_instructions += 1\n            if is_variable_reference(op):\n                i = get_variable_index(op)\n                if bsr_values[i] is not None:\n                    min_instructions += 1\n                else:\n                    for j in range(b):\n                        if bank_counts[j] == 0:\n                            min_instructions += 1\n                            bank_counts[j] = 1\n                            bank_sizes[j] -= 1\n                            if bank_sizes[j] == 0:\n                                break\n\n    # Calculate and return the result\n    return min_instructions"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.splitlines()[0].split())\n    program = stdin.splitlines()[1].split()\n    \n    min_time = 0\n    banks = [[] for _ in range(b)]\n    \n    i = 0\n    while i < len(program):\n        if program[i] == 'R':\n            n, i = int(program[i+1]), i+2\n            min_time += n\n        elif program[i] == 'V':\n            var = int(program[i+1][1:])\n            bank = var // s\n            banks[bank].append(var % s)\n            i += 2\n        else:\n            i += 1\n    \n    min_time += 2 * len(banks)\n    \n    for bank in banks:\n        if bank:\n            min_time += 1\n    \n    return str(min_time)"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.splitlines()[0].split())\n    program = stdin.splitlines()[1].split()\n    variables = {}\n    bank_size = b * s\n    result = 0\n\n    for i, op in enumerate(program):\n        if op.startswith(\"V\"):\n            if variables.get(int(op[1:])) is None:\n                result += bank_size\n                variables[int(op[1:])] = result\n            result += 1\n        elif op.startswith(\"R\"):\n            n, inner_program = map(str, op[1:].split(\":\"))\n            n = int(n)\n            inner_program = inner_program.split()\n            for j, inner_op in enumerate(inner_program):\n                if inner_op.startswith(\"V\"):\n                    if variables.get(int(inner_op[1:])) is None:\n                        result += bank_size\n                        variables[int(inner_op[1:])] = result\n                    result += 1\n                elif inner_op.startswith(\"R\"):\n                    n2, inner_program2 = map(str, inner_op[1:].split(\":\"))\n                    n2 = int(n2)\n                    inner_program2 = inner_program2.split()\n                    for k, inner_op2 in enumerate(inner_program2):\n                        if inner_op2.startswith(\"V\"):\n                            if variables.get(int(inner_op2[1:])) is None:\n                                result += bank_size\n                                variables[int(inner_op2[1:])] = result\n                            result += 1\n                        elif inner_op2.startswith(\"R\"):\n                            n3, inner_program3 = map(str, inner_op2[1:].split(\":\"))\n                            n3 = int(n3)\n                            inner_program3 = inner_program3.split()\n                            for l, inner_op3 in enumerate(inner_program3):\n                                if inner_op3.startswith(\"V\"):\n                                    if variables.get(int(inner_op3[1:])) is None:\n                                        result += bank_size\n                                        variables[int(inner_op3[1:])] = result\n                                    result += 1\n            result += n\n\n    return str(result)\n\ndef"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    banks, variables = map(int, input_list[0].split())\n    program = input_list[1].split()\n\n    bank_size = banks * variables\n    references = [0] * bank_size\n    bsr = None\n    bsr_set = False\n\n    for item in program:\n        if item[0] == 'V':\n            index = int(item[1:])\n            if index <= bank_size:\n                references[index - 1] += 1\n        elif item[0] == 'R':\n            count = int(item[1:])\n            inner_program = program[program.index(item) + 1:program.index('E')]\n            for _ in range(count):\n                for inner_item in inner_program:\n                    if inner_item[0] == 'V':\n                        index = int(inner_item[1:])\n                        if index <= bank_size:\n                            references[index - 1] += 1\n                    elif inner_item[0] == 'R':\n                        count = int(inner_item[1:])\n                        inner_inner_program = inner_program[inner_program.index(inner_item) + 1:inner_program.index('E')]\n                        for __ in range(count):\n                            for inner_inner_item in inner_inner_program:\n                                if inner_inner_item[0] == 'V':\n                                    index = int(inner_inner_item[1:])\n                                    if index <= bank_size:\n                                        references[index - 1] += 1\n        elif item == 'E':\n            if bsr is None:\n                bsr_set = True\n            elif not bsr_set:\n                bsr = 0\n\n    if bsr is not None:\n        references[bsr] += 1\n\n    min_references = min(references)\n    return str(min_references + bsr_set)\n"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    b, s = map(int, input().split())\n    program = input().split()\n\n    # Initialize variables\n    banks = [[] for _ in range(b)]\n    variables = [None] * (b * s)\n    bank_select = None\n    min_instructions = 0\n\n    # Helper function to calculate the number of instructions\n    def count_instructions(program):\n        nonlocal bank_select\n        count = 0\n        for operation in program:\n            if operation.startswith('V'):\n                index = int(operation[1:]) - 1\n                count += 1\n                if variables[index] is not None:\n                    count += variables[index] // 8\n                else:\n                    count += b\n            elif operation.startswith('R'):\n                count += int(operation[1:])\n            elif operation.startswith('E'):\n                count += count_instructions(operation[2:])\n                if bank_select is not None:\n                    count += b\n                else:\n                    count += 1\n            elif operation == 'S':\n                count += 1\n                bank_select = 0\n        return count\n\n    # Calculate minimum instructions\n    min_instructions = count_instructions(program)\n\n    return str(min_instructions)"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def run_program(memory_banks, program):\n        bsr = None\n        for instruction in program:\n            if instruction.startswith(\"V\"):\n                var_id = int(instruction[1:])\n                if var_id <= memory_banks * stdin[1]:\n                    if bsr is None:\n                        yield var_id\n                    else:\n                        yield bsr * memory_banks + var_id\n            elif instruction.startswith(\"R\"):\n                count = int(instruction[1:].split(\" \")[0])\n                if count > 1:\n                    for _ in range(count - 1):\n                        yield \"R\"\n                program = instruction.split(\" \")[1:]\n                for instr in run_program(memory_banks, program):\n                    yield instr\n            elif instruction.startswith(\"E\"):\n                pass\n\n    memory_banks, stdin[1] = map(int, stdin[0].split())\n    program = stdin[1].split()\n    instructions = list(run_program(memory_banks, program))\n    return len(instructions)\n"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    min_X = 1\n    max_X = N\n    while min_X <= max_X:\n        mid = (min_X + max_X) // 2\n        if f(mid, B) == N:\n            return str(mid)\n        elif f(mid, B) < N:\n            min_X = mid + 1\n        else:\n            max_X = mid - 1\n    return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    if B < 2 or N < 0 or B > 10000 or N >= 2**63:\n        return \"impossible\"\n    X = 0\n    while f(X, B) != N:\n        if f(X, B) > N:\n            return \"impossible\"\n        X += 1\n    return X\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    def f(x):\n        return sum(int(d) for d in str(x))\n    for x in range(1, 2**63):\n        if f(x) == N:\n            return str(x)\n    return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n\n    def f(x, base=10):\n        return sum(int(digit) for digit in str(x))\n\n    if N == 0:\n        return \"impossible\"\n\n    for x in range(1, 2**63):\n        if f(x, B) == N:\n            return x\n\n    return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    X = N\n    while f(X, B) != N:\n        X += 1\n        if X >= 2**63:\n            return \"impossible\"\n    return X\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    X = 0\n    while f(X, B) < N:\n        X += 1\n    if f(X, B) == N:\n        return str(X)\n    else:\n        return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    X = 0\n\n    while f_B(X, B) < N:\n        X += 1\n\n    if f_B(X, B) == N:\n        return str(X)\n    else:\n        return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    X = 1\n    while f_B(B, X) < N:\n        X += 1\n    if f_B(B, X) == N:\n        return str(X)\n    else:\n        return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    \n    def base_10_to_B(n: int, b: int) -> int:\n        digits = []\n        while n > 0:\n            digits.append(n % b)\n            n //= b\n        return int(''.join(map(str, digits[::-1])))\n    \n    def f_B(x: int) -> int:\n        return sum(int(d) for d in str(x))\n    \n    for i in range(1, 2**63):\n        x_10 = base_10_to_B(i, B)\n        if f_B(x_10) == N:\n            return i\n    return \"impossible\"\n"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    digits = [int(d) for d in str(N)]\n    X = 0\n\n    for i in range(len(digits)):\n        X += digits[i] * B ** i\n\n    if X == N:\n        return str(X)\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def haversine_distance(lat1, lon1, lat2, lon2):\n        R = 6371  # Radius of the earth in km\n        dLat = math.radians(lat2 - lat1)\n        dLon = math.radians(lon2 - lon1)\n        a = (math.sin(dLat / 2) * math.sin(dLat / 2) +\n             math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *\n             math.sin(dLon / 2) * math.sin(dLon / 2))\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        d = R * c\n        return d * 1000  # Convert to meters\n\n    def closest_roof(distances):\n        closest = None\n        for i, roof in enumerate(roofs):\n            if closest is None or (distances[roof[0]] < distances[closest] and roof[1] >= distances[roof[0]]):\n                closest = i\n        return closest\n\n    def expected_rain(clouds, distances):\n        total_rain = 0\n        for cloud in clouds:\n            start, end, prob, amount = cloud\n            start_distance = distances[d]\n            end_distance = start_distance + (end - start) * 1000  # Convert to meters\n            if start_distance < start * 1000:\n                start_distance = start * 1000\n            if end_distance > end * 1000:\n                end_distance = end * 1000\n            total_prob = 0\n            for dist in range(int(start_distance), int(end_distance) + 1):\n                total_prob += prob * (distances[dist] <= dist)\n            total_rain += amount * total_prob\n        return total_rain\n\n    lines = stdin.splitlines()\n    d, t, c, r = map(int, lines[0].split())\n    clouds = [(int(line.split()[0]), int(line.split()[1]), float(line.split()[2]), int(line.split()[3])) for line in lines[1:c + 1]]\n    roofs = [(int(line.split()[0]), int(line.split()[1])) for line in lines[c + 1:]]\n    distances = [haversine_distance(51.477, -0.0015, 51.48, -0.0015 + i * 0.001) for i in range(d + 1)]\n    distances.append(d * 0.001)\n\n    time_left = t - d * 1000 / 1000 / 60 - 1\n    if time_left < 0:\n        return \"0\"\n\n    rain_per_second = 0\n    for cloud in clouds:\n        start, end, prob, amount = cloud\n        if start <= time_left < end:\n            rain_per_second += prob * amount * (time_left - start + 1)\n\n    roof_distances = [haversine_distance(51.477, -0.0015, 51.48, -0.0015 + i * 0.001) for i in range(d + 1)]\n    roof_distances.append(d * 0.001)\n    closest_roof_distance = min(roof_distances, key=lambda x: abs(x - distances[d]))\n    closest_roof = closest_roof(roof_distances)\n    roof_rain = expected_rain([clouds[closest_roof]], roof_distances)\n    time_to_roof = roof_distances[closest_roof] / 1000 / 60\n\n    total_rain = time_left * rain_per_second + time_to_roof * roof_rain\n    return f\"{total_rain:.5f}\"\n\ninput1 = \"\"\"20 60 2 1\n5 15 0.3333"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n        R = 6371\n        lat1_rad, lon1_rad, lat2_rad, lon2_rad = map(math.radians, [lat1, lon1, lat2, lon2])\n        dlat, dlon = lat2_rad - lat1_rad, lon2_rad - lon1_rad\n        a = math.sin(dlat / 2) ** 2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        return R * c\n\n    def load_clouds(lines: List[str]) -> List[Cloud]:\n        clouds = []\n        for line in lines:\n            s, e, p, a = map(float, line.split())\n            clouds.append(Cloud(s, e, p, a))\n        return clouds\n\n    def load_roof_segments(lines: List[str]) -> List[Tuple[int, int]]:\n        roof_segments = []\n        for line in lines:\n            x, y = map(int, line.split())\n            roof_segments.append((x, y))\n        return roof_segments\n\n    def compute_expected_rain(clouds: List[Cloud], roof_segments: List[Tuple[int, int]]) -> float:\n        def segment_distance(x: int, y: int) -> float:\n            return haversine_distance(x, 0, y, 0)\n\n        def roof_overlap(a: Tuple[int, int], b: Tuple[int, int]) -> bool:\n            a_start, a_end = a\n            b_start, b_end = b\n            if a_start <= b_end <= a_end:\n                return True\n            if b_start <= a_end <= b_end:\n                return True\n            if a_start <= b_start <= a_end:\n                return True\n            if b_start <= a_start <= b_end:\n                return True\n            return False\n\n        def segment_rain(x: int, y: int, cloud: Cloud) -> float:\n            distance = segment_distance(x, y)\n            return cloud.amount * min(cloud.duration, distance)\n\n        expected_rain = 0.0\n        covered_segments = set()\n        for cloud in clouds:\n            for roof_segment in roof_segments:\n                if roof_overlap(roof_segment, cloud.zip_code_range):\n                    x, y = roof_segment\n                    expected_rain += segment_rain(x, y, cloud)\n                    covered_segments.add(roof_segment)\n\n        for roof_segment in roof_segments:\n            if roof_segment not in covered_segments:\n                x, y = roof_segment\n                expected_rain += segment_rain(x, y, Cloud(0, 0, 1, 0))\n\n        return expected_rain\n\n    def compute_bus_stop_time(d: int, t: int, tt: int, tc: int) -> float:\n        return d / (100 * 1000)\n\n    def compute_expected_rain_with_roofs(d: int, t: int, tt: int, tc: int, r: int, clouds: List[Cloud], roof_segments: List[Tuple[int, int]]) -> float:\n        bus_stop_time = compute_bus_stop_time(d, t, tt, tc)\n        if bus_stop_time > tt:\n            return float('inf')\n        return compute_expected_rain(clouds, roof_segments)\n\n    def find_min_expected_rain(d: int, t: int, tt: int, tc: int, r: int, clouds: List[Cloud], roof_segments: List[Tuple[int, int]]) -> float:\n        def is_valid(expected_rain: float) -> bool:\n            return expected_rain >= 0 and expected_rain <="
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_rainfall(clouds, time):\n        total_rainfall = 0\n        for cloud in clouds:\n            if cloud[0] <= time <= cloud[1]:\n                total_rainfall += cloud[3] * cloud[2]\n        return total_rainfall\n\n    def calculate_roof_coverage(x, y, roofs, distance):\n        coverage = 0\n        for roof in roofs:\n            if roof[0] <= x <= roof[1]:\n                coverage += min(distance, roof[1]) - x\n        return coverage\n\n    def find_min_rainfall(clouds, time, distance, roofs):\n        min_rainfall = float('inf')\n        for i in range(distance + 1):\n            roof_coverage = calculate_roof_coverage(i, distance, roofs, distance)\n            rainfall = calculate_rainfall(clouds, time + i) - roof_coverage\n            min_rainfall = min(min_rainfall, rainfall)\n        return min_rainfall\n\n    lines = stdin.split('\\n')\n    d, t, c, r = map(int, lines[0].split())\n    clouds = [list(map(float, lines[i+1].split())) for i in range(c)]\n    roofs = [[int(x), int(y)] for x, y in (line.split() for line in lines[c+1:])]\n\n    time_to_bus_stop = t - d\n    if time_to_bus_stop <= 0:\n        return 0.0\n\n    min_rainfall = find_min_rainfall(clouds, time_to_bus_stop, d, roofs)\n    if min_rainfall <= 0:\n        return 0.0\n\n    return round(min_rainfall, 5)\n\n\ninput_1 = \"\"\"20 60 2 1\n5 15 0.33333 30\n22 60 0.66666 70\n0 10\"\"\"\noutput_1 = solution(input_1)\nprint(\"Sample Output 1:\", output_1)\n\ninput_2 = \"\"\"3 4 2 1\n1 3 0.25 8\n2 4 0.66667 15\n1 2\"\"\"\noutput_2 = solution(input_2)\nprint(\"Sample Output 2:\", output_2)\n\ninput_3 = \"\"\"3 4 1 0\n0 2 0.25 8\n\"\"\"\noutput_3 = solution(input_3)\nprint(\"Sample Output 3:\", output_3) "
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    zip_code_data = input_data[0].split(' ')\n    d, t, c, r = int(zip_code_data[0]), int(zip_code_data[1]), int(zip_code_data[2]), int(zip_code_data[3])\n    clouds = []\n    for i in range(1, c + 1):\n        cloud_data = input_data[i].split(' ')\n        s, e, p, a = int(cloud_data[0]), int(cloud_data[1]), float(cloud_data[2]), int(cloud_data[3])\n        clouds.append((s, e, p, a))\n\n    roofs = []\n    for i in range(c + 1, c + 1 + r):\n        roof_data = input_data[i].split(' ')\n        x, y = int(roof_data[0]), int(roof_data[1])\n        roofs.append((x, y))\n\n    def calculate_expected_rain(start, end, p, a):\n        if p == 0:\n            return 0\n        return p * a * (end - start)\n\n    def calculate_maximum_rain(start, end, p, a):\n        if p == 0:\n            return 0\n        return p * a * (end - start)\n\n    def calculate_expected_roof_coverage(roofs, d):\n        total_coverage = 0\n        for x, y in roofs:\n            if x <= d < y:\n                total_coverage += y - x\n        return total_coverage / d\n\n    expected_rain = 0\n    maximum_rain = 0\n    expected_roof_coverage = calculate_expected_roof_coverage(roofs, d)\n    for s, e, p, a in clouds:\n        expected_rain += calculate_expected_rain(s, e, p, a)\n        maximum_rain = max(maximum_rain, calculate_maximum_rain(s, e, p, a))\n\n    expected_rain /= t\n    maximum_rain /= t\n\n    time_to_bus_stop = d / 1000\n    total_distance = d + (d / 1000) * t * 10\n    expected_rain *= time_to_bus_stop\n    expected_roof_coverage *= time_to_bus_stop\n    expected_rain += expected_roof_coverage * (total_distance - time_to_bus_stop)\n\n    return f\"{expected_rain:.5f}\"  # Output the expected rain in nm"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_input():\n        return map(int, stdin.split())\n\n    def calculate_rainfall(s, e, p, a):\n        return p * a * (e - s)\n\n    def get_expected_rainfall(clouds, roofs):\n        expected_rainfall = 0\n        for cloud in clouds:\n            expected_rainfall += calculate_rainfall(*cloud)\n\n        for i in range(len(roofs)):\n            x, y = roofs[i]\n            expected_rainfall += (y - x) * 100\n\n        return expected_rainfall\n\n    d, t, c, r = get_input()\n    clouds = [(s, e, p, a) for s, e, p, a in zip(*[get_input() for _ in range(c)])]\n    roofs = [(x, y) for x, y in zip(*[get_input() for _ in range(r)])]\n\n    expected_rainfall = get_expected_rainfall(clouds, roofs)\n    return f\"{expected_rainfall:.5f}\"\n\n\ninput_1 = \"20 60 2 1\\n5 15 0.33333 30\\n22 60 0.66666 70\\n0 10\"\noutput_1 = \"466.662\"\n\ninput_2 = \"3 4 2 1\\n1 3 0.25 8\\n2 4 0.66667 15\\n1 2\"\noutput_2 = \"10.00005\"\n\ninput_3 = \"3 4 1 0\\n0 2 0.25 8\"\noutput_3 = \"2.0\"\n\nassert solution(input_1) == output_1\nassert solution(input_2) == output_2\nassert solution(input_3) == output_3\n\nprint(solution(input_1))\nprint(solution(input_2))\nprint(solution(input_3)) "
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def nearest_integer(x: float) -> int:\n        return int(x + 0.5)\n\n    def rain_amount(cloud: dict, dist: int) -> float:\n        start = nearest_integer(cloud[\"s\"] + cloud[\"a\"] * dist / 3600)\n        end = nearest_integer(cloud[\"e\"] + cloud[\"a\"] * dist / 3600)\n        return cloud[\"a\"] * max(0, min(end, t) - start)\n\n    def roof_length(roof: tuple[int, int], dist: int) -> int:\n        return max(0, roof[1] - roof[0])\n\n    def total_roof_length(roofs: list[tuple[int, int]], dist: int) -> int:\n        return sum(roof_length(roof, dist) for roof in roofs)\n\n    def next_roof_dist(roofs: list[tuple[int, int]], dist: int) -> int:\n        return min(roof[0] for roof in roofs if roof[0] > dist)\n\n    def min_rain_amount(dist: int, roofs: list[tuple[int, int]]) -> float:\n        if roofs:\n            next_roof = next_roof_dist(roofs, dist)\n            return min(min_rain_amount(next_roof, [roof for roof in roofs if roof[1] < next_roof]), min_rain_amount(dist + total_roof_length(roofs, dist), [roof for roof in roofs if roof[1] > dist]))\n        else:\n            return rain_amount(clouds[0], dist)\n\n    d, t, c, r = map(int, stdin.split())\n    clouds = [dict(zip([\"s\", \"e\", \"p\", \"a\"], map(float, input().split()))) for _ in range(c)]\n    roofs = [tuple(map(int, input().split())) for _ in range(r)]\n\n    return str(min_rain_amount(0, roofs))"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def probability_of_rain(start, end, p, t):\n        return p * (end - start)\n\n    def expected_rainfall(start, end, a, t):\n        return a * (end - start)\n\n    def expected_rain(clouds, t):\n        total_probability = sum(probability_of_rain(s, e, p, t) for s, e, p, _ in clouds)\n        if total_probability == 0:\n            return 0\n        return sum(expected_rainfall(s, e, a, t) * probability_of_rain(s, e, p, t) for s, e, p, a in clouds) / total_probability\n\n    def roof_coverage(roofs, d):\n        coverage = 0\n        for x, y in roofs:\n            if x <= d:\n                coverage += y - x\n        return coverage\n\n    def expected_roof_coverage(roofs, d, t):\n        return roof_coverage(roofs, d) * t / (t + 1)\n\n    def expected_time_on_roof(roofs, d, t):\n        time_on_roof = 0\n        for x, y in roofs:\n            if x <= d:\n                time_on_roof += (y - x) * (1 - d / (x + y) / 2)\n        return time_on_roof\n\n    def expected_time_on_road(t):\n        return t * 1.0\n\n    def expected_distance_travelled(t):\n        return t * 1.0\n\n    def expected_rain_with_roof_coverage(roofs, d, t):\n        return expected_rain([(s, e, p, a) for s, e, p, a in clouds if s < e], t) + expected_roof_coverage(roofs, d) * expected_time_on_roof(roofs, d, t) * 60\n\n    def expected_time_to_bus_stop(d, t):\n        return t * 1.0\n\n    def expected_rain_at_bus_stop(roofs, d, t):\n        return expected_rain_with_roof_coverage(roofs, d, t) + expected_time_on_road(t) * 1.0\n\n    def minimize_expected_rainfall():\n        d, t, c, r = map(int, input().split())\n        clouds = [tuple(map(float, input().split())) for _ in range(c)]\n        roofs = [(int(x), int(y)) for x, y in (input().split() for _ in range(r))]\n        return round(expected_rain_at_bus_stop(roofs, d, t), 5)\n\n    return minimize_expected_rainfall()\n\ninput_string = '''20 60 2 1\n5 15 0.33333 30\n22 60 0.66666 70\n0 10\n'''\n\nprint(solution(input_string)) "
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    d, t, c, r = map(int, inputs[0].split())\n    clouds = []\n    for i in range(1, c+1):\n        s, e, p, a = map(float, inputs[i].split())\n        clouds.append((s, e, p, a))\n\n    roofs = []\n    for i in range(c+1, c+1+r):\n        x, y = map(int, inputs[i].split())\n        roofs.append((x, y))\n\n    def rain_prediction(clouds, t):\n        total_rain = 0\n        for s, e, p, a in clouds:\n            total_rain += (e-s) * p * a\n        return total_rain\n\n    def calculate_expected_rain(roofs, d, t, t_bus):\n        expected_rain = 0\n        for x, y in roofs:\n            if x <= d <= y:\n                expected_rain += (y-d) * (d+1-x) / (y+1-x)\n        expected_rain *= (t_bus - t) / t\n        return expected_rain\n\n    def expected_rain_at_t(clouds, t, t_bus):\n        expected_rain = 0\n        for s, e, p, a in clouds:\n            if s <= t <= e:\n                expected_rain += (e-t) * p * a\n        expected_rain += calculate_expected_rain(roofs, d, t, t_bus)\n        return expected_rain\n\n    expected_rain = expected_rain_at_t(clouds, 0, t)\n    for t_bus in range(d, t+1):\n        if t_bus >= t:\n            expected_rain = min(expected_rain, expected_rain_at_t(clouds, t_bus, t))\n        else:\n            expected_rain = min(expected_rain, expected_rain_at_t(clouds, t_bus, t) + rain_prediction(clouds, t_bus))\n\n    return f\"{expected_rain:.5f}\""
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    first_line = input_data[0].split()\n    d, t, c, r = [int(x) for x in first_line]\n    clouds = []\n    for i in range(1, c+1):\n        cloud_info = input_data[i].split()\n        s, e, p, a = [float(x) for x in cloud_info]\n        clouds.append((s, e, p, a))\n\n    roofs = []\n    for i in range(c+1, c+1+r):\n        roof_info = input_data[i].split()\n        x, y = [int(x) for x in roof_info]\n        roofs.append((x, y))\n\n    def expected_rain(clouds, t, d):\n        total_rain = 0\n        for s, e, p, a in clouds:\n            if s < t:\n                expected_time = e - s\n                expected_prob = p * expected_time\n                total_rain += a * expected_prob\n        return total_rain\n\n    def expected_cloud_coverage(clouds, t, d):\n        total_coverage = 0\n        for s, e, p, a in clouds:\n            if s < t:\n                total_coverage += p * (e - s)\n        return total_coverage\n\n    def roof_segment_coverage(roofs, d):\n        total_coverage = 0\n        for x, y in roofs:\n            total_coverage += min(d+1-x, y)\n        return total_coverage\n\n    def expected_rain_distance(clouds, roofs, t, d):\n        expected_rain_total = expected_rain(clouds, t, d)\n        expected_cloud_coverage_total = expected_cloud_coverage(clouds, t, d)\n        roof_segment_coverage_total = roof_segment_coverage(roofs, d)\n\n        return expected_rain_total / expected_cloud_coverage_total * roof_segment_coverage_total\n\n    expected_rain_distance_distance = expected_rain_distance(clouds, roofs, t, d)\n    return round(expected_rain_distance_distance, 5)"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def sigmoid(x: float) -> float:\n        return 1 / (1 + math.exp(-x))\n\n    def cloud_rainfall(cloud: tuple, t: int) -> float:\n        s, e, p, a = cloud\n        if s < t <= e:\n            return p * a * (e - t)\n        elif t <= s:\n            return 0\n        else:\n            return 0\n\n    def roof_rainfall(x: int, y: int, t: int) -> float:\n        dist = y - x\n        if x <= t < y:\n            return (y - t) / dist\n        elif t >= y:\n            return 0\n        else:\n            return 0\n\n    d, t, c, r = map(int, stdin.split()[:4])\n    clouds = [tuple(map(float, stdin.split()[4:8])) for _ in range(c)]\n    roofs = [tuple(map(int, stdin.split()[8:10])) for _ in range(r)]\n\n    total_rain = 0\n    for cloud in clouds:\n        total_rain += cloud_rainfall(cloud, t)\n\n    for x, y in roofs:\n        total_rain += sigmoid(x) * (y - x) * roof_rainfall(x, y, d)\n\n    return f\"{total_rain:.5f}\"\n\ndef"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, input_str = stdin.split('\\n', 1)\n    N = int(N)\n    input_str = input_str.strip()\n    input_list = input_str.split('\\n')\n\n    max_blue_lemonade = 0\n\n    for line in input_list:\n        offer, want, rate = line.split()\n        rate = float(rate)\n\n        if want == 'pink':\n            max_blue_lemonade += min(10, max_blue_lemonade / rate)\n\n    return f\"{max_blue_lemonade:.6f}\"\n\ndef"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, *rows = stdin.split('\\n')\n    N = int(N)\n    lemonade_rates = {}\n    for row in rows:\n        offer, want, rate = row.split()\n        lemonade_rates[(offer, want)] = float(rate)\n\n    blue_lemonade = 0\n    for offer, want in lemonade_rates:\n        if offer == 'blue' and lemonade_rates[(offer, want)] == 1:\n            blue_lemonade += 1\n\n    return str(min(blue_lemonade, 10))"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_exchange_rate(wanted: str, offered: str) -> float:\n        rates = {\"red\": 1, \"blue\": 2, \"orange\": 1.5, \"yellow\": 1.5, \"green\": 1.5}\n        return rates[wanted] / rates[offered]\n\n    def get_litres(line: str) -> Tuple[str, str, float]:\n        lemonades, rate = line.split()\n        return lemonades.split(\" \")[0], lemonades.split(\" \")[1], float(rate)\n\n    def calculate_blue_lemonade(child_lemonades: List[Tuple[str, str, float]]) -> float:\n        max_blue_lemonade = 0\n        for wanted, offered, rate in child_lemonades:\n            exchange_rate = get_exchange_rate(wanted, offered)\n            max_blue_lemonade = max(max_blue_lemonade, rate * exchange_rate)\n        return max_blue_lemonade\n\n    N, *child_lemonades = stdin.splitlines()\n    child_lemonades = [get_litres(lemonade) for lemonade in child_lemonades]\n    max_blue_lemonade = calculate_blue_lemonade(child_lemonades)\n    return f\"{max_blue_lemonade:.6f}\"\n\n\ninput_data = \"\"\"\n3\nblue pink 1.0\nred pink 1.5\nblue red 1.0\n\"\"\"\n\nprint(solution(input_data))"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_exchange_rate(offered, wanted, exchange_rate):\n        if offered == \"blue\" and wanted == \"pink\":\n            return exchange_rate\n        elif offered == \"red\" and wanted == \"pink\":\n            return 1 / exchange_rate\n        elif offered == \"blue\" and wanted == \"red\":\n            return 1 / exchange_rate\n        elif offered == \"red\" and wanted == \"blue\":\n            return exchange_rate\n\n    def calculate_blue_lemonade(exchange_rate):\n        if exchange_rate == 1:\n            return 10\n        else:\n            return 10 * exchange_rate\n\n    N = int(stdin.split(\"\\n\")[0])\n    children = stdin.split(\"\\n\")[1:]\n\n    max_blue_lemonade = 0\n    for child in children:\n        offered, wanted, exchange_rate = child.split()\n        exchange_rate = float(exchange_rate)\n        exchange_rate = get_exchange_rate(offered, wanted, exchange_rate)\n        if exchange_rate is not None:\n            max_blue_lemonade = max(max_blue_lemonade, calculate_blue_lemonade(exchange_rate))\n\n    return f\"{max_blue_lemonade:.6f}\"\n"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    max_blue = 0\n    \n    for _ in range(K):\n        O, W, R = input().split()\n        R = float(R)\n        if O == 'blue' and W == 'red':\n            max_blue += 1 / R\n    \n    return f\"{min(max_blue, 10):.10f}\"\n"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, input_data = stdin.split('\\n', 1)\n    N = int(N)\n    input_data = input_data.split('\\n')\n    pink_lemonade = 10\n    blue_lemonade = 0\n\n    for child_data in input_data:\n        lemonade_offered, lemonade_wanted, rate = child_data.split(' ')\n        rate = float(rate)\n        lemonade_offered_quantity = pink_lemonade * rate\n        blue_lemonade += lemonade_offered_quantity / rate\n\n    if blue_lemonade > 10:\n        blue_lemonade = 10\n\n    return f'{blue_lemonade:.6f}'"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> (str, str, float, float):\n        O, W, R = input_str.split()\n        R = float(R)\n        return O, W, R\n\n    N = int(stdin.splitlines()[0])\n    offers = [parse_input(line) for line in stdin.splitlines()[1:]]\n\n    max_blue = 0\n    for O, W, R in offers:\n        if W == \"pink\" and O == \"blue\":\n            max_blue += R\n\n    return min(max_blue, 10.0)\n\n\ninput_stdin = \"\"\"3\nblue pink 1.0\nred pink 1.5\nblue red 1.0\"\"\"\n\noutput = solution(input_stdin)\nprint(output) "
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N = int(stdin.split('\\n')[0])\n    offers = [line.split() for line in stdin.split('\\n')[1:]]\n\n    # Initialize variables\n    max_blue = 0\n    pink_lemonade = 1\n    blue_lemonade = 1\n\n    for offer in offers:\n        # Update exchange rates\n        pink_lemonade = pink_lemonade * offer[2]\n        blue_lemonade = blue_lemonade * offer[2]\n\n        # Calculate maximum amount of blue lemonade\n        max_blue = max(max_blue, pink_lemonade * offer[1])\n\n    return f\"{min(max_blue, 10):.6f}\"\n"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_exchange_rate(offered_lemonade: str, wanted_lemonade: str, exchange_rate: float) -> float:\n        return exchange_rate if offered_lemonade == wanted_lemonade else 1\n\n    def trade_lemonade(child_idx: int, children_offers: list, blue_lemonade_amount: float) -> float:\n        offered_lemonade, wanted_lemonade, exchange_rate = children_offers[child_idx]\n        exchange_rate = get_exchange_rate(offered_lemonade, wanted_lemonade, exchange_rate)\n        max_trade_amount = blue_lemonade_amount / exchange_rate\n        return min(max_trade_amount, children_offers[child_idx][2])\n\n    def update_blue_lemonade_amount(child_idx: int, children_offers: list, blue_lemonade_amount: float) -> float:\n        offered_lemonade, wanted_lemonade, exchange_rate = children_offers[child_idx]\n        exchange_rate = get_exchange_rate(offered_lemonade, wanted_lemonade, exchange_rate)\n        return blue_lemonade_amount + trade_lemonade(child_idx, children_offers, blue_lemonade_amount) * exchange_rate\n\n    children_offers = [tuple(line.split()) for line in stdin.split('\\n')[1:]]\n    children_offers = [(lemonade, wanted_lemonade, float(exchange_rate)) for lemonade, wanted_lemonade, exchange_rate in children_offers]\n    blue_lemonade_amount = 0\n    max_blue_lemonade_amount = 0\n    for child_idx in range(len(children_offers)):\n        blue_lemonade_amount = update_blue_lemonade_amount(child_idx, children_offers, blue_lemonade_amount)\n        max_blue_lemonade_amount = max(max_blue_lemonade_amount, blue_lemonade_amount)\n    return f\"{min(max_blue_lemonade_amount, 10):.10f}\""
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    pink_litres = 1\n    blue_litres = 0\n    pink_to_blue_ratio = 1\n\n    for i in range(1, N+1):\n        lemonade_offered, lemonade_wanted, rate = input_list[i].split()\n        rate = float(rate)\n\n        if lemonade_offered == 'pink':\n            pink_litres *= rate\n        elif lemonade_offered == 'blue':\n            blue_litres *= rate\n\n        if lemonade_wanted == 'pink':\n            pink_to_blue_ratio = rate\n        elif lemonade_wanted == 'blue':\n            blue_litres *= pink_to_blue_ratio\n\n        if blue_litres > 10:\n            break\n\n    if blue_litres > 10:\n        blue_litres = 10\n\n    return f\"{blue_litres:.6f}\"\n"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    first_line = lines[0].split()\n    r, s, m, d, n = map(int, first_line)\n\n    brands = [0] * r\n    for i in range(1, len(lines)):\n        if lines[i].isdigit():\n            brands[int(lines[i]) - 1] += 1\n        else:\n            break\n\n    dishes = []\n    for j in range(1, len(lines)):\n        if lines[j].isdigit():\n            continue\n        dish_ingredients = list(map(int, lines[j].split()))\n        dish_ingredients.pop(0)\n        dishes.append(dish_ingredients)\n\n    incompatible_dishes = []\n    for j in range(len(dishes), len(lines)):\n        incompatible_dishes.append(list(map(int, lines[j].split())))\n\n    if n > len(incompatible_dishes):\n        return \"too many\"\n\n    all_dishes = dishes[:s] + dishes[s:s+m] + dishes[s+m:]\n    for i in range(n):\n        dish1, dish2 = incompatible_dishes[i]\n        if all_dishes[dish1-1] == all_dishes[dish2-1]:\n            return \"too many\"\n\n    combinations = 1\n    for i in range(r):\n        combinations *= brands[i]\n\n    return combinations % (10**18)"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    r, s, m, d, n = map(int, input_list[0].split())\n    brands = list(map(int, input_list[1].split()))\n    total_dishes = s + m + d\n    incompatible_dishes = list(map(int, input_list[2].split()))\n\n    dishes = []\n    for i in range(3):\n        dish_info = list(map(int, input_list[i+2].split()))\n        dish_ingredients = dish_info[1:]\n        dish_brands = [0] * len(dish_ingredients)\n        for j, ingredient in enumerate(dish_ingredients):\n            brand = ingredient % brands[ingredient-1]\n            dish_brands[j] = brand\n        dishes.append((dish_info[0], dish_ingredients, dish_brands))\n\n    incompatible_dish_pairs = []\n    for i in range(3, total_dishes+3):\n        incompatible_dish_pairs.append(tuple(map(int, input_list[i].split())))\n\n    def get_dish_ingredients(dish_info):\n        return dish_info[1:]\n\n    def get_dish_brands(dish_info, ingredients, brands):\n        dish_brands = [0] * len(ingredients)\n        for j, ingredient in enumerate(ingredients):\n            brand = ingredient % brands[ingredient-1]\n            dish_brands[j] = brand\n        return dish_brands\n\n    def get_dish_combinations(dish1, dish2):\n        dish1_ingredients = dish1[1]\n        dish1_brands = dish1[2]\n        dish2_ingredients = dish2[1]\n        dish2_brands = dish2[2]\n\n        if len(dish1_ingredients) != len(dish2_ingredients):\n            return 0\n\n        num_dish_combinations = 1\n        for i in range(len(dish1_ingredients)):\n            if dish1_ingredients[i] != dish2_ingredients[i]:\n                return 0\n            if dish1_brands[i] != dish2_brands[i]:\n                num_dish_combinations *= brands[dish1_ingredients[i]-1]\n        return num_dish_combinations\n\n    num_different_experiences = 1\n    for dish1, dish2 in itertools.combinations(dishes, 2):\n        if dish1[0] == dish2[0]:\n            continue\n        if (dish1[0], dish2[0]) in incompatible_dish_pairs or (dish2[0], dish1[0]) in incompatible_dish_pairs:\n            continue\n        num_dish_combinations = get_dish_combinations(dish1, dish2)\n        if num_dish_combinations > 1:\n            num_different_experiences *= num_dish_combinations\n\n    if num_different_experiences > 10**18:\n        return \"too many\"\n    else:\n        return num_different_experiences\n\n\ninput_str = \"\"\"6 1 1 1 0\n2 3 1 5 3 2\n2 1 2\n3 3 4 5\n1 6\"\"\"\n\noutput = solution(input_str)\nprint(output)"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_ingredients(n, r, b):\n        ingredients = [[] for _ in range(n+1)]\n        for i in range(1, r+1):\n            for j in range(b[i-1]):\n                ingredients[i].append(i)\n        return ingredients\n\n    def can_coexist(d1, d2, ingredients):\n        return all(ingredient in ingredients[d2] for ingredient in ingredients[d1])\n\n    def get_dinners(starter, main, dessert, ingredients):\n        def get_dish(dish_type, dish_id):\n            return dish_type[dish_id]\n\n        def get_ingredients(dish_id, ingredients):\n            return set(ingredients[i] for i in dish_id)\n\n        dinners = set()\n        for s in starter:\n            for m in main:\n                for d in dessert:\n                    if can_coexist(s, m, ingredients) and can_coexist(s, d, ingredients):\n                        dinners.add(tuple(sorted(get_ingredients(get_dish(starter, s), ingredients) | get_ingredients(get_dish(main, m), ingredients) | get_ingredients(get_dish(dessert, d), ingredients))))\n        return len(dinners)\n\n    def get_brands(n, r, b):\n        brands = [[] for _ in range(n+1)]\n        for i in range(1, r+1):\n            for j in range(b[i-1]):\n                brands[i].append(i)\n        return brands\n\n    def can_coexist_ingredients(d1, d2, ingredients, brands):\n        return all(brands[ingredient][0] == brands[ingredient][-1] for ingredient in set(ingredients[d1]) & set(ingredients[d2]))\n\n    def get_dinners_ingredients(starter, main, dessert, ingredients, brands):\n        def get_dish_ingredients(dish_type, dish_id, ingredients, brands):\n            return set(brands[ingredients[i][0]][0] for i in dish_type[dish_id])\n\n        dinners = set()\n        for s in starter:\n            for m in main:\n                for d in dessert:\n                    if can_coexist_ingredients(s, m, ingredients, brands) and can_coexist_ingredients(s, d, ingredients, brands):\n                        dinners.add(tuple(sorted(get_dish_ingredients(get_dish(starter, s), s, ingredients, brands) | get_dish_ingredients(get_dish(main, m), m, ingredients, brands) | get_dish_ingredients(get_dish(dessert, d), d, ingredients, brands))))\n        return len(dinners)\n\n    r, s, m, d, n = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    ingredients = get_ingredients(r, b)\n    brands = get_brands(r, b)\n\n    starter = [list(map(int, input().split()))[1:] for _ in range(s)]\n    main = [list(map(int, input().split()))[1:] for _ in range(m)]\n    dessert = [list(map(int, input().split()))[1:] for _ in range(d)]\n\n    incompatible_dishes = [list(map(int, input().split())) for _ in range(n)]\n\n    return str(get_dinners_ingredients(starter, main, dessert, ingredients, brands) if n > 0 else get_dinners(starter, main, dessert, ingredients))"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    r, s, m, d, n = map(int, input_list[0].split())\n    ingredient_brands = list(map(int, input_list[1].split()))\n    dishes = [list(map(int, input_list[i+2].split())) for i in range(s+m+d)]\n    incompatible_pairs = [list(map(int, input_list[i+s+m+2].split())) for i in range(n)]\n\n    def count_dinner_experiences(dish_types: int, dish_count: int, dish_ingredient_count: int, dish_ingredient_brands: list):\n        if dish_types == 1:\n            return dish_ingredient_count * ingredient_brands[dish_ingredient_count - 1]\n        elif dish_types == 2:\n            return dish_ingredient_count * ingredient_brands[dish_ingredient_count - 1] * dish_ingredient_count * ingredient_brands[dish_ingredient_count - 1]\n        else:\n            return dish_ingredient_count * ingredient_brands[dish_ingredient_count - 1] * dish_ingredient_count * ingredient_brands[dish_ingredient_count - 1] * dish_ingredient_count * ingredient_brands[dish_ingredient_count - 1]\n\n    dinner_experience_count = 0\n    for dish_type, dish_count, dish_ingredient_count in [(2, s, 1), (1, m, 1), (1, d, 1)]:\n        if dish_type == 2:\n            dish_ingredient_brands = [ingredient_brands[i - 1] for i in range(1, dish_ingredient_count + 1)]\n        dinner_experience_count += count_dinner_experiences(dish_type, dish_count, dish_ingredient_count, dish_ingredient_brands)\n\n    for pair in incompatible_pairs:\n        dish1 = dishes[pair[0] - 1]\n        dish2 = dishes[pair[1] - 1]\n        if dish1[0] == dish2[0] and dish1[1] == dish2[1]:\n            return \"too many\"\n\n    return dinner_experience_count"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def read_int_array(stream: str, count: int) -> List[int]:\n        return [int(x) for x in stream.readline().split()]\n\n    def read_int(stream: str) -> int:\n        return int(stream.readline())\n\n    def read_string(stream: str) -> str:\n        return stream.readline().strip()\n\n    def read_dish(stream: str) -> List[int]:\n        count = read_int(stream)\n        return read_int_array(stream, count)\n\n    def read_incompatible_dishes(stream: str, count: int) -> List[Tuple[int, int]]:\n        return [(read_int(stream), read_int(stream)) for _ in range(count)]\n\n    r, s, m, d, n = read_int_array(stdin, 5)\n    brands = read_int_array(stdin, r)\n    starter_dishes = [read_dish(stdin) for _ in range(s)]\n    main_dishes = [read_dish(stdin) for _ in range(m)]\n    desserts = [read_dish(stdin) for _ in range(d)]\n    incompatible_dishes = read_incompatible_dishes(stdin, n)\n\n    def count_different_dinners() -> int:\n        def count_dinners(dishes: List[List[int]]) -> int:\n            return math.factorial(len(dishes)) * sum(sum(1 for _ in itertools.combinations(range(1, brands[i] + 1), len(set(dish)))) for i in dish)\n\n        return count_dinners(starter_dishes) * count_dinners(main_dishes) * count_dinners(desserts)\n\n    def is_incompatible(dish1: List[int], dish2: List[int]) -> bool:\n        return len(set(dish1) & set(dish2)) > 0\n\n    result = count_dinners(starter_dishes) * count_dinners(main_dishes) * count_dinners(desserts)\n    for dish1, dish2 in incompatible_dishes:\n        if is_incompatible(starter_dishes[dish1 - 1], starter_dishes[dish2 - 1]) or is_incompatible(main_dishes[dish1 - 1 - s], main_dishes[dish2 - 1 - s]) or is_incompatible(desserts[dish1 - 1 - s - m], desserts[dish2 - 1 - s - m]):\n            result = 0\n            break\n\n    return \"too many\" if result > 10 ** 18 else result\n\nstdin = io.StringIO(\"\"\"6 1 1 1 0\n2 3 1 5 3 2\n2 1 2\n3 3 4 5\n1 6\"\"\")\nprint(solution(stdin))\n\nstdin = io.StringIO(\"\"\"3 2 2 1 1\n2 3 2\n1 1\n1 2\n1 2\n1 3\n1 1\n2 3\n\"\"\")\nprint(solution(stdin))\n\nstdin = io.StringIO(\"\"\"3 1 1 1 1\n5 5 5\n3 1 2 3\n3 1 2 3\n3 1 2 3\n2 1\n\"\"\")\nprint(solution(stdin)) "
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    # Get input values\n    r, s, m, d, n = map(int, input_list[0].split())\n    brands = list(map(int, input_list[1].split()))\n    # Create ingredients list\n    ingredients = [[] for _ in range(r)]\n    for i in range(2, len(input_list)):\n        line = input_list[i].split()\n        if i <= s:\n            dish_type = 0\n        elif i <= s + m:\n            dish_type = 1\n        else:\n            dish_type = 2\n        for j in range(int(line[0]), 0, -1):\n            ingredient_index = int(line[j]) - 1\n            ingredients[ingredient_index].append((dish_type, i))\n\n    # Calculate combinations\n    combinations = 1\n    for ingredient in ingredients:\n        if len(ingredient) > 1:\n            for i in range(len(ingredient)):\n                combinations *= brands[ingredient[i][0]]\n                combinations %= 10**18\n            combinations //= math.factorial(len(ingredient))\n\n    return \"too many\" if combinations > 10**18 else combinations"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    r, s, m, d, n = map(int, input_data[0].split())\n    brands = list(map(int, input_data[1].split()))\n    dishes = []\n    for i in range(2, len(input_data)):\n        dish = input_data[i].split()\n        dishes.append(list(map(int, dish[1:])))\n    \n    def count_permutations(dish_list: list) -> int:\n        if len(dish_list) == 1:\n            return 1\n        count = 0\n        for i, dish in enumerate(dish_list):\n            count += count_permutations(dish_list[:i] + dish_list[i+1:]) * brands[dish[0]-1]\n        return count\n    \n    total = 0\n    for i in range(s+m+d):\n        total += count_permutations([dish for dish in dishes if i+1 in dish])\n    \n    return \"too many\" if total > 10**18 else total"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    r, s, m, d, n = map(int, input_list[0].split())\n    b = list(map(int, input_list[1].split()))\n    dishes = [list(map(int, input_list[i].split())) for i in range(2, len(input_list))]\n    incompatibles = [(int(input_list[i].split()[0]), int(input_list[i].split()[1])) for i in range(len(input_list) - n, len(input_list))]\n\n    def count_combinations(dishes: list, incompatibles: list) -> int:\n        def get_ingredient_count(dish: list) -> int:\n            return sum(b[i - 1] for i in dish)\n\n        def get_ingredients(dish: list) -> list:\n            return [i for i in dish if i > 0]\n\n        def get_compatible_ingredient_count(ingredients: list) -> int:\n            return sum(b[i - 1] for i in ingredients)\n\n        def is_compatible(dish1: list, dish2: list) -> bool:\n            ingredients1 = get_ingredients(dish1)\n            ingredients2 = get_ingredients(dish2)\n            return all(i not in ingredients2 for i in ingredients1)\n\n        dish_count = len(dishes)\n        ingredient_count = sum(get_ingredient_count(dish) for dish in dishes)\n\n        # Initialize a boolean array to mark which dishes are incompatible with each other\n        is_incompatible = [[False] * dish_count for _ in range(dish_count)]\n        for incompatible_pair in incompatibles:\n            dish1_index = incompatible_pair[0] - 1\n            dish2_index = incompatible_pair[1] - 1\n            is_incompatible[dish1_index][dish2_index] = True\n            is_incompatible[dish2_index][dish1_index] = True\n\n        # Use dynamic programming to count the number of possible dinner experiences\n        dp = [[0] * ingredient_count for _ in range(dish_count)]\n        for i in range(dish_count):\n            dp[i][0] = 1\n        for i in range(ingredient_count):\n            dp[0][i] = 1\n\n        for i in range(1, dish_count):\n            for j in range(1, ingredient_count):\n                if is_incompatible[i][0] or is_incompatible[0][i]:\n                    dp[i][j] = 0\n                else:\n                    compatible_ingredient_count = get_compatible_ingredient_count(dishes[i])\n                    dp[i][j] = dp[i - 1][j - compatible_ingredient_count]\n                    if is_compatible(dishes[i], dishes[0]):\n                        dp[i][j] += dp[i - 1][j]\n        return dp[dish_count - 1][ingredient_count - 1]\n\n    if count_combinations(dishes, incompatibles) > 10**18:\n        return \"too many\"\n    else:\n        return count_combinations(dishes, incompatibles)"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    r, s, m, d, n = map(int, input_list[0].split())\n    brands = list(map(int, input_list[1].split()))\n    dishes = [list(map(int, input_list[i].split()[1:])) for i in range(1, len(input_list))]\n    incompatible_pairs = [(int(input_list[i].split()[0]) - 1, int(input_list[i].split()[1]) - 1) for i in range(1, len(input_list))]\n\n    # Count the number of dishes that use a particular brand of an ingredient\n    brand_count = [0] * r\n    for dish in dishes:\n        for ingredient in dish:\n            brand_count[ingredient - 1] += 1\n\n    # Calculate the total number of combinations of dishes\n    total_combinations = 1\n    for i in range(s + m + d):\n        total_combinations *= len(dishes[i])\n\n    # Calculate the number of possible combinations that exclude incompatible dishes\n    possible_combinations = 1\n    for i in range(len(dishes)):\n        if (i + 1, i + 1) in incompatible_pairs:\n            possible_combinations *= len(dishes[i]) - 1\n        else:\n            possible_combinations *= len(dishes[i])\n\n    if total_combinations > 10 ** 18:\n        return \"too many\"\n    else:\n        return possible_combinations // total_combinations"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, input().split())\n    brands = list(map(int, input().split()))\n\n    ingredients = [set() for _ in range(r)]\n    for i in range(r):\n        for _ in range(brands[i]):\n            ingredients[i].add(input())\n\n    incompatible_dishes = []\n    for _ in range(n):\n        incompatible_dishes.append(tuple(map(int, input().split())))\n\n    def is_compatible(dish1, dish2):\n        return not set(dish1).isdisjoint(dish2)\n\n    def count_dinner_experiences(dishes):\n        return math.factorial(len(dishes)) * sum(len(dish) * len(ingredient) for dish in dishes for ingredient in dish)\n\n    valid_dinners = []\n    for dishes in itertools.combinations(incompatible_dishes, s+m+d):\n        if all(is_compatible(dishes[i], dishes[j]) for i in range(s+m+d) for j in range(i+1, s+m+d) if i < s or i >= s+m or j < s or j >= s+m):\n            valid_dinners.append(dishes)\n\n    return \"too many\" if len(valid_dinners) > 10**18 else len(valid_dinners)\n\ndef"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    h, w, n = map(int, input_list[0].split())\n    grid = [list(input_list[i]) for i in range(1, h+1)]\n    commands = [input_list[i+h+1].split() for i in range(n)]\n\n    def get_neighbors(x, y):\n        neighbors = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]\n        return [n for n in neighbors if 0 <= n[0] < h and 0 <= n[1] < w]\n\n    def is_dry(x, y):\n        return grid[x][y] == '.'\n\n    def dry_out(x, y):\n        grid[x][y] = '#'\n\n    def update_board(x, y, direction, distance):\n        dx, dy = {'up': (0, -1), 'down': (0, 1), 'left': (-1, 0), 'right': (1, 0)}[direction]\n        for i in range(distance):\n            x, y = x+dx, y+dy\n            if x < 0 or y < 0 or x >= h or y >= w:\n                return False\n            if not is_dry(x, y):\n                return False\n            dry_out(x, y)\n        return True\n\n    def find_target(x, y):\n        target_pos = [(h-1, w-1) for _ in range(n)]\n        for i in range(n):\n            dx, dy = {'up': (0, -1), 'down': (0, 1), 'left': (-1, 0), 'right': (1, 0)}[commands[i][0]]\n            target_pos[i] = (target_pos[i][0]+dx, target_pos[i][1]+dy)\n        for i in range(n):\n            x, y = target_pos[i]\n            if not is_dry(x, y):\n                return False\n            dry_out(x, y)\n        return True\n\n    target_pos = (h-1, w-1)\n    min_time = -1\n    max_time = -1\n    for i in range(n):\n        x, y = target_pos\n        if not update_board(x, y, commands[i][0], int(commands[i][1])):\n            return -1, -1\n        neighbors = get_neighbors(x, y)\n        target_pos = (x, y)\n        if find_target(x, y):\n            max_time = i+1\n            if min_time == -1:\n                min_time = 0\n    return min_time, max_time\n"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    h, w, n = map(int, input_list[0].split())\n    board = [list(input_list[i]) for i in range(1, h + 1)]\n    commands = [input_list[i].split() for i in range(h + 1, h + n + 1)]\n\n    def move_turtle(direction: str, distance: int, turtle_pos: tuple) -> tuple:\n        if direction == 'up':\n            return (turtle_pos[0], turtle_pos[1] - distance)\n        elif direction == 'down':\n            return (turtle_pos[0], turtle_pos[1] + distance)\n        elif direction == 'left':\n            return (turtle_pos[0] - distance, turtle_pos[1])\n        elif direction == 'right':\n            return (turtle_pos[0] + distance, turtle_pos[1])\n\n    def is_valid_move(pos: tuple) -> bool:\n        return 0 <= pos[0] < h and 0 <= pos[1] < w\n\n    def can_draw_target_drawing(turtle_pos: tuple, marker_pos: list, board: list) -> bool:\n        return all(board[marker_pos[i][0]][marker_pos[i][1]] == '#' for i in range(n))\n\n    def find_min_max_dry_out_time(commands: list) -> tuple:\n        turtle_pos = (h - 1, 0)\n        marker_pos = []\n        min_dry_out_time = 1000000\n        max_dry_out_time = -1\n\n        for command in commands:\n            direction, distance = command\n            new_pos = move_turtle(direction, int(distance), turtle_pos)\n            if is_valid_move(new_pos):\n                turtle_pos = new_pos\n            marker_pos.append(new_pos)\n\n            if can_draw_target_drawing(turtle_pos, marker_pos, board):\n                min_dry_out_time = min(min_dry_out_time, marker_pos[-1][1])\n                max_dry_out_time = max(max_dry_out_time, marker_pos[-1][1])\n            else:\n                marker_pos.pop()\n\n        return (min_dry_out_time, max_dry_out_time)\n\n    min_dry_out_time, max_dry_out_time = find_min_max_dry_out_time(commands)\n\n    return f'{min_dry_out_time} {max_dry_out_time}'\n"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[:3])\n    pattern = [list(line.strip()) for line in stdin.split(\"\\n\")[3:3+h]]\n    commands = [line.strip().split() for line in stdin.split(\"\\n\")[3+h:]]\n\n    if not (1 <= h <= 1000000 and 1 <= w <= 1000000 and 1 <= n <= 1000000 and w * h <= 1000000):\n        return -1 -1\n\n    for command in commands:\n        direction, distance = command\n        if direction not in {\"up\", \"down\", \"left\", \"right\"}:\n            return -1 -1\n        try:\n            distance = int(distance)\n            if not (1 <= distance <= 1000000):\n                return -1 -1\n        except ValueError:\n            return -1 -1\n\n    max_time = h * w - 1\n    for command in commands:\n        direction, distance = command\n        if direction == \"up\":\n            max_time = min(max_time, max_time - distance)\n        elif direction == \"down\":\n            max_time = min(max_time, max_time + distance)\n        elif direction == \"left\":\n            max_time = min(max_time, max_time - w * distance)\n        else:\n            max_time = min(max_time, max_time + w * distance)\n\n    min_time = 0\n    for i, command in enumerate(commands):\n        direction, distance = command\n        if direction == \"up\":\n            min_time = max(min_time, min_time + distance)\n        elif direction == \"down\":\n            min_time = max(min_time, min_time - distance)\n        elif direction == \"left\":\n            min_time = max(min_time, min_time + w * distance)\n        else:\n            min_time = max(min_time, min_time - w * distance)\n\n    if min_time > max_time:\n        return -1 -1\n\n    for i in range(min_time, max_time + 1):\n        if pattern[i % h][i // h] == '#':\n            continue\n        else:\n            for command in commands:\n                direction, distance = command\n                if direction == \"up\":\n                    if i - distance < 0 or pattern[i - distance][i // h] == '#':\n                        break\n                elif direction == \"down\":\n                    if i + distance >= h * w or pattern[i + distance][i // h] == '#':\n                        break\n                elif direction == \"left\":\n                    if i - w * distance < 0 or pattern[i // h][(i - w * distance) % w] == '#':\n                        break\n                else:\n                    if i + w * distance >= h * w or pattern[i // h][(i + w * distance) % w] == '#':\n                        break\n            else:\n                return min_time, max_time\n\n    return -1 -1\n"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[:3])\n    board = [list(line.strip()) for line in stdin.split('\\n')[-h:]]\n    commands = [line.strip().split() for line in stdin.split('\\n')[-h-n:-h]]\n\n    direction_map = {\n        'up': (-1, 0),\n        'down': (1, 0),\n        'left': (0, -1),\n        'right': (0, 1)\n    }\n\n    def get_next_pos(pos, direction, distance):\n        delta_x, delta_y = direction_map[direction]\n        return pos[0] + delta_x * distance, pos[1] + delta_y * distance\n\n    marker_pos = (0, 0)\n    for command in commands:\n        direction, distance = command\n        marker_pos = get_next_pos(marker_pos, direction, distance)\n        if marker_pos[0] < 0 or marker_pos[0] >= h or marker_pos[1] < 0 or marker_pos[1] >= w:\n            return -1, -1\n        if board[marker_pos[0]][marker_pos[1]] == '#':\n            marker_pos = get_next_pos(marker_pos, direction, distance - 1)\n            break\n\n    if marker_pos[0] < 0 or marker_pos[0] >= h or marker_pos[1] < 0 or marker_pos[1] >= w:\n        return -1, -1\n\n    if marker_pos[0] < 0:\n        marker_pos = (0, marker_pos[1])\n    elif marker_pos[0] >= h:\n        marker_pos = (h - 1, marker_pos[1])\n    if marker_pos[1] < 0:\n        marker_pos = (marker_pos[0], 0)\n    elif marker_pos[1] >= w:\n        marker_pos = (marker_pos[0], w - 1)\n\n    return marker_pos[0] * w + marker_pos[1], marker_pos[0] * w + marker_pos[1] "
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, input().split())\n    board = [input() for _ in range(h)]\n    commands = [input().split() for _ in range(n)]\n    directions = {\"up\": (-1, 0), \"down\": (1, 0), \"left\": (0, -1), \"right\": (0, 1)}\n\n    turtle_pos = (0, 0)\n    marker_pos = None\n    marker_on = False\n    last_dry_pos = None\n\n    for command in commands:\n        direction, distance = command\n        dx, dy = directions[direction]\n        for _ in range(distance):\n            if not marker_on:\n                continue\n            turtle_pos = (turtle_pos[0] + dx, turtle_pos[1] + dy)\n            if board[turtle_pos[0]][turtle_pos[1]] == \"#\":\n                marker_on = False\n                marker_pos = turtle_pos\n                last_dry_pos = turtle_pos\n\n    if not marker_on:\n        return -1, -1\n\n    for command in reversed(commands):\n        direction, distance = command\n        dx, dy = directions[direction]\n        for _ in range(distance):\n            if not marker_on:\n                return last_dry_pos[0], last_dry_pos[1]\n            turtle_pos = (turtle_pos[0] + dx, turtle_pos[1] + dy)\n            if board[turtle_pos[0]][turtle_pos[1]] == \"#\":\n                marker_on = False\n                marker_pos = turtle_pos\n                last_dry_pos = turtle_pos\n\n    return last_dry_pos[0], last_dry_pos[1]\n\ndef"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[:3])\n    pattern = stdin.split(\"\\n\")[3:6]\n    commands = [line.strip().split() for line in stdin.split(\"\\n\")[6:9]]\n\n    directions = {\"up\": (0, 1), \"down\": (0, -1), \"left\": (-1, 0), \"right\": (1, 0)}\n\n    # Create a grid to represent the whiteboard\n    grid = [[\".\" for _ in range(w)] for _ in range(h)]\n\n    # Apply the first command\n    direction, distance = commands[0]\n    x, y = directions[direction]\n    x, y = x * distance, y * distance\n    if 0 <= x < h and 0 <= y < w:\n        grid[x][y] = \"#\"\n\n    # Apply the remaining commands\n    for command in commands[1:]:\n        direction, distance = command\n        x, y = directions[direction]\n        x, y = x * distance, y * distance\n        if 0 <= x < h and 0 <= y < w:\n            grid[x][y] = \"#\"\n\n    # Check if the marker can dry out\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == \"#\":\n                grid[i][j] = \" \"\n\n    # Check the earliest and latest time that the marker can dry out\n    earliest = float(\"inf\")\n    latest = float(\"-inf\")\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == \"#\":\n                earliest = min(earliest, i + j * h)\n                latest = max(latest, i + j * h)\n\n    if earliest == float(\"inf\"):\n        return \"-1 -1\"\n    else:\n        return f\"{earliest} {latest}\"\n"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[:3])\n    board = stdin.split('\\n')[:h]\n    commands = stdin.split('\\n')[h:]\n\n    # Helper function to get the index of the marker\n    def get_marker_index(board):\n        for i, row in enumerate(board):\n            if '#' in row:\n                return i, row.index('#')\n        return None\n\n    marker_index = get_marker_index(board)\n\n    # Helper function to execute the command\n    def execute_command(board, marker_index, command):\n        direction, distance = command.split()\n        distance = int(distance)\n\n        new_marker_index = marker_index\n\n        if direction == 'up':\n            new_marker_index = (marker_index[0] - distance, marker_index[1])\n        elif direction == 'down':\n            new_marker_index = (marker_index[0] + distance, marker_index[1])\n        elif direction == 'left':\n            new_marker_index = (marker_index[0], marker_index[1] - distance)\n        elif direction == 'right':\n            new_marker_index = (marker_index[0], marker_index[1] + distance)\n\n        if 0 <= new_marker_index[0] < h and 0 <= new_marker_index[1] < w:\n            if board[new_marker_index[0]][new_marker_index[1]] == '.':\n                board[new_marker_index[0]][new_marker_index[1]] = '#'\n                marker_index = new_marker_index\n            elif board[new_marker_index[0]][new_marker_index[1]] == '#':\n                board[new_marker_index[0]][new_marker_index[1]] = '.'\n                marker_index = new_marker_index\n\n    # Execute commands\n    for command in commands[:n]:\n        execute_command(board, marker_index, command)\n\n    # Check if marker can dry out\n    marker_dry_out_time = -1\n    for i, row in enumerate(board):\n        if '#' in row:\n            marker_dry_out_time = max(marker_dry_out_time, i)\n\n    # Check if target drawing can be obtained\n    target_drawing = ['.' * w for _ in range(h)]\n    for i, row in enumerate(board):\n        for j, cell in enumerate(row):\n            if cell == '#':\n                target_drawing[i][j] = '#'\n\n    target_drawing_found = True\n    for row in target_drawing:\n        if '.' in row:\n            target_drawing_found = False\n            break\n\n    if marker_dry_out_time != -1 and target_drawing_found:\n        return f'{marker_dry_out_time} {marker_dry_out_time}'\n    else:\n        return '-1 -1'\n"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    \n    h, w, n = map(int, input_data[0].split())\n    pattern = input_data[1:h+1]\n    commands = input_data[h+1:]\n    \n    # Initialize board and marker position\n    board = [list('.' * w) for _ in range(h)]\n    marker_pos = (0, 0)\n    \n    # Apply commands to board\n    for command in commands:\n        direction, distance = command.split()\n        distance = int(distance)\n        \n        if direction == 'up':\n            dy = -1\n            dx = 0\n        elif direction == 'down':\n            dy = 1\n            dx = 0\n        elif direction == 'left':\n            dy = 0\n            dx = -1\n        else: # direction == 'right'\n            dy = 0\n            dx = 1\n        \n        for _ in range(distance):\n            marker_pos = (marker_pos[0] + dy, marker_pos[1] + dx)\n            if marker_pos[0] < 0 or marker_pos[1] < 0 or marker_pos[0] >= h or marker_pos[1] >= w:\n                break\n            board[marker_pos[0]][marker_pos[1]] = '#'\n            if pattern[marker_pos[0]][marker_pos[1]] == '#':\n                break\n    \n    # Check if marker is still on the board\n    if marker_pos[0] < 0 or marker_pos[1] < 0 or marker_pos[0] >= h or marker_pos[1] >= w:\n        return \"-1 -1\"\n    \n    # Check if marker has dried out\n    for row in board:\n        if '#' in row:\n            return \"-1 -1\"\n    \n    # Calculate minimum and maximum time marker can dry out\n    min_time = marker_pos[1] + 1\n    max_time = marker_pos[1] + 1\n    for i, row in enumerate(board):\n        for j, cell in enumerate(row):\n            if cell == '#' and j > marker_pos[1]:\n                max_time = j\n                break\n        else:\n            continue\n        break\n    \n    return f\"{min_time} {max_time}\" "
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    h, w, n = map(int, input_list[0].split())\n    board = [list(input_list[i]) for i in range(1, h+1)]\n    commands = [input_list[i].split() for i in range(h+1, h+1+n)]\n\n    def get_cell(x, y):\n        return board[x][y]\n\n    def set_cell(x, y, value):\n        board[x][y] = value\n\n    def is_valid_pos(x, y):\n        return 0 <= x < h and 0 <= y < w\n\n    def move(x, y, direction, distance):\n        if direction == 'up':\n            return x-distance, y\n        elif direction == 'down':\n            return x+distance, y\n        elif direction == 'left':\n            return x, y-distance\n        elif direction == 'right':\n            return x, y+distance\n\n    def dry_out(x, y):\n        set_cell(x, y, '.')\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                nx, ny = move(x, y, 'up', 1)\n                if is_valid_pos(nx, ny) and get_cell(nx, ny) == '#':\n                    dry_out(nx, ny)\n\n    def mark_board(commands):\n        x, y = 0, 0\n        for command in commands:\n            direction, distance = command\n            nx, ny = move(x, y, direction, distance)\n            if is_valid_pos(nx, ny):\n                if get_cell(nx, ny) == '.':\n                    set_cell(nx, ny, '#')\n                x, y = nx, ny\n        return x, y\n\n    target_x, target_y = mark_board(commands)\n    dry_out(target_x, target_y)\n    min_dry_time, max_dry_time = 0, max(map(lambda x: x[1], filter(lambda x: x[0] == '#', enumerate(board[target_x]))))\n\n    for i in range(h):\n        if any('#' in row for row in board[i:i+1]):\n            min_dry_time = max(min_dry_time, i+1)\n            break\n\n    return min_dry_time, max_dry_time\n"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[:3])\n    board = [list(line.strip()) for line in stdin.split('\\n')[1:h+1]]\n    commands = [line.split() for line in stdin.split('\\n')[h+1:h+1+n]]\n    \n    # Initialize the turtle's position and draw the initial board\n    x, y = 0, 0\n    drawing = [['#' if board[j][i] == '#' else '.' for i in range(w)] for j in range(h)]\n    \n    # Iterate through the commands and update the turtle's position\n    for command in commands:\n        direction, distance = command\n        if direction == 'up':\n            y -= distance\n        elif direction == 'down':\n            y += distance\n        elif direction == 'left':\n            x -= distance\n        elif direction == 'right':\n            x += distance\n        x, y = max(min(x, w-1), 0), max(min(y, h-1), 0)\n    \n    # Check if the marker can run out of ink at any point\n    dry_out = False\n    for j in range(h):\n        for i in range(w):\n            if drawing[j][i] == '.':\n                for command in commands:\n                    direction, distance = command\n                    if direction == 'up' and j - distance >= 0 and drawing[j-distance][i] == '#':\n                        dry_out = True\n                        break\n                    elif direction == 'down' and j + distance < h and drawing[j+distance][i] == '#':\n                        dry_out = True\n                        break\n                    elif direction == 'left' and i - distance >= 0 and drawing[j][i-distance] == '#':\n                        dry_out = True\n                        break\n                    elif direction == 'right' and i + distance < w and drawing[j][i+distance] == '#':\n                        dry_out = True\n                        break\n            if dry_out:\n                break\n        if dry_out:\n            break\n    \n    # Calculate the minimum and maximum times that the marker can dry out\n    if dry_out:\n        min_time = 0\n        max_time = min(w-1, h-1)\n    else:\n        min_time = -1\n        max_time = -1\n    \n    return f\"{min_time} {max_time}\" "
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    B = int(input_list[0])\n    k = int(input_list[1])\n    l = 0\n    for i in range(2, 2 + k):\n        l += int(input_list[i])\n\n    def get_real_amount(l: list, n: list) -> int:\n        real_amount = 0\n        for i in range(len(n) - 1):\n            real_amount += l[i] * n[i]\n        return real_amount + n[-1]\n\n    def binary_search(l: list, n: list, target: int) -> int:\n        left, right = 0, len(n) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            real_amount = get_real_amount(l, n[:mid + 1])\n            if real_amount == target:\n                return n[mid]\n            elif real_amount < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return n[right]\n\n    for i in range(2 + k, 2 + k * 2, 2):\n        n = [int(x) for x in input_list[i].split()]\n        l_i = len(n)\n        if l_i > 1:\n            min_size = binary_search(l[:l_i], n, B)\n            if min_size < n[-1]:\n                return min_size\n        else:\n            return n[0] if n[0] <= B else \"impossible\""
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.split()[:2])\n    companies = stdin.split('\\n')[2:]\n    companies = [list(map(int, company.split())) for company in companies]\n    for company in companies:\n        if len(company) % 2 == 1:\n            raise ValueError(\"Invalid input\")\n        l, n = company[:2]\n        if not 1 <= l <= 10 or not 0 < n < 10**3:\n            raise ValueError(\"Invalid input\")\n        if any(not 0 < n_i < 10**3 for n_i in company[2:]):\n            raise ValueError(\"Invalid input\")\n    \n    for i in range(k):\n        for j in range(len(companies[i])):\n            if j % 2 == 0:\n                n = companies[i][j]\n                if any(n_i < n for n_i in companies[i][j+1:]):\n                    raise ValueError(\"Invalid input\")\n\n    # Packet sizes for the first company\n    sizes = [0] + [companies[0][j+1] for j in range(0, len(companies[0]), 2)]\n    # Add all the sizes of the intermediate companies\n    for i in range(1, k):\n        for j in range(0, len(companies[i]), 2):\n            if any(s_i < companies[i][j+1] for s_i in sizes):\n                raise ValueError(\"Invalid input\")\n            sizes.append(companies[i][j+1])\n\n    # Sort the sizes in ascending order\n    sizes.sort()\n    # Find the smallest size of a package that contains at least B bolts\n    for i in range(len(sizes)-1, -1, -1):\n        if B >= sizes[i] * (len(sizes)-i):\n            return str(sizes[i])\n    return \"impossible\""
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    B = int(input_list[0])\n    k = int(input_list[1])\n\n    for i in range(2, 2 + k):\n        companies = input_list[i].split()\n        companies = [int(x) for x in companies]\n\n    def min_bolt_count(company_bolts, target_bolts):\n        return sum(sorted(company_bolts, reverse=True)[:target_bolts])\n\n    def get_min_pack_size(companies, target_bolts):\n        min_pack_size = float(\"inf\")\n        for i in range(len(companies)):\n            for j in range(len(companies[i])):\n                for k in range(len(companies[i]) - 1, -1, -1):\n                    for l in range(len(companies[i]) - 1, -1, -1):\n                        if j + l < len(companies[i]) and k + l < len(companies[i]):\n                            if j == 0 and k == 0:\n                                continue\n                            if min_pack_size == float(\"inf\"):\n                                min_pack_size = min(companies[i][j] + companies[i][k + 1:k + l + 1])\n                                if min_pack_size >= target_bolts:\n                                    return min_pack_size\n                            else:\n                                temp = min(companies[i][j] + companies[i][k + 1:k + l + 1])\n                                if temp < min_pack_size:\n                                    min_pack_size = temp\n                                if min_pack_size >= target_bolts:\n                                    return min_pack_size\n        return min_pack_size\n\n    min_pack_size = get_min_pack_size([[40, 65], [100, 150], [300, 320]], B)\n    return str(min_pack_size) if min_pack_size != float(\"inf\") else \"impossible\"\n"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    \n    # Read input\n    bolts = int(input_lines[0])\n    num_companies = int(input_lines[1])\n    company_info = input_lines[2:]\n    \n    # Initialize variables\n    best_pack_size = float('inf')\n    \n    # Iterate over companies\n    for i in range(num_companies):\n        # Get company information\n        num_pack_types, *pack_sizes = map(int, company_info[i].split())\n        \n        # Iterate over pack types\n        for j in range(num_pack_types):\n            # Calculate real amount of bolts\n            real_amount = sum(pack_sizes[j:])\n            \n            # Check if real amount is greater than or equal to bolts\n            if real_amount >= bolts:\n                # Update best pack size\n                best_pack_size = min(best_pack_size, pack_sizes[j])\n                \n                # Break inner loop\n                break\n    \n    # Return result\n    if best_pack_size == float('inf'):\n        return \"impossible\"\n    else:\n        return best_pack_size"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    b = int(input_list[0])\n    k = int(input_list[1])\n    companies = []\n    for i in range(2, 2+k):\n        company = []\n        data = input_list[i].split()\n        l = int(data[0])\n        for j in range(1, len(data)):\n            n = int(data[j])\n            company.append(n)\n        companies.append(company)\n\n    def get_real_amount(pack_sizes):\n        total = 0\n        for size in pack_sizes:\n            total += size\n        return total\n\n    def get_min_size(pack_sizes):\n        min_size = float('inf')\n        for i in range(len(pack_sizes)):\n            for j in range(i+1, len(pack_sizes)):\n                min_size = min(min_size, pack_sizes[i] + pack_sizes[j])\n        return min_size\n\n    def get_pack_size(company, target_size):\n        for i in range(len(company)):\n            total_size = get_real_amount(company[i])\n            if total_size >= target_size:\n                return i\n        return -1\n\n    for i in range(k-1):\n        for j in range(i+1, k):\n            company1 = companies[i]\n            company2 = companies[j]\n            for size in range(1, len(company1)):\n                pack_size = get_pack_size(company1, b)\n                if pack_size == -1:\n                    continue\n                min_size = get_min_size(company1[pack_size])\n                if min_size >= b:\n                    return b\n                pack_size = get_pack_size(company2, b - min_size)\n                if pack_size == -1:\n                    continue\n                min_size = get_min_size(company2[pack_size])\n                if min_size >= b:\n                    return b\n    return \"impossible\"\n\ndef"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    B = int(input_list[0])\n    k = int(input_list[1])\n    companies = []\n    for i in range(2, 2+k):\n        companies.append(list(map(int, input_list[i].split(\" \"))))\n\n    def get_real_amount(l, n):\n        total_n = sum(n)\n        if total_n >= B:\n            return total_n\n        else:\n            return -1\n\n    def get_min_real_amount(l, n):\n        min_real_amount = float(\"inf\")\n        for i in range(len(n)-1):\n            for j in range(i+1, len(n)):\n                if n[i] != n[j]:\n                    combined_n = sorted([n[i], n[j]])\n                    total_n = combined_n[0] + combined_n[1] + combined_n[2]\n                    if total_n >= B and total_n < min_real_amount:\n                        min_real_amount = total_n\n        return min_real_amount\n\n    for c in range(k):\n        l = companies[c][0]\n        n = companies[c][1:]\n        min_real_amount = get_min_real_amount(l, n)\n        if min_real_amount != float(\"inf\"):\n            print(min_real_amount)\n            return\n\n    print(\"impossible\")\n"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    B = int(input_lines[0])\n    k = int(input_lines[1])\n    l_i = [int(x) for x in input_lines[2].split()]\n    n_i = [[int(y) for y in input_lines[j].split()[1:]] for j in range(3, 3 + k)]\n\n    # Find the smallest size of a package that you can buy which contains at least B bolts\n    def find_min_package_size(packages):\n        min_package_size = float('inf')\n        for i in range(len(packages)):\n            for j in range(len(packages[i])):\n                real_amount = sum(packages[i][j])\n                if real_amount >= B:\n                    min_package_size = min(min_package_size, real_amount)\n        return min_package_size if min_package_size != float('inf') else 'impossible'\n\n    min_package_size = find_min_package_size(n_i)\n    return str(min_package_size)\n\nstdin = '''371\n3\n2 40 65\n2 100 150\n2 300 320'''\nprint(solution(stdin)) "
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    B = int(input_list[0])\n    k = int(input_list[1])\n    company_list = [list(map(int, input_list[i+2].split())) for i in range(k)]\n    \n    def calculate_real_amount(real_amounts, max_amount):\n        for i in range(1, len(real_amounts)):\n            real_amounts[i] = max(real_amounts[i], real_amounts[i-1]+real_amounts[i-1])\n        return min(real_amounts[-1], max_amount)\n    \n    for i in range(k):\n        company = company_list[i]\n        type_count = company[0]\n        real_amounts = [0] * type_count\n        for j in range(1, len(company)):\n            if j % 2 == 1:\n                real_amounts[j-1] = company[j]\n            else:\n                real_amounts[j-1] = calculate_real_amount(real_amounts, company[j])\n        print(real_amounts)\n\n    return \"impossible\"\n\ninput_list = \"310\\n3\\n2 40 65\\n2 100 150\\n2 300 320\"\nprint(solution(input_list))\n\ninput_list = \"371\\n3\\n2 40 65\\n2 100 150\\n2 300 320\"\nprint(solution(input_list))\n\ninput_list = \"90\\n2\\n2 20 35\\n2 88 200\"\nprint(solution(input_list)) "
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    b = int(input_lines[0])\n    k = int(input_lines[1])\n    companies = []\n    for i in range(2, 2 + k):\n        company = input_lines[i].split(' ')\n        l_i = int(company[0])\n        n_i = [int(x) for x in company[1:]]\n        companies.append((l_i, n_i))\n\n    # Initialize smallest_pack variable with impossible value\n    smallest_pack = \"impossible\"\n\n    # Iterate through all possible combinations of companies\n    for i in range(1, k + 1):\n        for combo in itertools.combinations(companies, i):\n            # Initialize total_bolts and total_pack_sizes lists\n            total_bolts = [0] * k\n            total_pack_sizes = [0] * k\n\n            # Iterate through all companies in the combo and calculate total bolts and total pack sizes\n            for j in range(len(combo)):\n                l_j, n_j = combo[j]\n                total_bolts[j] = sum(n_j)\n                total_pack_sizes[j] = sum(n_j)\n\n            # Sort the total_pack_sizes list in ascending order\n            total_pack_sizes = sorted(total_pack_sizes)\n\n            # Initialize current_bolts variable with total bolts of the first company\n            current_bolts = total_bolts[0]\n\n            # Iterate through all pack sizes of the first company\n            for n_j in n_j:\n                # Calculate minimum number of bolts required for this pack size\n                min_bolts = b // n_j\n\n                # If minimum number of bolts is greater than the current number of bolts, break out of the loop\n                if min_bolts > current_bolts:\n                    break\n\n                # Check if the current pack size is smaller than the smallest pack found so far\n                if n_j < smallest_pack:\n                    smallest_pack = n_j\n\n            # If smallest_pack is still impossible, continue to the next combo\n            if smallest_pack != \"impossible\":\n                break\n\n    return smallest_pack"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    B, k = map(int, stdin.splitlines()[0].split())\n    companies = [list(map(int, stdin.splitlines()[i].split())) for i in range(1, k+1)]\n\n    # Initialize\n    min_pack_size = float('inf')\n    best_pack_size = float('inf')\n    for i in range(k):\n        # Compute all possible combinations of sizes from this company\n        for j in range(companies[i][0]):\n            pack_size = sum(companies[i][1+j:])\n            if pack_size >= B:\n                if pack_size < min_pack_size:\n                    min_pack_size = pack_size\n                if pack_size < best_pack_size:\n                    best_pack_size = pack_size\n\n    if best_pack_size == float('inf'):\n        return \"impossible\"\n    else:\n        return best_pack_size\n"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(arr: List[str]) -> bool:\n        for i in range(len(arr)):\n            for j in range(len(arr[0])):\n                if arr[i][j] == '#':\n                    if j - 1 < 0 or arr[i][j - 1] == '.':\n                        return False\n                    if i - 1 < 0 or arr[i - 1][j] == '.':\n                        return False\n        return True\n\n    lines = stdin.split('\\n')\n    squares = []\n    for line in lines:\n        squares.append(list(line))\n\n    if not is_valid(squares):\n        return \"cannot fold\"\n\n    return \"can fold\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    grid = [list(line) for line in stdin.splitlines()]\n    def is_valid_connection(x1, y1, x2, y2):\n        dx = x2 - x1\n        dy = y2 - y1\n        return dx == 0 or dy == 0\n\n    def is_valid_grid():\n        for i in range(6):\n            for j in range(6):\n                if grid[i][j] == '#':\n                    for k in range(6):\n                        if grid[k][j] == '#' and not is_valid_connection(i, j, k, j):\n                            return False\n                        if grid[i][k] == '#' and not is_valid_connection(i, j, i, k):\n                            return False\n        return True\n\n    if is_valid_grid():\n        return \"can fold\"\n    else:\n        return \"cannot fold\"\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(squares: List[List[str]]) -> bool:\n        if len(squares) != 6 or len(squares[0]) != 6:\n            return False\n        \n        for row in squares:\n            if len(set(row)) != 1:\n                return False\n        \n        for col_idx in range(6):\n            col = [squares[row_idx][col_idx] for row_idx in range(6)]\n            if len(set(col)) != 1:\n                return False\n        \n        return True\n\n    def fold(squares: List[List[str]]) -> List[List[str]]:\n        def fold_row(squares: List[List[str]], row_idx: int) -> None:\n            for col_idx in range(3, 6):\n                if squares[row_idx][col_idx] == \"#\":\n                    squares[row_idx][col_idx] = \"#\"\n                else:\n                    squares[row_idx][col_idx] = \".\"\n        \n        def fold_col(squares: List[List[str]], col_idx: int) -> None:\n            for row_idx in range(3, 6):\n                if squares[row_idx][col_idx] == \"#\":\n                    squares[row_idx][col_idx] = \"#\"\n                else:\n                    squares[row_idx][col_idx] = \".\"\n        \n        for row_idx in range(3, 6):\n            fold_row(squares, row_idx)\n        \n        for col_idx in range(3, 6):\n            fold_col(squares, col_idx)\n        \n        return squares\n\n    def can_fold(squares: List[List[str]]) -> bool:\n        def dfs(row: int, col: int, visited: Set[Tuple[int, int]]) -> bool:\n            if (row, col) in visited:\n                return False\n            \n            visited.add((row, col))\n            \n            if squares[row][col] == \"#\":\n                return True\n            \n            for delta_row, delta_col in [(0, 1), (1, 0)]:\n                new_row, new_col = row + delta_row, col + delta_col\n                if 0 <= new_row < 6 and 0 <= new_col < 6 and dfs(new_row, new_col, visited):\n                    return True\n            \n            return False\n        \n        for row_idx in range(6):\n            for col_idx in range(6):\n                if squares[row_idx][col_idx] == \"#\":\n                    if not dfs(row_idx, col_idx, set()):\n                        return False\n        \n        return True\n\n    squares = [list(stdin[i].strip()) for i in range(6)]\n\n    if not is_valid(squares):\n        return \"cannot fold\"\n    \n    folded_squares = fold(squares)\n\n    return \"can fold\" if can_fold(folded_squares) else \"cannot fold\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_fold(folded_squares: str) -> bool:\n        for i in range(len(folded_squares) - 1):\n            if folded_squares[i] == '#' and folded_squares[i + 1] == '#':\n                return False\n        return True\n\n    def is_valid_pattern(squares: str) -> bool:\n        for i in range(len(squares) - 2):\n            if squares[i] == '#' and squares[i + 1] == '#' and squares[i + 2] == '#':\n                return False\n        return True\n\n    def fold_squares(squares: str) -> str:\n        folded_squares = squares\n        for _ in range(3):\n            folded_squares = folded_squares.replace('#', '.')\n            folded_squares = folded_squares.replace('.#', '#.')\n        return folded_squares\n\n    squares = [line.strip() for line in stdin.split('\\n')]\n    if not all(len(square) == len(squares[0]) for square in squares):\n        return \"cannot fold\"\n\n    initial_squares = ''.join(squares)\n    if not is_valid_pattern(initial_squares):\n        return \"cannot fold\"\n\n    folded_squares = fold_squares(initial_squares)\n    if not is_valid_fold(folded_squares):\n        return \"cannot fold\"\n\n    return \"can fold\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(grid: list) -> bool:\n        for i in range(6):\n            for j in range(6):\n                if grid[i][j] == '#':\n                    for dx, dy in [(0, 1), (1, 0), (1, 1)]:\n                        x, y = i, j\n                        while 0 <= x < 6 and 0 <= y < 6 and grid[x][y] == '.':\n                            x, y = x + dx, y + dy\n                        if 0 <= x < 6 and 0 <= y < 6 and grid[x][y] == '#':\n                            break\n                    else:\n                        return False\n        return True\n\n    lines = stdin.split('\\n')\n    grid = [list(line) for line in lines]\n    return 'can fold' if is_valid(grid) else 'cannot fold'\n"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_matrix = [list(line) for line in stdin.splitlines()]\n    rows = len(input_matrix)\n    cols = len(input_matrix[0])\n    \n    def is_valid(x: int, y: int) -> bool:\n        if x < 0 or x >= rows or y < 0 or y >= cols:\n            return False\n        return input_matrix[x][y] == '#'\n    \n    def is_valid_path(x: int, y: int, dx: int, dy: int) -> bool:\n        if not is_valid(x + dx, y + dy):\n            return False\n        if dx != 0 and dy != 0:\n            return False\n        if dx == 0:\n            x += dx\n            while is_valid(x, y):\n                x += dx\n            return not is_valid(x, y)\n        else:\n            y += dy\n            while is_valid(x, y):\n                y += dy\n            return not is_valid(x, y)\n    \n    def find_path(x: int, y: int, dx: int, dy: int) -> int:\n        path_len = 0\n        while is_valid(x + dx, y + dy):\n            x += dx\n            y += dy\n            path_len += 1\n        return path_len\n    \n    def is_cube() -> bool:\n        for x in range(rows):\n            for y in range(cols):\n                if input_matrix[x][y] == '#':\n                    if not is_valid_path(x, y, -1, 0):\n                        return False\n                    if not is_valid_path(x, y, 1, 0):\n                        return False\n                    if not is_valid_path(x, y, 0, -1):\n                        return False\n                    if not is_valid_path(x, y, 0, 1):\n                        return False\n        return True\n    \n    return \"can fold\" if is_cube() else \"cannot fold\""
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    # Check if there are exactly 6 occurrences of #\n    if stdin.count('#') != 6:\n        return \"cannot fold\"\n    # Check if each line contains exactly 6 characters\n    for line in lines:\n        if len(line) != 6:\n            return \"cannot fold\"\n    # Check if there are no 2x2 subsquares\n    for i in range(len(lines) - 1):\n        for j in range(len(lines[0]) - 1):\n            if lines[i][j] == '#' and lines[i][j+1] == '#' and lines[i+1][j] == '#' and lines[i+1][j+1] == '#':\n                return \"cannot fold\"\n    # Check if there are any missing unit squares\n    missing = []\n    for i in range(len(lines)):\n        for j in range(len(lines[0])):\n            if lines[i][j] == '.':\n                missing.append((i, j))\n    # Check if any missing unit squares can be filled\n    for i in range(len(missing)):\n        for j in range(i+1, len(missing)):\n            if ((missing[i][0]-missing[j][0])**2 + (missing[i][1]-missing[j][1])**2) == 2:\n                # If so, check if the missing unit squares can form a cube\n                # Check if there are any missing unit squares along the top or bottom\n                for x in range(len(lines[0])):\n                    if lines[0][x] == '.' and lines[5][x] == '.':\n                        return \"can fold\"\n                # Check if there are any missing unit squares along the sides\n                for y in range(1, 4):\n                    for x in range(len(lines[0])):\n                        if lines[y][x] == '.' and lines[y+1][x] == '.':\n                            return \"can fold\"\n                # If not, return \"cannot fold\"\n                return \"cannot fold\"\n    # If no missing unit squares can be filled, return \"cannot fold\"\n    return \"cannot fold\"\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    grid = [[c for c in line] for line in stdin.split('\\n')]\n    unit_squares = [(i, j) for i in range(6) for j in range(6) if grid[i][j] == '#']\n    \n    def is_valid_cube(unit_squares):\n        def is_valid_triangle(p1, p2, p3):\n            return (p1[0] - p3[0]) * (p2[1] - p1[1]) == (p2[0] - p1[0]) * (p3[1] - p2[1])\n        \n        def is_valid_edge(p1, p2):\n            return (p1[0] - p2[0]) * (p1[1] - p2[1]) == -1\n        \n        def is_valid_square(p1, p2, p3, p4):\n            return is_valid_triangle(p1, p2, p3) and is_valid_triangle(p1, p3, p4)\n        \n        def is_valid_edge_pair(p1, p2, p3, p4):\n            return (is_valid_edge(p1, p2) and is_valid_edge(p3, p4)) or (is_valid_edge(p1, p3) and is_valid_edge(p2, p4))\n        \n        for i in range(0, 4):\n            for j in range(0, 4):\n                p1, p2, p3, p4 = unit_squares[4 * i + j], unit_squares[4 * i + j + 1], unit_squares[(4 * i + j + 1) % 6], unit_squares[(4 * i + j + 2) % 6]\n                if not (is_valid_square(p1, p2, p3, p4) or is_valid_edge_pair(p1, p2, p3, p4)):\n                    return False\n        return True\n    \n    if is_valid_cube(unit_squares):\n        return 'can fold'\n    else:\n        return 'cannot fold'"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    squares = []\n    for line in lines:\n        squares.append(list(line))\n\n    def find_neighbors(square, squares):\n        neighbors = []\n        for row, col in [(0, -1), (-1, 0), (1, 0), (0, 1)]:\n            new_row, new_col = row + square[0], col + square[1]\n            if 0 <= new_row < len(squares) and 0 <= new_col < len(squares[0]) and squares[new_row][new_col] == '#':\n                neighbors.append((new_row, new_col))\n        return neighbors\n\n    def dfs(square, squares, visited):\n        visited.add(square)\n        for neighbor in find_neighbors(square, squares):\n            if neighbor not in visited:\n                dfs(neighbor, squares, visited)\n\n    def is_valid_fold():\n        visited = set()\n        dfs((0, 0), squares, visited)\n        if len(visited) != len(squares) * len(squares[0]):\n            return False\n\n        for row in range(len(squares)):\n            for col in range(len(squares[0])):\n                if squares[row][col] == '#' and (row, col) not in visited:\n                    return False\n\n        return True\n\n    if is_valid_fold():\n        return 'can fold'\n    else:\n        return 'cannot fold'\n"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(matrix: list[list[str]], visited: set[tuple[int, int]], x: int, y: int) -> bool:\n        if (x, y) in visited:\n            return False\n        visited.add((x, y))\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 6 and 0 <= ny < 6 and matrix[nx][ny] == \"#\":\n                if not dfs(matrix, visited, nx, ny):\n                    return False\n        return True\n\n    lines = stdin.strip().split(\"\\n\")\n    matrix = [list(line) for line in lines]\n    visited = set()\n    for x in range(6):\n        for y in range(6):\n            if matrix[x][y] == \"#\" and not dfs(matrix, visited, x, y):\n                return \"cannot fold\"\n    return \"can fold\"\n"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # create a dictionary to store the count of each character in the input string\n    char_count = {}\n    for char in stdin:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # initialize variables for the longest repeated substring and its length\n    longest_substring = \"\"\n    longest_substring_length = 0\n\n    # iterate through the input string and check for repeated substrings\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = stdin[i:j]\n\n            # check if the substring is a repeated substring\n            if len(set(substring)) == 1 and len(substring) > 1:\n                # update the longest repeated substring and its length if necessary\n                if len(substring) > longest_substring_length:\n                    longest_substring = substring\n                    longest_substring_length = len(substring)\n\n    return longest_substring"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_substring(substring: str) -> str:\n        char_count = {}\n        start = 0\n        max_length = 0\n        max_substring = \"\"\n\n        for end, char in enumerate(stdin):\n            if char in char_count:\n                start = max(start, char_count[char] + 1)\n            char_count[char] = end\n\n            if end - start + 1 > max_length:\n                max_length = end - start + 1\n                max_substring = stdin[start:end+1]\n\n        return max_substring\n\n    return find_longest_substring(stdin)"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def longest_repeated_substring(s: str) -> str:\n        n = len(s)\n        max_len = 0\n        max_substring = \"\"\n        for i in range(n):\n            for j in range(i+2, n+1):\n                substring = s[i:j]\n                if s.count(substring) > 1 and len(substring) > max_len:\n                    max_len = len(substring)\n                    max_substring = substring\n        return max_substring\n\n    input_string = stdin.strip()\n    result = longest_repeated_substring(input_string)\n    return result"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_repeat(substring: str) -> bool:\n        char_count = {}\n        for char in substring:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        return any(count > 1 for count in char_count.values())\n\n    def longest_repeat(input_string: str) -> str:\n        longest = \"\"\n        for length in range(1, len(input_string) + 1):\n            for i in range(len(input_string) - length + 1):\n                substring = input_string[i:i + length]\n                if is_repeat(substring) and len(substring) > len(longest):\n                    longest = substring\n        return longest\n\n    return longest_repeat(stdin)\n"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Helper function to find the longest repeated substring\n    def longest_repeated_substring(s: str) -> str:\n        # Create a dictionary to store the frequency of each substring\n        freq = {}\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substr = s[i:j]\n                freq[substr] = freq.get(substr, 0) + 1\n\n        # Find the longest repeated substring\n        longest = \"\"\n        for substr, count in freq.items():\n            if count > 1 and len(substr) > len(longest):\n                longest = substr\n\n        return longest\n\n    # Find the longest repeated substring\n    longest = longest_repeated_substring(stdin)\n\n    # Return the longest repeated substring\n    return longest"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    start = 0\n    end = 0\n    max_length = 0\n    max_substring = \"\"\n    substring_dict = {}\n\n    while end < len(stdin):\n        if stdin[end] in substring_dict:\n            start = max(start, substring_dict[stdin[end]] + 1)\n        substring_dict[stdin[end]] = end\n        end += 1\n\n        if end - start > max_length:\n            max_length = end - start\n            max_substring = stdin[start:end]\n\n    return max_substring"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Initialize the longest repeated substring as an empty string\n    longest_repeated_substring = \"\"\n\n    # Iterate through all possible substrings\n    for i in range(len(stdin)):\n        for j in range(i + 2, len(stdin) + 1):\n            # Check if the current substring occurs more than once in the input string\n            if stdin[i:j] * 2 in stdin:\n                # Update the longest repeated substring if the current substring is longer\n                if len(stdin[i:j]) > len(longest_repeated_substring):\n                    longest_repeated_substring = stdin[i:j]\n\n    return longest_repeated_substring"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    longest_repeated_substring = \"\"\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = stdin[i:j]\n            if stdin.count(substring) > 1:\n                if len(substring) > len(longest_repeated_substring):\n                    longest_repeated_substring = substring\n                elif len(substring) == len(longest_repeated_substring) and substring < longest_repeated_substring:\n                    longest_repeated_substring = substring\n    return longest_repeated_substring\n\ndef"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Convert the input string to a list of characters for easy manipulation\n    chars = list(stdin)\n\n    # Initialize variables for the longest repeated substring and its length\n    longest_substring = \"\"\n    longest_length = 0\n\n    # Iterate through the list of characters\n    for i in range(len(chars)):\n        for j in range(i + 1, len(chars) + 1):\n            # Check if the current substring occurs more than once in the input string\n            if stdin.count(chars[i:j]) > 1:\n                # If it does, check if its length is greater than the current longest repeated substring\n                if len(chars[i:j]) > longest_length:\n                    longest_substring = chars[i:j]\n                    longest_length = len(chars[i:j])\n\n    # Return the longest repeated substring\n    return longest_substring\n"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    max_substring = \"\"\n    substrings = set()\n    for i in range(len(stdin)):\n        for j in range(i+1, len(stdin)+1):\n            substring = stdin[i:j]\n            if substring in substrings:\n                max_substring = max(max_substring, substring)\n            else:\n                substrings.add(substring)\n    return max_substring\n\ndef"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_ticket_cost(A: int, B: int) -> int:\n        return 2 + abs(A - B)\n\n    def calculate_coupons(ticket: tuple, time: int) -> int:\n        A, B = ticket\n        return calculate_ticket_cost(A, B)\n\n    def find_valid_ticket(time: int, tickets: list) -> tuple:\n        for ticket in tickets:\n            A, B = ticket\n            if A <= time <= B:\n                return ticket\n        return None\n\n    def process_trips(trips: list, time: int) -> int:\n        coupons = 0\n        valid_ticket = find_valid_ticket(time, trips)\n        while valid_ticket:\n            coupons += calculate_coupons(valid_ticket, time)\n            time += 10000\n            valid_ticket = find_valid_ticket(time, trips)\n        return coupons\n\n    N, *trips = stdin.split()\n    N = int(N)\n    trips = [tuple(map(int, trip.split())) for trip in trips]\n\n    coupons = process_trips(trips, 0)\n\n    return str(coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_coupons(N: int, trips: list) -> int:\n        trips.sort()\n        min_coupons = 0\n        current_coupons = 0\n        for trip in trips:\n            start_zone, start_time = trip\n            min_coupons += current_coupons + 2\n            current_coupons = 2 + abs(start_zone - start_zone)\n        return min_coupons\n\n    N = int(stdin.split()[0])\n    trips = []\n    for i in range(1, N + 1):\n        zone, time = map(int, stdin.split()[i].split())\n        trips.append((zone, time))\n\n    return str(get_min_coupons(N, trips))"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    coupons = 0\n    zone_dict = {}\n\n    for i in range(1, N+1):\n        zone, time = [int(j) for j in input_list[i].split()]\n\n        if zone not in zone_dict:\n            zone_dict[zone] = [time]\n        else:\n            zone_dict[zone].append(time)\n\n    for key, value in zone_dict.items():\n        if len(value) == 1:\n            coupons += 2\n        else:\n            for i in range(len(value)-1):\n                coupons += 2 + abs(value[i+1] - value[i])\n\n    return coupons"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    coupons = []\n    for i in range(1, N+1):\n        zone, time = map(int, input_list[i].split())\n        coupons.append((zone, time))\n    \n    coupons.sort(key=lambda x: x[1])\n    coupons.append((0, 1000000000))\n\n    total_coupons = 0\n    current_zone = 0\n    for zone, time in coupons:\n        total_coupons += 2 + abs(current_zone - zone)\n        current_zone = zone\n\n    return str(total_coupons)\n"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    input_list = input_list[1:]\n    coupons = 0\n    intervals = []\n\n    for i in range(N):\n        A, B, T = map(int, input_list[i].split())\n        intervals.append((A, B))\n        coupons += 2 + abs(A - B)\n\n    intervals = sorted(intervals, key=lambda x: (-x[1], x[0]))\n    for i in range(N):\n        A, B = intervals[i]\n        coupons -= 2 + abs(A - B)\n        for j in range(i + 1, N):\n            C, D = intervals[j]\n            if A <= C <= B:\n                coupons += 2 + abs(C - D)\n            elif A <= D <= B:\n                coupons += 2 + abs(A - D)\n            else:\n                continue\n    return coupons\n\ndef"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_ticket_cost(ticket_zone_interval):\n        return 2 + abs(ticket_zone_interval[0] - ticket_zone_interval[1])\n\n    def find_minimum_coupons(trips):\n        coupons_count = 0\n        ticket_zone_intervals = []\n        for trip in trips:\n            ticket_zone_intervals.append(trip)\n            ticket_zone_intervals.sort(key=lambda x: x[1])\n\n            # check if there is a valid ticket for the current trip\n            valid_ticket = False\n            for i in range(len(ticket_zone_intervals)):\n                if ticket_zone_intervals[i][0] <= trip[0] and ticket_zone_intervals[i][1] >= trip[0]:\n                    valid_ticket = True\n                    break\n            if not valid_ticket:\n                coupons_count += get_ticket_cost([0, trip[0]])\n                ticket_zone_intervals.append([0, trip[0]])\n\n            # check if the trip is in a valid interval for any ticket\n            valid_interval = False\n            for i in range(len(ticket_zone_intervals)):\n                if ticket_zone_intervals[i][0] <= trip[0] and ticket_zone_intervals[i][1] >= trip[1]:\n                    valid_interval = True\n                    break\n            if not valid_interval:\n                coupons_count += get_ticket_cost([ticket_zone_intervals[i][1], trip[1]])\n                ticket_zone_intervals[i][1] = trip[1]\n\n        return coupons_count\n\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    trips = []\n    for i in range(1, N + 1):\n        Z, T = map(int, input_list[i].split())\n        trips.append((Z, T))\n\n    return str(find_minimum_coupons(trips))"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def purchase_ticket(A, B, time):\n        return 2 + abs(A - B)\n\n    def is_valid(A, B, time):\n        return A <= time <= B\n\n    N, *trips = stdin.split()\n    N = int(N)\n    trips = [list(map(int, trip.split())) for trip in trips]\n    total_coupons = 0\n\n    for i in range(N):\n        A, B, time = trips[i]\n        coupons = purchase_ticket(A, B, time)\n        total_coupons += coupons\n\n    return total_coupons\n"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_ticket_cost(start_zone: int, end_zone: int) -> int:\n        return 2 + abs(start_zone - end_zone)\n\n    N = int(stdin.split('\\n')[0])\n    trips = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    if not trips:\n        return \"0\"\n\n    min_coupons = float('inf')\n    for i in range(N):\n        start_zone, start_time = trips[i]\n        if i == N - 1:\n            min_coupons = min(min_coupons, find_ticket_cost(start_zone, 0))\n            break\n\n        end_zone, end_time = trips[i + 1]\n        min_coupons = min(min_coupons, find_ticket_cost(start_zone, end_zone))\n\n    return str(min_coupons)\n"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N = int(input_list[0])\n    coupons = 0\n    zones = [0]\n    for i in range(1, len(input_list)):\n        zone, time = map(int, input_list[i].split())\n        coupons += 2 + abs(zones[-1] - zone)\n        zones.append(zone)\n    return str(coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    coupons = 0\n    for i in range(1, N+1):\n        A, B, T = map(int, input_list[i].split())\n        if A <= B:\n            coupons += 2 + abs(A - B)\n        else:\n            coupons += 2 + abs(B - A)\n    return str(coupons)\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def count_ways(root: int) -> int:\n        if root == 1:\n            return 1\n\n        ways = [0] * 2\n        for child in range(1, root):\n            if ways[0] == 0 and ways[1] == 0:\n                break\n            ways[0] = (ways[0] + count_ways(child)) % MOD\n            ways[1] = (ways[1] + ways[0]) % MOD\n\n        return (ways[0] + ways[1]) % MOD\n\n    n, *nodes = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    if n == 1:\n        return \"1\"\n\n    nodes.sort(reverse=True)\n    root = nodes[0]\n    ways = count_ways(root)\n\n    for i in range(1, n):\n        root = lcm(root, nodes[i])\n        ways = (ways + count_ways(root)) % MOD\n\n    return str(ways)\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a: int, b: int) -> int:\n        return (a * b) // gcd(a, b)\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    n = int(stdin[0].strip())\n    values = [int(x.strip()) for x in stdin[1].split()]\n    if n == 1:\n        return \"1\"\n\n    # Create a tree from the values\n    tree = {}\n    for i in range(n):\n        if i % 2 == 0:\n            tree[values[i]] = {\"left\": None, \"right\": None}\n        else:\n            tree[values[i - 1]][\"right\"] = values[i]\n            tree[values[i]] = {\"left\": None, \"right\": None}\n\n    # Count the number of ways to arrange the nodes into an LCM tree\n    count = 1\n    for i in range(n // 2):\n        left = tree[values[i]]\n        right = tree[values[n - i - 1]]\n        lcm_value = lcm(left[\"value\"], right[\"value\"])\n        count = (count * (2 * i + 1)) % (10**9 + 7)\n        left[\"value\"] = lcm_value\n        right[\"value\"] = lcm_value\n\n    # Count the number of ways to arrange the nodes into an LCM tree\n    # when the values of the nodes are swapped\n    count_swapped = 1\n    for i in range(n // 2):\n        left = tree[values[i]]\n        right = tree[values[n - i - 1]]\n        lcm_value = lcm(left[\"value\"], right[\"value\"])\n        count_swapped = (count_swapped * (2 * i + 1)) % (10**9 + 7)\n        left[\"value\"] = lcm_value\n        right[\"value\"] = lcm_value\n\n    # The number of ways to arrange the nodes into an LCM tree\n    # is the sum of the counts when the values of the nodes are swapped\n    count = (count + count_swapped) % (10**9 + 7)\n\n    return str(count)\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    if n % 2 == 0:\n        return \"0\"\n    nodes = list(map(int, stdin.splitlines()[1].split()))\n    MOD = 10**9 + 7\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def dfs(node, parent, used, memo):\n        if node >= n:\n            return 1\n        if parent is None:\n            if used[node] == 0:\n                return dfs(node + 1, None, used, memo)\n            else:\n                return 0\n        if (parent, node) in memo:\n            return memo[(parent, node)]\n        if used[node] == 0:\n            res = dfs(node + 1, parent, used, memo)\n            for i in range(n):\n                if i != parent and used[i] == 0:\n                    res += dfs(node + 1, i, used, memo)\n                    res %= MOD\n            memo[(parent, node)] = res\n        return memo[(parent, node)]\n\n    used = [0] * n\n    used[0] = 1\n    memo = {}\n    res = dfs(1, None, used, memo)\n    return str(res)\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(x: int, y: int) -> int:\n        return (x * y) // gcd(x, y)\n\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    def lcm_tree(root: int, nodes: list[int]) -> int:\n        if root == 1:\n            return 1\n        left = 2 * root\n        right = 2 * root + 1\n        left_val = lcm(root, nodes[left]) if left < len(nodes) else 1\n        right_val = lcm(root, nodes[right]) if right < len(nodes) else 1\n        return lcm(left_val, right_val)\n\n    n = int(stdin[0])\n    nodes = [int(x) for x in stdin[1].split()]\n    root = nodes[0]\n    nodes = nodes[1:]\n    result = 0\n    for tree in range(1, 2 ** n):\n        tree_nodes = [root]\n        for i in range(n - 1):\n            bit = (tree >> (n - i - 1)) & 1\n            if bit:\n                tree_nodes.append(lcm_tree(tree_nodes[-1], nodes))\n            else:\n                tree_nodes.append(lcm_tree(tree_nodes[-2], nodes))\n                tree_nodes.pop()\n        if tree_nodes[-1] == nodes[-1]:\n            result += 1\n    return str(result % (10**9 + 7))\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(x: int, y: int) -> int:\n        return x * y // math.gcd(x, y)\n\n    def helper(values: List[int], i: int) -> int:\n        if i == len(values) - 1:\n            return 1\n\n        count = 0\n        for j in range(i + 1, len(values)):\n            if lcm(values[i], values[j]) == values[i + 1]:\n                count += helper(values, j + 1)\n                count %= MOD\n\n        return count\n\n    n = int(stdin.split('\\n')[0])\n    values = list(map(int, stdin.split('\\n')[1].split()))\n    MOD = 10**9 + 7\n    return helper(values, 0)\n\n\nn = 7\nvalues = [2, 3, 4, 4, 8, 12, 24]\nprint(solution(str(n) + '\\n' + ' '.join(map(str, values))))\n\nn = 3\nvalues = [7, 7, 7]\nprint(solution(str(n) + '\\n' + ' '.join(map(str, values))))\n\nn = 5\nvalues = [1, 2, 3, 2, 1]\nprint(solution(str(n) + '\\n' + ' '.join(map(str, values)))) "
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(x: int, y: int) -> int:\n        return (x * y) // math.gcd(x, y)\n\n    def dfs(idx: int, parent: int) -> int:\n        if idx == n:\n            return 1\n\n        result = 0\n        for child in range(idx + 1, n):\n            if parent == -1 or tree[child] != tree[parent]:\n                result += dfs(child, idx)\n\n        return result\n\n    n = int(stdin.split(\"\\n\")[0])\n    tree = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lcm(tree[i], tree[j]) == tree[i] + tree[j]:\n                count += dfs(0, -1)\n                count %= (10**9 + 7)\n\n    return str(count)\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from math import gcd\n\n    def lcm(x, y):\n        return (x * y) // gcd(x, y)\n\n    def lcm_tree(tree):\n        if len(tree) == 1:\n            return [tree]\n        else:\n            left_trees = lcm_tree(tree[:len(tree) // 2])\n            right_trees = lcm_tree(tree[len(tree) // 2:])\n            result = []\n            for left_tree in left_trees:\n                for right_tree in right_trees:\n                    root_value = lcm(left_tree[-1], right_tree[-1])\n                    if root_value < tree[len(tree) // 2 - 1]:\n                        result.append([*left_tree, root_value, *right_tree])\n            return result\n\n    def count_ways(tree, cache):\n        if len(tree) == 1:\n            return 1\n        else:\n            left_ways = count_ways(tree[:len(tree) // 2], cache)\n            right_ways = count_ways(tree[len(tree) // 2:], cache)\n            total_ways = left_ways * right_ways\n            root_value = tree[len(tree) // 2 - 1]\n            key = (root_value, len(tree))\n            if key in cache:\n                total_ways -= cache[key]\n            cache[key] = total_ways\n            return total_ways % (10**9 + 7)\n\n    n, *values = map(int, stdin.split())\n    values.sort()\n    tree = values + [0] * (2 * n - 1)\n    tree[n - 1] = values[n - 1] * (2 * n - 1)\n\n    ways = 0\n    for i in range(1, 2 * n - 1):\n        ways += count_ways(lcm_tree([tree[i - 1], tree[i + 1]])[0], {})\n    return str(ways % (10**9 + 7))\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def lcm_tree(root: int, values: list) -> int:\n        if root >= len(values):\n            return 1\n        left = lcm_tree(2 * root + 1, values)\n        right = lcm_tree(2 * root + 2, values)\n        return left * right * values[root] // gcd(values[root], left * right)\n\n    n, *values = map(int, stdin.split())\n    lcm_tree_root = lcm_tree(0, values)\n    return str(lcm_tree_root % (10**9 + 7))\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    n = int(input_list[0])\n    values = list(map(int, input_list[1].split()))\n\n    def lcm(a: int, b: int) -> int:\n        return (a * b) // math.gcd(a, b)\n\n    def dfs(node: int, parent: int) -> int:\n        left, right = 2 * node + 1, 2 * node + 2\n        if left >= n:\n            return 1\n        res = 0\n        for child in range(left, right + 1):\n            if child != parent:\n                res += dfs(child, node)\n        return res % MOD\n\n    MOD = 1000000007\n    if n == 1:\n        return '1'\n\n    values.sort(reverse=True)\n    for i in range(1, n):\n        if lcm(values[i - 1], values[i]) != values[i - 1]:\n            return '0'\n\n    return str(dfs(0, -1))\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    values = list(map(int, stdin.split('\\n')[1].split()))\n\n    def lcm(x: int, y: int) -> int:\n        return (x * y) // math.gcd(x, y)\n\n    def dfs(start: int, values: List[int], memo: Dict[int, int]) -> int:\n        if start == n:\n            return 1\n\n        if start in memo:\n            return memo[start]\n\n        total = 0\n        for i in range(start, n):\n            total += dfs(i + 1, values, memo)\n\n        memo[start] = total\n        return total\n\n    memo = {}\n    total = dfs(0, values, memo)\n    return str(total % (10**9 + 7))\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[1:]\n    grid = [[cell for cell in row] for row in grid]\n\n    def find_nearest_cell(x, y, directions):\n        for dx, dy in directions:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < N and 0 <= new_y < M and grid[new_x][new_y] != '#':\n                return new_x, new_y\n        return None, None\n\n    def move(x, y, direction):\n        dx, dy = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}[direction]\n        new_x, new_y = x + dx, y + dy\n        if 0 <= new_x < N and 0 <= new_y < M and grid[new_x][new_y] != '#':\n            return new_x, new_y\n        return x, y\n\n    def find_treasure(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < N and 0 <= new_y < M and grid[new_x][new_y] == 'G':\n                return new_x, new_y\n        return None, None\n\n    def search():\n        days = 0\n        stamina = K\n        x, y = 0, 0\n        while True:\n            if grid[x][y] == 'S':\n                days = 1\n            elif grid[x][y] == 'G':\n                return days\n            else:\n                days += 1\n\n            directions = [('U', -1), ('D', 1), ('L', -1), ('R', 1)]\n            for direction in directions:\n                new_x, new_y = move(x, y, direction[0])\n                if stamina >= getattr(grid[new_x][new_y], direction[0]) * direction[1]:\n                    x, y = new_x, new_y\n                    stamina -= getattr(grid[x][y], direction[0]) * direction[1]\n                    break\n            else:\n                break\n\n        return -1\n\n    return str(search())\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[1:]\n\n    def is_valid(x, y):\n        if 0 <= x < N and 0 <= y < M:\n            return True\n        return False\n\n    def move(x, y, dx, dy):\n        if is_valid(x+dx, y+dy):\n            if grid[x][y] == '.':\n                return x+dx, y+dy, 1\n            elif grid[x][y] == 'F':\n                return x+dx, y+dy, 2\n            elif grid[x][y] == 'M':\n                return x+dx, y+dy, 3\n            elif grid[x][y] == 'S':\n                return x, y, 0\n            elif grid[x][y] == 'G':\n                return x, y, -1\n            elif grid[x][y] == '#':\n                return x+dx, y+dy, 0\n            else:\n                return x, y, 0\n        return x, y, 0\n\n    def dfs(x, y, stamina):\n        if stamina < 0:\n            return float('inf')\n        if x == N-1 and y == M-1:\n            return 0\n        if not is_valid(x, y) or grid[x][y] == '#':\n            return float('inf')\n\n        return min(dfs(x+dx, y+dy, stamina-cost) for dx, dy, cost in ((0, 1, 1), (0, -1, 1), (1, 0, 1), (-1, 0, 1)))\n\n    if K >= 4:\n        result = dfs(0, 0, K)\n        if result == float('inf'):\n            return \"-1\"\n        else:\n            return result + 1\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    grid = [input().strip() for _ in range(N)]\n\n    def is_valid(i, j):\n        return 0 <= i < N and 0 <= j < M and grid[i][j] == '.'\n\n    def manhattan_distance(i1, j1, i2, j2):\n        return abs(i1 - i2) + abs(j1 - j2)\n\n    def bfs(start_i, start_j, target_i, target_j, stamina):\n        visited = [[False for _ in range(M)] for _ in range(N)]\n        visited[start_i][start_j] = True\n        queue = [(start_i, start_j, 0, 0)]\n\n        while queue:\n            i, j, di, dj = queue.pop(0)\n            if i == target_i and j == target_j:\n                return di + dj + stamina\n\n            if is_valid(i - di, j - dj) and not visited[i - di][j - dj]:\n                queue.append((i - di, j - dj, di + 1, dj))\n            if is_valid(i + di, j + dj) and not visited[i + di][j + dj]:\n                queue.append((i + di, j + dj, di, dj + 1))\n            if is_valid(i - dj, j + di) and not visited[i - dj][j + di]:\n                queue.append((i - dj, j + di, di, dj - 1))\n            if is_valid(i + dj, j - di) and not visited[i + dj][j - di]:\n                queue.append((i + dj, j - di, di, dj + 1))\n\n        return -1\n\n    start_i, start_j = None, None\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i, start_j = i, j\n                break\n        if start_i is not None:\n            break\n\n    target_i, target_j = None, None\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'G':\n                target_i, target_j = i, j\n                break\n        if target_i is not None:\n            break\n\n    if start_i is None or target_i is None:\n        return -1\n\n    days = 0\n    while days < 100:\n        stamina = bfs(start_i, start_j, target_i, target_j, K)\n        if stamina == -1:\n            return -1\n        days += 1\n        K = 4\n\n    return days - 1\n\ninput_data = '''3 5 4\nS#.F.\n.MFMG\n'''\n\nprint(solution(input_data))"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[1:]\n    grid = [list(line) for line in grid]\n\n    def get_cost(cell):\n        if cell == 'S':\n            return 0\n        elif cell == 'F':\n            return 2\n        elif cell == 'M':\n            return 3\n        elif cell == 'G':\n            return float('inf')\n        else:\n            return 1\n\n    def get_new_pos(pos, direction):\n        new_pos = list(pos)\n        if direction == 'U':\n            new_pos[0] -= 1\n        elif direction == 'D':\n            new_pos[0] += 1\n        elif direction == 'L':\n            new_pos[1] -= 1\n        elif direction == 'R':\n            new_pos[1] += 1\n        return tuple(new_pos)\n\n    def dfs(pos, visited, path, stamina):\n        if stamina < 0:\n            return False\n        if pos == (N - 1, M - 1):\n            return True\n        visited.add(pos)\n        for direction in ['U', 'D', 'L', 'R']:\n            new_pos = get_new_pos(pos, direction)\n            if new_pos not in visited and 0 <= new_pos[0] < N and 0 <= new_pos[1] < M:\n                if grid[new_pos[0]][new_pos[1]] != '#':\n                    if dfs(new_pos, visited, path + [direction], stamina - get_cost(grid[pos[0]][pos[1]])):\n                        return True\n        return False\n\n    stamina = K\n    visited = set()\n    path = []\n    days = 1\n    while not dfs((0, 0), visited, path, stamina):\n        if stamina == 0:\n            break\n        days += 1\n        stamina = K\n        if days % 2 == 0 and days > 1:\n            visited = set()\n            path = []\n    else:\n        return days\n    return -1\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    grid = [input().strip() for _ in range(N)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M and grid[x][y] != '#'\n\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def bfs(x, y, target_x, target_y):\n        queue = [(x, y, 0)]\n        seen = {(x, y): 0}\n        while queue:\n            x, y, d = queue.pop(0)\n            if (x, y) == (target_x, target_y):\n                return d\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and (nx, ny) not in seen and seen.get((nx, ny), float('inf')) > d + 1:\n                    seen[(nx, ny)] = d + 1\n                    queue.append((nx, ny, d + 1))\n        return float('inf')\n\n    source_x, source_y = 0, 0\n    for i in range(N):\n        source_y = grid[i].index('S')\n        if grid[i][source_y] == 'S':\n            source_x = i\n            break\n\n    target_x, target_y = 0, 0\n    for i in range(N):\n        target_y = grid[i].index('G')\n        if grid[i][target_y] == 'G':\n            target_x = i\n            break\n\n    days = 0\n    while source_x != target_x or source_y != target_y:\n        if K == 0:\n            return -1\n        if days % 2 == 0 and grid[source_x][source_y] == 'F':\n            K -= 2\n        elif days % 2 == 1 and grid[source_x][source_y] == 'M':\n            K -= 3\n        if K == 0:\n            return -1\n        if grid[source_x][source_y] == 'S':\n            distance_to_target = bfs(source_x, source_y, target_x, target_y)\n        else:\n            distance_to_target = 0\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = source_x + dx, source_y + dy\n                if is_valid(nx, ny) and (grid[nx][ny] == 'F' or grid[nx][ny] == 'M'):\n                    distance_to_target = min(distance_to_target, bfs(source_x, source_y, target_x, target_y))\n        if distance_to_target == float('inf'):\n            return -1\n        if distance_to_target % 2 == 0 and grid[source_x][source_y] == 'F':\n            K -= 2\n        elif distance_to_target % 2 == 1 and grid[source_x][source_y] == 'M':\n            K -= 3\n        if K == 0:\n            return -1\n        days += 1\n        if days % 2 == 0:\n            K -= 1\n        source_x, source_y = target_x, target_y\n    return days\n\nT = int(input())\nfor _ in range(T):\n    stdin = input()\n    print(solution(stdin)) "
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    grid = [input() for _ in range(N)]\n\n    def valid_move(row, col, direction):\n        if direction == 0:  # up\n            return 0 <= row - 1 < N\n        elif direction == 1:  # down\n            return 0 <= row + 1 < N\n        elif direction == 2:  # left\n            return 0 <= col - 1 < M\n        elif direction == 3:  # right\n            return 0 <= col + 1 < M\n        else:\n            raise ValueError(\"Invalid direction\")\n\n    def move(row, col, direction):\n        if direction == 0:  # up\n            row -= 1\n        elif direction == 1:  # down\n            row += 1\n        elif direction == 2:  # left\n            col -= 1\n        elif direction == 3:  # right\n            col += 1\n        else:\n            raise ValueError(\"Invalid direction\")\n        return row, col\n\n    def get_cost(row, col):\n        if grid[row][col] == '.':\n            return 1\n        elif grid[row][col] == 'F':\n            return 2\n        elif grid[row][col] == 'M':\n            return 3\n        else:\n            raise ValueError(\"Invalid cell type\")\n\n    def search_treasure(row, col, stamina):\n        if grid[row][col] == 'G':\n            return stamina\n        elif stamina <= 0:\n            return -1\n        else:\n            min_cost = float('inf')\n            for direction in range(4):\n                new_row, new_col = move(row, col, direction)\n                if valid_move(new_row, new_col, direction):\n                    cost = get_cost(new_row, new_col)\n                    remaining_stamina = stamina - cost\n                    if remaining_stamina < 0:\n                        treasure = search_treasure(new_row, new_col, K)\n                        if treasure != -1:\n                            min_cost = min(min_cost, cost + treasure)\n                    else:\n                        treasure = search_treasure(new_row, new_col, remaining_stamina)\n                        if treasure != -1:\n                            min_cost = min(min_cost, cost + treasure)\n            return min_cost if min_cost != float('inf') else -1\n\n    return search_treasure(0, 0, K)\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[1:]\n    grid = [''.join(line.split()) for line in grid]\n\n    def get_distance(x1, y1, x2, y2):\n        return abs(x2 - x1) + abs(y2 - y1)\n\n    def get_neighbors(x, y):\n        return [(x1, y1) for x1 in range(x - 1, x + 2) for y1 in range(y - 1, y + 2) if (x1, y1) != (x, y) and 0 <= x1 < N and 0 <= y1 < M]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M\n\n    def move(x, y, dx, dy):\n        x1, y1 = x + dx, y + dy\n        if is_valid(x1, y1) and grid[x1][y1] != '#' and grid[x1][y1] != 'S':\n            return x1, y1\n        return x, y\n\n    def min_cost(x, y):\n        if grid[x][y] == 'S':\n            return 0\n        if grid[x][y] == 'G':\n            return 0\n        if grid[x][y] == 'F':\n            return 2\n        if grid[x][y] == 'M':\n            return 3\n        return 1\n\n    def find_treasure(x, y, stamina):\n        days = 0\n        while stamina >= 0:\n            if days % 2 == 0:\n                stamina += K\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                x1, y1 = move(x, y, dx, dy)\n                cost = min_cost(x1, y1)\n                if stamina >= cost:\n                    x, y = x1, y1\n                    stamina -= cost\n                    if grid[x][y] == 'G':\n                        return days + 1\n            days += 1\n        return -1\n\n    return str(find_treasure(0, 0, K))\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split(\"\\n\")[1:]\n\n    visited = [[False] * M for _ in range(N)]\n    queue = [(0, 0, 0, 0)]  # (day, x, y, stamina)\n    visited[0][0] = True\n\n    while queue:\n        day, x, y, stamina = queue.pop(0)\n\n        if (x, y) == (N - 1, M - 1):\n            return day\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny]:\n                visited[nx][ny] = True\n\n                if grid[nx][ny] == \".\":\n                    next_stamina = max(0, stamina - 1)\n                elif grid[nx][ny] == \"F\":\n                    next_stamina = max(0, stamina - 2)\n                elif grid[nx][ny] == \"M\":\n                    next_stamina = max(0, stamina - 3)\n                else:\n                    continue\n\n                next_day = day + 1\n                if next_stamina == K:\n                    next_day = max(next_day, day + 1)\n\n                queue.append((next_day, nx, ny, next_stamina))\n\n    return -1\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    grid = [list(line) for line in stdin.split('\\n')[1:N+1]]\n    \n    def move_to(x, y, dx, dy):\n        return grid[x+dx][y+dy]\n    \n    def move(x, y, dx, dy):\n        return move_to(x, y, dx, dy) == '.' and K >= 1 + move_to(x+dx, y+dy, -dx, -dy) in {'F', 'M', '#', 'G'}.count('G')\n    \n    def bfs(x, y, dx, dy):\n        visited = set()\n        queue = [(x, y, 0)]\n        while queue:\n            x, y, d = queue.pop(0)\n            if (x, y, d) in visited:\n                continue\n            visited.add((x, y, d))\n            if move(x, y, dx, dy) and (x, y, d+1) not in visited:\n                queue.append((x+dx, y+dy, d+1))\n        return visited\n    \n    s_x, s_y = 0, 0\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                s_x, s_y = i, j\n                break\n        if s_x != 0:\n            break\n    \n    if grid[s_x][s_y] != 'S':\n        return \"-1\"\n    \n    days = 0\n    while not (grid[s_x][s_y] == 'G' or days >= 2):\n        visited = bfs(s_x, s_y, -1, 0) | bfs(s_x, s_y, 1, 0) | bfs(s_x, s_y, 0, -1) | bfs(s_x, s_y, 0, 1)\n        visited.add((s_x, s_y, 0))\n        if not visited:\n            return \"-1\"\n        \n        s_x, s_y, d = visited.pop()\n        K -= 1 + d\n        days += 1\n    \n    return str(days) if grid[s_x][s_y] == 'G' else \"-1\"\n\ninput_1 = \"2 5 4\\nS#.F.\\n.MFMG\"\ninput_2 = \"1 2 1\\nGS\"\ninput_3 = \"2 2 10\\nS#\\n#G\"\n\nprint(solution(input_1)) # Output: 3\nprint(solution(input_2)) # Output: 1\nprint(solution(input_3)) # Output: -1 "
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    grid = [input() for _ in range(N)]\n    \n    def get_neighbor(i: int, j: int) -> int:\n        directions = [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]\n        valid_neighbors = [(x, y) for x, y in directions if 0 <= x < N and 0 <= y < M]\n        return min(valid_neighbors, key=lambda x: grid[x[0]][x[1]])\n\n    def search(i: int, j: int, stamina: int) -> int:\n        if grid[i][j] == 'G':\n            return 0\n        if stamina == 0:\n            return float('inf')\n        if stamina < 1 or grid[i][j] == '#':\n            return float('inf')\n        if grid[i][j] == 'F':\n            stamina -= 2\n        elif grid[i][j] == 'M':\n            stamina -= 3\n        else:\n            stamina -= 1\n        current = (i, j)\n        next_cell = get_neighbor(*current)\n        return 1 + search(*next_cell, stamina)\n\n    if N * M > 50 or K > 100:\n        return -1\n\n    min_days = float('inf')\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                min_days = min(min_days, search(i, j, K))\n\n    if min_days == float('inf'):\n        return -1\n    return min_days\n"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, cmd_str = input().split()\n    H, W = int(H), int(W)\n    grid = [input() for _ in range(H)]\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < H and 0 <= y < W and grid[x][y] != '#'\n\n    def dfs(x: int, y: int, cmd: str) -> bool:\n        if (x, y) == (H - 1, W - 1):\n            return True\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and cmd[0] in ['L', 'R', 'U', 'D']:\n                if dfs(nx, ny, cmd[1:]):\n                    return True\n        return False\n\n    def fix_cmd_str(cmd_str: str) -> str:\n        count = 0\n        for i, c in enumerate(cmd_str):\n            if c in ['L', 'R', 'U', 'D']:\n                count += 1\n            else:\n                cmd_str = cmd_str[:i] + cmd_str[i + 1:]\n                count += 1\n        return count\n\n    return fix_cmd_str(cmd_str)"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    H, W, command_string = input(stdin).split('\\n')\n    H, W = int(H), int(W)\n    grid = [input() for _ in range(H)]\n\n    # Find the starting and goal positions\n    for i, row in enumerate(grid):\n        for j, col in enumerate(row):\n            if col == 'S':\n                start_i, start_j = i, j\n            elif col == 'G':\n                goal_i, goal_j = i, j\n\n    # Calculate the number of changes needed\n    i, j = start_i, start_j\n    visited = {(i, j)}\n    changes = 0\n    for cmd in command_string:\n        if cmd == 'L':\n            j -= 1\n        elif cmd == 'R':\n            j += 1\n        elif cmd == 'U':\n            i -= 1\n        elif cmd == 'D':\n            i += 1\n        \n        # Check if the command would cause the robot to leave the grid\n        if i < 0 or i >= H or j < 0 or j >= W:\n            changes += 1\n            i, j = start_i, start_j\n        \n        # Check if the command would run into an obstacle\n        if grid[i][j] == '#':\n            changes += 1\n            i, j = start_i, start_j\n        \n        # Check if the command would reach the goal\n        if (i, j) == (goal_i, goal_j) and changes % 2 == 0:\n            changes += 1\n            i, j = start_i, start_j\n        \n        # Check if the robot has already visited this position\n        if (i, j) in visited:\n            changes += 1\n            i, j = start_i, start_j\n        else:\n            visited.add((i, j))\n    \n    return changes"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    H, W, cmd_str = map(int, input().split())\n    grid = [input() for _ in range(H)]\n    start = tuple(map(lambda x: x == \"S\", grid[0]))\n    goal = tuple(map(lambda x: x == \"G\", grid[-1]))\n\n    # Helper function to check if a move is valid\n    def is_valid(pos):\n        x, y = pos\n        return 0 <= x < H and 0 <= y < W and grid[x][y] == \".\"\n\n    # Helper function to find the next move based on the command\n    def next_move(pos, cmd):\n        x, y = pos\n        if cmd == \"L\":\n            return (x, y - 1) if is_valid((x, y - 1)) else pos\n        elif cmd == \"R\":\n            return (x, y + 1) if is_valid((x, y + 1)) else pos\n        elif cmd == \"U\":\n            return (x - 1, y) if is_valid((x - 1, y)) else pos\n        elif cmd == \"D\":\n            return (x + 1, y) if is_valid((x + 1, y)) else pos\n\n    # Helper function to check if the command string is valid\n    def is_valid_cmd(cmd_str):\n        pos = start\n        for cmd in cmd_str:\n            if cmd == \"L\" or cmd == \"R\" or cmd == \"U\" or cmd == \"D\":\n                pos = next_move(pos, cmd)\n        return pos == goal\n\n    # Initialize a list of valid commands\n    valid_cmds = [cmd for cmd in cmd_str if is_valid_cmd(cmd_str[:i] + cmd_str[i+1:])]\n\n    # Calculate the minimum number of changes needed\n    min_changes = len(cmd_str) - len(valid_cmds)\n\n    return min_changes"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[0:2])\n    grid = stdin.split('\\n')[1:H+1]\n    start, goal = None, None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n    command_string = stdin.split('\\n')[-1]\n\n    def is_valid_move(robot: tuple, direction: str) -> bool:\n        i, j = robot\n        di, dj = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}[direction]\n        i_new, j_new = i + di, j + dj\n        if 0 <= i_new < H and 0 <= j_new < W:\n            if grid[i_new][j_new] != '#' and (i_new, j_new) != start:\n                return True\n        return False\n\n    def is_successful(robot: tuple) -> bool:\n        return robot == goal\n\n    def is_valid_sequence(sequence: str) -> bool:\n        robot = start\n        for command in sequence:\n            if command in ['U', 'D', 'L', 'R']:\n                if is_valid_move(robot, command):\n                    robot = (robot[0] + {'U': -1, 'D': 1, 'L': 0, 'R': 0}[command],\n                             robot[1] + {'U': 0, 'D': 0, 'L': -1, 'R': 1}[command])\n        return is_successful(robot)\n\n    def min_changes(command_string: str) -> int:\n        min_changes = 0\n        for i in range(len(command_string)):\n            new_command_string = command_string[:i] + command_string[i+1:]\n            if not is_valid_sequence(new_command_string):\n                min_changes += 1\n            else:\n                new_command_string = command_string[:i] + 'D' + command_string[i+1:]\n                if not is_valid_sequence(new_command_string):\n                    min_changes += 1\n        return min_changes\n\n    return min_changes(command_string)"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    H, W, cmd, grid = input().split()\n    H, W = int(H), int(W)\n    grid = list(grid)\n    for i in range(H):\n        grid[i] = list(grid[i])\n    start_pos = None\n    goal_pos = None\n    obstacles = []\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start_pos = (i, j)\n            elif grid[i][j] == 'G':\n                goal_pos = (i, j)\n            elif grid[i][j] == '#':\n                obstacles.append((i, j))\n\n    def is_valid(pos):\n        return 0 <= pos[0] < H and 0 <= pos[1] < W and grid[pos[0]][pos[1]] != '#'\n\n    def move(pos, direction):\n        if direction == 'L' and is_valid((pos[0], pos[1]-1)):\n            return (pos[0], pos[1]-1)\n        elif direction == 'R' and is_valid((pos[0], pos[1]+1)):\n            return (pos[0], pos[1]+1)\n        elif direction == 'U' and is_valid((pos[0]-1, pos[1])):\n            return (pos[0]-1, pos[1])\n        elif direction == 'D' and is_valid((pos[0]+1, pos[1])):\n            return (pos[0]+1, pos[1])\n        else:\n            return pos\n\n    def dfs(pos, cmd_i):\n        if pos == goal_pos:\n            return True\n        if cmd_i == len(cmd):\n            return False\n        if cmd[cmd_i] == 'L':\n            new_pos = move(pos, 'L')\n            if dfs(new_pos, cmd_i+1):\n                return True\n        elif cmd[cmd_i] == 'R':\n            new_pos = move(pos, 'R')\n            if dfs(new_pos, cmd_i+1):\n                return True\n        elif cmd[cmd_i] == 'U':\n            new_pos = move(pos, 'U')\n            if dfs(new_pos, cmd_i+1):\n                return True\n        elif cmd[cmd_i] == 'D':\n            new_pos = move(pos, 'D')\n            if dfs(new_pos, cmd_i+1):\n                return True\n        return False\n\n    dfs(start_pos, 0)\n    changes = 0\n    for i in range(len(cmd)):\n        if cmd[i] == 'L' or cmd[i] == 'R' or cmd[i] == 'U' or cmd[i] == 'D':\n            changes += 1\n            if changes > 1:\n                return changes-1\n    return changes"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    H, W = map(int, input_data[0].split())\n    grid = [list(row) for row in input_data[1:H+1]]\n    start_pos = None\n    goal_pos = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start_pos = (i, j)\n            elif grid[i][j] == 'G':\n                goal_pos = (i, j)\n\n    command_string = input_data[-1]\n\n    def is_valid(pos, command):\n        row, col = pos\n        if command == 'U':\n            return row > 0\n        elif command == 'D':\n            return row < H-1\n        elif command == 'L':\n            return col > 0\n        elif command == 'R':\n            return col < W-1\n        else:\n            return False\n\n    def is_empty(pos):\n        row, col = pos\n        return grid[row][col] == '.'\n\n    def is_obstacle(pos):\n        row, col = pos\n        return grid[row][col] == '#'\n\n    def is_goal(pos):\n        row, col = pos\n        return grid[row][col] == 'G'\n\n    def execute_command(pos, command):\n        if command == 'U':\n            return (pos[0]-1, pos[1])\n        elif command == 'D':\n            return (pos[0]+1, pos[1])\n        elif command == 'L':\n            return (pos[0], pos[1]-1)\n        elif command == 'R':\n            return (pos[0], pos[1]+1)\n        else:\n            return pos\n\n    def can_move(pos, command):\n        if is_valid(pos, command) and is_empty(pos):\n            return True\n        elif is_valid(pos, command) and is_obstacle(pos):\n            return False\n        else:\n            return False\n\n    def is_reachable(pos):\n        if pos == goal_pos:\n            return True\n        else:\n            return False\n\n    def is_successful(command_string):\n        current_pos = start_pos\n        for command in command_string:\n            if is_valid(current_pos, command) and can_move(current_pos, command):\n                current_pos = execute_command(current_pos, command)\n            elif command in ['U', 'D', 'L', 'R']:\n                current_pos = execute_command(current_pos, command)\n            if is_reachable(current_pos):\n                return True\n        return False\n\n    min_changes = 0\n    for i in range(len(command_string)):\n        if command_string[i] in ['U', 'D', 'L', 'R']:\n            min_changes += 1\n        else:\n            if is_successful(command_string[:i] + command_string[i+1:]):\n                min_changes += 1\n            if is_successful(command_string[:i] + command_string[i+2:]):\n                min_changes += 1\n            if is_successful(command_string[:i] + command_string[i+3:]):\n                min_changes += 1\n            if is_successful(command_string[:i] + command_string[i+4:]):\n                min_changes += 1\n\n    return min_changes"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    H, W = map(int, input_list[0].split())\n    grid = input_list[1:H+1]\n    commands = input_list[-1]\n    \n    def is_valid(i, j, commands, grid):\n        if not (0 <= i < H and 0 <= j < W):\n            return False\n        if grid[i][j] == '#':\n            return False\n        for c in commands:\n            if c == 'L' and j > 0 and grid[i][j-1] == '.':\n                j -= 1\n            elif c == 'R' and j < W-1 and grid[i][j+1] == '.':\n                j += 1\n            elif c == 'U' and i > 0 and grid[i-1][j] == '.':\n                i -= 1\n            else:\n                return False\n        return True\n\n    def dfs(i, j, commands, grid, depth):\n        if is_valid(i, j, commands, grid):\n            return depth\n        for c in commands:\n            if c == 'L' and j > 0 and grid[i][j-1] == '.':\n                depth = dfs(i, j-1, commands, grid, depth+1)\n            elif c == 'R' and j < W-1 and grid[i][j+1] == '.':\n                depth = dfs(i, j+1, commands, grid, depth+1)\n            elif c == 'U' and i > 0 and grid[i-1][j] == '.':\n                depth = dfs(i-1, j, commands, grid, depth+1)\n            else:\n                continue\n            if depth > 0:\n                return depth\n        return -1\n\n    depth = dfs(0, 0, commands, grid, 0)\n\n    if depth == -1:\n        return -1\n    else:\n        return depth\n"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    grid_size = [int(x) for x in input_list.pop(0).split()]\n    grid = input_list[:grid_size[0]]\n    command_string = input_list[-1]\n\n    # Find start and goal positions\n    start_pos = None\n    goal_pos = None\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == 'S':\n                start_pos = (i, j)\n            elif cell == 'G':\n                goal_pos = (i, j)\n\n    # Find all valid moves from start position\n    def get_valid_moves(pos, command_string):\n        moves = []\n        for cmd in command_string:\n            if cmd == 'L':\n                new_pos = (pos[0], (pos[1] - 1) % grid_size[1])\n                if grid[new_pos[0]][new_pos[1]] == '.':\n                    moves.append(new_pos)\n            elif cmd == 'R':\n                new_pos = (pos[0], (pos[1] + 1) % grid_size[1])\n                if grid[new_pos[0]][new_pos[1]] == '.':\n                    moves.append(new_pos)\n            elif cmd == 'U':\n                new_pos = ((pos[0] - 1) % grid_size[0], pos[1])\n                if grid[new_pos[0]][new_pos[1]] == '.':\n                    moves.append(new_pos)\n            elif cmd == 'D':\n                new_pos = ((pos[0] + 1) % grid_size[0], pos[1])\n                if grid[new_pos[0]][new_pos[1]] == '.':\n                    moves.append(new_pos)\n        return moves\n\n    # Breadth-first search to find shortest path\n    queue = [(start_pos, '')]\n    visited = set()\n    while queue:\n        (pos, command) = queue.pop(0)\n        if pos == goal_pos:\n            return len(command)\n        if pos in visited:\n            continue\n        visited.add(pos)\n        for new_pos in get_valid_moves(pos, command):\n            queue.append((new_pos, command + new_pos[1]))"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    H, W, *grid = stdin.split('\\n')\n    H, W = int(H), int(W)\n    grid = [list(row) for row in grid]\n\n    # Calculate the initial position and goal position\n    start_pos = None\n    goal_pos = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start_pos = (i, j)\n            elif grid[i][j] == 'G':\n                goal_pos = (i, j)\n\n    # Initialize the robot's current position and command string\n    current_pos = start_pos\n    command_string = stdin.split('\\n')[-1]\n\n    # Helper function to check if the robot can move in a given direction\n    def can_move(direction):\n        next_pos = current_pos[0] + direction[0], current_pos[1] + direction[1]\n        if 0 <= next_pos[0] < H and 0 <= next_pos[1] < W:\n            if grid[next_pos[0]][next_pos[1]] == '#' or next_pos == goal_pos:\n                return False\n            else:\n                return True\n        else:\n            return False\n\n    # Helper function to check if the robot can reach the goal\n    def can_reach_goal():\n        for i in range(len(command_string)):\n            if command_string[i] == 'L' and can_move((-1, 0)):\n                current_pos = (current_pos[0], current_pos[1] - 1)\n            elif command_string[i] == 'R' and can_move((1, 0)):\n                current_pos = (current_pos[0], current_pos[1] + 1)\n            elif command_string[i] == 'U' and can_move((0, 1)):\n                current_pos = (current_pos[0] - 1, current_pos[1])\n            elif command_string[i] == 'D' and can_move((0, -1)):\n                current_pos = (current_pos[0] + 1, current_pos[1])\n            else:\n                continue\n            if current_pos == goal_pos:\n                return True\n        return False\n\n    # Check if the robot can reach the goal with the current command string\n    if can_reach_goal():\n        return 0\n\n    # Otherwise, we need to fix the command string\n    min_changes = float('inf')\n    for i in range(len(command_string)):\n        for j in range(i, len(command_string)):\n            if can_reach_goal():\n                min_changes = min(min_changes, j - i + 1)\n                continue\n            if command_string[i] == 'L' and can_move((-1, 0)):\n                if command_string[j] == 'L':\n                    min_changes = min(min_changes, j - i + 2)\n                else:\n                    min_changes = min(min_changes, j - i + 1)\n            elif command_string[i] == 'R' and can_move((1, 0)):\n                if command_string[j] == 'R':\n                    min_changes = min(min_changes, j - i + 2)\n                else:\n                    min_changes = min(min_changes, j - i + 1)\n            elif command_string[i] == 'U' and can_move((0, 1)):\n                if command_string[j] == 'U':\n                    min_changes = min(min_changes, j - i + 2)\n                else:\n                    min_changes = min(min_changes, j - i + 1)\n            elif command_string[i] == 'D' and can_move((0, -1)):\n                if command_string[j] == 'D':\n                    min_changes = min(min_changes, j - i + 2)\n                else:\n                    min_changes = min(min_changes, j - i + 1)\n            else:\n                continue\n    return min_changes"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    H, W, cmd_string = stdin.split(\"\\n\")\n    H = int(H)\n    W = int(W)\n    H, W = W, H\n    grid = [list(line) for line in cmd_string.split(\"\\n\")]\n\n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W\n\n    def bfs(start, goal):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            (x, y), dist = queue.pop(0)\n            if (x, y) == goal:\n                return dist\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and grid[nx][ny] != '#':\n                    queue.append(((nx, ny), dist + 1))\n        return -1\n\n    start = None\n    for x in range(H):\n        for y in range(W):\n            if grid[x][y] == 'S':\n                start = (x, y)\n                break\n        if start is not None:\n            break\n\n    goal = None\n    for x in range(H):\n        for y in range(W):\n            if grid[x][y] == 'G':\n                goal = (x, y)\n                break\n        if goal is not None:\n            break\n\n    dist = bfs(start, goal)\n    return dist"
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    beacons = [tuple(map(int, input_list[i+1].split())) for i in range(N)]\n    max_distance = 4 * 10**6\n    grid_size = max_distance + 1\n\n    def manhattan_distance(beacon_index: int, receiver_position: tuple) -> int:\n        return abs(beacon_index[0] - receiver_position[0]) + abs(beacon_index[1] - receiver_position[1])\n\n    def is_possible(receiver_position: tuple, beacon_index: int, distance: int) -> bool:\n        return manhattan_distance(beacon_index, receiver_position) == distance\n\n    possible_receivers = []\n    for x in range(-1 * grid_size, grid_size):\n        for y in range(-1 * grid_size, grid_size):\n            if all(is_possible((x, y), beacon_index, distance) for beacon_index, distance in enumerate(beacons)):\n                possible_receivers.append((x, y))\n\n    if len(possible_receivers) == 1:\n        return f\"{possible_receivers[0][0]} {possible_receivers[0][1]}\"\n    elif len(possible_receivers) > 1:\n        return \"uncertain\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    beacons = []\n    for i in range(1, N + 1):\n        x, y, d = map(int, input_list[i].split())\n        beacons.append((x, y, d))\n\n    def get_position(beacons):\n        x_sum, y_sum, d_sum = 0, 0, 0\n        for b in beacons:\n            x_sum += b[0]\n            y_sum += b[1]\n            d_sum += b[2]\n        x_avg = x_sum // N\n        y_avg = y_sum // N\n\n        for b in beacons:\n            b[2] = abs(b[0] - x_avg) + abs(b[1] - y_avg))\n\n        beacons.sort(key=lambda x: x[2])\n        x_pos, y_pos = beacons[0][0], beacons[0][1]\n\n        return x_pos, y_pos\n\n    x_pos, y_pos = get_position(beacons)\n    if x_pos % 1 == 0 and y_pos % 1 == 0:\n        return f\"{x_pos} {y_pos}\"\n    else:\n        return \"impossible\"\n\ninput_list = [\n    \"3\\n999999 0 1000\\n999900 950 451\\n987654 123 13222\",\n    \"2\\n100 0 101\\n0 200 199\",\n    \"2\\n100 0 100\\n0 200 199\"\n]\n\nfor input_string in input_list:\n    print(solution(input_string))"
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def is_valid(position):\n        return position[0] % 1 == 0 and position[1] % 1 == 0\n\n    def find_consistent_receiver(beacons, distances):\n        for x in range(min_x, max_x + 1):\n            for y in range(min_y, max_y + 1):\n                if is_valid((x, y)):\n                    possible_receiver = (x, y)\n                    total_distance = sum(manhattan_distance(possible_receiver, beacon) for beacon in beacons)\n                    if total_distance % 4 == 0 and total_distance == sum(distances):\n                        return possible_receiver\n        return None\n\n    def main(stdin: str) -> str:\n        num_beacons, *beacons = stdin.split('\\n')\n        beacons = [tuple(map(int, line.split())) for line in beacons]\n        num_beacons = int(num_beacons)\n        distances = [int(line.split()[-1]) for line in beacons]\n\n        beacons = [(x, y) for x, y, _ in beacons]\n        distances = distances\n\n        min_x = min(beacons, key=lambda x: x[0])[0]\n        max_x = max(beacons, key=lambda x: x[0])[0]\n        min_y = min(beacons, key=lambda x: x[1])[1]\n        max_y = max(beacons, key=lambda x: x[1])[1]\n\n        receiver = find_consistent_receiver(beacons, distances)\n\n        if receiver:\n            return f\"{receiver[0]} {receiver[1]}\"\n        elif sum(distances) % 4 == 0:\n            return \"uncertain\"\n        else:\n            return \"impossible\"\n\n    return main(stdin)\n\ninput1 = \"\"\"3\n999999 0 1000\n999900 950 451\n987654 123 13222\"\"\"\n\ninput2 = \"\"\"2\n100 0 101\n0 200 199\"\"\"\n\ninput3 = \"\"\"2\n100 0 100\n0 200 199\"\"\"\n\nprint(solution(input1))\nprint(solution(input2))\nprint(solution(input3)) "
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, *beacons = stdin.splitlines()\n    N = int(N)\n    beacons = [tuple(map(int, line.split())) for line in beacons]\n\n    possible_positions = set()\n    for x, y, dist in beacons:\n        for dx in range(dist + 1):\n            possible_positions.add((x + dx, y))\n            possible_positions.add((x - dx, y))\n        for dy in range(dist + 1):\n            possible_positions.add((x, y + dy))\n            possible_positions.add((x, y - dy))\n\n    possible_positions = [pos for pos in possible_positions if pos[0] == int(pos[0]) and pos[1] == int(pos[1])]\n    if len(possible_positions) == 0:\n        return \"impossible\"\n    elif len(possible_positions) == 1:\n        return \" \".join(map(str, possible_positions[0]))\n    else:\n        return \"uncertain\"\n\ninput_str = \"\"\"3\n999999 0 1000\n999900 950 451\n987654 123 13222\n\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_valid_position(x, y):\n        return x.is_integer() and y.is_integer()\n\n    def closest_position(x, y, positions, distances):\n        min_distance = float('inf')\n        closest_position = None\n\n        for i in range(len(positions)):\n            distance = manhattan_distance(x, y, positions[i][0], positions[i][1])\n\n            if distance < min_distance and distance == distances[i]:\n                min_distance = distance\n                closest_position = (positions[i][0], positions[i][1])\n\n        return closest_position\n\n    input_lines = stdin.splitlines()\n    num_beacons = int(input_lines[0])\n    positions = [(int(x), int(y)) for x, y, d in [line.split() for line in input_lines[1:]]]\n    distances = [int(d) for x, y, d in [line.split() for line in input_lines[1:]]]\n\n    valid_positions = []\n\n    for x in range(min(positions)[0], max(positions)[0] + 1):\n        for y in range(min(positions)[1], max(positions)[1] + 1):\n            if is_valid_position(x, y):\n                valid_positions.append((x, y))\n\n    for x, y in valid_positions:\n        closest = closest_position(x, y, positions, distances)\n\n        if closest is not None:\n            if valid_positions.count(closest) == len(distances):\n                return f\"{closest[0]} {closest[1]}\"\n\n    return \"uncertain\" if len(valid_positions) > 0 else \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    beacons = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    # Check if there is exactly one receiver position consistent with the input\n    candidates = set()\n    for i in range(N):\n        for j in range(i + 1, N):\n            x_diff = abs(beacons[i][0] - beacons[j][0])\n            y_diff = abs(beacons[i][1] - beacons[j][1])\n            if x_diff + y_diff == beacons[i][2] + beacons[j][2]:\n                candidates.add((beacons[i][0] + beacons[j][0]) // 2, (beacons[i][1] + beacons[j][1]) // 2)\n    if len(candidates) == 1:\n        return f\"{next(iter(candidates))[0]} {next(iter(candidates))[1]}\"\n\n    # Check if multiple receiver positions are consistent with the input\n    uncertain = False\n    for i in range(N):\n        for j in range(i + 1, N):\n            x_diff = abs(beacons[i][0] - beacons[j][0])\n            y_diff = abs(beacons[i][1] - beacons[j][1])\n            if x_diff + y_diff != beacons[i][2] + beacons[j][2]:\n                uncertain = True\n                break\n        if uncertain:\n            break\n    if uncertain:\n        return \"uncertain\"\n\n    # Check if no receiver position is consistent with the input\n    for i in range(N):\n        for j in range(i + 1, N):\n            x_diff = abs(beacons[i][0] - beacons[j][0])\n            y_diff = abs(beacons[i][1] - beacons[j][1])\n            if x_diff + y_diff == beacons[i][2] + beacons[j][2]:\n                return \"impossible\"\n    return \"uncertain\""
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, *data = stdin.split('\\n')\n    N = int(N)\n    beacons = [tuple(map(int, d.split())) for d in data]\n\n    def manhattan_distance(x, y):\n        return abs(x[0] - y[0]) + abs(x[1] - y[1])\n\n    def check_position(X, Y):\n        return all(manhattan_distance((X, Y), beacon) <= D for beacon, D in zip(beacons, distances))\n\n    distances = [manhattan_distance((X_i, Y_i), (0, 0)) for X_i, Y_i, D_i in beacons]\n\n    if len(set(distances)) == 1:\n        for X in range(0, 1001):\n            for Y in range(0, 1001):\n                if check_position(X, Y):\n                    return f\"{X} {Y}\"\n        return \"impossible\"\n    else:\n        return \"uncertain\""
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    N = int(inputs[0])\n    beacons = [(int(x), int(y), int(d)) for x, y, d in [line.split() for line in inputs[1:]]]\n\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_consistent(x_r, y_r, beacons):\n        return all(manhattan_distance(x_r, y_r, x, y) == d for x, y, d in beacons)\n\n    def find_consistent_positions(beacons):\n        for x in range(1000):\n            for y in range(1000):\n                if is_consistent(x, y, beacons):\n                    yield x, y\n\n    consistent_positions = list(find_consistent_positions(beacons))\n\n    if len(consistent_positions) == 1:\n        x_r, y_r = consistent_positions[0]\n        return f\"{x_r} {y_r}\"\n    elif len(consistent_positions) > 1:\n        return \"uncertain\"\n    else:\n        return \"impossible\"\n\ndef"
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n    beacons = [tuple(map(int, input_data[i+1].split())) for i in range(N)]\n    \n    # Calculate all possible positions for the receiver\n    possible_positions = set()\n    for x in range(0, 2*10**6):\n        for y in range(0, 2*10**6):\n            if all(abs(x - b[0]) + abs(y - b[1]) == b[2] for b in beacons):\n                possible_positions.add((x, y))\n    \n    if len(possible_positions) == 1:\n        return f\"{list(possible_positions)[0][0]} {list(possible_positions)[0][1]}\"\n    elif len(possible_positions) > 1:\n        return \"uncertain\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_valid_position(x, y):\n        return x.is_integer() and y.is_integer()\n\n    def is_consistent(x, y, distances):\n        return all(is_valid_position(x + d, y) for d in distances)\n\n    def find_consistent_receiver_position(beacons, distances):\n        x_range = max(max(beacons, key=lambda b: b[0])[0], max(distances, key=lambda d: d[1])[1])\n        y_range = max(max(beacons, key=lambda b: b[1])[1], max(distances, key=lambda d: d[2])[2])\n        for x in range(x_range + 1):\n            for y in range(y_range + 1):\n                if is_consistent(x, y, distances):\n                    return x, y\n        return None, None\n\n    def find_receiver_position(beacons, distances):\n        x, y = find_consistent_receiver_position(beacons, distances)\n        if x is not None and y is not None:\n            return x, y\n        else:\n            for x, y in beacons:\n                if is_consistent(x, y, distances):\n                    return x, y\n            return None, None\n\n    input_data = stdin.splitlines()\n    num_beacons = int(input_data[0])\n    beacons = [tuple(map(int, line.split())) for line in input_data[1:num_beacons + 1]]\n    distances = [tuple(map(int, line.split())) for line in input_data[num_beacons + 1:]]\n\n    x, y = find_receiver_position(beacons, distances)\n\n    if x is not None and y is not None:\n        return f\"{x} {y}\"\n    elif len(set(distances)) == 1:\n        return \"uncertain\"\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(r1: int, r2: int, c1: int, c2: int) -> bool:\n        return r1 < r2 and c1 < c2\n\n    def match_corners(corners: List[Tuple[int, int]], used: Set[int]) -> List[int]:\n        matched = []\n        for i in range(len(corners)):\n            if i not in used:\n                r1, c1 = corners[i]\n                for j in range(len(corners)):\n                    if j not in used:\n                        r2, c2 = corners[j]\n                        if is_valid(r1, r2, c1, c2) and (r1, c1) != (r2, c2):\n                            matched.append(j + 1)\n                            used.add(j)\n                            break\n        return matched\n\n    def find_matching(corners: List[Tuple[int, int]]) -> str:\n        used = set()\n        result = []\n        while len(used) < len(corners):\n            matched = match_corners(corners, used)\n            if not matched:\n                return \"syntax error\"\n            result.extend(matched)\n        return \"\\n\".join(map(str, result))\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    corners = []\n    for i in range(1, n * 2 + 1, 2):\n        r1, c1 = map(int, lines[i].split())\n        r2, c2 = map(int, lines[i + 1].split())\n        corners.append((r1, c1))\n        corners.append((r2, c2))\n\n    return find_matching(corners)"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    if n <= 0 or n > 10**5:\n        return \"syntax error\"\n    \n    corners = []\n    for i in range(n):\n        r1, c1, r2, c2 = [int(x) for x in stdin.split('\\n')[1+i].split()]\n        corners.append((r1, c1, r2, c2))\n    \n    matching = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if corners[i][0] == corners[j][2] or corners[i][1] == corners[j][3] or corners[i][2] == corners[j][0] or corners[i][3] == corners[j][1]:\n                matching.append((i+1, j+1))\n    \n    if len(matching) == 0:\n        return \"syntax error\"\n    \n    return '\\n'.join(str(x) for x in matching) "
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    corners = []\n    for i in range(n * 2):\n        if i % 2 == 0:\n            r1, c1 = map(int, stdin.split())\n            corners.append((r1, c1))\n        else:\n            r2, c2 = map(int, stdin.split())\n            corners.append((r2, c2))\n\n    def check(corners: list) -> bool:\n        for i in range(len(corners)):\n            for j in range(i + 1, len(corners)):\n                if corners[i][1] == corners[j][1] or corners[i][2] == corners[j][2]:\n                    return False\n        return True\n\n    def find_match(corners: list) -> list:\n        match = []\n        for i in range(len(corners)):\n            for j in range(len(corners)):\n                if corners[i][0] == corners[j][1] or corners[i][1] == corners[j][0]:\n                    match.append(j)\n        return match\n\n    if check(corners):\n        match = find_match(corners)\n        if len(match) == n:\n            return '\\n'.join(map(str, match))\n    return 'syntax error'"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    if n < 1 or n > 10**5:\n        return \"syntax error\"\n\n    corner_pairs = []\n    for i in range(1, n * 2, 2):\n        row1, col1 = map(int, input_data[i].split())\n        row2, col2 = map(int, input_data[i + 1].split())\n        if row1 < 1 or row1 > 10**9 or col1 < 1 or col1 > 10**9 or \\\n           row2 < 1 or row2 > 10**9 or col2 < 1 or col2 > 10**9:\n            return \"syntax error\"\n        corner_pairs.append(((row1, col1), (row2, col2)))\n\n    def is_valid(corner_pairs: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> bool:\n        n = len(corner_pairs)\n        borders = set(range(1, n + 1))\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    pair1, pair2 = corner_pairs[i], corner_pairs[j]\n                    if pair1[0] == pair2[0] or pair1[0] == pair2[1] or \\\n                       pair1[1] == pair2[0] or pair1[1] == pair2[1]:\n                        borders.discard(i + 1)\n                        borders.discard(j + 1)\n                        break\n            else:\n                continue\n            break\n        return len(borders) > 0\n\n    if is_valid(corner_pairs):\n        result = [i + 1 for i in range(n)]\n        return '\\n'.join(map(str, result))\n    else:\n        return \"syntax error\"\n\nstdin = \"\"\"\\\n2\n4 7\n9 8\n14 17\n19 18\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\\\n2\n4 7\n14 17\n9 8\n19 18\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\\\n2\n4 8\n9 7\n14 18\n19 17\n\"\"\"\nprint(solution(stdin))"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list.pop(0))\n    if n <= 0 or n > 10**5:\n        return \"syntax error\"\n    \n    corners = []\n    for _ in range(n):\n        corners.append(tuple(map(int, input_list.pop(0).split())))\n    \n    def is_valid(start_corner, end_corner):\n        for other_start, other_end in corners:\n            if start_corner[0] <= other_start[0] <= end_corner[0] and start_corner[1] <= other_start[1] <= end_corner[1] and start_corner[0] <= other_end[0] <= end_corner[0] and start_corner[1] <= other_end[1] <= end_corner[1]:\n                return False\n        return True\n    \n    def backtrack(used_corners, result, n):\n        if len(used_corners) == 2 * n:\n            return result\n        \n        for i in range(n):\n            if i not in used_corners:\n                for j in range(n):\n                    if j not in used_corners:\n                        start_corner = corners[i]\n                        end_corner = corners[j]\n                        if is_valid(start_corner, end_corner):\n                            result.append(i + 1)\n                            result.append(j + 1)\n                            used_corners.add(i)\n                            used_corners.add(j)\n                            backtrack(used_corners, result, n)\n                            used_corners.remove(i)\n                            used_corners.remove(j)\n                            result.pop()\n                            result.pop()\n    \n    result = []\n    used_corners = set()\n    backtrack(used_corners, result, n)\n    \n    if not result:\n        return \"syntax error\"\n    else:\n        return '\\n'.join(map(str, result))"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list.pop(0))\n    if n < 1 or n > 10**5:\n        return \"syntax error\"\n    corners = [(int(input_list[2*i]), int(input_list[2*i+1])) for i in range(n)]\n\n    def is_valid(c1, c2):\n        return c1[1] == c2[1] or c1[0] == c2[0]\n\n    def find_matching(corners):\n        for i in range(n):\n            for j in range(n):\n                if i != j and is_valid(corners[i], corners[j]):\n                    return i, j\n        return None\n\n    matching = find_matching(corners)\n    if matching is None:\n        return \"syntax error\"\n    return str(matching[0] + 1) + \"\\n\" + str(matching[1] + 1) "
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    if n < 1 or n > 10**5:\n        return \"syntax error\"\n    corners = [None] * (2 * n)\n    for i in range(n):\n        corners[2*i] = tuple(map(int, input_list[i+1].split()))\n        corners[2*i+1] = tuple(map(int, input_list[i+n+1].split()))\n    def find_match(i: int) -> int:\n        for j in range(i+1, 2*n):\n            if corners[i] == corners[j][::-1]:\n                return j\n        return -1\n    match_list = [find_match(i) for i in range(n)]\n    if -1 in match_list:\n        return \"syntax error\"\n    result = [i for i in range(1, n+1)]\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    if n < 1 or n > 10**5:\n        return \"syntax error\"\n    corner_pairs = [(int(x), int(y)) for i, x, y in zip(range(2*n), input_data[1::2], input_data[2::2])]\n    if not all(1 <= x <= 10**9 and 1 <= y <= 10**9 for x, y in corner_pairs):\n        return \"syntax error\"\n    n_pairs = [(x, y) for x, y in corner_pairs if (x, y) != (1, 1)]\n    if len(n_pairs) != n-1:\n        return \"syntax error\"\n    n_pairs = sorted(n_pairs)\n    adj_list = {}\n    for i in range(1, n+1):\n        adj_list[i] = []\n    for i, (x, y) in enumerate(n_pairs):\n        adj_list[x].append((y, i+1))\n        adj_list[y].append((x, i+1))\n    def dfs(v: int, parent: int) -> int:\n        if parent != -1 and adj_list[v][0][0] == parent:\n            return -1\n        for child, edge_id in adj_list[v]:\n            if child != parent:\n                ret = dfs(child, v)\n                if ret == -1:\n                    return -1\n                edge_id = min(edge_id, ret)\n                adj_list[v][adj_list[v].index((child, ret))] = (child, edge_id)\n                adj_list[child][adj_list[child].index((v, ret))] = (v, edge_id)\n        return v\n    ret = dfs(1, -1)\n    if ret == -1:\n        return \"syntax error\"\n    result = []\n    for i in range(1, n+1):\n        result.append(adj_list[i][0][1])\n    return '\\n'.join(str(i) for i in result)"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    if n < 1 or n > 10**5:\n        return \"syntax error\"\n    corners = []\n    for i in range(1, 2 * n + 1, 2):\n        corners.append((int(input_list[i]), int(input_list[i + 1])))\n    for i in range(n):\n        if corners[i][0] < 1 or corners[i][1] < 1 or corners[i][0] > 10**9 or corners[i][1] > 10**9:\n            return \"syntax error\"\n    for i in range(n - 1):\n        if corners[i][1] >= corners[i + 1][0] or corners[i][1] >= corners[i + 1][1] or corners[i][0] >= corners[i + 1][0] or corners[i][0] >= corners[i + 1][1]:\n            return \"syntax error\"\n    matching = []\n    for i in range(n):\n        matching.append(i + 1)\n    return \"\\n\".join(map(str, matching))"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    if n < 1 or n > 10**5:\n        return \"syntax error\"\n\n    corners = []\n    for i in range(2*n):\n        r, c = [int(x) for x in stdin.split('\\n')[i+1].split()]\n        if (r, c) in corners:\n            return \"syntax error\"\n        corners.append((r, c))\n\n    rectangles = []\n    for i in range(n):\n        for j in range(n):\n            if (i, j) in rectangles or (j, i) in rectangles:\n                return \"syntax error\"\n            rectangles.append((i, j))\n\n    result = []\n    for i in range(n):\n        for j in range(n):\n            if corners[2*i] == corners[2*i+1] and corners[2*j+1] == corners[2*j+2]:\n                result.append(i+1)\n                result.append(j+1)\n                break\n        if len(result) == 2*i+2:\n            break\n\n    if len(result) != 2*n:\n        return \"syntax error\"\n    else:\n        return '\\n'.join(map(str, result))"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    plates = [list(map(int, stdin.split()))]\n    for _ in range(1, 2):\n        plates.append(list(map(int, input().split())))\n\n    # compute the missing values\n    for row in plates:\n        for i in range(2):\n            if row[i] == 0:\n                for j in range(2, 4):\n                    if row[j] != 0:\n                        row[i] = (row[j] * (200 - row[j])) // (row[j] - row[i])\n                        break\n\n    # compute the number of solutions\n    def count_solutions(plates: list) -> int:\n        solutions = 0\n        for i in range(2):\n            solutions += (200 - plates[0][i]) * (200 - plates[1][i])\n        for i in range(2, 4):\n            solutions += (200 - plates[0][i]) * (200 - plates[1][i])\n        return solutions\n\n    num_solutions = count_solutions(plates)\n    if num_solutions < 200:\n        return str(num_solutions)\n    else:\n        return \"many\""
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip().split(\"\\n\")\n    top_row = list(map(int, input_str[0].split()))\n    bottom_row = list(map(int, input_str[1].split()))\n\n    def find_solutions(salamander, yeti, golem, imp, kraken):\n        slop_burger = golem * salamander // yeti\n        slop_sushi = golem * (2 * salamander + golem) // (2 * yeti + golem)\n        burger_drumstick = golem * (2 * salamander + golem) // yeti\n        sushi_drumstick = golem * salamander // yeti\n        total_slop = salamander + burger_drumstick + sushi_drumstick\n        total_sushi = salamander + burger_drumstick + slop_sushi\n        total_burger = salamander + burger_drumstick + slop_burger\n        total_drumstick = burger_drumstick + sushi_drumstick + slop_drumstick\n        return (salamander, burger_drumstick, sushi_drumstick, total_slop, total_sushi, total_burger, total_drumstick)\n\n    def compute_all_solutions():\n        solutions = set()\n        for salamander in range(1, 201):\n            for yeti in range(1, 201):\n                for golem in range(1, 201):\n                    for imp in range(1, 201):\n                        for kraken in range(1, 201):\n                            salamander_burger_drumstick, salamander_sushi_drumstick, total_slop, total_sushi, total_burger, total_drumstick = find_solutions(salamander, yeti, golem, imp, kraken)\n                            if total_burger == top_row[0] and total_sushi == top_row[1] and total_slop == bottom_row[0] and total_drumstick == bottom_row[1]:\n                                solutions.add((salamander_burger_drumstick, salamander_sushi_drumstick))\n        return solutions\n\n    solutions = compute_all_solutions()\n    if len(solutions) == 0:\n        return \"many\"\n    return str(len(solutions))"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def compute_solutions(burger_slop, sushi_drumstick):\n        salamander_burger, salamander_slop, yeti_drumstick, yeti_sushi, golem_burger, golem_drumstick, imp_burger, imp_sushi, kraken_slop, kraken_drumstick = burger_slop + yeti_drumstick + golem_drumstick + imp_sushi + [kraken_drumstick, salamander_slop, yeti_burger, salamander_burger, golem_sushi, golem_burger, imp_drumstick, imp_sushi, kraken_burger]\n\n        salamander_burger, yeti_burger, golem_burger, imp_sushi, kraken_drumstick = map(int, [salamander_burger, yeti_burger, golem_burger, imp_sushi, kraken_drumstick])\n        salamander_slop, yeti_drumstick, golem_drumstick, imp_burger, kraken_slop = map(int, [salamander_slop, yeti_drumstick, golem_drumstick, imp_burger, kraken_slop])\n\n        yeti_sushi, golem_sushi, imp_sushi = map(int, [yeti_sushi, golem_sushi, imp_sushi])\n\n        total_burger = salamander_burger + yeti_burger + golem_burger + imp_burger\n        total_slop = salamander_slop + yeti_drumstick + golem_drumstick + imp_sushi\n        total_sushi = yeti_sushi + golem_sushi + imp_sushi\n        total_drumstick = salamander_drumstick + yeti_drumstick + golem_drumstick + imp_drumstick\n\n        salamander_burger_per_drumstick = salamander_burger / yeti_drumstick\n        yeti_drumstick_per_slop = yeti_drumstick / salamander_slop\n        golem_slop_per_drumstick = golem_sushi / golem_drumstick\n        imp_sushi_per_burger = imp_sushi / imp_burger\n        kraken_drumstick_per_slop = kraken_drumstick / salamander_slop\n\n        solutions = 0\n        for burger_per_drumstick in range(int(total_burger / total_drumstick) + 1):\n            if burger_per_drumstick * total_drumstick != total_burger:\n                continue\n\n            for slop_per_drumstick in range(int(total_slop / total_drumstick) + 1):\n                if slop_per_drumstick * total_drumstick != total_slop:\n                    continue\n\n                for sushi_per_slop in range(int(total_sushi / total_slop) + 1):\n                    if sushi_per_slop * total_slop != total_sushi:\n                        continue\n\n                solutions += burger_per_drumstick * slop_per_drumstick * sushi_per_slop\n\n        return solutions\n\n    burger_slop, sushi_drumstick = stdin.splitlines()\n    burger_slop = list(map(int, burger_slop.split()))\n    sushi_drumstick = list(map(int, sushi_drumstick.split()))\n\n    solutions = compute_solutions(burger_slop, sushi_drumstick)\n\n    if solutions == 0:\n        return \"many\"\n    else:\n        return solutions\n\n\ndef"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def compute_proportions(row1: List[int], row2: List[int]) -> List[int]:\n        result = []\n        for i in range(5):\n            if row1[i] == 0:\n                result.append(0)\n            else:\n                result.append(row2[i] * row1[0] // row1[i])\n        return result\n\n    def count_solutions(row1: List[int], row2: List[int]) -> int:\n        if row1[0] + row1[2] + row1[4] + row1[6] == 0:\n            return 1\n        if row1[0] + row1[2] + row1[4] + row1[6] > 200:\n            return 0\n\n        if row2[0] + row2[2] + row2[4] + row2[6] == 0:\n            return 1\n        if row2[0] + row2[2] + row2[4] + row2[6] > 200:\n            return 0\n\n        row1_proportions = compute_proportions(row1, row2)\n        row2_proportions = compute_proportions(row2, row1)\n\n        count = 0\n        for i in range(5):\n            if row1_proportions[i] != 0:\n                count += 1\n            if row2_proportions[i] != 0:\n                count += 1\n\n        return 2 ** count\n\n    def is_valid_input(plate: List[int]) -> bool:\n        return all(0 <= x <= 200 for x in plate)\n\n    def compute_distinct_solutions(partial_plates: List[List[int]]) -> int:\n        if not all(is_valid_input(plate) for plate in partial_plates):\n            return 0\n\n        row1, row2 = partial_plates\n        solutions = []\n        for i in range(1, 5):\n            for j in range(1, 5):\n                if row1[i] != 0 and row2[j] != 0:\n                    solutions.append(count_solutions(row1, row2))\n\n        result = set(solutions)\n        if max(result) == 0:\n            return 0\n        elif max(result) == 1:\n            return 1\n        else:\n            return \"many\"\n\n    def parse_input(input_str: str) -> List[List[int]]:\n        return [list(map(int, input_str.split()[i::2])) for i in range(2)]\n\n    partial_plates = parse_input(stdin)\n    distinct_solutions = compute_distinct_solutions(partial_plates)\n    return str(distinct_solutions)"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    top_plate = list(map(int, input_lines[0].split()[:8]))\n    bottom_plate = list(map(int, input_lines[1].split()[:8]))\n    \n    def get_burger_slop_amount(monster_plate: List[int]) -> Tuple[int, int]:\n        burger_slop = monster_plate[0]\n        if burger_slop == _:\n            return (0, 0)\n        else:\n            return (burger_slop, monster_plate[1])\n    \n    def get_sushi_drumstick_amount(monster_plate: List[int]) -> Tuple[int, int]:\n        sushi_drumstick = monster_plate[2]\n        if sushi_drumstick == _:\n            return (0, 0)\n        else:\n            return (sushi_drumstick, monster_plate[3])\n    \n    def compute_distinct_solutions(burger_slop_amount: int, sushi_drumstick_amount: int) -> int:\n        solutions = 1\n        if burger_slop_amount == 0 or sushi_drumstick_amount == 0:\n            return 0\n        for burger_factor in range(1, 11):\n            for slop_factor in range(1, 11):\n                if burger_factor * burger_slop_amount + slop_factor * sushi_drumstick_amount == 0:\n                    solutions += 1\n        return solutions\n    \n    burger_slop_top = get_burger_slop_amount(top_plate)\n    sushi_drumstick_top = get_sushi_drumstick_amount(top_plate)\n    burger_slop_bottom = get_burger_slop_amount(bottom_plate)\n    sushi_drumstick_bottom = get_sushi_drumstick_amount(bottom_plate)\n    \n    solutions = compute_distinct_solutions(burger_slop_top[0] + burger_slop_bottom[0], sushi_drumstick_top[0] + sushi_drumstick_bottom[0])\n    \n    if solutions == 1:\n        return \"1\"\n    else:\n        return \"many\""
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def compute_solutions(plates):\n        def compute_proportion(plate1, plate2):\n            return plate1 / plate2\n\n        def compute_proportions(plate1, plate2):\n            burger_proportion = compute_proportion(plate1[0], plate2[0])\n            slop_proportion = compute_proportion(plate1[1], plate2[1])\n            sushi_proportion = compute_proportion(plate1[2], plate2[2])\n            drumstick_proportion = compute_proportion(plate1[3], plate2[3])\n            return burger_proportion, slop_proportion, sushi_proportion, drumstick_proportion\n\n        def compute_pet_placements(pets, proportions):\n            pet_placements = []\n            for pet in pets:\n                burger_placement = int(proportions[0] * pet[1])\n                slop_placement = int(proportions[1] * pet[1])\n                sushi_placement = int(proportions[2] * pet[1])\n                drumstick_placement = int(proportions[3] * pet[1])\n                pet_placements.append([burger_placement, slop_placement, sushi_placement, drumstick_placement])\n            return pet_placements\n\n        def compute_solution(pet_placements):\n            def is_valid_solution(plate):\n                return all(plate[i] >= 0 for i in range(len(plate))) and all(plate[i] <= 200 for i in range(len(plate)))\n\n            total_solutions = 0\n            for burger in range(21):\n                for slop in range(21 - burger):\n                    for sushi in range(21 - burger - slop):\n                        for drumstick in range(21 - burger - slop - sushi):\n                            if is_valid_solution([burger, slop, sushi, drumstick]):\n                                total_solutions += 1\n            return total_solutions\n\n        pets = [[\"Salamander\", 90, 22], [\"Yeti\", 40, 6], [\"Golem\", 81, 12], [\"Imp\", 6, 12], [\"Kraken\", 90, 36]]\n        top_plate = [int(x) for x in stdin.split()[:4]]\n        bottom_plate = [int(x) for x in stdin.split()[4:]]\n        proportions = compute_proportions(top_plate, bottom_plate)\n        pet_placements = compute_pet_placements(pets, proportions)\n        solution_count = compute_solution(pet_placements)\n        return solution_count\n\n    return str(compute_solutions(stdin))"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def check_constraint(s: int, t: int) -> bool:\n        return s <= 200 and t <= 200 and s + t <= 200\n\n    def count_solutions(x: int, y: int, plate: str, empty: str) -> int:\n        if empty == '_':\n            return 1\n        total = 0\n        for i in range(1, 21):\n            if check_constraint(i, empty):\n                total += count_solutions(i, empty, plate, y)\n        return total\n\n    plates = stdin.strip().split('\\n')\n    plates = [list(map(lambda x: int(x) if x != '_' else 0, line.split())) for line in plates]\n\n    total = 1\n    for plate, empty in zip(plates, ['_', '_']):\n        for i in range(1, 21):\n            if check_constraint(i, empty):\n                total *= count_solutions(i, empty, plate, 0)\n\n    if total >= 2**31 - 1:\n        return \"many\"\n    else:\n        return str(total)\n"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    plates = stdin.split(\"\\n\")\n\n    # Parse input\n    burger_slop, sushi_drumstick = plates\n    burger_slop = burger_slop.split()\n    sushi_drumstick = sushi_drumstick.split()\n\n    monsters = [\n        [\"Salamander\", \"Yeti\", \"Golem\", \"Imp\", \"Kraken\"],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n    ]\n\n    # Fill monsters table\n    for i, plate in enumerate(burger_slop):\n        if plate != \"_\":\n            monsters[1][i] = int(plate)\n    for i, plate in enumerate(sushi_drumstick):\n        if plate != \"_\":\n            monsters[2][i] = int(plate)\n\n    # Compute number of solutions\n    burger_slop_ratio = monsters[1][0] / monsters[1][1]\n    sushi_drumstick_ratio = monsters[2][2] / monsters[2][3]\n\n    total_drumstick = monsters[2][0] + monsters[2][1]\n    total_sushi = monsters[2][2] + monsters[2][3]\n    total_burger_slop = monsters[1][0] + monsters[1][1]\n\n    total_sushi_drumstick_ratio = total_sushi / total_drumstick\n\n    monster_burger_slop_ratios = [\n        burger_slop_ratio,\n        total_burger_slop_ratio / total_burger_slop_ratio,\n        total_burger_slop_ratio / total_burger_slop_ratio,\n        burger_slop_ratio / total_sushi_drumstick_ratio,\n        burger_slop_ratio / total_sushi_drumstick_ratio,\n    ]\n\n    monster_sushi_drumstick_ratios = [\n        total_sushi_drumstick_ratio,\n        total_sushi_drumstick_ratio,\n        total_sushi_drumstick_ratio,\n        total_sushi_drumstick_ratio,\n        total_sushi_drumstick_ratio,\n    ]\n\n    monster_ratios = [\n        monster_burger_slop_ratios,\n        monster_sushi_drumstick_ratios,\n    ]\n\n    def compute_solutions(ratios, visited):\n        if len(visited) == 2:\n            return 1\n        elif visited[0] == 5:\n            return 0\n        else:\n            solutions = 0\n            for i in range(5):\n                if not visited[i]:\n                    visited[i] = True\n                    solutions += compute_solutions(\n                        ratios[i], visited\n                    )\n                    visited[i] = False\n            return solutions\n\n    solutions = compute_solutions(monster_ratios, [False] * 5)\n\n    return str(solutions)\n"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def compute_proportions(plate1, plate2):\n        for plate in (plate1, plate2):\n            for i in range(4):\n                for j in range(i+1, 5):\n                    if plate[i] != \"_\" and plate[j] != \"_\":\n                        if plate[j] / plate[i] == plate[i] / plate[j]:\n                            continue\n                        else:\n                            return None\n        return True\n\n    def count_solutions(plate1, plate2):\n        num_solutions = 0\n        for i in range(201):\n            for j in range(201):\n                if i * plate2[4] + j * plate2[5] == plate1[0] * i + plate1[1] * j:\n                    num_solutions += 1\n        return num_solutions\n\n    plate1 = list(map(int, stdin.split()[:4]))\n    plate2 = list(map(int, stdin.split()[4:]))\n\n    if not compute_proportions(plate1, plate2):\n        return \"many\"\n\n    return count_solutions(plate1, plate2)\n\n\ninput_1 = \"90 22 _ 6 _ _ _ _ 81 40 _ _ 12 60 _ 90 _\"\ninput_2 = \"85 55 _ 99 51 _ _ _ _ _ 160 _ _ 136 _ _ _ _ 170\"\ninput_3 = \"160 _ _ 136 _ _ _ _ _ 170 160 _ _ _ 120 _ _ 144 _ _\"\n\nprint(solution(input_1))\nprint(solution(input_2))\nprint(solution(input_3)) "
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Helper function to check if there is only one possible solution\n    def has_unique_solution(partial_info: list, plate_order: list, index: int) -> bool:\n        if index == len(partial_info):\n            return True\n        if partial_info[index][0] == '_':\n            return has_unique_solution(partial_info, plate_order, index + 1)\n        else:\n            total = sum(partial_info[i][1] for i in range(len(partial_info)) if i != index)\n            if total == 0:\n                return False\n            num_units = partial_info[index][0]\n            num_items = int(num_units / total * plate_order[index])\n            if num_items == 0:\n                return False\n            else:\n                for i in range(len(partial_info)):\n                    if i != index:\n                        partial_info[i][1] = int(partial_info[i][1] - num_items * plate_order[i] / plate_order[index])\n                return has_unique_solution(partial_info, plate_order, index + 1)\n\n    # Split the input string into lines and parse it into partial information and plate order\n    partial_info, plate_order = [], []\n    for line in stdin.split('\\n'):\n        row = []\n        for entry in line.split(' '):\n            if entry == '_':\n                row.append(['_', 0])\n            else:\n                row.append([int(entry), 0])\n        partial_info.append(row)\n        plate_order.append([row[0][1], row[1][1]])\n\n    # Check if there is only one possible solution\n    for i in range(len(partial_info)):\n        if not has_unique_solution(partial_info, plate_order, i):\n            return \"many\"\n\n    # Calculate the number of distinct solutions\n    num_solutions = 1\n    for i in range(len(partial_info)):\n        if partial_info[i][0][0] != '_':\n            num_solutions *= partial_info[i][0][1] + 1\n            if num_solutions > 1000000:\n                return \"many\"\n\n    return str(num_solutions)"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    adj_list = {i: [] for i in range(1, N + 1)}\n\n    for i in range(1, N):\n        u, v = map(int, input_list[i].split())\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    count = 0\n    for u in adj_list:\n        for v in adj_list[u]:\n            if len(adj_list[u]) == 1 and len(adj_list[v]) == 1:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, v: int, visited: set[int], path: list[int]) -> int:\n        path.append(u)\n        visited.add(u)\n        if u == v:\n            return 1 if len(path) == 2 else 0\n        count = 0\n        for neighbor in graph[u]:\n            if neighbor not in visited:\n                count += dfs(neighbor, v, visited, path)\n        return count\n\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    graph = [[] for _ in range(N + 1)]\n    for line in input_list[1:]:\n        u, v = map(int, line.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    count = 0\n    for i in range(1, N):\n        for j in range(i + 1, N):\n            count += dfs(i, j, set(), [])\n\n    return str(count)\n"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    roads = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n\n    adjacency_list = [[] for _ in range(N)]\n    for u, v in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n\n    count = 0\n    for i in range(N):\n        for j in adjacency_list[i]:\n            if len(adjacency_list[j]) == 2 and j != i:\n                count += 1\n\n    return str(count // 2)\n\n\ndef"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    road_dict = {}\n    for i in range(1, N):\n        u, v = map(int, input_list[i].split())\n        if u not in road_dict:\n            road_dict[u] = [v]\n        else:\n            road_dict[u].append(v)\n        if v not in road_dict:\n            road_dict[v] = [u]\n        else:\n            road_dict[v].append(u)\n    \n    # Checking all optimal paths of length 2\n    count = 0\n    for junction in road_dict:\n        for neighbor in road_dict[junction]:\n            if len(road_dict[junction]) == 1 and len(road_dict[neighbor]) == 1:\n                count += 1\n    \n    return str(count)"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    roads = [tuple(map(int, input().split())) for _ in range(N - 1)]\n    \n    adj_list = [[] for _ in range(N)]\n    for u, v in roads:\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n    \n    def dfs(v: int, visited: set, path: list) -> int:\n        if v in visited:\n            return 0\n        visited.add(v)\n        path.append(v)\n        count = 0\n        for next_v in adj_list[v]:\n            if len(path) == 2 and next_v == path[-2]:\n                continue\n            count += dfs(next_v, visited.copy(), path)\n        path.pop()\n        return count\n    \n    return dfs(0, set(), [])\n"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    roads = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    \n    adj = [[] for _ in range(N)]\n    for u, v in roads:\n        adj[u-1].append(v-1)\n        adj[v-1].append(u-1)\n    \n    def dfs(v, p, visited, count):\n        visited[v] = True\n        for u in adj[v]:\n            if u != p:\n                if not visited[u]:\n                    count[0] += dfs(u, v, visited, count)\n                elif count[1]:\n                    count[0] += count[1].count(u)\n        return count[0]\n    \n    count = [0, []]\n    visited = [False] * N\n    for v in range(N):\n        if not visited[v]:\n            count[0] += dfs(v, -1, visited, count)\n            if count[1]:\n                count[0] += count[1].count(v)\n    \n    return str(count[0])"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_path(path: list, visited: set) -> bool:\n        if len(path) == 2:\n            return True\n        for i in range(len(path)):\n            for j in range(i + 1, len(path)):\n                if path[i] == path[j]:\n                    continue\n                if (path[i], path[j]) not in visited:\n                    visited.add((path[i], path[j]))\n                    if is_valid_path(path[:i] + [path[j]] + path[i + 1:j] + [path[i]] + path[j + 1:], visited):\n                        return True\n                    visited.remove((path[i], path[j]))\n        return False\n\n    N, *roads = stdin.splitlines()\n    N = int(N)\n    adj_list = [[] for _ in range(N)]\n    for u, v in [map(int, road.split()) for road in roads]:\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n\n    optimal_paths = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if is_valid_path([i, j], set()):\n                optimal_paths += 1\n\n    return str(optimal_paths)\n"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_optimal(path: List[int]) -> bool:\n        if len(path) == 2:\n            return True\n        return False\n\n    def count_optimal_paths(graph: List[List[int]], visited: List[int], path: List[int], result: int) -> None:\n        if is_optimal(path):\n            result[0] += 1\n            return\n        if len(path) == len(graph):\n            return\n\n        for neighbor in graph[path[-1]]:\n            if neighbor not in visited:\n                visited.append(neighbor)\n                count_optimal_paths(graph, visited, path + [neighbor], result)\n                visited.pop()\n\n    def create_graph(n: int, roads: List[List[int]]) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        for road in roads:\n            graph[road[0] - 1].append(road[1] - 1)\n            graph[road[1] - 1].append(road[0] - 1)\n        return graph\n\n    def parse_input(stdin: str) -> Tuple[int, List[List[int]]]:\n        n, *roads = stdin.split()\n        n = int(n)\n        roads = [list(map(int, road.split())) for road in roads]\n        return n, roads\n\n    n, roads = parse_input(stdin)\n    graph = create_graph(n, roads)\n    visited = []\n    path = [1]\n    result = [0]\n    count_optimal_paths(graph, visited, path, result)\n    return str(result[0])"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_optimal_paths_count(adjacency_list: list, num_junctions: int) -> int:\n        def bfs(start: int, end: int) -> int:\n            visited = [False] * num_junctions\n            queue = [(start, 0)]\n            visited[start] = True\n            paths_count = 0\n\n            while queue:\n                node, dist = queue.pop(0)\n\n                if node == end:\n                    paths_count += 1\n\n                for neighbor in adjacency_list[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append((neighbor, dist + 1))\n\n            return paths_count\n\n        total_paths_count = 0\n\n        for i in range(1, num_junctions):\n            for j in range(i + 1, num_junctions + 1):\n                if bfs(i, j) == 2:\n                    total_paths_count += 1\n\n        return total_paths_count\n\n    def get_input(stdin: str) -> tuple:\n        num_junctions = int(stdin.split(\"\\n\")[0])\n        adjacency_list = [[] for _ in range(num_junctions + 1)]\n\n        for line in stdin.split(\"\\n\")[1:]:\n            u, v = map(int, line.split())\n            adjacency_list[u].append(v)\n            adjacency_list[v].append(u)\n\n        return num_junctions, adjacency_list\n\n    num_junctions, adjacency_list = get_input(stdin)\n    total_paths_count = get_optimal_paths_count(adjacency_list, num_junctions)\n\n    return str(total_paths_count)\n"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbors(node: int) -> List[int]:\n        return [x for x in range(1, N + 1) if (x, node) in roads]\n\n    def is_optimal(path: List[int]) -> bool:\n        if len(path) != 2:\n            return False\n        start, end = path[0], path[-1]\n        return len(shortest_paths[start][end]) == 2\n\n    def count_optimal_paths(node: int, visited: List[int], current_path: List[int]) -> int:\n        if node in visited:\n            return 0\n        if is_optimal(current_path + [node]):\n            return 1\n        visited.append(node)\n        return sum(count_optimal_paths(neighbor, visited, current_path + [node]) for neighbor in get_neighbors(node))\n\n    N, *roads = stdin.split('\\n')\n    N = int(N)\n    roads = [tuple(map(int, line.split())) for line in roads]\n    shortest_paths = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n\n    for node1 in range(1, N + 1):\n        for node2 in range(1, N + 1):\n            if (node1, node2) in roads:\n                shortest_paths[node1][node2] = 1\n            elif node1 != node2:\n                for road in roads:\n                    if road[0] == node1 and road[1] != node2:\n                        shortest_paths[node1][node2] = min(shortest_paths[node1][node2], shortest_paths[road[1]][node2])\n                    elif road[1] == node1 and road[0] != node2:\n                        shortest_paths[node1][node2] = min(shortest_paths[node1][node2], shortest_paths[road[0]][node2])\n\n    optimal_paths_count = 0\n    for start in range(1, N + 1):\n        for end in range(1, N + 1):\n            if start != end and shortest_paths[start][end] == 2:\n                optimal_paths_count += count_optimal_paths(start, [], [])\n\n    return str(optimal_paths_count)\n"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, fragment = input().splitlines()\n    encrypted_message = encrypted_message.lower()\n    fragment = fragment.lower()\n\n    # Count the frequency of each letter in the fragment\n    fragment_freq = {}\n    for letter in fragment:\n        if letter in fragment_freq:\n            fragment_freq[letter] += 1\n        else:\n            fragment_freq[letter] = 1\n\n    # Initialize the count of positions where the fragment could occur\n    count = 0\n\n    # Iterate through the encrypted message and check if the fragment can be found in each position\n    for i in range(len(encrypted_message) - len(fragment) + 1):\n        found = True\n        for j, letter in enumerate(fragment):\n            if encrypted_message[i + j] != letter and encrypted_message[i + j] != fragment[j].upper():\n                found = False\n                break\n        if found:\n            count += 1\n\n    if count == 1:\n        # If there is a unique position, return the corresponding substring\n        index = encrypted_message.find(fragment)\n        return encrypted_message[index:index + len(fragment)]\n    else:\n        # Otherwise, return the count of positions where the fragment could occur\n        return count"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, fragment = input(stdin).split(\"\\n\")\n    if len(fragment) == 0:\n        return 0\n\n    count = 0\n    positions = []\n    for i in range(len(encrypted_message) - len(fragment) + 1):\n        if encrypted_message[i:i+len(fragment)] == fragment:\n            count += 1\n            positions.append(i)\n\n    if count == 1:\n        return encrypted_message[positions[0]:positions[0] + len(fragment)]\n    else:\n        return count\n\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    message, fragment = stdin.split('\\n')\n    positions = []\n\n    for i in range(len(message) - len(fragment) + 1):\n        if message[i:i+len(fragment)] == fragment:\n            positions.append(i)\n\n    if len(positions) == 1:\n        return message[positions[0]:positions[0] + len(fragment)]\n    elif len(positions) > 1:\n        return len(positions)\n    else:\n        return \"0\""
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = input(stdin).splitlines()\n\n    if len(encrypted_message) > 250000 or len(decrypted_fragment) > 250000:\n        return \"Error: message is too long\"\n\n    if len(decrypted_fragment) == 0:\n        return \"Error: fragment is empty\"\n\n    substitution_map = {chr(i): chr((i - ord('a') + len(decrypted_fragment)) % 26 + ord('a')) for i in range(ord('a'), ord('z') + 1)}\n\n    reversed_map = {v: k for k, v in substitution_map.items()}\n\n    encrypted_message = encrypted_message.lower()\n    decrypted_fragment = decrypted_fragment.lower()\n\n    decrypted_message = \"\"\n    possible_positions = []\n\n    for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n        encrypted_fragment = encrypted_message[i:i + len(decrypted_fragment)]\n        decrypted_fragment_ = decrypted_fragment\n\n        for key, value in reversed_map.items():\n            decrypted_fragment_ = decrypted_fragment_.replace(key, value)\n\n        if encrypted_fragment == decrypted_fragment_:\n            possible_positions.append(i)\n            decrypted_message += encrypted_fragment\n\n    if len(possible_positions) == 0:\n        return \"Error: fragment is not part of the message\"\n    elif len(possible_positions) == 1:\n        return decrypted_message[:possible_positions[0]]\n    else:\n        return str(len(possible_positions)) "
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = input().split('\\n')\n    decrypted_fragment = decrypted_fragment.lower()\n\n    positions = []\n    for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n        if encrypted_message[i:i+len(decrypted_fragment)] == decrypted_fragment:\n            positions.append(i)\n\n    if len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0]+len(decrypted_fragment)]\n    else:\n        return str(len(positions))"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, fragment = stdin.split('\\n')\n    positions = []\n    for i in range(len(encrypted_message) - len(fragment) + 1):\n        if encrypted_message[i:i+len(fragment)] == fragment:\n            positions.append(i)\n    if len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0]+len(fragment)]\n    elif len(positions) > 1:\n        return len(positions)\n    else:\n        return 0\n\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, fragment = input(stdin).split('\\n')\n    fragment = fragment.lower()\n    positions = []\n\n    for i in range(len(encrypted_message) - len(fragment) + 1):\n        if encrypted_message[i:i+len(fragment)] == fragment:\n            positions.append(i)\n\n    if len(positions) == 0:\n        return \"0\"\n    elif len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0] + len(fragment)]\n    else:\n        return str(len(positions))\n\nprint(solution(\"Sample Input 1:\\nsecretmessage\\nboot\\nSample Output 1:essa\\n\\nSample Input 2:\\ntreetreetreetree\\nwood\\nSample Output 2:3\\n\\nSample Input 3:\\noranges\\napples\\nSample Output 3:0\"))\n\"\"\" \nSample Input 4:\nsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecretsecret"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, fragment = stdin.split(\"\\n\")\n    \n    # Initialize a dictionary to store the frequency of each letter in the fragment\n    fragment_freq = {}\n    for letter in fragment:\n        if letter in fragment_freq:\n            fragment_freq[letter] += 1\n        else:\n            fragment_freq[letter] = 1\n\n    # Initialize a dictionary to store the frequency of each letter in the encrypted message\n    encrypted_freq = {}\n    for letter in encrypted_message:\n        if letter in encrypted_freq:\n            encrypted_freq[letter] += 1\n        else:\n            encrypted_freq[letter] = 1\n\n    # Initialize the count of possible positions\n    possible_positions = 0\n\n    # Iterate through each letter in the fragment and check if it can be substituted with any letter in the encrypted message\n    for letter in fragment_freq:\n        if letter in encrypted_freq:\n            possible_positions += encrypted_freq[letter]\n\n    # If possible_positions is 0, it means the fragment could occur in any position in the encrypted message\n    if possible_positions == 0:\n        return \"0\"\n    else:\n        # Otherwise, return the substring of the encrypted message that could correspond to the fragment\n        for i in range(len(encrypted_message)):\n            if all(encrypted_message[i:i+len(fragment)] == fragment):\n                return encrypted_message[i:i+len(fragment)]"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, fragment = input(stdin).split('\\n')\n    positions = []\n    for i in range(len(encrypted_message) - len(fragment) + 1):\n        if encrypted_message[i:i + len(fragment)] == fragment:\n            positions.append(i)\n    if len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0] + len(fragment)]\n    else:\n        return len(positions)"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, fragment = [input() for _ in range(2)]\n    fragment_set = set(fragment)\n    positions = []\n    \n    for i in range(len(encrypted_message) - len(fragment) + 1):\n        if all(encrypted_message[i+j] in fragment_set for j in range(len(fragment))):\n            positions.append(i)\n    \n    if len(positions) == 0:\n        return str(len(positions))\n    else:\n        return encrypted_message[positions[0]:positions[0]+len(fragment)]\n"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split(\"\\n\", 1)\n    N = int(N)\n    grid = program.split(\"\\n\")\n\n    robot_pos = None\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == \"R\":\n                robot_pos = (i, j)\n                break\n        if robot_pos is not None:\n            break\n\n    if robot_pos is None:\n        raise ValueError(\"There should be a robot on the grid\")\n\n    def is_valid_move(row: int, col: int, direction: str) -> bool:\n        if direction == \"<\":\n            if col > 0 and grid[row][col - 1] == \".\":\n                return True\n        elif direction == \">\":\n            if col < N - 1 and grid[row][col + 1] == \".\":\n                return True\n        elif direction == \"^\":\n            if row > 0 and grid[row - 1][col] == \".\":\n                return True\n        elif direction == \"v\":\n            if row < N - 1 and grid[row + 1][col] == \".\":\n                return True\n        else:\n            raise ValueError(f\"Invalid direction {direction}\")\n\n    def get_next_pos(row: int, col: int, direction: str) -> Tuple[int, int]:\n        if direction == \"<\":\n            return (row, col - 1)\n        elif direction == \">\":\n            return (row, col + 1)\n        elif direction == \"^\":\n            return (row - 1, col)\n        elif direction == \"v\":\n            return (row + 1, col)\n        else:\n            raise ValueError(f\"Invalid direction {direction}\")\n\n    def dfs(row: int, col: int, direction: str, visited: Set[Tuple[int, int]]) -> bool:\n        if (row, col) in visited:\n            return False\n        visited.add((row, col))\n\n        if direction == \"<\":\n            if grid[row][col - 1] == \".\":\n                return dfs(row, col - 1, direction, visited)\n            elif grid[row][col - 1] == \"R\":\n                return True\n        elif direction == \">\":\n            if grid[row][col + 1] == \".\":\n                return dfs(row, col + 1, direction, visited)\n            elif grid[row][col + 1] == \"R\":\n                return True\n        elif direction == \"^\":\n            if grid[row - 1][col] == \".\":\n                return dfs(row - 1, col, direction, visited)\n            elif grid[row - 1][col] == \"R\":\n                return True\n        elif direction == \"v\":\n            if grid[row + 1][col] == \".\":\n                return dfs(row + 1, col, direction, visited)\n            elif grid[row + 1][col] == \"R\":\n                return True\n        else:\n            raise ValueError(f\"Invalid direction {direction}\")\n\n    visited = set()\n    count = 0\n    for direction in program:\n        row, col = robot_pos\n        if is_valid_move(row, col, direction):\n            count += 1\n            row, col = get_next_pos(row, col, direction)\n            if (row, col) in visited:\n                break\n            if not dfs(row, col, direction, visited):\n                count -= 1\n                break\n            robot_pos = (row, col)\n\n    if count == N:\n        return \"1\"\n    else:\n        for i in range(count, count + N - 1):\n            if i % N == 0:\n                return str(i + 1)\n        return str(count + N)"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split(\"\\n\")\n    N = int(N)\n\n    grid = []\n    for i in range(N):\n        row = stdin.split(\"\\n\")[i + 2]\n        grid.append(list(row))\n\n    robot_pos = next((i, j) for i in range(N) for j in range(N) if grid[i][j] == 'R')\n    robot_trail = [(robot_pos[0], robot_pos[1])]\n\n    i, j = robot_pos\n    for direction in program:\n        if direction == '<':\n            j -= 1\n        elif direction == '>':\n            j += 1\n        elif direction == '^':\n            i -= 1\n        elif direction == 'v':\n            i += 1\n\n        if 0 <= i < N and 0 <= j < N and grid[i][j] == '.':\n            robot_trail.append((i, j))\n\n    if len(set(robot_trail)) == len(robot_trail):\n        return '1'\n    else:\n        X = len(set(robot_trail[:len(set(robot_trail))]))\n        return str(X)"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split('\\n', 1)\n    N = int(N)\n    program = list(program.strip())\n    grid = []\n    \n    for _ in range(N):\n        row = input().strip()\n        grid.append(row)\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'R':\n                robot_pos = (i, j)\n                break\n    \n    robot_trail = [robot_pos]\n    i, j = robot_pos\n    while True:\n        next_pos = robot_pos\n        for direction in program:\n            if direction == '<':\n                if j > 0 and grid[i][j-1] != '#':\n                    j -= 1\n            elif direction == '>':\n                if j < N-1 and grid[i][j+1] != '#':\n                    j += 1\n            elif direction == '^':\n                if i > 0 and grid[i-1][j] != '#':\n                    i -= 1\n            elif direction == 'v':\n                if i < N-1 and grid[i+1][j] != '#':\n                    i += 1\n            else:\n                raise ValueError(\"Invalid direction\")\n        if next_pos in robot_trail:\n            robot_trail.append(robot_pos)\n            break\n        else:\n            robot_trail.append(next_pos)\n            robot_pos = next_pos\n    \n    if len(robot_trail) == N*N:\n        return \"1\"\n    else:\n        for i in range(len(robot_trail)-1):\n            for j in range(i+1, len(robot_trail)):\n                if robot_trail[i:j] == robot_trail[j:]:\n                    return str(j-i)\n        raise ValueError(\"Failed to find a repetition of a continuous subsequence of the trail\") "
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split('\\n', 1)\n    N = int(N)\n    grid = stdin.split('\\n', N-1)[1:]\n    \n    robot_row, robot_col = None, None\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'R':\n                robot_row, robot_col = i, j\n                break\n        if robot_row is not None:\n            break\n    \n    trails = []\n    robot_trail = [grid[robot_row][robot_col]]\n    direction = {'<': (-1, 0), '>': (1, 0), '^': (0, -1), 'v': (0, 1)}\n    for c in program:\n        if c in direction:\n            row_diff, col_diff = direction[c]\n            row, col = robot_row, robot_col\n            while 0 <= row < N and 0 <= col < N and grid[row][col] != '#':\n                row, col = row + row_diff, col + col_diff\n                if row == robot_row and col == robot_col:\n                    break\n            robot_trail.append(grid[row][col])\n            if len(trails) > 0 and robot_trail == trails[-1]:\n                trails.pop()\n            trails.append(robot_trail[:])\n            if len(trails) > 1 and trails[-1] == trails[-2]:\n                return str(len(trails[-1]))\n        else:\n            robot_trail.append(c)\n    \n    return '1'"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split(\"\\n\")\n    N = int(N)\n    grid = [input().split() for _ in range(N)]\n    robot_row = robot_col = 0\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \"R\":\n                robot_row, robot_col = i, j\n                break\n    visited = set()\n    move = 0\n    while True:\n        visited.add(str(robot_row) + \",\" + str(robot_col))\n        for c in program:\n            if c == \"<\" and robot_col > 0 and grid[robot_row][robot_col - 1] != \"#\":\n                robot_col -= 1\n            elif c == \">\" and robot_col < N - 1 and grid[robot_row][robot_col + 1] != \"#\":\n                robot_col += 1\n            elif c == \"^\" and robot_row > 0 and grid[robot_row - 1][robot_col] != \"#\":\n                robot_row -= 1\n            elif c == \"v\" and robot_row < N - 1 and grid[robot_row + 1][robot_col] != \"#\":\n                robot_row += 1\n            else:\n                continue\n            if str(robot_row) + \",\" + str(robot_col) in visited:\n                break\n        else:\n            move += 1\n            continue\n        break\n    if move == 1:\n        return \"1\"\n    else:\n        return str(N - move)\n\ninput_data = \"\"\"6\n>^<^\n######\n"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(i: int, j: int, grid: List[List[str]]) -> bool:\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == '.'\n\n    def move(i: int, j: int, grid: List[List[str]], direction: str) -> Tuple[int, int]:\n        if direction == '<':\n            return i, j - 1\n        elif direction == '>':\n            return i, j + 1\n        elif direction == '^':\n            return i - 1, j\n        elif direction == 'v':\n            return i + 1, j\n        else:\n            return i, j\n\n    def generate_trail(i: int, j: int, grid: List[List[str]], program: str) -> List[Tuple[int, int]]:\n        trail = [(i, j)]\n        for direction in program:\n            next_i, next_j = move(i, j, grid, direction)\n            if is_valid(next_i, next_j, grid) and (next_i, next_j) not in trail:\n                trail.append((next_i, next_j))\n                i, j = next_i, next_j\n            else:\n                continue\n        return trail\n\n    def find_cycle(trail: List[Tuple[int, int]]) -> int:\n        cycle_length = 0\n        for i in range(len(trail)):\n            if trail[i] in trail[i + 1:]:\n                cycle_length = trail[i + 1:].index(trail[i]) + 1\n                break\n        return cycle_length\n\n    N, program = stdin.split('\\n')\n    N = int(N)\n    grid = [list(line) for line in stdin.split('\\n')[2:N + 2]]\n    i, j = next(x for x, cell in enumerate(grid[N - 1]) if cell == 'R')\n    trail = generate_trail(i, j, grid, program)\n\n    if len(trail) == len(set(trail)):\n        return 1\n    else:\n        cycle_length = find_cycle(trail)\n        return cycle_length"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, program, grid = stdin.split(\"\\n\")\n    N = int(N)\n    grid = [[c for c in line] for line in grid]\n\n    robot_pos = None\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \"R\":\n                robot_pos = (i, j)\n                break\n\n    trail = []\n    for _ in range(N):\n        for char in program:\n            if char == \"<\":\n                robot_pos = (robot_pos[0], max(robot_pos[1] - 1, 0))\n            elif char == \">\":\n                robot_pos = (robot_pos[0], min(robot_pos[1] + 1, N - 1))\n            elif char == \"^\":\n                robot_pos = (max(robot_pos[0] - 1, 0), robot_pos[1])\n            elif char == \"v\":\n                robot_pos = (min(robot_pos[0] + 1, N - 1), robot_pos[1])\n            if grid[robot_pos[0]][robot_pos[1]] != \"#\":\n                trail.append((robot_pos[0], robot_pos[1]))\n            if grid[robot_pos[0]][robot_pos[1]] == \"R\":\n                break\n\n    if len(trail) == N * N:\n        return \"1\"\n    else:\n        X = 0\n        for i in range(len(trail) - 1):\n            if trail[i] == trail[i + 1]:\n                X += 1\n            else:\n                break\n        return str(X + 1)\n"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split(\"\\n\", 1)\n    N = int(N)\n    grid = program.split(\"\\n\")\n    robot_pos = None\n    for i in range(N):\n        if \"R\" in grid[i]:\n            robot_pos = (i, grid[i].index(\"R\"))\n            break\n    if robot_pos is None:\n        return \"1\"\n    trail = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \".\":\n                continue\n            new_pos = (i, j)\n            if new_pos == robot_pos:\n                continue\n            new_pos = check_move(grid, new_pos, program, i, j)\n            if new_pos:\n                trail.append(new_pos)\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \".\":\n                continue\n            new_pos = (i, j)\n            if new_pos == robot_pos:\n                continue\n            new_pos = check_move(grid, new_pos, program, i, j, reverse=True)\n            if new_pos:\n                trail.append(new_pos)\n    if len(trail) == len(set(trail)):\n        return \"1\"\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \".\":\n                continue\n            new_pos = (i, j)\n            if new_pos == robot_pos:\n                continue\n            new_pos = check_move(grid, new_pos, program, i, j)\n            if new_pos:\n                new_pos = check_move(grid, new_pos, program, i, j, reverse=True)\n                if new_pos:\n                    return 1\n    return \"1\"\n\ndef"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split(\"\\n\")\n    N = int(N)\n\n    grid = [input().split() for _ in range(N)]\n    robot_pos = None\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \"R\":\n                robot_pos = (i, j)\n                break\n        if robot_pos is not None:\n            break\n\n    if robot_pos is None:\n        return \"1\"\n\n    def get_neighbors(cell: tuple) -> list:\n        i, j = cell\n        neighbors = []\n        if i > 0:\n            neighbors.append((i - 1, j))\n        if i < N - 1:\n            neighbors.append((i + 1, j))\n        if j > 0:\n            neighbors.append((i, j - 1))\n        if j < N - 1:\n            neighbors.append((i, j + 1))\n        return neighbors\n\n    def get_cells_visited(program: str, start_cell: tuple, grid: list, visited: set) -> set:\n        cells_visited = set()\n        i, j = start_cell\n        for char in program:\n            if char == \"<\":\n                j -= 1\n            elif char == \">\":\n                j += 1\n            elif char == \"^\":\n                i -= 1\n            elif char == \"v\":\n                i += 1\n            if (i, j) in grid and (i, j) not in visited:\n                visited.add((i, j))\n                cells_visited.add((i, j))\n        return cells_visited\n\n    visited = set()\n    visited.add(robot_pos)\n    cells_visited = get_cells_visited(program, robot_pos, grid, visited)\n    while True:\n        new_cells_visited = set()\n        for cell in cells_visited:\n            neighbors = get_neighbors(cell)\n            for neighbor in neighbors:\n                if neighbor not in visited and grid[neighbor[0]][neighbor[1]] != \"#\":\n                    new_cells_visited.add(neighbor)\n        visited = visited.union(cells_visited)\n        if len(new_cells_visited) == 0:\n            return \"1\"\n        cells_visited = new_cells_visited"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, program = map(str, stdin.split(\"\\n\")[:2])\n    N = int(N)\n    grid = stdin.split(\"\\n\")[2:]\n\n    def is_empty(cell):\n        return cell == \".\"\n\n    def is_impassable(cell):\n        return cell == \"#\"\n\n    def is_robot(cell):\n        return cell == \"R\"\n\n    def get_neighbors(row, col):\n        return [\n            (row - 1, col) if 0 <= row - 1 < N and not is_impassable(grid[row - 1][col]) else None,\n            (row, col + 1) if 0 <= col + 1 < N and not is_impassable(grid[row][col + 1]) else None,\n            (row + 1, col) if 0 <= row + 1 < N and not is_impassable(grid[row + 1][col]) else None,\n            (row, col - 1) if 0 <= col - 1 < N and not is_impassable(grid[row][col - 1]) else None,\n        ]\n\n    def get_cell_content(row, col):\n        return grid[row][col]\n\n    def move_robot(direction):\n        row, col = get_robot_position()\n        neighbors = get_neighbors(row, col)\n\n        if direction == \">\":\n            if neighbors[1] is not None:\n                row, col = neighbors[1]\n            else:\n                return False\n        elif direction == \"<\":\n            if neighbors[2] is not None:\n                row, col = neighbors[2]\n            else:\n                return False\n        elif direction == \"^\":\n            if neighbors[3] is not None:\n                row, col = neighbors[3]\n            else:\n                return False\n        elif direction == \"v\":\n            if neighbors[0] is not None:\n                row, col = neighbors[0]\n            else:\n                return False\n\n        grid[row][col] = \"R\"\n        grid[row][col - 1] = \".\"\n        return True\n\n    def get_robot_position():\n        for row in range(N):\n            for col in range(N):\n                if is_robot(get_cell_content(row, col)):\n                    return row, col\n\n    def get_trail():\n        row, col = get_robot_position()\n        trail = [(row, col)]\n\n        while True:\n            for direction in program:\n                if not move_robot(direction):\n                    return trail\n                row, col = get_robot_position()\n                trail.append((row, col))\n\n    def find_cycle(trail):\n        seen = set()\n        i = 0\n        for j in range(len(trail)):\n            if tuple(trail[i:j + 1]) in seen:\n                return j - i\n            seen.add(tuple(trail[i:j + 1]))\n            i = j + 1\n        return len(trail)\n\n    trail = get_trail()\n    X = find_cycle(trail)\n\n    if X == len(trail):\n        return \"1\"\n    else:\n        return str(X)\n"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    fogs = []\n    for i in range(1, n + 1):\n        params = list(map(int, stdin.splitlines()[i].split()))\n        fogs.append(params)\n\n    missed_fogs = 0\n    for i in range(n):\n        m, d, l, r, h, delta_d, delta_x, delta_h = fogs[i]\n        missed_fogs += (r - l) * (h - 1) * (m - 1)\n\n    return str(missed_fogs)"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    fogs = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    \n    total_missed = 0\n    for i in range(n):\n        total_missed += sum(fogs[i][0] - 1)\n    \n    return str(total_missed)\n\n\ndef"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    fogs = []\n    for i in range(1, n + 1):\n        params = stdin.splitlines()[i].split()\n        fogs.append([int(params[j]) for j in range(len(params))])\n\n    total_missed = 0\n    for i in range(n):\n        missed = fogs[i][0]\n        for j in range(1, missed + 1):\n            total_missed += j * fogs[i][1] * fogs[i][2]\n\n    return str(total_missed)"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    fogs = []\n\n    for _ in range(n):\n        params = list(map(int, input().split()))\n        m, d, l, r, h, dd, dh, dh_min = params\n        fogs.append((m, d, l, r, h, dd, dh, dh_min))\n\n    total_missed = 0\n    for _, _, _, _, _, _, _, _ in fogs:\n        total_missed += 1\n\n    return str(total_missed)\n\nn = 3\nfogs = [(4, 0, 0, 10, 10, 1, 15, 0), (3, 5, 50, 55, 8, 1, -16, 2), (3, 10, 7, 10, 4, 1, 8, -1)]\n\nprint(solution(n, fogs)) # Output: 6"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def compute_patch_area(m: int, h: int, delta_h: int) -> int:\n        return m * h + (m - 1) * delta_h\n\n    n, stdin = read_line(stdin)\n    fogs_missed = 0\n\n    for _ in range(n):\n        m, d, l, r, h, delta_d, delta_x, delta_h = read_line(stdin)\n        total_patch_area = 0\n        for k in range(m):\n            total_patch_area += compute_patch_area(m, h, delta_h)\n        fogs_missed += d * (1 - total_patch_area / (r - l) / h)\n\n    return str(fogs_missed)\n\ndef"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    fogs = []\n    for i in range(1, n + 1):\n        m, d, l, r, h, dd, dx, dh = map(int, stdin.splitlines()[i].split())\n        fogs.append((m, d, l, r, h, dd, dx, dh))\n    \n    total_missed = 0\n    for i in range(n):\n        m, d, l, r, h, dd, dx, dh = fogs[i]\n        total_missed += m - 1\n    \n    return str(total_missed)\n"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    fogs = [line.split() for line in stdin.splitlines()[1:]]\n    total_missed_fogs = 0\n    \n    for i in range(n):\n        m, d, l, r, h, dd, dh, dh2 = [int(x) for x in fogs[i]]\n        for j in range(m):\n            total_missed_fogs += (l + j*dh + (dh2 if dh2 > 0 else 0)) // dh\n            \n    return str(total_missed_fogs)\n"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> tuple:\n        n, *params = input_str.split()\n        n = int(n)\n        fogs = []\n        for i in range(n):\n            m, d, l, r, h, dd, dh, dh_i = map(int, params[i*8:i*8+8])\n            fogs.append((m, d, l, r, h, dd, dh, dh_i))\n        return n, fogs\n\n    def count_missed_fogs(fogs: list) -> int:\n        missed_fogs = 0\n        for i, (m, d, l, r, h, dd, dh, dh_i) in enumerate(fogs):\n            missed_fogs += (r - l) * (h + dh_i * m - 1)\n        return missed_fogs\n\n    n, fogs = parse_input(stdin)\n    return str(count_missed_fogs(fogs))"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    fogs = []\n    for i in range(1, n + 1):\n        m, d, l, r, h, dd, dx, dh = map(int, stdin.splitlines()[i].split())\n        fogs.append((m, d, l, r, h, dd, dx, dh))\n\n    total_missed_fogs = 0\n    for i in range(n):\n        missed_fogs = 0\n        for j in range(fogs[i][0]):\n            missed_fogs += fogs[i][1]\n        total_missed_fogs += missed_fogs\n\n    return str(total_missed_fogs)\n\ninput_string = \"\"\"2\n2 3 0 2 9 2 3 0\n1 6 1 4 6 3 -1 -2\n\n3\n4 0 0 10 10 1 15 0\n3 5 50 55 8 1 -16 2\n3 10 7 10 4 1 8 -1\n\n2\n7 0 0 20 10 3 0 10\n10 1 0 2 5 2 2 7\n\"\"\"\noutput = solution(input_string)\nprint(output)"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    fogs = []\n    for i in range(1, n + 1):\n        m, d, ll, r, h, dd, dx, dh = map(int, stdin.split(\"\\n\")[i].split())\n        fogs.append((m, d, ll, r, h, dd, dx, dh))\n\n    missed_fogs = 0\n    for i in range(n):\n        m, d, ll, r, h, dd, dx, dh = fogs[i]\n        missed_fogs += (r - ll) * dd\n\n    return str(missed_fogs)\n\ndef"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def time(dist):\n        return dist / 2\n\n    def min_time(A, B, conveyors):\n        conveyors.sort(key=lambda c: distance(A, c))\n        conveyors.sort(key=lambda c: distance(B, c))\n        conveyor_times = []\n\n        for c in conveyors:\n            d = distance(A, c)\n            if d <= 1:\n                A = c[1] if A[0] - c[0] > 0 else c[0]\n                continue\n            t = time(d)\n            conveyor_times.append((c, t))\n\n        d = distance(A, B)\n        t = time(d)\n        return t + min((c[1] for c in conveyor_times), default=0)\n\n    stdin = stdin.split('\\n')\n    A = tuple(map(float, stdin[0].split()[:2]))\n    B = tuple(map(float, stdin[0].split()[2:]))\n    N = int(stdin[1])\n    conveyors = [tuple(map(float, stdin[i + 2].split())) for i in range(N)]\n\n    return f\"{min_time(A, B, conveyors):.10f}\"\n"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    coordinates_A = list(map(float, input_data[0].split()))\n    coordinates_B = list(map(float, input_data[1].split()))\n    N = int(input_data[2])\n    conveyors = []\n    for i in range(N):\n        conveyors.append(list(map(float, input_data[i+3].split())))\n\n    def distance(point1, point2):\n        return ((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)**0.5\n\n    def time_to_reach_point(point, conveyors):\n        time = 0\n        for conveyor in conveyors:\n            if distance(point, conveyor[0]) <= distance(point, conveyor[1]):\n                time = max(time, distance(point, conveyor[0])/2)\n            else:\n                time = max(time, (distance(conveyor[1], point) - distance(conveyor[0], point))/2 + distance(conveyor[0], point)/2)\n        return time\n\n    time_to_A = time_to_reach_point(coordinates_A, conveyors)\n    time_to_B = time_to_reach_point(coordinates_B, conveyors)\n    total_time = time_to_A + time_to_B\n\n    return f\"{total_time:.4f}\"\n\n\ninput_data = '''\n60.0 0.0 50.0 170.0\n3\n40.0 0.0 0.0 0.0\n5.0 20.0 5.0 170.0\n95.0 0.0 95.0 80.0\n'''\nprint(solution(input_data))\n\n\ninput_data = '''\n60.0 0.0 50.0 170.0\n3\n40.0 0.0 0.0 0.0\n5.0 20.0 5.0 170.0\n95.0 0.0 95.0 100.0\n'''\nprint(solution(input_data))\n\n\ninput_data = '''\n0.0 1.0 4.0 1.0\n1\n0.0 0.0 4.0 0.0\n'''\nprint(solution(input_data))"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    init_coords = list(map(float, input_data[0].split()))\n    conveyors = []\n    n = int(input_data[1])\n    for i in range(n):\n        conveyor_coords = list(map(float, input_data[i+2].split()))\n        conveyors.append(conveyor_coords)\n\n    def distance(a, b):\n        return ((a[0] - b[0])**2 + (a[1] - b[1])**2)**0.5\n\n    def get_min_time(a, b):\n        min_time = float('inf')\n        for conveyor in conveyors:\n            if distance(a, conveyor) < 1 and distance(b, conveyor) < 1:\n                min_time = min(min_time, (distance(a, conveyor) + distance(conveyor, b)) / 2)\n        return min_time\n\n    min_time = min(get_min_time(init_coords, conveyor) for conveyor in conveyors)\n    return str(min_time)\n\ninput_data = '''60.0 0.0 50.0 170.0\n3\n40.0 0.0 0.0 0.0\n5.0 20.0 5.0 170.0\n95.0 0.0 95.0 80.0'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n\n    # Parse input\n    xa, ya, xb, yb = map(float, input_data[0].split())\n    n = int(input_data[1])\n    conveyors = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(float, input_data[2 + _].split())\n        conveyors.append(((x1, y1), (x2, y2)))\n\n    # Calculate the minimum time\n    def get_time(p):\n        x, y = p\n        time = 0\n        for i, (p1, p2) in enumerate(conveyors):\n            x1, y1 = p1\n            x2, y2 = p2\n            if x1 <= x <= x2 and y1 <= y <= y2:\n                if x == x1 or x == x2 or y == y1 or y == y2:\n                    time += ((y - y1)**2 + (x - x1)**2)**0.5 / 10**6\n                else:\n                    time += 2 / 10**6\n                if i % 2 == 0:\n                    time += 1 / 10**6\n                break\n        return time\n\n    time_a = get_time((xa, ya))\n    time_b = get_time((xb, yb))\n    time = time_b + time_a\n\n    return f\"{time:.6f}\"\n"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def fastest_conveyor(p1, p2, conveyors):\n        fastest = None\n        conveyor_to_use = None\n        for conveyor in conveyors:\n            start, end = conveyor\n            if start[0] <= p1[0] <= end[0] and start[1] <= p1[1] <= end[1]:\n                dist = distance(p1, p2)\n                time = dist / 2\n                if fastest is None or time < fastest:\n                    fastest = time\n                    conveyor_to_use = conveyor\n        return conveyor_to_use, fastest\n\n    def fastest_path(p1, p2, conveyors):\n        time = 0\n        while p1 != p2:\n            conveyor, t = fastest_conveyor(p1, p2, conveyors)\n            if conveyor:\n                p1 = (conveyor[1][0], conveyor[1][1])\n                time += t\n            else:\n                time += distance(p1, p2) / 1\n                p1 = (p1[0], p1[1] - 1)\n        return time\n\n    lines = stdin.splitlines()\n    X1, Y1, X2, Y2 = map(float, lines[0].split())\n    N = int(lines[1])\n    conveyors = []\n    for i in range(2, 2 + N):\n        X1, Y1, X2, Y2 = map(float, lines[i].split())\n        conveyors.append(((X1, Y1), (X2, Y2)))\n\n    A = (X1, Y1)\n    B = (X2, Y2)\n    time = fastest_path(A, B, conveyors)\n    return f\"{time:.4f}\""
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2) ** 0.5\n\n    def point_on_line(p1, p2, ratio):\n        x = p1[0] + (p2[0] - p1[0]) * ratio\n        y = p1[1] + (p2[1] - p1[1]) * ratio\n        return (x, y)\n\n    def closest_point(p, p1, p2):\n        line = [p1, p2]\n        d = distance(p1, p2)\n        if d == 0:\n            return p1\n\n        t = (p[0] - p1[0]) * (p2[0] - p1[0]) + (p[1] - p1[1]) * (p2[1] - p1[1])\n        if t < 0:\n            return p1\n        if t > d:\n            return p2\n\n        ratio = t / d\n        return point_on_line(p1, p2, ratio)\n\n    def time_to_travel(p1, p2, speed):\n        return distance(p1, p2) / speed\n\n    lines = []\n    x_a, y_a, x_b, y_b = map(float, input().split())\n    n = int(input())\n\n    for i in range(n):\n        x1, y1, x2, y2 = map(float, input().split())\n        lines.append(((x1, y1), (x2, y2)))\n\n    p1 = (x_a, y_a)\n    p2 = (x_b, y_b)\n\n    closest_a = p1\n    closest_b = p2\n\n    for line in lines:\n        closest_a = closest_point(closest_a, p1, line[0])\n        closest_b = closest_point(closest_b, p2, line[1])\n\n    time_a = time_to_travel(p1, closest_a, 2)\n    time_b = time_to_travel(closest_b, p2, 2)\n\n    total_time = time_a + time_b\n\n    return f\"{total_time:.6f}\""
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    x_a, y_a, x_b, y_b = map(float, stdin.split()[:4])\n    n = int(stdin.split()[4])\n    conveyors = [list(map(float, stdin.split()[5 + i * 4: 9 + i * 4])) for i in range(n)]\n\n    # helper function to check if a point is on a conveyor\n    def on_conveyor(x, y, conveyor):\n        x1, y1, x2, y2 = conveyor\n        if y1 == y2:\n            return x1 <= x <= x2 and y1 <= y <= y2\n        else:\n            return False\n\n    # distance function\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    # check if we can go from A to B without using conveyors\n    if distance(x_a, y_a, x_b, y_b) <= 1:\n        return str(distance(x_a, y_a, x_b, y_b) / 1)\n\n    # calculate the time needed to walk on a conveyor\n    def time_on_conveyor(x1, y1, x2, y2, x, y):\n        dx = x2 - x1\n        dy = y2 - y1\n        dist = distance(x1, y1, x2, y2)\n        if dx == 0:\n            return dist / 2 if y1 <= y <= y2 else (dist - dist / 2)\n        if dy == 0:\n            return dist / 2 if x1 <= x <= x2 else (dist - dist / 2)\n        theta = math.atan2(dy, dx)\n        dx1 = x1 - x\n        dy1 = y1 - y\n        dx2 = x2 - x\n        dy2 = y2 - y\n        a1 = (dx1 * math.cos(theta) + dy1 * math.sin(theta)) / dist\n        a2 = (dx2 * math.cos(theta) + dy2 * math.sin(theta)) / dist\n        a = a1 + a2\n        if a >= 1 and a <= 2:\n            return dist / 2\n        else:\n            return (1 - a) * dist\n\n    # calculate the time needed to walk on the floor\n    def time_on_floor(x, y, x_dest, y_dest):\n        dist = distance(x, y, x_dest, y_dest)\n        return dist / 1\n\n    # calculate the time needed to get from A to B using the conveyors\n    time_conveyor = float('inf')\n    for conveyor in conveyors:\n        if on_conveyor(x_a, y_a, conveyor) and on_conveyor(x_b, y_b, conveyor):\n            x1, y1, x2, y2 = conveyor\n            time_conveyor = min(time_conveyor, time_on_conveyor(x1, y1, x2, y2, x_a, y_a) + time_on_conveyor(x1, y1, x2, y2, x_b, y_b) + time_on_floor(x_a, y_a, x_b, y_b))\n\n    # calculate the time needed to get from A to B without using the conveyors\n    time_floor = time_on_floor(x_a, y_a, x_b, y_b)\n\n    # return the minimum time\n    return str(min(time_floor, time_conveyor))"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    initial_pos = tuple(map(float, input_data[0].split()))\n    conveyors = []\n    for i in range(1, len(input_data) - 1):\n        conveyors.append(tuple(map(float, input_data[i].split())))\n    \n    def distance(a, b):\n        return ((a[0] - b[0])**2 + (a[1] - b[1])**2)**0.5\n    \n    def min_time(start, end, conveyors):\n        time = 0\n        current_pos = start\n        while current_pos != end:\n            if distance(current_pos, end) < distance(current_pos, conveyors[0][0]):\n                current_pos = (current_pos[0] + (end[0] - current_pos[0]) / distance(current_pos, end) * 1, current_pos[1] + (end[1] - current_pos[1]) / distance(current_pos, end) * 1)\n            else:\n                current_pos = (current_pos[0] + (conveyors[0][0][0] - current_pos[0]) / distance(current_pos, conveyors[0][0]) * 2, current_pos[1] + (conveyors[0][0][1] - current_pos[1]) / distance(current_pos, conveyors[0][0]) * 2)\n                time += 2 / 3\n                conveyors.pop(0)\n        return time\n    \n    time = min_time(initial_pos, (40.0, 0.0), [(0.0, 0.0, 0.0, 0.0)])\n    time += min_time((40.0, 0.0), (5.0, 20.0), [(5.0, 20.0, 5.0, 170.0)])\n    time += min_time((5.0, 20.0), (95.0, 0.0), [(95.0, 0.0, 95.0, 80.0)])\n    \n    return f\"{time:.6f}\"\n\ninput_data = \"\"\"60.0 0.0 50.0 170.0\n3\n40.0 0.0 0.0 0.0\n5.0 20.0 5.0 170.0\n95.0 0.0 95.0 80.0\"\"\"\n\noutput_data = \"\"\"168.7916512460\"\"\"\n\nassert solution(input_data) == output_data\n\ninput_data = \"\"\"60.0 0.0 50.0 170.0\n3\n40.0 0.0 0.0 0.0\n5.0 20.0 5.0 170.0\n95.0 0.0 95.0 100.0\"\"\"\n\noutput_data = \"\"\"163.5274740179\"\"\"\n\nassert solution(input_data) == output_data\n\ninput_data = \"\"\"0.0 1.0 4.0 1.0\n1\n0.0 0.0 4.0 0.0\"\"\"\n\noutput_data = \"\"\"3.7320508076\"\"\"\n\nassert solution(input_data) == output_data "
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0])**2 + (a[1] - b[1])**2)**0.5\n\n    def nearest_conveyor(pos, conveyors):\n        conveyor = None\n        min_dist = float('inf')\n        for c in conveyors:\n            if c[0] <= pos[0] <= c[2] and c[1] <= pos[1] <= c[3]:\n                dist = distance(pos, (c[0], c[1]))\n                if dist < min_dist:\n                    min_dist = dist\n                    conveyor = c\n        return conveyor, min_dist\n\n    def walk_time(pos, conveyor, conveyors):\n        if conveyor is None:\n            return distance(pos, (pos[0], pos[1] + 1))\n        if pos[1] < conveyor[1] or pos[1] > conveyor[3]:\n            return distance(pos, (pos[0], pos[1] + 1))\n        dist = distance(pos, (conveyor[2], conveyor[1]))\n        if dist < 2:\n            return 2\n        return dist + walk_time((conveyor[2], conveyor[1]), None, conveyors)\n\n    lines = stdin.split('\\n')\n    x_a, y_a, x_b, y_b = map(float, lines[0].split())\n    n = int(lines[1])\n    conveyors = []\n    for i in range(2, 2 + n):\n        x1, y1, x2, y2 = map(float, lines[i].split())\n        conveyors.append((x1, y1, x2, y2))\n\n    start = (x_a, y_a)\n    end = (x_b, y_b)\n    conveyor, dist = nearest_conveyor(start, conveyors)\n    time = max(dist, walk_time(start, conveyor, conveyors))\n    conveyor, dist = nearest_conveyor(end, conveyors)\n    time += max(dist, walk_time(end, conveyor, conveyors))\n    return time"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def euclidean_distance(point1, point2):\n        return ((point2[0] - point1[0]) ** 2 + (point2[1] - point1[1]) ** 2) ** 0.5\n\n    def compute_time(start, end):\n        distance = euclidean_distance(start, end)\n        if distance == 0:\n            return 0\n        time = distance / 2\n        return time\n\n    lines = stdin.splitlines()\n    start = tuple(map(float, lines[0].split()))\n    end = tuple(map(float, lines[1].split()))\n    conveyors = [tuple(map(float, line.split())) for line in lines[2:]]\n\n    def is_conveyor_valid(start, end):\n        for conveyor in conveyors:\n            if start[0] < conveyor[0] and start[1] < conveyor[1] and start[0] < conveyor[2] and start[1] < conveyor[3] and \\\n               end[0] > conveyor[0] and end[1] > conveyor[1] and end[0] > conveyor[2] and end[1] > conveyor[3]:\n                return True\n        return False\n\n    def get_time(start, end):\n        conveyor_start = None\n        for conveyor in conveyors:\n            if start[0] < conveyor[0] and start[1] < conveyor[1] and \\\n               end[0] > conveyor[2] and end[1] > conveyor[3]:\n                conveyor_start = conveyor\n                break\n        if conveyor_start is None:\n            return compute_time(start, end)\n        conveyor_end = (conveyor_start[2], conveyor_start[3])\n        conveyor_start = (conveyor_start[0], conveyor_start[1])\n        time_to_conveyor_start = compute_time(start, conveyor_start)\n        time_on_conveyor = compute_time(conveyor_start, conveyor_end)\n        time_to_end = compute_time(conveyor_end, end)\n        return time_to_conveyor_start + time_on_conveyor + time_to_end\n\n    if is_conveyor_valid(start, end):\n        return str(get_time(start, end))\n    else:\n        time_to_start = compute_time(start, (0, 0))\n        time_to_end = compute_time((0, 0), end)\n        return str(time_to_start + time_to_end)\n"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if N < K or P > N or N % 2 == 0 or K > N // 2 + 1 or P > N // 2 + 1:\n        return \"IMPOSSIBLE\"\n\n    s = \"\"\n    for i in range(K):\n        s += chr(i + ord('a'))\n\n    s = s * (N // K)\n    s += s[:P]\n\n    for i in range(K, N - P + 1):\n        s += chr(K + (i - K) % (26 - K))\n\n    return s\n"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    N, K, P = map(int, input_str.split())\n\n    if K > 26 or N > 10**6 or P > N:\n        return \"IMPOSSIBLE\"\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def longest_palindrome_substring(s: str) -> str:\n        longest = \"\"\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                substring = s[i:j+1]\n                if is_palindrome(substring) and len(substring) > len(longest):\n                    longest = substring\n        return longest\n\n    # Generate all possible characters that can be used in the string\n    chars = \"abcdefghijklmnopqrstuvwxyz\"\n    if K == 26:\n        possible_chars = chars\n    else:\n        possible_chars = \"\"\n        for i in range(K):\n            possible_chars += chars[i]\n\n    # Find the longest palindromic substring that satisfies the P requirement\n    longest_palindrome = \"\"\n    for i in range(2, N+1):\n        if is_palindrome(possible_chars[:i]):\n            longest_palindrome = possible_chars[:i]\n\n    if len(longest_palindrome) < P:\n        return \"IMPOSSIBLE\"\n\n    return longest_palindrome\n"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n\n    if K > 13:\n        return \"IMPOSSIBLE\"\n\n    if P > N:\n        return \"IMPOSSIBLE\"\n\n    # Generate all possible characters\n    chars = \"abcdefghijklmnopqrstuvwxyz\"\n\n    # Check if the length of the string is less than N\n    if len(chars) < N:\n        return \"IMPOSSIBLE\"\n\n    # Create a string consisting of K distinct characters\n    result = \"\"\n    for _ in range(K):\n        result += chars[0]\n        chars = chars[1:]\n\n    # Check if the length of the string is equal to P\n    if len(result) < P:\n        result += chars[:P - len(result)]\n\n    # Check if the string is a palindrome\n    if result == result[::-1]:\n        return result\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n\n    if N < K or P > N:\n        return \"IMPOSSIBLE\"\n\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    char_count = {char: 0 for char in alphabet}\n    palindrome_count = 0\n\n    for i in range(N):\n        if palindrome_count >= P:\n            break\n\n        for char in char_count:\n            if palindrome_count >= P:\n                break\n\n            if char_count[char] < K:\n                char_count[char] += 1\n                palindrome_count += 1\n\n    if palindrome_count < P:\n        return \"IMPOSSIBLE\"\n\n    result = \"\"\n    for char in char_count:\n        result += char * char_count[char]\n\n    return result\n"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n\n    if K > N // 2:\n        return \"IMPOSSIBLE\"\n\n    # Generate all possible strings\n    all_strings = [\"\".join(p) for p in itertools.product(string.ascii_lowercase, repeat=K)]\n\n    # Filter strings by length\n    strings_by_length = [s for s in all_strings if len(s) == N]\n\n    # Filter strings by having exactly K distinct characters\n    strings_by_distinct_chars = [s for s in strings_by_length if len(set(s)) == K]\n\n    # Filter strings by having a longest palindromic substring of length P\n    for s in strings_by_distinct_chars:\n        if longest_palindromic_substring(s) == P:\n            return s\n\n    return \"IMPOSSIBLE\"\n\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    \n    if N < 2 or K < 1 or P < 1:\n        return \"IMPOSSIBLE\"\n    \n    if P > N:\n        return \"IMPOSSIBLE\"\n    \n    if P == N:\n        return \"\".join([chr(i) for i in range(ord('a'), ord('a') + K)])\n    \n    if K > 9:\n        return \"IMPOSSIBLE\"\n    \n    for i in range(10**(K-1), 10**K):\n        if len(str(i)) == P:\n            return str(i)\n    \n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    \n    if K > P or P > N // 2 + 1 or K > 26:\n        return \"IMPOSSIBLE\"\n    \n    chars = 'abcdefghijklmnopqrstuvwxyz'\n    palindromes = [chars[i] for i in range(K)] + [chars[K - i - 1] for i in range(K)]\n    palindromes = sorted(palindromes, key=lambda x: len(x), reverse=True)\n    \n    for i in range(N - 2 * K + 1):\n        substring = ''.join(palindromes)\n        if len(substring) > i + K and len(substring) <= N - i - K + 1:\n            if len(substring) == P:\n                return substring\n            if len(substring) < P:\n                return \"IMPOSSIBLE\""
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if K == 1 or K > N:\n        return \"IMPOSSIBLE\"\n    if N % (K - 1) != 0:\n        return \"IMPOSSIBLE\"\n    ans = \"\"\n    for i in range(1, K + 1):\n        ans += chr(ord('a') + (i - 1) * (N // (K - 1)) + (i - 1))\n    if len(ans) < N:\n        for i in range(1, K + 1):\n            if i != K:\n                ans += chr(ord('a') + (i - 1) * (N // (K - 1) - 1) + (i - 1))\n    return ans"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    \n    if N < K or P > N:\n        return \"IMPOSSIBLE\"\n    \n    # Create a string of K lowercase Latin alphabet characters\n    chars = \"abcdefghijklmnopqrstuvwxyz\"[:K]\n    \n    # Create a dictionary to store the length of the palindromic substring for each character\n    palindrome_length = {c: 0 for c in chars}\n    \n    # Iterate through all possible substrings of the string\n    for i in range(N):\n        for j in range(i, N):\n            substring = chars[i] + chars[j]\n            if substring == substring[::-1]:\n                palindrome_length[chars[i]] = max(palindrome_length[chars[i]], len(substring))\n                palindrome_length[chars[j]] = max(palindrome_length[chars[j]], len(substring))\n    \n    # Find the longest palindromic substring that satisfies the requirement\n    max_palindrome_length = max(palindrome_length.values())\n    \n    # Check if the longest palindromic substring has length P\n    if max_palindrome_length != P:\n        return \"IMPOSSIBLE\"\n    \n    # Create a dictionary to store the number of occurrences of each character\n    char_count = {c: 0 for c in chars}\n    \n    # Count the occurrences of each character in the string\n    for i in range(N):\n        char_count[chars[i]] += 1\n    \n    # Check if the string has exactly K distinct characters\n    if sum(char_count.values()) != K:\n        return \"IMPOSSIBLE\"\n    \n    # Create the string\n    result = \"\"\n    for i in range(N):\n        for c in chars:\n            if char_count[c] > 0:\n                result += c\n                char_count[c] -= 1\n                break\n    return result"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n\n    if K > N or N % 2 != 0 or P > N:\n        return \"IMPOSSIBLE\"\n\n    for length in range(P, N // 2 + 1):\n        for i in range(N - length + 1):\n            substring = stdin[i:i + length]\n            if substring == substring[::-1]:\n                palindrome = substring\n            else:\n                continue\n\n            for j in range(i - 1, -1, -1):\n                if stdin[j] in palindrome:\n                    palindrome = palindrome.replace(stdin[j], '', 1)\n                if len(set(palindrome)) == K:\n                    return palindrome\n\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    if len(words) == 1:\n        return words[0]\n\n    syllables = [word_to_syllables(word) for word in words]\n\n    if len(syllables) != 3:\n        return stdin\n\n    if syllables[0] != 5 or syllables[2] != 7:\n        return stdin\n\n    for i in range(1, 3):\n        if syllables[i] not in [7, 10]:\n            return stdin\n\n    return format_haiku(words)\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Helper function to count the number of syllables in a word\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUYaeiouy\"\n        syllables = 0\n        last_char_was_vowel = False\n        for char in word:\n            if char.isalpha():\n                if char in vowels:\n                    if not last_char_was_vowel:\n                        syllables += 1\n                    last_char_was_vowel = True\n                else:\n                    last_char_was_vowel = False\n            elif char == \"Q\" and word[word.index(char) + 1] == \"U\":\n                # QU sequence\n                syllables += 1\n                last_char_was_vowel = False\n        if last_char_was_vowel:\n            syllables += 1\n        return syllables\n\n    # Split the input line into words\n    words = stdin.split()\n    # Initialize the haiku variables\n    haiku_lines = [\"\", \"\", \"\"]\n    haiku_syllables = [0, 0, 0]\n    haiku_words = [0, 0, 0]\n\n    # Iterate over the words, adding them to the haiku lines and updating the syllable counts\n    for i, word in enumerate(words):\n        syllables = count_syllables(word)\n        # If the word fits in the current line, add it\n        if haiku_syllables[0] + syllables <= 5 and haiku_syllables[1] + 1 <= 7:\n            if haiku_words[0] == 0:\n                haiku_lines[0] += word + \" \"\n                haiku_syllables[0] += syllables\n                haiku_words[0] += 1\n            elif haiku_words[1] == 0:\n                haiku_lines[1] += word + \" \"\n                haiku_syllables[1] += syllables\n                haiku_words[1] += 1\n            else:\n                haiku_lines[2] += word + \" \"\n                haiku_syllables[2] += syllables\n                haiku_words[2] += 1\n        # If the word doesn't fit in the current line, add it to the next line\n        elif haiku_syllables[1] + syllables <= 7:\n            haiku_lines[1] += word + \" \"\n            haiku_syllables[1] += syllables\n            haiku_words[1] += 1\n        # If the word doesn't fit in the next line, add it to the next one\n        elif haiku_syllables[2] + syllables <= 5:\n            haiku_lines[2] += word + \" \"\n            haiku_syllables[2] += syllables\n            haiku_words[2] += 1\n        # If the word doesn't fit in any of the lines, the haiku is not possible\n        else:\n            return stdin\n\n    # Add any remaining words to the last line\n    for i in range(3):\n        if haiku_words[i] < 3:\n            haiku_lines[i] = haiku_lines[i].strip()\n            for j in range(haiku_words[i], 3):\n                if j < len(words):\n                    haiku_lines[i] += words[j] + \" \"\n                    haiku_syllables[i] += count_syllables(words[j])\n                    haiku_words[i] += 1\n                    if haiku_syllables[i] > 17:\n                        haiku_lines[i] = haiku_lines[i].strip()\n                        break\n            break\n\n    # Format and return the haiku\n    haiku = \"\"\n    for i in range(3):\n        haiku += haiku_lines[i].strip() + \"\\n\"\n    return haiku"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # function to count syllables in a word\n    def count_syllables(word: str) -> int:\n        # initialize syllable count and character index\n        syllables = 0\n        i = 0\n        # loop through each character in the word\n        while i < len(word):\n            # if current character is a vowel, increment the syllable count\n            if word[i].lower() in ['a', 'e', 'i', 'o', 'u', 'y']:\n                # check if previous character is a vowel and 'y' is not at the beginning of the word\n                if syllables > 0 and word[i-1].lower() in ['a', 'e', 'i', 'o', 'u', 'y'] and word[i] == 'y':\n                    # decrement syllable count\n                    syllables -= 1\n                else:\n                    # increment syllable count\n                    syllables += 1\n            # if current character is a consonant followed by a vowel, increment the syllable count\n            elif i < len(word)-1 and word[i].isalpha() and word[i+1].lower() in ['a', 'e', 'i', 'o', 'u', 'y']:\n                # increment syllable count\n                syllables += 1\n            # if current character is 'qu', treat it as one syllable\n            elif i < len(word)-1 and word[i:i+2] == 'qu':\n                # increment syllable count\n                syllables += 1\n            # increment character index\n            i += 1\n        # check if last character is 'y' and the next-to-last character is a consonant\n        if syllables > 0 and word[-1] == 'y' and word[-2].isalpha() and word[-2] != 'e':\n            # decrement syllable count\n            syllables -= 1\n        # return the syllable count\n        return syllables\n    \n    # split the input line into words\n    words = stdin.split(' ')\n    # initialize variables to hold haiku lines\n    line1 = ''\n    line2 = ''\n    line3 = ''\n    # loop through each word and attempt to add it to a haiku line\n    for word in words:\n        # if line1 is empty, add the word to line1\n        if not line1:\n            line1 = word\n        # if line1 has more than $5$ syllables, move the word to line2\n        elif count_syllables(line1) > 5:\n            line2 += ' ' + word\n        # otherwise, add the word to line1\n        else:\n            line1 += ' ' + word\n    # if line2 is empty, move the words from line1 to line3\n    if not line2:\n        line3 = line1\n    # otherwise, add the words from line1 to line2 and move the remaining words to line3\n    else:\n        line2 += ' ' + line1\n        line3 = ' '.join(words[len(line1.split(' '))+len(line2.split(' ')):])\n    # print the haiku lines, left-justified\n    return '{0:<100}'.format(line1) + '{0:<100}'.format(line2) + '{0:<100}'.format(line3)"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        syllables = 0\n        in_vowel = False\n        for char in word:\n            if char.isalpha():\n                if char.upper() in 'AEIOUY':\n                    in_vowel = True\n                else:\n                    if in_vowel:\n                        syllables += 1\n                    in_vowel = False\n            else:\n                if in_vowel:\n                    syllables += 1\n                in_vowel = False\n        if in_vowel:\n            syllables += 1\n        return syllables\n\n    words = stdin.split()\n    if len(words) != 9:\n        return stdin\n\n    haiku = []\n    for i in range(3):\n        line = []\n        for j in range(3):\n            word = words[i * 3 + j]\n            if i == 2 and j == 2:\n                line.append(word)\n            else:\n                syllables = count_syllables(word)\n                if syllables == 5:\n                    if j == 0:\n                        line.append(word)\n                    elif j == 1 and i == 1:\n                        line.append(word)\n                elif syllables == 7:\n                    if j == 1:\n                        line.append(word)\n        haiku.append(' '.join(line))\n\n    return '\\n'.join(haiku)"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.strip().split()\n    if len(words) != 9:\n        return stdin\n\n    def count_syllables(word: str) -> int:\n        syllables = 0\n        i = 0\n        while i < len(word):\n            if word[i].isalpha():\n                if i + 1 < len(word) and word[i + 1] == 'Q':\n                    i += 1\n                elif i + 1 < len(word) and word[i + 1] == 'Y':\n                    i += 1\n                syllables += 1\n            i += 1\n        return syllables\n\n    haiku = [0, 0, 0]\n    for word in words:\n        syllables = count_syllables(word)\n        if syllables == 5:\n            haiku[0] += 1\n        elif syllables == 7:\n            haiku[1] += 1\n        elif syllables == 5:\n            haiku[2] += 1\n        else:\n            return stdin\n\n    if haiku[0] == 1 and haiku[1] == 1 and haiku[2] == 1:\n        return \"\\n\".join([\n            \" \".join(words[0:2]),\n            \" \".join(words[2:4]),\n            \" \".join(words[4:])\n        ])\n    else:\n        return stdin\n\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = {'A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u'}\n        syllables = 0\n        current_syllable = 0\n        for i, char in enumerate(word):\n            if char in vowels:\n                current_syllable += 1\n            elif i > 0 and word[i - 1] not in vowels and char not in vowels:\n                current_syllable += 1\n        return current_syllable\n\n    lines = stdin.split('. ')\n    haiku = []\n    for line in lines:\n        words = line.split()\n        haiku_line = []\n        current_syllable = 0\n        for word in words:\n            if current_syllable == 7:\n                haiku_line.append('')\n                current_syllable = 0\n            current_syllable += count_syllables(word)\n            haiku_line.append(word)\n        haiku.append(haiku_line)\n\n    for i in range(len(haiku)):\n        haiku[i] = ' '.join(haiku[i])\n\n    if len(haiku) == 3:\n        haiku = [line.strip() for line in haiku]\n        return '\\n'.join(haiku)\n    else:\n        return stdin.strip()\n"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        syllables = 0\n        num_consonants = 0\n        for i in range(len(word)):\n            if word[i].isalpha():\n                if i == 0 or not word[i - 1].isalpha():\n                    num_consonants = 0\n                if word[i].lower() in 'aeiouy':\n                    if num_consonants >= 1 and (i == len(word) - 1 or not word[i + 1].isalpha()):\n                        syllables += 1\n                        num_consonants = 0\n                else:\n                    num_consonants += 1\n            else:\n                num_consonants = 0\n        return syllables\n\n    words = stdin.split()\n    haiku = []\n    for i in range(0, len(words), 3):\n        line = words[i:i + 3]\n        if i + 3 <= len(words):\n            haiku.append(line)\n        else:\n            haiku.append(line + [''] * (3 - len(line)))\n\n    for i in range(3):\n        for j in range(3):\n            if haiku[i][j] == '':\n                haiku[i][j] = '  '\n            else:\n                haiku[i][j] += ' '\n                num_syllables = count_syllables(haiku[i][j])\n                if num_syllables != 7 and num_syllables != 5:\n                    return stdin\n\n    for i in range(3):\n        print(haiku[i].lstrip())\n"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        count = 0\n        i = 0\n        while i < len(word):\n            if word[i].isalpha():\n                j = i\n                while j < len(word) and (word[j].isalpha() or word[j] in ['Q', 'U']):\n                    j += 1\n                count += 1\n                i = j\n            else:\n                i += 1\n        if i < len(word) and word[i] == 'Y':\n            count -= 1\n        if count == 0:\n            raise ValueError(\"Word has no syllables\")\n        return count\n\n    def divide_haiku(words: List[str]) -> List[str]:\n        lines = [[]]\n        for word in words:\n            line_length = sum(len(line) for line in lines)\n            if line_length + len(word) + len(lines) > 17:\n                lines.append([])\n            lines[-1].append(word)\n        if len(lines) != 3:\n            raise ValueError(\"Cannot divide into haiku\")\n        return lines\n\n    words = stdin.split()\n    try:\n        for i, word in enumerate(words):\n            count_syllables(word)\n        lines = divide_haiku(words)\n        return \"\\n\".join([\" \".join(line) for line in lines])\n    except ValueError as e:\n        return \" \".join(words)\n"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        count = 0\n        prev_consonant = False\n        for i in range(len(word)):\n            char = word[i]\n            if char.isalpha():\n                if i == len(word) - 1 or not word[i + 1].isalpha():\n                    count += 1\n                if char.islower():\n                    prev_consonant = False\n                else:\n                    if not prev_consonant:\n                        count += 1\n                    prev_consonant = True\n            else:\n                prev_consonant = False\n        if prev_consonant:\n            count += 1\n        return count\n\n    words = stdin.split()\n    haiku = []\n    line_count = 0\n    for i in range(len(words)):\n        if line_count == 0:\n            haiku.append(words[i])\n            line_count += count_syllables(words[i])\n        elif line_count == 5:\n            haiku.append(words[i])\n            line_count += count_syllables(words[i])\n        elif line_count == 12:\n            haiku.append(words[i])\n            line_count += count_syllables(words[i])\n        elif line_count == 19:\n            break\n        else:\n            haiku.append('')\n            line_count = count_syllables(words[i])\n            haiku[-1] += words[i]\n\n    if line_count == 19:\n        haiku = [' '.join(haiku[i:i + 3]) for i in range(0, len(haiku), 3)]\n        haiku = ['\\n'.join(haiku[i:i + 2]) for i in range(0, len(haiku), 3)]\n        return haiku[0] + '\\n' + haiku[1] + '\\n' + haiku[2]\n    else:\n        return stdin\n\n\ninput_line = \"Blue Ridge mountain road. Leaves, glowing in autumn sun, fall in Virginia.\"\nprint(solution(input_line)) "
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split()\n    lines = [line.strip() for line in lines]\n\n    def count_syllables(word: str) -> int:\n        syllables = 0\n        vowels = \"AEIOUY\"\n        last_char = \"\"\n        for i, char in enumerate(word):\n            if char.isalpha() and last_char.isalpha():\n                if char.upper() in vowels and last_char.upper() in vowels:\n                    syllables += 1\n            last_char = char\n        return syllables\n\n    haiku = []\n    for line in lines:\n        words = line.split()\n        syllables = [count_syllables(word) for word in words]\n        if sum(syllables[:-1]) == 5 and sum(syllables[1:]) == 7:\n            haiku.append(\" \".join(words))\n            if len(haiku) == 3:\n                return \"\\n\".join(haiku)\n    return \" \".join(lines)\n"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n', 1)[0])\n    names = stdin.split('\\n', 1)[1].split('\\n')\n\n    # Get the index of the first \"ThoreHusfeldt\" in the list\n    index = next((i for i, name in enumerate(names) if name == \"ThoreHusfeldt\"), -1)\n\n    # If \"ThoreHusfeldt\" is not the first, the problem is solved\n    if index != 0:\n        return \"Thore sucks\"\n\n    # Find the smallest prefix that uniquely determines Thore on the scoreboard\n    for i in range(len(\"ThoreHusfeldt\") - 1, 0, -1):\n        prefix = \"ThoreHusfeldt\"[:i]\n        if prefix not in [name[:i] for name in names[:index]]:\n            return prefix\n\n    # If the problem is still not solved, Thore is the best ThoreH\n    return \"ThoreH is awesome\"\n"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    names = stdin.split(\"\\n\")[1:]\n\n    thore_index = -1\n    thore_h_index = -1\n\n    for i, name in enumerate(names):\n        if name == \"ThoreHusfeldt\":\n            thore_index = i\n            break\n\n    for i, name in enumerate(names):\n        if \"ThoreHusfeld\" in name and \"ThoreHusfeldt\" not in name:\n            thore_h_index = i\n            break\n\n    if thore_index == -1 and thore_h_index == -1:\n        return \"Thore is awesome\"\n    elif thore_h_index > thore_index:\n        return \"ThoreH sucks\"\n    else:\n        for i in range(1, len(names[thore_index]) + 1):\n            prefix = names[thore_index][:i]\n            if all(prefix not in name for name in names[:thore_index]):\n                return prefix\n\n\ndef"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    scoreboard = stdin.splitlines()[1:]\n    \n    for i in range(n - 1):\n        if scoreboard[i] in scoreboard[i+1]:\n            thore_name = scoreboard[i]\n            break\n        \n    if thore_name:\n        prefix = thore_name.split(\"H\")[0] + \"H\"\n    else:\n        prefix = \"ThoreH\"\n        \n    for i in range(n):\n        if prefix in scoreboard[i]:\n            return \"ThoreH\"\n    \n    if thore_name and \"ThoreH\" in scoreboard[n-1]:\n        return \"Thore sucks\"\n    \n    return prefix + \" is awesome\"\n\n\ninput_string = \"\"\"2\nThoreTiemann\nThoreHusfeldt\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, name = stdin.split('\\n')\n    n = int(n)\n\n    def is_prefix(prefix: str, name: str) -> bool:\n        return name.startswith(prefix)\n\n    for i in range(n - 1):\n        if is_prefix(\"ThoreHusfeldt\", name[i]):\n            return \"Thore sucks\"\n\n    return \"Thore is awesome\" if is_prefix(\"ThoreHusfeldt\", name[-1]) else \"ThoreH\"\n\ninput_1 = \"2\\nThoreTiemann\\nThoreHusfeldt\"\ninput_2 = \"2\\nThoreHusfeldt\\nJohanSannemo\"\ninput_3 = \"2\\nThoreHusfeldter\\nThoreHusfeldt\"\n\nprint(solution(input_1))  # Output: ThoreH\nprint(solution(input_2))  # Output: Thore is awesome\nprint(solution(input_3))  # Output: Thore sucks "
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, name = input().split()\n    n = int(n)\n    stdin_list = stdin.split('\\n')\n\n    for i in range(n):\n        if name == stdin_list[i]:\n            best_stdin = stdin_list[:i]\n            best_stdin.append(stdin_list[i])\n            break\n\n    best_stdin.sort(key=lambda x: len(x))\n\n    if name.startswith('ThoreHusfeldt'):\n        if len(best_stdin) > 1:\n            return 'ThoreH sucks'\n        else:\n            return 'Thore is awesome'\n    else:\n        for i in range(len(name), 0, -1):\n            prefix = name[:i]\n            if all(not x.startswith(prefix) for x in best_stdin):\n                return prefix"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    names = stdin[1].split(\"\\n\")\n\n    # Find ThoreHusfeldt's index\n    thore_index = -1\n    for i in range(len(names)):\n        if names[i] == \"ThoreHusfeldt\":\n            thore_index = i\n            break\n\n    # Check if there's another Thore above ThoreHusfeldt\n    for i in range(thore_index):\n        if \"ThoreHusfeldt\" in names[i]:\n            return \"Thore sucks\"\n\n    # Find the smallest prefix that uniquely determines ThoreHusfeldt\n    prefix = \"ThoreH\"\n    while any(prefix in name[:len(prefix)] for i, name in enumerate(names) if i != thore_index):\n        prefix = prefix[:-1]\n\n    # Output the result\n    if prefix == \"ThoreH\":\n        return \"Thore is awesome\"\n    else:\n        return prefix"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    names = stdin.split('\\n')[1:]\n    thoreh = \"ThoreHusfeldt\"\n\n    for i, name in enumerate(names):\n        if name.startswith(thoreh) and len(name) == len(thoreh):\n            if i == 0:\n                return \"Thore is awesome\"\n            else:\n                return \"Thore sucks\"\n\n    for i, name in enumerate(names):\n        if name.startswith(thoreh):\n            for j in range(i+1, n):\n                if names[j].startswith(thoreh):\n                    return thoreh[:-1]\n\n    return thoreh\n"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, stdin = stdin.split(\"\\n\", 1)\n    n = int(n)\n    stdin = stdin.split(\"\\n\")\n\n    for i in range(n):\n        if \"ThoreHusfeldt\" in stdin[i]:\n            thore_index = i\n            break\n\n    best_thore = \"ThoreH\"\n    for i in range(thore_index):\n        if \"ThoreH\" in stdin[i]:\n            best_thore = stdin[i]\n            break\n\n    for i in range(thore_index + 1, n):\n        if \"ThoreH\" in stdin[i]:\n            return \"Thore is awesome\"\n\n    if best_thore == \"ThoreHusfeldt\":\n        return \"Thore is awesome\"\n    else:\n        return best_thore"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    names = stdin.split('\\n')[1:]\n    best_prefix = ''\n    for name in names:\n        if name.startswith('ThoreHusfeldt'):\n            best_prefix = name\n            break\n    \n    for name in names:\n        if name.startswith(best_prefix):\n            continue\n        if 'ThoreHusfeldt' in name:\n            return 'Thore is awesome'\n        if best_prefix.startswith(name):\n            return 'Thore sucks'\n    \n    return best_prefix"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    names = stdin.split('\\n')[1:]\n    thoreh_index = None\n    \n    for i, name in enumerate(names):\n        if name == 'ThoreHusfeldt':\n            thoreh_index = i\n            break\n    \n    if thoreh_index is None:\n        raise ValueError(\"ThoreHusfeldt not found in the input\")\n    \n    if thoreh_index == 0:\n        return \"Thore is awesome\"\n    \n    for i in range(thoreh_index):\n        if 'ThoreHusfeld' in names[i]:\n            return \"ThoreH sucks\"\n    \n    for i in range(thoreh_index, n):\n        if 'ThoreHusfeldt' in names[i]:\n            return \"Thore is awesome\"\n    \n    for i in range(thoreh_index, n):\n        if 'ThoreHusfeld' in names[i]:\n            return names[i][:len(names[i]) - 1] + ' is awesome'\n    \n    raise ValueError(\"No solution found\")\n\n\ndef"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def value(walk: str) -> int:\n        val = 1\n        for step in walk:\n            if step == 'L':\n                val *= 2\n            elif step == 'R':\n                val = val * 2 + 1\n            elif step == 'P':\n                pass\n            else:\n                raise ValueError(\"Invalid step\")\n        return val\n\n    def value_of_set(pattern: str) -> int:\n        def all_walks(pattern: str) -> str:\n            if len(pattern) == 0:\n                return \"\"\n            if pattern[0] == '*':\n                return all_walks(pattern[1:]) + 'L' + all_walks(pattern[1:]) + 'R'\n            if pattern[0] == 'P':\n                return all_walks(pattern[1:]) + 'P'\n            raise ValueError(\"Invalid pattern\")\n\n        walks = all_walks(pattern)\n        return sum(value(walk) for walk in walks)\n\n    return str(value_of_set(stdin))"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_child_label(node_label: int, move: str) -> int:\n        if move == 'L':\n            return node_label * 2\n        elif move == 'R':\n            return (node_label * 2) + 1\n        else:\n            return node_label\n\n    def calculate_set_value(set_string: str) -> int:\n        stack = [1]\n        current_move = 'P'\n        value = 0\n        for char in set_string:\n            if char == '*':\n                if current_move == 'L':\n                    current_move = 'R'\n                elif current_move == 'R':\n                    current_move = 'P'\n                else:\n                    current_move = 'L'\n            elif char == 'L':\n                value += stack[-1]\n                stack.append(get_child_label(stack[-1], current_move))\n                current_move = 'L'\n            elif char == 'R':\n                value += stack[-1]\n                stack.append(get_child_label(stack[-1], current_move))\n                current_move = 'R'\n            elif char == 'P':\n                stack.append(stack[-1])\n                current_move = 'P'\n            else:\n                raise ValueError(f\"Invalid character {char}\")\n        return value\n\n    return str(calculate_set_value(stdin))"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_child(node_label: int, direction: str) -> int:\n        if direction == 'L':\n            return 2 * node_label\n        elif direction == 'R':\n            return 2 * node_label + 1\n\n    def get_node_label(node_index: int) -> int:\n        return (index + 1) // 2\n\n    def get_node_direction(node_index: int, walk_direction: str) -> str:\n        if walk_direction == 'L':\n            return 'L'\n        elif walk_direction == 'R':\n            return 'R'\n        else:\n            return 'P'\n\n    index = -1\n    node_label = 1\n    current_direction = 'R'\n    current_node_index = 0\n    walk = []\n    total_value = 0\n\n    for char in stdin:\n        if char == 'L':\n            current_direction = 'L'\n        elif char == 'R':\n            current_direction = 'R'\n        elif char == 'P':\n            current_direction = 'P'\n        else:\n            index += 1\n            total_value += get_node_label(current_node_index)\n            walk.append(current_direction)\n            current_node_index = get_child(node_label, current_direction)\n            node_label = get_node_label(current_node_index)\n            current_direction = get_node_direction(current_node_index, current_direction)\n\n    return total_value"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_value(node, depth, moves, values):\n        if depth == len(moves):\n            values.append(node.value)\n            return\n        if moves[depth] == '*':\n            calculate_value(node.left, depth+1, moves, values)\n            calculate_value(node.right, depth+1, moves, values)\n        else:\n            new_node = node.left if moves[depth] == 'L' else node.right\n            calculate_value(new_node, depth+1, moves, values)\n\n    def add_node(root, node_label):\n        new_node = Node(node_label)\n        if root is None:\n            return new_node\n        if node_label % 2 == 0:\n            root.left = add_node(root.left, node_label * 2)\n        else:\n            root.right = add_node(root.right, node_label * 2 + 1)\n        return root\n\n    class Node:\n        def __init__(self, value):\n            self.value = value\n            self.left = None\n            self.right = None\n\n    root = Node(1)\n    moves = stdin.split()\n    for move in moves:\n        if move == 'L' or move == 'R':\n            root = add_node(root, 1)\n    values = []\n    calculate_value(root, 0, moves, values)\n    return sum(values)"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def walk_value(walk: str) -> int:\n        if walk == \"L\":\n            return 2 * 1 + 1\n        elif walk == \"R\":\n            return 2 * 1 + 2\n        else:\n            return 1\n\n    def calculate_set_value(set_of_walks: str) -> int:\n        total_value = 0\n        for i in range(len(set_of_walks)):\n            if set_of_walks[i] == \"*\":\n                total_value += walk_value(set_of_walks[i - 1])\n            else:\n                total_value += walk_value(set_of_walks[i])\n        return total_value\n\n    return calculate_set_value(stdin)\n"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Define a function to calculate the value of a single walk\n    def calculate_value(walk: str) -> int:\n        node = 1  # Start from the root\n        for move in walk:\n            if move == 'L':\n                node *= 2\n            elif move == 'R':\n                node = node * 2 + 1\n            else:  # move == 'P'\n                continue\n        return node\n\n    # Parse the input string\n    walks = stdin.split()\n\n    # Calculate the value of each walk and sum them up\n    value = sum(calculate_value(walk) for walk in walks)\n\n    # Return the result\n    return str(value)"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def binary_tree(node: int, start: int, end: int):\n        if start > end:\n            return\n        mid = (start + end) // 2\n        tree[node] = (2 * node * mid, 2 * node * (mid + 1) - 1)\n        binary_tree(2 * node, start, mid - 1)\n        binary_tree(2 * node + 1, mid + 1, end)\n\n    def get_value(node: int, walk: str) -> int:\n        if walk == \"P\":\n            return node\n        if walk == \"L\":\n            return get_value(tree[node][0], \"P\")\n        if walk == \"R\":\n            return get_value(tree[node][1], \"P\")\n\n    tree = {1: (2, 3)}\n    binary_tree(1, 0, 10000)\n    n, m = len(stdin), 0\n    while m < n:\n        if stdin[m] == \"*\":\n            m += 1\n            if m >= n:\n                break\n            stdin[m] = \"P\"\n        m += 1\n    return sum(get_value(1, w) for w in stdin)\n"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def walk(node: int, move: str) -> int:\n        if move == 'L':\n            return 2 * node\n        elif move == 'R':\n            return 2 * node + 1\n        else:\n            return node\n\n    def value(moves: str) -> int:\n        node = 1\n        for move in moves:\n            if move == 'L':\n                node *= 2\n            elif move == 'R':\n                node = 2 * node + 1\n            else:\n                continue\n        return node\n\n    def value_of_walks(walks: str) -> int:\n        return sum(value(walk) for walk in walks.split('*'))\n\n    return value_of_walks(stdin)\n"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_child_label(parent_label: int, move: str) -> int:\n        if move == 'L':\n            return 2 * parent_label\n        elif move == 'R':\n            return 2 * parent_label + 1\n        else:\n            return parent_label\n\n    def get_value(node_label: int, move_pattern: str) -> int:\n        if not move_pattern:\n            return node_label\n        else:\n            child_label = get_child_label(node_label, move_pattern[0])\n            return get_value(child_label, move_pattern[1:])\n\n    def calculate_set_value(stdin: str) -> int:\n        walk_patterns = stdin.split('*')\n        total_value = 0\n        for walk_pattern in walk_patterns:\n            total_value += get_value(1, walk_pattern)\n        return total_value\n\n    return str(calculate_set_value(stdin))"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_value(node: int) -> int:\n        if node == 1:\n            return 1\n        return 2 * get_value(node // 2) + (1 if node % 2 == 1 else 0)\n\n    def get_value_from_walk(walk: str) -> int:\n        if walk == \"\":\n            return 1\n        return get_value_from_walk(walk[1:])\n\n    def get_value_from_set(set_str: str) -> int:\n        if set_str == \"\":\n            return 0\n        value = 0\n        while set_str:\n            if set_str[0] == \"*\":\n                value += get_value_from_set(set_str[1:])\n                break\n            elif set_str[0] == \"L\":\n                value += get_value(2 * get_value(1))\n            elif set_str[0] == \"R\":\n                value += get_value(2 * get_value(1) + 1)\n            elif set_str[0] == \"P\":\n                value += get_value(1)\n            set_str = set_str[1:]\n        return value\n\n    value = get_value_from_set(stdin)\n    return str(value)\n"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, statements = int(stdin.split('\\n')[0]), stdin.split('\\n')[1:]\n    \n    def is_rhyming(X, Y):\n        return X[-min(3, len(X), len(Y)):].lower() == Y[-min(3, len(X), len(Y)):].lower()\n    \n    words = set()\n    for statement in statements:\n        X, Y = statement.split()\n        words.add(X.lower())\n        words.add(Y.lower())\n    \n    def is_consistent(X, Y):\n        if X.lower() == Y.lower():\n            return True\n        if X.lower() in words and Y.lower() in words:\n            return is_rhyming(X, Y)\n        return False\n    \n    for i in range(N):\n        X, Y = statements[i].split()\n        if is_consistent(X, Y):\n            continue\n        else:\n            return \"wait what?\"\n    \n    return \"yes\"\n"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    statements = input_list[1:]\n\n    def is_rhyming(X, Y):\n        return X[-min(3, len(X), len(Y)):].lower() == Y[-min(3, len(X), len(Y)):].lower()\n\n    def is_same(X, Y):\n        return X.lower() == Y.lower()\n\n    def is_consistent(X, Y):\n        if X == Y:\n            return True\n        if is_rhyming(X, Y):\n            return True\n        return False\n\n    def check_consistency(statements):\n        seen = set()\n        for statement in statements:\n            X, Y = statement.split(\" is \")\n            if is_same(X, Y):\n                seen.add(X)\n            elif X in seen and not is_consistent(X, Y):\n                return False\n            elif Y in seen and not is_consistent(Y, X):\n                return False\n        return True\n\n    return \"yes\" if check_consistency(statements) else \"wait what?\"\n"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def rhymes(X, Y):\n        return X[-min(3, len(X), len(Y)):].lower() == Y[-min(3, len(X), len(Y)):].lower()\n\n    def marten_is_same(X, Y):\n        for i in range(1, len(X) + 1):\n            for j in range(i, len(Y) + 1):\n                if X[:i] == Y[:j] and rhymes(X[-i:], Y[-j:]):\n                    return True\n        return False\n\n    N = int(stdin[0])\n    statements = stdin[1:].split('\\n')\n    words = set()\n\n    for statement in statements:\n        X, Y = statement.split()\n        words.add(X)\n        words.add(Y)\n\n    for i in range(len(statements)):\n        statement = statements[i].split()\n        X, Y = statement[0], statement[1]\n        if Y == \"not\":\n            Y = \" \".join(X, Y, statement[2])\n        if not rhymes(X, Y) and not marten_is_same(X, Y):\n            return \"wait what?\"\n\n    return \"yes\""
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    words = stdin.split('\\n')[1:]\n    \n    rhyming_words = {}\n    for i in range(len(words)):\n        if 'not' in words[i]:\n            words[i] = words[i].replace('not', '')\n        x, y = words[i].split(' is ')\n        x, y = x.strip(), y.strip()\n        for char in x:\n            if char not in 'abcdefghijklmnopqrstuvwxyz':\n                return 'wait what?'\n        for char in y:\n            if char not in 'abcdefghijklmnopqrstuvwxyz':\n                return 'wait what?'\n        if x not in rhyming_words:\n            rhyming_words[x] = y\n        elif rhyming_words[x] != y:\n            return 'wait what?'\n        if y not in rhyming_words:\n            rhyming_words[y] = x\n        elif rhyming_words[y] != x:\n            return 'wait what?'\n    \n    return 'yes'"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    statements = stdin.split('\\n')[1:]\n    words = set()\n    for statement in statements:\n        words.add(statement.split()[0])\n        words.add(statement.split()[2])\n    words = sorted(list(words))\n    for i in range(len(words)):\n        if len(words[i]) > 20:\n            return \"wait what?\"\n    if M\u00e5rten(words[0], words[1]) or M\u00e5rten(words[1], words[0]):\n        return \"yes\"\n    for i in range(2, len(words)):\n        if M\u00e5rten(words[i - 1], words[i]) or M\u00e5rten(words[i], words[i - 1]):\n            return \"yes\"\n    return \"wait what?\"\n\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    words = {}\n    for i in range(n):\n        statement = stdin.split(\"\\n\")[i+1]\n        word1, word2 = statement.split()\n        if word1 in words:\n            if words[word1] != word2:\n                return \"wait what?\"\n        if word2 in words:\n            if words[word2] != word1:\n                return \"wait what?\"\n        words[word1] = word2\n        words[word2] = word1\n    return \"yes\""
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def rhyme(word1: str, word2: str) -> bool:\n        return word1[-min(3, len(word1), len(word2)):] == word2[-min(3, len(word1), len(word2)):]\n\n    def is_consistent(statements: list) -> bool:\n        def check_implications(statement1: str, statement2: str) -> bool:\n            words1 = statement1.split()\n            words2 = statement2.split()\n\n            if words1[1] == 'not' and words2[1] == 'not' and words1[0] == words2[0]:\n                return True\n\n            if words1[1] != 'not' and words2[1] == 'not' and words1[0] == words2[0]:\n                return False\n\n            if words1[1] != 'not' and words2[1] != 'not' and words1[0] != words2[0]:\n                return True\n\n            if words1[1] != 'not' and words2[1] == 'not' and words1[0] != words2[0]:\n                return False\n\n            return rhyme(words1[0], words2[0])\n\n        for i in range(len(statements)):\n            for j in range(i+1, len(statements)):\n                if not check_implications(statements[i], statements[j]):\n                    return False\n        return True\n\n    input_list = stdin.split('\\n')\n    statements = input_list[1:]\n    if is_consistent(statements):\n        return \"yes\"\n    else:\n        return \"wait what?\""
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    statements = stdin.split('\\n')[1:]\n\n    def is_rhyming(word1, word2):\n        min_len = min(len(word1), len(word2))\n        return word1[-min_len:] == word2[-min_len:]\n\n    def is_consistent(word1, word2, statements):\n        for statement in statements:\n            if word1 in statement or word2 in statement:\n                return True\n        return False\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if is_rhyming(statements[i].split()[0], statements[j].split()[0]) and not is_consistent(statements[i].split()[0], statements[j].split()[0], statements[:i] + statements[i+1:j] + statements[j+1:]):\n                return \"wait what?\"\n\n    return \"yes\""
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    statements = stdin.splitlines()[1:]\n\n    words = set()\n    rhymes = set()\n\n    for statement in statements:\n        x, y = statement.split()\n        words.add(x)\n        words.add(y)\n        if x[:-3] == y[:-3]:\n            rhymes.add((x, y))\n\n    for word in words:\n        for i in range(1, min(3, len(word), 20) + 1):\n            if word[:i] in words:\n                if word[:i] != word:\n                    rhymes.add((word, word[:i]))\n                    rhymes.add((word[:i], word))\n\n    if len(rhymes) == len(words):\n        return \"yes\"\n    else:\n        return \"wait what?\""
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    num_statements = int(input_data[0])\n    words = {}\n\n    for i in range(1, num_statements + 1):\n        statement = input_data[i].split()\n        x, y = statement[0], statement[2]\n        if x not in words:\n            words[x] = set()\n        if y not in words:\n            words[y] = set()\n\n        if statement[1] == 'is':\n            words[x].add(y)\n            words[y].add(x)\n        else:\n            words[x].discard(y)\n            words[y].discard(x)\n\n    for x in words:\n        for y in words:\n            if x != y and len(set(words[x]) & set(words[y])) != 0:\n                return 'wait what?'\n\n    return 'yes'"
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    sequence_list = input_data[1:]\n\n    def count_sequences(seq_list, sequence):\n        count = 0\n        for seq in seq_list:\n            if seq == sequence:\n                count += 1\n        return count\n\n    if n == 1:\n        if sequence_list[0] == \"A\" or sequence_list[0] == \"C\" or sequence_list[0] == \"M\":\n            return \"impossible\"\n        else:\n            return \"1 1\" + \"\\n\" + sequence_list[0]\n    else:\n        if count_sequences(sequence_list, \"A\") == n:\n            return \"1 0\" + \"\\n\" + \"A\"\n        elif count_sequences(sequence_list, \"C\") == n:\n            return \"1 0\" + \"\\n\" + \"C\"\n        elif count_sequences(sequence_list, \"M\") == n:\n            return \"1 0\" + \"\\n\" + \"M\"\n        else:\n            return \"impossible\"\n"
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    fossil_sequences = input_lines[1:]\n\n    # Create a set of unique sequences\n    unique_sequences = set(fossil_sequences)\n\n    # Find the longest common suffix and prefix for all sequences\n    common_suffix = ''\n    common_prefix = ''\n    for i in range(1, len(fossil_sequences)):\n        common_suffix = find_common_suffix(fossil_sequences[i], common_suffix)\n        common_prefix = find_common_prefix(fossil_sequences[i], common_prefix)\n\n    # Check if any sequence is a suffix of the current species sequence\n    current_species_sequence = input_lines[1]\n    if common_suffix and common_suffix in unique_sequences:\n        # If it is, remove it from the unique sequences and continue\n        unique_sequences.remove(common_suffix)\n    elif not common_suffix:\n        # If there is no common suffix, try removing the common prefix\n        common_prefix_length = len(common_prefix)\n        unique_sequences = {sequence[common_prefix_length:] for sequence in unique_sequences}\n        unique_sequences.add(current_species_sequence[common_prefix_length:])\n\n    # Count the number of sequences for each path\n    path1_sequences = 0\n    path2_sequences = 0\n    for sequence in unique_sequences:\n        if sequence.startswith(common_prefix):\n            path1_sequences += 1\n        else:\n            path2_sequences += 1\n\n    # If there are no sequences for either path, return impossible\n    if not path1_sequences and not path2_sequences:\n        return \"impossible\"\n\n    # Create example for each path\n    example1 = \"\"\n    example2 = \"\"\n    if path1_sequences > 0:\n        example1 = \"\\n\".join(sorted(unique_sequences)[:path1_sequences])\n    if path2_sequences > 0:\n        example2 = \"\\n\".join(sorted(unique_sequences)[path1_sequences:])\n\n    return f\"{path1_sequences} {path2_sequences}\\n{example1}\\n{example2}\"\n\ndef"
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    current_species = input_data[1]\n    fossil_sequences = input_data[2:]\n\n    # Create a dictionary to store the frequency of each nucleotide sequence\n    sequence_counts = {}\n    for sequence in fossil_sequences:\n        if sequence not in sequence_counts:\n            sequence_counts[sequence] = 1\n        else:\n            sequence_counts[sequence] += 1\n\n    # Check if the current species is present in the sequence counts dictionary\n    if current_species in sequence_counts:\n        current_species_count = sequence_counts[current_species]\n        del sequence_counts[current_species]\n    else:\n        return \"impossible\"\n\n    # Check if there are enough sequences to form two evolutionary paths\n    if n < 2 or current_species_count == 0:\n        return \"impossible\"\n\n    # Calculate the number of sequences in each path\n    path1_count = n - 1\n    path2_count = current_species_count\n\n    # Find the sequences in the first path\n    path1_sequences = []\n    for sequence, count in sequence_counts.items():\n        if count <= path1_count:\n            path1_sequences.append(sequence)\n            path1_count -= count\n        if path1_count == 0:\n            break\n\n    # Find the sequences in the second path\n    path2_sequences = []\n    for sequence, count in sequence_counts.items():\n        if count <= path2_count:\n            path2_sequences.append(sequence)\n            path2_count -= count\n        if path2_count == 0:\n            break\n\n    # Output the example\n    output = f\"{len(path1_sequences)} {len(path2_sequences)}\\n\"\n    output += '\\n'.join(path1_sequences) + '\\n'\n    output += '\\n'.join(path2_sequences)\n    return output "
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n, current_species, *fossil_sequences = stdin.split('\\n')\n    n = int(n)\n    fossil_sequences = [seq.strip() for seq in fossil_sequences]\n    \n    # Check if it is impossible\n    if len(set(fossil_sequences)) != n:\n        return \"impossible\"\n    \n    # Initialize\n    fossil_sequences.sort(key=len)\n    paths = [set() for _ in range(2)]\n    fossil_sequences_dict = {seq: i for i, seq in enumerate(fossil_sequences)}\n    \n    # Find first common sequence\n    first_common_seq = ''\n    for seq in fossil_sequences:\n        if all(seq in fossil_sequences_dict for seq in seq):\n            first_common_seq = seq\n            break\n    if not first_common_seq:\n        return \"impossible\"\n    \n    # Assign sequences to paths\n    for seq in fossil_sequences:\n        if seq == first_common_seq:\n            paths[0].add(seq)\n        else:\n            paths[1].add(seq)\n    \n    # Output example\n    s1 = len(paths[0])\n    s2 = len(paths[1])\n    return f\"{s1} {s2}\\n\" + '\\n'.join(paths[0]) + '\\n' + '\\n'.join(paths[1])"
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, current_species = map(int, stdin.splitlines()[0].split())\n    current_species = stdin.splitlines()[1]\n    sequences = stdin.splitlines()[2:]\n\n    if n == 1:\n        if sequences[0] == current_species:\n            return \"1 1\\n\" + current_species\n        else:\n            return \"impossible\"\n\n    def count_path(sequence: str, current_species: str) -> int:\n        count = 0\n        for i in range(len(sequence)):\n            if sequence[i] != current_species[i]:\n                count += 1\n        return count\n\n    sequence_counts = {}\n    for sequence in sequences:\n        if sequence in sequence_counts:\n            sequence_counts[sequence] += 1\n        else:\n            sequence_counts[sequence] = 1\n\n    # Find sequences that have a different count of mutations compared to the current species\n    different_count_sequences = [sequence for sequence, count in sequence_counts.items() if count != count_path(sequence, current_species)]\n\n    # If there are no sequences with a different count of mutations, return impossible\n    if len(different_count_sequences) == 0:\n        return \"impossible\"\n\n    # Determine which paths have sequences attributed to them\n    path_counts = {}\n    for sequence in different_count_sequences:\n        path = count_path(sequence, current_species)\n        if path in path_counts:\n            path_counts[path] += 1\n        else:\n            path_counts[path] = 1\n\n    # Display the example\n    return f\"{max(path_counts.values())} {max(path_counts.values())}\" + \"\\n\" + \\\n           \"\\n\".join(sorted(different_count_sequences, key=lambda x: sequence_counts[x]))"
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    current_species = input_list[1]\n    fossil_sequences = input_list[2:]\n\n    if n == 1:\n        if fossil_sequences[0] == current_species:\n            return \"1 1\\n\" + fossil_sequences[0]\n        else:\n            return \"impossible\"\n\n    seq_dict = {}\n    for seq in fossil_sequences:\n        if seq in seq_dict:\n            seq_dict[seq] += 1\n        else:\n            seq_dict[seq] = 1\n\n    sorted_seq_dict = sorted(seq_dict.items(), key=lambda x: x[1])\n    first_path = []\n    second_path = []\n    for seq, count in sorted_seq_dict:\n        if seq == current_species:\n            first_path.append(seq)\n        else:\n            second_path.append(seq)\n\n    if not first_path:\n        return \"impossible\"\n\n    return f\"{len(first_path)} {len(second_path)}\\n\" + \"\\n\".join(first_path) + \"\\n\" + \"\\n\".join(second_path)\n\n\ndef"
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n = int(stdin.split('\\n')[0])\n    current_species = stdin.split('\\n')[1]\n    fossil_sequences = stdin.split('\\n')[2:]\n\n    # process input\n    # create a set to keep track of the sequences in the fossil record\n    fossil_set = set()\n    # create two lists to keep track of the sequences in each path\n    path1 = []\n    path2 = []\n    # iterate over the sequences in the fossil record\n    for sequence in fossil_sequences:\n        # if the sequence is not already in the set and is not the current species, add it to the set and one of the paths\n        if sequence not in fossil_set and sequence != current_species:\n            fossil_set.add(sequence)\n            # if the sequence is shorter than the current species, add it to path 1, otherwise, add it to path 2\n            if len(sequence) < len(current_species):\n                path1.append(sequence)\n            else:\n                path2.append(sequence)\n\n    # check if it is possible for all the fossil material to come from two evolutionary paths\n    if len(path1) + len(path2) != len(fossil_set):\n        return \"impossible\"\n\n    # display an example of how the nucleotide sequences in the fossil record participate in two evolutionary paths\n    return f\"{len(path1)} {len(path2)}\\n\" + \"\\n\".join(path1 + path2) "
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_line(stdin: str) -> tuple[str, str]:\n        line = stdin.split('\\n')[0]\n        stdin = stdin.split('\\n', 1)[1]\n        return line, stdin\n\n    n, live_seq = get_next_line(stdin)\n    n = int(n)\n    fossil_seqs = []\n    for _ in range(n):\n        seq, stdin = get_next_line(stdin)\n        fossil_seqs.append(seq)\n\n    live_seq_count = 0\n    for seq in fossil_seqs:\n        if seq == live_seq:\n            live_seq_count += 1\n\n    if live_seq_count == 0:\n        return \"impossible\"\n\n    first_path = []\n    second_path = []\n\n    for i, seq in enumerate(fossil_seqs):\n        if seq == live_seq:\n            continue\n        if len(first_path) < len(second_path):\n            first_path.append(seq)\n        else:\n            second_path.append(seq)\n\n    if len(first_path) == 0 or len(second_path) == 0:\n        return \"impossible\"\n\n    return f\"{len(first_path)} {len(second_path)}\" + \"\\n\" + \"\\n\".join(first_path) + \"\\n\" + \"\\n\".join(second_path) + \"\\n\""
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    curr_species = input_list[1]\n    fossil_species = input_list[2:]\n    species_count = {}\n    for species in fossil_species:\n        if species not in species_count:\n            species_count[species] = 1\n        else:\n            species_count[species] += 1\n    min_freq = min(species_count.values())\n    max_freq = max(species_count.values())\n    if min_freq == 1 and max_freq == n:\n        return \"impossible\"\n    elif min_freq == 1:\n        return \"1 \" + str(n)\n    else:\n        first_path = []\n        second_path = []\n        for species, freq in species_count.items():\n            if freq == min_freq:\n                first_path.append(species)\n            elif freq == max_freq:\n                second_path.append(species)\n        return f\"{len(first_path)} {len(second_path)}\\n\" + '\\n'.join(first_path) + '\\n' + '\\n'.join(second_path) "
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    current_species = input_lines[1]\n    fossil_sequences = input_lines[2:]\n\n    def find_sequence(sequences, target):\n        for sequence in sequences:\n            if sequence == target:\n                return True\n        return False\n\n    def find_common_sequence(sequences):\n        common_sequence = ''\n        for i in range(len(sequences[0])):\n            base = sequences[0][i]\n            for sequence in sequences:\n                if sequence[i] != base:\n                    return None\n            common_sequence += base\n        return common_sequence\n\n    def find_fossil_sequences(common_sequence):\n        fossil_sequences_1 = []\n        fossil_sequences_2 = []\n        for sequence in fossil_sequences:\n            if find_sequence(fossil_sequences_1, sequence):\n                fossil_sequences_2.append(sequence)\n            else:\n                fossil_sequences_1.append(sequence)\n        return fossil_sequences_1, fossil_sequences_2\n\n    common_sequence = find_common_sequence([current_species] + fossil_sequences)\n    if common_sequence is None:\n        return \"impossible\"\n\n    fossil_sequences_1, fossil_sequences_2 = find_fossil_sequences(common_sequence)\n\n    print(len(fossil_sequences_1), len(fossil_sequences_2))\n    for sequence in fossil_sequences_1:\n        print(sequence)\n    for sequence in fossil_sequences_2:\n        print(sequence) "
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, input().split())\n    tricks = []\n    for _ in range(m):\n        t, p, d = map(float, input().split())\n        tricks.append((t, p, d))\n    tricks.sort()\n\n    expected_time = 0\n    current_time = 0\n    failed_tricks = 0\n    for trick in tricks:\n        t, p, d = trick\n        if current_time < t:\n            current_time = t\n        time_to_recover = d * failed_tricks\n        expected_time += (t - current_time + time_to_recover) * p\n        current_time = t + d\n        failed_tricks += 1\n\n    expected_time += (r - current_time) * (1 - sum(trick[1] for trick in tricks))\n\n    return f\"{expected_time:.6f}\""
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = sorted(list(map(int, stdin.split()[3:6:2]) + map(float, stdin.split()[4:7:2]) + [1000] * (m - len(range(m)))))\n    \n    def prob(t, p, d):\n        return p * (1 - p ** t) / (1 - p ** (t + 1)) + d * (1 - p ** t) / (1 - p ** (t + 1))\n    \n    expected_time = sum([prob(tricks[i] - 1, tricks[i + 1], tricks[i + 2]) for i in range(0, m, 3)]) + r - n\n    \n    return f\"{expected_time:.6f}\""
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_expected_time(n: int, r: int, m: int, tricks: List[Tuple[int, float, int]]) -> float:\n        def probability_of_success(p: float, attempts: int) -> float:\n            return p ** attempts\n\n        def expected_time_to_set_record(n: int, r: int, tricks: List[Tuple[int, float, int]]) -> float:\n            expected_time = n\n            for trick in tricks:\n                t, p, d = trick\n                expected_time += d * (1 - probability_of_success(p, (r - t) // d))\n            return expected_time\n\n        def optimal_reset_strategy(n: int, r: int, tricks: List[Tuple[int, float, int]]) -> float:\n            expected_time = n\n            for trick in tricks:\n                t, p, d = trick\n                expected_time += d * (1 - probability_of_success(p, (r - t) // d))\n                expected_time = max(expected_time, n)\n                expected_time = expected_time_to_set_record(n, r, tricks)\n            return expected_time\n\n        return round(optimal_reset_strategy(n, r, tricks), 6)\n\n    input_data = stdin.split(\"\\n\")\n    n, r, m = map(int, input_data[0].split())\n    tricks = [(int(x[0]), float(x[1]), int(x[2])) for x in [line.split() for line in input_data[1:]]]\n    tricks.sort(key=lambda x: x[0])\n\n    return str(calculate_expected_time(n, r, m, tricks))\n"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = sorted([list(map(int, stdin.split()[3:][i:i+3])) for i in range(0, len(stdin.split()[3:]), 3)], key=lambda x: x[0])\n    \n    dp = [0] * (n+1)\n    for trick in tricks:\n        t, p, d = trick\n        for i in range(t, n+1):\n            dp[i] += p * dp[i-t] + (1 - p) * dp[i-t-1] + d * (1 - p)\n    \n    return round(dp[n], 6)"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = []\n    for _ in range(m):\n        t, p, d = map(float, stdin.split()[3:6])\n        tricks.append((t, p, d))\n\n    # Sort tricks by time\n    tricks.sort(key=lambda x: x[0])\n\n    # Calculate probability of success for each trick\n    probabilities = []\n    for i in range(m):\n        p = tricks[i][1]\n        probabilities.append(p)\n        for j in range(i + 1, m):\n            if tricks[j][0] < tricks[i][0]:\n                p *= (1 - tricks[j][1])\n        probabilities[i] = p\n\n    # Calculate expected time\n    expected_time = 0\n    for i in range(m):\n        t, p, d = tricks[i]\n        expected_time += t + (r - t - expected_time) / probabilities[i] * (1 - p)\n\n    # Calculate reset time\n    reset_time = sum([t[2] for t in tricks])\n\n    # Calculate total time\n    total_time = r if n <= r else n + reset_time\n\n    # Calculate optimal strategy\n    optimal_strategy = max(int(total_time * 10) // 10, 1)\n\n    # Calculate expected time with optimal strategy\n    expected_time_optimal = expected_time + optimal_strategy * reset_time\n\n    return f\"{expected_time_optimal:.10f}\""
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = sorted(list(map(int, stdin.split()[3:])), key=lambda x: x[0])\n    d = {}\n    prob = 1\n    expected_time = 0\n    for trick in tricks:\n        t, p, d = trick\n        prob *= 1 - p\n        if prob < 1e-6:\n            break\n        d = max(d, t)\n        expected_time += (d - t + 1) * prob\n    if prob < 1e-6:\n        expected_time = float('inf')\n    else:\n        expected_time += (n - d) * prob\n    return str(expected_time)\n\n\ndef"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> tuple:\n        n, r, m = map(int, input_str.split())\n        tricks = []\n        for _ in range(m):\n            trick_data = input_str.split()\n            t, p, d = map(float, trick_data)\n            tricks.append((t, p, d))\n        tricks.sort()\n        return n, r, m, tricks\n\n    def find_best_reset_time(n: int, tricks: list) -> float:\n        total_time = 0\n        fail_time = 0\n        success_count = 0\n\n        for t, p, d in tricks:\n            total_time += t\n            fail_time += t + d\n            success_count += 1\n            if success_count == 2:\n                break\n            if fail_time >= n:\n                success_count -= 1\n                total_time -= t\n                fail_time -= d\n            else:\n                success_count = 1\n                fail_time = t + d\n\n        return total_time\n\n    n, r, m, tricks = parse_input(stdin)\n    best_reset_time = find_best_reset_time(n, tricks)\n    return str(best_reset_time)\n\ndef"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def probability(x, p):\n        return 1 - (1 - p) ** x\n\n    def expected_time(p, d, t, n):\n        return t + d + expected_time(p, d, t + d, n - t) if t < n else 0\n\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = [list(map(int, stdin.split()[i:i+3])) for i in range(3, 3 + m*3, 3)]\n\n    tricks.sort(key=lambda x: x[0])\n    times = [t for t, _, _ in tricks]\n\n    expected_reset = sum(expected_time(probability(1, p), d, t, n) for t, p, d in tricks)\n    expected_play = sum(expected_time(probability(1, p), d, t, n) for t, p, d in tricks) * (r - n) / 5000\n\n    return f\"{expected_reset + expected_play:.6f}\""
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = sorted([[int(x) for x in stdin.split()[3+i*3:3+i*3+3]] for i in range(m)], key=lambda x: x[0])\n    if m == 0:\n        return str(r)\n\n    def calc_expected_time(n, r, tricks):\n        if not tricks:\n            return r\n\n        trick, p, d = tricks.pop(0)\n        expected_time = (1 - p) * calc_expected_time(n, r, tricks) + p * (trick + d)\n        expected_time_no_trick = calc_expected_time(n, r, tricks)\n\n        return min(expected_time, expected_time_no_trick)\n\n    expected_time = calc_expected_time(n, r, tricks)\n    return f\"{expected_time:.6f}\"\n\ndef"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, input().split())\n    tricks = []\n    for _ in range(m):\n        t, p, d = map(float, input().split())\n        tricks.append((t, p, d))\n\n    total_time = 0\n    tricks.sort(key=lambda x: x[0])\n    i = 0\n    while i < m and tricks[i][0] < n:\n        t, p, d = tricks[i]\n        total_time += t\n        i += 1\n        while i < m and tricks[i][0] == t:\n            i += 1\n\n    expected_time = total_time\n    while i < m:\n        t, p, d = tricks[i]\n        time_loss = d * (1 - p)\n        expected_time += time_loss\n        i += 1\n\n    while i < m:\n        t, p, d = tricks[i]\n        expected_time += t + time_loss\n        i += 1\n\n    print(round(expected_time, 6))\n"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    sequences = []\n    for i in range(1, n):\n        for j in range(1, n):\n            if j % n != i and j != n:\n                sequences.append(j)\n    sequences = sorted(sequences)\n    return sequences[k-1]\n\n\ninput_stdin = \"4 3\\n\"\noutput_expected = \"2 1 2\"\noutput_actual = solution(input_stdin)"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    if n == 2:\n        return \"1\"\n    if n == 3:\n        return \"2 1 2\"\n    if k == 1:\n        return \"1\"\n    if k == 2:\n        return \"2\"\n\n    result = []\n    current_sequence = [1] * (n-1)\n    current_sequence[0] = n\n    k -= 1\n    for i in range(n-1):\n        current_sequence[i] = i+1\n\n    while k > 0:\n        current_sequence.sort(reverse=True)\n        if k % 2 == 0:\n            current_sequence.pop()\n        else:\n            current_sequence.pop(0)\n        k //= 2\n\n    for num in current_sequence:\n        result.append(str(num))\n\n    return \" \".join(result)\n\ndef"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 1:\n        return str(n - 1)\n\n    if n % 2 == 0:\n        start = (k - 1) // (n // 2) * (n // 2) + 1\n        end = start + (n // 2) - 1\n    else:\n        start = (k - 1) // ((n + 1) // 2) * ((n + 1) // 2) + 1\n        end = start + (n + 1) // 2 - 1\n\n    sequence = [n - 1] * (n - 1)\n    for i in range(start, end + 1):\n        sequence[i % n - 1] = i // n\n\n    return ' '.join(map(str, sequence))\n\ndef"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    k = int(input_list[1])\n    min_petals = 1\n    max_petals = n-1\n    sequence = []\n    \n    for i in range(n-1):\n        if k <= (max_petals - min_petals + 1):\n            sequence.append(min_petals)\n            k -= 1\n            min_petals += 1\n        else:\n            sequence.append(max_petals)\n            max_petals -= 1\n    \n    return \" \".join(map(str, sequence))"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequences = [\n        [1] * (n - 1) + [n] if i == 0 else\n        [n] * (i + 1) + [i + 1] * (n - i - 2) + [n]\n        for i in range(n - 2, -1, -1)]\n\n    return \" \".join(map(str, sequences[k - 1]))\n"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = []\n    if n % 2 == 0:\n        for i in range(1, n, 2):\n            result.append(i)\n            result.append(n - i)\n    else:\n        for i in range(1, n, 2):\n            result.append(i)\n            result.append(n - i - 1)\n        result.append(n - 1)\n\n    result = sorted(result)\n    return \" \".join(map(str, result[k - 1]))\n"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequences = [str(i) for i in range(1, n)]\n    if n > 2:\n        sequences += [str(i) + str(i+1) for i in range(1, n-1)]\n        for i in range(1, n-1):\n            sequences += [str(i) + str(i+j) for j in range(2, n-i+1)]\n        sequences = [seq for seq in sequences if len(set(seq)) == n-1]\n        sequences.sort()\n    return sequences[k-1]\n\nn, k = map(int, input().split())\nprint(solution(str(n) + \" \" + str(k))) "
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    # Initialize the list of valid sequences\n    sequences = []\n    for a in range(1, n):\n        for b in range(a + 1, n):\n            valid = True\n            for i in range(b - a):\n                if (b - a) % i == 0 and (b - a) // i <= n - 1:\n                    valid = False\n            if valid:\n                sequences.append([a, b])\n\n    # Find the kth sequence\n    kth_sequence = sequences[k - 1]\n\n    # Convert the sequence to a string\n    sequence_str = ' '.join(map(str, kth_sequence))\n\n    return sequence_str\n\ndef"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    valid_sequences = []\n    for i in range(1, n):\n        for j in range(i, n - 1):\n            valid_sequences.append(f\"{j} {' '.join(str(j - i) for i in range(j))}\")\n\n    return valid_sequences[k - 1]\n\n\ndef"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    k = input_data[1]\n\n    def generate_sequences(n):\n        def backtrack(start, current):\n            if start == n - 1:\n                sequences.append(current + [n - 1])\n                return\n            for i in range(1, n):\n                if i % n != 0:\n                    backtrack(start + 1, current + [i])\n\n        sequences = []\n        backtrack(0, [])\n        return sequences\n\n    def is_valid_sequence(sequence):\n        for i in range(n - 1):\n            if sum(sequence[i:i + n]) % n == 0:\n                return False\n        return True\n\n    valid_sequences = [seq for seq in generate_sequences(n) if is_valid_sequence(seq)]\n    return valid_sequences[k - 1]\n"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited, graph, current_path):\n        visited[start] = True\n        current_path.append(start)\n\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, graph, current_path)\n\n    def dfs_blocked(start, visited, graph, current_path, blocked_roads, blocked_nodes, blocked_edges):\n        visited[start] = True\n        current_path.append(start)\n        blocked_nodes.add(start)\n\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if (start, neighbor) not in blocked_edges and (neighbor, start) not in blocked_edges:\n                    dfs_blocked(neighbor, visited, graph, current_path, blocked_roads, blocked_nodes, blocked_edges)\n                else:\n                    blocked_roads.add((start, neighbor))\n                    blocked_edges.add((start, neighbor))\n\n    def find_min_length(graph, blocked_roads):\n        min_length = float('inf')\n        for _, road in enumerate(graph):\n            visited = [False] * len(graph)\n            current_path = []\n            dfs(road[0], visited, graph, current_path)\n            if road[0] in current_path:\n                current_path.remove(road[0])\n            if len(current_path) < min_length:\n                min_length = len(current_path)\n\n        return min_length + len(blocked_roads)\n\n    def blocked_road_re_route(graph, blocked_roads, blocked_nodes):\n        blocked_edges = set()\n        for road in blocked_roads:\n            blocked_edges.add((road[0], road[1]))\n            blocked_edges.add((road[1], road[0]))\n\n        for node in blocked_nodes:\n            visited = [False] * len(graph)\n            current_path = []\n            dfs_blocked(node, visited, graph, current_path, blocked_roads, blocked_nodes, blocked_edges)\n\n        return current_path\n\n    n, m = map(int, stdin.split()[0:2])\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        u, v = map(int, stdin.split()[2 * i + 1:2 * i + 3])\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    min_length = find_min_length(graph, set())\n    min_length = max(min_length, 1)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                for path in blocked_road_re_route(graph, {(i, j)}, {i, j}):\n                    new_length = len(path) + len(set((i, j) for i, j in blocked_road_re_route(graph, {(i, j)}, set())))\n                    min_length = min(min_length, new_length)\n\n    return min_length\n\ndef"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_path_length(adj: list, blocked_road: tuple) -> int:\n        n = len(adj)\n        visited = [False] * n\n        visited[0] = True\n        queue = [(0, 0)]\n\n        while queue:\n            dist, node = queue.pop(0)\n            for neighbor, edge_len in adj[node]:\n                if not visited[neighbor]:\n                    if (node, neighbor) == blocked_road:\n                        return dist + 1\n                    visited[neighbor] = True\n                    queue.append((dist + edge_len, neighbor))\n        return 0\n\n    def find_min_path_length(adj: list) -> int:\n        blocked_road = (1, 2)\n        max_length = find_path_length(adj, blocked_road)\n        for u, v in adj[1]:\n            if u != blocked_road[0] and v != blocked_road[1]:\n                new_blocked_road = (u, v)\n                new_max_length = find_path_length(adj, new_blocked_road)\n                max_length = max(max_length, new_max_length)\n        return max_length\n\n    n, m = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u - 1].append((v - 1, 1))\n        adj[v - 1].append((u - 1, 1))\n\n    return find_min_path_length(adj)\n"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m = map(int, stdin.split()[0:2])\n    roads = [map(int, stdin.split()[2*i+2:2*i+4]) for i in range(m)]\n    roads = [(u-1, v-1) for u, v in roads]\n\n    # Helper function to compute the longest path from a given node\n    def longest_path(node: int) -> int:\n        # If this node has been visited, return its length\n        if node in visited:\n            return visited[node]\n        # Otherwise, visit all neighbors\n        max_length = 0\n        for neighbor, road_id in enumerate(graph[node]):\n            # If this neighbor is unblocked, add its longest path to ours\n            if road_id >= 0:\n                max_length = max(max_length, longest_path(neighbor))\n        # Store the longest path and return it\n        visited[node] = max_length + 1\n        return visited[node]\n\n    # Initialize the graph and visited dictionary\n    graph = [[] for _ in range(n)]\n    visited = {}\n\n    # Build the graph and find the longest path from each node\n    for u, v in roads:\n        graph[u].append(v)\n        graph[v].append(-1)\n    max_length = 0\n    for node in range(n):\n        max_length = max(max_length, longest_path(node))\n\n    # Output the minimum length path\n    return max_length"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    roads = [tuple(map(int, road.split())) for road in input_data[1:]]\n\n    adj_list = [[] for _ in range(n)]\n    for u, v in roads:\n        adj_list[u - 1].append(v - 1)\n\n    def dfs(v: int, visited: set, path: list) -> None:\n        visited.add(v)\n        path.append(v)\n        for u in adj_list[v]:\n            if u not in visited:\n                dfs(u, visited, path)\n\n    max_length_paths = []\n    for u in range(n):\n        path = []\n        dfs(u, set(), path)\n        max_length_paths.append(len(path))\n\n    blocked_road_id = max_length_paths.index(max(max_length_paths))\n    blocked_road = roads[blocked_road_id]\n    print(blocked_road)\n\n    return str(max(max_length_paths) - 1)\n"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    road_list = [tuple(map(int, input_list[i].split())) for i in range(1, m+1)]\n    # Initialize adjacency list\n    adjacency_list = [[] for _ in range(n)]\n    for u, v in road_list:\n        adjacency_list[u-1].append(v-1)\n        adjacency_list[v-1].append(u-1)\n\n    # Helper function to find the minimum length path\n    def find_min_length_path(u: int, blocked_road: int) -> int:\n        # Initialize the visited array\n        visited = [False] * n\n        # Initialize the distance array\n        distance = [float('inf')] * n\n        # Initialize the distance to source node as 0\n        distance[u] = 0\n        # Initialize the visited list\n        visited[u] = True\n        # Initialize the queue\n        queue = [u]\n        # Initialize the block list\n        block_list = [False] * m\n        block_list[blocked_road] = True\n        # Initialize the max_length\n        max_length = 0\n        # Loop until the queue is empty\n        while queue:\n            # Pop the first element from the queue\n            v = queue.pop(0)\n            # If the current node is blocked, skip it\n            if block_list[adjacency_list[v].index(u)]:\n                continue\n            # Update the distance array\n            distance[v] = min(distance[v], distance[u] + 1)\n            # If the current node is the sink node, update the max_length\n            if v == n-1:\n                max_length = max(max_length, distance[n-1])\n            # Add the neighbor nodes to the queue\n            for neighbor in adjacency_list[v]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n        return max_length\n\n    # Initialize the worst case scenario\n    worst_case = float('inf')\n    # Loop through all possible blocked roads\n    for blocked_road in range(m):\n        # Loop through all starting nodes\n        for u in range(n):\n            # Find the minimum length path from u to the sink node\n            min_length = find_min_length_path(u, blocked_road)\n            # Update the worst case scenario\n            worst_case = min(worst_case, min_length)\n    return str(worst_case)\n"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(cur, visited, depth, graph, paths):\n        visited[cur] = True\n        for node in graph[cur]:\n            if not visited[node]:\n                dfs(node, visited, depth + 1, graph, paths)\n                paths.append((cur, node, depth + 1))\n\n    def find_min_length_path(blocked_road, paths, graph):\n        min_length = float('inf')\n        for start, end, length in paths:\n            if start == blocked_road[0] and end == blocked_road[1]:\n                continue\n            path_length = length + graph[start][end]\n            if path_length < min_length:\n                min_length = path_length\n        return min_length\n\n    def is_connected(graph, visited):\n        for node in graph:\n            if not visited[node]:\n                return False\n        return True\n\n    n, m = map(int, stdin.split()[0:2])\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split()[2:4])\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * (n + 1)\n    dfs(1, visited, 0, graph, [])\n\n    if not is_connected(graph, visited):\n        return \"0\"\n\n    paths = []\n    visited = [False] * (n + 1)\n    dfs(1, visited, 0, graph, paths)\n\n    blocked_road = None\n    max_length = 0\n    for u, v, length in paths:\n        if length > max_length:\n            max_length = length\n            blocked_road = (u, v)\n\n    min_length = find_min_length_path(blocked_road, paths, graph)\n\n    return str(min_length)"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(cur, visited, depth, graph, result, max_depth):\n        if visited[cur]:\n            return\n        visited[cur] = True\n        depth[cur] = 1\n        for nxt in graph[cur]:\n            if not visited[nxt]:\n                dfs(nxt, visited, depth, graph, result, max_depth)\n                depth[cur] += depth[nxt]\n                result[0] = max(result[0], depth[cur])\n                max_depth[0] = max(max_depth[0], depth[cur])\n\n    def block_road(graph, blocked):\n        new_graph = [[] for _ in range(n)]\n        for u, v in graph:\n            if (u, v) not in blocked:\n                for new_u, new_v in graph:\n                    if new_v == u:\n                        new_graph[new_u].append((new_v, u))\n        return new_graph\n\n    def longest_path(graph):\n        visited = [False] * n\n        depth = [0] * n\n        result = [0]\n        max_depth = [0]\n        for i in range(n):\n            dfs(i, visited, depth, graph, result, max_depth)\n        return result[0], max_depth[0]\n\n    def min_length_path(max_depth, blocked, graph):\n        new_graph = block_road(graph, blocked)\n        new_max_depth, _ = longest_path(new_graph)\n        return max(max_depth - new_max_depth, 0)\n\n    def main(n, m, graph):\n        max_depth, _ = longest_path(graph)\n        blocked = set()\n        for i in range(m):\n            u, v = map(int, input().split())\n            if min_length_path(max_depth, blocked, graph) == 0:\n                return 0\n            blocked.add((u, v))\n        return min_length_path(max_depth, blocked, graph)\n\n    n, m = map(int, input().split())\n    graph = [tuple(map(int, input().split())) for _ in range(m)]\n    stdin = (n, m, graph)\n\n    return str(main(*stdin))"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_path(path: list, blocked_road: tuple) -> bool:\n        for i in range(len(path) - 1):\n            if path[i] == blocked_road[0] and path[i + 1] == blocked_road[1]:\n                return False\n        return True\n\n    n, m = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m + 1]]\n    max_path_length = float('inf')\n    for blocked_road in roads:\n        new_max_path_length = max_path_length\n        for path in itertools.permutations(roads):\n            if is_valid_path(path, blocked_road):\n                new_max_path_length = min(new_max_path_length, len(path))\n        max_path_length = new_max_path_length\n\n    return max_path_length\n"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import combinations\n    n, m = map(int, input().split())\n    roads = [tuple(map(int, input().split())) for _ in range(m)]\n\n    def is_connected(graph, a, b):\n        queue = [a]\n        visited = set()\n        while queue:\n            vertex = queue.pop(0)\n            if vertex == b:\n                return True\n            visited.add(vertex)\n            queue.extend(graph[vertex] - visited)\n        return False\n\n    def dfs(graph, start, end, blocked):\n        if start == end:\n            return 1\n        if blocked.get((start, end), None) is not None:\n            return blocked[(start, end)]\n        blocked[(start, end)] = float('-inf')\n        for neighbor in graph[start]:\n            if not is_connected(graph, start, end):\n                blocked[(start, end)] = max(blocked[(start, end)], dfs(graph, neighbor, end, blocked))\n        return blocked[(start, end)]\n\n    def min_path(graph, blocked_edges):\n        paths = []\n        for road in blocked_edges:\n            graph[road[0]].remove(road[1])\n            graph[road[1]].remove(road[0])\n            paths.append(dfs(graph, 1, n, {}))\n            graph[road[0]].add(road[1])\n            graph[road[1]].add(road[0])\n        return min(paths)\n\n    blocked_edges = combinations(roads, 2)\n    graph = {i: set(range(1, n + 1)) - {i} for i in range(1, n + 1)}\n    return min_path(graph, blocked_edges)\n"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    n, m = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # Helper function to find the length of the longest path starting from a station\n    def longest_path(start: int) -> int:\n        visited = [False] * n\n        queue = [start]\n        visited[start] = True\n        length = 0\n\n        while queue:\n            length += 1\n            new_queue = []\n\n            for node in queue:\n                for neighbor in [u for u, v in roads if v == node and not visited[u]]:\n                    visited[neighbor] = True\n                    new_queue.append(neighbor)\n\n            queue = new_queue\n\n        return length\n\n    # Find the longest path for each station\n    longest_paths = [longest_path(node) for node in range(1, n + 1)]\n\n    # Find the minimum length path by blocking a road\n    min_length = n\n    for u, v in roads:\n        # Check if the road is not already blocked\n        if not any(w == u or w == v for w, _ in roads):\n            # Update the longest paths after blocking the road\n            longest_paths[u - 1] = longest_path(u)\n            longest_paths[v - 1] = longest_path(v)\n\n            # Check if the minimum length path is affected\n            min_length = min(min_length, *longest_paths)\n\n            # Unblock the road by restoring the longest paths\n            longest_paths[u - 1] = longest_path(u)\n            longest_paths[v - 1] = longest_path(v)\n\n    return str(min_length)\n"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    xy = list(map(int, input_list[0].split()))\n    vw = list(map(float, input_list[1].split()))\n    \n    # Calculate the time taken to travel the distance\n    distance = abs(xy[0]) + abs(xy[1])\n    time_travel = distance / vw[0]\n    \n    # Calculate the time taken to rotate\n    angle = 2 * np.pi * abs(xy[0]) / vw[1]\n    time_rotate = angle / vw[1]\n    \n    # Calculate the minimum time taken\n    time = min(time_travel, time_rotate)\n    \n    # Format the output to 8 decimal places\n    return \"{:.8f}\".format(time)"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    xy = tuple(map(int, input_data[0].split()))\n    vw = tuple(map(float, input_data[1].split()))\n\n    x, y = xy\n    v, w = vw\n\n    # Calculate distance and angle to target\n    distance = abs(x) + abs(y)\n    angle = math.atan2(y, x)\n\n    # Calculate time taken for straight line travel\n    time_straight = distance / v\n\n    # Calculate time taken for rotation\n    time_rotate = abs(angle / w)\n\n    # Determine which path takes the minimum time\n    if time_straight < time_rotate:\n        return f\"{time_straight:.6f}\"\n    else:\n        return f\"{time_rotate:.6f}\"\n\ndef"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n    d = ((x**2) + (y**2))**0.5\n    \n    if x == 0 and y == 0:\n        return \"0.00000000\"\n    \n    if x == 0:\n        theta = np.pi / 2\n    else:\n        theta = np.arctan(y / x)\n    \n    t_x = d / v\n    t_y = abs(y / v * np.cos(theta))\n    t_w = abs(np.arctan(w * d) / w)\n    \n    t = max(t_x, t_y, t_w)\n    \n    return f\"{t:.{8}f}\"\n\ndef"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.splitlines()\n    xy = list(map(int, inputs[0].split()))\n    vw = list(map(float, inputs[1].split()))\n\n    x, y = xy\n    v, w = vw\n\n    time = 0\n\n    if x == 0 and y == 0:\n        time = 0\n    elif x == 0:\n        time = y / v\n    elif y == 0:\n        time = x / v\n    else:\n        time = abs(x) / v + abs(y) / v\n\n    angle = math.atan2(y, x)\n    angle_to_rotate = math.atan2(v * math.sin(angle), v * math.cos(angle) + v * w)\n\n    if angle_to_rotate < 0:\n        angle_to_rotate += 2 * math.pi\n\n    time += angle_to_rotate / w\n\n    return f\"{time:.6f}\"\n"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    x, y = map(int, lines[0].split())\n    v, w = map(float, lines[1].split())\n\n    def rotate(angle: float) -> str:\n        return \"rotate\" if angle >= 0 else \"counter_rotate\"\n\n    def calculate_time(distance: float, speed: float, angle: float) -> float:\n        if angle == 0:\n            return distance / speed\n        time = abs(distance / (speed * math.cos(angle)))\n        if time < abs(angle / w):\n            time += time * (abs(angle) / w)\n        return time\n\n    distance = math.sqrt(x ** 2 + y ** 2)\n    speed = v * 0.51  # Reduce speed by a small margin to account for drift\n    if y > 0:\n        time = calculate_time(distance, speed, math.atan(x / y))\n        if distance > 0:\n            return time + calculate_time(distance * y / x, speed, math.atan(y / x))\n        else:\n            return time + calculate_time(distance * y / x, speed, -math.atan(y / x))\n    else:\n        time = calculate_time(distance, speed, -math.atan(x / y))\n        if distance > 0:\n            return time + calculate_time(distance * y / x, speed, -math.atan(y / x))\n        else:\n            return time + calculate_time(distance * y / x, speed, math.atan(y / x))\n"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1: int, y1: int, x2: int, y2: int) -> float:\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def time_to_travel(x1: int, y1: int, x2: int, y2: int, v: float) -> float:\n        distance_traveled = distance(x1, y1, x2, y2)\n        return distance_traveled / v\n\n    def turn_to_target(x1: int, y1: int, x2: int, y2: int, w: float) -> float:\n        angle = np.arctan2(y2 - y1, x2 - x1)\n        turn_angle = np.arcsin(w / 2 * distance(x1, y1, x2, y2))\n        return np.abs(turn_angle - angle)\n\n    x, y, v, w = map(float, stdin.splitlines()[1].split())\n    x, y = int(x), int(y)\n\n    time_to_target = time_to_travel(0, 0, x, y, v) + turn_to_target(0, 0, x, y, w)\n    time_to_return = time_to_travel(x, y, 0, 0, v) + turn_to_target(x, y, 0, 0, w)\n\n    return min(time_to_target, time_to_return)\n"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    xy, vw = stdin.splitlines()\n    x, y = map(int, xy.split())\n    v, w = map(float, vw.split())\n\n    time_to_travel = abs(x) * v / 2 + abs(y) * v / 2\n    time_to_rotate = abs(x) * w / 2 + abs(y) * w / 2\n\n    total_time = max(time_to_travel, time_to_rotate)\n\n    return f\"{total_time:.6f}\"\n"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split(\"\\n\")\n    xy_str, vw_str = input_list\n    x, y = map(int, xy_str.split())\n    v, w = map(float, vw_str.split())\n\n    dist = x * x + y * y\n    time = dist / (v + v / w)\n\n    return f\"{time:.6f}\"\n\n\ndef"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    x, y = map(int, input_list[0].split())\n    v, w = map(float, input_list[1].split())\n\n    theta = abs(atan2(y, x))\n    dist = sqrt(x**2 + y**2)\n\n    time = dist / v\n    time_turn = theta / w\n\n    return str(time + time_turn)\n"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n\n    # Calculate the angle at which the vehicle needs to rotate\n    angle = math.atan2(y, x)\n\n    # Calculate the minimum time required to get to the target\n    min_time = abs(x) / v + abs(y) / v + abs(angle) / w\n\n    return f\"{min_time:.10f}\"\n\n\ndef"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    debts = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n\n    total_debt = sum(map(lambda x: x[1], debts))\n    total_return = sum(map(lambda x: x[1], debts))\n\n    for i in range(N):\n        if total_return == 0:\n            break\n\n        for j in range(N):\n            if i == j:\n                continue\n\n            if debts[i][0] == j + 1:\n                total_return -= min(total_debt, debts[i][1])\n                total_debt -= min(total_debt, debts[i][1])\n\n    return total_return + total_debt\n"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0].strip())\n    debts = []\n    for i in range(1, N + 1):\n        debt = list(map(int, stdin[i].strip().split()))\n        debts.append(debt)\n\n    # Calculate the minimum total ammount of money town has to give to its inhabitants\n    total = sum([debt[1] for debt in debts])\n    for i in range(N):\n        for j in range(N):\n            if debts[i][0] == j + 1:\n                total += min(debt[1] + debts[j][1], debts[i][1])\n                debts[i][1] -= min(debt[1] + debts[j][1], debts[i][1])\n                debts[j][1] -= min(debt[1] + debts[j][1], debts[i][1])\n                break\n\n    return str(total)"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    debt_list = []\n    for i in range(1, N+1):\n        debt_list.append(list(map(int, input_data[i].split())))\n    \n    # Calculate the maximum debt for each person\n    max_debt = [0] * N\n    for i in range(N):\n        for j in range(N):\n            if debt_list[j][0] == i+1:\n                max_debt[i] = max(max_debt[i], debt_list[j][1])\n                \n    # Calculate the minimum total amount of money the town has to give\n    total_give = sum(max_debt)\n    \n    return str(total_give)\n\ninput_data = '''4\n2 100\n1 100\n4 70\n3 70'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(curr: int, remaining_debt: int, visited: set):\n        if remaining_debt == 0:\n            return 0\n        if curr in visited:\n            return float('inf')\n        visited.add(curr)\n        res = float('inf')\n        for i in range(len(graph[curr])):\n            if debt[curr][i] <= 0:\n                continue\n            new_debt = debt[curr][i] - remaining_debt\n            if new_debt > 0:\n                res = min(res, new_debt + dfs(graph[curr][i], new_debt, visited))\n            else:\n                res = min(res, dfs(graph[curr][i], debt[curr][i], visited))\n        return res\n\n    N, graph, debt = [], {}, {}\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    for i in range(1, N + 1):\n        line = lines[i].split()\n        A = int(line[0])\n        B = int(line[1])\n        if A not in debt:\n            debt[A] = [0] * N\n            graph[A] = []\n        if B not in debt:\n            debt[B] = [0] * N\n            graph[B] = []\n        debt[A][B - 1] = B\n        graph[A].append(B - 1)\n\n    visited = set()\n    min_total = float('inf')\n    for i in range(N):\n        min_total = min(min_total, dfs(i, debt[i][i], visited))\n\n    return str(min_total)\n"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph: dict, start: int) -> list:\n        visited = set()\n        path = [start]\n        while visited != len(graph):\n            current = path[-1]\n            if current in visited:\n                break\n            visited.add(current)\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    path.append(neighbor)\n                    break\n        return path\n\n    def find_minimum_gifts(graph: dict, gifts: dict) -> int:\n        total_cost = 0\n        while gifts:\n            cycle = find_cycle(graph, next(iter(gifts)))\n            for i in range(len(cycle) - 1):\n                source = cycle[i]\n                target = cycle[i + 1]\n                amount = gifts.pop((source, target), 0)\n                if amount > 0:\n                    gifts[target, source] += amount\n                    total_cost += amount\n        return total_cost\n\n    input_list = stdin.split(\"\\n\")\n    num_people = int(input_list[0])\n    graph = {i: set() for i in range(1, num_people + 1)}\n    gifts = {}\n    for i in range(1, num_people + 1):\n        line = input_list[i].split()\n        borrower, amount = int(line[0]), int(line[1])\n        graph[i].add(borrower)\n        gifts[borrower, i] = amount\n\n    min_total_cost = find_minimum_gifts(graph, gifts)\n    return str(min_total_cost)"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_give(graph: dict, visited: set, current: int, total: int, debt: int, depth: int) -> int:\n        visited.add(current)\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                min_give = get_min_give(graph, visited, neighbor, total + debt, debt, depth + 1)\n                total += min_give\n        return total - debt\n\n    N, *edges = stdin.strip().split('\\n')\n    N = int(N)\n    graph = {i: [] for i in range(1, N + 1)}\n    for edge in edges:\n        a, b = map(int, edge.split())\n        graph[a].append(b)\n\n    visited = set()\n    min_give = float('inf')\n    for i in range(1, N + 1):\n        min_give = min(min_give, get_min_give(graph, visited, i, 0, 0, 0))\n\n    return min_give\n\ninput_data = '''4\n2 100\n1 100\n4 70\n3 70'''\n\nprint(solution(input_data))"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    adj_matrix = [[0] * (N + 1) for _ in range(N + 1)]\n    \n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            adj_matrix[i][j] = adj_matrix[j][i]\n    \n    for line in input_data[1:]:\n        person1, person2, debt = map(int, line.split())\n        adj_matrix[person1][person2] = debt\n    \n    total_cost = 0\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if adj_matrix[i][j] > adj_matrix[j][i]:\n                total_cost += adj_matrix[i][j] - adj_matrix[j][i]\n    \n    return str(total_cost)"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, *data = stdin.split('\\n')\n    N = int(N)\n    graph = [[] for _ in range(N + 1)]\n    for edge in data:\n        u, v = map(int, edge.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DFS to find the maximum connected component\n    visited = [False] * (N + 1)\n    def dfs(u):\n        if not visited[u]:\n            visited[u] = True\n            for v in graph[u]:\n                dfs(v)\n\n    max_component = 0\n    for i in range(1, N + 1):\n        if not visited[i]:\n            dfs(i)\n            max_component = max(max_component, sum(visited))\n            visited = [False] * (N + 1)\n\n    # The minimum total amount of money the town has to give is the sum of all debts\n    total_debt = sum(map(int, data))\n    return max(0, total_debt - max_component)\n"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    debts = []\n    for i in range(1, N + 1):\n        debt = list(map(int, stdin.splitlines()[i].split()))\n        debts.append(debt)\n\n    debts_graph = [[] for _ in range(N + 1)]\n    for debt in debts:\n        debts_graph[debt[0]].append((debt[1], debt[2]))\n\n    def dfs(node, depth, visited, graph, memo):\n        if visited[node]:\n            return 0\n        visited[node] = True\n        result = 0\n        for debt, person in graph[node]:\n            if not visited[person]:\n                result += dfs(person, depth + 1, visited, graph, memo)\n            if depth == 0 and result + debt > memo[node]:\n                memo[node] = result + debt\n        return result\n\n    min_cost = float('inf')\n    for person in range(1, N + 1):\n        visited = [False] * (N + 1)\n        cost = dfs(person, 0, visited, debts_graph, [0] * (N + 1))\n        min_cost = min(min_cost, cost)\n\n    return str(min_cost)\n\n\ninput_data = \"\"\"4\n2 100\n1 100\n4 70\n3 70\n\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    debts = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    debts.sort(key=lambda x: x[1], reverse=True)\n\n    total_owed = sum(debts[i][1] for i in range(N))\n    total_given = 0\n\n    for i in range(N):\n        total_owed -= debts[i][1]\n        total_given += debts[i][1]\n        if total_owed <= total_given:\n            break\n\n    return total_given\n\n\ndef"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_city(path: str, visited: set, city: int) -> int:\n        for i in range(1, N+1):\n            if i not in visited and i != city:\n                return i\n        return -1\n\n    N, M = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    longest_path = [1]\n    visited = set()\n\n    for i in range(N):\n        city = get_next_city(longest_path, visited, 1)\n        if city == -1:\n            break\n        longest_path.append(city)\n        visited.add(city)\n\n    return len(longest_path) - 1\n\ninput1 = \"4 3\\n1 2\\n1 3\\n2 4\"\ninput2 = \"6 6\\n1 2\\n1 3\\n2 4\\n3 4\\n3 5\\n5 6\"\n\nprint(solution(input1)) # Output: 2\nprint(solution(input2)) # Output: 5 "
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_list[1:]]\n\n    # Create adjacency list for each city\n    adjacency_list = {i: [] for i in range(1, N + 1)}\n    for road in roads:\n        adjacency_list[road[0]].append(road[1])\n        adjacency_list[road[1]].append(road[0])\n\n    # DFS for finding the longest path\n    def dfs(city, visited, path, path_length):\n        visited.add(city)\n        path.append(city)\n        path_length += 1\n\n        if city == 1:\n            return path_length\n\n        for neighbor in adjacency_list[city]:\n            if neighbor not in visited:\n                dfs(neighbor, visited.copy(), path, path_length)\n                if path_length > max_length:\n                    max_length = path_length\n\n                visited.remove(neighbor)\n                path.pop()\n                path_length -= 1\n\n    max_length = 0\n    for city in range(1, N + 1):\n        dfs(city, set(), [], 0)\n\n    return str(max_length)"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:M+1]]\n    graph = [[] for _ in range(N+1)]\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node, visited, path_length, path):\n        visited[node] = True\n        path_length += 1\n        path.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, path_length, path)\n        path.pop()\n        visited[node] = False\n        return path_length\n\n    longest_path_length = 0\n    visited = [False] * (N+1)\n    for start in range(1, N+1):\n        if not visited[start]:\n            path = [start]\n            path_length = dfs(start, visited, 0, path)\n            if path_length > longest_path_length:\n                longest_path_length = path_length\n                longest_path = path\n\n    return longest_path_length\n"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    roads = [(int(a), int(b)) for a, b in map(lambda x: x.split(), input_data[1:])]\n\n    graph = {i: [] for i in range(1, N + 1)}\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node, path, visited, stack, result):\n        if len(path) > result[0]:\n            result[0] = len(path)\n        visited[node] = True\n        stack.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, path + [neighbor], visited, stack, result)\n        stack.pop()\n        visited[node] = False\n\n    result = [0]\n    for i in range(1, N + 1):\n        visited = [False] * (N + 1)\n        dfs(i, [i], visited, [], result)\n\n    return str(result[0])\n"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    roads = {}\n    for i in range(1, M+1):\n        city1, city2 = map(int, input_list[i].split())\n        if city1 not in roads:\n            roads[city1] = [city2]\n        else:\n            roads[city1].append(city2)\n        if city2 not in roads:\n            roads[city2] = [city1]\n        else:\n            roads[city2].append(city1)\n    \n    longest_path_length = 0\n    for city in roads:\n        path_length = 1\n        visited = [city]\n        queue = [(city, city)]\n        while queue:\n            current_city, start_city = queue.pop(0)\n            for neighbor in roads[current_city]:\n                if neighbor not in visited:\n                    visited.append(neighbor)\n                    queue.append((neighbor, start_city))\n                    path_length += 1\n        if path_length > longest_path_length:\n            longest_path_length = path_length\n    \n    return str(longest_path_length-1)\n"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, M = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Find the longest simple path\n    longest_simple_path = []\n    for i in range(N):\n        for j in range(N):\n            if (i, j) not in roads:\n                continue\n            simple_path = find_simple_path(i, j, roads)\n            if len(simple_path) > len(longest_simple_path):\n                longest_simple_path = simple_path\n\n    # Find the longest ring\n    longest_ring = []\n    for road in roads:\n        if find_ring(road, roads):\n            ring = [road]\n            while True:\n                next_road = find_next_road(ring[-1], roads)\n                if next_road is None:\n                    break\n                ring.append(next_road)\n            if len(ring) > len(longest_ring):\n                longest_ring = ring\n\n    # Compute the length of the longest path\n    if len(longest_simple_path) > len(longest_ring):\n        longest_path = longest_simple_path\n    else:\n        longest_path = longest_ring\n    return len(longest_path)\n\n\ndef"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_paths(start: int, visited: set[int], paths: list[list[int]], graph: dict[int, list[int]], path_length: int) -> int:\n        if start == 1:\n            return path_length\n\n        if visited & graph[start]:\n            return -1\n\n        visited.add(start)\n        paths.append(start)\n\n        max_length = -1\n        for neighbor in graph[start]:\n            if neighbor in visited:\n                continue\n\n            length = find_paths(neighbor, visited.copy(), paths.copy(), graph, path_length + 1)\n            if length != -1:\n                max_length = max(max_length, length)\n\n        visited.remove(start)\n        paths.pop()\n\n        return max_length\n\n    N, M = map(int, stdin.split()[:2])\n    graph = {i: [] for i in range(1, N + 1)}\n    for _ in range(M):\n        a, b = map(int, stdin.split()[:2])\n        graph[a].append(b)\n        graph[b].append(a)\n\n    longest_path = 0\n    for start in range(1, N + 1):\n        path_length = find_paths(start, set(), [], graph, 0)\n        longest_path = max(longest_path, path_length)\n\n    return str(longest_path)\n"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_path_length(path: list) -> int:\n        length = 0\n        for i in range(len(path)):\n            if i % 2 == 0:\n                length += roads[path[i]][path[i+1]]\n            else:\n                length += roads[path[i]][path[i-1]]\n        return length\n\n    def find_longest_path(start: int, visited: set, path: list) -> int:\n        if len(visited) == N:\n            return get_path_length(path)\n\n        longest_path_length = 0\n        for city in range(1, N+1):\n            if city not in visited:\n                new_visited = visited.copy()\n                new_visited.add(city)\n                new_path = path + [city]\n                longest_path_length = max(longest_path_length, find_longest_path(city, new_visited, new_path))\n\n        return longest_path_length\n\n    # Read input\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    roads = {}\n    for i in range(1, N+1):\n        roads[i] = {}\n    for i in range(1, M+1):\n        A, B = map(int, lines[i].split())\n        roads[A][B] = 1\n        roads[B][A] = 1\n\n    # Find longest path\n    longest_path_length = 0\n    for city in range(1, N+1):\n        visited = {city}\n        new_path = [city]\n        longest_path_length = max(longest_path_length, find_longest_path(city, visited, new_path))\n\n    # Output result\n    return str(longest_path_length)"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    adjacency_list = [[] for _ in range(N+1)]\n    for _ in range(M):\n        u, v = map(int, stdin.split()[:2])\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n\n    def dfs(u, parent, visited, dp):\n        visited[u] = True\n        for v in adjacency_list[u]:\n            if v != parent and not visited[v]:\n                dfs(v, u, visited, dp)\n        dp[u] = len(adjacency_list[u])\n\n    visited = [False] * (N+1)\n    dp = [0] * (N+1)\n    for i in range(1, N+1):\n        if not visited[i]:\n            dfs(i, -1, visited, dp)\n\n    longest_path_length = max(dp)\n\n    return str(longest_path_length)\n\ndef"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, node, path_length, max_length, paths):\n        visited[node] = True\n        path_length += 1\n        paths.append(node)\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(graph, visited, neighbor, path_length, max_length, paths)\n\n        path_length -= 1\n        paths.pop()\n        visited[node] = False\n\n    def find_longest_path(graph, start_node, end_node):\n        visited = [False] * (N + 1)\n        paths = []\n        max_length = 0\n        for node in range(1, N + 1):\n            if not visited[node]:\n                dfs(graph, visited, node, 0, max_length, paths)\n\n        for i, path in enumerate(paths):\n            if path == end_node:\n                return max(max_length, i)\n\n    N, M = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        A, B = map(int, stdin.split()[:2])\n        graph[A].append(B)\n        graph[B].append(A)\n\n    longest_path = find_longest_path(graph, 1, 1)\n    return str(longest_path)\n"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, L, walk = map(int, lines[0].split())\n    adjacency = [list(map(int, lines[i+1].split()[1:])) for i in range(N)]\n\n    def dfs(node, visited, path, parent, step, visit_count, max_visit_count):\n        if visit_count[node] >= max_visit_count[node]:\n            return\n        visit_count[node] += 1\n        path.append(node)\n        for neighbour in adjacency[node]:\n            if neighbour != parent:\n                dfs(neighbour, visited, path, node, step, visit_count, max_visit_count)\n        path.pop()\n\n    # Initialize visit_count and max_visit_count for each node\n    visit_count = [0] * N\n    max_visit_count = [0] * N\n    for i in range(N):\n        dfs(i, [False] * N, [], -1, 0, visit_count, max_visit_count)\n\n    # Compute the chance of success\n    chance_of_success = 1\n    for i in range(L):\n        current_node = walk[i]\n        if visit_count[current_node] < max_visit_count[current_node]:\n            chance_of_success *= max_visit_count[current_node] / (max_visit_count[current_node] - visit_count[current_node])\n        else:\n            chance_of_success = 0\n            break\n\n    return round(chance_of_success, 6)"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, L, walk, *adj_list = stdin.split('\\n')\n    N, L = int(N), int(L)\n    adj_list = [list(map(int, adj_list[i].split())) for i in range(N)]\n\n    def bfs(start: int, target: int) -> bool:\n        queue = [(start, False)]\n        visited = set()\n        while queue:\n            node, sentry_visited = queue.pop(0)\n            if node == target:\n                return not sentry_visited\n            if node in visited:\n                continue\n            visited.add(node)\n            if sentry_visited:\n                continue\n            for neighbour in adj_list[node]:\n                queue.append((neighbour, sentry_visited or (neighbour == target)))\n        return False\n\n    total_chance = 0\n    for i in range(L - 1):\n        total_chance += bfs(walk[i], walk[i + 1])\n\n    return str(total_chance / (L - 1))\n"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbours(adjacency_list: list, node: int) -> list:\n        return adjacency_list[node]\n\n    def bfs(graph, start_node, end_node):\n        queue = [(start_node, [start_node])]\n        while queue:\n            (vertex, path) = queue.pop(0)\n            for next_vertex in get_neighbours(graph, vertex) + [vertex]:\n                if next_vertex == end_node:\n                    yield path + [next_vertex]\n                else:\n                    yield from bfs(graph, next_vertex, end_node)\n\n    def count_possible_paths(walk: list, adjacency_list: list) -> int:\n        graph = [[] for _ in range(len(adjacency_list))]\n        for node, neighbours in enumerate(adjacency_list):\n            for neighbour in neighbours:\n                graph[node].append(neighbour)\n        paths_to_target = sum(1 for _ in bfs(graph, walk[0], walk[-1]))\n        return paths_to_target\n\n    def count_capture_chances(walk: list, adjacency_list: list) -> float:\n        paths_to_target = count_possible_paths(walk, adjacency_list)\n        return 1 / paths_to_target if paths_to_target > 0 else 0\n\n    lines = stdin.splitlines()\n    num_nodes = int(lines[0])\n    num_rooms = int(lines[1])\n    walk = [int(x) for x in lines[2].split()]\n    adjacency_list = [[int(x) for x in lines[i+3].split()[1:]] for i in range(num_nodes)]\n\n    chance = count_capture_chances(walk, adjacency_list)\n    return str(chance)"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    num_nodes, num_rooms, walk_length = map(int, input_list[0].split())\n    rooms_list = input_list[1].split()\n    nodes_list = input_list[2:]\n    adjacency_list = {int(rooms_list[i]): [] for i in range(num_nodes)}\n    for i in range(num_nodes):\n        adjacency_list[int(rooms_list[i])].extend(map(int, nodes_list[i].split()[1:]))\n\n    def is_valid_walk(walk_list: list) -> bool:\n        for i in range(num_rooms - 1):\n            if walk_list[i] == walk_list[i + 1]:\n                return False\n        return True\n\n    def get_chance_of_success(walk_list: list) -> float:\n        chance_success = 1\n        for room in walk_list:\n            chance_success *= (num_nodes - adjacency_list[room].count(0)) / num_nodes\n        return chance_success\n\n    valid_walks = []\n    for i in range(num_rooms):\n        for j in range(i + 1, num_rooms):\n            for k in range(j + 1, num_rooms):\n                walk_list = [walk_list[i] for i in range(num_rooms)]\n                walk_list[i], walk_list[j], walk_list[k] = walk_list[j], walk_list[i], walk_list[k]\n                if is_valid_walk(walk_list):\n                    valid_walks.append(walk_list)\n\n    chance_success = 0\n    for walk_list in valid_walks:\n        chance_success += get_chance_of_success(walk_list)\n    chance_success /= len(valid_walks)\n\n    return str(chance_success)"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    L = int(input_list[1])\n    walk_list = list(map(int, input_list[2].split()))\n    neighbours_list = []\n    for i in range(3, 3 + N):\n        neighbours_list.append(list(map(int, input_list[i].split()[1:])))\n\n    def is_safe(visited, i):\n        if i == L - 1:\n            return True\n        for neighbour in neighbours_list[i]:\n            if visited[neighbour] == False:\n                visited[neighbour] = True\n                if is_safe(visited, neighbour):\n                    return True\n                visited[neighbour] = False\n        return False\n\n    def is_successful(visited):\n        for i in range(L - 1):\n            if visited[walk_list[i]] == False:\n                return False\n        return True\n\n    def count_successful_walks():\n        count = 0\n        for i in range(N):\n            if is_safe([False] * N, i):\n                count += 1\n        return count\n\n    count = count_successful_walks()\n    chance = count / (2 ** N)\n    return '{:.6f}'.format(chance)"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    num_nodes = int(input_list.pop(0))\n    num_rooms = int(input_list.pop(0))\n    walk = [int(room) for room in input_list.pop(0).split()]\n    neighbors = [[int(neighbor) for neighbor in input_list.pop(i).split()[1:]] for i in range(num_nodes)]\n\n    graph = [[] for _ in range(num_nodes)]\n    for i in range(num_nodes):\n        for neighbor in neighbors[i]:\n            graph[i].append(neighbor)\n\n    visited = [False] * num_nodes\n    chance_success = 1\n    for room in walk:\n        visited[room] = True\n        if not visited[neighbors[room][0]]:\n            chance_success *= 0.5\n\n        if not visited[neighbors[neighbors[room][0]][0]]:\n            chance_success *= 0.5\n\n    return f\"{chance_success:.6f}\""
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    l = int(input_list[1])\n    rooms = [int(i) for i in input_list[2].split()]\n    neighbours = [[] for _ in range(n)]\n    for i in range(3, len(input_list)):\n        if i == 3:\n            continue\n        num_neighbours = int(input_list[i])\n        for j in range(1, num_neighbours + 1):\n            neighbours[i-1].append(int(input_list[i+j])-1)\n            neighbours[int(input_list[i+j])-1].append(i-1)\n        i += num_neighbours\n\n    def dfs(visited: list, node: int, visited_rooms: list):\n        visited[node] = True\n        visited_rooms.append(node)\n        for neighbour in neighbours[node]:\n            if not visited[neighbour]:\n                dfs(visited, neighbour, visited_rooms)\n\n    visited = [False] * n\n    visited_rooms = []\n    dfs(visited, rooms[0], visited_rooms)\n\n    prob_success = 1\n    for i in range(l-1):\n        prob_success *= 1/len(visited_rooms)\n\n    return f\"{1-prob_success:.6f}\""
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, visited: set, depth: int) -> bool:\n        visited.add(node)\n        for neighbor in nodes[node]:\n            if neighbor not in visited:\n                if depth >= len(rooms) and not dfs(neighbor, visited, depth + 1):\n                    return False\n        return True\n\n    def bfs(node: int, visited: set, depth: int) -> bool:\n        queue = [(node, depth)]\n        while queue:\n            node, depth = queue.pop(0)\n            if node == len(rooms) - 1:\n                return True\n            visited.add(node)\n            for neighbor in nodes[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, depth + 1))\n        return False\n\n    # Read input\n    N, L, rooms = [], [], []\n    for line in stdin.splitlines():\n        if not N:\n            N = list(map(int, line.split()))\n        elif not L:\n            L = list(map(int, line.split()))\n        else:\n            rooms.append(list(map(int, line.split())))\n\n    # Initialize nodes\n    nodes = [[] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if i != j and rooms[i][j] == 1:\n                nodes[i].append(j)\n\n    # Calculate chance of success\n    chance_of_success = 0.0\n    for room in rooms:\n        for start, end in zip(room, room[1:]):\n            visited = set()\n            if dfs(start, visited, 0):\n                chance_of_success += 1\n            if bfs(start, visited, 0):\n                chance_of_success += 1\n            chance_of_success /= 2\n\n    return \"{:.6f}\".format(chance_of_success)\n"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, L, walk = map(int, lines[0].split())\n    nodes = [[int(x) for x in lines[i+1].split()] for i in range(N)]\n\n    def is_valid_move(curr, target):\n        return curr == target or (curr == 0 and target == L-1) or (curr == L-1 and target == 0)\n\n    def count_paths(node, visited):\n        if node in visited:\n            return 0\n        visited.add(node)\n        if node == L-1:\n            return 1\n        return sum(count_paths(neighbour, visited) for neighbour in nodes[node])\n\n    total_paths = count_paths(walk[0], set())\n    captain_paths = count_paths(walk[0], set())\n    for i in range(1, L):\n        if is_valid_move(walk[i-1], walk[i]):\n            captain_paths *= nodes[walk[i-1]][walk[i]]\n        else:\n            captain_paths *= (nodes[walk[i-1]][0] + nodes[walk[i-1]][L-1]) * nodes[walk[i]][0] + nodes[walk[i]][L-1]\n    captain_paths //= total_paths\n\n    return captain_paths / (10**6)\n\ninput_1 = \"\"\"3\n1\n0\n2 1 2\n1 0\n1 0\n\"\"\"\ninput_2 = \"\"\"8\n6\n1 0 2 3 0 1\n7 1 2 3 4 5 6 7\n1 0\n2 0 3\n2 0 2\n1 0\n1 0\n1 0\n1 0\n\"\"\"\n\nprint(solution(input_1)) # Output: 0.5\nprint(solution(input_2)) # Output: 0.0446429 "
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, L, *walk, *neighbours = stdin.strip().split('\\n')\n    N, L = int(N), int(L)\n    neighbours = [set(map(int, line.split())) for line in neighbours]\n\n    # Helper function to get the number of paths between two nodes\n    def get_paths(i, j):\n        if i == j:\n            return 1\n        if not (i, j) in paths:\n            paths[(i, j)] = sum(get_paths(i, k) * get_paths(k, j) for k in neighbours[i] & neighbours[j])\n        return paths[(i, j)]\n\n    # Compute all possible paths and store them in a dictionary\n    paths = {}\n    for i in range(N):\n        for j in range(i+1, N):\n            get_paths(i, j)\n\n    # Compute the probability that the captain can complete his mission without being discovered\n    total_paths = sum(paths.values())\n    safe_paths = sum(get_paths(walk[i], walk[i+1]) for i in range(L-1))\n    chance = safe_paths / total_paths\n\n    return str(chance)"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = list(map(int, stdin.split('\\n')[1].split()))\n\n    if len(set(colors)) < n:\n        return \"IMPOSSIBLE\"\n\n    instructions = []\n    for color in sorted(set(colors)):\n        left = 0\n        while left < n and colors[left] == color:\n            left += 1\n        instructions.append((color, left, n))\n\n    return str(len(instructions)) + '\\n' + '\\n'.join([f\"{i[1]} {i[2]} {i[0]}\" for i in instructions])\n"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.splitlines()\n    n = int(input_str[0])\n    c = list(map(int, input_str[1].split()))\n\n    if len(set(c)) != n:\n        return \"IMPOSSIBLE\"\n\n    tape_art = [0] * n\n    color_map = {}\n\n    for i in range(n):\n        if tape_art[c[i]-1] == 0:\n            tape_art[c[i]-1] = i+1\n            color_map[c[i]-1] = i+1\n        else:\n            start = tape_art[c[i]-1]\n            end = i\n            for j in range(start, end+1):\n                if j in color_map:\n                    start = j + 1\n            tape_art[c[i]-1] = start\n            color_map[c[i]-1] = i+1\n\n    output = []\n    for i in range(n):\n        if tape_art[i] != 0:\n            output.append(f\"{tape_art[i]-1} {i+1} {c[i]-1}\")\n\n    if len(output) == n:\n        return f\"{len(output)}\\n\" + \"\\n\".join(output)\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_instructions(n, c):\n        if len(c) != n:\n            return \"IMPOSSIBLE\"\n        instructions = []\n        for i in range(n):\n            if c[i] != 1:\n                return \"IMPOSSIBLE\"\n            if i > 0 and c[i] == c[i - 1]:\n                return \"IMPOSSIBLE\"\n            instructions.append([1, i, c[i]])\n        instructions.append([n, n, 1])\n        return instructions\n\n    def format_output(instructions):\n        if instructions == \"IMPOSSIBLE\":\n            return instructions\n        output = str(len(instructions)) + \"\\n\"\n        for instruction in instructions:\n            output += \" \".join([str(x) for x in instruction]) + \"\\n\"\n        return output.rstrip()\n\n    n = int(stdin.split(\"\\n\")[0])\n    c = list(map(int, stdin.split(\"\\n\")[1].split()))\n    instructions = get_instructions(n, c)\n    output = format_output(instructions)\n    return output\n"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    colors = list(map(int, input().split()))\n    tape_art = [0] * n\n\n    for color in colors:\n        tape_art[color - 1] += 1\n\n    if max(tape_art) > 1:\n        return \"IMPOSSIBLE\"\n\n    instructions = []\n    for i, count in enumerate(tape_art):\n        if count > 0:\n            instructions.append((i + 1, i + 1, i + 1))\n\n    return str(len(instructions)) + \"\\n\" + \"\\n\".join(map(str, instructions))\n\n\ninput_string = \"\"\"6\n1 2 3 3 2 1\n4\n1 2 1 2\"\"\"\n\noutput_string = \"\"\nfor case in input_string.split(\"\\n\\n\"):\n    output_string += solution(case) + \"\\n\\n\"\n\nprint(output_string.strip()) "
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_range(colors, n):\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if colors[i] != colors[j]:\n                    return i + 1, j\n        return 1, n\n\n    def build_instructions(colors, n):\n        instructions = []\n        current_range = 1\n        color_count = {c: 0 for c in set(colors)}\n        for i in range(n):\n            color = colors[i]\n            color_count[color] += 1\n            if color_count[color] == 1:\n                start, end = current_range, i\n                current_range = i + 1\n                instructions.append((start, end, color))\n        if current_range != n + 1:\n            start, end = current_range, n\n            instructions.append((start, end, color))\n        return instructions\n\n    def execute_instructions(instructions):\n        result = [0] * n\n        for start, end, color in instructions:\n            for i in range(start - 1, end):\n                result[i] = color\n        return result\n\n    n = int(stdin.split(\"\\n\")[0])\n    colors = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    if len(set(colors)) != n:\n        return \"IMPOSSIBLE\"\n\n    instructions = build_instructions(colors, n)\n    if len(instructions) != len(set(colors)):\n        return \"IMPOSSIBLE\"\n\n    result = execute_instructions(instructions)\n    output = \"\\n\".join(f\"{i + 1} {start} {end} {color}\" for i, (start, end, color) in enumerate(instructions))\n    return output\n"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    colors = list(map(int, stdin.splitlines()[1].split()))\n\n    # Determine the colors of each section\n    sections = [[] for _ in range(n)]\n    for color in colors:\n        for i in range(n):\n            if not sections[i]:\n                sections[i].append(color)\n                break\n            elif color == sections[i][-1]:\n                break\n            elif color < sections[i][-1]:\n                j = i\n                while j > 0 and sections[j-1] and color < sections[j-1][-1]:\n                    j -= 1\n                sections[j].append(color)\n                break\n            else:\n                continue\n\n    # Check if the art can be reconstructed\n    if len(set(colors)) != len(sections):\n        return \"IMPOSSIBLE\"\n\n    # Create the instructions\n    instructions = []\n    for i, section in enumerate(sections):\n        if section:\n            color = section[0]\n            instructions.append((i+1, i+1, color))\n\n    return str(len(instructions)) + \"\\n\" + \"\\n\".join(map(str, instructions))"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    color_list = list(map(int, input_list[1].split()))\n    # initialize a dictionary to store the range of the tape for each color\n    tape_dict = {}\n\n    for i in range(1, n+1):\n        color = color_list[i-1]\n        if color not in tape_dict:\n            tape_dict[color] = [i, i]\n        else:\n            tape_dict[color][1] = i\n\n    if len(tape_dict) != n:\n        return \"IMPOSSIBLE\"\n\n    output_list = []\n    for color, range_list in tape_dict.items():\n        start, end = range_list\n        output_list.append(f\"{start} {end} {color}\")\n\n    return len(output_list), output_list"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip().split('\\n')\n    n = int(input_str[0])\n    colors = list(map(int, input_str[1].split()))\n    \n    if len(set(colors)) != n:\n        return \"IMPOSSIBLE\"\n    \n    instructions = []\n    for i in range(n):\n        if colors[i] == 1:\n            instructions.append([1+i, n, 1])\n            continue\n        if colors[i] == n:\n            instructions.append([1, n-i, 2])\n            continue\n        if colors[i] == n-1:\n            instructions.append([1+i, n, 3])\n            continue\n        if colors[i] == 2:\n            instructions.append([1, i+1, 1])\n            instructions.append([n-i+1, n, 2])\n            continue\n        if colors[i] == 3:\n            instructions.append([1, i, 3])\n            instructions.append([n-i+1, n, 1])\n            continue\n        if colors[i] == n-2:\n            instructions.append([1+i, n, 2])\n            instructions.append([1, n-i, 3])\n            continue\n    return str(len(instructions)) + '\\n' + '\\n'.join([str(i[0]) + ' ' + str(i[1]) + ' ' + str(i[2]) for i in instructions])\n\ninput_str = \"\"\"6\n1 2 3 3 2 1\"\"\"\noutput_str = solution(input_str)\nprint(output_str)\n\ninput_str = \"\"\"4\n1 2 1 2\"\"\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def valid_color(colors: list, color: int) -> bool:\n        return color in colors\n\n    def get_ranges(n: int, colors: list) -> list:\n        ranges = []\n        for i in range(1, n + 1):\n            if valid_color(colors, i):\n                ranges.append([i, i])\n        return ranges\n\n    def update_ranges(ranges: list, l: int, r: int) -> None:\n        for i in range(len(ranges)):\n            if ranges[i][0] <= l <= ranges[i][1]:\n                ranges[i][0] = r + 1\n            if ranges[i][0] <= r <= ranges[i][1]:\n                ranges[i][1] = l - 1\n\n    def find_color(colors: list, c: int) -> int:\n        for i in range(len(colors)):\n            if colors[i] == c:\n                return i\n        return -1\n\n    def execute_instructions(n: int, colors: list, ranges: list, instructions: list) -> str:\n        result = \"\"\n        for instruction in instructions:\n            l, r, c = instruction\n            if not valid_color(colors, c):\n                return \"IMPOSSIBLE\"\n            index = find_color(colors, c)\n            if index == -1:\n                return \"IMPOSSIBLE\"\n            if not valid_color(colors, c):\n                return \"IMPOSSIBLE\"\n            if l > 1 and valid_color(colors, colors[index - 1]):\n                if ranges[index - 1][1] + 1 >= l:\n                    return \"IMPOSSIBLE\"\n            if r < n and valid_color(colors, colors[index + 1]):\n                if ranges[index + 1][0] - 1 <= r:\n                    return \"IMPOSSIBLE\"\n            update_ranges(ranges, l, r)\n            result += f\"{l} {r} {c}\\n\"\n        return result\n\n    n, *colors = stdin.split()\n    n = int(n)\n    colors = list(map(int, colors))\n\n    ranges = get_ranges(n, colors)\n    instructions = []\n\n    for i in range(n):\n        if ranges[i][1] - ranges[i][0] == 0:\n            return \"IMPOSSIBLE\"\n        if ranges[i][0] == 1:\n            instructions.append([ranges[i][0], ranges[i][1], colors[i]])\n        else:\n            instructions.append([ranges[i][0] - 1, ranges[i][1], colors[i]])\n\n    return execute_instructions(n, colors, ranges, instructions)\n\n\ndef"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    colors = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    # Check if there are any duplicate colors\n    if len(set(colors)) != n:\n        return \"IMPOSSIBLE\"\n\n    instructions = []\n\n    for i in range(n):\n        l = i + 1\n        r = i + 1\n        color = colors[i]\n        instructions.append([l, r, color])\n\n    return len(instructions), *instructions"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    sequences = []\n    for i in range(1, N+1):\n        L, *sequence = map(int, input_data[i].split())\n        sequences.append(list(sequence))\n\n    best_sequence = []\n    while sequences:\n        min_sequence = min(sequences, key=lambda seq: seq[0])\n        best_sequence.append(min_sequence.pop(0))\n        sequences = [seq for seq in sequences if seq]\n\n    return ' '.join(map(str, best_sequence))\n"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    sequences = []\n\n    for i in range(1, N + 1):\n        L = int(input_data[i])\n        sequence = list(map(int, input_data[i + 1].split()))\n        sequences.append(sequence)\n\n    solution_sequence = []\n\n    for sequence in sequences:\n        for card in sequence:\n            if not solution_sequence or solution_sequence[-1] > card:\n                solution_sequence.append(card)\n            else:\n                solution_sequence.insert(0, card)\n\n    return \" \".join(map(str, solution_sequence))"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    N = int(input_lines[0])\n    sequences = []\n    for i in range(1, N + 1):\n        L = int(input_lines[i].split()[0])\n        sequence = [int(x) for x in input_lines[i].split()[1:]]\n        sequences.append(sequence)\n\n    def is_better(seq1, seq2):\n        for i in range(min(len(seq1), len(seq2))):\n            if seq1[i] < seq2[i]:\n                return True\n            elif seq1[i] > seq2[i]:\n                return False\n        if len(seq1) < len(seq2):\n            return True\n        return False\n\n    best_sequence = []\n    for sequence in sequences:\n        if not best_sequence:\n            best_sequence = sequence\n        else:\n            if is_better(best_sequence, sequence):\n                best_sequence = sequence\n\n    return \" \".join(str(x) for x in best_sequence)"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    sequences = []\n    for i in range(1, N + 1):\n        L = int(stdin.split('\\n')[i].split()[0])\n        sequence = [int(x) for x in stdin.split('\\n')[i].split()[1:]]\n        sequences.append(sequence)\n\n    def merge_sort(seq):\n        if len(seq) <= 1:\n            return seq\n        mid = len(seq) // 2\n        left = merge_sort(seq[:mid])\n        right = merge_sort(seq[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    min_sequence = []\n    for sequence in sequences:\n        sorted_sequence = merge_sort(sequence)\n        min_sequence.extend(sorted_sequence)\n\n    return ' '.join(str(x) for x in min_sequence)\n\n\ninput_data = \"\"\"3\n1 2\n1 100\n1 1\n2\n5 10 20 30 40 50\n2 28 27\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    sequences = []\n    for i in range(1, N + 1):\n        L = int(input_data[i])\n        sequence = [int(x) for x in input_data[i + 1].split()]\n        sequences.append(sequence)\n\n    # Sort sequences in decreasing order\n    sequences.sort(reverse=True)\n\n    solution_sequence = []\n    for sequence in sequences:\n        solution_sequence.extend(sequence)\n\n    return ' '.join(map(str, solution_sequence))"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    sequences = []\n    for i in range(1, N + 1):\n        L = int(input_data[i])\n        sequence = [int(x) for x in input_data[i+1].split()]\n        sequences.append(sequence)\n\n    def merge_sort(sequence):\n        if len(sequence) > 1:\n            mid = len(sequence) // 2\n            left = sequence[:mid]\n            right = sequence[mid:]\n            merge_sort(left)\n            merge_sort(right)\n            i = j = k = 0\n            while i < len(left) and j < len(right):\n                if left[i] < right[j]:\n                    sequence[k] = left[i]\n                    i += 1\n                else:\n                    sequence[k] = right[j]\n                    j += 1\n                k += 1\n            while i < len(left):\n                sequence[k] = left[i]\n                i += 1\n                k += 1\n            while j < len(right):\n                sequence[k] = right[j]\n                j += 1\n                k += 1\n\n    def get_best_sequence(sequences):\n        best_sequence = []\n        for sequence in sequences:\n            merge_sort(sequence)\n            best_sequence += sequence\n        return best_sequence\n\n    best_sequence = get_best_sequence(sequences)\n    return ' '.join(map(str, best_sequence))\n"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    sequences = []\n    for i in range(1, n + 1):\n        length = int(input_data[i].split()[0])\n        sequence = [int(x) for x in input_data[i].split()[1:]]\n        sequences.append(sequence)\n\n    solution_sequence = merge_sort([card for sequence in sequences for card in sequence])\n    return \" \".join(str(card) for card in solution_sequence)"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data.pop(0))\n    sequences = []\n    \n    for i in range(N):\n        L = int(input_data.pop(0))\n        sequence = [int(x) for x in input_data.pop(0).split()]\n        sequences.append(sequence)\n    \n    best_sequence = []\n    \n    for i in range(N):\n        L = len(sequences[i])\n        for j in range(L):\n            card_value = sequences[i][j]\n            if not best_sequence or card_value < best_sequence[-1]:\n                best_sequence.append(card_value)\n    \n    return ' '.join(str(x) for x in best_sequence)\n\ndef"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def parse_sequence(sequence_description: str) -> List[int]:\n        length, *cards = map(int, sequence_description.split())\n        return list(cards)\n\n    def find_best_sequence(sequences: List[List[int]]) -> List[int]:\n        def compare(card1: int, card2: int) -> int:\n            return card1 - card2\n\n        best_sequence = []\n        for sequence in sequences:\n            if not best_sequence:\n                best_sequence = sequence\n            else:\n                for index, card in enumerate(sequence):\n                    if index < len(best_sequence):\n                        best_card = best_sequence[index]\n                        if compare(card, best_card) > 0:\n                            best_sequence[index] = card\n                    else:\n                        best_sequence.append(card)\n        return best_sequence\n\n    N, *sequences_descriptions = stdin.split('\\n')\n    sequences = [parse_sequence(sequence_description) for sequence_description in sequences_descriptions]\n    best_sequence = find_best_sequence(sequences)\n    return ' '.join(map(str, best_sequence))"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    sequences = []\n    for i in range(1, n + 1):\n        sequence_len = int(input_lines[i])\n        sequence = [int(x) for x in input_lines[i + 1].split()]\n        sequences.append((sequence_len, sequence))\n\n    sequences.sort(key=lambda x: x[0])\n    solution_sequence = []\n    for sequence_len, sequence in sequences:\n        for card in sequence:\n            solution_sequence.append(card)\n\n    return ' '.join(str(x) for x in solution_sequence)\n\n\ninput_stdin = '''3\n1 2\n1 100\n1 1\n2\n5 10 20 30 40 50\n2 28 27'''\n\nresult = solution(input_stdin)\nprint(result) "
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    inv = [line.split() for line in stdin.split('\\n')[1:]]\n    cards = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    circles = set()\n\n    def get_circle(inv1, inv2):\n        a, b, c, d, e, f = cards\n        circles = {\n            (a, b, c), (a, b, d), (a, b, e), (a, b, f),\n            (a, c, d), (a, c, e), (a, c, f),\n            (a, d, e), (a, d, f),\n            (a, e, f),\n            (b, c, d), (b, c, e), (b, c, f),\n            (b, d, e), (b, d, f),\n            (b, e, f),\n            (c, d, e), (c, d, f),\n            (d, e, f),\n            (e, f),\n            (a, b), (a, c), (a, d), (a, e), (a, f),\n            (b, c), (b, d), (b, e), (b, f),\n            (c, d), (c, e), (c, f),\n            (d, e), (d, f),\n            (e, f),\n            (a, b, c, d), (a, b, c, e), (a, b, c, f),\n            (a, b, d, e), (a, b, d, f),\n            (a, b, e, f),\n            (a, c, d, e), (a, c, d, f),\n            (a, c, e, f),\n            (a, d, e, f),\n            (b, c, d, e), (b, c, d, f),\n            (b, c, e, f),\n            (b, d, e, f),\n            (c, d, e, f),\n            (a, b, c, d, e), (a, b, c, d, f),\n            (a, b, c, e, f),\n            (a, b, d, e, f),\n            (a, c, d, e, f),\n            (b, c, d, e, f),\n        }\n        return circles\n\n    for inv1, inv2 in itertools.combinations(inv, 2):\n        a, b, c = inv1\n        d, e, f = inv2\n        if a[1] == b[1] == c[1] == d[1] == e[1] == f[1] == 1:\n            circles |= get_circle(a, d)\n        elif a[1] == b[1] == c[1] == d[1] == e[1] == f[1] == 2:\n            circles |= get_circle(a, e)\n        elif a[1] == b[1] == c[1] == d[1] == e[1] == f[1] == 1:\n            circles |= get_circle(a, e)\n        elif a[1] == b[1] == c[1] == d[1] == e[1] == f[1] == 2:\n            circles |= get_circle(a, f)\n        elif a[1] == b[1] == c[1] == d[1] == e[1] == f[1] == 1:\n            circles |= get_circle(b, e)\n        elif a[1] == b[1] == c[1] == d[1] == e[1] == f[1] == 2:\n            circles |= get_circle(b, f)\n        elif a[1] == b[1] == c[1] == d[1] == e[1] == f[1] == 1:\n            circles |= get_circle(c, e)\n        elif a[1] == b[1] == c[1] == d[1] == e[1] == f[1] == 2:\n            circles |= get_circle(c, f)\n        elif a[1] == b["
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    investigations = []\n    for _ in range(N):\n        line = input().split()\n        investigations.append((line[0], int(line[1]), int(line[2])))\n\n    count = 0\n    for A in range(1, 27):\n        for B in range(A+1, 27):\n            for C in range(B+1, 27):\n                circle_suspects = set([A, B, C])\n                valid_investigations = [True] * N\n                for i in range(N):\n                    if i in valid_investigations:\n                        suspects = investigations[i][0]\n                        player = investigations[i][1]\n                        reply = investigations[i][2]\n                        if player == 1:\n                            if len(suspects) != reply:\n                                valid_investigations[i] = False\n                        else:\n                            if len(suspects) == reply:\n                                valid_investigations[i] = False\n                            for suspect in suspects:\n                                if suspect in circle_suspects:\n                                    circle_suspects.remove(suspect)\n                if all(valid_investigations):\n                    count += 1\n    return count\n"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, *investigations = stdin.split('\\n')\n    N = int(N)\n    count = 0\n    if N == 0:\n        return 26**3\n    for investigation in investigations:\n        suspect1, suspect2, player, reply = investigation.split()\n        player = int(player)\n        reply = int(reply)\n        count += (player - 1) * (reply + 1)\n    return 26**3 - count"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    black_vienna_circle = set()\n    possible_suspects = set(string.ascii_uppercase)\n\n    for i in range(1, n + 1):\n        card1, card2, player, reply = input_data[i].split()\n        player = int(player)\n        reply = int(reply)\n\n        if player == 1:\n            possible_suspects.remove(card1[0])\n            possible_suspects.remove(card2[0])\n        elif player == 2:\n            black_vienna_circle.add(card1[0])\n            black_vienna_circle.add(card2[0])\n\n        if len(black_vienna_circle) == 3:\n            break\n\n    if len(black_vienna_circle) < 3:\n        if len(possible_suspects) == 0:\n            return \"No solution\"\n        else:\n            return 0\n\n    return math.prod(len(possible_suspects) - 2 * i for i in range(3))"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, *investigations = stdin.split('\\n')\n    N = int(N)\n    if N == 0:\n        return \"2600\"\n\n    # 26! = 26 * 25 * ... * 2 * 1\n    count = 26\n    for i in range(2, N + 1):\n        count *= i\n\n    # Since the player can choose any 3 suspects, we need to divide the total count by 3!\n    count //= 6\n\n    # Count the number of solutions\n    solutions = 0\n    for i in range(N):\n        suspect1, suspect2, player, reply = investigations[i].split()\n        suspect1, suspect2, player, reply = suspect1.upper(), suspect2.upper(), int(player), int(reply)\n\n        # If both suspects are in the player's hand, the player can choose any 3 suspects\n        if reply == 2:\n            solutions += count\n        # If only one suspect is in the player's hand, the remaining 2 suspects must be in the circle\n        elif reply == 1:\n            solutions *= 2\n            count -= 2\n        # If no suspects are in the player's hand, the remaining 3 suspects must be in the circle\n        elif reply == 0:\n            solutions *= 6\n            count -= 6\n\n    # Return the number of solutions\n    return str(solutions)"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    investigations = [list(map(str, input().split())) for _ in range(N)]\n    suspects = set(chr(i) for i in range(ord('A'), ord('Z') + 1))\n    circles = []\n\n    for i, j, reply in investigations:\n        if reply == 2:\n            circles.append(set(suspects) - set(j, i))\n        elif reply == 1:\n            circles.append(set(j) | set(i))\n            circles.append(set(j) - set(i))\n        else:\n            circles.append(set(suspects))\n            circles.append(set())\n\n    admissible_solutions = 1\n    for circle in circles:\n        suspects &= circle\n        if not suspects:\n            return 0\n        elif len(suspects) == 3:\n            admissible_solutions = 0\n\n    return factorial(26) // factorial(3) // admissible_solutions\n\ndef"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def process_line(line: str) -> (str, int):\n        letter1, letter2, player, reply = line.split()\n        return (letter1 + letter2, int(player), int(reply))\n\n    investigations = []\n    n = int(stdin.split('\\n', 1)[0])\n    for line in stdin.split('\\n')[1:]:\n        investigations.append(process_line(line))\n\n    def count_solutions(suspects: set, circle: set, used: set) -> int:\n        if len(suspects) == 3:\n            return 1\n        if len(used) == n:\n            return 0\n\n        count = 0\n        for i, (suspect, player, reply) in enumerate(investigations[used]):\n            if suspect in circle:\n                continue\n\n            if player == 2:\n                new_circle = circle.copy()\n                new_circle.add(suspect)\n                new_used = used.copy()\n                new_used.add(i)\n                count += count_solutions(suspects, new_circle, new_used)\n            elif reply == 1:\n                new_suspects = suspects.copy()\n                new_suspects.add(suspect)\n                count += count_solutions(new_suspects, circle, used)\n\n        return count\n\n    result = count_solutions(set(), set(), set())\n    return str(result)\n"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    investigations = [line.split() for line in stdin.split(\"\\n\")[1:]]\n\n    def count_solutions():\n        card_count = [26, 26]\n        black_vienna = set()\n\n        for suspect1, suspect2, player, reply in investigations:\n            if int(player) == 1:\n                card_count[0] -= int(reply)\n                card_count[1] -= int(reply)\n            else:\n                card_count[0] -= int(reply)\n                card_count[1] -= int(reply)\n\n            if int(reply) == 2:\n                black_vienna.add(suspect1)\n                black_vienna.add(suspect2)\n\n            if int(reply) == 1:\n                if suspect1 not in black_vienna:\n                    black_vienna.add(suspect1)\n                if suspect2 not in black_vienna:\n                    black_vienna.add(suspect2)\n\n            if int(reply) == 0:\n                if suspect1 not in black_vienna:\n                    black_vienna.add(suspect1)\n                if suspect2 not in black_vienna:\n                    black_vienna.add(suspect2)\n\n        return card_count[0] * card_count[1]\n\n    return str(count_solutions())"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    player1_cards = set(input_data[1].split()[0] for i in range(N))\n    player2_cards = set(input_data[1].split()[0] for i in range(N, 2 * N))\n    possible_circles = 26\n    for i in range(N):\n        player1_reply = input_data[i + 1].split()[1]\n        player2_reply = input_data[i + 1].split()[2]\n        if int(player1_reply) == 1:\n            possible_circles -= len(player1_cards.intersection(player2_cards))\n        if int(player2_reply) == 1:\n            possible_circles -= len(player1_cards.intersection(player2_cards))\n    return possible_circles"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n    replies = {}\n\n    for i in range(1, N + 1):\n        suspect1, suspect2, player, reply = input_data[i].split()\n        replies.setdefault((suspect1, suspect2), {}).setdefault(int(player), int(reply))\n\n    def count_admissible_solutions(replies):\n        count = 0\n        for (suspect1, suspect2), replies_dict in replies.items():\n            if replies_dict.get(1) == 2:\n                count += 25\n                continue\n            if replies_dict.get(2) == 2:\n                count += 25\n                continue\n            if replies_dict.get(1) == 1 and replies_dict.get(2) == 1:\n                count += 1\n        return count\n\n    return count_admissible_solutions(replies)"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(sequence: str) -> bool:\n        stack = []\n        for char in sequence:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def invert_segment(sequence: str, l: int, r: int) -> str:\n        left = sequence[:l]\n        right = sequence[l:]\n        inverted_right = right[::-1]\n        return left + inverted_right\n\n    def can_invert_to_valid(sequence: str) -> bool:\n        if is_valid(sequence):\n            return False\n\n        for i in range(1, len(sequence)):\n            if sequence[i] == '(':\n                continue\n            for j in range(i, -1, -1):\n                if sequence[j] == '(':\n                    break\n            if sequence[i:j+1] == ')':\n                inverted_sequence = invert_segment(sequence, j+1, i-1)\n                if is_valid(inverted_sequence):\n                    return True\n        return False\n\n    input_sequence = stdin.strip()\n    if can_invert_to_valid(input_sequence):\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(sequence: str) -> bool:\n        stack = []\n        for bracket in sequence:\n            if bracket == '(':\n                stack.append(bracket)\n            elif bracket == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def make_valid(sequence: str) -> bool:\n        stack = []\n        for i, bracket in enumerate(sequence):\n            stack.append(bracket)\n            while is_valid(sequence[:i] + stack):\n                if not stack:\n                    return True\n                stack.pop()\n        return is_valid(sequence)\n\n    if is_valid(stdin):\n        return \"possible\"\n    else:\n        if make_valid(stdin):\n            return \"possible\"\n        else:\n            return \"impossible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(brackets: str) -> bool:\n        stack = []\n        for b in brackets:\n            if b == '(':\n                stack.append(b)\n            elif b == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def make_valid(brackets: str) -> bool:\n        stack = []\n        for i, b in enumerate(brackets):\n            if b == '(':\n                stack.append(b)\n            elif b == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n            else:\n                raise ValueError(\"Invalid character\")\n        return not stack\n\n    def invert(brackets: str, l: int, r: int) -> str:\n        stack = []\n        inv_count = 0\n        for i, b in enumerate(brackets):\n            if b == '(':\n                stack.append(b)\n            elif b == ')':\n                if not stack or stack.pop() != '(':\n                    return \"impossible\"\n            else:\n                raise ValueError(\"Invalid character\")\n            if i == l - 1:\n                stack.append(b)\n            elif i == r:\n                if not stack or stack.pop() != '(':\n                    return \"impossible\"\n                inv_count += 1\n        return \"possible\" if inv_count <= 1 else \"impossible\"\n\n    n = len(stdin)\n    if n % 2 != 0:\n        return \"impossible\"\n\n    if is_valid(stdin):\n        return \"possible\"\n\n    if make_valid(stdin):\n        return \"possible\"\n\n    return invert(stdin, 1, n)\n"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(bracket_seq: str) -> bool:\n        stack = []\n        for b in bracket_seq:\n            if b == '(':\n                stack.append(b)\n            else:\n                if not stack or stack[-1] == ')':\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    def valid_inversion(bracket_seq: str, l: int, r: int) -> bool:\n        if l > r:\n            return False\n        left_brackets, right_brackets = 0, 0\n        for i, b in enumerate(bracket_seq):\n            if i < l:\n                continue\n            if i > r:\n                break\n            if b == '(':\n                left_brackets += 1\n            else:\n                right_brackets += 1\n        return left_brackets == right_brackets\n\n    bracket_seq = stdin.strip()\n    if is_valid(bracket_seq):\n        return \"possible\"\n    for i in range(len(bracket_seq)):\n        for j in range(i, len(bracket_seq)):\n            if valid_inversion(bracket_seq, i + 1, j):\n                return \"possible\"\n    return \"impossible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for char in stdin:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack:\n                return \"impossible\"\n            stack.pop()\n    if not stack:\n        return \"possible\"\n    return \"impossible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s: str) -> bool:\n        stack = []\n        for b in s:\n            if b == '(':\n                stack.append(b)\n            elif b == ')':\n                if not stack:\n                    return False\n                if stack[-1] == '(':\n                    stack.pop()\n                else:\n                    return False\n        return len(stack) == 0\n\n    def make_valid(s: str) -> bool:\n        def invert(s: str, l: int, r: int) -> str:\n            left, right = s[:l], s[l:]\n            left_brackets, left_chars = [], []\n            right_brackets, right_chars = [], []\n            for i, c in enumerate(left):\n                if c == '(':\n                    left_brackets.append(i)\n                elif c == ')':\n                    left_chars.append(i)\n            for i, c in enumerate(right):\n                if c == '(':\n                    right_chars.append(i)\n                elif c == ')':\n                    right_brackets.append(i)\n            left_brackets.reverse()\n            right_brackets.reverse()\n            for i in range(len(left_brackets)):\n                if left_brackets[i] < right_brackets[i]:\n                    left_chars[i], right_chars[i] = right_chars[i], left_chars[i]\n            left_brackets.reverse()\n            right_brackets.reverse()\n            inverted_left = ''.join(left_chars)\n            inverted_right = ''.join(right_chars)\n            return inverted_left + right_brackets[0] + inverted_right\n\n        stack = []\n        for b in s:\n            if b == '(':\n                stack.append(b)\n            elif b == ')':\n                if not stack:\n                    return False\n                if stack[-1] == '(':\n                    stack.pop()\n                else:\n                    if len(stack) == 1:\n                        return invert(s, stack[-1], stack[-1] + 1)\n                    else:\n                        return False\n        return len(stack) == 0\n\n    if is_valid(stdin):\n        return \"possible\"\n    else:\n        if make_valid(stdin):\n            return \"possible\"\n        else:\n            return \"impossible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    stack = []\n    for i in range(n):\n        if stdin[i] == '(':\n            stack.append(i)\n        elif stdin[i] == ')':\n            if not stack:\n                return \"impossible\"\n            l = stack.pop()\n            if i - l > 1:\n                if stdin[l:i+1] == \"()\":\n                    stdin = stdin[:l] + \")\" + stdin[i+1:]\n                else:\n                    return \"impossible\"\n    if stack:\n        return \"impossible\"\n    return \"possible\"\n\ndef"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(brackets: str) -> bool:\n        stack = []\n        for bracket in brackets:\n            if bracket == '(':\n                stack.append(bracket)\n            elif bracket == ')':\n                if not stack:\n                    return False\n                if stack[-1] == '(':\n                    stack.pop()\n                else:\n                    return False\n        return len(stack) == 0\n\n    def invert(brackets: str, l: int, r: int) -> str:\n        left, right = brackets[:l-1], brackets[l:]\n        return left + right[::-1]\n\n    def dfs(brackets: str, visited: set) -> bool:\n        if brackets in visited:\n            return False\n        visited.add(brackets)\n\n        if is_valid(brackets):\n            return True\n\n        for i in range(1, len(brackets)):\n            if brackets[i] == '(' and brackets[i-1] == ')':\n                result = dfs(invert(brackets, i, i+1), visited)\n                if result:\n                    return True\n\n        return False\n\n    brackets = stdin.strip()\n    visited = set()\n    result = dfs(brackets, visited)\n    return \"possible\" if result else \"impossible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s: str) -> bool:\n        stack = []\n        for bracket in s:\n            if bracket == '(':\n                stack.append(bracket)\n            else:\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    def make_valid(s: str) -> bool:\n        left_count = s.count('(')\n        right_count = s.count(')')\n        if left_count == right_count:\n            return True\n        if left_count > right_count:\n            return False\n        return True\n\n    def is_possible(s: str, l: int, r: int) -> bool:\n        if not make_valid(s[:l] + s[l:r][::-1] + s[r:]):\n            return False\n        return True\n\n    def bracket_sequence(s: str) -> str:\n        n = len(s)\n        for l in range(1, n + 1):\n            for r in range(l, n + 1):\n                if is_possible(s, l, r):\n                    return \"possible\"\n        return \"impossible\"\n\n    return bracket_sequence(stdin)\n"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(brackets: str) -> bool:\n        stack = []\n        for b in brackets:\n            if b == '(':\n                stack.append(b)\n            elif b == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return len(stack) == 0\n\n    def is_valid_inversion(brackets: str, l: int, r: int) -> bool:\n        stack = []\n        for i, b in enumerate(brackets):\n            if b == '(':\n                stack.append(b)\n            elif b == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n            if i == r:\n                break\n        return is_valid(brackets[:l] + brackets[l+1:r].replace('(', ')' if brackets[l] == ')' else '(') + brackets[r+1:] + brackets[l])\n\n    brackets = stdin.strip()\n    if is_valid(brackets):\n        return \"possible\"\n    for i in range(1, len(brackets)):\n        for j in range(i+1, len(brackets)+1):\n            if is_valid_inversion(brackets, i, j):\n                return \"possible\"\n    return \"impossible\""
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    timetable = [tuple(map(int, stdin.split()[2:])) for _ in range(M)]\n\n    def check_delay(start_time, station, end_time):\n        for train in timetable:\n            if train[0] == station and train[1] <= start_time <= train[2] - L and train[1] <= end_time <= train[2] - L:\n                return True\n        return False\n\n    start_time = 1800\n    while check_delay(start_time, 1, start_time + 1800):\n        start_time += 1\n\n    return str(start_time) if start_time <= 86400 else \"impossible\""
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_train(start_time: int, delay: int) -> tuple:\n        for x in range(1, N + 1):\n            for s, t, l in trains[x]:\n                if s <= start_time and start_time + 1800 <= t + delay:\n                    return x, s\n        return None, None\n\n    def is_possible(start_time: int, delay: int) -> bool:\n        return start_time + 1800 + delay <= 1800\n\n    N, M = map(int, stdin.split()[0:2])\n    trains = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        x, s, t, l = map(int, stdin.split()[1:5])\n        trains[x].append((s, t, l))\n\n    start_time = 1800\n    while not is_possible(start_time, 0):\n        start_time += 1\n\n    while True:\n        if is_possible(start_time, 0):\n            break\n        next_train, next_start_time = find_train(start_time, 0)\n        if next_train is None:\n            return \"impossible\"\n        start_time = next_start_time\n\n    return start_time\n"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    delays = []\n    for _ in range(M):\n        X, S, T, L = map(int, input().split())\n        delays.append((S + L, T + L))\n    \n    delays.sort()\n    earliest_start = 0\n    for delay in delays:\n        if delay[0] - earliest_start >= 1800:\n            return earliest_start\n        earliest_start = delay[1]\n    \n    return \"impossible\"\n\nprint(solution(\"\"\"2 3\n1 1800 9000 1800\n1 2000 9200 1600\n1 2200 9400 1400\"\"\"))\n\nprint(solution(\"\"\"2 2\n1 1800 3600 1800\n1 1900 3600 1600\"\"\"))"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    timetable = []\n    for _ in range(M):\n        X, S, T, L = map(int, input().split())\n        timetable.append((X, S, T, L))\n    \n    timetable.sort(key=lambda x: (x[0], x[1], x[2]))\n    start_stations = [t[0] for t in timetable]\n    start_station_indices = [i for i, x in enumerate(start_stations) if x == 1]\n    \n    for index in start_station_indices:\n        start_time = timetable[index][1] + timetable[index][3]\n        for i in range(index+1, index+N-1):\n            if timetable[i][0] == timetable[i+1][0]:\n                continue\n            delay = timetable[i][1] + timetable[i][3] - timetable[i-1][2]\n            next_start_time = timetable[i][1] + delay\n            if next_start_time - start_time < 1800:\n                start_time = next_start_time\n            else:\n                break\n        else:\n            return start_time\n        \n    return \"impossible\"\n"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N, M = map(int, input_list[0].split())\n    timetable = [tuple(map(int, input_list[i+1].split())) for i in range(M)]\n\n    def is_possible(start_time: int) -> bool:\n        for X, S, T, L in timetable:\n            if start_time + L <= S:\n                continue\n            if start_time + L >= T:\n                return False\n            next_time = S - start_time - L\n            if next_time >= 1800:\n                return False\n        return True\n\n    def find_start_time():\n        start_time = 1800\n        while not is_possible(start_time):\n            start_time += 1\n            if start_time >= 1800 + 3600 * (N-1):\n                return \"impossible\"\n        return start_time\n\n    return find_start_time()"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    timetable = []\n    for _ in range(M):\n        X, S, T, L = map(int, stdin.split()[2:6])\n        timetable.append((X, S + L, T + L))\n    timetable.sort(key=lambda x: (x[0], x[1]))\n\n    def is_possible(start_time: int) -> bool:\n        trains = [0] * N\n        for X, S, T in timetable:\n            if trains[X] < S:\n                trains[X] = S\n            if trains[X + 1] > T:\n                trains[X + 1] = T\n        return trains[1] - start_time <= 1800\n\n    for start_time in range(0, 86400, 1800):\n        if is_possible(start_time):\n            return start_time\n    return \"impossible\"\n"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    timetable = [list(map(int, input().split())) for _ in range(M)]\n\n    timetable.sort(key=lambda x: x[2] - x[1] - x[3])\n\n    for i in range(M):\n        for j in range(i + 1, M):\n            if timetable[i][0] != timetable[j][0] and timetable[i][1] < timetable[j][2] - 1800 and timetable[i][3] < timetable[j][1] - 1800:\n                return str(timetable[i][1] - 1800)\n\n    return \"impossible\"\n\ninput_string = \"2 3\\n1 1800 9000 1800\\n1 2000 9200 1600\\n1 2200 9400 1400\"\noutput = solution(input_string)\nprint(output) "
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    timetable = []\n    for _ in range(M):\n        X, S, T, L = map(int, input().split())\n        timetable.append((X, S, T, L))\n\n    # Sort timetable by station, then by time\n    timetable.sort(key=lambda x: (x[0], x[1]))\n\n    # Initialize earliest start time for each station\n    earliest_start_time = [0] * N\n    for X, S, T, L in timetable:\n        earliest_start_time[X] = max(earliest_start_time[X], S + L)\n\n    # Find the earliest start time for station N\n    for X, S, T, L in reversed(timetable):\n        if X == N - 1:\n            earliest_start_time[N - 1] = max(earliest_start_time[N - 1], S + L)\n        elif earliest_start_time[X + 1] - T >= 1800:\n            earliest_start_time[X] = max(earliest_start_time[X], earliest_start_time[X + 1] - 1800)\n\n    # Check if there's a valid start time for the journey\n    for start_time in earliest_start_time:\n        if start_time >= 1800:\n            return str(start_time)\n\n    return \"impossible\"\n\ndef"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    timetable = []\n\n    for _ in range(M):\n        X, S, T, L = map(int, input().split())\n        timetable.append((X, S, T, L))\n\n    timetable.sort(key=lambda x: (x[0], x[2]))\n\n    start_time = 0\n    for i in range(M):\n        X, S, T, L = timetable[i]\n        if start_time == 0:\n            start_time = S\n        elif start_time < S:\n            break\n        else:\n            start_time += T + L - start_time % (T + L)\n            start_time -= start_time % (T + L)\n\n    if start_time < 1800:\n        return \"impossible\"\n    else:\n        return start_time"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    timetable = [tuple(map(int, stdin.split()[2:])) for _ in range(M)]\n\n    def is_possible(start_time: int, X: int, S: int, T: int, L: int) -> bool:\n        return start_time + L <= T and start_time + L + (X + 1 - X) * 1800 <= S\n\n    earliest_start_time = 1800\n    for X, S, T, L in timetable:\n        if not is_possible(earliest_start_time, X, S, T, L):\n            return \"impossible\"\n        earliest_start_time = max(earliest_start_time, S - (X + 1 - X) * 1800)\n\n    return str(earliest_start_time)\n\ninput_data = \"\"\"2 3\n1 1800 9000 1800\n1 2000 9200 1600\n1 2200 9400 1400\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    team_size = n\n    total_teams = m\n    \n    # Initialize player lists\n    players = [f'{chr(64+i)}{j+1}' for i in range(1, total_teams+1) for j in range(team_size)]\n    total_players = len(players)\n    \n    # Construct playing schedule\n    playing_schedule = []\n    for round_number in range(1, (total_players * (total_players-1)) // 2 + 1):\n        games_in_round = []\n        for i in range(total_players):\n            for j in range(i+1, total_players):\n                games_in_round.append(f'{players[i]}-{players[j]}')\n        playing_schedule.append(' '.join(games_in_round))\n    \n    # Ensure no player has a bye in more than 1 round\n    for i in range(total_players):\n        bye_count = sum(1 for game in playing_schedule if players[i] in game)\n        if bye_count > 1:\n            # If a player has a bye in more than 1 round, swap them with another player\n            # and repeat until the bye count is less than or equal to 1\n            other_player_index = i + bye_count // 2 + 1\n            if other_player_index >= total_players:\n                other_player_index -= total_players\n            players[i], players[other_player_index] = players[other_player_index], players[i]\n            bye_count = sum(1 for game in playing_schedule if players[i] in game)\n            if bye_count > 1:\n                # If the swap still results in a bye count greater than 1, the problem is unsolvable\n                return \"Unable to construct a schedule with no byes in more than 1 round.\"\n    \n    return '\\n'.join(playing_schedule)"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    players = [(f\"{chr(ord('A') + i // n)}{i % n + 1}\") for i in range(n * m)]\n    \n    # Create rounds\n    rounds = []\n    for i in range(1, m):\n        round_games = []\n        for player in players[i * n:(i+1) * n]:\n            for opponent in players[:i * n] + players[(i+1) * n:]:\n                round_games.append(f\"{player}-{opponent}\")\n        rounds.append(round_games)\n    \n    # Add byes\n    for i in range(m, n * m):\n        player = players[i]\n        bye_round = i // n\n        rounds[bye_round].append(f\"{player}-Bye\")\n    \n    # Output rounds\n    output = []\n    for i, round_games in enumerate(rounds):\n        output.append(f\"Round {i+1}: \" + \" \".join(round_games))\n    \n    return \"\\n\".join(output)"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.strip().split()\n    n, m = map(int, input_data)\n    if n * m > 100:\n        return \"Invalid input\"\n    players = [(f\"{chr(i+65)}{j+1}\") for i in range(m) for j in range(n)]\n    games = []\n    for i in range(m):\n        for j in range(n):\n            player1 = players[i*n+j]\n            for k in range(m):\n                for l in range(n):\n                    if k == i and l == j:\n                        continue\n                    player2 = players[k*n+l]\n                    games.append(f\"{player1}-{player2}\")\n    rounds = []\n    for i in range(0, len(games), m*n):\n        round_games = games[i:i+m*n]\n        rounds.append(round_games)\n    return \"\\n\".join([\" \".join(round_games) for round_games in rounds])"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    schedule = []\n\n    for i in range(m):\n        team_schedule = []\n        for j in range(n):\n            player_schedule = []\n            for k in range(m):\n                if k == i:\n                    continue\n                player_schedule.append(f\"{chr(ord('A')+i*n+j+1)}{chr(ord('A')+k*n+j+1)}\")\n            team_schedule.extend(player_schedule)\n        schedule.append(team_schedule)\n\n    result = []\n    for i in range(m-1):\n        for game in schedule[i]:\n            result.append(game)\n        result.append(\"\")\n\n    for game in schedule[-1]:\n        result.append(game)\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    total_rounds = (m - 1) * n + 1\n    rounds = []\n\n    for i in range(1, total_rounds + 1):\n        games = []\n        for player in range(1, n + 1):\n            for team in range(1, m + 1):\n                if team == player:\n                    continue\n                opponent = (player + (team - 1) * n) % (m * n) + 1\n                opponent_team = (opponent - 1) // n + 1\n                games.append(f\"A{player}-B{opponent_team} B{opponent_team}-A{player}\")\n        rounds.append(\" \".join(games))\n\n    return \"\\n\".join(rounds)\n"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    teams = [f\"A{i}\" for i in range(1, n+1)] + [f\"B{i}\" for i in range(1, n+1)]\n    max_rounds = (m-1) * n + 1\n    rounds = []\n    \n    # iterate over teams\n    for i in range(len(teams)):\n        # iterate over remaining teams\n        for j in range(i+1, len(teams)):\n            # iterate over rounds\n            for k in range(max_rounds):\n                # check if round can be filled with games between i and j teams\n                if k <= (m-1) * n - 1:\n                    round_teams = [f\"{teams[i]}{j+1}\", f\"{teams[j]}{i+1}\"]\n                    rounds.append(round_teams)\n                    break\n    \n    return \"\\n\".join([\" \".join([f\"{team[0]}-{team[1]}\" for team in round_]) for round_ in rounds])\n"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = []\n    \n    # Generate all possible pairings for each player\n    all_pairings = [(i, j) for i in range(1, n+1) for j in range(1, n+1) if i != j]\n    \n    # Divide the players into teams\n    teams = [list(range(i, i+n)) for i in range(1, m*n+1, n)]\n    \n    # Iterate through each round\n    for round in range(1, (m-1) * n + 1):\n        round_pairings = []\n        \n        # Iterate through each team and add their pairings to the round\n        for team in teams:\n            for player in team:\n                if round == 1:\n                    # First round, each player plays against all others\n                    for target_player in team:\n                        if player != target_player:\n                            round_pairings.append((player, target_player))\n                else:\n                    # Not first round, each player plays against their opponent from the previous round\n                    opponent = all_pairings.pop()\n                    round_pairings.append((player, opponent[round%2]))\n        \n        result.append(round_pairings)\n    \n    # Format the output\n    for i in range(len(result)):\n        output = []\n        for pairing in result[i]:\n            output.append(f\"{pairing[0]}{pairing[1]}\")\n        print(\" \".join(output))"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    players = [\"A\" + str(i) for i in range(1, n + 1)] + [\"B\" + str(i) for i in range(1, n + 1)]\n    rounds = []\n    for i in range(m - 1):\n        for j in range(n):\n            rounds.append(f\"{players[i*n+j]}-{players[(i+1)*n+j]}\")\n            players.remove(players[(i+1)*n+j])\n    for i in range(m):\n        for j in range(n):\n            rounds.append(f\"{players[i*n+j]}-{players[(i+1)*n+j]}\")\n            players.remove(players[(i+1)*n+j])\n    return \"\\n\".join(rounds)\n"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n * m > 100:\n        return \"Invalid input\"\n    \n    # Create the teams and players\n    teams = [f\"Team{i}\" for i in range(1, m + 1)]\n    players = [f\"{team}{i}\" for team in teams for i in range(1, n + 1)]\n    \n    # Initialize the playing schedule\n    schedule = []\n    \n    # Iterate through each player and create a game for each player except themselves\n    for i, player in enumerate(players):\n        games = [f\"{player}-{other}\" for j, other in enumerate(players) if i != j]\n        schedule.append(games)\n    \n    # Divide the schedule into rounds\n    rounds = [schedule[i:i + n] for i in range(0, len(schedule), n)]\n    \n    # Ensure that no player has a bye in more than 1 round\n    while len(rounds) > (m - 1) * n + 1:\n        # Find the player with the most rounds with a bye\n        bye_count = [sum(1 for game in round_ if \"Bye\" in game) for round_ in rounds]\n        most_rounds_with_bye = max(bye_count)\n        \n        # Remove the round with the most rounds with a bye\n        rounds.remove(rounds[bye_count.index(most_rounds_with_bye)])\n    \n    # Format the output\n    output = \"\\n\".join([\" \".join(round_) for round_ in rounds])\n    return output"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    games_per_player = (m - 1) * n\n    rounds = (m - 1) * n + 1\n    players = ['A' + str(i) for i in range(1, n + 1)]\n    teams = [players[i:i + n] for i in range(0, n, n)]\n\n    result = []\n    for round_num in range(1, rounds + 1):\n        round_games = []\n        for player in players:\n            for team in teams:\n                if player not in team:\n                    opponent = team[(team.index(player) + 1) % n]\n                    round_games.append(f\"{player}-{opponent}\")\n        result.append(' '.join(round_games))\n\n    return '\\n'.join(result)\n\ninput_str = \"3 2\"\noutput_str = solution(input_str)\nprint(output_str)\n\ninput_str = \"2 3\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(i: int, j: int, table_size: int) -> bool:\n        for di in range(table_size):\n            for dj in range(table_size):\n                if layout[i + di][j + dj] == 'X':\n                    return False\n        return True\n\n    def get_perimeter(i: int, j: int, table_size: int) -> int:\n        perimeter = 0\n        for di in range(table_size):\n            for dj in range(table_size):\n                if not (di == 0 and dj == 0) and layout[i + di][j + dj] == '.':\n                    perimeter += 1\n        return perimeter\n\n    R, C, layout = stdin.split('\\n')\n    R, C = int(R), int(C)\n\n    for i in range(R):\n        if len(layout[i]) != C:\n            return \"Invalid input\"\n\n    table_size = 1\n    while True:\n        for i in range(R - table_size + 1):\n            for j in range(C - table_size + 1):\n                if is_valid(i, j, table_size) and get_perimeter(i, j, table_size) <= R + C:\n                    return get_perimeter(i, j, table_size)\n        table_size += 1"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    apartment = stdin.split('\\n')[1:]\n    table_length = min(R, C)\n    table_width = max(R, C)\n    free_squares = 0\n\n    for row in apartment:\n        free_squares += row.count('.')\n\n    for side in range(1, table_length + 1):\n        free_squares -= side\n\n    for side in range(table_length, table_width):\n        free_squares -= 2\n\n    if table_length == R:\n        free_squares -= (table_width - 2)\n    elif table_length == C:\n        free_squares -= (table_width - 2)\n\n    guests = free_squares // 2\n\n    return str(guests)\n"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split(','))\n    free_squares = stdin.split()[1:]\n    free_squares = [''.join(free_squares[i:i+C]) for i in range(0, len(free_squares), C)]\n    free_squares = [list(row) for row in free_squares]\n\n    for i in range(R):\n        for j in range(C):\n            if free_squares[i][j] == 'X':\n                free_squares[i][j] = 0\n            else:\n                free_squares[i][j] = 1\n\n    guests_count = 0\n    for i in range(R):\n        for j in range(C):\n            if free_squares[i][j] == 1:\n                perimeter = 2 * (R + C - 2)\n                if perimeter % 2 == 0:\n                    guests_count += perimeter / 2\n                else:\n                    guests_count += (perimeter + 1) / 2\n    return guests_count"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_people(table_dimensions, apartment_dimensions):\n        people_count = 0\n        for i in range(table_dimensions[0]):\n            for j in range(table_dimensions[1]):\n                if i == 0 or j == 0 or i == table_dimensions[0] - 1 or j == table_dimensions[1] - 1:\n                    people_count += 1\n                elif i == j or (i + 1 == table_dimensions[0] and j == table_dimensions[1] - 1) or (j + 1 == table_dimensions[1] and i == table_dimensions[0] - 1):\n                    people_count += 1\n        return min(people_count, (apartment_dimensions[0] - table_dimensions[0] + 1) * (apartment_dimensions[1] - table_dimensions[1] + 1))\n\n    R, C = map(int, stdin.split())\n    apartment_dimensions = [R, C]\n    table_dimensions = [1, 1]\n    for i in range(R):\n        for j in range(C):\n            if stdin[i * C + j] == 'X':\n                continue\n            if i + 1 < R and stdin[(i + 1) * C + j] != 'X':\n                table_dimensions[0] += 1\n            if j + 1 < C and stdin[i * C + j + 1] != 'X':\n                table_dimensions[1] += 1\n            if table_dimensions[0] * table_dimensions[1] > apartment_dimensions[0] * apartment_dimensions[1]:\n                return 0\n    return count_people(table_dimensions, apartment_dimensions)"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    apartment = stdin.split('\\n')[1:]\n    free_squares = [(i, j) for i in range(R) for j in range(C) if apartment[i][j] == '.']\n    perimeters = [sum(1 for _ in (itertools.product([-1, 0, 1], [-1, 0, 1]))) for i, j in free_squares]\n    max_guests = 0\n    for i, j in free_squares:\n        guests = 0\n        for dx, dy in itertools.product([-1, 0, 1], [-1, 0, 1]):\n            if 0 <= i+dx < R and 0 <= j+dy < C and apartment[i+dx][j+dy] == '.' and (i+dx, j+dy) in free_squares:\n                guests += 1\n        max_guests = max(max_guests, guests)\n    return str(max_guests)\n"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    apartment = stdin.split()[2:]\n    \n    # Initialize the matrix\n    matrix = [[0 for j in range(C)] for i in range(R)]\n    \n    # Fill the matrix with the given input\n    for i in range(R):\n        for j in range(C):\n            if apartment[i][j] == '.':\n                matrix[i][j] = 1\n    \n    # Find the number of people Mirko can invite to dinner\n    count = 0\n    for i in range(R):\n        for j in range(C):\n            if matrix[i][j] == 1:\n                count += 1\n                if count == 4:\n                    break\n        if count == 4:\n            break\n    return str(count)"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, input().split())\n    apartment = [input() for _ in range(R)]\n    free_squares = 0\n    for row in apartment:\n        free_squares += row.count('.')\n    guests = min(free_squares // 2, R * C // 4)\n    return guests\n\n\ninput_data = '''2 2\n..\n..\n4 4\nX.XX\nX..X\n..X.\n..XX'''\n\nfor case in input_data.split('\\n\\n'):\n    if case:\n        print(solution(case))\n"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0])\n    layout = stdin.split()[1:]\n    layout = [list(row) for row in layout]\n    \n    def perimeter(row, col):\n        return (layout[row-1][col] == '.' and layout[row][col-1] == '.')\n    \n    count = 0\n    for r in range(R):\n        for c in range(C):\n            if perimeter(r, c):\n                count += 1\n    \n    return str(count)\n\ndef"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C, layout = 0, 0, []\n    for i, line in enumerate(stdin.split('\\n')):\n        if i == 0:\n            R, C = map(int, line.split())\n        else:\n            layout.append(list(line))\n\n    # Find all possible table sizes\n    possible_sizes = set()\n    for r in range(1, R + 1):\n        for c in range(1, C + 1):\n            if r * c <= R * C:\n                possible_sizes.add((r, c))\n\n    # Find all possible table positions\n    possible_positions = set()\n    for r1 in range(R):\n        for c1 in range(C):\n            if layout[r1][c1] == '.':\n                for size in possible_sizes:\n                    r2, c2 = r1 + size[0] - 1, c1 + size[1] - 1\n                    if r2 < R and c2 < C:\n                        for r3 in range(r1, r2 + 1):\n                            for c3 in range(c1, c2 + 1):\n                                if layout[r3][c3] == '.':\n                                    possible_positions.add((r1, c1, r2, c2))\n\n    # Find the largest possible table size that fits in the apartment\n    max_size = max(possible_sizes, key=lambda x: x[0] * x[1])\n\n    # Calculate the number of guests Mirko can invite\n    guests = sum(r + c - 1 for r, c in possible_positions if r1 <= r <= r2 and c1 <= c <= c2 and (r - r1 + c - c1) % max_size[1] == 0)\n\n    return str(guests)"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    dimensions, layout = stdin.split(\"\\n\")\n    rows, cols = map(int, dimensions.split())\n    table_perimeter = 2 * (rows + cols - 2)\n    free_squares = 0\n    for i in range(rows):\n        for j in range(cols):\n            if layout[i][j] == \".\":\n                free_squares += 1\n    guests = min(free_squares, table_perimeter)\n    return str(guests)"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    cards = []\n    for i in range(1, n + 1):\n        card = list(map(int, input_list[i].split()))\n        cards.append(card)\n\n    def get_card_at_pos(pos):\n        for card in cards:\n            if card[0] == pos[0] and card[1] == pos[1]:\n                return card\n        return None\n\n    def get_jumps(card):\n        jumps = []\n        for i in range(-card[2], card[2] + 1):\n            for j in range(-card[3], card[3] + 1):\n                jumps.append((i, j))\n        return jumps\n\n    def is_valid_move(pos, new_pos):\n        card = get_card_at_pos(pos)\n        jumps = get_jumps(card)\n        return (new_pos[0], new_pos[1]) in jumps\n\n    def dp_reach_0(pos, visited, prices):\n        if pos == (0, 0):\n            return 0\n        if (pos[0], pos[1], prices) in visited:\n            return visited[(pos[0], pos[1], prices)]\n\n        visited[(pos[0], pos[1], prices)] = float('inf')\n        for card in cards:\n            if card[0] == pos[0] and card[1] == pos[1]:\n                for jump in get_jumps(card):\n                    new_pos = (pos[0] + jump[0], pos[1] + jump[1])\n                    if is_valid_move(pos, new_pos) and prices - card[4] >= 0:\n                        visited[(pos[0], pos[1], prices)] = min(visited[(pos[0], pos[1], prices)], prices - card[4] + dp_reach_0(new_pos, visited, prices - card[4]))\n\n        return visited[(pos[0], pos[1], prices)]\n\n    if dp_reach_0((3, 3, 0), {}, 0) == float('inf'):\n        return -1\n    else:\n        return dp_reach_0((3, 3, 0), {}, 0)"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_cost(card_list, tarot_card_prices):\n        def get_offset_values(card_location, tarot_card):\n            offset_values = [(card_location[0] - tarot_card[0], card_location[1] - tarot_card[1]), (card_location[0] + tarot_card[0], card_location[1] - tarot_card[1]), (card_location[0] - tarot_card[0], card_location[1] + tarot_card[1]), (card_location[0] + tarot_card[0], card_location[1] + tarot_card[1]), (card_location[0] + tarot_card[1], card_location[1] - tarot_card[0]), (card_location[0] - tarot_card[1], card_location[1] - tarot_card[0]), (card_location[0] + tarot_card[1], card_location[1] + tarot_card[0]), (card_location[0] - tarot_card[1], card_location[1] + tarot_card[0])]\n            return offset_values\n\n        def get_valid_offsets(card_location, tarot_card):\n            valid_offsets = []\n            offset_values = get_offset_values(card_location, tarot_card)\n            for offset in offset_values:\n                if offset[0] >= 0 and offset[1] >= 0 and (offset[0], offset[1]) not in card_list:\n                    valid_offsets.append(offset)\n            return valid_offsets\n\n        def get_new_card_list(card_list, tarot_card):\n            new_card_list = card_list.copy()\n            new_card_list.append(tarot_card)\n            return new_card_list\n\n        def get_minimum_cost(card_list, tarot_card_prices, target_location):\n            if len(card_list) == 1 and card_list[0][0] == target_location[0] and card_list[0][1] == target_location[1]:\n                return tarot_card_prices[card_list[0][4]]\n\n            min_cost = float('inf')\n            for card in card_list:\n                valid_offsets = get_valid_offsets(card, (0, 0))\n                for offset in valid_offsets:\n                    new_card_list = get_new_card_list(card_list, card)\n                    cost = tarot_card_prices[card[4]] + get_minimum_cost(new_card_list, tarot_card_prices, offset)\n                    min_cost = min(min_cost, cost)\n            return min_cost\n\n        return get_minimum_cost(card_list, tarot_card_prices, (0, 0))\n\n    n = int(stdin.readline())\n    card_list = []\n    for i in range(n):\n        card_data = list(map(int, stdin.readline().split()))\n        card_list.append(card_data)\n\n    tarot_card_prices = {(i, j, a, b, p): p for i, j, a, b, p in card_list}\n    min_cost = calculate_cost(card_list, tarot_card_prices)\n    return str(min_cost) if min_cost != float('inf') else '-1'\n\n\ninput_data = \"2\\n3 3 2 2 100\\n1 1 1 1 500\\n\"\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, *cards = stdin.split('\\n')\n    n = int(n)\n    tarot_cards = []\n    for card in cards:\n        r, c, a, b, p = map(int, card.split())\n        tarot_cards.append((r, c, a, b, p))\n\n    # Initialize the knight's position\n    knight_pos = tarot_cards[0][0], tarot_cards[0][1]\n\n    # Initialize the visited set\n    visited = set()\n    visited.add(str(knight_pos))\n\n    # Initialize the queue\n    queue = [(0, 0, 0)]\n\n    while queue:\n        current_cost, r, c = queue.pop(0)\n\n        if (r, c) == (0, 0):\n            return current_cost\n\n        for dr, dc, da, db, dp in tarot_cards:\n            new_r, new_c = r + dr, c + dc\n            new_a, new_b, new_p = da, db, dp\n\n            if 0 <= new_r < 1001 and 0 <= new_c < 1001 and str((new_r, new_c)) not in visited:\n                visited.add(str((new_r, new_c)))\n                queue.append((current_cost + new_p, new_r, new_c))\n\n    return -1"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    card_positions = []\n    for i in range(1, n+1):\n        card_positions.append(tuple(map(int, input_data[i].split())))\n    \n    return calculate_minimum_cost(card_positions)\n\ndef"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list.pop(0))\n    \n    if n == 0:\n        return \"-1\"\n    \n    tarot_cards = []\n    for i in range(n):\n        row = input_list.pop(0).split(\" \")\n        r, c, a, b, p = map(int, row)\n        tarot_cards.append((r, c, a, b, p))\n    \n    # Find minimum cost to reach (0, 0)\n    min_cost = float(\"inf\")\n    \n    def bfs(tarot_cards):\n        visited = set()\n        queue = [(0, 0, 0)]\n        \n        while queue:\n            r, c, cost = queue.pop(0)\n            if (r, c) == (0, 0):\n                nonlocal min_cost\n                min_cost = min(min_cost, cost)\n                continue\n            \n            for dr, dc in [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]:\n                new_r, new_c = r + dr, c + dc\n                if 0 <= new_r <= 10**9 and 0 <= new_c <= 10**9:\n                    for tarot_card in tarot_cards:\n                        tarot_r, tarot_c, _, _, card_cost = tarot_card\n                        if (new_r, new_c) == (tarot_r, tarot_c):\n                            if (new_r, new_c) not in visited:\n                                queue.append((new_r, new_c, cost + card_cost))\n                                visited.add((new_r, new_c))\n    \n    bfs(tarot_cards)\n    return min_cost if min_cost != float(\"inf\") else \"-1\""
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_offset(a: int, b: int) -> tuple:\n        return (-a, -b) if a < 0 else (a, -b) if b < 0 else (b, a)\n\n    def get_jumps(card: tuple, knight: tuple) -> list:\n        r1, c1, a, b, _ = card\n        r2, c2 = knight\n        offsets = [get_offset(a, b) for _ in range(4)]\n        jumps = [(r2 + r1 + r, c2 + c1 + c) for r, c in offsets]\n        return [(r, c) for r, c in jumps if 0 <= r <= r2 + r1 and 0 <= c <= c2 + c1]\n\n    def min_cost(tarot_cards: list, knight: tuple) -> int:\n        queue = [(0, knight)]\n        visited = set([knight])\n        while queue:\n            cost, pos = queue.pop(0)\n            if pos == (0, 0):\n                return cost\n            for card in tarot_cards:\n                jumps = get_jumps(card, pos)\n                for jump in jumps:\n                    if jump not in visited:\n                        visited.add(jump)\n                        queue.append((cost + card[4], jump))\n        return -1\n\n    n = int(stdin.readline())\n    tarot_cards = []\n    for _ in range(n):\n        r, c, a, b, p = map(int, stdin.readline().split())\n        tarot_cards.append((r, c, a, b, p))\n\n    knight = (3, 3, 2, 2, 100)\n    result = min_cost(tarot_cards, knight)\n    return str(result)"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbors(r: int, c: int, a: int, b: int) -> List[Tuple[int, int]]:\n        return [(r + a, c + b), (r - a, c - b), (r + b, c - a), (r - b, c + a), (r + b, c + a), (r - b, c - a), (r + a, c - b), (r - a, c + b)]\n\n    def get_min_cost(r: int, c: int, a: int, b: int, p: int, visited: Set[Tuple[int, int]]) -> int:\n        if r == 0 and c == 0:\n            return p\n        min_cost = float('inf')\n        for neighbor_r, neighbor_c in get_neighbors(r, c, a, b):\n            if (neighbor_r, neighbor_c) not in visited:\n                min_cost = min(min_cost, get_min_cost(neighbor_r, neighbor_c, a, b, p, visited.union({(r, c)})))\n        return min_cost if min_cost != float('inf') else -1\n\n    n, *cards = stdin.split('\\n')\n    n = int(n)\n    cards = [tuple(map(int, card.split())) for card in cards]\n\n    initial_r, initial_c = cards[0][:2]\n    visited = set()\n    min_cost = float('inf')\n\n    for r, c, a, b, p in cards:\n        min_cost = min(min_cost, get_min_cost(r, c, a, b, p, visited))\n\n    return str(min_cost)\n"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return str(0)\n\n    def is_valid(x, y):\n        return -10**9 <= x <= 10**9 and -10**9 <= y <= 10**9\n\n    def move_cost(x, y):\n        return abs(x) + abs(y)\n\n    def next_positions(x, y, a, b):\n        return [(x - a, y - b), (x + a, y - b), (x - a, y + b), (x + a, y + b), (x + b, y + a), (x - b, y + a), (x + b, y - a), (x - b, y - a)]\n\n    def min_cost(positions, visited, cost_so_far, target_pos, target_price):\n        if pos == target_pos and card_price <= target_price:\n            return cost_so_far + card_price\n\n        for i in range(len(positions)):\n            if positions[i] in visited:\n                continue\n\n            x, y = positions[i]\n            a, b = tarot_cards[i][2], tarot_cards[i][3]\n            new_positions = next_positions(x, y, a, b)\n            for new_pos in new_positions:\n                if is_valid(new_pos[0], new_pos[1]) and (new_pos not in visited or cost_so_far + move_cost(x, y) + tarot_cards[i][4] < cost_so_far + move_cost(*new_pos) + min_cost(new_positions, visited | {new_pos}, cost_so_far + move_cost(x, y) + tarot_cards[i][4], target_pos, target_price)):\n                    min_cost = min_cost(new_positions, visited | {new_pos}, cost_so_far + move_cost(x, y) + tarot_cards[i][4], target_pos, target_price)\n                    if min_cost is not None:\n                        return min_cost\n\n        return None\n\n    input_data = stdin.split('\\n')[1:]\n    tarot_cards = [tuple(map(int, line.split())) for line in input_data]\n    target_pos = (0, 0)\n    target_price = float('inf')\n    positions = [(0, 0)]\n    visited = {(0, 0)}\n    cost_so_far = 0\n\n    for card_price in [card[4] for card in tarot_cards]:\n        if card_price <= target_price:\n            min_cost = min_cost(positions, visited, cost_so_far, target_pos, target_price)\n            if min_cost is not None:\n                target_price = card_price\n                cost_so_far = min_cost\n                continue\n            else:\n                return -1\n\n        min_cost = min_cost(positions, visited, cost_so_far, target_pos, target_price)\n        if min_cost is not None:\n            cost_so_far = min_cost\n            continue\n        else:\n            return -1\n\n    return cost_so_far\n"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def knight_jumps(a, b, r, c):\n        return [(-a, -b), (a, -b), (-a, b), (a, b), (b, a), (-b, a), (b, -a), (-b, -a)]\n\n    def move_and_jump(r, c, a, b, board, visited):\n        if (r, c) in visited:\n            return board[r][c]\n        min_cost = float('inf')\n        visited.add((r, c))\n        for jump in knight_jumps(a, b, r, c):\n            nr, nc = r + jump[0], c + jump[1]\n            if nr == 0 and nc == 0:\n                min_cost = min(min_cost, board[nr][nc])\n            else:\n                min_cost = min(min_cost, move_and_jump(nr, nc, jump[0], jump[1], board, visited))\n        return min_cost\n\n    def knight_path(n, cards):\n        board = [[float('inf') for _ in range(1001)] for _ in range(1001)]\n        visited = set()\n        for card in cards:\n            board[card[0]][card[1]] = card[4]\n        for card in cards:\n            if card[0] == 0 and card[1] == 0:\n                return card[4]\n            for jump in knight_jumps(card[2], card[3], card[0], card[1]):\n                nr, nc = card[0] + jump[0], card[1] + jump[1]\n                board[nr][nc] = min(board[nr][nc], card[4] + jump[0] * jump[1])\n                visited.add((nr, nc))\n        return min(move_and_jump(card[0], card[1], card[2], card[3], board, visited) for card in cards)\n\n    n = int(stdin.readline())\n    cards = []\n    for _ in range(n):\n        data = list(map(int, stdin.readline().split()))\n        cards.append(data)\n    return str(knight_path(n, cards))"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list.pop(0))\n    if n == 0:\n        return \"-1\"\n    tarot_cards = [tuple(map(int, input_list[i].split())) for i in range(n)]\n    # sort tarot cards by price\n    tarot_cards.sort(key=lambda x: x[4])\n\n    def can_reach(r, c, a, b, visited):\n        if (r, c) in visited:\n            return False\n        visited.add((r, c))\n        if r == 0 and c == 0:\n            return True\n        for i in range(-a, a+1):\n            for j in range(-b, b+1):\n                if can_reach(r+i, c+j, a, b, visited):\n                    return True\n        return False\n\n    min_cost = float('inf')\n    for card in tarot_cards:\n        r, c, a, b, p = card\n        if can_reach(r, c, a, b, set()):\n            min_cost = min(min_cost, p)\n        else:\n            min_cost = -1\n            break\n\n    return str(min_cost)\n"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, B = map(int, stdin.split())\n    B = str(B)\n    valid_subsets = set()\n\n    def is_valid(subset: str) -> bool:\n        if subset == \"0\":\n            return False\n        total = 0\n        for digit in subset:\n            total += int(digit)\n        return total % 3 == 0\n\n    def generate_valid_subsets(s: str) -> None:\n        if not s:\n            return\n        for i in range(len(s)):\n            if is_valid(s[:i+1]):\n                valid_subsets.add(s[:i+1])\n                generate_valid_subsets(s[i+1:])\n\n    generate_valid_subsets(B)\n    return len(valid_subsets) % (10**9 + 7)\n\ninput_str = \"3\\n361\"\nprint(solution(input_str))\n\ninput_str = \"2\\n11\"\nprint(solution(input_str)) "
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, B = map(int, stdin.split())\n    B = str(B)\n    valid_subsets = set()\n\n    def is_valid(subset: str) -> bool:\n        return subset == ''.join(sorted(subset)) and int(subset) % 3 == 0\n\n    for length in range(1, len(B) + 1):\n        for i in range(len(B) - length + 1):\n            subset = B[i:i + length]\n            if is_valid(subset):\n                valid_subsets.add(subset)\n\n    return str(len(valid_subsets) % (10**9 + 7))\n"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split('\\n'))\n    B = str(S)\n    valid = set()\n    for i in range(len(B)):\n        for j in range(i+1, len(B)+1):\n            subset = B[i:j]\n            if subset.startswith('0') or int(subset) % 3 == 0:\n                valid.add(subset)\n    return len(valid) % (10**9 + 7)\n"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    b_str = input_list[1]\n\n    def is_valid(s: str) -> bool:\n        for i in range(1, len(s)):\n            if int(s[:i]) * 3 != int(s[:i]) * 3 // 3 * 3:\n                return False\n        return True\n\n    def count_valid_subsets(b: int) -> int:\n        count = 0\n        for i in range(1, len(str(b)) + 1):\n            if is_valid(str(b)[:i]):\n                count += 1\n        return count\n\n    b = int(b_str)\n    return str(count_valid_subsets(b) % (10**9 + 7))"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    B = int(stdin.splitlines()[1])\n    \n    def valid_subset(num: int) -> bool:\n        if num == 0:\n            return False\n        while num > 0:\n            if num % 3 != 0:\n                return False\n            num //= 3\n        return True\n    \n    valid_subsets = 0\n    for i in range(1, B + 1):\n        if valid_subset(i):\n            valid_subsets += 1\n    \n    return str(valid_subsets % (10**9 + 7))\n\n\ndef"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    b_str = input_list[1]\n\n    def is_valid(s: str) -> bool:\n        try:\n            int(s)\n            return True\n        except ValueError:\n            return False\n\n    def num_valid_subsets(s: str) -> int:\n        def dfs(index: int, subset: str, count: int) -> int:\n            if index == len(s):\n                return 1 if is_valid(subset) else 0\n\n            return dfs(index + 1, subset + s[index], count) + dfs(index + 1, subset, count)\n\n        return dfs(0, \"\", 0) % (10**9 + 7)\n\n    return num_valid_subsets(b_str)\n"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, B = input().split()\n    B = str(int(B))\n\n    def is_valid(S):\n        for i in range(len(S)):\n            if S[i] == '0' and i > 0:\n                return False\n            if S[i] == '4' and i < len(S) - 1 and S[i+1] == '7':\n                return False\n        return True\n\n    def count_valid_subsets(B):\n        MOD = 10**9 + 7\n        valid_subsets = [0] * (len(B) + 1)\n        valid_subsets[0] = 1\n        for i in range(1, len(B)):\n            if B[i] == '4' and B[i-1] == '7':\n                continue\n            valid_subsets[i+1] = (valid_subsets[i-1] * 2) % MOD\n            if is_valid(B[:i+1]):\n                valid_subsets[i+1] = (valid_subsets[i+1] + valid_subsets[i]) % MOD\n        return valid_subsets[len(B)]\n\n    return str(count_valid_subsets(B))\n\n\ninput_data = \"\"\"3\n361\n2\n11\"\"\"\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, input().split())\n    valid_subsets = 0\n    if S == 0:\n        return str(valid_subsets)\n    if S % 3 == 0:\n        valid_subsets += 1\n    for i in range(1, len(str(S))):\n        if S % (10**i) == 0:\n            valid_subsets += 1\n    return str(valid_subsets % (10**9 + 7))\n"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    S = stdin.split('\\n')[1]\n\n    def valid_subset(s: str) -> bool:\n        if not s:\n            return True\n        for i in range(len(s)):\n            if i > 0 and s[i] == s[i - 1]:\n                continue\n            if valid_subset(s[:i] + s[i + 1:]):\n                return True\n        return False\n\n    count = 0\n    for i in range(1, len(S) + 1):\n        for subset in itertools.combinations(S, i):\n            if valid_subset(''.join(subset)):\n                count += 1\n\n    return str(count % (10**9 + 7))\n\ninput_string = '''3\n361'''\n\nprint(solution(input_string)) "
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    B = int(stdin.split('\\n')[1])\n    \n    # define a subset S of characters from B \"valid\" iff the characters in S can be concatenated together in some way to form a number with no leading zeros that is also divisible by 3\n    def is_valid(subset):\n        num = int(''.join(subset))\n        return num % 3 == 0 and num > 0\n    \n    # find all valid subsets of S and count them modulo 10^9 + 7\n    subsets = set()\n    for i in range(1, len(str(B))+1):\n        for subset in itertools.combinations(str(B), i):\n            if is_valid(subset):\n                subsets.add(subset)\n    \n    return str(len(subsets) % (10**9 + 7))\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(gas_stations: list, left: int, right: int) -> int:\n        if left > right:\n            return float('inf')\n        \n        mid = (left + right) // 2\n        total_cost = 0\n        current_gas = 0\n        \n        for i in range(mid, -1, -1):\n            current_gas += gas_stations[i][1]\n            total_cost += gas_stations[i][1] * (gas_stations[i][0] / 1000)\n            \n            if total_cost > g or current_gas > g:\n                return binary_search(gas_stations, mid + 1, right)\n        \n        return total_cost\n    \n    n, g = map(int, stdin.split()[0:2])\n    gas_stations = []\n    \n    for _ in range(n):\n        dist, cost = map(int, stdin.split()[2:4])\n        gas_stations.append((dist, cost))\n    \n    left, right = 0, n\n    min_cost = binary_search(gas_stations, left, right)\n    \n    return min_cost if min_cost != float('inf') else \"cancel road trip\""
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, g = map(int, input_list.pop(0).split())\n\n    gas_stations = []\n    for _ in range(n):\n        distance, cost_per_gallon = map(int, input_list.pop(0).split())\n        gas_stations.append((distance, cost_per_gallon))\n\n    # Sort gas stations by increasing distance\n    gas_stations.sort(key=lambda x: x[0])\n\n    min_cost = 0\n    total_distance = 0\n    fuel_in_tank = g\n\n    for distance, cost_per_gallon in gas_stations:\n        gallons_needed = (distance - total_distance) / 1000 * fuel_in_tank\n        fuel_in_tank -= gallons_needed\n\n        if fuel_in_tank < 0:\n            return \"cancel road trip\"\n\n        min_cost += gallons_needed * cost_per_gallon\n        fuel_in_tank = g\n        total_distance = distance\n\n    return min_cost\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(n: int, g: int, stations: list) -> bool:\n        total_distance = sum(stations[i][0] * stations[i][1] for i in range(n))\n        if total_distance <= g:\n            return True\n        else:\n            return False\n\n    def min_cost(n: int, g: int, stations: list) -> int:\n        if not is_possible(n, g, stations):\n            return \"cancel road trip\"\n\n        min_cost = 0\n        fuel_left = g\n        current_position = 0\n\n        while current_position < n:\n            distance_to_station = stations[current_position][0]\n            fuel_needed = fuel_left * stations[current_position][1]\n\n            if fuel_needed <= distance_to_station * stations[current_position][1]:\n                fuel_left = fuel_left - distance_to_station * stations[current_position][1]\n                current_position += 1\n            else:\n                min_cost += distance_to_station * stations[current_position][1]\n                fuel_left = fuel_left - distance_to_station * stations[current_position][1]\n\n        return min_cost\n\n    # Test cases\n    n, g = map(int, input().split())\n    stations = [list(map(int, input().split())) for _ in range(n)]\n\n    return min_cost(n, g, stations)\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split()[0:2])\n    stations = [tuple(map(int, stdin.split()[2*i+2:2*i+4])) for i in range(n)]\n    \n    # Initialize variables\n    current_station = stations[0]\n    current_cost = 0\n    total_distance = 0\n    tank_capacity = g\n    \n    # Iterate through the stations\n    for i in range(1, n):\n        # Calculate distance and cost to next station\n        distance_to_station = stations[i][0] - current_station[0]\n        cost_per_gallon = stations[i][1]\n        gallons_needed = (distance_to_station + current_station[0]) / 1000 * tank_capacity\n        \n        # Calculate total cost\n        current_cost += gallons_needed * cost_per_gallon\n        \n        # Update total distance and current station\n        total_distance += distance_to_station\n        current_station = stations[i]\n        \n        # Check if tank is empty\n        tank_capacity -= gallons_needed\n        if tank_capacity < 0:\n            return \"cancel road trip\"\n    \n    # Calculate cost for final trip\n    distance_to_station = total_distance + current_station[0] - stations[0][0]\n    cost_per_gallon = current_station[1]\n    gallons_needed = (distance_to_station + current_station[0]) / 1000 * tank_capacity\n    current_cost += gallons_needed * cost_per_gallon\n    \n    return current_cost\n\ndef"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_distance(gas_station_index: int) -> int:\n        return int(distance[gas_station_index][0])\n\n    def get_cost(gas_station_index: int) -> int:\n        return int(distance[gas_station_index][1])\n\n    def get_gas_limit(gas_station_index: int) -> int:\n        return int(distance[gas_station_index][2])\n\n    def get_remaining_gas(gas_station_index: int) -> int:\n        return int(distance[gas_station_index][3])\n\n    def update_remaining_gas(gas_station_index: int, new_remaining_gas: int):\n        distance[gas_station_index][3] = new_remaining_gas\n\n    def can_refuel(gas_station_index: int) -> bool:\n        return get_remaining_gas(gas_station_index) < fuel_capacity\n\n    def calculate_distance_to_rightmost_gas_station() -> int:\n        total_distance = 0\n        current_gas_station_index = 0\n        fuel_needed = fuel_capacity\n\n        while fuel_needed > 0:\n            distance_to_gas_station = get_distance(current_gas_station_index)\n\n            if fuel_needed <= fuel_limit_at_station:\n                fuel_needed -= fuel_limit_at_station\n            else:\n                fuel_needed -= fuel_capacity\n\n            total_distance += distance_to_gas_station\n\n            if fuel_needed < 0:\n                return -1\n\n            current_gas_station_index += 1\n\n        return total_distance\n\n    n, fuel_capacity = map(int, stdin.split()[:2])\n    distance = [list(map(int, stdin.split()[i:i+4])) for i in range(1, n * 4 + 1, 4)]\n    distance = [distance[i:i + n] for i in range(0, len(distance), n)]\n\n    fuel_limit_at_station = max(map(lambda x: x[2], distance))\n    remaining_gas_at_station = fuel_capacity\n\n    total_distance = calculate_distance_to_rightmost_gas_station()\n\n    if total_distance == -1:\n        return \"cancel road trip\"\n    else:\n        return total_distance\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(distances: List[int], costs: List[int]) -> bool:\n        if len(distances) != len(costs):\n            return False\n        if len(distances) != len(set(distances)):\n            return False\n        return True\n\n    def calculate_cost(distances: List[int], costs: List[int], fuel_tank_capacity: int) -> int:\n        total_cost = 0\n        current_distance = 0\n        while current_distance < distances[-1]:\n            next_station_index = next((i for i, d in enumerate(distances) if d > current_distance), len(distances)) - 1\n            distance_to_next_station = distances[next_station_index] - current_distance\n            fuel_needed = (distance_to_next_station / 1000) * fuel_tank_capacity\n            cost_per_gallon = costs[next_station_index]\n            cost_needed = fuel_needed * cost_per_gallon\n            total_cost += cost_needed\n            current_distance = distances[next_station_index]\n        return total_cost\n\n    n, fuel_tank_capacity = map(int, stdin.split()[0:2])\n    gas_stations = []\n    for _ in range(n):\n        d, c = map(int, stdin.split()[2:4])\n        gas_stations.append((d, c))\n\n    if not is_valid([d for d, c in gas_stations], [c for d, c in gas_stations]):\n        return \"cancel road trip\"\n\n    distances = [d for d, c in sorted(gas_stations, key=lambda x: x[0])]\n    costs = [c for d, c in sorted(gas_stations, key=lambda x: x[0])]\n    return calculate_cost(distances, costs, fuel_tank_capacity)\n\nn_cases = int(input())\nfor i in range(n_cases):\n    stdin = input()\n    print(solution(stdin)) "
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_input() -> tuple:\n        n, g = map(int, input().split())\n        stations = []\n        for _ in range(n):\n            d, c = map(int, input().split())\n            stations.append((d, c))\n        return n, g, stations\n\n    def distance_to_station(stations: list, current_distance: int) -> tuple:\n        return next(((d, c) for d, c in stations if d > current_distance), (float('inf'), 0))\n\n    n, g, stations = get_input()\n    current_distance = 0\n    current_fuel = g\n    current_cost = 0\n\n    while current_distance < stations[-1][0]:\n        d_to_next_station, c_per_gallon = distance_to_station(stations, current_distance)\n        gallons_to_next_station = (current_fuel - c_per_gallon) // c_per_gallon\n        distance_to_gas_station = gallons_to_next_station * c_per_gallon\n\n        if d_to_next_station == float('inf'):\n            return \"cancel road trip\"\n\n        fuel_to_next_station = gallons_to_next_station * c_per_gallon\n        total_cost_to_next_station = fuel_to_next_station + distance_to_gas_station\n\n        if current_cost + total_cost_to_next_station > 10**9:\n            return \"cancel road trip\"\n\n        current_distance += d_to_next_station\n        current_fuel -= fuel_to_next_station\n        current_cost += total_cost_to_next_station\n\n    return current_cost\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        n, g = map(int, stdin.readline().split())\n        gas_stations = []\n        for _ in range(n):\n            d, c = map(int, stdin.readline().split())\n            gas_stations.append((d, c))\n        return n, g, gas_stations\n\n    def calculate_min_cost(n: int, g: int, gas_stations: list) -> str:\n        min_cost = 0\n        current_position = 0\n        fuel_tank_capacity = g\n\n        for distance, cost in sorted(gas_stations, key=lambda x: x[0]):\n            if current_position + distance > fuel_tank_capacity:\n                return \"cancel road trip\"\n            fuel_required = (distance - current_position) * fuel_tank_capacity\n            min_cost += fuel_required * cost\n            current_position += distance\n\n        return str(min_cost)\n\n    n, g, gas_stations = read_input()\n    result = calculate_min_cost(n, g, gas_stations)\n    return result\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def min_cost_travel(n: int, g: int, stations: list) -> int:\n        stations.sort(key=lambda x: x[0])  # sort by distance\n        total_cost = 0\n        fuel_tank = g\n        current_position = 0\n\n        for i in range(n):\n            dist, cost = stations[i]\n            if current_position + dist > fuel_tank:\n                fuel_needed = dist - (current_position % dist)\n                fuel_gained = fuel_needed - (fuel_tank - current_position)\n                total_cost += fuel_gained * cost\n                current_position += fuel_gained\n                fuel_tank = current_position + g\n                if fuel_tank < dist:\n                    return \"cancel road trip\"\n            else:\n                fuel_tank -= dist\n                current_position += dist\n\n            total_cost += (current_position - dist) // dist * cost\n\n        return total_cost\n\n    n, g = map(int, stdin.split()[:2])\n    stations = []\n    for _ in range(n):\n        dist, cost = map(int, stdin.split()[2:4])\n        stations.append((dist, cost))\n\n    return min_cost_travel(n, g, stations)\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int]]]:\n        n, g = map(int, input_str.split())\n        stations = []\n        for _ in range(n):\n            dist, cost = map(int, input_str.split())\n            stations.append((dist, cost))\n        return n, g, stations\n\n    def min_cost_to_last_station(n: int, g: int, stations: List[Tuple[int, int]]) -> int:\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dist, cost = stations[i - 1]\n            dp[i] = dp[i - 1] + cost * g\n            for j in range(i - 1, -1, -1):\n                dist_j, _ = stations[j]\n                if dist_j < dist:\n                    dp[i] = min(dp[i], dp[j] + (dist - dist_j) * cost)\n        return dp[n]\n\n    n, g, stations = parse_input(stdin)\n    if stations[-1][0] > 2 * g:\n        return \"cancel road trip\"\n    else:\n        return min_cost_to_last_station(n, g, stations)\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def knapSack(capacity, weights, values, n):\n        dp = [0] * (capacity + 1)\n        for i in range(n + 1):\n            for j in range(capacity + 1):\n                if i == 0 or j == 0:\n                    dp[j] = 0\n                elif weights[i-1] <= j:\n                    dp[j] = max(dp[j-weights[i-1]] + values[i-1], dp[j])\n                else:\n                    dp[j] = dp[j]\n        return dp[capacity]\n\n    n, k = map(int, stdin.split()[0:2])\n    jewels = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    jewels.sort(key=lambda x: x[0], reverse=True)\n    result = []\n\n    for i in range(1, k+1):\n        total_value = 0\n        for jewel in jewels:\n            if jewel[0] > i:\n                break\n            total_value += jewel[1]\n        result.append(total_value)\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    jewels = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    jewels.sort(key=lambda x: x[1], reverse=True)\n    max_values = [0] * (k + 1)\n    for s, v in jewels:\n        for i in range(1, k+1):\n            if s <= i:\n                max_values[i] = max(max_values[i], max_values[i-s] + v)\n    return ' '.join(map(str, max_values))\n\ndef"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    jewels = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    jewels.sort(key=lambda x: x[1], reverse=True)\n    \n    dp = [[0] * (k+1) for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        size, value = jewels[i-1]\n        for knapsack in range(1, k+1):\n            if size <= knapsack:\n                dp[i][knapsack] = max(dp[i-1][knapsack], dp[i-1][knapsack-size] + value)\n            else:\n                dp[i][knapsack] = dp[i-1][knapsack]\n                \n    answer = [dp[-1][i] for i in range(1, k+1)]\n    \n    return ' '.join(map(str, answer))\n\ndef"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n, k = map(int, stdin.split()[0:2])\n    jewels = []\n    for _ in range(n):\n        s, v = map(int, stdin.split()[2:4])\n        jewels.append((s, v))\n\n    # solve problem\n    knapsacks = [0] * (k + 1)\n    for s, v in jewels:\n        for i in range(1, k + 1):\n            if s <= i:\n                knapsacks[i] = max(knapsacks[i], knapsacks[i - s] + v)\n\n    # output result\n    return ' '.join(map(str, knapsacks))\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    jewels = sorted(list(map(int, stdin.split()[2:])), reverse=True)\n\n    max_values = [0] * (k + 1)\n\n    for jewel_size, jewel_value in enumerate(jewels, 1):\n        for knapsack_size in range(1, k + 1):\n            if jewel_size > knapsack_size:\n                max_values[knapsack_size] = max(max_values[knapsack_size], max_values[knapsack_size - jewel_size] + jewel_value)\n\n    return ' '.join(map(str, max_values[1:]))\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n, k = input_data[0], input_data[1]\n    jewels = input_data[2:]\n\n    dp = [0] * (k + 1)\n    for size, value in jewels:\n        for i in range(size, k + 1):\n            dp[i] = max(dp[i], dp[i - size] + value)\n\n    return ' '.join(map(str, dp))\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def knapSack(capacity, weights, values, n, k):\n        dp = [[0 for _ in range(capacity + 1)] for _ in range(k + 1)]\n\n        for i in range(1, k + 1):\n            for j in range(1, capacity + 1):\n                if weights[i - 1] <= j:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1])\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[k][capacity]\n\n    n, k = map(int, stdin.readline().split())\n    jewels = []\n    for _ in range(n):\n        size, value = map(int, stdin.readline().split())\n        jewels.append((size, value))\n\n    weights = [0] * (k + 1)\n    values = [0] * (k + 1)\n    for i in range(1, k + 1):\n        weights[i] = sum(size for size, value in jewels[:i])\n        values[i] = sum(value for size, value in jewels[:i])\n\n    result = []\n    for i in range(1, k + 1):\n        if weights[i] <= k:\n            result.append(knapSack(k, weights, values, i, k))\n        else:\n            result.append(knapSack(k, weights, values, i, k - 1))\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    jewels = sorted([tuple(map(int, line.split())) for line in stdin.splitlines()[1:]], key=lambda x: x[1], reverse=True)\n    \n    def knapSack(capacity: int, items: list, i: int) -> int:\n        if capacity <= 0 or i < 0:\n            return 0\n        if items[i][0] > capacity:\n            return knapSack(capacity, items, i - 1)\n        return max(knapSack(capacity - items[i][0], items, i - 1), knapSack(capacity, items, i - 1) + items[i][1])\n    \n    result = [knapSack(i, jewels, n - 1) for i in range(1, k + 1)]\n    \n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, k = map(int, input_data[0].split())\n    jewels = [tuple(map(int, line.split())) for line in input_data[1:]]\n    jewels.sort(key=lambda x: x[1], reverse=True)\n    knapsacks = [0] * (k + 1)\n\n    for jewel in jewels:\n        s, v = jewel\n        for i in range(k, s - 1, -1):\n            knapsacks[i] = max(knapsacks[i], knapsacks[i - s] + v)\n\n    return ' '.join(map(str, knapsacks[1:]))"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    jewels = [tuple(map(int, stdin.split()[2:])) for _ in range(n)]\n    jewels.sort(key=lambda x: x[1], reverse=True)\n    \n    def knapSack(capacity: int, jewels: list, index: int) -> int:\n        if capacity <= 0 or index < 0:\n            return 0\n        if jewels[index][0] > capacity:\n            return knapSack(capacity, jewels, index - 1)\n        return max(\n            jewels[index][1] + knapSack(capacity - jewels[index][0], jewels, index - 1),\n            knapSack(capacity, jewels, index - 1)\n        )\n    \n    ans = [knapSack(i, jewels, n - 1) for i in range(1, k + 1)]\n    return \" \".join(map(str, ans))"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, r = map(int, input_list[0].split())\n    village_data = [list(map(int, input_list[i+1].split())) for i in range(n)]\n    minion_data = [list(map(int, input_list[i+1+n].split())) for i in range(m)]\n\n    def is_in_village(village, minion):\n        return max(abs(village[0]-minion[0]), abs(village[1]-minion[1])) <= village[2]\n\n    def is_in_villages(minion):\n        return any(is_in_village(village, minion) for village in village_data)\n\n    def count_minions_in_attack_radius(center, radius):\n        return sum(1 for minion in minion_data if minion[2] <= abs(minion[0]-center[0])+abs(minion[1]-center[1]) and minion[2] <= radius)\n\n    max_destroyed_minions = 0\n    for i in range(n):\n        max_destroyed_minions = max(max_destroyed_minions, count_minions_in_attack_radius(village_data[i][:2], village_data[i][2]))\n\n    return max_destroyed_minions\n"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m, r = map(int, input_data[0].split())\n    villages = []\n    for i in range(1, n+1):\n        vx, vy, vr = map(int, input_data[i].split())\n        villages.append((vx, vy, vr))\n    minions = []\n    for i in range(n+1, n+1+m):\n        mx, my = map(int, input_data[i].split())\n        minions.append((mx, my))\n    \n    max_minions = 0\n    for mx, my in minions:\n        for vx, vy, vr in villages:\n            if (mx - vx)**2 + (my - vy)**2 <= vr**2:\n                break\n        else:\n            max_minions += 1\n            if max_minions == r:\n                break\n    \n    return str(max_minions)\n\n\ninput_data = \"\"\"2 4 5\n0 0 1\n3 3\n-3 3\n3 -3\n3 0\n0 3\n3 4\n-3 4\n4 -4\n\"\"\"\nprint(solution(input_data)) "
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, r = map(int, input_data[0].split())\n    villages = []\n    for i in range(1, n + 1):\n        village = list(map(int, input_data[i].split()))\n        villages.append(village)\n    minions = []\n    for i in range(n + 1, n + 1 + m):\n        minion = list(map(int, input_data[i].split()))\n        minions.append(minion)\n    \n    max_minions = 0\n    for minion in minions:\n        for village in villages:\n            dist = ((minion[0] - village[0])**2 + (minion[1] - village[1])**2)**0.5\n            if dist <= village[2] + minion[2]:\n                max_minions += 1\n                break\n    \n    return max_minions\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m, r = map(int, input_data[0].split())\n    villages = []\n    minions = []\n    for i in range(1, n + 1):\n        vx, vy, vr = map(int, input_data[i].split())\n        villages.append((vx, vy, vr))\n    for i in range(n + 1, n + 1 + m):\n        mx, my = map(int, input_data[i].split())\n        minions.append((mx, my))\n\n    def is_inside_circle(point, circle):\n        x, y = point\n        cx, cy, cr = circle\n        return (x - cx) ** 2 + (y - cy) ** 2 <= cr ** 2\n\n    def is_inside_villages(point):\n        return any(is_inside_circle(point, village) for village in villages)\n\n    def is_outside_villages(point):\n        return all(not is_inside_circle(point, village) for village in villages)\n\n    def is_valid_minion_point(point):\n        x, y = point\n        return -r <= x <= r and -r <= y <= r and not is_inside_villages((x, y))\n\n    def minions_inside_circle(circle):\n        return [minion for minion in minions if is_inside_circle(minion, circle)]\n\n    max_minions = 0\n    for i in range(-r, r + 1):\n        for j in range(-r, r + 1):\n            if is_valid_minion_point((i, j)):\n                circle = (i, j, r)\n                minions_inside = minions_inside_circle(circle)\n                if len(minions_inside) > max_minions and is_outside_villages((i, j)):\n                    max_minions = len(minions_inside)\n\n    return str(max_minions)"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m, r = map(int, input_data[0].split())\n    villages = [tuple(map(int, input_data[i+1].split())) for i in range(n)]\n    minions = [tuple(map(int, input_data[i+1+n].split())) for i in range(m)]\n\n    # Helper function to calculate distance between two points\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    # Helper function to check if a minion is inside a village\n    def inside_village(village, minion):\n        vx, vy, vr = village\n        mx, my = minion\n        return distance((vx, vy), (mx, my)) <= vr\n\n    # Helper function to check if an attack will hit a village\n    def hits_village(village, attack_center, attack_radius):\n        vx, vy, vr = village\n        ax, ay = attack_center\n        return distance((vx, vy), (ax, ay)) <= attack_radius + vr\n\n    # Calculate the maximum number of minions Liam can destroy\n    max_minions = 0\n    for minion in minions:\n        min_radius = 2 * r  # Minimum radius for attack\n        attack_radius = min_radius  # Current attack radius\n        while not inside_village(villages[0], minion) and not hits_village(villages[0], villages[0], attack_radius):\n            attack_radius += 1\n\n        max_minions += 1\n\n    return str(max_minions)\n"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_inside(center_x, center_y, radius, x, y):\n        return distance(center_x, center_y, x, y) <= radius\n\n    def is_valid_attack(village_x, village_y, village_radius, minion_x, minion_y):\n        return not (is_inside(village_x, village_y, village_radius, minion_x, minion_y) or\n               is_inside(minion_x, minion_y, 1, village_x, village_y))\n\n    n, m, r = map(int, stdin.split()[:3])\n    village_positions = []\n    for i in range(n):\n        village_x, village_y, village_radius = map(int, stdin.split()[3:6])\n        village_positions.append((village_x, village_y, village_radius))\n\n    minion_positions = []\n    for i in range(m):\n        minion_x, minion_y = map(int, stdin.split()[6 + 2 * i: 8 + 2 * i])\n        minion_positions.append((minion_x, minion_y))\n\n    max_minions = 0\n    for i in range(n):\n        village_x, village_y, village_radius = village_positions[i]\n        valid_minions = sum(is_valid_attack(village_x, village_y, village_radius, *minion_positions[j]) for j in range(m))\n        max_minions = max(max_minions, valid_minions)\n\n    return max_minions\n\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split()[0:3])\n    villages = []\n    for _ in range(n):\n        vx, vy, vr = map(int, stdin.split()[3:6])\n        villages.append((vx, vy, vr))\n        stdin = stdin[6:]\n\n    minions = []\n    for _ in range(m):\n        mx, my = map(int, stdin.split()[1:3])\n        minions.append((mx, my))\n        stdin = stdin[3:]\n\n    # Find the maximum number of minions that can be destroyed without hitting any village\n    count = 0\n    for minion in minions:\n        for village in villages:\n            distance = ((minion[0] - village[0]) ** 2 + (minion[1] - village[1]) ** 2) ** 0.5\n            if distance <= village[2] + r:  # If the minion is inside the village's radius + attack radius\n                break\n        else:  # If the minion is not inside any village's radius + attack radius\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split()[0:3])\n    villages = []\n    for i in range(n):\n        x, y, r = map(int, stdin.split()[i*3+1:i*3+4])\n        villages.append((x, y, r))\n    \n    minions = []\n    for i in range(m):\n        x, y = map(int, stdin.split()[n*3+i*2+1:n*3+i*2+3])\n        minions.append((x, y))\n\n    max_minions = 0\n    for i in range(len(minions)):\n        minion = minions[i]\n        if not any(is_inside_village(village, minion) for village in villages):\n            dist = max(distance(village, minion) for village in villages)\n            if dist <= r:\n                max_minions += 1\n\n    return str(max_minions)\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m, r = map(int, input_data[0].split())\n    villages = []\n    for i in range(1, n+1):\n        vx, vy, vr = map(int, input_data[i].split())\n        villages.append((vx, vy, vr))\n    enemy_minions = []\n    for i in range(n+1, n+1+m):\n        mx, my = map(int, input_data[i].split())\n        enemy_minions.append((mx, my))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def within_radius(p, r):\n        return all(distance(p, v[:2]) <= v[2] + r for v in villages)\n\n    def can_attack(p, r):\n        return all(distance(p, m) > r for m in enemy_minions)\n\n    max_attack_radius = r\n    while True:\n        if all(can_attack(v[:2], max_attack_radius) and within_radius(v[:2], max_attack_radius) for v in villages):\n            break\n        max_attack_radius += 1\n\n    return m - sum(1 for m in enemy_minions if distance(m, v[:2]) <= v[2] + max_attack_radius)"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def point_in_circle(x: int, y: int, cx: int, cy: int, r: int) -> bool:\n        return (x - cx)**2 + (y - cy)**2 <= r**2\n\n    def is_minion_inside_village(vx: int, vy: int, mx: int, my: int, vr: int, cx: int, cy: int, cr: int) -> bool:\n        return point_in_circle(vx, vy, cx, cy, cr) and point_in_circle(mx, my, cx, cy, vr)\n\n    def is_minion_inside_villages(mx: int, my: int, villages: list) -> bool:\n        for cx, cy, cr in villages:\n            if point_in_circle(mx, my, cx, cy, cr):\n                return True\n        return False\n\n    n, m, r = map(int, stdin.split()[0:3])\n    villages = [tuple(map(int, stdin.split()[i:i+3])) for i in range(3, 3+n*3, 3)]\n    minions = [tuple(map(int, stdin.split()[i:i+2])) for i in range(3+n*3, 3+n*3+m*2, 2)]\n\n    max_minions_destroyed = 0\n    for mx, my in minions:\n        for cx, cy, cr in villages:\n            if not is_minion_inside_village(mx, my, cx, cy, cr, cx, cy, r):\n                if not is_minion_inside_villages(mx, my, villages):\n                    max_minions_destroyed += 1\n                    break\n\n    return str(max_minions_destroyed)"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_interesting_subsequence(A, k, s):\n        n = len(A)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + A[i]\n\n        max_length = 0\n        for i in range(n - k):\n            if prefix_sum[i + k + 1] - prefix_sum[i] <= s:\n                max_length = max(max_length, k)\n            else:\n                max_length = max(max_length, i + 1)\n\n        return max_length\n\n    def main(stdin: str) -> str:\n        input_data = list(map(int, stdin.split()))\n        n, s = input_data[0], input_data[1]\n        A = input_data[2:]\n\n        result = []\n        for i in range(n):\n            max_length = find_interesting_subsequence(A, i + 1, s)\n            result.append(max_length)\n\n        return '\\n'.join(map(str, result))\n\n    return main(stdin)\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    N, S = map(int, input_list.pop(0).split())\n    A = list(map(int, input_list))\n\n    def is_interesting(subseq):\n        return sum(subseq[:K]) <= S and sum(subseq[K:]) <= S\n\n    def longest_interesting_subseq(i):\n        longest = 0\n        for j in range(i, N):\n            if is_interesting(A[i:j+1]):\n                longest = max(longest, j - i + 1)\n        return longest\n\n    result = []\n    for i in range(N):\n        result.append(longest_interesting_subseq(i))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def interesting_subsequence(seq):\n        prefix_sum = [0] * (2 * K + 1)\n        for i in range(len(seq)):\n            for j in range(1, 2 * K + 1):\n                prefix_sum[j] += seq[i]\n                if prefix_sum[j] > S:\n                    return False\n        return True\n\n    N, S = map(int, input().split())\n    A = [int(x) for x in input().split()]\n\n    K = N // 2\n    result = []\n\n    for i in range(N):\n        if interesting_subsequence(A[i:i + 2 * K + 1]):\n            result.append(2 * K + 1)\n        else:\n            result.append(0)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, S = map(int, input_list.pop(0).split())\n    A = list(map(int, input_list))\n    MOD = 10**9 + 7\n\n    def count_interesting_subsequences(A, i, k):\n        if i + k > N:\n            return 0\n        sum_first_k = sum(A[i:i+k])\n        sum_last_k = sum(A[N-k:])\n        if sum_first_k + sum_last_k > S:\n            return 0\n        if k == 1:\n            return 1\n        return count_interesting_subsequences(A, i+1, k) + count_interesting_subsequences(A, i+1, k-1)\n\n    result = []\n    for i in range(N):\n        longest_subsequence = count_interesting_subsequences(A, 0, i+1)\n        result.append(longest_subsequence)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    dp = [1] * N\n    for i in range(N):\n        for j in range(i):\n            if A[i] - A[j] <= S:\n                dp[i] = max(dp[i], dp[j] + 1)\n    result = [0] * N\n    for i in range(N):\n        for j in range(i + 1, N):\n            if A[i] + A[j] <= S and dp[i] + dp[j] > dp[i] + dp[j - 1]:\n                dp[i] = dp[i] + dp[j]\n    for i in range(N):\n        result[i] = dp[i]\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n    \n    def max_len_subseq(start):\n        max_len = 0\n        curr_sum = 0\n        i = start\n        while i < len(A) and curr_sum + A[i] <= S:\n            curr_sum += A[i]\n            max_len = max(max_len, i - start + 1)\n            i += 1\n        return max_len\n    \n    result = []\n    for i in range(N):\n        max_len = 0\n        for j in range(i+1):\n            max_len = max(max_len, max_len_subseq(j))\n        result.append(max_len)\n        \n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    def is_interesting(i, j):\n        if i <= j:\n            return sum(A[i:j+1]) <= S\n        else:\n            return False\n\n    def longest_interesting_subsequence(i):\n        longest = 0\n        for j in range(i, len(A)):\n            if is_interesting(i, j):\n                longest = max(longest, longest_interesting_subsequence(j+1))\n            else:\n                break\n        return longest + 1\n\n    result = []\n    for i in range(len(A)):\n        result.append(longest_interesting_subsequence(i))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, input().split())\n    A = [int(x) for x in stdin.split(\"\\n\")[:N]]\n\n    def longest_interesting_subsequence(i):\n        def can_add(k):\n            return A[i] + sum(A[i+1:i+k+1]) <= S\n\n        if i >= N:\n            return 0\n        elif can_add(1):\n            return 1 + longest_interesting_subsequence(i+1)\n        else:\n            return longest_interesting_subsequence(i+1)\n\n    output = [longest_interesting_subsequence(i) for i in range(N)]\n    return \"\\n\".join(str(o) for o in output)"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, S = map(int, input_data[0].split())\n    A = list(map(int, input_data[1:]))\n\n    dp = [1] * N\n\n    for i in range(1, N):\n        for j in range(i):\n            if A[i] > S - A[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    result = ['0'] * N\n    for i in range(N):\n        for j in range(i + 1, N):\n            if A[i] > S - A[j]:\n                result[i] = max(result[i], result[j] + 1)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def interesting_subsequence_length(A, S):\n        prefix_sum = [0]\n        for a in A:\n            prefix_sum.append(prefix_sum[-1] + a)\n        n = len(prefix_sum)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if prefix_sum[i] <= S:\n                dp[i][i] = 1\n        for len_ in range(2, n + 1):\n            for i in range(n - len_ + 1):\n                j = i + len_ - 1\n                if prefix_sum[j] - prefix_sum[i - 1] <= S:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) + 1\n        return max(dp[0][n - 1], dp[1][n - 1])\n\n    N, S = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n    result = []\n    for i in range(N):\n        length = interesting_subsequence_length(A[i:], S)\n        result.append(str(length))\n    return \"\\n\".join(result)"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    sequence = stdin.splitlines()[1]\n\n    mirror_sequence = sequence[::-1]\n    mirror_words = []\n    i = 0\n    while i < N:\n        word = \"\"\n        while i < N and sequence[i] == mirror_sequence[i]:\n            word += sequence[i]\n            i += 1\n        mirror_words.append(word)\n\n    max_mirror_word = max(mirror_words)\n\n    if max_mirror_word:\n        return \"DA\\n\" + max_mirror_word\n    else:\n        return \"NE\\n\" + max_mirror_word"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = stdin.split(\"\\n\")\n    N = int(N)\n    if N % 2 == 1:\n        return \"NE\", \"\"\n\n    left, right = 0, N - 1\n    while left <= right:\n        if sequence[left] < sequence[right]:\n            break\n        left += 1\n        right -= 1\n\n    if left > right:\n        return \"DA\", \"\"\n\n    left_word = sequence[:left]\n    right_word = sequence[right + 1:]\n    most_beautiful_word = \"\".join(sorted(left_word + right_word))\n\n    return \"DA\", most_beautiful_word\n"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = input().split()\n    N = int(N)\n    most_beautiful_word = \"\"\n\n    for char in sequence:\n        most_beautiful_word = char + most_beautiful_word\n\n    if most_beautiful_word < sequence:\n        return \"DA\\n\" + most_beautiful_word\n    else:\n        return \"NE\\n\" + most_beautiful_word"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    sequence = stdin.split('\\n')[1]\n\n    words = []\n    i = 0\n    while i < N:\n        if i % 2 == 0:\n            words.append(sequence[i])\n        else:\n            words.append(words[-1] + sequence[i])\n        i += 1\n\n    if len(words) % 2 == 0:\n        return \"DA\\n\" + words[-1]\n    else:\n        return \"NE\\n\" + words[-2]"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    sequence = stdin.split('\\n')[1]\n\n    # Initialize the current player and the starting word\n    current_player = 0\n    current_word = ''\n\n    while len(sequence) > 0:\n        # Remove the rightmost letter and append it to the current word\n        letter = sequence[-1]\n        sequence = sequence[:-1]\n        current_word += letter\n\n        # If it's Mirko's turn, remove the rightmost letter and append it to the end of the sequence\n        if current_player == 0:\n            sequence += sequence[-1]\n            sequence = sequence[:-1]\n\n        # Switch the current player\n        current_player = 1 - current_player\n\n    # Determine whether Slavko can win and the most beautiful word he can end the game with\n    if current_player == 0:\n        return 'DA\\n' + current_word\n    else:\n        return 'NE\\n' + current_word"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    sequence = stdin.split('\\n')[1]\n\n    mirror = {c: c.upper() for c in 'abcdefghijklmnopqrstuvwxyz'}\n\n    for i in range(N - 1, -1, -1):\n        if sequence[i] in mirror:\n            end_position = i + 1\n            break\n\n    most_beautiful_word = ''\n    for i in range(N - 1, end_position - 1, -1):\n        most_beautiful_word += mirror[sequence[i]]\n\n    if end_position == N:\n        return \"NE\\n\" + most_beautiful_word\n    else:\n        return \"DA\\n\" + most_beautiful_word\n\n\ndef"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = stdin.split('\\n')\n    N = int(N)\n\n    if N % 2 == 0:\n        return \"NE\"\n\n    def find_beautiful_word(sequence: str) -> str:\n        word = \"\"\n        while sequence:\n            word += sequence[-1]\n            sequence = sequence[:-1]\n            if not sequence:\n                return word\n        return word\n\n    beautiful_word = find_beautiful_word(sequence)\n    if beautiful_word < sequence[N // 2]:\n        return \"DA\", beautiful_word\n    else:\n        return \"NE\", \"\"\n\n\ninput_file = \"input.txt\"\noutput_file = \"output.txt\"\n\nwith open(input_file, \"r\") as file_in, open(output_file, \"w\") as file_out:\n    stdin = file_in.read()\n    result = solution(stdin)\n    file_out.write(f\"{result[0]}\\n{result[1]}\") "
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    sequence = stdin.split('\\n')[1]\n    best_word = ''\n    if N % 2 == 0:\n        return 'DA\\n' + best_word\n    for i in range(N):\n        if i % 2 == 0:\n            best_word = sequence[0] + best_word\n            sequence = sequence[1:]\n        else:\n            best_word = sequence[-1] + best_word\n            sequence = sequence[:-1]\n    return 'DA\\n' + best_word\n"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = map(str, stdin.split('\\n'))\n    N = int(N)\n    sequence = list(sequence)\n    max_word = ''\n    current_word = ''\n    for _ in range(N):\n        if sequence:\n            letter = sequence.pop()\n            if max_word < current_word:\n                max_word = current_word\n            current_word += letter\n        else:\n            break\n    if max_word == current_word:\n        return \"NE\\n{}\".format(max_word)\n    else:\n        return \"DA\\n{}\".format(max_word)\n\n\ninput_data = '''4\nkava\n'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0].strip())\n    sequence = stdin[1].strip()\n\n    if N % 2 == 0:\n        return \"DA\\n\" + \"a\" * (N // 2)\n    else:\n        return \"DA\\n\" + sequence[::-1]\n"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[0].split())\n    adj_list = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        x, y = map(int, stdin.split()[1:3])\n        adj_list[x].append(y)\n        adj_list[y].append(x)\n\n    def dfs(node, visited, order, res):\n        visited[node] = True\n        order.append(node)\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, order, res)\n\n    order = []\n    visited = [False] * (n + 1)\n    dfs(1, visited, order, [])\n\n    def count_ways(guest_areas, k):\n        if k == 0:\n            return 1\n        if len(guest_areas) == 0:\n            return 0\n        count = 0\n        for i in guest_areas:\n            count += count_ways(guest_areas - {i}, k - 1)\n        return count\n\n    result = []\n    for _ in range(q):\n        k, a = map(int, stdin.split()[1:3])\n        guest_areas = set(map(int, stdin.split()[3:3 + a]))\n        result.append(count_ways(guest_areas, k))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, end, visited, curr_path):\n        if start == end:\n            if curr_path not in paths:\n                paths.append(curr_path)\n            return\n        for node in graph[start]:\n            if not visited[node]:\n                dfs(node, end, visited, curr_path + [node])\n\n    n, m, q = map(int, stdin.split()[:3])\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v = map(int, stdin.split()[3 + i * 2:5 + i * 2])\n        graph[u].append(v)\n        graph[v].append(u)\n\n    paths = []\n    for i in range(q):\n        k, a = map(int, stdin.split()[q * 2 + 1 + i * 2:q * 2 + 2 + i * 2])\n        curr_path = []\n        for j in range(a):\n            u = int(stdin.split()[q * 2 + 2 + i * a + j])\n            dfs(u, u, [False] * (n + 1), curr_path + [u])\n\n        result = len(paths)\n        paths.clear()\n        print(result)\n"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[0:3])\n    runs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1] if line]\n    ski_runs = {i: set() for i in range(1, n+1)}\n    for run in runs:\n        ski_runs[run[0]].add(run[1])\n    \n    def dfs(node, path, visited, result):\n        if node in path:\n            return\n        visited.add(node)\n        path.add(node)\n        for neighbor in ski_runs[node]:\n            if neighbor not in visited:\n                dfs(neighbor, path, visited, result)\n        result.append(tuple(sorted(path)))\n    \n    for i in range(1, n+1):\n        dfs(i, set(), set(), [])\n    \n    def query(k, a, areas):\n        result = 0\n        for path in paths:\n            if len(path) == k and all(i in path for i in areas):\n                result += 1\n        return result\n    \n    queries = [line.split() for line in stdin.split('\\n')[m+1:].split('\\n') if line]\n    paths = [path for path in dfs(1, set(), set(), []) if len(path) == n]\n    output = '\\n'.join(str(query(int(k), int(a), [int(i) for i in query_areas])) for k, a, *query_areas in queries)\n    \n    return output\n"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_paths(start: int, end: int, paths: List[str]) -> int:\n        if start == end:\n            return 1\n        if start > end or not paths:\n            return 0\n        count = 0\n        for path in paths:\n            if path[start] == \"1\":\n                count += find_paths(start + 1, end, paths)\n        return count\n\n    def dfs(node: int, adj_list: List[List[int]], visited: List[bool], query: List[int], result: List[int]) -> None:\n        if visited[node]:\n            return\n        visited[node] = True\n        if node == query[0]:\n            result.append(1)\n        for next_node in adj_list[node]:\n            if next_node == query[1]:\n                result.append(2)\n                break\n            dfs(next_node, adj_list, visited, query, result)\n\n    n, m, q = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        adj_list[x - 1].append(y - 1)\n\n    result = []\n    for _ in range(q):\n        k, a = map(int, stdin.readline().split())\n        query = list(map(int, stdin.readline().split()))[1:]\n        paths = [[] for _ in range(n)]\n        for i in range(k - 1, -1, -1):\n            paths[query[i] - 1].append(str(i + 1))\n        result.append(find_paths(0, n - 1, paths))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, q = map(int, input_list[0].split())\n    run_list = []\n    for i in range(1, m+1):\n        x, y = map(int, input_list[i].split())\n        run_list.append((x, y))\n\n    def find_path(start, end, path=None):\n        if path is None:\n            path = []\n        path = path + [start]\n        if start == end:\n            return [path]\n        paths = []\n        for neighbor in G[start]:\n            if neighbor not in path:\n                newpaths = find_path(neighbor, end, path)\n                for newpath in newpaths:\n                    paths.append(newpath)\n        return paths\n\n    G = {}\n    for i in range(1, n+1):\n        G[i] = []\n    for run in run_list:\n        G[run[0]].append(run[1])\n\n    result = []\n    for i in range(1, q+1):\n        k, a = map(int, input_list[m+i].split())\n        query_set = set(map(int, input_list[m+i+1].split()))\n        # check if there are enough snack stands to stock for each area\n        if len(query_set) > k:\n            result.append(0)\n            continue\n        # check if there is a path from area 1 to all areas in the query set\n        path_set = set()\n        for area in query_set:\n            path_set = path_set.union(set(find_path(1, area)))\n        if len(path_set) != len(query_set):\n            result.append(0)\n            continue\n        result.append(comb(n, k))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(cur: int, depth: int, target: int, visited: set[int], snack_stands: set[int]) -> int:\n        if depth == target:\n            return 1 if cur in snack_stands else 0\n        if depth > target:\n            return 0\n        res = 0\n        for nxt in adj[cur]:\n            if nxt not in visited:\n                visited.add(nxt)\n                res += dfs(nxt, depth + 1, target, visited, snack_stands)\n                visited.remove(nxt)\n        return res\n\n    n, m, q = map(int, stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        adj[x].append(y)\n        adj[y].append(x)\n\n    res = []\n    for _ in range(q):\n        k, a = map(int, stdin.readline().split())\n        fav_areas = set(map(int, stdin.readline().split()))\n        snack_stands = set()\n        for area in fav_areas:\n            visited = set()\n            visited.add(1)\n            for i in range(2, n + 1):\n                if i not in fav_areas:\n                    if 1 not in fav_areas:\n                        break\n                    visited.add(i)\n            else:\n                snack_stands.add(area)\n            visited.remove(1)\n        res.append(dfs(1, 1, k, set(), snack_stands))\n\n    return '\\n'.join(map(str, res))\n\ndef"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(cur, target, visited, stack, target_stack, used, memo):\n        if cur == target:\n            if used == target_stack:\n                memo[tuple(stack)] = 1\n            return 1\n        if cur in visited:\n            return memo.get(tuple(stack + [cur]), 0)\n        \n        visited.add(cur)\n        for i in range(1, n+1):\n            if i != cur and (i, cur) not in used:\n                used.add((i, cur))\n                stack.append(i)\n                dfs(i, target, visited, stack, target_stack, used, memo)\n                stack.pop()\n                used.remove((i, cur))\n        return memo.get(tuple(stack), 0)\n    \n    n, m, q = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n+1)]\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        adj_list[x].append(y)\n    \n    memo = {}\n    for i in range(q):\n        k, a = map(int, stdin.readline().split())\n        used = set()\n        stack = []\n        target = 1\n        for j in range(a):\n            target = int(stdin.readline().strip())\n            used.add((target, i))\n            stack.append(target)\n        \n        count = dfs(1, target, set(), stack, target_stack, used, memo)\n        yield count\n\ndef"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, m, q = map(int, input_list[0].split())\n    ski_runs = []\n    for i in range(1, m + 1):\n        x, y = map(int, input_list[i].split())\n        ski_runs.append((x, y))\n\n    def dfs(visited: set, i: int, path: list) -> None:\n        if i == n + 1:\n            path.append(1)\n            return\n        for j in range(1, n + 1):\n            if j not in visited:\n                visited.add(j)\n                path.append(j)\n                dfs(visited, i + 1, path)\n                path.pop()\n                visited.remove(j)\n\n    def backtrack(snack_stands: set, k: int, areas: list, i: int) -> int:\n        if i == len(areas):\n            return 1 if k == 0 else 0\n        ans = 0\n        for j in range(i + 1, n + 1):\n            if (ski_runs[ski_runs.index((areas[i], j)) + 1] not in snack_stands) and (areas[i] in snack_stands):\n                snack_stands.add(ski_runs[ski_runs.index((areas[i], j)) + 1])\n                ans += backtrack(snack_stands, k - 1, areas, i + 1)\n                snack_stands.remove(ski_runs[ski_runs.index((areas[i], j)) + 1])\n        return ans\n\n    output = []\n    for i in range(q):\n        k, a = map(int, input_list[m + i].split())\n        areas = list(map(int, input_list[m + i].split())[1:])\n        snack_stands = set()\n        dfs(set(), 1, [1])\n        for j in range(1, n + 1):\n            if j not in snack_stands:\n                snack_stands.add(ski_runs[ski_runs.index((1, j)) + 1])\n        output.append(backtrack(snack_stands, k, areas, 1))\n    return \"\\n\".join(map(str, output))\n"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(k: int, areas: set[int]) -> int:\n        if len(areas) == k:\n            return 1\n        if len(areas) > k:\n            return 0\n        return count_ways(k, areas.union(ski_runs[areas.pop()]))\n\n    n, m, q = map(int, stdin.split()[:3])\n    ski_runs = [set(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n    for i in range(m):\n        for j in range(i+1, m):\n            if ski_runs[i] & ski_runs[j]:\n                raise ValueError(\"There is a ski run shared by two areas\")\n    for i in range(m):\n        for j in range(i+1, m):\n            if not ski_runs[i] & ski_runs[j]:\n                raise ValueError(\"There is no ski run between two areas\")\n\n    result = []\n    for line in stdin.split('\\n')[m+1:]:\n        k, a = map(int, line.split()[:2])\n        areas = set(map(int, line.split()[2:]))\n        if len(areas) > a:\n            raise ValueError(\"There are more areas than specified\")\n        result.append(count_ways(k, areas))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited, target):\n        if len(visited) == target and start not in visited:\n            visited.add(start)\n            return 1\n        if len(visited) == target:\n            return 0\n        visited.add(start)\n        for i in range(1, n+1):\n            if i not in visited and (start, i) in runs:\n                ret = dfs(i, visited.copy(), target)\n                if ret > 0:\n                    return ret\n        return 0\n\n    n, m, q = map(int, stdin.split()[:3])\n    runs = [(i, j) for i in range(1, n+1) for j in range(1, n+1) if i != j]\n\n    ans = []\n    for _ in range(q):\n        k, a = map(int, stdin.split()[3:5])\n        areas = list(map(int, stdin.split()[5:5+a]))\n        ret = 0\n        for i in range(1, k+1):\n            visited = set()\n            ret += dfs(1, visited, i)\n        ans.append(ret)\n    return '\\n'.join(map(str, ans))\n\ndef"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    inspection_times = []\n    for _ in range(n):\n        inspection_times.append(list(map(int, input().split())))\n\n    flight_times = []\n    for _ in range(n):\n        flight_times.append(list(map(int, input().split())))\n\n    flights = []\n    for _ in range(m):\n        s, f, t = map(int, input().split())\n        flights.append((s - 1, f - 1, t))\n\n    planes = 0\n    flight_graph = [[float('inf')] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                for k in range(n):\n                    if k != i and k != j:\n                        flight_graph[i][j] = min(flight_graph[i][j], flight_graph[i][k] + flight_graph[k][j])\n\n    for flight in flights:\n        s, f, t = flight\n        planes += 1\n        t += inspection_times[s][f]\n        for i in range(n):\n            if i != s and i != f:\n                flight_time = flight_times[s][i] + flight_times[i][f]\n                if flight_graph[s][i] + flight_graph[i][f] + flight_time >= t:\n                    planes -= 1\n                    break\n\n    return planes\n\ndef"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def min_planes(n: int, m: int, inspection_times: list, flights: list) -> int:\n        flight_times = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    flight_times[i][j] = flights[i][j]\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for t in range(1, m + 1):\n            for i in range(n + 1):\n                for j in range(n + 1):\n                    if i == 0 and j == 0:\n                        dp[i][j] = 0\n                    elif i == 0:\n                        dp[i][j] = dp[i][j - 1] + 1\n                    elif j == 0:\n                        dp[i][j] = dp[i - 1][j] + 1\n                    else:\n                        dp[i][j] = min(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n                        if i > 0 and j > 0:\n                            if flights[i - 1][j - 1] + inspection_times[i - 1] + inspection_times[j - 1] + flight_times[i - 1][j - 1] <= t:\n                                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1)\n                            else:\n                                dp[i][j] = dp[i - 1][j - 1]\n        return dp[n][m]\n\n    n, m = map(int, input().split())\n    inspection_times = [list(map(int, input().split())) for _ in range(n)]\n    flights = [list(map(int, input().split())) for _ in range(n)]\n    flights += [[flights[i][j] for j in range(n)] for i in range(n)]\n    inspection_times += [[inspection_times[i][j] for j in range(n)] for i in range(n)]\n    inspection_times += [[0] * n for _ in range(n)]\n    return str(min_planes(n, m, inspection_times, flights))"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph: list, start: int, end: int) -> int:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n\n        while True:\n            u = -1\n            min_dist = float('inf')\n            for i in range(n):\n                if not visited[i] and dist[i] < min_dist:\n                    u = i\n                    min_dist = dist[i]\n\n            if u == -1:\n                break\n\n            visited[u] = True\n            for v in range(n):\n                if not visited[v] and graph[u][v] != float('inf'):\n                    new_dist = dist[u] + graph[u][v]\n                    if new_dist < dist[v]:\n                        dist[v] = new_dist\n\n        return dist[end]\n\n    def inspection_time(airports: list, i: int) -> int:\n        return airports[i - 1]\n\n    def flight_time(airports: list, i: int, j: int) -> int:\n        return airports[i - 1][j - 1]\n\n    def min_planes(flights: list, airports: list) -> int:\n        def schedule_flight(flight: tuple, time: int) -> int:\n            s, f, t = flight\n            return inspection_time(airports, s) + flight_time(airports, s, f) + flight_time(airports, f, s) + flight_time(airports, f, t)\n\n        def unscheduled_flight(flight: tuple, time: int) -> int:\n            s, f, t = flight\n            return flight_time(airports, s, f) + flight_time(airports, f, s) + flight_time(airports, f, t)\n\n        n = len(airports)\n        max_time = 0\n        for flight in flights:\n            max_time = max(max_time, schedule_flight(flight, flight[2]))\n\n        min_planes = 1\n        for flight in flights:\n            time = unscheduled_flight(flight, max_time)\n            time += flight_time(airports, flight[0], flight[1])\n            time += inspection_time(airports, flight[0])\n            time += inspection_time(airports, flight[1])\n            while time < max_time:\n                time += n * flight_time(airports, flight[1], flight[0]) + inspection_time(airports, flight[1])\n            min_planes = max(min_planes, int(time / max_time))\n\n        return min_planes\n\n    def main(stdin: str) -> str:\n        n, m = map(int, stdin.split()[:2])\n        airports = list(map(int, stdin.split()[2:2 + n]))\n        airports = [list(map(int, stdin.split()[2 + i: 2 + n + n * i])) for i in range(n)]\n\n        flights = []\n        for i in range(m):\n            s, f, t = map(int, stdin.split()[2 + n + n * i: 5 + n + n * i])\n            flights.append((s, f, t))\n\n        return str(min_planes(flights, airports))\n\n    return main(stdin)"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    inspection_times = list(map(int, stdin.splitlines()[1].split()))\n    flights = list(map(int, stdin.splitlines()[2:]))\n    \n    def min_planes(m):\n        dp = [1] * (m + 1)\n        for _ in range(n):\n            for t in range(m, 0, -1):\n                for s, f, t_f in flights:\n                    if s == t:\n                        dp[t] = max(dp[t], dp[t - s] + 1)\n                        dp[t] = max(dp[t], dp[t - f] + 1)\n        return dp[-1]\n    \n    planes = min_planes(m)\n    return str(planes)\n"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    def get_flight_time(i, j, flights):\n        return flights[i][j]\n\n    def get_inspection_time(i, inspections):\n        return inspections[i]\n\n    def count_planes(flights, inspections, flights_info):\n        planes = defaultdict(int)\n        for i, j, t in flights_info:\n            flight_time = get_flight_time(i, j, flights)\n            inspection_time = get_inspection_time(i, inspections)\n            planes[i] += 1\n            planes[j] += 1\n            planes[i] -= 1\n            planes[j] -= 1\n            planes[i] += 1\n            planes[j] += 1\n            planes[i] -= 1\n            planes[j] -= 1\n            planes[i] += 1\n            planes[j] += 1\n            planes[i] -= 1\n            planes[j] -= 1\n        return max(planes.values())\n\n    def main(n, m, inspections, flights, flights_info):\n        min_planes = float('inf')\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    flights[i][j] = flights[j][i]\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if i != j and j != k and k != i:\n                        if flights[i][j] == flights[i][k] + flights[k][j]:\n                            flights[i][j] = flights[i][k] + flights[k][j]\n                        if flights[i][j] == flights[i][k] + flights[k][j] + get_flight_time(k, j, flights):\n                            flights[i][j] = flights[i][k] + flights[k][j] + get_flight_time(k, j, flights)\n        for i in range(m):\n            planes_count = count_planes(flights, inspections, flights_info[i:i+1])\n            min_planes = min(min_planes, planes_count)\n        return min_planes\n\n    def parse_input(stdin: str) -> tuple:\n        n, m = map(int, stdin.split()[:2])\n        inspections = list(map(int, stdin.split()[2:2 + n]))\n        flights = [[float('inf')] * n for _ in range(n)]\n        flights_info = []\n        for _ in range(n):\n            row = list(map(int, stdin.split()[2 + n:]))\n            flights_info.append(row[:n])\n            flights_info.append(row[n:])\n            row = list(map(int, stdin.split()[2 + 2 * n:]))\n            flights_info.append(row[:n])\n            flights_info.append(row[n:])\n        return n, m, inspections, flights, flights_info\n\n    n, m, inspections, flights, flights_info = parse_input(stdin)\n    min_planes = main(n, m, inspections, flights, flights_info)\n    return str(min_planes)\n\ntest_cases = [\n    \"2 2\\n1 1\\n0 1\\n1 0\\n1 2 1\\n2 1 1\",\n    \"2 2\\n1 1\\n0 1\\n1 0\\n1 2 1\\n2 1 3\"\n]\n\nfor test_case in test_cases:\n    print(solution(test_case)) "
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph: list, start: int, end: int) -> int:\n        visited = [False for _ in range(len(graph))]\n        dist = [float('inf') for _ in range(len(graph))]\n        dist[start] = 0\n\n        while True:\n            min_dist = float('inf')\n            next_node = -1\n\n            for i in range(len(graph)):\n                if not visited[i] and dist[i] < min_dist:\n                    min_dist = dist[i]\n                    next_node = i\n\n            if next_node == -1:\n                break\n\n            visited[next_node] = True\n\n            for neighbor, weight in enumerate(graph[next_node]):\n                if not visited[neighbor] and dist[next_node] + weight < dist[neighbor]:\n                    dist[neighbor] = dist[next_node] + weight\n\n        return dist[end] if dist[end] != float('inf') else -1\n\n    def min_planes(flights: list, inspection_time: list) -> int:\n        n = len(inspection_time)\n        time = [[0 for _ in range(n)] for _ in range(n)]\n\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    time[i][j] = flights[i][j]\n\n        planes = 0\n        used_airports = set()\n        new_flights = []\n\n        while flights:\n            min_time = float('inf')\n            next_flight = -1\n\n            for i, (s, f, t) in enumerate(flights):\n                if s in used_airports and f not in used_airports:\n                    time[s][f] = dijkstra(time, s, f)\n\n                if t + time[s][f] < min_time:\n                    min_time = t + time[s][f]\n                    next_flight = i\n\n            if next_flight == -1:\n                break\n\n            s, f, t = flights.pop(next_flight)\n            used_airports.add(s)\n            used_airports.add(f)\n            planes += 1\n            new_flights.append((s, f, t))\n\n            for i, row in enumerate(time):\n                for j, w in enumerate(row):\n                    if i != j and (i, j) not in used_airports and (s, j) in used_airports:\n                        time[i][j] = min(time[i][j], time[s][j] + time[i][j])\n\n            flights.extend(new_flights)\n            new_flights.clear()\n\n        return planes\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines.pop(0).split())\n    inspection_time = [int(i) for i in lines.pop(0).split()]\n    flights = []\n\n    for _ in range(m):\n        s, f, t = map(int, lines.pop(0).split())\n        flights.append((s, f, t))\n\n    return min_planes(flights, inspection_time)\n\n\ndef"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_flight_time(graph, start, end):\n        visited = [False] * n\n        queue = [(start, 0)]\n        visited[start] = True\n        flight_time = 0\n        while queue:\n            node, cost = queue.pop(0)\n            if node == end:\n                flight_time = cost\n                break\n            for neighbor, weight in enumerate(graph[node]):\n                if not visited[neighbor] and weight > 0:\n                    queue.append((neighbor, cost + weight))\n                    visited[neighbor] = True\n        return flight_time\n\n    def calculate_inspection_time(inspection_times, start, end):\n        return inspection_times[end]\n\n    def calculate_minimum_planes(flight_times, inspection_times, flights):\n        planes = [0] * n\n        for start, end, time in flights:\n            planes[start] += 1\n            planes[end] += 1\n            flight_time = calculate_flight_time(flight_times, start, end)\n            inspection_time = calculate_inspection_time(inspection_times, start, end)\n            planes[start] += inspection_time // flight_time + 1\n        return max(planes)\n\n    def process_input(input_str: str):\n        n, m = map(int, input_str.split())\n        inspection_times = list(map(int, input_str.split()))\n        graph = [list(map(int, input_str.split())) for _ in range(n)]\n        flights = []\n        for _ in range(m):\n            s, f, t = map(int, input_str.split())\n            flights.append((s, f, t))\n        return n, m, inspection_times, graph, flights\n\n    n, m, inspection_times, flight_times, flights = process_input(stdin)\n    result = calculate_minimum_planes(flight_times, inspection_times, flights)\n    return str(result)\n"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def bellman_ford(flights, inspection_times, start_time, end_time, n):\n        dist = [float('inf')] * n\n        dist[start_time] = 0\n        for _ in range(n - 1):\n            for flight in flights:\n                from_time, to_time, time = flight\n                if dist[from_time] != float('inf'):\n                    dist[to_time] = min(dist[to_time], dist[from_time] + time)\n        for flight in flights:\n            from_time, to_time, time = flight\n            if dist[from_time] != float('inf'):\n                dist[to_time] = min(dist[to_time], dist[from_time] + time + inspection_times[to_time])\n            if dist[to_time] > time_limit - dist[start_time]:\n                return False\n        return dist[end_time] != float('inf')\n\n    def dfs(flights, inspection_times, visited, start_time, end_time, n, time_limit, planes):\n        if planes == 0:\n            return False\n        if time_limit - inspection_times[start_time] < 0:\n            return False\n        if start_time == end_time:\n            return planes - 1\n        visited[start_time] = True\n        for flight in flights:\n            from_time, to_time, time = flight\n            if not visited[to_time] and (to_time != start_time or time == 0):\n                if dfs(flights, inspection_times, visited, to_time, end_time, n, time_limit - time - inspection_times[start_time], planes - 1):\n                    return True\n        return False\n\n    def min_planes(flights, inspection_times, start_time, end_time, n):\n        time_limit = 0\n        for i in range(n):\n            time_limit += inspection_times[i]\n        flights = sorted(flights)\n        planes = 0\n        for i in range(n):\n            if not bellman_ford(flights, inspection_times, i, end_time, n):\n                planes += 1\n        if not dfs(flights, inspection_times, [False] * n, start_time, end_time, n, time_limit, planes):\n            return -1\n        return planes\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    inspection_times = list(map(int, lines[1].split()))\n    flights = []\n    for i in range(2, 2 + n):\n        flights.append(list(map(int, lines[i].split())))\n    flights = sorted(flights)\n    for i in range(m):\n        s, f, t = map(int, lines[2 + n + i].split())\n        flights.append([s, f, t])\n    return str(min_planes(flights, inspection_times, 0, n - 1, n))\n\ninput_str = '''2 2\n1 1\n0 1\n1 0\n1 2 1\n2 1 1\n'''\n\nprint(solution(input_str))\n\ninput_str = '''2 2\n1 1\n0 1\n1 0\n1 2 1\n2 1 3\n'''\n\nprint(solution(input_str)) "
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def read_int() -> int:\n        return int(stdin.readline().strip())\n\n    def read_ints() -> List[int]:\n        return list(map(int, stdin.readline().strip().split()))\n\n    n = read_int()\n    inspection_times = read_ints()\n\n    adjacency_matrix = [read_ints() for _ in range(n)]\n\n    m = read_int()\n    flights = [read_ints() for _ in range(m)]\n\n    # Calculate the longest possible flight time\n    longest_flight_time = 0\n    for flight in flights:\n        start, end, time = flight\n        longest_flight_time = max(longest_flight_time, adjacency_matrix[start][end] + time)\n\n    # Calculate the shortest possible flight time\n    shortest_flight_time = 0\n    for i in range(n):\n        shortest_flight_time = max(shortest_flight_time, adjacency_matrix[i][i] + inspection_times[i])\n\n    # Calculate the minimum number of planes needed\n    min_planes = math.ceil((longest_flight_time - shortest_flight_time) / sum(inspection_times))\n\n    return min_planes\n"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = [False] * len(graph)\n        dist = [float('inf')] * len(graph)\n        dist[start] = 0\n\n        while not all(visited):\n            u = min(range(len(graph)), key=lambda x: dist[x] if not visited[x] else float('inf'))\n            visited[u] = True\n\n            for v, w in enumerate(graph[u]):\n                if not visited[v] and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n\n        return dist[end]\n\n    def min_planes(n, m, inspection_times, flight_times, flights):\n        planes = 1\n        flights_left = m\n\n        while flights_left > 0:\n            planes += 1\n\n            for flight in flights:\n                s, f, t = flight\n                inspection_time = inspection_times[s]\n                flight_time = flight_times[s][f]\n\n                if t - inspection_time - flight_time >= 0:\n                    flights_left -= 1\n                    if flights_left == 0:\n                        break\n\n        return planes\n\n    n, m = map(int, stdin.readline().split())\n    inspection_times = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    flight_times = [[list(map(int, stdin.readline().split())) for _ in range(n)] for _ in range(n)]\n    flights = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    total_time = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                total_time[i] += 0\n            else:\n                total_time[i] += dijkstra(flight_times, i, j)\n\n    min_planes(n, m, inspection_times, total_time, flights)\n\n    return str(min_planes(n, m, inspection_times, total_time, flights))\n"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    d, w = map(int, input_data[0].split())\n    dishes = input_data[1:]\n    discrete_dishes = []\n    continuous_dishes = []\n    \n    for dish in dishes:\n        if dish.startswith(\"D\"):\n            _, w_i, t_i, delta_t_i = dish.split()\n            discrete_dishes.append((int(w_i), int(t_i), int(delta_t_i)))\n        else:\n            _, t_i, delta_t_i = dish.split()\n            continuous_dishes.append((int(t_i), int(delta_t_i)))\n    \n    def calculate_total_tastiness(discrete_dishes: List[Tuple[int, int, int]], continuous_dishes: List[Tuple[int, int]], w: int) -> float:\n        total_tastiness = 0.0\n        remaining_weight = w\n        for w_i, t_i, delta_t_i in sorted(discrete_dishes, key=lambda x: x[1], reverse=True):\n            if remaining_weight >= w_i:\n                remaining_weight -= w_i\n                total_tastiness += t_i - (w_i - 1) * delta_t_i\n        for t_i, delta_t_i in continuous_dishes:\n            total_tastiness += t_i * w - delta_t_i * w ** 2 / 2\n            if total_tastiness > 1e6:\n                return \"impossible\"\n        return total_tastiness\n\n    total_tastiness = calculate_total_tastiness(discrete_dishes, continuous_dishes, w)\n    if isinstance(total_tastiness, str):\n        return total_tastiness\n    else:\n        return f\"{total_tastiness:.6f}\"\n"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    d, w = map(int, input_lines[0].split())\n    dishes = input_lines[1:]\n\n    discrete_dishes = []\n    continuous_dishes = []\n\n    for dish in dishes:\n        if dish.startswith('D'):\n            weight, taste, decay = map(int, dish.split()[1:])\n            discrete_dishes.append((weight, taste, decay))\n        elif dish.startswith('C'):\n            taste, decay = map(int, dish.split()[1:])\n            continuous_dishes.append((taste, decay))\n\n    def calculate_tastiness(discrete_dishes, continuous_dishes):\n        total_tastiness = 0\n        used_weight = 0\n\n        for weight, taste, decay in discrete_dishes:\n            total_tastiness += (taste - used_weight * decay) * weight\n            used_weight += weight\n\n        for taste, decay in continuous_dishes:\n            total_tastiness += (taste - used_weight * decay) * weight\n            used_weight += weight\n\n        return total_tastiness\n\n    if w == 0:\n        return \"0.000000000\"\n\n    max_tastiness = calculate_tastiness(discrete_dishes, continuous_dishes)\n    if w % 1000 != 0:\n        return \"impossible\"\n    else:\n        return f\"{max_tastiness:.6f}\"\n"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def discrete_tastiness(n, t, dt, w):\n        return t - (n-1) * dt\n\n    def continuous_tastiness(x, t, dt, w):\n        return (t - x * dt) * x\n\n    def max_tastiness(dishes):\n        max_discrete_tastiness = 0\n        max_continuous_tastiness = 0\n        for dish in dishes:\n            if dish[0] == 'D':\n                w_i, t_i, dt_i = map(int, dish[1:].split())\n                max_discrete_tastiness += discrete_tastiness(w_i, t_i, dt_i, w)\n            elif dish[0] == 'C':\n                t_i, dt_i = map(int, dish[1:].split())\n                max_continuous_tastiness += continuous_tastiness(w, t_i, dt_i, w)\n        return max(max_discrete_tastiness, max_continuous_tastiness)\n\n    def is_possible(dishes, w):\n        total_weight = 0\n        for dish in dishes:\n            if dish[0] == 'D':\n                w_i, _, _ = map(int, dish[1:].split())\n                total_weight += w_i\n            elif dish[0] == 'C':\n                _, _ = map(int, dish[1:].split())\n        return total_weight == w\n\n    n, w = map(int, stdin.splitlines()[0].split())\n    dishes = stdin.splitlines()[1:]\n\n    if not is_possible(dishes, w):\n        return \"impossible\"\n    else:\n        return f\"{max_tastiness(dishes):.6f}\""
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def discrete_tastiness(n, w_i, t_i, dt_i):\n        return t_i - (n-1) * dt_i\n\n    def continuous_tastiness(x, t_i, dt_i):\n        return (t_i - x * dt_i) * x\n\n    def meal_tastiness(meal_w):\n        tastiness = 0\n        for i in range(len(discrete_dishes)):\n            n = 1 + meal_w // discrete_dishes[i][0]\n            tastiness += discrete_tastiness(n, *discrete_dishes[i][1:])\n        for i in range(len(continuous_dishes)):\n            tastiness += continuous_tastiness(meal_w, *continuous_dishes[i][1:])\n        return tastiness\n\n    stdin_list = stdin.split('\\n')\n    d, w = map(int, stdin_list[0].split())\n    discrete_dishes = []\n    continuous_dishes = []\n\n    for i in range(1, d+1):\n        line = stdin_list[i].split()\n        if line[0] == 'D':\n            discrete_dishes.append(list(map(int, line[1:])))\n        else:\n            continuous_dishes.append(list(map(int, line[1:])))\n\n    if w == 0:\n        return 'impossible'\n    meal_w = 0\n    for i in range(len(discrete_dishes)):\n        meal_w += discrete_dishes[i][0]\n    if meal_w > w:\n        return 'impossible'\n    for i in range(len(continuous_dishes)):\n        meal_w += continuous_dishes[i][0]\n        if meal_w > w:\n            return 'impossible'\n\n    return format(meal_tastiness(w), '.6f')\n"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def discrete_tastiness(n: int, w_i: int, t_i: int, delta_t_i: int) -> float:\n        return t_i - (n - 1) * delta_t_i\n\n    def continuous_tastiness(x: float, t_i: int, delta_t_i: int) -> float:\n        return (t_i - x * delta_t_i) * x\n\n    def discrete_meal_tastiness(w: int, w_i: int, t_i: int, delta_t_i: int) -> float:\n        n = w // w_i\n        return sum((discrete_tastiness(n, w_i, t_i, delta_t_i) for _ in range(n)))\n\n    def continuous_meal_tastiness(w: int, t_i: int, delta_t_i: int) -> float:\n        return integrate.quad(lambda x: continuous_tastiness(x, t_i, delta_t_i), 0, w)[0]\n\n    d, w = map(int, stdin.split()[0:2])\n    dishes = stdin.split('\\n')[1:]\n\n    if d == 0:\n        return \"impossible\"\n\n    max_tastiness = 0.0\n\n    for line in dishes:\n        if line.startswith('D '):\n            _, w_i, t_i, delta_t_i = map(int, line.split())\n            max_tastiness += discrete_meal_tastiness(w, w_i, t_i, delta_t_i)\n        elif line.startswith('C '):\n            _, t_i, delta_t_i = map(int, line.split())\n            max_tastiness += continuous_meal_tastiness(w, t_i, delta_t_i)\n        else:\n            raise ValueError(\"Invalid dish description\")\n\n    return f\"{max_tastiness:.6f}\""
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    d, w = map(int, input_data[0].split())\n    dishes = input_data[1:]\n\n    def compute_tastiness(t_i, w_i, n, delta_t_i):\n        return t_i - (n - 1) * delta_t_i if w_i == 1 else 0\n\n    discrete_dishes = []\n    continuous_dishes = []\n    for dish in dishes:\n        if dish.startswith(\"D\"):\n            w_i, t_i, delta_t_i = map(int, dish.split()[1:])\n            discrete_dishes.append((w_i, t_i, delta_t_i))\n        else:\n            t_i, delta_t_i = map(int, dish.split()[1:])\n            continuous_dishes.append((t_i, delta_t_i))\n\n    max_tastiness = 0\n    for w_i, t_i, delta_t_i in discrete_dishes:\n        if w_i <= w:\n            max_tastiness += compute_tastiness(t_i, w_i, 1, delta_t_i)\n            w -= w_i\n    if w > 0:\n        for t_i, delta_t_i in continuous_dishes:\n            max_tastiness += compute_tastiness(t_i, 1, w, delta_t_i)\n            if w == 0:\n                break\n\n    if max_tastiness > 0:\n        return f\"{max_tastiness:.6f}\"\n    else:\n        return \"impossible\"\n\ninput_data = \"\"\"2 15\nD 4 10 1\nC 6 1\n\"\"\"\n\nprint(solution(input_data))"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    d, w = map(int, input_data[0].split())\n    dishes = input_data[1:]\n    \n    total_tastiness = 0\n    \n    for dish in dishes:\n        if dish.startswith('D '):\n            weight, tastiness, decay = map(int, dish.split()[1:])\n            total_tastiness += (tastiness - (w - weight) * decay) * weight\n        elif dish.startswith('C '):\n            tastiness, decay = map(int, dish.split()[1:])\n            total_tastiness += tastiness * (w / (1 - decay) + (1 - 1 / (1 - decay)) * decay)\n    \n    if total_tastiness == 0:\n        return \"impossible\"\n    else:\n        return round(total_tastiness, 6)"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def discrete_tastiness(n, t_i, decay_t_i):\n        return t_i - (n - 1) * decay_t_i\n\n    def continuous_tastiness(weight, t_i, decay_t_i):\n        return (t_i - weight * decay_t_i) * weight\n\n    def max_tastiness(dishes):\n        discrete_total_tastiness = 0\n        continuous_total_tastiness = 0\n\n        for dish in dishes:\n            if dish[0] == 'D':\n                w_i, t_i, decay_t_i = map(int, dish.split()[1:])\n                for i in range(1, w_i + 1):\n                    discrete_total_tastiness += discrete_tastiness(i, t_i, decay_t_i)\n            else:\n                t_i, decay_t_i = map(int, dish.split()[1:])\n                continuous_total_tastiness += continuous_tastiness(w, t_i, decay_t_i)\n\n        return max(discrete_total_tastiness + continuous_total_tastiness, 0)\n\n    _, w = map(int, stdin.splitlines()[0].split())\n    dishes = stdin.splitlines()[1:]\n    if not all(dish.count(' ') == 2 for dish in dishes):\n        return \"impossible\"\n\n    return f\"{max_tastiness(dishes):.6f}\""
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def discrete_dish_tastiness(w_i, t_i, delta_t_i, n):\n        return t_i - (n-1) * delta_t_i\n\n    def continuous_dish_tastiness(t_i, delta_t_i, x):\n        return (t_i - x * delta_t_i) * x\n\n    def discrete_dish_weight(w_i, n):\n        return n * w_i\n\n    def continuous_dish_weight(t_i, delta_t_i, x):\n        return x\n\n    def tastiness(w_i, t_i, delta_t_i, n):\n        return discrete_dish_tastiness(w_i, t_i, delta_t_i, n)\n\n    def weight(w_i, n):\n        return discrete_dish_weight(w_i, n)\n\n    def weight_fraction(w_i, t_i, delta_t_i, x):\n        return continuous_dish_weight(t_i, delta_t_i, x)\n\n    input_str = stdin.split('\\n')\n    d, w = map(int, input_str.pop(0).split())\n    meal = {}\n\n    for _ in range(d):\n        line = input_str.pop(0).split()\n        if line[0] == 'D':\n            w_i, t_i, delta_t_i = map(int, line[1:])\n            meal[f'D{w_i}'] = {'w_i': w_i, 't_i': t_i, 'delta_t_i': delta_t_i}\n        elif line[0] == 'C':\n            t_i, delta_t_i = map(int, line[1:])\n            meal[f'C{t_i}'] = {'t_i': t_i, 'delta_t_i': delta_t_i}\n\n    meal_tastiness = 0\n    meal_weight = 0\n    for dish, info in meal.items():\n        if dish.startswith('D'):\n            w_i, t_i, delta_t_i, n = info['w_i'], info['t_i'], info['delta_t_i'], 1\n            meal_tastiness += tastiness(w_i, t_i, delta_t_i, n)\n            meal_weight += weight(w_i, n)\n        else:\n            t_i, delta_t_i = info['t_i'], info['delta_t_i']\n            x = int((w - meal_weight) / (w - meal_weight + 1e-6))\n            meal_tastiness += weight_fraction(t_i, delta_t_i, x)\n            meal_weight += continuous_dish_weight(t_i, delta_t_i, x)\n\n    if meal_weight == w:\n        return round(meal_tastiness, 6)\n    else:\n        return 'impossible'"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def discrete_dish(n, w_i, t_i, delta_t_i):\n        return t_i - (n - 1) * delta_t_i\n\n    def continuous_dish(x, t_i, delta_t_i):\n        return (t_i - x * delta_t_i) * x\n\n    def total_tastiness(w, dishes):\n        discrete_tastiness = [discrete_dish(n, w_i, t_i, delta_t_i)\n                            for n, (w_i, t_i, delta_t_i) in dishes if w_i <= w]\n        continuous_tastiness = [continuous_dish(x, t_i, delta_t_i)\n                             for x, t_i, delta_t_i in dishes if w <= t_i + x * delta_t_i]\n        return sum(discrete_tastiness) + sum(continuous_tastiness)\n\n    n, w = map(int, stdin.split()[:2])\n    dishes = [line.split() for line in stdin.split('\\n')[1:]]\n    dishes = [(int(w_i), int(t_i), int(delta_t_i))\n                 for i, (dish_type, w_i, t_i, delta_t_i) in enumerate(dishes)\n                 if dish_type == 'D']\n    continuous_dishes = [(float(t_i), int(delta_t_i))\n                      for i, (dish_type, t_i, delta_t_i) in enumerate(dishes)\n                      if dish_type == 'C']\n    if not dishes and not continuous_dishes:\n        return \"impossible\"\n    else:\n        return f\"{total_tastiness(w, dishes):.6f}\""
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, visited: set, path: list, count: int, target: int, graph: list) -> bool:\n        if count == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited and dfs(neighbor, visited, path, count+1, target, graph):\n                path.append(neighbor)\n                return True\n        visited.remove(node)\n        return False\n\n    n = int(stdin.split('\\n')[0])\n    songs = []\n    graph = [[] for _ in range(n+1)]\n    for i in range(1, n+1):\n        song = stdin.split('\\n')[i].split()\n        artist = song[0]\n        num_neighbors = int(song[1])\n        neighbors = list(map(int, song[2:]))\n        songs.append((artist, num_neighbors, neighbors))\n        for neighbor in neighbors:\n            graph[i].append(neighbor)\n\n    playlist = [1]\n    while len(playlist) < 9:\n        next_song = songs[playlist[-1]-1][2][0]\n        playlist.append(next_song)\n        songs[playlist[-1]-1][1] -= 1\n        songs[playlist[-1]-1][2].remove(playlist[-2])\n\n    if len(playlist) == 9:\n        return ' '.join(map(str, playlist))\n    else:\n        return 'fail'\n\ninput_str = \"\"\"10\na 2 10 3\nb 1 6\nc 2 1 5\nd 1 9\ne 1 4\nf 1 2\ng 2 6 8\nh 0\ni 1 3\nj 1 7\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_playlist(playlist: list) -> bool:\n        def is_valid_chain(start: int, end: int) -> bool:\n            visited = set()\n            queue = [start]\n            while queue:\n                current = queue.pop(0)\n                if current == end:\n                    return True\n                if current in visited:\n                    return False\n                visited.add(current)\n                for neighbor in adjacency_list[current]:\n                    queue.append(neighbor)\n            return False\n\n        for i in range(1, len(playlist)):\n            if not is_valid_chain(playlist[i - 1], playlist[i]):\n                return False\n        return True\n\n    def build_adjacency_list() -> dict:\n        adjacency_list = {}\n        for _ in range(n):\n            adjacency_list[_] = []\n        for i in range(1, n + 1):\n            for j in range(1, t[i] + 1):\n                adjacency_list[i].append(s[i][j])\n        return adjacency_list\n\n    n, *t, *s = map(int, stdin.split())\n    s = [s[i : i + t[i]] for i in range(0, len(t), t[0])]\n    t = [t[i] for i in range(1, len(t), t[0])]\n    adjacency_list = build_adjacency_list()\n\n    playlist = [1]\n    for i in range(1, n):\n        next_song = None\n        for neighbor in adjacency_list[playlist[-1]]:\n            if neighbor != playlist[-1]:\n                next_song = neighbor\n                break\n        if next_song is None:\n            return \"fail\"\n        playlist.append(next_song)\n\n    if is_valid_playlist(playlist):\n        return \" \".join(map(str, playlist))\n    else:\n        return \"fail\"\n"
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_common_songs(song1: int, song2: int, songs: List[Tuple[int, int]]) -> bool:\n        if song1 == song2:\n            return True\n        for i in range(len(songs)):\n            if i == song1 - 1 and song2 - 1 in songs[i]:\n                return True\n            if i == song2 - 1 and song1 - 1 in songs[i]:\n                return True\n        return False\n\n    def backtrack(remaining_songs: List[int], songs: List[Tuple[int, int]], playlist: List[int]) -> None:\n        if len(playlist) == 9:\n            print(\" \".join(map(str, playlist)))\n            return\n        for song in remaining_songs:\n            if song == playlist[-1]:\n                continue\n            if all(get_common_songs(song, s, songs) for s in playlist):\n                backtrack(remaining_songs, songs, playlist + [song])\n\n    n = int(stdin.readline())\n    songs = []\n    for _ in range(n):\n        line = stdin.readline().split()\n        artist = line[0]\n        next_songs = list(map(int, line[2:]))\n        songs.append((int(line[1]), next_songs))\n\n    playlist = [1]\n    backtrack(list(range(2, n + 1)), songs, playlist)\n"
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_next_songs(n: int, songs: list, current_song: int) -> List[int]:\n        next_songs = []\n        for i in range(n):\n            if songs[i][1] == current_song:\n                next_songs.append(i)\n        return next_songs\n\n    def dfs(n: int, songs: list, current_song: int, visited: set, result: List[int], index: int) -> bool:\n        if index == 9:\n            return True\n        if current_song in visited:\n            return False\n        visited.add(current_song)\n        next_songs = find_next_songs(n, songs, current_song)\n        for next_song in next_songs:\n            if dfs(n, songs, next_song, visited.copy(), result, index + 1):\n                result[index] = next_song\n                return True\n        return False\n\n    n = int(stdin.split('\\n')[0])\n    songs = [line.split() for line in stdin.split('\\n')[1:]]\n    for i in range(n):\n        songs[i][1] = int(songs[i][1])\n    for i in range(n):\n        songs[i][2:] = list(map(int, songs[i][2:]))\n\n    result = [-1] * 9\n    if not dfs(n, songs, 0, set(), result, 0):\n        return \"fail\"\n    return ' '.join(map(str, result))"
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n = int(stdin)\n    songs = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        line = stdin.split(\"\\n\")[i].split()\n        artist = line[0]\n        t = int(line[1])\n        s = [int(x) for x in line[2:]]\n        songs[i] = (artist, t, s)\n\n    # find playlist\n    playlist = []\n    used = [False] * (n + 1)\n    def dfs(start):\n        nonlocal playlist, used, songs\n        if len(playlist) == 9:\n            return True\n        if used[start]:\n            return False\n        used[start] = True\n        artist, t, s = songs[start]\n        if t == 0:\n            playlist.append(start)\n            if len(playlist) == 9:\n                return True\n            for i in range(1, n + 1):\n                if not used[i] and songs[i][0] != artist:\n                    if dfs(i):\n                        return True\n            return False\n        for i in s:\n            if dfs(i):\n                return True\n        return False\n\n    dfs(1)\n    if len(playlist) == 9:\n        return \" \".join(map(str, playlist))\n    else:\n        return \"fail\"\n"
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    songs = {}\n    for i in range(1, n + 1):\n        data = stdin.split(\"\\n\")[i].split()\n        artist = data[0]\n        if artist not in songs:\n            songs[artist] = []\n        songs[artist].append((int(data[1]), i))\n\n    def dfs(remaining_artists, current_song, prev_artist):\n        if len(remaining_artists) == 0:\n            return True\n        for artist in sorted(remaining_artists):\n            if artist == prev_artist:\n                continue\n            if current_song in songs[artist]:\n                for next_song in sorted(songs[artist], key=lambda x: x[1]):\n                    if next_song[0] != current_song:\n                        if dfs(remaining_artists - {artist}, next_song[1], artist):\n                            return True\n        return False\n\n    if dfs(set(songs.keys()), 1, None):\n        playlist = []\n        current_artist = None\n        current_song = 1\n        for i in range(1, 10):\n            while current_song not in songs[current_artist]:\n                current_artist = sorted(list(songs.keys() - {current_artist}))[0]\n            next_song = sorted(songs[current_artist], key=lambda x: x[1])[0][1]\n            playlist.append(next_song)\n            current_artist = sorted(list(songs.keys() - {current_artist}))[0]\n        return \" \".join(map(str, playlist))\n    else:\n        return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start: int, target: int, visited: set, adj: list):\n        queue = [(start, [])]\n        while queue:\n            node, path = queue.pop(0)\n            if node == target:\n                return path\n            for neighbor in adj[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [node]))\n        return None\n\n    def find_playlist(songs: list, adj: list, target: int) -> list:\n        for i in range(len(songs)):\n            if bfs(i + 1, target, set(), adj) is not None:\n                return [i + 1] + bfs(i + 1, target, set(), adj)[1:]\n        return []\n\n    n, *data = stdin.split()\n    n = int(n)\n    songs = [data[i:i + 2] for i in range(0, len(data), 2)]\n    adj = [[] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, songs[i - 1][1] + 1):\n            adj[i].append(songs[i - 1][1] + songs[i - 1][2][j - 1])\n\n    target = 10\n    playlist = find_playlist(songs, adj, target)\n    if playlist:\n        return ' '.join(map(str, playlist))\n    else:\n        return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, visited: set, graph: list, stack: list) -> bool:\n        if len(stack) == 9:\n            return True\n        visited.add(node)\n        for neighbor in range(len(graph)):\n            if neighbor not in visited and graph[node][neighbor] > 0:\n                graph[node][neighbor] -= 1\n                graph[neighbor][node] -= 1\n                if dfs(neighbor, visited, graph, stack):\n                    stack.append(neighbor)\n                    return True\n                graph[node][neighbor] += 1\n                graph[neighbor][node] += 1\n        visited.remove(node)\n        return False\n\n    songs = stdin.split(\"\\n\")\n    num_songs = int(songs.pop(0))\n    if num_songs != 9:\n        return \"fail\"\n\n    graph = [[0] * num_songs for _ in range(num_songs)]\n    for song in songs:\n        artist, connections = song.split()\n        connections = [int(s) for s in connections.split()]\n        for neighbor in connections:\n            graph[artists.index(artist)][neighbor - 1] = 1\n\n    artists = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]\n    for start in range(num_songs):\n        if dfs(start, set(), graph, []):\n            return \" \".join(str(song + 1) for song in stack)\n\n    return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(adj_list: list, start_node: int, target_node: int) -> bool:\n        visited = [False] * n\n        queue = [start_node]\n        visited[start_node] = True\n        while queue:\n            current_node = queue.pop(0)\n            if current_node == target_node:\n                return True\n            for neighbor in adj_list[current_node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        return False\n\n    def find_playlist(adj_list: list) -> str:\n        playlist = [1]\n        for i in range(1, n):\n            for j in range(1, n + 1):\n                if bfs(adj_list, j, i + 1):\n                    playlist.append(i + 1)\n                    break\n            if len(playlist) == 9:\n                return ' '.join(map(str, playlist))\n        return 'fail'\n\n    n, *data = stdin.split('\\n')\n    n = int(n)\n    adj_list = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        _, t, *s_list = data[i - 1].split()\n        t = int(t)\n        s_list = list(map(int, s_list))\n        for s in s_list:\n            adj_list[i].append(s)\n\n    return find_playlist(adj_list)\n\ninput_data = '''10\na 2 10 3\nb 1 6\nc 2 1 5\nd 1 9\ne 1 4\nf 1 2\ng 2 6 8\nh 0\ni 1 3\nj 1 7'''\n\nprint(solution(input_data)) # expected output: \"5 4 9 3 1 10 7 6 2\" "
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, visited: set, path: list, visited_edges: set, remaining: int) -> bool:\n        if len(path) == remaining:\n            return True\n        for adj in graph[node]:\n            if adj not in visited_edges and adj not in visited:\n                if dfs(adj, visited, path + [adj], visited_edges | {(node, adj)}, remaining):\n                    return True\n        return False\n\n    def find_path(start: int, end: int) -> list:\n        visited_edges = set()\n        visited = set()\n        path = [start]\n        if not dfs(start, visited, path, visited_edges, 8):\n            return []\n        return path\n\n    def is_valid_playlist(playlist: list) -> bool:\n        for i in range(len(playlist) - 1):\n            for j in range(i + 1, len(playlist)):\n                if graph[playlist[i]][playlist[j]] == 0:\n                    return False\n        return True\n\n    def find_common_node(path1: list, path2: list) -> int:\n        for i in range(len(path1)):\n            for j in range(len(path2)):\n                if path1[i] == path2[j]:\n                    return path1[i]\n        return -1\n\n    def find_playlist() -> str:\n        nodes = list(range(1, n + 1))\n        random.shuffle(nodes)\n        playlist = []\n        for i in range(9):\n            node = nodes.pop()\n            for _ in range(i + 1):\n                path = find_path(node, node)\n                if not path:\n                    return \"fail\"\n                node = find_common_node(playlist, path)\n                if node == -1:\n                    return \"fail\"\n            playlist.append(node)\n        return \" \".join(map(str, playlist))\n\n    n = int(stdin.splitlines()[0])\n    graph = [[] for _ in range(n + 1)]\n    for line in stdin.splitlines()[1:]:\n        artist, *edges = line.split()\n        for edge in edges:\n            graph[int(edge)].append(int(artist))\n\n    playlist = find_playlist()\n    if is_valid_playlist(playlist):\n        return playlist\n    else:\n        return \"fail\""
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def add_one(time: str) -> str:\n        hour, minute = map(int, time.split(':'))\n        if minute < 59:\n            minute += 1\n        else:\n            minute = 0\n            if hour < 23:\n                hour += 1\n            else:\n                hour = 0\n        return f\"{hour:02}:{minute:02}\"\n\n    def subtract_one(time: str) -> str:\n        hour, minute = map(int, time.split(':'))\n        if minute > 0:\n            minute -= 1\n        else:\n            minute = 59\n            if hour > 0:\n                hour -= 1\n            else:\n                hour = 23\n        return f\"{hour:02}:{minute:02}\"\n\n    original_time, current_time = stdin.split('\\n')\n    visited_times = set()\n\n    while current_time != original_time:\n        visited_times.add(current_time)\n        if current_time < original_time:\n            current_time = add_one(current_time)\n        else:\n            current_time = subtract_one(current_time)\n\n    return str(len(visited_times)) + '\\n' + '\\n'.join(visited_times)\n"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    original_time, current_time = stdin.split('\\n')\n    \n    # Parse input times\n    orig_h, orig_m = map(int, original_time.split(':'))\n    curr_h, curr_m = map(int, current_time.split(':'))\n    \n    # Calculate time difference\n    diff_h, diff_m = curr_h - orig_h, curr_m - orig_m\n    \n    # Normalize time difference\n    if diff_m < 0:\n        diff_m += 60\n        diff_h -= 1\n    if diff_h < 0:\n        diff_h += 24\n    \n    # Calculate all possible times\n    times = set()\n    for h in range(24):\n        for m in range(60):\n            if (h, m) == (curr_h, curr_m):\n                times.add(current_time)\n            else:\n                diff_h_ = h - orig_h\n                diff_m_ = m - orig_m\n                if diff_m_ < 0:\n                    diff_m_ += 60\n                    diff_h_ -= 1\n                if diff_h_ < 0:\n                    diff_h_ += 24\n                if diff_h_ == diff_h and diff_m_ == diff_m:\n                    times.add(f\"{h:02d}:{m:02d}\")\n    \n    # Output solution\n    result = f\"{len(times)}\\n\" + '\\n'.join(sorted(times))\n    return result"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    original_time = stdin[0]\n    current_time = stdin[1]\n\n    original_hour, original_minute = original_time.split(':')\n    current_hour, current_minute = current_time.split(':')\n\n    original_hour, original_minute = int(original_hour), int(original_minute)\n    current_hour, current_minute = int(current_hour), int(current_minute)\n\n    difference_hour = current_hour - original_hour\n    difference_minute = current_minute - original_minute\n\n    if difference_minute < 0:\n        difference_minute += 60\n        difference_hour -= 1\n\n    if difference_hour < 0:\n        difference_hour += 24\n\n    times_seen = 0\n    for i in range(difference_hour + 1):\n        for j in range(difference_minute + 1):\n            times_seen += 1\n            new_hour = (original_hour + i) % 24\n            new_minute = (original_minute + j) % 60\n            print(f'{new_hour:02d}:{new_minute:02d}')\n\n    return f'{times_seen}'\n\n\ndef"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    original_time, current_time = stdin.split('\\n')\n    original_hour, original_minute = map(int, original_time.split(':'))\n    current_hour, current_minute = map(int, current_time.split(':'))\n\n    if original_hour == current_hour:\n        if original_minute == current_minute:\n            return \"0\\n\" + current_time\n        else:\n            return \"1\\n\" + current_time\n    elif current_hour < original_hour:\n        if current_minute < original_minute:\n            return \"2\\n\" + current_time + \"\\n\" + current_time.replace(':', '0')\n        else:\n            return \"1\\n\" + current_time\n    else:\n        if current_minute < original_minute:\n            return \"2\\n\" + current_time + \"\\n\" + \"23\" + current_time[2:]\n        else:\n            return \"1\\n\" + current_time\n\ndef"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    original_time, current_time = stdin.strip().split('\\n')\n    original_hour, original_minute = map(int, original_time.split(':'))\n    current_hour, current_minute = map(int, current_time.split(':'))\n\n    # Calculate the number of times to set the clock\n    num_times = 1\n    if original_hour > current_hour:\n        num_times = 24 - original_hour + current_hour\n    elif original_hour < current_hour:\n        num_times = current_hour - original_hour\n    if original_minute > current_minute:\n        num_times = num_times * 4 - (original_minute - current_minute) // 5\n    else:\n        num_times = num_times * 4 + (current_minute - original_minute) // 5\n\n    # Calculate the times to set the clock\n    times = []\n    for i in range(num_times):\n        new_hour = (original_hour + i) % 24\n        new_minute = (original_minute + 5 * (i % 4)) % 60\n        times.append(f'{new_hour:02d}:{new_minute:02d}')\n\n    return f'{num_times}\\n' + '\\n'.join(times)"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    original_time = input_list[0]\n    current_time = input_list[1]\n\n    def set_time(time: str, new_time: str) -> str:\n        h1, m1 = map(int, time.split(':'))\n        h2, m2 = map(int, new_time.split(':'))\n\n        if h2 < h1:\n            h2 += 24\n        if m2 < m1:\n            m2 += 60\n\n        if h2 == h1 and m2 == m1:\n            return ''\n\n        h_diff = h2 - h1\n        m_diff = m2 - m1\n\n        if h_diff == 1:\n            return f'{h1 + 1:02d}:{m2:02d}'\n        elif h_diff == -1:\n            return f'{h1 - 1:02d}:{m2:02d}'\n        elif m_diff == 1:\n            return f'{h2:02d}:{m1 + 1:02d}'\n        elif m_diff == -1:\n            return f'{h2:02d}:{m1 - 1:02d}'\n        else:\n            return ''\n\n    result = []\n    for h in range(24):\n        for m in range(60):\n            new_time = f'{h:02d}:{m:02d}'\n            if new_time != current_time:\n                time_str = set_time(original_time, new_time)\n                if time_str:\n                    result.append(time_str)\n\n    return str(len(result)) + '\\n' + '\\n'.join(result) + '\\n'"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    original_time = input_list[0]\n    current_time = input_list[1]\n\n    def increment_time(time: str) -> str:\n        hh, mm = time.split(\":\")\n        hh, mm = int(hh), int(mm)\n        if mm < 59:\n            mm += 1\n        else:\n            hh += 1\n            mm = 0\n        if hh > 23:\n            hh = 0\n        return f\"{hh:02d}:{mm:02d}\"\n\n    def decrement_time(time: str) -> str:\n        hh, mm = time.split(\":\")\n        hh, mm = int(hh), int(mm)\n        if mm > 0:\n            mm -= 1\n        else:\n            hh -= 1\n            mm = 59\n        if hh < 0:\n            hh = 23\n        return f\"{hh:02d}:{mm:02d}\"\n\n    def is_valid_time(time: str) -> bool:\n        hh, mm = time.split(\":\")\n        hh, mm = int(hh), int(mm)\n        return 0 <= hh <= 23 and 0 <= mm <= 59\n\n    def set_clock(time: str, target_time: str) -> None:\n        if target_time < time:\n            target_time = increment_time(target_time)\n        while target_time > time:\n            time = increment_time(time)\n        return time\n\n    seen_times = set()\n    current_time = current_time.replace(\":\", \"\")\n    while current_time not in seen_times:\n        seen_times.add(current_time)\n        current_time = set_clock(current_time, current_time)\n\n    result = []\n    for time in seen_times:\n        result.append(f\"{original_time}:{time[:2]}:{time[2:]}\")\n\n    return len(seen_times) - 1, *result\n"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    original_time, current_time = stdin.split('\\n')\n    original_hour, original_minute = map(int, original_time.split(':'))\n    current_hour, current_minute = map(int, current_time.split(':'))\n\n    def set_clock(hour, minute, direction):\n        if direction == 'increase':\n            if minute == 59:\n                minute = 0\n                if hour == 23:\n                    hour = 0\n                else:\n                    hour += 1\n            else:\n                minute += 1\n        elif direction == 'decrease':\n            if minute == 0:\n                minute = 59\n                if hour == 0:\n                    hour = 23\n                else:\n                    hour -= 1\n            else:\n                minute -= 1\n        return hour, minute\n\n    def check_time(hour, minute):\n        return hour in range(0, 24) and minute in range(0, 60)\n\n    unique_times = set()\n    for direction in ('increase', 'decrease'):\n        new_hour, new_minute = set_clock(original_hour, original_minute, direction)\n        while check_time(new_hour, new_minute):\n            unique_times.add(f'{new_hour:02d}:{new_minute:02d}')\n            new_hour, new_minute = set_clock(new_hour, new_minute, direction)\n\n    return f'{len(unique_times)}\\n' + '\\n'.join(unique_times)\n"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def increment(time: str) -> str:\n        hour, minute = map(int, time.split(':'))\n        if minute == 59:\n            if hour == 23:\n                hour = 0\n            else:\n                hour += 1\n            minute = 0\n        else:\n            minute += 1\n        return f\"{hour:02d}:{minute:02d}\"\n\n    def decrement(time: str) -> str:\n        hour, minute = map(int, time.split(':'))\n        if minute == 0:\n            if hour == 0:\n                hour = 23\n            else:\n                hour -= 1\n            minute = 59\n        else:\n            minute -= 1\n        return f\"{hour:02d}:{minute:02d}\"\n\n    def is_valid(time: str) -> bool:\n        hour, minute = map(int, time.split(':'))\n        return 0 <= hour <= 23 and 0 <= minute <= 59\n\n    stdin_lines = stdin.strip().split('\\n')\n    original_time = stdin_lines[0]\n    current_time = stdin_lines[1]\n\n    if not is_valid(current_time) or not is_valid(original_time):\n        return \"Invalid input\"\n\n    if current_time == original_time:\n        return \"1\\n\" + current_time\n\n    clock_times = []\n    current_time_str = increment(current_time)\n    clock_times.append(current_time)\n\n    while current_time_str != original_time:\n        if is_valid(current_time_str):\n            clock_times.append(current_time_str)\n        current_time_str = increment(current_time_str)\n\n    clock_times.append(original_time)\n    return f\"{len(clock_times)}\\n\" + \"\\n\".join(clock_times)"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    std_time = input_data[0]\n    current_time = input_data[1]\n\n    def increment_time(time: str, by_hour: bool) -> str:\n        hour, minute = time.split(':')\n        hour = int(hour)\n        minute = int(minute)\n        if by_hour:\n            if minute == 59:\n                hour += 1\n                minute = 0\n                if hour == 24:\n                    hour = 0\n            else:\n                minute += 1\n        else:\n            if minute == 0:\n                hour -= 1\n                minute = 59\n                if hour == -1:\n                    hour = 23\n            else:\n                minute -= 1\n        return f\"{hour:02d}:{minute:02d}\"\n\n    def count_valid_times(start_time: str, current_time: str) -> int:\n        valid_times = 0\n        for hour in range(0, 24):\n            for minute in range(0, 60):\n                if current_time == f\"{hour:02d}:{minute:02d}\":\n                    valid_times += 1\n        return valid_times\n\n    def get_time(start_time: str, current_time: str) -> str:\n        time = start_time\n        while time != current_time:\n            time = increment_time(time, True)\n            yield time\n            time = increment_time(time, False)\n\n    valid_times = count_valid_times(std_time, current_time)\n    print(valid_times)\n    for time in get_time(std_time, current_time):\n        print(time)\n"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    i = 0\n    result = \"\"\n    while i < len(stdin):\n        if stdin[i] == \"(\":\n            stack.append(i)\n        elif stdin[i] == \")\":\n            start = stack.pop()\n            result += f\"{start},{i}:\"\n        i += 1\n    return result\n\ndef"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    start_index = 0\n    result = \"\"\n\n    for index, char in enumerate(stdin):\n        if char == \"(\":\n            stack.append(char)\n            result += f\"{start_index},{index}:{start_index},{index}:{start_index},{index}:{start_index},{index}:\"\n            start_index = index + 1\n        elif char == \")\":\n            stack.pop()\n            result = result[:-1]\n\n    if len(stack) == 0:\n        return result[:-1]\n    else:\n        return result\n"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def convert_to_alternative_bracket_notation(s: str) -> str:\n        stack = []\n        result = []\n        start = 0\n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if not stack:\n                    return \"Invalid bracket notation\"\n                start_index = stack.pop()\n                result.append(f\"{start_index},{i}:{start},1:\")\n                start = i + 1\n        if stack:\n            return \"Invalid bracket notation\"\n        return ','.join(result)\n\n    def shortest_alternative_bracket_notation(s: str) -> str:\n        notation = convert_to_alternative_bracket_notation(s)\n        if notation == \"Invalid bracket notation\":\n            return notation\n        return min(notation.split(','), key=lambda x: (x.count(':'), x.count('1')))\n\n    return shortest_alternative_bracket_notation(stdin)\n"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    start = 0\n    min_len = float('inf')\n    min_notation = \"\"\n\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if not stack:\n                return \"Invalid syntax\"\n            start = stack.pop()\n            notation = str(start) + \",\" + str(i) + \":\" + str(i) + \",\" + str(i)\n            if len(notation) < min_len:\n                min_len = len(notation)\n                min_notation = notation\n\n    if stack:\n        return \"Invalid syntax\"\n\n    return min_notation\n"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    headers = []\n    max_header = \"\"\n    for i, char in enumerate(stdin):\n        if char == \"(\":\n            stack.append(i)\n        elif char == \")\":\n            if not stack:\n                return \"Error: Unbalanced parentheses\"\n            start = stack.pop()\n            headers.append(f\"{start},{i}:{i},{i}\")\n            if len(headers[-1]) < len(max_header) or not max_header:\n                max_header = headers[-1]\n    if not stack:\n        return max_header\n    return \"Error: Unbalanced parentheses\""
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    start = 0\n    result = \"\"\n\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if len(stack) > 0:\n                start = stack.pop()\n                end = i\n                result += f\"{start},{end}:{start+1},{end-1}:\"\n\n    return result"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_start(s: str, start: int) -> int:\n        depth = 0\n        for i in range(start, len(s)):\n            if s[i] == '(':\n                depth += 1\n            elif s[i] == ')':\n                depth -= 1\n            if depth == 0:\n                return i + 1\n        return -1\n\n    def find_alternative_notation(s: str) -> str:\n        start = 0\n        result = ''\n        depth = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                depth += 1\n                end = find_start(s, i + 1)\n                if end == -1:\n                    return result\n                result += str(start) + ',' + str(end) + ':'\n                start = end\n            elif s[i] == ')':\n                depth -= 1\n        return result\n\n    return find_alternative_notation(stdin)"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    result = []\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if not stack:\n                return \"IMPOSSIBLE\"\n            start = stack.pop()\n            result.append(f\"{start},{i}:{i},{i}\")\n    if stack:\n        return \"IMPOSSIBLE\"\n    result.sort()\n    return result[0]"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    start = 0\n    max_end = 0\n    \n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                start = stack.pop()\n                end = i\n                if end - start > max_end:\n                    max_end = end - start\n                    max_start = start\n                    max_end_index = end\n            else:\n                return \"Invalid input\"\n    \n    if stack:\n        return \"Invalid input\"\n    \n    return str(max_start) + ',' + str(max_end_index) + \":\" + str(max_end_index) + ',' + str(max_end_index) + \":\" "
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    start = 0\n    alt_notation = []\n    \n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if not stack:\n                return \"There is a mismatched closing bracket at index \" + str(i)\n            start_index = stack.pop()\n            alt_notation.append((start_index+1, i))\n    \n    if stack:\n        return \"There is a mismatched opening bracket at index \" + str(stack.pop())\n    \n    alt_notation.sort()\n    alt_notation = [str(start)+\",\"+str(end)+\":\" for start, end in alt_notation]\n    \n    return \",\".join(alt_notation)"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    event_types = [[] for _ in range(M)]\n\n    for _ in range(N):\n        start, end, *counts = map(int, input().split())\n        for i, count in enumerate(counts):\n            event_types[i].extend([(start, end) for _ in range(count)])\n\n    durations = [0] * M\n\n    for events in event_types:\n        for start, end in events:\n            for i in range(M):\n                if durations[i] < end - start:\n                    durations[i] = end - start\n\n    if max(durations) == 0:\n        return \"-1\"\n\n    return \" \".join(map(str, durations))"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    events = [list(map(int, stdin.split()[i+2:i+M+4])) for i in range(0, N*M, M+4)]\n    durations = [0]*M\n\n    for event in events:\n        start_date, end_date, *freq = event\n        for i, f in enumerate(freq):\n            durations[i] += f * (end_date - start_date + 1)\n\n    total_duration = sum(durations)\n    if total_duration > 0:\n        return ' '.join(map(str, durations))\n    else:\n        return '-1'\n\ninput_data = \"\"\"\n1 1\n26 02 03 03 1\n1 1\n26 02 03 03 2\n\"\"\"\n\nresult = solution(input_data)\nprint(result)"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    events = []\n    for _ in range(N):\n        start_date, end_date, *counts = map(int, input().split())\n        events.append((start_date, end_date, counts))\n\n    durations = [0] * M\n    for start_date, end_date, counts in events:\n        for i, count in enumerate(counts):\n            if count > 0:\n                durations[i] += end_date - start_date + 1\n\n    if any(duration <= 0 for duration in durations):\n        return \"-1\"\n    else:\n        return \" \".join(map(str, durations))"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def parse_date(date_str: str) -> int:\n        year, month, day = map(int, date_str)\n        return (year - 1) * 365 + (month - 1) * 30 + day\n\n    def parse_entry(entry_str: str) -> tuple:\n        start_date, event_types = entry_str.split(' ')[:2]\n        start_date_int = parse_date(start_date)\n        event_types_int = [int(x) for x in event_types.split(' ')]\n        return start_date_int, event_types_int\n\n    N, M = map(int, stdin.split()[:2])\n    entries = [parse_entry(line) for line in stdin.split('\\n')[1:N + 1]]\n    events = [{} for _ in range(M)]\n\n    for start_date, event_types in entries:\n        for i, count in enumerate(event_types):\n            events[i][start_date] = count\n\n    event_durations = [0] * M\n    for i, event in enumerate(events):\n        sorted_dates = sorted(event.keys())\n        if not sorted_dates:\n            continue\n        for j in range(len(sorted_dates) - 1):\n            event_durations[i] += sorted_dates[j + 1] - sorted_dates[j]\n        event_durations[i] += 365 - sorted_dates[-1] + sorted_dates[0]\n\n    if any(event_durations):\n        return ' '.join(map(str, event_durations))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    observations = [list(map(int, line.strip().split())) for line in stdin.split('\\n')[1:N+1]]\n\n    # Calculate the start and end date of each event\n    start_dates, end_dates = [], []\n    for obs in observations:\n        start_dates.append([obs[i] for i in range(0, M, 3)])\n        end_dates.append([obs[i] for i in range(2, M+2, 3)])\n\n    # Calculate the duration of each event\n    durations = [0] * M\n    for i in range(M):\n        durations[i] = 0\n        for j in range(N):\n            durations[i] += end_dates[j][i] - start_dates[j][i] + 1\n\n    # Check if there is a solution\n    unique_durations = set(durations)\n    if len(unique_durations) == 1:\n        return str(list(unique_durations)[0])\n    else:\n        return \"-1\""
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    observations = [list(map(int, stdin.split()[i+2:i+7])) for i in range(N*M, len(stdin.split()), 7)]\n\n    # Calculate the event durations\n    event_durations = [0] * M\n    for observation in observations:\n        start_date, end_date, count = observation[0], observation[1], observation[2:]\n        duration = end_date - start_date + 1\n        for i, event_count in enumerate(count):\n            event_durations[i] += event_count * duration\n\n    # Check if there is at least one solution\n    if any(d > 365 for d in event_durations):\n        return \"-1\"\n\n    # Calculate the total duration of each event type\n    total_duration = sum(event_durations)\n    if total_duration > 365 * N:\n        return \"-1\"\n\n    return \" \".join(map(str, event_durations))"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def parse_date(date_str: str) -> int:\n        month, day = map(int, date_str)\n        return month * 365 + day\n\n    def parse_observations(observations: str) -> List[Tuple[int, int]]:\n        start_date, end_date, *counts = map(int, observations.split())\n        return [(start_date, end_date, count) for count in counts]\n\n    N, M = map(int, stdin.split()[0:2])\n    events = [parse_observations(line) for line in stdin.split('\\n')[1:N+1]]\n\n    total_durations = [0] * M\n    for telescope_events in events:\n        for start_date, end_date, count in telescope_events:\n            event_duration = end_date - start_date\n            for i in range(M):\n                total_durations[i] += count * event_duration\n\n    durations = [duration // 365 for duration in total_durations]\n    if all(duration == 0 for duration in durations):\n        return \"-1\"\n    else:\n        return ' '.join(map(str, durations))"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    events = []\n\n    for _ in range(N):\n        start_date, event_type, end_date, frequency = map(int, input().split())\n        events.append((start_date, event_type, end_date, frequency))\n\n    durations = [0] * M\n\n    for start_date, event_type, end_date, frequency in events:\n        durations[event_type - 1] += (end_date - start_date + 1) * frequency\n\n    if sum(durations) == 0:\n        return \"-1\"\n\n    return \" \".join(map(str, durations))\n"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    observations = []\n    for _ in range(N):\n        observation = list(map(int, stdin.split()[2:]))\n        observations.append(observation)\n\n    durations = [0] * M\n    for observation in observations:\n        start_date = observation[0]\n        end_date = observation[1]\n        for i in range(2, len(observation), 2):\n            event_type = i // 2 - 1\n            durations[event_type] += observation[i] * (end_date - start_date + 1)\n\n    total_duration = 0\n    for duration in durations:\n        if duration > 0:\n            total_duration += duration\n\n    if total_duration == 0:\n        return \"-1\"\n    else:\n        return str(total_duration)"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    observations = [list(map(int, stdin.split()[2:])) for _ in range(N)]\n\n    durations = [0] * M\n    for obs in observations:\n        start_date, start_month, end_date, end_month, *counts = obs\n        duration = (end_date - start_date) * 365 + (end_month - start_month) * 365 // 12 + (end_date - start_date) + (end_month - start_month)\n        for i, count in enumerate(counts):\n            durations[i] += count * duration\n\n    if sum(durations) == 0:\n        return \"-1\"\n\n    return \" \".join(map(str, durations))"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_next(a: int) -> int:\n        for i in range(a, N):\n            if i not in visited:\n                return i\n        raise ValueError(\"Impossible\")\n\n    def backtrack(start: int, path: List[int]):\n        if len(path) == K:\n            return True\n        for i in range(start, N):\n            if i not in path:\n                path.append(i)\n                if backtrack(i + 1, path):\n                    return True\n                path.pop()\n        return False\n\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    visited = set()\n    arrows = [None] * N\n\n    for i in range(N):\n        arrows[a[i] - 1] = i + 1\n        visited.add(i)\n\n    for i in range(N):\n        if arrows[i] is None:\n            raise ValueError(\"Impossible\")\n\n    next_person = find_next(0)\n    path = [next_person - 1]\n    success = backtrack(next_person, path)\n\n    if not success:\n        raise ValueError(\"Impossible\")\n\n    result = [arrows[i] for i in path]\n    return \" \".join(map(str, result))\n\ndef"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def backtrack(start: int, target: int, path: List[int]) -> bool:\n        if start == target:\n            if len(path) == N:\n                return True\n            return False\n\n        for i in range(start, N):\n            if i not in path:\n                path.append(i)\n                if backtrack(i + 1, target, path):\n                    return True\n                path.pop()\n\n        return False\n\n    def is_valid(order: List[int]) -> bool:\n        for i in range(N):\n            for j in range(i + 1, N):\n                if a[order[i]] == order[j] or a[order[j]] == order[i]:\n                    return False\n        return True\n\n    def find_arrows(order: List[int]) -> List[int]:\n        arrows = [-1] * N\n        for i in range(N):\n            arrows[order[i]] = a[order[(i + 1) % N]]\n        return arrows\n\n    def is_solution(order: List[int]) -> bool:\n        visited = set()\n        for i in range(N):\n            visited.add(order[i])\n            if a[order[i]] not in visited:\n                return False\n        return True\n\n    if not backtrack(0, 1, []):\n        return \"Impossible\"\n\n    for i in range(2, N + 1):\n        if not backtrack(0, i, []):\n            return \"Impossible\"\n\n    for i in range(K):\n        if not backtrack(0, i + 1, []):\n            return \"Impossible\"\n\n    for order in itertools.permutations(range(1, N + 1)):\n        if is_valid(order):\n            arrows = find_arrows(order)\n            if arrows != [-1] * N:\n                return \" \".join(map(str, arrows))\n\n    return \"Impossible\""
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    if K % N != 0:\n        return \"Impossible\"\n\n    # Create the graph\n    graph = [[] for _ in range(N)]\n    for i in range(N):\n        graph[a[i] - 1].append(i)\n\n    # Initialize the arrows\n    arrows = [i for i in range(N)]\n\n    # Find the placement of arrows\n    for _ in range(K // N):\n        for i in range(N):\n            arrows[i] = graph[arrows[i]][0]\n            graph[arrows[i]].remove(i)\n\n    # Print the placement of arrows\n    output = []\n    for i in range(N):\n        if arrows[i] == i:\n            output.append(N)\n        else:\n            output.append(arrows[i] + 1)\n\n    return \" \".join(map(str, output))"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split(','))\n    dancers = list(map(int, stdin.split()[1].split(',')))\n\n    arrows = [0] * N\n    for i in range(1, N + 1):\n        if dancers[i - 1] == i:\n            arrows[i - 1] = i + 1\n        else:\n            arrows[i - 1] = dancers[i - 1]\n\n    for i in range(N):\n        if arrows[i] == 0:\n            arrows[i] = i + 1\n\n    return ' '.join(map(str, arrows))\n"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    if N > 10000 or K > 10**9:\n        return \"Impossible\"\n\n    arrows = [0] * N\n    for i in range(1, N+1):\n        arrows[a[i-1]-1] = i\n\n    if arrows.count(0) != 0:\n        return \"Impossible\"\n\n    for i in range(N):\n        if arrows[i] == i + 1:\n            return \"Impossible\"\n\n    return \" \".join(map(str, arrows))\n\ndef"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_str: str = stdin.strip()\n    lines = input_str.split(\"\\n\")\n    N, K = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n\n    def find_path(i: int, path: List[int]) -> bool:\n        if i == 0:\n            return True\n        for j in range(1, N + 1):\n            if j not in path and (i - 1, j) in adj:\n                path.append(i - 1)\n                if find_path(j, path):\n                    return True\n                path.pop()\n        return False\n\n    def dfs(i: int, visited: Set[int], adj: Dict[Tuple[int, int], int]) -> None:\n        visited.add(i)\n        for j in range(1, N + 1):\n            if j not in visited and (i, j) in adj:\n                dfs(j, visited, adj)\n\n    adj: Dict[Tuple[int, int], int] = {}\n    for i in range(1, N + 1):\n        adj[(a[i - 1], i)] = 1\n\n    visited: Set[int] = set()\n    for i in range(1, N + 1):\n        if i not in visited:\n            dfs(i, visited, adj)\n\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if (j, i) in adj:\n                adj[(j, i)] = adj[(j, i)] + adj[(i, j)]\n                adj.pop((j, i))\n\n    path: List[int] = []\n    if not find_path(N, path):\n        return \"Impossible\"\n\n    result: List[int] = [0] * N\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if (i, j) in adj:\n                result[i - 1] = j\n                break\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N, K = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n\n    def find_arrows(a, N, K, stdin):\n        for i in range(1, N+1):\n            for j in range(1, N+1):\n                if j != i:\n                    a.append(j)\n                    K -= 1\n                    if K == 0:\n                        arrows = [stdin[0] for _ in range(N-1)]\n                        for i in range(N):\n                            arrows[i] = str(a[i+1]) + arrows[i]\n                        return ''.join(arrows)\n                    find_arrows(a, N, K, stdin)\n        return \"Impossible\"\n\n    return find_arrows(a, N, K, input_list[1].split())"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split(','))\n    A = list(map(int, stdin.split()[1].split(',')))\n    \n    # The first person starts on the first mark\n    marks = [1]\n    \n    # The dance is performed K times\n    for _ in range(K):\n        # Add the new positions to the list of marks\n        marks.extend(A)\n        \n        # Remove duplicates and sort the list\n        marks = sorted(set(marks))\n    \n    # Check if the number of marks is equal to the total number of dancers\n    if len(marks) != N:\n        return \"Impossible\"\n    \n    # Calculate the arrows between the marks\n    arrows = []\n    for i in range(1, N+1):\n        # Find the previous mark\n        prev_mark = marks.index(i) - 1\n        if prev_mark < 0:\n            prev_mark = N - 1\n        \n        # Find the next mark\n        next_mark = marks[(marks.index(i) + 1) % N]\n        \n        # Add the arrow to the list\n        arrows.append((prev_mark, next_mark))\n    \n    # Print the arrows as a list\n    return ' '.join(str(i) for pair in arrows for i in pair)"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K = map(int, input_list[0].split())\n    people_positions = list(map(int, input_list[1].split()))\n    \n    arrows = [i for i in range(1, N+1)]\n    people_positions.sort()\n    \n    def find_placement(current_position, arrows):\n        if current_position == K:\n            return arrows\n        \n        for i in range(1, N+1):\n            if i == current_position:\n                continue\n            arrows.append(i)\n            result = find_placement(current_position+1, arrows)\n            if result:\n                return result\n            arrows.pop()\n        return None\n    \n    result = find_placement(1, arrows)\n    if not result:\n        return \"Impossible\"\n    \n    for i in range(len(result)):\n        if result[i] == i+1:\n            result[i] = people_positions[i]\n    \n    return ' '.join(map(str, result))"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def reconstruct_arrows(N: int, K: int, a: List[int], b: List[int]):\n        arrows = [0] * N\n        for i in range(N):\n            arrows[i] = (b[i] - 1) % N\n\n        count = 0\n        while count < K:\n            for i in range(N):\n                arrows[i] = (arrows[i] + 1) % N\n            count += 1\n\n        return arrows\n\n    def verify_solution(N: int, a: List[int], b: List[int], arrows: List[int]):\n        for i in range(N):\n            if arrows[i] == i:\n                return False\n            if arrows[i] == a[i - 1]:\n                return False\n        return True\n\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    arrows = reconstruct_arrows(N, K, a, b)\n    if not verify_solution(N, a, b, arrows):\n        return \"Impossible\"\n\n    return \" \".join(map(str, arrows))\n\ninput_str = \"\"\"6 2\n3 4 5 6 1 2\n\"\"\"\nprint(solution(input_str)) "
    }
]