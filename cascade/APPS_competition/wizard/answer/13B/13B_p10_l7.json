[
    {
        "number": 3000,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tokens = stdin.split()[1:]\n    \n    stack = []\n    result = 0\n    for token in tokens:\n        if token == '(':\n            stack.append(token)\n        elif token == ')':\n            while stack and stack[-1] != '(':\n                op = stack.pop()\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if op == '+':\n                    result = (num1 + num2) % (10**9 + 7)\n                elif op == '*':\n                    result = (num1 * num2) % (10**9 + 7)\n            stack.pop()\n        else:\n            stack.append(int(token))\n    \n    return str(result)"
    },
    {
        "number": 3000,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    expression = input()\n\n    def evaluate(bracket_sequence: str) -> int:\n        stack = []\n        result = 0\n\n        for char in bracket_sequence:\n            if char == \"(\":\n                stack.append(\"(\")\n            elif char == \")\":\n                sub_expression = \"\"\n                while stack and stack[-1] != \"(\":\n                    sub_expression = stack.pop() + sub_expression\n                stack.pop()  # Remove the opening parenthesis\n                sub_result = evaluate(sub_expression)\n                if not stack:\n                    result = sub_result\n                elif stack[-1] == \"+\":\n                    result += sub_result\n                else:  # stack[-1] == \"*\"\n                    result *= sub_result\n            else:\n                stack.append(char)\n\n        return result\n\n    return str(evaluate(expression) % (10**9 + 7))"
    },
    {
        "number": 3000,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for token in stdin.split():\n        if token == \"(\":\n            stack.append(token)\n        elif token == \")\":\n            if len(stack) == 0 or stack[-1] == \"(\":\n                return \"Invalid bracket sequence\"\n            while stack[-1] != \"(\":\n                stack.pop()\n            stack.pop()\n        elif token.isdigit():\n            stack.append(token)\n        else:\n            return \"Invalid bracket sequence\"\n\n    if len(stack) != 1:\n        return \"Invalid bracket sequence\"\n\n    return str(int(stack[0]) % (10**9 + 7))"
    },
    {
        "number": 3000,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def evaluate(tokens: List[str]) -> int:\n        stack = []\n        for token in tokens:\n            if token == '(':\n                stack.append('(')\n            elif token == ')':\n                right = stack.pop()\n                while stack and stack[-1] != '(':\n                    right = str(evaluate([stack.pop(), right]))\n                stack.pop()\n                if stack:\n                    stack[-1] = str(evaluate([stack[-1], right]))\n            else:\n                stack.append(token)\n        return int(stack[0])\n\n    n = int(input())\n    tokens = input().split()\n    return str(evaluate(tokens) % (10**9 + 7))"
    },
    {
        "number": 3000,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    tokens = stdin.split()\n    num = 1\n    for token in tokens:\n        if token == '(':\n            stack.append(num)\n            num = 1\n        elif token == ')':\n            result = stack.pop() * num\n            if stack:\n                stack[-1] *= result\n            else:\n                num = result\n        else:\n            num *= int(token)\n    return str(num % (10**9 + 7))\n\ndef"
    },
    {
        "number": 3000,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for token in stdin.split():\n        if token == '(':\n            stack.append('(')\n        elif token == ')':\n            expression = []\n            while stack[-1] != '(':\n                expression.append(stack.pop())\n            stack.pop()\n            stack.append(evaluate(expression))\n    return str(evaluate(stack) % (10**9 + 7))\n\ndef"
    },
    {
        "number": 3000,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    operators = {'+', '*'}\n    output = []\n\n    for token in stdin.split():\n        if token == '(':\n            stack.append('(')\n        elif token == ')':\n            while stack and stack[-1] != '(':\n                output.append(stack.pop())\n            stack.pop()\n        elif token in operators:\n            while stack and stack[-1] in operators:\n                output.append(stack.pop())\n            if stack and stack[-1] == '(':\n                stack.append(token)\n            else:\n                stack.append(token)\n        else:\n            stack.append(int(token) % (10**9 + 7))\n\n    while stack:\n        output.append(stack.pop())\n\n    return str(eval(''.join(map(str, output))) % (10**9 + 7))\n\nn = int(input())\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 3000,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    operators = {'+': 1, '*': 2}\n    for token in stdin.split():\n        if token == '(':\n            stack.append(token)\n        elif token == ')':\n            if not stack:\n                return \"Invalid bracket sequence\"\n            while stack[-1] != '(':\n                a = stack.pop()\n                if not stack:\n                    return \"Invalid bracket sequence\"\n                b = stack.pop()\n                if b == '+' or b == '*':\n                    a = a * operators[b]\n                c = stack.pop()\n                if c == '+' or c == '*':\n                    b = b * operators[c]\n                stack.append(a * b)\n            stack.pop()\n        else:\n            stack.append(int(token) % (10**9 + 7))\n    return str(stack[-1]) if stack else \"Invalid bracket sequence\""
    },
    {
        "number": 3000,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    stack = []\n    result = 0\n    for token in input_list:\n        if token == '(':\n            stack.append(token)\n        elif token == ')':\n            if len(stack) == 0:\n                return \"Invalid bracket sequence\"\n            while stack[-1] != '(':\n                result = (result * 10) + int(stack.pop())\n            stack.pop()\n        else:\n            stack.append(token)\n    if len(stack) != 0:\n        return \"Invalid bracket sequence\"\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 3000,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tokens = stdin.split()[1:]\n    \n    stack = []\n    for token in tokens:\n        if token == '(':\n            stack.append(token)\n        elif token == ')':\n            if len(stack) < 3:\n                return \"Invalid bracket sequence\"\n            num1 = int(stack[-3])\n            num2 = int(stack[-2])\n            op = stack[-1]\n            stack = stack[:-3]\n            if op == '+':\n                stack.append(num1 + num2)\n            elif op == '*':\n                stack.append(num1 * num2)\n        else:\n            stack.append(token)\n            \n    if len(stack) != 1:\n        return \"Invalid bracket sequence\"\n    \n    return str(stack[0] % (10**9+7))"
    },
    {
        "number": 3001,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    num_str = str(num)\n    n = len(num_str)\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def increment(num: str) -> str:\n        if num[-1] == '9':\n            if len(num) == 1:\n                return '10'\n            else:\n                return increment(num[:-1]) + '0'\n        else:\n            return num[:-1] + str(int(num[-1]) + 1)\n\n    count = 0\n    while not is_palindrome(num_str):\n        num_str = increment(num_str)\n        count += 1\n\n    return str(count)"
    },
    {
        "number": 3001,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def advance_wheels(wheels: str) -> str:\n        new_wheels = wheels.lstrip(\"0\")\n        if not new_wheels:\n            return \"0\" * len(wheels)\n        if new_wheels[-1] == \"9\":\n            new_wheels = new_wheels[:-1] + \"0\"\n        new_wheels = new_wheels.lstrip(\"0\")\n        if not new_wheels:\n            return \"0\" * len(wheels)\n        new_wheels = \"0\" * (len(wheels) - len(new_wheels)) + new_wheels\n        return new_wheels\n\n    def is_palindrome(wheels: str) -> bool:\n        return wheels == wheels[::-1]\n\n    wheels = stdin.lstrip(\"0\")\n    if not wheels:\n        return \"0\"\n    if is_palindrome(wheels):\n        return \"0\"\n    step = 0\n    while not is_palindrome(wheels):\n        wheels = advance_wheels(wheels)\n        step += 1\n    return str(step)"
    },
    {
        "number": 3001,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    num_wheels = len(stdin)\n    max_value = 10**num_wheels\n    \n    def is_palindrome(num: int) -> bool:\n        return str(num) == str(num)[::-1]\n\n    steps = 0\n    for i in range(max_value):\n        if is_palindrome(num):\n            break\n        steps += 1\n        num = (num % (10**(num_wheels - 1) * 10)) + ((num // 10) % 10)\n\n    return steps"
    },
    {
        "number": 3001,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def advance_wheel(wheel: int, digits: int) -> int:\n        if wheel == 9:\n            return 0\n        return wheel + 1\n\n    def is_palindrome(number: str) -> bool:\n        return number == number[::-1]\n\n    def get_next_palindrome(number: str) -> str:\n        left, right = 0, len(number) - 1\n        while left < right and number[left] == number[right]:\n            left += 1\n            right -= 1\n\n        left_wheel = number[left]\n        right_wheel = number[right]\n\n        for i in range(left + 1, right + 1):\n            if number[i] > left_wheel:\n                left_wheel = number[i]\n            elif number[i] < right_wheel:\n                right_wheel = number[i]\n\n        return number[:left] + advance_wheel(right_wheel, left) + number[left + 1:right] + advance_wheel(left_wheel, len(number) - right - 1) + number[right + 1:]\n\n    number = int(stdin)\n    steps = 0\n    while not is_palindrome(str(number)):\n        number = int(get_next_palindrome(str(number)))\n        steps += 1\n\n    return steps"
    },
    {
        "number": 3001,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def increment_wheel(wheel: list) -> list:\n        carry = 1\n        for i in range(len(wheel) - 1, -1, -1):\n            new_value = wheel[i] + carry\n            if new_value == 10:\n                carry = 1\n                wheel[i] = 0\n            else:\n                carry = 0\n                wheel[i] = new_value\n        if carry == 1:\n            wheel.insert(0, 0)\n        return wheel\n\n    def is_palindrome(wheel: list) -> bool:\n        return str(wheel) == str(wheel)[::-1]\n\n    def count_steps(wheel: list) -> int:\n        count = 0\n        while not is_palindrome(wheel):\n            wheel = increment_wheel(wheel)\n            count += 1\n        return count\n\n    wheel = [int(digit) for digit in stdin]\n    result = count_steps(wheel)\n    return str(result)"
    },
    {
        "number": 3001,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input string into a list of integers\n    input_list = [int(digit) for digit in stdin]\n\n    # Initialize the palindrome with the same digits as the input\n    palindrome = input_list.copy()\n\n    # Reverse the input list to make it a palindrome\n    palindrome.reverse()\n\n    # Calculate the number of steps required to reach the palindrome\n    steps = 0\n    for i in range(len(input_list)):\n        steps += abs(input_list[i] - palindrome[i])\n\n    return str(steps)"
    },
    {
        "number": 3001,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k = len(stdin)\n    current_number = int(stdin)\n    max_value = int(\"9\" * k)\n    \n    def reverse_number(number: int) -> int:\n        reversed_number = 0\n        while number > 0:\n            digit = number % 10\n            reversed_number = reversed_number * 10 + digit\n            number //= 10\n        return reversed_number\n    \n    def count_steps(current_number: int, target_number: int) -> int:\n        steps = 0\n        while current_number != target_number:\n            target_number_reverse = reverse_number(target_number)\n            if target_number_reverse == target_number:\n                break\n            if target_number_reverse < target_number:\n                target_number = reverse_number(target_number_reverse)\n            else:\n                target_number_reverse = reverse_number(target_number)\n                if target_number_reverse < target_number:\n                    target_number = reverse_number(target_number_reverse)\n                else:\n                    target_number += 1\n            steps += 1\n        return steps\n    \n    palindrome_number = reverse_number(current_number)\n    steps = count_steps(current_number, palindrome_number)\n    return str(steps)"
    },
    {
        "number": 3001,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def increment(counter: List[int]) -> None:\n        carry = 1\n        for i in range(len(counter) - 1, -1, -1):\n            carry, counter[i] = divmod(counter[i] + carry, 10)\n\n    def is_palindrome(counter: List[int]) -> bool:\n        return counter == counter[::-1]\n\n    def min_steps(counter: List[int]) -> int:\n        def dfs(steps: int, index: int) -> int:\n            if is_palindrome(counter):\n                return steps\n            if index == len(counter):\n                return steps + 1\n            if counter[index] == 9:\n                increment(counter)\n                return dfs(steps + 1, index + 1)\n            else:\n                return min(dfs(steps, index + 1), dfs(steps + 1, index + 1))\n\n        return dfs(0, 0)\n\n    counter = [int(d) for d in stdin]\n    return str(min_steps(counter))"
    },
    {
        "number": 3001,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    num_str = str(num)\n    num_len = len(num_str)\n    min_steps = num_len\n    \n    for i in range(num_len):\n        palindrome_digits = num_str[i:] + num_str[:i]\n        palindrome = int(palindrome_digits)\n        steps = 0\n        \n        while num < palindrome:\n            num += (10 ** (num_len - i - 1))\n            steps += 1\n        \n        if steps < min_steps:\n            min_steps = steps\n    \n    return str(min_steps)"
    },
    {
        "number": 3001,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Convert input to a list of digits\n    digits = [int(d) for d in stdin]\n\n    # Initialize the leftmost wheel to be the maximum value\n    left = 9\n\n    # Initialize the rightmost wheel to be the minimum value\n    right = 0\n\n    # Count the number of changes to the left wheel\n    changes = 0\n\n    # While the left wheel is less than the right wheel\n    while left < right:\n        # Increment the left wheel\n        left += 1\n\n        # If the left wheel overflows to 10, increment the next left wheel\n        if left == 10:\n            left = 0\n            changes += 1\n\n        # Increment the right wheel\n        right += 1\n\n    # Calculate the number of changes to the right wheel\n    changes += right\n\n    # Calculate the number of changes to the left wheel\n    changes = (changes - 1) // 2\n\n    return str(changes)"
    },
    {
        "number": 3002,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split('\\n')\n    e = int(stdin_list[0])\n    entries = stdin_list[1:]\n\n    def check_service_history(entries) -> bool:\n        total_distance = 0\n        last_service = None\n        for entry in entries:\n            year, month, odometer = map(int, entry.split())\n            if last_service and year * 12 + month - last_service[0] * 12 - last_service[1] > 12:\n                return False\n            total_distance += odometer\n            if total_distance > 20000:\n                return False\n            last_service = (year, month)\n        return True\n\n    def check_tampering(entries) -> bool:\n        for i in range(1, len(entries)):\n            _, _, odometer_i = map(int, entries[i].split())\n            _, _, odometer_j = map(int, entries[i-1].split())\n            if odometer_i - odometer_j < 0:\n                return True\n        return False\n\n    if not check_service_history(entries):\n        return \"insufficient service\"\n    if check_tampering(entries):\n        return \"tampered odometer\"\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    entries = stdin.split(\"\\n\")\n    e = int(entries[0])\n    service_history = []\n    for i in range(1, e + 1):\n        y, m, o = map(int, entries[i].split())\n        service_history.append((y, m, o))\n\n    def is_tampered_odometer(service_history: List[Tuple[int, int, int]]) -> bool:\n        for i in range(1, len(service_history)):\n            y1, m1, o1 = service_history[i - 1]\n            y2, m2, o2 = service_history[i]\n            if o2 < o1:\n                return True\n        return False\n\n    def is_insufficient_service(service_history: List[Tuple[int, int, int]]) -> bool:\n        distance_traveled = 0\n        yearly_distance = 2000\n        service_interval = 30000\n        last_service_year = service_history[0][0]\n        for y, m, o in service_history:\n            if y > last_service_year + 1:\n                yearly_distance = 0\n            distance_traveled += yearly_distance\n            yearly_distance = 20000\n            last_service_year = y\n            if o + distance_traveled >= 100000:\n                distance_traveled -= 100000\n\n            if o + distance_traveled >= service_interval:\n                return False\n        return True\n\n    if is_tampered_odometer(service_history):\n        return \"tampered odometer\"\n    elif is_insufficient_service(service_history):\n        return \"insufficient service\"\n    else:\n        return \"seems legit\"\n\nstdin = \"\"\"3\n2017 4 0\n2017 8 12000\n2018 8 42000\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 3002,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    entries = stdin.split(\"\\n\")\n    num_entries = int(entries[0])\n    entries = entries[1:]\n\n    def is_valid_entry(entry: str) -> bool:\n        year, month, odometer = map(int, entry.split())\n        return 1950 <= year <= 2050 and 1 <= month <= 12 and 0 <= odometer <= 99999\n\n    entries = [entry for entry in entries if is_valid_entry(entry)]\n\n    def is_service_valid(service_entry: str, prev_entry: str) -> bool:\n        year, month, odometer = map(int, service_entry.split())\n        prev_year, prev_month, prev_odometer = map(int, prev_entry.split())\n        travel_distance = (odometer - prev_odometer) % 100000\n        if travel_distance < 2000:\n            return False\n        if travel_distance > 20000:\n            return False\n        if (year - prev_year) * 12 + (month - prev_month) > 12:\n            return False\n        if odometer >= 100000:\n            return False\n        return True\n\n    def is_service_interval_valid(service_entry: str, prev_entry: str) -> bool:\n        year, month, odometer = map(int, service_entry.split())\n        prev_year, prev_month, prev_odometer = map(int, prev_entry.split())\n        travel_distance = (odometer - prev_odometer) % 100000\n        if travel_distance >= 30000:\n            return True\n        if (year - prev_year) * 12 + (month - prev_month) >= 12:\n            return True\n        return False\n\n    if len(entries) != num_entries:\n        return \"insufficient service\"\n\n    for i in range(1, len(entries)):\n        if not is_service_valid(entries[i], entries[i - 1]):\n            return \"insufficient service\"\n\n    for i in range(1, len(entries)):\n        if not is_service_interval_valid(entries[i], entries[i - 1]):\n            return \"tampered odometer\"\n\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    entries = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    total_distance = 0\n    last_reading = 0\n    valid_service = True\n    for year, month, reading in entries:\n        if reading < last_reading:\n            valid_service = False\n            break\n        if year == 1950 and month == 1 and reading == 0:\n            continue\n        total_distance += reading - last_reading\n        if total_distance < 2000:\n            valid_service = False\n            break\n        if total_distance > 20000:\n            valid_service = False\n            break\n        if year != entries[-1][0]:\n            if total_distance < 30000:\n                valid_service = False\n                break\n            total_distance = 0\n        last_reading = reading\n    if not valid_service:\n        return \"tampered odometer\"\n    if total_distance < 30000:\n        return \"insufficient service\"\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    entries = [list(map(int, line.strip().split())) for line in stdin.split('\\n')]\n    total_distance = 0\n    last_service_date = None\n    last_odometer = 0\n\n    for year, month, odometer in entries:\n        if year < 1950 or year > 2050 or month < 1 or month > 12:\n            return \"tampered odometer\"\n\n        if last_service_date is None:\n            last_service_date = (year, month)\n            last_odometer = odometer\n            continue\n\n        if (year, month) <= last_service_date:\n            return \"tampered odometer\"\n\n        distance_traveled = odometer - last_odometer\n        if distance_traveled < 0:\n            return \"tampered odometer\"\n\n        total_distance += distance_traveled\n        last_service_date = (year, month)\n        last_odometer = odometer\n\n    if total_distance < 2000 or total_distance > 20000:\n        return \"tampered odometer\"\n\n    months_traveled = (last_service_date[0] - entries[0][0]) * 12 + (last_service_date[1] - entries[0][1])\n    required_services = max(months_traveled // 12, total_distance // 30000)\n    actual_services = len(entries) - 1\n\n    if actual_services < required_services:\n        return \"insufficient service\"\n\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    entries = stdin.strip().split('\\n')\n    e = int(entries[0])\n    entries = entries[1:]\n    if e != len(entries):\n        return \"Invalid input\"\n\n    def is_valid_reading(reading: int) -> bool:\n        return 0 <= reading <= 99999\n\n    def is_valid_entry(entry: str) -> bool:\n        year, month, reading = map(int, entry.split())\n        return 1950 <= year <= 2050 and 1 <= month <= 12 and is_valid_reading(reading)\n\n    def is_valid_history(history: List[str]) -> bool:\n        return all(is_valid_entry(entry) for entry in history)\n\n    def is_tampered(history: List[str]) -> bool:\n        for i in range(1, len(history)):\n            previous_reading = int(history[i - 1].split()[2])\n            current_reading = int(history[i].split()[2])\n            if current_reading < previous_reading:\n                return True\n        return False\n\n    def is_service_history_valid(history: List[str]) -> bool:\n        monthly_distance = 2000\n        monthly_distance_limit = 20000\n        service_distance_limit = 30000\n        service_month_limit = 12\n\n        def is_valid_service(entry: str) -> bool:\n            year, month, reading = map(int, entry.split())\n            next_month = (year, month % 12 + 1) if month % 12 != 0 else (year + 1, 1)\n            distance_traveled = reading\n            while next_month[0] * 12 + next_month[1] <= year * 12 + month:\n                next_month = (next_month[0], next_month[1] % 12 + 1) if next_month[1] % 12 != 0 else (next_month[0] + 1, 1)\n                distance_traveled += min(monthly_distance, monthly_distance_limit)\n            service_distance = distance_traveled - reading\n            service_months = (year * 12 + month - (year * 12 + month - 12) % 12) // 12\n            return service_distance >= service_distance_limit and service_months >= service_month_limit\n\n        return all(is_valid_service(entry) for entry in history)\n\n    history = [entry for entry in entries if is_valid_entry(entry)]\n    if not is_valid_history(history):\n        return \"Invalid input\"\n\n    if is_tampered(history):\n        return \"tampered odometer\"\n\n    if not is_service_history_valid(history):\n        return \"insufficient service\"\n\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    lines = stdin.splitlines()\n    e = int(lines[0])\n    entries = []\n    for i in range(1, e+1):\n        entry = list(map(int, lines[i].split()))\n        entries.append(entry)\n\n    # check if odometer has been tampered with\n    for i in range(len(entries) - 1):\n        if entries[i][2] > entries[i+1][2]:\n            return \"tampered odometer\"\n\n    # check if the car has been serviced often enough\n    max_distance = 0\n    for i in range(len(entries)):\n        if i == 0:\n            max_distance = entries[i][2]\n        else:\n            max_distance = max(max_distance, entries[i][2])\n\n    if max_distance > 20000:\n        return \"insufficient service\"\n\n    # check if the car has been serviced within 12 months\n    prev_entry = None\n    for entry in entries:\n        if prev_entry and (entry[0] - prev_entry[0]) * 12 + entry[1] - prev_entry[1] < 12:\n            return \"insufficient service\"\n        prev_entry = entry\n\n    # the odometer seems legit\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    entries = stdin.split(\"\\n\")\n    num_entries = int(entries[0])\n    total_distance = 0\n    max_distance = 99999\n    max_distance_per_month = 2000\n    min_distance_per_month = 20000\n    distance_traveled_per_month = {}\n\n    for entry in entries[1:]:\n        year, month, odometer_reading = map(int, entry.split())\n        if year not in distance_traveled_per_month:\n            distance_traveled_per_month[year] = {}\n        distance_traveled_per_month[year][month] = odometer_reading\n\n    for year in distance_traveled_per_month:\n        for month in distance_traveled_per_month[year]:\n            distance_traveled = distance_traveled_per_month[year][month]\n            if distance_traveled >= max_distance:\n                return \"tampered odometer\"\n            total_distance += distance_traveled\n            if total_distance < min_distance_per_month:\n                return \"insufficient service\"\n            if total_distance >= max_distance_per_month:\n                return \"seems legit\"\n\n    return \"seems legit\"\n\nstdin = \"3\\n2017 4 0\\n2017 8 12000\\n2018 8 42000\"\nprint(solution(stdin)) "
    },
    {
        "number": 3002,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    entries = stdin.split(\"\\n\")\n    e = int(entries[0])\n    service_history = []\n    for i in range(1, e+1):\n        year, month, odometer = map(int, entries[i].split())\n        service_history.append((year, month, odometer))\n\n    distance_travelled = 0\n    for i in range(len(service_history)-1):\n        distance_travelled += service_history[i+1][2] - service_history[i][2]\n    if distance_travelled < 2000 or distance_travelled > 20000:\n        return \"tampered odometer\"\n\n    if distance_travelled < 30000:\n        service_interval = 12\n    else:\n        service_interval = int(distance_travelled / 30000)\n\n    service_years = 0\n    for i in range(len(service_history)-1):\n        if service_history[i+1][0] - service_history[i][0] >= 1:\n            service_years += 1\n\n    if service_years >= service_interval:\n        return \"seems legit\"\n    else:\n        return \"insufficient service\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    entries = stdin.splitlines()\n    e = int(entries[0])\n    if e < 1 or e > 500:\n        return \"Invalid input\"\n    \n    total_distance = 0\n    service_years = []\n    service_months = []\n    service_odometers = []\n    for i in range(1, e+1):\n        entry = list(map(int, entries[i].split()))\n        if len(entry) != 3:\n            return \"Invalid input\"\n        y, m, o = entry\n        if y < 1950 or y > 2050 or m < 1 or m > 12 or o < 0 or o > 99999:\n            return \"Invalid input\"\n        \n        if i > 1:\n            total_distance += o - service_odometers[-1]\n        service_years.append(y)\n        service_months.append(m)\n        service_odometers.append(o)\n    \n    max_distance = 20000\n    min_distance = 2000\n    service_year = 1950\n    while service_year <= 2050:\n        if service_years and service_year == service_years[0]:\n            service_year = service_years.pop(0)\n            service_month = service_months.pop(0)\n            service_odometer = service_odometers.pop(0)\n            while service_years and service_year == service_years[0]:\n                service_year = service_years.pop(0)\n                service_month = service_months.pop(0)\n                service_odometer = service_odometers.pop(0)\n            if service_year == 2050 and service_month == 12:\n                break\n            elif total_distance >= min_distance:\n                min_distance += 30000\n                max_distance += 20000\n            else:\n                return \"insufficient service\"\n        else:\n            total_distance += 99999\n            service_year += 1\n    \n    if total_distance < min_distance:\n        return \"insufficient service\"\n    else:\n        return \"seems legit\""
    },
    {
        "number": 3003,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_colors(graph):\n        visited = [False] * len(graph)\n        color = [None] * len(graph)\n        available_colors = [True] * len(graph)\n\n        def dfs(v, c):\n            visited[v] = True\n            color[v] = c\n            available_colors[c] = False\n\n            for neighbor in graph[v]:\n                if not visited[neighbor]:\n                    for i in range(len(graph)):\n                        if available_colors[i]:\n                            dfs(neighbor, i)\n                            break\n\n        for i in range(len(graph)):\n            if not visited[i]:\n                dfs(i, 0)\n\n        return len(set(color))\n\n    N = int(stdin.split(\"\\n\")[0])\n    graph = [[] for _ in range(N)]\n\n    for i in range(1, N + 1):\n        line = stdin.split(\"\\n\")[i].split()\n        for j in line:\n            graph[int(j)].append(i - 1)\n\n    return str(find_min_colors(graph))"
    },
    {
        "number": 3003,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    num_vertices, edges = stdin.split(\"\\n\")\n    num_vertices = int(num_vertices)\n    edges = [list(map(int, line.split())) for line in edges.split(\"\\n\")]\n\n    # Build the adjacency matrix\n    adj_matrix = [[0] * num_vertices for _ in range(num_vertices)]\n    for i in range(num_vertices):\n        for j in range(num_vertices):\n            if i in edges[j]:\n                adj_matrix[i][j] = 1\n\n    # Color the graph using the greedy algorithm\n    colors = [0] * num_vertices\n    available_colors = [1]\n    for i in range(num_vertices):\n        valid_colors = [color for color in available_colors if not any(adj_matrix[i][j] and colors[j] == color for j in range(num_vertices))]\n        if not valid_colors:\n            raise ValueError(\"Invalid graph: no valid color for vertex\", i)\n        colors[i] = valid_colors[0]\n        available_colors.append(valid_colors[-1] + 1)\n\n    # Return the minimum number of colors used\n    return str(len(available_colors) - 1)"
    },
    {
        "number": 3003,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n\n    def find_coloring(graph: list) -> int:\n        colors = defaultdict(int)\n        color = 1\n        for vertex in range(len(graph)):\n            if colors[vertex] == 0:\n                colors[vertex] = color\n                color_neighbors(graph, vertex, colors, color)\n                color += 1\n        return color - 1\n\n    def color_neighbors(graph: list, vertex: int, colors: dict, color: int) -> None:\n        for neighbor in graph[vertex]:\n            if colors[neighbor] == 0:\n                colors[neighbor] = color\n                color_neighbors(graph, neighbor, colors, color)\n\n    n = int(stdin.split('\\n')[0])\n    graph = [[] for _ in range(n)]\n    for i, line in enumerate(stdin.split('\\n')[1:], 1):\n        for v in line.split():\n            graph[i - 1].append(int(v))\n    return str(find_coloring(graph))"
    },
    {
        "number": 3003,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split(\"\\n\")\n    n = int(stdin_list[0])\n    adj_list = [[] for _ in range(n)]\n    for i in range(1, n+1):\n        edge_list = stdin_list[i].split(\" \")\n        for j in range(len(edge_list)):\n            adj_list[i-1].append(int(edge_list[j]))\n\n    visited = [False] * n\n    color = [-1] * n\n    def dfs(v: int, c: int):\n        visited[v] = True\n        color[v] = c\n        for i in adj_list[v]:\n            if not visited[i]:\n                dfs(i, c)\n\n    min_colors = n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, 0)\n            for j in range(1, n):\n                if color[j] == color[i]:\n                    min_colors -= 1\n            break\n\n    return str(min_colors)\n\nstdin_1 = \"4\\n1 2\\n0 2 3\\n0 1\\n1\"\nprint(solution(stdin_1))\n\nstdin_2 = \"5\\n2 3 4\\n2 3 4\\n0 1\\n0 1\\n0 1\"\nprint(solution(stdin_2))\n\nstdin_3 = \"6\\n1 3\\n0 2 4\\n1 5\\n0 4\\n1 3 5\\n2 4\"\nprint(solution(stdin_3))\n\nstdin_4 = \"4\\n1 2 3\\n0 2 3\\n0 1 3\\n0 1 2\"\nprint(solution(stdin_4)) "
    },
    {
        "number": 3003,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    lines = stdin.split('\\n')\n    num_vertices = int(lines[0])\n    adjacency_matrix = [[False for _ in range(num_vertices)] for _ in range(num_vertices)]\n    for i in range(1, len(lines)):\n        for j in map(int, lines[i].split()):\n            adjacency_matrix[i-1][j-1] = True\n            adjacency_matrix[j-1][i-1] = True\n    \n    # Initialize the color assignment and count the number of colors used\n    color_assignment = [0] * num_vertices\n    num_colors_used = 0\n    \n    # Iterate through the vertices and assign colors\n    for i in range(num_vertices):\n        uncolored_neighbors = [j for j in range(num_vertices) if adjacency_matrix[i][j] and color_assignment[j] == 0]\n        if not uncolored_neighbors:\n            continue\n        available_colors = [j for j in range(1, num_colors_used+1) if all(color_assignment[k] != j for k in range(num_vertices) if adjacency_matrix[i][k])]\n        if not available_colors:\n            num_colors_used += 1\n            available_colors = [num_colors_used]\n        color_assignment[i] = min(available_colors)\n    \n    # Return the minimum number of colors used\n    return str(num_colors_used)"
    },
    {
        "number": 3003,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split(\"\\n\")\n    n = int(stdin_list[0])\n    edges = []\n    for i in range(n):\n        edge_line = list(map(int, stdin_list[i + 1].split()))\n        edges.append(edge_line)\n\n    visited = [False] * n\n    color = [0] * n\n    result = 0\n\n    def dfs(v, c):\n        visited[v] = True\n        color[v] = c\n        for u in edges[v]:\n            if not visited[u]:\n                dfs(u, c + 1)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, 1)\n            result = max(result, max(color))\n\n    return str(result)"
    },
    {
        "number": 3003,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, color):\n        nonlocal colors, used_colors\n        if colors[node] is not None:\n            return colors[node]\n        colors[node] = color\n        used_colors.add(color)\n        for neighbor in adj_list[node]:\n            if colors[neighbor] is not None and colors[neighbor] == color:\n                return False\n            elif colors[neighbor] is None and not dfs(neighbor, (color + 1) % num_colors):\n                return False\n        return True\n\n    num_vertices = int(stdin.split('\\n')[0])\n    adj_list = [set() for _ in range(num_vertices)]\n    for i in range(1, num_vertices + 1):\n        neighbors = set(map(int, stdin.split('\\n')[i].split()))\n        adj_list[i - 1] = neighbors\n\n    colors = [None] * num_vertices\n    num_colors = 1\n    used_colors = set()\n    while True:\n        colors = [None] * num_vertices\n        if all(dfs(node, 0) for node in range(num_vertices)):\n            break\n        num_colors += 1\n\n    return str(num_colors)"
    },
    {
        "number": 3003,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    adj_list = [[] for _ in range(n)]\n    \n    for i in range(1, n+1):\n        edges = lines[i].split()\n        for edge in edges:\n            adj_list[i-1].append(int(edge)-1)\n    \n    color_count = 0\n    visited = [False] * n\n    color = [-1] * n\n    \n    def dfs(vertex, c):\n        nonlocal color_count\n        color[vertex] = c\n        visited[vertex] = True\n        \n        for neighbor in adj_list[vertex]:\n            if not visited[neighbor] and color[neighbor] == c:\n                color_count += 1\n            elif not visited[neighbor]:\n                dfs(neighbor, 1-c)\n    \n    dfs(0, 0)\n    \n    if color_count == 0:\n        return str(len(set(color)))\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3003,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    num_vertices = int(lines[0])\n    edges = []\n    for i in range(1, num_vertices + 1):\n        edge_list = [int(x) for x in lines[i].split()]\n        edges.append(edge_list)\n\n    def dfs(start, color):\n        visited.add(start)\n        colors[start] = color\n        for end in edges[start]:\n            if end not in visited:\n                dfs(end, (color + 1) % num_colors)\n\n    num_colors = 0\n    for i in range(num_vertices):\n        visited = set()\n        colors = [-1] * num_vertices\n        dfs(i, num_colors)\n        num_colors = max(num_colors, max(colors) + 1)\n\n    return str(num_colors)"
    },
    {
        "number": 3003,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    edges = [[] for _ in range(n)]\n    for i, line in enumerate(stdin.split(\"\\n\")[1:]):\n        for j, v in enumerate(line.split()):\n            edges[i].append(int(v))\n    \n    # DFS to find connected components\n    visited = [False] * n\n    stack = [0]\n    groups = []\n    while stack:\n        group = []\n        while stack:\n            v = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                group.append(v)\n                stack.extend(edges[v])\n        groups.append(group)\n    \n    # Count the number of colors needed\n    min_colors = len(groups)\n    for group in groups:\n        min_colors = min(min_colors, len(set(group)))\n    \n    return str(min_colors)"
    },
    {
        "number": 3004,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')[1:]\n    offers = []\n    for line in lines:\n        color, start, end = line.split()\n        offers.append((color, int(start), int(end)))\n\n    def is_valid(selected_offers):\n        colors = set()\n        last_section = 0\n        for offer in selected_offers:\n            color, start, end = offer\n            if start < last_section:\n                return False\n            colors.add(color)\n            last_section = end\n        return len(colors) <= 3\n\n    min_offers = float('inf')\n    for i in range(1, 1 << len(offers)):\n        selected_offers = [offers[j] for j in range(len(offers)) if (i & (1 << j))]\n        if is_valid(selected_offers):\n            min_offers = min(min_offers, sum(end - start for _, start, end in selected_offers))\n\n    return str(min_offers) if min_offers != float('inf') else 'IMPOSSIBLE'"
    },
    {
        "number": 3004,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from collections import Counter\n\n    def is_valid_offer(offer: str, sections_painted: set) -> bool:\n        color, first_section, last_section = offer.split()\n        first_section, last_section = int(first_section), int(last_section)\n        if first_section in sections_painted or last_section in sections_painted:\n            return False\n        for i in range(first_section, last_section + 1):\n            if i in sections_painted:\n                return False\n        return True\n\n    N = int(stdin.readline())\n    offers = stdin.readlines()\n\n    sections_painted = set()\n    colors_used = Counter()\n    valid_offers = []\n\n    for offer in offers:\n        if is_valid_offer(offer, sections_painted):\n            color, first_section, last_section = offer.split()\n            sections_painted.update(range(int(first_section), int(last_section) + 1))\n            colors_used[color] += 1\n            valid_offers.append(offer)\n\n    if len(sections_painted) < 10000:\n        return \"IMPOSSIBLE\"\n    elif colors_used.most_common(1)[0][1] > 3:\n        return \"IMPOSSIBLE\"\n    else:\n        return str(len(valid_offers))"
    },
    {
        "number": 3004,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    offers = {}\n    for line in stdin.splitlines()[1:]:\n        color, start, end = line.split()\n        start, end = int(start), int(end)\n        if color not in offers:\n            offers[color] = []\n        offers[color].append((start, end))\n\n    colors = set(offers.keys())\n    used_colors = set()\n    painted = set()\n    min_count = float('inf')\n\n    def paint_fence(painted, offers, used_colors, color, start, end, count):\n        if end > 10000:\n            return False\n        if start in painted or (start - 1) in painted:\n            return False\n        painted.add(start)\n        used_colors.add(color)\n        count += 1\n\n        if len(used_colors) > 3:\n            return False\n\n        if end == 10000:\n            if count < min_count:\n                min_count = count\n            return True\n\n        for next_color, sections in offers.items():\n            for next_start, next_end in sections:\n                if next_start == end + 1:\n                    if paint_fence(painted, offers, used_colors, next_color, next_start, next_end, count):\n                        return True\n        painted.remove(start)\n        used_colors.remove(color)\n        return False\n\n    for color, sections in offers.items():\n        for start, end in sections:\n            painted.clear()\n            used_colors.clear()\n            if paint_fence(painted, offers, used_colors, color, start, end, 0):\n                return str(min_count)\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3004,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    offers = [tuple(map(int, line.split()[1:])) for line in lines[1:]]\n\n    # Sort the offers by first section\n    offers.sort(key=lambda x: x[0])\n\n    # Initialize the color count and the minimum number of offers\n    color_count = 1\n    min_offers = 1\n\n    # Initialize the current color and current section\n    current_color = offers[0][0]\n    current_section = offers[0][1]\n\n    # Iterate through the offers\n    for offer in offers[1:]:\n        # If the current section is the same as the first section of the offer,\n        # increase the color count and check if the color count is greater than 3\n        if current_section == offer[0]:\n            color_count += 1\n            if color_count > 3:\n                return \"IMPOSSIBLE\"\n        else:\n            # If the current section is greater than the first section of the offer,\n            # check if the difference between the current section and the first section is greater than the difference\n            # between the current section and the last section of the offer\n            if current_section - offer[0] > current_section - offer[1]:\n                return \"IMPOSSIBLE\"\n            # If the difference is greater, update the minimum offers and the current color and current section\n            min_offers += 1\n            current_color = offer[0]\n            current_section = offer[1]\n            color_count = 1\n\n    return str(min_offers)"
    },
    {
        "number": 3004,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    offers = []\n    colors = set()\n    for offer in stdin.split(\"\\n\")[1:]:\n        color, a, b = offer.split()\n        a, b = int(a), int(b)\n        offers.append((color, a, b))\n        colors.add(color)\n\n    if len(colors) > 3:\n        return \"IMPOSSIBLE\"\n\n    offers.sort(key=lambda x: x[1])\n    sections = [False] * 10000\n\n    for offer in offers:\n        color, a, b = offer\n        for i in range(a, b + 1):\n            if sections[i]:\n                return \"IMPOSSIBLE\"\n            sections[i] = True\n\n    return str(len(offers))"
    },
    {
        "number": 3004,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    offers = []\n    colors = set()\n    num_sections = 10000\n\n    for line in stdin.split('\\n'):\n        if line == \"\":\n            continue\n        color, a, b = line.split()\n        a, b = int(a), int(b)\n        if b - a + 1 > num_sections:\n            return \"IMPOSSIBLE\"\n        offers.append((color, a, b))\n        colors.add(color)\n\n    if len(colors) > 3:\n        return \"IMPOSSIBLE\"\n\n    offers.sort(key=lambda x: x[1])\n\n    for i in range(len(offers) - 1):\n        if offers[i][2] >= offers[i + 1][1]:\n            return \"IMPOSSIBLE\"\n\n    return str(len(offers))\n\n\ndef"
    },
    {
        "number": 3004,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    offers = []\n    colors = set()\n    for i, line in enumerate(stdin.split(\"\\n\")):\n        if i == 0:\n            n_offers = int(line)\n            continue\n        if i > n_offers:\n            break\n        color, a, b = line.split()\n        a, b = int(a), int(b)\n        if a == b:\n            continue\n        if a > b:\n            a, b = b, a\n        offers.append((color, a, b))\n        colors.add(color)\n    \n    if len(colors) > 3:\n        return \"IMPOSSIBLE\"\n    \n    offers.sort(key=lambda x: x[1])\n    accepted_offers = []\n    last_a = 0\n    last_color = \"\"\n    \n    for color, a, b in offers:\n        if a <= last_a:\n            continue\n        if color == last_color:\n            return \"IMPOSSIBLE\"\n        last_a = b\n        last_color = color\n        accepted_offers.append((color, a, b))\n    \n    return len(accepted_offers)"
    },
    {
        "number": 3004,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    offers = [tuple(line.split()) for line in lines[1:]]\n    colors = set()\n    for offer in offers:\n        colors.add(offer[0])\n\n    if len(colors) > 3:\n        return \"IMPOSSIBLE\"\n\n    offers.sort(key=lambda x: int(x[1]))\n    painted_sections = [False] * 10000\n    current_offer = 0\n    min_offers = n\n\n    for i in range(10000):\n        while current_offer < n and int(offers[current_offer][2]) < i:\n            current_offer += 1\n\n        if current_offer >= n:\n            break\n\n        if not painted_sections[i]:\n            painted_sections[i] = True\n            min_offers = min(min_offers, n - current_offer - (int(offers[current_offer][2]) - i))\n\n    return str(min_offers)\n\ndef"
    },
    {
        "number": 3004,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    offers = []\n\n    for _ in range(n):\n        color, a, b = stdin.readline().split()\n        offers.append((int(a), int(b), color))\n\n    offers.sort(key=lambda x: (x[0], -x[1]))\n    used_colors = set()\n    i = 0\n    j = 1\n    num_colors = 1\n    min_offers = n\n\n    while i < n:\n        if offers[i][1] < offers[j][0] - 1:\n            used_colors.remove(offers[i][2])\n            num_colors -= 1\n            i += 1\n        elif offers[j][1] <= offers[i][1]:\n            used_colors.add(offers[j][2])\n            num_colors += 1\n            j += 1\n        else:\n            min_offers = min(min_offers, n - num_colors)\n            if num_colors > 3:\n                return \"IMPOSSIBLE\"\n\n        if num_colors == 3:\n            return str(min_offers)\n\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3004,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_offer(offer, fence):\n        color, start, end = offer\n        return end - start < len(fence)\n\n    def get_colors(offers):\n        colors = set()\n        for offer in offers:\n            colors.add(offer[0])\n        return colors\n\n    def can_paint_fence(offers, fence_length):\n        colors = get_colors(offers)\n        if len(colors) > 3:\n            return False\n        used_sections = sum([offer[2] - offer[1] + 1 for offer in offers])\n        return used_sections == fence_length\n\n    def find_minimum_offers(offers, fence_length):\n        colors = get_colors(offers)\n        min_offers = float('inf')\n        for combination in itertools.combinations(colors, 3):\n            combination_offers = [offer for offer in offers if offer[0] in combination]\n            if can_paint_fence(combination_offers, fence_length):\n                min_offers = min(min_offers, len(combination_offers))\n        return min_offers\n\n    n = int(stdin.readline().strip())\n    offers = []\n    for _ in range(n):\n        offer = stdin.readline().strip().split()\n        if is_valid_offer(offer, range(1, 10001)):\n            offers.append(offer)\n\n    if can_paint_fence(offers, 10000):\n        return str(find_minimum_offers(offers, 10000))\n    else:\n        return \"IMPOSSIBLE\"\n\nimport sys\n"
    },
    {
        "number": 3005,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_factoring(string):\n        n = len(string)\n        weight_max = float('inf')\n        max_factoring = ''\n        for i in range(1, n):\n            for j in range(i, n):\n                substring = string[i:j+1]\n                count = string.count(substring)\n                if count > 1:\n                    factoring = f\"({substring})^{count}\"\n                    weight = len(factoring) - 4\n                    if weight < weight_max:\n                        weight_max = weight\n                        max_factoring = factoring\n        return max_factoring\n\n    return str(len(find_max_factoring(stdin)))"
    },
    {
        "number": 3005,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_factoring(string: str) -> str:\n        max_factoring = \"\"\n        max_weight = 0\n        for i in range(len(string)):\n            for j in range(i + 1, len(string) + 1):\n                substring = string[i:j]\n                count = string.count(substring)\n                if count > 1:\n                    factoring = f\"({substring})^{count}\"\n                    weight = len(factoring)\n                    if weight > max_weight:\n                        max_factoring = factoring\n                        max_weight = weight\n        return max_factoring\n\n    return str(len(find_max_factoring(stdin)))"
    },
    {
        "number": 3005,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    import re\n\n    def find_factors(s: str) -> str:\n        factors = []\n        for i in range(1, len(s) // 2 + 1):\n            if s.count(s[:i]) > 1:\n                factors.append(f\"({s[:i]})^{s.count(s[:i])}\")\n        return factors\n\n    def find_maximal_factor(s: str) -> str:\n        factors = find_factors(s)\n        if not factors:\n            return str(len(s))\n        return min(factors, key=len)\n\n    result = find_maximal_factor(stdin)\n    return str(len(result) - 2)"
    },
    {
        "number": 3005,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    max_weight = len(stdin)\n    substring = \"\"\n    max_substring = \"\"\n\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = stdin[i:j]\n            count = stdin.count(substring)\n\n            if count > 1:\n                weight = len(substring) * count\n\n                if weight < max_weight:\n                    max_weight = weight\n                    max_substring = substring\n\n    return max_weight\n\nstdin = input(\"Enter a string: \")\nprint(solution(stdin)) "
    },
    {
        "number": 3005,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_irreducible_factoring(s: str) -> str:\n        if len(s) == 1:\n            return s\n        \n        for i in range(1, len(s) // 2 + 1):\n            if s[:i] * (len(s) // i) == s:\n                if i == 1:\n                    return s\n                else:\n                    sub_factoring = find_irreducible_factoring(s[:i])\n                    return \"(\" + sub_factoring + \")^\" + str(len(s) // i)\n        \n        return s\n    \n    def weight(factoring: str) -> int:\n        return len(factoring) - 2 + sum(c.isdigit() for c in factoring)\n    \n    max_weight = -1\n    max_factoring = \"\"\n    \n    for i in range(1, len(stdin) // 2 + 1):\n        substring = stdin[:i]\n        factoring = find_irreducible_factoring(substring)\n        w = weight(factoring)\n        \n        if w > max_weight:\n            max_weight = w\n            max_factoring = factoring\n    \n    return max_weight"
    },
    {
        "number": 3005,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    import re\n\n    def factor(s: str) -> str:\n        pattern = r'(.+?)\\1+'\n        matches = list(re.finditer(pattern, s))\n        if not matches:\n            return s\n        max_match = max(matches, key=lambda x: len(x.group(1)))\n        factor_match = s[max_match.start():max_match.end()]\n        factor_count = len(max_match.group()) // len(factor_match)\n        return f\"({factor_match})^{factor_count}\"\n\n    def weight(s: str) -> int:\n        return len(s)\n\n    max_factor = factor(stdin)\n    max_weight = weight(max_factor)\n    return max_weight\n"
    },
    {
        "number": 3005,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_maximal_factoring(string):\n        stack = []\n        i = 0\n        while i < len(string):\n            if len(stack) > 0 and stack[-1] == string[i]:\n                stack.append(string[i])\n                i += 1\n            elif len(stack) > 1:\n                sub_factoring = \"\".join(stack)\n                stack = []\n                j = i\n                while j < len(string) and string[j] == sub_factoring[0]:\n                    j += 1\n                if j - i > 1:\n                    return sub_factoring, j - i\n            else:\n                stack = []\n                stack.append(string[i])\n                i += 1\n\n        if len(stack) > 1:\n            sub_factoring = \"\".join(stack)\n            return sub_factoring, 1\n        else:\n            return \"\", 0\n\n    max_factoring, weight = find_maximal_factoring(stdin)\n    return str(weight)"
    },
    {
        "number": 3005,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    import re\n\n    def factorize(string: str) -> str:\n        pattern = r\"((\\w)\\2*)\"\n        matches = re.findall(pattern, string)\n\n        factoring = \"\"\n        for match in matches:\n            substring, repetitions = match[0], len(match[1])\n            if repetitions > 1:\n                factoring += f\"({substring})^{repetitions}\"\n            else:\n                factoring += substring\n        return factoring\n\n    def weight(factoring: str) -> int:\n        return sum(len(factor) for factor in factoring.split(\"*\"))\n\n    def max_weight_factoring(string: str) -> int:\n        factorings = [factorize(string[i:]) for i in range(len(string))]\n        max_weight = 0\n        for factoring in factorings:\n            if factoring.count(\"(\") <= 1 and weight(factoring) > max_weight:\n                max_weight = weight(factoring)\n        return max_weight\n\n    return str(max_weight_factoring(stdin))"
    },
    {
        "number": 3005,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n + 1):\n            if stdin[i:j] == stdin[j:j + j - i]:\n                dp[i] = max(dp[i], dp[j] + j - i)\n    return dp[0]\n\ninput_string = input()\nprint(solution(input_string)) "
    },
    {
        "number": 3005,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if stdin[i] == stdin[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    ans = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if stdin[i:j] * dp[j] == stdin[i:i + dp[j] * len(stdin[i:j])]:\n                ans = min(ans, len(stdin[i:j]) * dp[j])\n    return ans if ans != float('inf') else 1\n\ndef"
    },
    {
        "number": 3006,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    program1 = []\n    program2 = []\n\n    for line in stdin.split(\"\\n\"):\n        if line.startswith(\"D \"):\n            program1.append((\"D\", int(line.split(\" \")[1])))\n            program2.append((\"D\", int(line.split(\" \")[1])))\n        elif line.startswith(\"I \"):\n            program1.append((\"I\", int(line.split(\" \")[1]), line.split(\" \")[2]))\n            program2.append((\"I\", int(line.split(\" \")[1]), line.split(\" \")[2]))\n        else:\n            break\n\n    if len(program1) != len(program2):\n        return \"1\"\n\n    for i in range(len(program1)):\n        if program1[i] != program2[i]:\n            return \"1\"\n\n    return \"0\"\n\ndef"
    },
    {
        "number": 3006,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> List[str]:\n        operations = []\n        for line in input_str.strip().split('\\n'):\n            if line.startswith('D'):\n                operations.append(f\"Del({line.split()[1]})\")\n            elif line.startswith('I'):\n                operations.append(f\"Ins({line.split()[1]}, {line.split()[2]})\")\n            else:\n                break\n        return operations\n\n    def apply_operations(operations: List[str], sequence: str) -> str:\n        result = sequence\n        for operation in operations:\n            if operation.startswith('Del'):\n                position = int(operation.split('(')[1].split(')')[0]) - 1\n                result = result[:position] + result[position + 1:]\n            elif operation.startswith('Ins'):\n                position, char = map(int, operation.split('(')[1].split(')')[0].split(','))\n                result = result[:position] + chr(char) + result[position:]\n        return result\n\n    operations1, operations2 = parse_input(stdin)\n    if operations1 == operations2:\n        return '0'\n    else:\n        sequence = 'A' * 10000000000\n        result1 = apply_operations(operations1, sequence)\n        result2 = apply_operations(operations2, sequence)\n        if result1 == result2:\n            return '0'\n        else:\n            return '1'"
    },
    {
        "number": 3006,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input into two programs\n    programs = stdin.split('\\n\\n')\n    if len(programs) != 2:\n        return \"Error: Invalid input\"\n    \n    # Parse the programs into operations\n    operations = [parse_operation(line) for line in programs[0].split('\\n')]\n    if not all(operations):\n        return \"Error: Invalid program 1\"\n    operations2 = [parse_operation(line) for line in programs[1].split('\\n')]\n    if not all(operations2):\n        return \"Error: Invalid program 2\"\n    \n    # Apply the operations to a long string\n    long_string = 'A' * 10000000000\n    long_string1 = apply_operations(long_string, operations)\n    long_string2 = apply_operations(long_string, operations2)\n    \n    # Compare the results\n    if long_string1 == long_string2:\n        return \"0\"\n    else:\n        return \"1\"\n\ndef"
    },
    {
        "number": 3006,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    program1, program2 = stdin.strip().split('\\n')\n    program1 = program1.split(' ')\n    program2 = program2.split(' ')\n\n    def apply_operation(program: list, operation: str) -> list:\n        if operation[0] == 'D':\n            index = int(operation[1:])\n            program[index - 1:index] = []\n        elif operation[0] == 'I':\n            index, char = operation[1:].split(' ')\n            index = int(index)\n            program[index:index] = [char]\n        return program\n\n    def compare_programs(program1: list, program2: list) -> bool:\n        return apply_operation(program1.copy(), 'E') == apply_operation(program2.copy(), 'E')\n\n    return '0' if compare_programs(program1, program2) else '1'"
    },
    {
        "number": 3006,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    program1 = parse_program(stdin.split('\\n')[0:stdin.index('E') + 1])\n    program2 = parse_program(stdin.split('\\n')[stdin.index('E') + 2:])\n    \n    if program1 == program2:\n        return \"0\"\n    else:\n        return \"1\"\n\ndef"
    },
    {
        "number": 3006,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    program1, program2 = stdin.strip().split('\\n\\n')\n\n    def process_program(program: str) -> list:\n        ops = []\n        for line in program.split('\\n'):\n            if line[0] == 'D':\n                ops.append(('D', int(line.split()[1])))\n            elif line[0] == 'I':\n                ops.append(('I', int(line.split()[1]), line.split()[2]))\n        return ops\n\n    ops1 = process_program(program1)\n    ops2 = process_program(program2)\n\n    if ops1 == ops2:\n        return '0'\n    else:\n        return '1'"
    },
    {
        "number": 3006,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    class LongLongString:\n        def __init__(self, string):\n            self.string = string\n        \n        def ins(self, p, c):\n            self.string = self.string[:p] + c + self.string[p:]\n        \n        def del_(self, p):\n            self.string = self.string[:p] + self.string[p+1:]\n        \n    program1 = stdin.split(\"\\n\")\n    program2 = stdin.split(\"\\n\")\n    for i in range(len(program1)):\n        program1[i] = program1[i].split()\n        program2[i] = program2[i].split()\n    \n    def compare_programs(program1, program2):\n        string = LongLongString(\"A\" * 10000000000)\n        for operation in program1:\n            if operation[0] == \"D\":\n                string.del_(int(operation[1]))\n            elif operation[0] == \"I\":\n                string.ins(int(operation[1]), operation[2])\n        string1 = string.string\n        \n        string = LongLongString(\"A\" * 10000000000)\n        for operation in program2:\n            if operation[0] == \"D\":\n                string.del_(int(operation[1]))\n            elif operation[0] == \"I\":\n                string.ins(int(operation[1]), operation[2])\n        string2 = string.string\n        \n        return string1 == string2\n    \n    return \"0\" if compare_programs(program1, program2) else \"1\""
    },
    {
        "number": 3006,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    operations = [line.strip() for line in stdin.split('\\n') if line.strip() != \"\"]\n    program1 = []\n    program2 = []\n    for operation in operations:\n        if operation[0] == \"D\":\n            program1.append((\"D\", int(operation.split(\" \")[1])))\n            program2.append((\"D\", int(operation.split(\" \")[1])))\n        elif operation[0] == \"I\":\n            program1.append((\"I\", int(operation.split(\" \")[1]), operation.split(\" \")[2]))\n            program2.append((\"I\", int(operation.split(\" \")[1]), operation.split(\" \")[2]))\n        else:\n            break\n\n    # Check if the two programs are identical\n    if program1 == program2:\n        return \"0\"\n    else:\n        return \"1\" "
    },
    {
        "number": 3006,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Remove the trailing spaces and split the input by lines\n    lines = stdin.strip().splitlines()\n\n    # Initialize two lists to store the operations of the two programs\n    program1 = []\n    program2 = []\n\n    # Process the lines of the input\n    for line in lines:\n        if line[0] == \"E\":\n            break\n        elif line[0] == \"D\":\n            position = int(line.split(\" \")[1])\n            program1.append((\"D\", position))\n            program2.append((\"D\", position))\n        elif line[0] == \"I\":\n            position, character = line.split(\" \")[1:]\n            position = int(position)\n            program1.append((\"I\", position, character))\n            program2.append((\"I\", position, character))\n\n    # Compare the two programs\n    if program1 == program2:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 3006,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    class LongLongString:\n        def __init__(self):\n            self.string = []\n\n        def ins(self, p, c):\n            self.string.insert(p - 1, c)\n\n        def del_(self, p):\n            self.string.pop(p - 1)\n\n        def __eq__(self, other):\n            return self.string == other.string\n\n    operations = stdin.split('\\n')\n    program1 = LongLongString()\n    program2 = LongLongString()\n\n    for operation in operations:\n        op_type, *args = operation.split()\n        if op_type == 'D':\n            program1.del_(int(args[0]))\n            program2.del_(int(args[0]))\n        elif op_type == 'I':\n            program1.ins(int(args[0]), args[1])\n            program2.ins(int(args[0]), args[1])\n\n    return str(int(program1 == program2)) "
    },
    {
        "number": 3007,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Calculate the total number of fruits that Johan can sell in the remaining time\n    total_fruits = min(f, d) * 100\n\n    # Calculate the number of fruits that Johan can plant\n    plantable_fruits = min(f, d)\n\n    # Calculate the number of fruits that Johan can buy from the neighboring village\n    buyable_fruits = min(d, 40 - t0 - t1 - t2)\n\n    # Calculate the maximum number of exotic fruits that Johan can buy\n    max_exotic_fruits = min(1, buyable_fruits)\n\n    # Calculate the total amount of Bling that Johan can earn from selling the maximum number of fruits and exotic fruits\n    total_bling = total_fruits + max_exotic_fruits * 500\n\n    return str(total_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    max_bling = 0\n    total_fruit_trees = t0 + t1 + t2\n\n    for i in range(1, d + 1):\n        if i <= t0:\n            b += 3 * f * 100\n            f += 3\n        elif i <= t1:\n            b += 3 * f * 100\n            f -= t0\n            f += 3\n        else:\n            b += 3 * f * 100\n            f -= t0 + t1\n            f += 3\n\n        b += f * 100\n        max_bling = max(max_bling, b)\n\n        if i <= total_fruit_trees:\n            b -= 100\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Calculate the maximum Bling Johan can have after playing d days\n    max_bling = b + 100 * (f + t0 + t1 + t2)\n\n    # If there are fruit trees, calculate the maximum Bling he can have from those trees\n    if t0 + t1 + t2 > 0:\n        max_bling += 300 * ((t0 + t1 + t2) // 3)\n\n    # Calculate the maximum Bling Johan can have from buying exotic fruits\n    if b >= 400:\n        max_bling += 500 * min(f, 1)\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    \n    # The maximum number of fruits that can be sold for Bling\n    max_sellable_fruits = min(f, d)\n    \n    # The maximum number of fruits that can be planted into fruit trees\n    max_plantable_fruits = min(f, 100 - t0)\n    \n    # The maximum amount of Bling Johan can have from selling and planting fruits\n    bling = max_sellable_fruits * 100 + max_plantable_fruits * 100\n    \n    # The number of fruits that Johan has after selling and planting\n    f = f - max_sellable_fruits - max_plantable_fruits\n    \n    # The number of fruit trees that Johan has after selling and planting\n    t0 = min(t0 + max_plantable_fruits, 100)\n    t1 = min(t1 + max_plantable_fruits, 100)\n    t2 = min(t2 + max_plantable_fruits, 100)\n    \n    # The number of fruits that Johan has from the fruit trees\n    f += t0 + t1 + t2\n    \n    # The maximum amount of Bling Johan can have from buying exotic fruits\n    max_buyable_exotic_fruits = min(b // 500, d)\n    b -= max_buyable_exotic_fruits * 500\n    \n    # The maximum amount of Bling Johan can have from selling and planting exotic fruits\n    max_sellable_exotic_fruits = min(f, d)\n    max_plantable_exotic_fruits = min(f, 100 - t0)\n    bling += max_sellable_exotic_fruits * 500 + max_plantable_exotic_fruits * 500\n    f -= max_sellable_exotic_fruits + max_plantable_exotic_fruits\n    t0 = min(t0 + max_plantable_exotic_fruits, 100)\n    t1 = min(t1 + max_plantable_exotic_fruits, 100)\n    t2 = min(t2 + max_plantable_exotic_fruits, 100)\n    f += t0 + t1 + t2\n    \n    # The number of exotic fruit trees that Johan has after selling and planting\n    t0 = min(t0 + max_plantable_exotic_fruits, 100)\n    t1 = min(t1 + max_plantable_exotic_fruits, 100)\n    t2 = min(t2 + max_plantable_exotic_fruits, 100)\n    \n    return str(bling) "
    },
    {
        "number": 3007,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    fruits_per_day = 3\n\n    # calculate total number of fruits from all fruit trees\n    total_fruits = f + t0 * fruits_per_day + t1 * fruits_per_day + t2 * fruits_per_day\n\n    # calculate maximum number of fruits that can be sold\n    max_fruits_to_sell = min(total_fruits, d * 10)\n\n    # calculate total Bling from selling fruits\n    total_bling = max_fruits_to_sell * 100\n\n    # calculate Bling from buying exotic fruit\n    exotic_fruit_bling = min(d * 400, b)\n    if exotic_fruit_bling > 0:\n        total_bling += exotic_fruit_bling\n        b -= exotic_fruit_bling\n\n    return str(total_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    max_bling = 0\n\n    for days_left in range(1, d + 1):\n        b += f * 100\n        f += sum([t0, t1, t2])\n        b += sum([t0, t1, t2]) * 500\n\n        if days_left % 3 == 0:\n            t0, t1, t2 = t1, t2, 0\n        else:\n            t0, t1, t2 = t0, t1, t2 + 1\n\n        max_bling = max(max_bling, b)\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    max_bling = 0\n\n    # Buy an exotic fruit if possible\n    if b >= 400:\n        b -= 400\n        max_bling += 500\n\n    # Sell fruits if possible\n    max_bling += f * 100\n    f = 0\n\n    # Sell fruit trees if possible\n    for t in [t0, t1, t2]:\n        max_bling += t * 300\n        f += t * 3\n\n    # Buy fruit trees if possible\n    while d > 0 and f < 100:\n        if b >= 400:\n            b -= 400\n            max_bling += 100\n            f += 1\n            d -= 1\n        else:\n            break\n\n    # Use remaining Bling to buy fruits if possible\n    while d > 0 and f < 100 and b >= 100:\n        b -= 100\n        f += 1\n        max_bling += 100\n        d -= 1\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = map(int, stdin.split())\n    # calculate maximum amount of bling that can be earned in the remaining time\n    b += f * 100\n    b += t_0 * 300\n    b += t_1 * 300\n    b += t_2 * 300\n    return str(b)"
    },
    {
        "number": 3007,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_fruit(day, trees, fruits):\n        if day >= 3 and trees[day-3] > 0:\n            fruits += trees[day-3]\n        return fruits\n\n    def sell_fruit(price, bling, num_fruits):\n        if bling >= price * num_fruits:\n            bling -= price * num_fruits\n        else:\n            num_fruits = bling // price\n            bling -= num_fruits * price\n        return bling, num_fruits\n\n    def buy_exotic(bling, exotic, price):\n        if bling >= price:\n            exotic += 1\n            bling -= price\n        return bling, exotic\n\n    def count_exotic(day, exotics):\n        if day >= 3 and exotics[day-3] > 0:\n            exotics[day-3] -= 1\n        return exotics\n\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    trees = [t0, t1, t2]\n    exotics = [0, 0, 0]\n    exotic = 0\n    max_bling = b\n    for day in range(1, d+1):\n        fruits = count_fruit(day, trees, f)\n        b, f = sell_fruit(100, b, fruits)\n        b, exotic = buy_exotic(b, exotic, 400)\n        b, exotic = sell_fruit(500, b, exotic)\n        exotics = count_exotic(day, exotics)\n        trees = [t0, t1, t2]\n        max_bling = max(max_bling, b)\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Calculate the maximum bling for each fruit tree\n    tree_yields = [0, 3, 6]\n    max_bling_per_tree = [100 * (t0 + t1 + t2) // y for y in tree_yields]\n\n    # Calculate the maximum bling for fruit harvesting\n    max_bling_per_fruit = 100\n\n    # Calculate the maximum bling for exotic fruit harvesting\n    max_bling_per_exotic_fruit = 500\n\n    # Calculate the maximum bling for selling exotic fruit\n    sell_exotic_fruit_cost = 400\n\n    # Calculate the maximum bling for planting fruit trees\n    plant_fruit_tree_cost = 0\n\n    # Calculate the maximum bling Johan can achieve in the remaining time\n    max_bling = b\n    for day in range(1, d+1):\n        # Sell fruits and exotic fruits\n        if day % 3 == 1:\n            max_bling += max_bling_per_tree[0]\n            max_bling_per_tree[0] = 0\n            max_bling_per_tree = [max(max_bling_per_tree[i], max_bling_per_tree[i+1]) for i in range(2)]\n        elif day % 3 == 2:\n            max_bling += max_bling_per_tree[1]\n            max_bling_per_tree[1] = 0\n            max_bling_per_tree[0] = max(max_bling_per_tree[0], max_bling_per_tree[2])\n        elif day % 3 == 0:\n            max_bling += max_bling_per_tree[2]\n            max_bling_per_tree[2] = 0\n            max_bling_per_tree[1] = max(max_bling_per_tree[1], max_bling_per_tree[2])\n\n        # Buy fruit trees\n        if f > 0:\n            max_bling += plant_fruit_tree_cost\n            f -= 1\n\n        # Buy exotic fruit\n        if max_bling - max_bling_per_exotic_fruit >= sell_exotic_fruit_cost:\n            max_bling -= sell_exotic_fruit_cost\n            max_bling += max_bling_per_exotic_fruit\n\n    return str(max_bling)"
    },
    {
        "number": 3008,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:N+2]))\n    b = list(map(int, stdin.split()[N+2:]))\n    \n    # Sort the assistants based on their quality\n    assistants = sorted(zip(a, b), key=lambda x: (x[0], x[1]))\n    n_ranks = 1\n    \n    # Iterate through the assistants and assign ranks\n    for i in range(N-1):\n        if assistants[i][0] + K < assistants[i+1][0] or assistants[i][1] + K < assistants[i+1][1]:\n            n_ranks += 1\n    \n    return str(n_ranks)"
    },
    {
        "number": 3008,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    N, K = map(int, stdin.splitlines()[0].split())\n    a_list = list(map(int, stdin.splitlines()[1].split()))\n    b_list = list(map(int, stdin.splitlines()[2].split()))\n    \n    # sort by total measurement\n    assistants = [(a + b, i) for i, (a, b) in enumerate(zip(a_list, b_list))]\n    assistants.sort(reverse=True)\n    \n    # initialize rank and ranks list\n    rank = 0\n    ranks = []\n    \n    # iterate through sorted assistants\n    for total_measurement, i in assistants:\n        # check if assistant's rank should be increased\n        if not ranks or total_measurement >= ranks[-1] - K:\n            rank += 1\n            ranks.append(total_measurement)\n            \n    # return the number of distinct ranks\n    return str(rank)"
    },
    {
        "number": 3008,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    \n    # Sort the assistants based on their combined qualities (a + b)\n    assistants = sorted(zip(a, b, range(N)), key=lambda x: x[0] + x[1])\n    \n    # Initialize the ranks and the current rank\n    ranks = [0] * N\n    current_rank = 0\n    \n    # Iterate over the assistants and assign ranks while following the rules\n    for i in range(N):\n        for j in range(i):\n            if (assistants[i][0] + K < assistants[j][0] or assistants[i][1] + K < assistants[j][1]) and ranks[i] <= ranks[j]:\n                ranks[i] = ranks[j] + 1\n        if current_rank < ranks[i]:\n            current_rank = ranks[i]\n    \n    # Return the maximum number of distinct ranks\n    return str(current_rank + 1)"
    },
    {
        "number": 3008,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    assistants_a = list(map(int, stdin.split()[2:N+2]))\n    assistants_b = list(map(int, stdin.split()[N+2:]))\n    \n    def merge_sort(arr: List[int]) -> List[int]:\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n    \n    def merge(left: List[int], right: List[int]) -> List[int]:\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result += left[i:]\n        result += right[j:]\n        return result\n    \n    assistants_rank = assistants_a + assistants_b\n    assistants_rank = merge_sort(assistants_rank)\n    \n    distinct_ranks = []\n    for i in range(N):\n        if i == 0 or assistants_rank[i] - assistants_rank[i-1] > K:\n            distinct_ranks.append(assistants_rank[i])\n    \n    return str(len(distinct_ranks))"
    },
    {
        "number": 3008,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split('\\n')[0].split())\n    a_list = list(map(int, stdin.split('\\n')[1].split()))\n    b_list = list(map(int, stdin.split('\\n')[2].split()))\n\n    # Sort the measurements in ascending order\n    a_list.sort()\n    b_list.sort()\n\n    # Initialize the rank for the first assistant\n    rank = 1\n    a_rank = [1]\n    b_rank = [1]\n\n    # Iterate through the assistants and assign the rank\n    for i in range(1, N):\n        if a_list[i] - a_list[i - 1] > K or b_list[i] - b_list[i - 1] > K:\n            rank += 1\n            a_rank.append(rank)\n            b_rank.append(rank)\n        else:\n            a_rank.append(rank)\n            b_rank.append(rank)\n\n    return str(max(a_rank + b_rank))"
    },
    {
        "number": 3008,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, assistants_a, assistants_b = stdin.split(\"\\n\")\n    N = int(N)\n    K = int(K)\n    assistants_a = list(map(int, assistants_a.split()))\n    assistants_b = list(map(int, assistants_b.split()))\n\n    assistants_a.sort(reverse=True)\n    assistants_b.sort(reverse=True)\n\n    rank = 1\n    current_a = assistants_a[0]\n    current_b = assistants_b[0]\n\n    for i in range(1, N):\n        if assistants_a[i] + K < current_a or assistants_b[i] + K < current_b:\n            current_a = assistants_a[i]\n            current_b = assistants_b[i]\n            rank += 1\n\n    return str(rank)\n\ninput_data = \"2 10\\n1 12\\n1 13\"\nprint(solution(input_data)) "
    },
    {
        "number": 3008,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, assistants_a, assistants_b = stdin.split()\n    N = int(N)\n    K = int(K)\n    assistants_a = list(map(int, assistants_a))\n    assistants_b = list(map(int, assistants_b))\n\n    assistants_a.sort(reverse=True)\n    assistants_b.sort(reverse=True)\n\n    i, j = 0, 0\n    ranks = 0\n\n    while i < N and j < N:\n        if assistants_a[i] + K < assistants_a[j]:\n            ranks += 1\n            i += 1\n        elif assistants_b[i] + K < assistants_b[j]:\n            ranks += 1\n            j += 1\n        else:\n            i += 1\n            j += 1\n\n    return str(ranks + 1)"
    },
    {
        "number": 3008,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, assistants_a, assistants_b = stdin.split('\\n')\n    N = int(N)\n    K = int(K)\n    assistants_a = list(map(int, assistants_a.split()))\n    assistants_b = list(map(int, assistants_b.split()))\n    \n    assistants_rank = [0] * N\n    max_rank = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if assistants_a[i] + K < assistants_a[j] or assistants_b[i] + K < assistants_b[j]:\n                assistants_rank[i] = max(assistants_rank[i], assistants_rank[j])\n                max_rank = max(max_rank, assistants_rank[i])\n            else:\n                assistants_rank[j] = max(assistants_rank[i], assistants_rank[j])\n                max_rank = max(max_rank, assistants_rank[j])\n    \n    return str(max_rank + 1)"
    },
    {
        "number": 3008,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, k = list(map(int, lines[0].split()))\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n\n    a.sort()\n    b.sort()\n\n    ranks = []\n    i, j = 0, 0\n\n    while i < n and j < n:\n        if a[i] + k < a[j]:\n            ranks.append(i)\n            i += 1\n        elif b[i] + k < b[j]:\n            ranks.append(i)\n            i += 1\n        else:\n            ranks.append(j)\n            j += 1\n\n    for i in range(i, n):\n        ranks.append(i)\n\n    for j in range(j, n):\n        ranks.append(j)\n\n    return str(len(set(ranks)))\n\ninput1 = \"2 10\\n1 12\\n1 13\"\ninput2 = \"2 10\\n1 5\\n1 12\"\ninput3 = \"2 10\\n1 5\\n1 4\"\ninput4 = \"2 10\\n1 5\\n4 1\"\n\nprint(solution(input1))  # Output: 2\nprint(solution(input2))  # Output: 2\nprint(solution(input3))  # Output: 2\nprint(solution(input4))  # Output: 2 "
    },
    {
        "number": 3008,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, K = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n\n    rankings = []\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    for i in range(N):\n        ranking = 0\n        for j in range(i+1, N):\n            if a[i] - a[j] > K or b[i] - b[j] > K:\n                ranking += 1\n        rankings.append(ranking + 1)\n\n    return str(max(rankings))\n"
    },
    {
        "number": 3009,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lamps = []\n    for i in range(n):\n        lamp = stdin.split('\\n')[i+1].split(' ')\n        lamps.append([int(lamp[0]), int(lamp[1]), int(lamp[2])])\n\n    positive_energy = sum(lamp[2] for lamp in lamps if lamp[2] > 0)\n    negative_energy = sum(lamp[2] for lamp in lamps if lamp[2] < 0)\n\n    if positive_energy == negative_energy:\n        return 'IMPOSSIBLE'\n\n    min_distance = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            lamp1 = lamps[i]\n            lamp2 = lamps[j]\n            distance = ((lamp1[0] - lamp2[0]) ** 2 + (lamp1[1] - lamp2[1]) ** 2) ** 0.5\n            if distance < min_distance:\n                min_distance = distance\n\n    return round(min_distance, 6)"
    },
    {
        "number": 3009,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    lamps = []\n    for i in range(1, N + 1):\n        lamp = list(map(int, lines[i].split()))\n        lamps.append(lamp)\n\n    # Calculate total positive and negative energies\n    total_positive_energy = sum(map(lambda x: x[2], lamps))\n    total_negative_energy = 0\n    for lamp in lamps:\n        total_negative_energy += max(0, lamp[2])\n\n    # Check if it's impossible to balance the energy\n    if total_positive_energy == total_negative_energy:\n        return \"IMPOSSIBLE\"\n\n    # Calculate the length of the shortest line\n    min_length = float('inf')\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            lamp_i = lamps[i - 1]\n            lamp_j = lamps[j - 1]\n            x_i, y_i = lamp_i[:2]\n            x_j, y_j = lamp_j[:2]\n            length = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5\n            if abs(total_positive_energy - (total_negative_energy + lamp_i[2] - lamp_j[2])) < 1e-6:\n                min_length = min(min_length, length)\n\n    return str(min_length) if min_length != float('inf') else \"IMPOSSIBLE\""
    },
    {
        "number": 3009,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    lamps = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    def get_distance(p1: tuple, p2: tuple) -> float:\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def get_total_energy(lamps: list) -> int:\n        return sum(e for _, _, e in lamps)\n\n    def is_valid_line(line: list) -> bool:\n        if len(line) < 3:\n            return False\n        for i in range(1, len(line)):\n            p1 = line[i - 1]\n            p2 = line[i]\n            distance = get_distance(p1, p2)\n            if distance < 1:\n                return False\n        return True\n\n    def get_min_length(lamps: list) -> float:\n        lines = []\n        for lamp1 in lamps:\n            for lamp2 in lamps:\n                if lamp1 != lamp2:\n                    lines.append((lamp1, lamp2))\n\n        valid_lines = [line for line in lines if is_valid_line(line)]\n        if not valid_lines:\n            return float('inf')\n\n        min_length = float('inf')\n        for line in valid_lines:\n            total_energy = get_total_energy(line)\n            if total_energy == 0:\n                continue\n            length = sum(get_distance(p1, p2) for p1, p2 in zip(line, line[1:]))\n            if total_energy < 0:\n                length = -length\n            min_length = min(min_length, length)\n\n        return min_length\n\n    min_length = get_min_length(lamps)\n\n    if min_length == float('inf'):\n        return 'IMPOSSIBLE'\n    elif min_length < 0:\n        min_length = -min_length\n\n    return format(min_length, '.6f')"
    },
    {
        "number": 3009,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    num_lamps, lamps = parse_input(stdin)\n    \n    # Calculate energy contribution of each lamp\n    lamp_energies = [lamp[2] for lamp in lamps]\n    \n    # Calculate total energy contribution\n    total_energy = sum(lamp_energies)\n    \n    # Calculate optimal length of line\n    line_length = calculate_line_length(lamps, lamp_energies, total_energy)\n    \n    # Check if line length is possible\n    if line_length is None:\n        return \"IMPOSSIBLE\"\n    \n    # Return line length\n    return format(line_length, \".6f\")\n\ndef"
    },
    {
        "number": 3009,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The function takes a string as input and returns the length of the shortest continuous line dividing the positive and negative energy sources in the room.\n    \"\"\"\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    lamps = []\n\n    for i in range(1, n+1):\n        x, y, e = map(int, input_list[i].split())\n        lamps.append((x, y, e))\n\n    lamps.sort(key=lambda x: (x[0], x[1]))\n    positive_sum = sum(x[2] for x in lamps if x[2] > 0)\n    negative_sum = sum(x[2] for x in lamps if x[2] < 0)\n\n    if positive_sum < negative_sum:\n        positive_sum, negative_sum = negative_sum, positive_sum\n\n    diff = abs(positive_sum - negative_sum)\n    left, right = 0, 1000000\n\n    while left + 1e-6 < right:\n        mid = (left + right) / 2\n        count = 0\n        cur_positive_sum, cur_negative_sum = 0, 0\n\n        for lamp in lamps:\n            if lamp[2] > 0:\n                cur_positive_sum += lamp[2]\n            else:\n                cur_negative_sum -= lamp[2]\n\n            if lamp[0] >= mid:\n                count += 1\n                if lamp[2] > 0:\n                    cur_positive_sum -= lamp[2]\n                else:\n                    cur_negative_sum += lamp[2]\n\n        if cur_positive_sum + cur_negative_sum - diff <= 0:\n            left = mid\n        else:\n            right = mid\n\n    return round(left, 6)"
    },
    {
        "number": 3009,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split('\\n')\n    num_lamps = int(stdin_list[0])\n    lamps_list = []\n    \n    for i in range(1, num_lamps + 1):\n        x, y, e = map(int, stdin_list[i].split())\n        lamps_list.append((x, y, e))\n    \n    def is_inside(x, y, line):\n        if len(line) == 1:\n            return False\n        p1, p2 = line\n        a = (p2[1] - p1[1]) / (p2[0] - p1[0])\n        b = p1[1] - a * p1[0]\n        return y > a * x + b\n    \n    def find_intersection(line1, line2):\n        if len(line1) == 1 or len(line2) == 1:\n            return None\n        p1, p2 = line1\n        p3, p4 = line2\n        x = (p2[0] - p1[0]) * (p3[1] - p4[1]) * (p4[0] - p3[0]) - (p2[1] - p1[1]) * (p3[0] - p4[0]) * (p4[1] - p3[1])\n        y = (p2[0] - p1[0]) * (p3[1] - p4[1]) * (p1[0] - p3[0]) - (p2[1] - p1[1]) * (p3[0] - p4[0]) * (p1[1] - p3[1])\n        if x == 0 and y == 0:\n            return None\n        return (x / (x**2 + y**2), -y / (x**2 + y**2))\n    \n    def find_closest_point(p1, p2, p3):\n        a = (p2[1] - p1[1]) / (p2[0] - p1[0])\n        b = p1[1] - a * p1[0]\n        x = (b - p3[1] + a * p3[0]) / (a**2 + 1)\n        y = a * x + b\n        return (x, y)\n    \n    def find_closest_points(p1, p2, p3):\n        p4 = find_closest_point(p1, p2, p3)\n        if is_inside(p4[0], p4[1], [(p1, p2)]):\n            return p3, p4\n        else:\n            return p4, p3\n    \n    def find_balance_line(lamps_list):\n        n = len(lamps_list)\n        if n == 2:\n            return None\n        bal_line = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lamps_list[i][2] * lamps_list[j][2] < 0:\n                    bal_line.append((lamps_list[i][:2], lamps_list[j][:2]))\n        if len(bal_line) == 0:\n            return None\n        return min(bal_line, key=lambda x: abs(x[1][0] - x[0][0]) + abs(x[1][1] - x[0][1]))\n    \n    def find_min_balance_length(lamps_list):\n        bal_line = find_balance_line(lamps_list)\n        if bal_line is None:\n            return \"IMPOSSIBLE\"\n        min_length = float('inf')\n        for i in range(len(bal_line)):\n            line1 = bal_line[i]\n            for j in range(i + 1, len(bal_line)):\n                line2 = bal_line[j]\n                intersection = find_intersection(line1, line2)\n                if intersection is not None:\n                    p3, p4 = find_closest_points(line1[0], line1[1], intersection)\n                    length = abs(p3[0"
    },
    {
        "number": 3009,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    lamps = []\n\n    for i in range(1, N + 1):\n        x, y, e = map(int, lines[i].split())\n        lamps.append((x, y, e))\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def is_inside(line, lamp):\n        A, B, C = line\n        x, y, e = lamp\n        return (A * x + B * y + C) * e >= 0\n\n    def is_overlapping(lamps):\n        for i in range(N):\n            for j in range(i + 1, N):\n                x1, y1, e1 = lamps[i]\n                x2, y2, e2 = lamps[j]\n                if distance(x1, y1, x2, y2) <= 2:\n                    return True\n        return False\n\n    def find_line(lamps):\n        min_length = float('inf')\n        for A in range(-99, 100):\n            for B in range(-99, 100):\n                C = -A * 10 - B * 10\n                if A == 0 and B == 0:\n                    continue\n                if is_overlapping([(x, y, e) for x, y, e in lamps if is_inside((A, B, C), (x, y, e))]):\n                    continue\n                line_length = sum([distance(x, y, x * A + y * B + C / 2) for x, y, e in lamps if is_inside((A, B, C), (x, y, e))])\n                if line_length < min_length:\n                    min_length = line_length\n                    best_line = (A, B, C)\n        return best_line\n\n    line = find_line(lamps)\n    return '{:.6f}'.format(sum([distance(x, y, x * line[0] + y * line[1] + line[2] / 2) for x, y, e in lamps]))"
    },
    {
        "number": 3009,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((b[0] - a[0]) ** 2 + (b[1] - a[1]) ** 2) ** 0.5\n\n    def is_inside(line, lamp):\n        A, B, C = line\n        x, y = lamp\n        return (B[1] - A[1]) * x - (B[0] - A[0]) * y >= (B[1] - A[1]) * A[0] - (B[0] - A[0]) * A[1]\n\n    def energy_inside(lamp_positions, line):\n        return sum(lamp[2] for lamp in lamp_positions if is_inside(line, lamp[:2]))\n\n    def find_balance_line(lamp_positions):\n        n = len(lamp_positions)\n        lines = []\n        min_length = float('inf')\n\n        for i in range(n):\n            A = lamp_positions[i][:2]\n            for j in range(i + 1, n):\n                B = lamp_positions[j][:2]\n                for k in range(j + 1, n):\n                    C = lamp_positions[k][:2]\n                    d1 = distance(A, B)\n                    d2 = distance(B, C)\n                    d3 = distance(C, A)\n                    s = (d1 + d2 + d3) / 2\n                    area = (d1 * d2 * d3) ** 0.5\n                    if area == 0:\n                        continue\n                    h = 2 * area / d1\n                    line = (A, B, C)\n                    energy_positive = energy_inside(lamp_positions, line)\n                    energy_negative = sum(lamp[2] for lamp in lamp_positions) - energy_positive\n                    if energy_negative < energy_positive:\n                        energy_negative, energy_positive = energy_positive, energy_negative\n                    length = h / energy_positive * energy_negative\n                    if length < min_length:\n                        min_length = length\n                        lines.clear()\n                        lines.append(line)\n                    elif length == min_length:\n                        lines.append(line)\n\n        if min_length == float('inf'):\n            return \"IMPOSSIBLE\"\n        return min_length\n\n    N = int(stdin.readline())\n    lamp_positions = []\n    for _ in range(N):\n        x, y, e = map(int, stdin.readline().split())\n        lamp_positions.append((x, y, e))\n\n    return str(find_balance_line(lamp_positions))"
    },
    {
        "number": 3009,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def energy_balance(x1, y1, x2, y2, x3, y3, x4, y4, energy_a, energy_b, energy_c, energy_d):\n        area_a = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)\n        area_b = (x3 - x1) * (y4 - y1) - (x4 - x1) * (y3 - y1)\n        area_c = (x4 - x1) * (y2 - y1) - (x2 - x1) * (y4 - y1)\n        area_d = (x2 - x1) * (y1 - y3) - (x3 - x1) * (y2 - y3)\n        sum_area = abs(area_a) + abs(area_b) + abs(area_c) + abs(area_d)\n        sum_energy = energy_a + energy_b + energy_c + energy_d\n        balance = sum_energy / (2 * sum_area)\n        return balance\n\n    def is_possible(x1, y1, x2, y2, x3, y3, x4, y4, energy_a, energy_b, energy_c, energy_d):\n        area_a = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)\n        area_b = (x3 - x1) * (y4 - y1) - (x4 - x1) * (y3 - y1)\n        area_c = (x4 - x1) * (y2 - y1) - (x2 - x1) * (y4 - y1)\n        area_d = (x2 - x1) * (y1 - y3) - (x3 - x1) * (y2 - y3)\n        sum_area = abs(area_a) + abs(area_b) + abs(area_c) + abs(area_d)\n        return sum_area > 0\n\n    stdin = stdin.strip().split('\\n')\n    n = int(stdin[0])\n    lamps = []\n\n    for i in range(1, n + 1):\n        x, y, e = map(int, stdin[i].split())\n        lamps.append((x, y, e))\n\n    min_balance = float('inf')\n    min_line = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    x1, y1, e1 = lamps[i]\n                    x2, y2, e2 = lamps[j]\n                    x3, y3, e3 = lamps[k]\n                    x4, y4, e4 = lamps[l]\n                    if is_possible(x1, y1, x2, y2, x3, y3, x4, y4, e1, e2, e3, e4):\n                        balance = energy_balance(x1, y1, x2, y2, x3, y3, x4, y4, e1, e2, e3, e4)\n                        if balance < min_balance:\n                            min_balance = balance\n                            min_line = ((x1, y1), (x2, y2), (x3, y3), (x4, y4))\n\n    if min_balance == float('inf'):\n        return 'IMPOSSIBLE'\n    else:\n        return distance(min_line[0][0], min_line[0][1], min_line[1][0], min_line[1][1])"
    },
    {
        "number": 3009,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def energy(lamp):\n        return lamp[2]\n\n    def is_inside(line, lamp):\n        return (lamp[0] - line[0]) * (line[1] - line[2]) - (line[0] - line[1]) * (lamp[1] - line[2]) > 0\n\n    def closest_intersection(line1, line2, lamps):\n        intersections = []\n        for lamp1 in lamps:\n            for lamp2 in lamps:\n                if lamp1 == lamp2:\n                    continue\n                x1, y1 = lamp1[:2]\n                x2, y2 = lamp2[:2]\n                A = y2 - y1\n                B = x1 - x2\n                C = (x2 - x1) * y1 - (y2 - y1) * x1\n                if abs(A * x1 + B * y1 + C) / ((A ** 2 + B ** 2) ** 0.5) <= 1e-6:\n                    intersections.append((x1, y1))\n        if not intersections:\n            return None\n        return min(intersections, key=lambda x: distance(line1[0], line1[1], x[0], x[1]) + distance(line2[0], line2[1], x[0], x[1]))\n\n    def total_energy(lamp, lamps):\n        return sum(energy(lamp2) for lamp2 in lamps if is_inside(lamp, lamp2))\n\n    def find_shortest_balancing_line(lamps):\n        min_length = float('inf')\n        for lamp1 in lamps:\n            for lamp2 in lamps:\n                if lamp1 == lamp2:\n                    continue\n                line = closest_intersection(lamp1[:2], lamp2[:2], lamps)\n                if line is not None:\n                    length = distance(line[0], line[1], lamp1[0], lamp1[1]) + distance(line[0], line[1], lamp2[0], lamp2[1])\n                    if length < min_length:\n                        min_length = length\n        return min_length\n\n    n = int(stdin.readline())\n    lamps = []\n    for _ in range(n):\n        x, y, e = map(int, stdin.readline().strip().split())\n        lamps.append((x, y, e))\n\n    shortest_balancing_line = find_shortest_balancing_line(lamps)\n    if shortest_balancing_line == float('inf'):\n        return 'IMPOSSIBLE'\n    return '{:.6f}'.format(shortest_balancing_line)"
    },
    {
        "number": 3010,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lines = stdin.split('\\n')[1:]\n    points = set()\n\n    for line in lines:\n        x0, y0, x1, y1 = map(int, line.split())\n        for x in range(min(x0, x1), max(x0, x1) + 1):\n            for y in range(min(y0, y1), max(y0, y1) + 1):\n                points.add((x, y))\n\n    count = 0\n    for point in points:\n        if len(set(point)) == 2:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3010,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lines = stdin.split('\\n')[1:]\n    points = set()\n\n    for line in lines:\n        x0, y0, x1, y1 = map(int, line.split())\n        points.add((x0, y0))\n        points.add((x1, y1))\n\n    return str(len(points))\n"
    },
    {
        "number": 3010,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_intersect_points(lines: List[Tuple[int, int, int, int]]) -> Set[Tuple[int, int]]:\n        def is_vertical(line: Tuple[int, int, int, int]) -> bool:\n            return line[0] == line[2]\n        \n        def is_horizontal(line: Tuple[int, int, int, int]) -> bool:\n            return line[1] == line[3]\n        \n        def get_slope(line: Tuple[int, int, int, int]) -> Union[float, None]:\n            if is_vertical(line):\n                return None\n            return (line[3] - line[1]) / (line[2] - line[0])\n        \n        def get_y_intercept(line: Tuple[int, int, int, int]) -> Union[float, None]:\n            if is_vertical(line):\n                return None\n            return line[1] - get_slope(line) * line[0]\n        \n        def is_parallel(line1: Tuple[int, int, int, int], line2: Tuple[int, int, int, int]) -> bool:\n            return get_slope(line1) == get_slope(line2)\n        \n        def get_intersect_point(line1: Tuple[int, int, int, int], line2: Tuple[int, int, int, int]) -> Tuple[int, int]:\n            if is_vertical(line1):\n                return line1[0], line2[1] - get_slope(line2) * (line1[0] - line2[0])\n            elif is_vertical(line2):\n                return line2[0], line1[1] - get_slope(line1) * (line2[0] - line1[0])\n            else:\n                return (line1[0] * get_slope(line2) - line2[0] * get_slope(line1)) / (get_slope(line2) - get_slope(line1)), \\\n                       (line1[1] * get_slope(line2) - line2[1] * get_slope(line1)) / (get_slope(line2) - get_slope(line1))\n\n        intersect_points = set()\n        for i in range(len(lines)):\n            for j in range(i + 1, len(lines)):\n                line1, line2 = lines[i], lines[j]\n                if is_parallel(line1, line2):\n                    continue\n                \n                intersect_point = get_intersect_point(line1, line2)\n                intersect_points.add(intersect_point)\n        \n        return intersect_points\n\n    n = int(stdin.readline())\n    lines = []\n    for _ in range(n):\n        x0, y0, x1, y1 = map(int, stdin.readline().split())\n        lines.append((x0, y0, x1, y1))\n    \n    intersect_points = get_intersect_points(lines)\n    return str(len(intersect_points)) if len(intersect_points) != float('inf') else '-1'\n\ninputs = [\n    \"3\\n1 3 9 5\\n2 2 6 8\\n4 8 9 3\\n\",\n    \"3\\n5 2 7 10\\n7 4 4 10\\n2 4 10 8\\n\",\n    \"3\\n2 1 6 5\\n2 5 5 4\\n5 1 7 7\\n\",\n    \"2\\n-1 -2 -1 -1\\n-1 2 -1 -1\\n\"\n]\n\nfor input_str in inputs:\n    print(solution(input_str)) "
    },
    {
        "number": 3010,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    segments = []\n    for i in range(1, n + 1):\n        x0, y0, x1, y1 = map(int, lines[i].split())\n        segments.append(((x0, y0), (x1, y1)))\n    \n    points = set()\n    for segment in segments:\n        (x0, y0), (x1, y1) = segment\n        if x0 == x1:\n            step = 1 if y0 < y1 else -1\n            for y in range(y0, y1 + step, step):\n                points.add((x0, y))\n        elif y0 == y1:\n            step = 1 if x0 < x1 else -1\n            for x in range(x0, x1 + step, step):\n                points.add((x, y0))\n        else:\n            dx = x1 - x0\n            dy = y1 - y0\n            g = abs(dy) - abs(dx)\n            if g < 0:\n                step_x = 1 if x0 < x1 else -1\n                step_y = 1 if y0 < y1 else -1\n                x = x0\n                y = y0\n                points.add((x, y))\n                for i in range(abs(dx)):\n                    x += step_x\n                    y += step_y\n                    points.add((x, y))\n            else:\n                step_x = 1 if x0 < x1 else -1\n                step_y = 1 if y0 < y1 else -1\n                x = x0\n                y = y0\n                points.add((x, y))\n                for i in range(abs(dy)):\n                    x += step_x\n                    y += step_y\n                    points.add((x, y))\n                \n    return str(len(points)) if len(points) != float('inf') else '-1'"
    },
    {
        "number": 3010,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    lines = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    \n    points = set()\n    \n    for line in lines:\n        x0, y0, x1, y1 = line\n        slope = (y1 - y0) / (x1 - x0)\n        intercept = y0 - slope * x0\n        \n        if slope != 0:\n            x_intercept = (0 - intercept) / slope\n            y_intercept = 0\n            points.add((x_intercept, y_intercept))\n        if slope != float('inf'):\n            x_intercept = 1000000\n            y_intercept = slope * 1000000 + intercept\n            points.add((x_intercept, y_intercept))\n        if slope != -float('inf'):\n            x_intercept = -1000000\n            y_intercept = slope * (-1000000) + intercept\n            points.add((x_intercept, y_intercept))\n        if slope != 0:\n            x_intercept = 1000000\n            y_intercept = slope * 1000000 + intercept\n            points.add((x_intercept, y_intercept))\n        if x0 != x1:\n            slope = (y1 - y0) / (x1 - x0)\n            intercept = y0 - slope * x0\n            x_intercept = (y_intercept - intercept) / slope\n            y_intercept = y_intercept\n            points.add((x_intercept, y_intercept))\n        if y0 != y1:\n            slope = (y1 - y0) / (x1 - x0)\n            intercept = y0 - slope * x0\n            x_intercept = (y_intercept - intercept) / slope\n            y_intercept = y_intercept\n            points.add((x_intercept, y_intercept))\n    \n    return str(len(points) - 1)"
    },
    {
        "number": 3010,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    points = set()\n    \n    for line in lines[1:]:\n        x0, y0, x1, y1 = map(int, line.split())\n        points.add((x0, y0))\n        points.add((x1, y1))\n        \n    return str(len(points)) if len(points) != len(lines[1:]) else \"-1\""
    },
    {
        "number": 3010,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lines = stdin.split('\\n')[1:]\n    points = set()\n    for line in lines:\n        x0, y0, x1, y1 = map(int, line.split())\n        # Calculate the slope of the line\n        slope = (y1 - y0) / (x1 - x0)\n        # Calculate the y-intercept of the line\n        intercept = y0 - slope * x0\n        \n        # Add all the points on the line to the set of points\n        for x in range(min(x0, x1), max(x0, x1) + 1):\n            y = slope * x + intercept\n            points.add((x, int(y)))\n    \n    # Calculate the number of distinct points\n    num_distinct_points = len(points)\n    \n    # Check if there are infinitely many such points\n    if num_distinct_points == 0:\n        return -1\n    \n    return str(num_distinct_points)"
    },
    {
        "number": 3010,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    lines = lines[1:]\n    \n    def is_intersect(p1, p2, p3, p4) -> bool:\n        def ccw(a, b, c):\n            return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])\n        return ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 and ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            x1, y1, x2, y2 = tuple(map(int, lines[i].split()))\n            x3, y3, x4, y4 = tuple(map(int, lines[j].split()))\n            if is_intersect((x1, y1), (x2, y2), (x3, y3), (x4, y4)):\n                count += 1\n    \n    return str(count)"
    },
    {
        "number": 3010,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    lines = lines[1:]\n    points = set()\n    \n    for line in lines:\n        x0, y0, x1, y1 = map(int, line.split())\n        if x0 == x1:\n            for i in range(min(y0, y1), max(y0, y1) + 1):\n                points.add((x0, i))\n        elif y0 == y1:\n            for i in range(min(x0, x1), max(x0, x1) + 1):\n                points.add((i, y0))\n        else:\n            m = (y1 - y0) / (x1 - x0)\n            b = y0 - m * x0\n            x = lambda y: (y - b) / m\n            for i in range(min(y0, y1), max(y0, y1) + 1):\n                points.add((int(x(i)), i))\n    \n    return str(len(points))"
    },
    {
        "number": 3010,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_intersections(lines):\n        intersections = set()\n        for i in range(len(lines)):\n            for j in range(i + 1, len(lines)):\n                inter = get_intersection(lines[i], lines[j])\n                if inter:\n                    intersections.add(inter)\n        return intersections\n\n    def get_intersection(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if denom == 0:\n            return None\n        x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom\n        y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom\n        return round(x), round(y)\n\n    lines = []\n    for line in stdin.split('\\n')[1:]:\n        x0, y0, x1, y1 = map(int, line.split())\n        lines.append((x0, y0, x1, y1))\n\n    intersections = get_intersections(lines)\n    if len(intersections) == 0:\n        return \"-1\"\n    return str(len(intersections))"
    },
    {
        "number": 3011,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        num = str(i)\n        hill = True\n        rise = True\n        for j in range(len(num) - 1):\n            if num[j] < num[j + 1]:\n                hill = False\n                break\n            elif num[j] > num[j + 1]:\n                rise = False\n        if hill and rise:\n            count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_numbers = []\n    current_hill = []\n    current_digit = None\n\n    for digit in str(n):\n        digit = int(digit)\n\n        if current_digit is None:\n            current_digit = digit\n            current_hill.append(digit)\n            continue\n\n        if digit > current_digit:\n            while current_hill and current_hill[-1] >= digit:\n                current_hill.pop()\n\n            if not current_hill:\n                break\n\n            current_hill.append(digit)\n            current_digit = digit\n\n        elif digit < current_digit:\n            while current_hill and current_hill[-1] <= digit:\n                current_hill.pop()\n\n            if not current_hill:\n                break\n\n            current_hill.append(digit)\n            current_digit = digit\n\n        else:\n            current_hill.append(digit)\n            current_digit = digit\n\n    if current_hill == [] or current_hill[-1] != current_digit:\n        return \"-1\"\n\n    hill_numbers.append(\"\".join(map(str, current_hill)))\n\n    while current_hill:\n        current_digit = current_hill[-1]\n        for digit in range(current_digit - 1, -1, -1):\n            if current_hill[-1] == digit:\n                hill_numbers.append(\"\".join(map(str, current_hill + [digit])))\n            else:\n                break\n        current_hill.pop()\n\n    return str(len(hill_numbers))\n"
    },
    {
        "number": 3011,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_numbers = []\n    current_number = 1\n    current_hill = True\n\n    while current_number <= n:\n        if current_hill:\n            hill_numbers.append(current_number)\n        current_number += 1\n\n        if current_hill:\n            if current_number > n // 2:\n                current_hill = False\n            else:\n                current_hill = current_number <= n // 2\n        else:\n            if current_number > n // 2:\n                current_hill = True\n            else:\n                current_hill = current_number <= n // 2\n\n    return str(len(hill_numbers)) if n in hill_numbers else \"-1\"\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_count = 0\n    \n    def is_hill(num: int) -> bool:\n        digits = [int(d) for d in str(num)]\n        increasing = decreasing = True\n        for i in range(1, len(digits)):\n            if digits[i] < digits[i - 1]:\n                decreasing = False\n            if digits[i] > digits[i - 1]:\n                increasing = False\n            if not increasing and not decreasing:\n                return False\n        return True\n    \n    for i in range(1, n + 1):\n        if is_hill(i):\n            hill_count += 1\n    \n    return str(hill_count) if hill_count > 0 else \"-1\""
    },
    {
        "number": 3011,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_numbers = 0\n    current_digit = None\n\n    for digit in str(n):\n        if current_digit is None:\n            current_digit = int(digit)\n        else:\n            if int(digit) < current_digit:\n                hill_numbers += 1\n            current_digit = int(digit)\n\n    if hill_numbers > 0:\n        return str(hill_numbers * (hill_numbers + 1) // 2)\n    else:\n        return \"-1\"\n\ninput_str = input()\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 3011,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_numbers = 0\n    for i in range(1, n+1):\n        digits = [int(d) for d in str(i)]\n        if all(digits[j] >= digits[j-1] for j in range(1, len(digits))) or all(digits[j] <= digits[j-1] for j in range(1, len(digits))):\n            hill_numbers += 1\n    return str(hill_numbers)"
    },
    {
        "number": 3011,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_numbers = []\n    for i in range(1, n + 1):\n        digits = [int(d) for d in str(i)]\n        if digits == sorted(digits) or digits == sorted(digits, reverse=True):\n            hill_numbers.append(i)\n    return str(len(hill_numbers))\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    hill_count = 10\n    while hill_count <= n:\n        next_num = hill_numbers[-1] + 1\n        if next_num > 9:\n            break\n        hill_numbers.append(next_num)\n        hill_count += 1\n\n    for i in range(len(hill_numbers)):\n        current_num = hill_numbers[i]\n        for j in range(i + 1, len(hill_numbers)):\n            next_num = hill_numbers[j]\n            if next_num < current_num:\n                break\n            elif next_num > current_num:\n                current_num = next_num\n            else:\n                current_num = next_num\n        hill_numbers[i] = current_num\n\n    hill_numbers = set(hill_numbers)\n    if n in hill_numbers:\n        return str(len(hill_numbers))\n    else:\n        return \"-1\""
    },
    {
        "number": 3011,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    is_hill_number = False\n\n    for i in range(1, n + 1):\n        is_hill_number_temp = True\n        s = str(i)\n\n        for j in range(len(s) - 1):\n            if s[j] > s[j + 1]:\n                is_hill_number_temp = False\n                break\n\n        if is_hill_number_temp and i <= n:\n            count += 1\n            is_hill_number = True\n\n    if is_hill_number:\n        return str(count)\n    else:\n        return str(-1)\n"
    },
    {
        "number": 3011,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_numbers = 0\n    current_num = 1\n    current_digit = 1\n    while current_num <= n:\n        if current_digit == 1:\n            current_num = current_num * 10 + 1\n            hill_numbers += 1\n            current_digit += 1\n        elif current_digit == current_num:\n            current_num = current_num * 10 + current_digit - 1\n            hill_numbers += 1\n            current_digit += 1\n        else:\n            current_num = current_num * 10 + current_digit - 1\n            hill_numbers += 1\n            current_digit -= 1\n    \n    if current_num > n:\n        hill_numbers -= 1\n    \n    return str(hill_numbers) if current_num == n else \"-1\""
    },
    {
        "number": 3012,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    if a11 + a12 + a21 + a22 > 5000:\n        raise ValueError(\"Too many players in the team\")\n    if N > 10**18:\n        raise ValueError(\"Too large sequence length\")\n\n    MOD = 1000000007\n    total = 0\n\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % MOD\n        return result\n\n    def comb(n: int, k: int) -> int:\n        if n < k:\n            return 0\n        return factorial(n) * pow(factorial(k), MOD - 2, MOD) * pow(factorial(n - k), MOD - 2, MOD) % MOD\n\n    for i in range(a11 + a12):\n        for j in range(a21 + a22):\n            for k in range(a11 + a12 - i):\n                for l in range(a21 + a22 - j):\n                    for m in range(a11 + a12 - i - k):\n                        for n in range(a21 + a22 - j - l):\n                            for o in range(a11 + a12 - i - k - m):\n                                for p in range(a21 + a22 - j - l - n):\n                                    if i + k + m == a11 and j + l + n + o + p == a22:\n                                        total += comb(i + k + m + j + l + n + o + p, N)\n                                        total %= MOD\n\n    return str(total)"
    },
    {
        "number": 3012,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a_11, a_12, a_21, a_22, N = map(int, stdin.split())\n    MOD = 1000000007\n\n    # Calculate the number of valid sequences for each combination of attack and defense tricks\n    num_seqs = {}\n    for atk_trick in range(1, 3):\n        for def_trick in range(1, 3):\n            num_players = a_11 if atk_trick == 1 else a_12\n            num_players += a_21 if def_trick == 2 else a_22\n            if num_players == 0:\n                continue\n\n            num_seq = 0\n            for num_attackers in range(1, num_players + 1):\n                if num_attackers == 1:\n                    num_seq += 1\n                elif num_attackers == 2:\n                    num_seq += num_players - 1\n                else:\n                    num_seq += num_players - 1 - (num_attackers - 2)\n            num_seqs[(atk_trick, def_trick)] = num_seq\n\n    # Calculate the number of valid sequences for each attacker and defender combination\n    num_valid_seqs = {}\n    for attacker in range(1, a_11 + a_12 + 1):\n        for defender in range(1, a_21 + a_22 + 1):\n            for num_attackers in range(1, attacker + 1):\n                for num_defenders in range(1, defender + 1):\n                    num_valid = 0\n                    for atk_trick, def_trick in num_seqs.keys():\n                        num_valid += num_seqs[(atk_trick, def_trick)]\n                        num_valid %= MOD\n                    num_valid_seqs[(attacker, defender, num_attackers, num_defenders)] = num_valid\n\n    # Calculate the number of valid sequences for each length N\n    num_sequences = 0\n    for num_attackers, num_defenders, attacker, defender in num_valid_seqs.keys():\n        if num_attackers == N:\n            num_sequences += num_valid_seqs[(num_attackers, num_defenders, attacker, defender)]\n            num_sequences %= MOD\n\n    return str(num_sequences)\n"
    },
    {
        "number": 3012,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    # Helper function to calculate the number of possible moves with a given attacker and defender\n    def count_moves(attacker, defender):\n        if attacker == 0 or defender == 0:\n            return 0\n        if attacker == 1 and defender == 1:\n            return (N - 1) * (N - 2)\n        if attacker == 1 and defender == 2:\n            return N * (N - 1)\n        if attacker == 2 and defender == 1:\n            return N * (N - 1)\n        if attacker == 2 and defender == 2:\n            return N * (N - 1)\n\n    # Calculate the number of possible moves for each combination of attacker and defender\n    moves = [[0] * 4 for _ in range(4)]\n    for attacker in range(1, 3):\n        for defender in range(1, 3):\n            moves[attacker][defender] = count_moves(a11 + a12 - attacker, a21 + a22 - defender)\n\n    # Calculate the number of possible sequences of moves\n    result = 1\n    for i in range(N):\n        result = (result * (moves[1][2] + moves[2][1])) % 1000000007\n\n    return str(result)"
    },
    {
        "number": 3012,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    \n    # If there are no players who can perform or defend against the given skills, there are no valid sequences\n    if a11 == 0 or a12 == 0 or a21 == 0 or a22 == 0:\n        return str(0)\n    \n    # Calculate the number of possible sequences\n    MOD = 1000000007\n    sequences = 1\n    for i in range(2, N + 1):\n        sequences = (sequences * (a11 * a12 + a21 * a22)) % MOD\n    \n    return str(sequences)"
    },
    {
        "number": 3012,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    if N > 10**18:\n        return str(0)\n\n    mod = 1000000007\n    dp = [[0] * 5 for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(N):\n        for j in range(5):\n            for k in range(5):\n                dp[i + 1][j] += dp[i][k]\n                dp[i + 1][j] %= mod\n\n    result = 0\n    for i in range(5):\n        for j in range(5):\n            if i == 0 or j == 0:\n                continue\n            if (i + j) % 3 == 0:\n                result += dp[N][i] * dp[N][j]\n                result %= mod\n\n    return str(result)"
    },
    {
        "number": 3012,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    MOD = 1000000007\n\n    # Calculate the number of players for each skill\n    players = [0] * 4\n    players[0] = a11 + a21\n    players[1] = a12 + a22\n    players[2] = players[0] + players[1]\n    players[3] = players[2] + 1\n\n    # Calculate the number of valid sequences for each length\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(N):\n        # Calculate the number of players who can perform each trick\n        attacks = [0] * 2\n        attacks[0] = players[0]\n        attacks[1] = players[1]\n\n        # Calculate the number of players who can defend against each trick\n        defends = [0] * 2\n        defends[0] = players[2] - players[0]\n        defends[1] = players[2] - players[1]\n\n        # Calculate the number of valid sequences for this length\n        if i >= 2 and attacks[0] >= 2 and attacks[1] >= 2:\n            # The third consecutive attack\n            dp[i] = (dp[i - 2] * defends[0] * defends[1]) % MOD\n        elif attacks[0] >= 1 and attacks[1] >= 1:\n            # The second consecutive attack\n            dp[i] = (dp[i - 1] * defends[0] * defends[1]) % MOD\n        else:\n            # The first attack\n            dp[i] = (dp[i - 1] * attacks[0] * defends[0] + dp[i - 1] * attacks[1] * defends[1]) % MOD\n\n    return str(dp[N])"
    },
    {
        "number": 3012,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    # Calculate the number of players for each skill\n    players = [0] * 4\n    players[0] = a11 + a12\n    players[1] = a11 + a21\n    players[2] = a12 + a22\n    players[3] = a21 + a22\n\n    # Check if there are not enough players for each skill\n    if any(n <= 0 for n in players):\n        return \"0\"\n\n    # Calculate the number of possible moves for each player\n    moves = [0] * 4\n    moves[0] = players[0] * players[1]\n    moves[1] = players[0] * players[2]\n    moves[2] = players[1] * players[3]\n    moves[3] = players[2] * players[3]\n\n    # Calculate the number of possible sequences of moves\n    total_moves = 1\n    for i in range(N):\n        if i % 3 == 0:\n            total_moves *= sum(moves)\n        else:\n            total_moves *= sum(moves[1:])\n            moves = moves[1:]\n\n    # Calculate the modulo\n    return str(total_moves % 1000000007)"
    },
    {
        "number": 3012,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    players = []\n    if a11 + a22 >= 1:\n        players.append(1)\n    if a12 + a21 >= 1:\n        players.append(2)\n\n    def generate_moves(current_move: Tuple[int, int], rest_moves: int) -> int:\n        attacker, defender = current_move\n        if rest_moves == 0:\n            return 1\n\n        moves = 0\n        for i in players:\n            if i == attacker:\n                continue\n            for j in players:\n                if i == j:\n                    continue\n                moves += generate_moves((i, j), rest_moves - 1)\n        return moves\n\n    result = generate_moves((1, 2), N)\n    return str(result % 1000000007)"
    },
    {
        "number": 3012,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    if N == 1:\n        return 1\n    elif N == 2:\n        return (a11 * a22 + a12 * a21) % 1000000007\n    elif N == 3:\n        return (a11 * a12 * a21 + a11 * a22 * a21 + a12 * a21 * a22) % 1000000007\n    else:\n        if a11 == 0:\n            a11 = 1\n        if a12 == 0:\n            a12 = 1\n        if a21 == 0:\n            a21 = 1\n        if a22 == 0:\n            a22 = 1\n        return (pow(a11 * a12 * a21 + a11 * a22 * a21 + a12 * a21 * a22, N - 2, 1000000007) % 1000000007) "
    },
    {
        "number": 3012,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    # Create a matrix to store the number of players that can perform each skill\n    matrix = [[0] * (a11 + a12 + a21 + a22) for _ in range(2)]\n    matrix[0][:a11] = [1] * a11\n    matrix[1][a11:a11 + a12] = [1] * a12\n    matrix[0][a11 + a12:a11 + a12 + a21] = [1] * a21\n    matrix[1][a11 + a12 + a21:a11 + a12 + a21 + a22] = [1] * a22\n\n    # Helper function to calculate the number of ways to choose k elements from a list\n    def choose(n: int, k: int) -> int:\n        return 1 if k == 0 else (1 if n == k else choose(n - 1, k - 1) + choose(n - 1, k))\n\n    # Calculate the total number of ways to choose each player\n    total_ways = choose(a11 + a12 + a21 + a22, N)\n\n    # Calculate the number of ways to choose each type of player for each skill\n    attack_ways = [sum(matrix[0][:a11]) - 1, sum(matrix[0][a11:a11 + a12]) - 1, sum(matrix[1][a11 + a12:a11 + a12 + a21]) - 1, sum(matrix[1][a11 + a12 + a21:]) - 1]\n    defend_ways = [sum(matrix[1][:a11]) - 1, sum(matrix[0][:a11]) - 1, sum(matrix[1][a11:a11 + a12]) - 1, sum(matrix[0][a11:a11 + a12]) - 1]\n\n    # Initialize the count of valid sequences\n    count = 0\n\n    # Iterate through each possible combination of players for each skill\n    for a1 in range(a11 + a12):\n        for d1 in range(a11 + a12):\n            for a2 in range(a21 + a22):\n                for d2 in range(a21 + a22):\n                    # Check if the current combination is valid\n                    if a1 != d1 and a2 != d2:\n                        # Calculate the number of ways to choose the remaining players\n                        remaining_ways = total_ways - attack_ways[0] - defend_ways[0] - attack_ways[1] - defend_ways[1] - attack_ways[2] - defend_ways[2] - attack_ways[3] - defend_ways[3]\n\n                        # Calculate the number of ways to choose the remaining attackers\n                        remaining_attack_ways = sum(attack_ways[1:]) - attack_ways[a1 % 2] - attack_ways[(a2 + a1) % 2]\n\n                        # Calculate the number of ways to choose the remaining defenders\n                        remaining_defend_ways = sum(defend_ways[1:]) - defend_ways[d1 % 2] - defend_ways[(d2 + d1) % 2]\n\n                        # Calculate the number of ways to choose the remaining attack-defend pairs\n                        attack_defend_ways = min(remaining_attack_ways, remaining_defend_ways)\n\n                        # Calculate the number of ways to choose the remaining players\n                        remaining_ways = remaining_ways - (attack_ways[0] + defend_ways[0] + attack_ways[1] + defend_ways[1] + attack_ways[2] + defend_ways[2] + attack_ways[3] + defend_ways[3])\n\n                        # Calculate the number of ways to choose the remaining pairs\n                        pair_ways = min(remaining_attack_ways, remaining_defend_ways - attack_defend_ways)\n\n                "
    },
    {
        "number": 3013,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    w = 2 * pi * b\n\n    # Compute angle at which avatar leaves spiral\n    theta = atan2(ty, tx)\n    dist = hypot(tx, ty)\n    r = dist / theta\n    phi = w * theta\n    spiral_x = b * phi * cos(phi)\n    spiral_y = b * phi * sin(phi)\n    avatar_x = spiral_x + b * phi * cos(phi + w)\n    avatar_y = spiral_y + b * phi * sin(phi + w)\n    detach_x = (avatar_x - tx) / (avatar_x - spiral_x) * tx + (avatar_y - ty) / (avatar_y - spiral_y) * ty\n    detach_y = (avatar_x - tx) / (avatar_x - spiral_x) * ty + (avatar_y - ty) / (avatar_y - spiral_y) * tx\n\n    return f\"{detach_x:.5f} {detach_y:.5f}\""
    },
    {
        "number": 3013,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    x = 0\n    y = 0\n    radius = 0\n    angle = 0\n    while (tx - x)**2 + (ty - y)**2 > radius**2:\n        x = b * angle * math.cos(angle)\n        y = b * angle * math.sin(angle)\n        radius = math.sqrt(x**2 + y**2)\n        angle += 0.01\n    return f\"{x:.5f} {y:.5f}\""
    },
    {
        "number": 3013,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    distance = math.sqrt(tx**2 + ty**2)\n    target_angle = math.atan2(ty, tx)\n    spiral_angle = lambda r: r * b\n    def spiral_position(r):\n        return r * math.cos(spiral_angle(r)), r * math.sin(spiral_angle(r))\n    \n    def distance_to_spiral(r, x, y):\n        spiral_x, spiral_y = spiral_position(r)\n        return math.sqrt((x - spiral_x)**2 + (y - spiral_y)**2)\n    \n    r = 0.0\n    while distance_to_spiral(r, tx, ty) < 1e-3:\n        r += 1e-4\n    \n    def spiral_x_intersection(r, x, y):\n        spiral_x, spiral_y = spiral_position(r)\n        slope = (y - spiral_y) / (x - spiral_x)\n        return (x - spiral_x) / (1 + slope**2)\n    \n    def spiral_y_intersection(r, x, y):\n        spiral_x, spiral_y = spiral_position(r)\n        slope = (y - spiral_y) / (x - spiral_x)\n        return (y - spiral_y) / (1 + slope**2) + slope * (x - spiral_x) / (1 + slope**2)\n    \n    def intersection_point(r, x, y):\n        return spiral_x_intersection(r, x, y), spiral_y_intersection(r, x, y)\n    \n    def point_on_spiral(r, angle):\n        spiral_x, spiral_y = spiral_position(r)\n        return spiral_x + math.cos(angle) * r, spiral_y + math.sin(angle) * r\n    \n    min_distance = float('inf')\n    for angle in np.linspace(target_angle - math.pi, target_angle + math.pi, 360):\n        x, y = point_on_spiral(r, angle)\n        distance = math.sqrt((tx - x)**2 + (ty - y)**2)\n        if distance < min_distance:\n            min_distance = distance\n            min_x, min_y = x, y\n    \n    return f'{min_x:.5f} {min_y:.5f}'"
    },
    {
        "number": 3013,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    target_x, target_y = tx, ty\n    theta = 0\n    r = b * theta\n    x, y = r * math.cos(theta), r * math.sin(theta)\n    \n    while abs(x - target_x) + abs(y - target_y) > 10**-3:\n        theta += 0.001\n        r = b * theta\n        x, y = r * math.cos(theta), r * math.sin(theta)\n        \n    return f\"{x:.5f} {y:.5f}\"\n\nstdin = input()\noutput = solution(stdin)\nprint(output) "
    },
    {
        "number": 3013,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    r = b * 2 * pi\n    target_distance = sqrt(tx**2 + ty**2)\n    if target_distance <= 2 * pi * b:\n        return \"0.0 0.0\"\n    theta = asin(tx / target_distance)\n    distance = target_distance - r * theta\n    if distance <= r:\n        return \"0.0 0.0\"\n    if ty >= 0:\n        x = sqrt(distance**2 - (target_distance - ty)**2)\n        y = target_distance - ty\n    else:\n        x = -sqrt(distance**2 - (target_distance + ty)**2)\n        y = target_distance + ty\n    return f\"{x:.5f} {y:.5f}\"\n\ndef"
    },
    {
        "number": 3013,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = list(map(float, stdin.split()))\n    target = complex(tx, ty)\n\n    theta = 0\n    r = 0\n    spiral_point = complex(0, 0)\n\n    while True:\n        spiral_point = complex(r * math.cos(theta), r * math.sin(theta))\n        if abs(spiral_point - target) < 1e-3:\n            break\n\n        theta += 0.01\n        r = b * theta\n\n    x, y = spiral_point.real, spiral_point.imag\n    return f\"{x:.5f} {y:.5f}\""
    },
    {
        "number": 3013,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    r = b * 360  # length of one revolution\n    R = (tx ** 2 + ty ** 2) ** 0.5  # distance from target to origin\n    theta = math.atan2(ty, tx)  # angle between target and x-axis\n    \n    # If the target is in the first quadrant, we need to leave the spiral at the correct angle, \n    # so that it reaches the target in one full rotation. If the target is in the second or third \n    # quadrant, we need to leave the spiral at the angle that is between 0 and 360 degrees \n    # that is closest to the target angle.\n    if 0 <= theta < math.pi:\n        phi = theta + r\n    else:\n        phi = r - theta if theta < 0 else 2 * math.pi - theta\n    \n    # Compute the position of the point where the avatar should leave the spiral.\n    x = R * math.cos(phi)\n    y = R * math.sin(phi)\n    \n    return f\"{x:.5f} {y:.5f}\""
    },
    {
        "number": 3013,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    target = complex(tx, ty)\n    min_dist = float('inf')\n    min_point = None\n    \n    for phi in range(1000):\n        r = b * phi\n        point = complex(r * cos(phi), r * sin(phi))\n        dist = abs(point - target)\n        if dist < min_dist:\n            min_dist = dist\n            min_point = point\n            \n    return f\"{min_point.real:.5f} {min_point.imag:.5f}\""
    },
    {
        "number": 3013,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def polar_to_cartesian(r, phi):\n        return r * cos(phi), r * sin(phi)\n\n    def cartesian_to_polar(x, y):\n        return sqrt(x**2 + y**2), atan2(y, x)\n\n    def distance(x1, y1, x2, y2):\n        return sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    def spiral_point(b, phi):\n        return polar_to_cartesian(b * phi, phi)\n\n    def angle_to_target(spiral_x, spiral_y, target_x, target_y):\n        angle = atan2(target_y - spiral_y, target_x - spiral_x)\n        if angle < 0:\n            angle += 2 * pi\n        return angle\n\n    def search_point(b, target_x, target_y):\n        spiral_x, spiral_y = 0, 0\n        spiral_phi = 0\n        while distance(spiral_x, spiral_y, target_x, target_y) > 10**(-3):\n            spiral_phi += 0.001\n            spiral_x, spiral_y = spiral_point(b, spiral_phi)\n        return spiral_x, spiral_y\n\n    b, target_x, target_y = map(float, stdin.split())\n    spiral_x, spiral_y = search_point(b, target_x, target_y)\n    angle = angle_to_target(spiral_x, spiral_y, target_x, target_y)\n    release_x, release_y = spiral_point(b, angle)\n\n    return f\"{release_x:.5f} {release_y:.5f}\""
    },
    {
        "number": 3013,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n    \n    # Calculate the angle the avatar will need to travel to hit the target\n    angle = math.atan2(t_x, t_y)\n    \n    # Calculate the distance the avatar will need to travel to reach the target\n    distance = math.sqrt(t_x**2 + t_y**2)\n    \n    # Calculate the distance the avatar will need to travel to travel around the spiral\n    spiral_distance = 2 * math.pi * b\n    \n    # Calculate the number of full turns the avatar will need to make\n    turns = math.ceil(distance / spiral_distance)\n    \n    # Calculate the distance the avatar will need to travel to reach the target after making the necessary turns\n    remaining_distance = distance - turns * spiral_distance\n    \n    # Calculate the angle of the point on the spiral where the avatar should leave the spiral\n    spiral_angle = angle + turns * 2 * math.pi\n    \n    # Calculate the x and y coordinates of the point on the spiral where the avatar should leave the spiral\n    x = b * spiral_angle * math.cos(spiral_angle)\n    y = b * spiral_angle * math.sin(spiral_angle)\n    \n    # Calculate the distance between the point and the target\n    target_distance = math.sqrt((t_x - x)**2 + (t_y - y)**2)\n    \n    # Calculate the x and y coordinates of the point where the avatar should release the target\n    release_x = x + (t_x - x) / target_distance * (target_distance - 1)\n    release_y = y + (t_y - y) / target_distance * (target_distance - 1)\n    \n    return f\"{release_x:.5f} {release_y:.5f}\""
    },
    {
        "number": 3014,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    corridors = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:-1]]\n\n    # Create a graph representing the club\n    graph = {i: set() for i in range(1, n + 1)}\n    for u, v in corridors:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    # BFS to find connected components\n    def bfs(start):\n        visited, queue = set(), [start]\n        while queue:\n            current = queue.pop(0)\n            if current not in visited:\n                visited.add(current)\n                queue.extend(graph[current] - visited)\n        return visited\n\n    # Count connected components and determine the maximum number of corridors to be removed\n    connected_components = [bfs(i) for i in range(1, n + 1) if i not in {c for cs in connected_components[:-1] for c in cs}]\n    max_corridors_removed = (len(connected_components) - 1) // 2\n\n    # Choose the corridors to be removed\n    corridors_to_remove = set()\n    for i in range(len(connected_components) - 1):\n        component_1, component_2 = connected_components[i], connected_components[i + 1]\n        for u in component_1:\n            for v in component_2:\n                if (u, v) in corridors:\n                    corridors_to_remove.add((u, v))\n                    break\n        if len(corridors_to_remove) == max_corridors_removed:\n            break\n\n    # Print the result\n    result = [max_corridors_removed] + sorted([cor[0] * m + cor[1] for cor in corridors_to_remove])\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3014,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    corridors = [[] for _ in range(n)]\n\n    for _ in range(m):\n        u, v = map(int, input().split())\n        corridors[u - 1].append(v - 1)\n        corridors[v - 1].append(u - 1)\n\n    def dfs(start: int, visited: set, component: set) -> set:\n        visited.add(start)\n        component.add(start)\n        for neighbor in corridors[start]:\n            if neighbor not in visited:\n                component = component.union(dfs(neighbor, visited, component))\n        return component\n\n    removed = 0\n    to_remove = []\n    for i in range(n):\n        if i not in to_remove:\n            visited = set()\n            component = dfs(i, visited, set())\n            if len(component) > 1:\n                to_remove.extend(component)\n                removed += 1\n                if removed >= m // 2:\n                    break\n\n    return str(removed) + \"\\n\" + \"\\n\".join(map(str, to_remove))\n\ninput_string = \"\"\nn, m = map(int, input_string.split())\ninput_string = input_string.strip()\n\noutput = solution(input_string)\nprint(output) "
    },
    {
        "number": 3014,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    rooms = [[] for _ in range(n)]\n    for i in range(1, m + 1):\n        u, v = map(int, lines[i].split())\n        rooms[u - 1].append(v - 1)\n        rooms[v - 1].append(u - 1)\n\n    def dfs(room, visited):\n        visited[room] = True\n        for neighbor in rooms[room]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n\n    def is_cycle(start):\n        visited = [False] * n\n        dfs(start, visited)\n        return any(visited)\n\n    removed_corridors = 0\n    removed_corridor_indices = []\n    for i in range(m):\n        if not is_cycle(i):\n            removed_corridors += 1\n            removed_corridor_indices.append(i + 1)\n        if removed_corridors >= m // 2:\n            break\n\n    result = [str(removed_corridors)] + [str(x) for x in removed_corridor_indices]\n    return \"\\n\".join(result)"
    },
    {
        "number": 3014,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, corridors = stdin.split()\n    n = int(n)\n    m = int(m)\n    adj_list = {i: set() for i in range(1, n+1)}\n    \n    for i in range(m):\n        u, v = map(int, input().split())\n        adj_list[u].add(v)\n        adj_list[v].add(u)\n    \n    removed = 0\n    result = []\n    \n    for i in range(1, n+1):\n        visited = set()\n        cycle_corridors = []\n        \n        def dfs(node, parent):\n            visited.add(node)\n            nonlocal removed\n            \n            for neighbor in adj_list[node]:\n                if neighbor == parent:\n                    continue\n                \n                if neighbor not in visited:\n                    if dfs(neighbor, node):\n                        cycle_corridors.append((node, neighbor))\n                        removed += 1\n                        return True\n                elif neighbor in cycle_corridors:\n                    cycle_corridors.append((node, neighbor))\n                    return True\n                \n            return False\n        \n        for neighbor in adj_list[i]:\n            if neighbor not in visited:\n                if dfs(neighbor, i):\n                    result.extend(cycle_corridors)\n                    break\n        \n        if removed >= m // 2:\n            break\n    \n    print(removed)\n    for corridor in result:\n        print(*corridor)"
    },
    {
        "number": 3014,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    corridors = [[] for _ in range(n+1)]\n    \n    for i in range(m):\n        u, v = map(int, stdin.split())\n        corridors[u].append(v)\n        corridors[v].append(u)\n    \n    def dfs(room, visited, path):\n        visited[room] = True\n        path.append(room)\n        \n        for neighbor in corridors[room]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, path)\n                \n        path.pop()\n    \n    count = 0\n    for i in range(1, n+1):\n        visited = [False] * (n+1)\n        path = []\n        dfs(i, visited, path)\n        count += len(path) - 1\n    \n    return str(m//2 - count//2) + \"\\n\" + \"\\n\".join(str(i) for i in range(1, m+1) if i not in path[:len(path)//2])"
    },
    {
        "number": 3014,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_rooms, num_corridors = map(int, stdin.split())\n\n    # Create adjacency list of rooms\n    rooms = [[] for _ in range(num_rooms + 1)]\n    for _ in range(num_corridors):\n        u, v = map(int, input().split())\n        rooms[u].append(v)\n        rooms[v].append(u)\n\n    # Create a DSU (Disjoint Set Union) structure\n    dsu = [-1] * (num_rooms + 1)\n\n    # Helper function to find the parent of a node\n    def find(x: int) -> int:\n        if dsu[x] < 0:\n            return x\n        dsu[x] = find(dsu[x])\n        return dsu[x]\n\n    # Helper function to merge two nodes\n    def merge(x: int, y: int) -> None:\n        x, y = find(x), find(y)\n        if x == y:\n            return\n        if dsu[x] > dsu[y]:\n            x, y = y, x\n        dsu[x] += dsu[y]\n        dsu[y] = x\n\n    # Helper function to count the number of cycles in the graph\n    def count_cycles(start: int) -> int:\n        count = 0\n        visited = [False] * (num_rooms + 1)\n        def dfs(node: int) -> None:\n            nonlocal count\n            visited[node] = True\n            for neighbor in rooms[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor)\n            visited[node] = False\n        dfs(start)\n        return count\n\n    # Helper function to find cycles in the graph and remove them\n    def remove_cycles(start: int) -> None:\n        visited = [False] * (num_rooms + 1)\n        def dfs(node: int) -> None:\n            visited[node] = True\n            for neighbor in rooms[node]:\n                if not visited[neighbor]:\n                    merge(node, neighbor)\n                    dfs(neighbor)\n        dfs(start)\n\n    # Count the number of cycles and find the maximum number of cycles that can be removed\n    max_cycles = 0\n    for i in range(1, num_rooms + 1):\n        cycles = count_cycles(i)\n        if cycles > 0:\n            max_cycles += cycles\n    max_cycles //= 2\n\n    # Remove the cycles and count the number of removed corridors\n    removed_corridors = 0\n    for i in range(1, num_rooms + 1):\n        cycles = count_cycles(i)\n        if cycles > 0:\n            remove_cycles(i)\n            removed_corridors += cycles\n\n    # Print the number of removed corridors and the corridors to be removed\n    if removed_corridors > max_cycles:\n        removed_corridors = max_cycles\n    print(removed_corridors)\n    for i in range(1, num_rooms + 1):\n        cycles = count_cycles(i)\n        if cycles > 0:\n            remove_cycles(i)\n            if removed_corridors > 0:\n                print(i)\n                removed_corridors -= 1"
    },
    {
        "number": 3014,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    corridors = [[] for _ in range(n)]\n    removed = set()\n\n    for i in range(m):\n        u, v = map(int, input().split())\n        corridors[u - 1].append(v - 1)\n        corridors[v - 1].append(u - 1)\n\n    def dfs(start, visited, path):\n        visited[start] = True\n        path.append(start)\n\n        for neighbor in corridors[start]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, path)\n\n        path.pop()\n\n    count = 0\n\n    for i in range(n):\n        visited = [False] * n\n        path = []\n        dfs(i, visited, path)\n\n        for j in range(len(path)):\n            for k in range(j + 1, len(path)):\n                removed.add(tuple(sorted((path[j], path[k]))))\n                count += 1\n\n    if count > m // 2:\n        return \"0\\n\"\n\n    for i in range(1, m + 1):\n        if tuple(sorted((u, v))) not in removed:\n            removed.add(tuple(sorted((u, v))))\n            count += 1\n\n            if count == m // 2:\n                result = str(i) + \"\\n\"\n                for u, v in removed:\n                    result += str(u) + \" \" + str(v) + \"\\n\"\n                return result\n\n    return \"0\\n\"\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 3014,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split()]\n    corridors = []\n\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        corridors.append((min(u, v), max(u, v)))\n\n    def dfs(start, visited):\n        visited[start] = True\n        for corridor in corridors:\n            if not visited[corridor[1]] and corridor[0] == start:\n                dfs(corridor[1], visited)\n\n    cycles = 0\n    for i in range(1, n + 1):\n        visited = [False] * (n + 1)\n        dfs(i, visited)\n        cycles += sum(visited)\n\n    if cycles == 2:\n        return str(0)\n    elif cycles % 2 == 1:\n        return str(-1)\n    else:\n        removed_corridors = min(m, cycles // 2)\n        corridors_to_remove = []\n        for corridor in corridors:\n            if not corridor in corridors_to_remove:\n                corridors_to_remove.append(corridor)\n                removed_corridors -= 1\n                if removed_corridors == 0:\n                    break\n\n        return str(len(corridors_to_remove)) + '\\n' + '\\n'.join(str(x + 1) for x in corridors_to_remove)"
    },
    {
        "number": 3014,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    corridors = set()\n    \n    for _ in range(m):\n        u, v = map(int, input().split())\n        corridors.add((u, v))\n        \n    result = 0\n    removed_corridors = set()\n    \n    for corridor in corridors:\n        if (corridor[1], corridor[0]) not in corridors:\n            removed_corridors.add(corridor)\n            result += 1\n            \n            if result >= m // 2:\n                break\n                \n    return str(result) + \"\\n\" + \"\\n\".join(str(corridor[0]) for corridor in removed_corridors)"
    },
    {
        "number": 3014,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, int, List[Tuple[int, int]]]:\n        n, m = map(int, input().split())\n        corridors = [tuple(map(int, input().split())) for _ in range(m)]\n        return n, m, corridors\n\n    def find_cycles(n: int, m: int, corridors: List[Tuple[int, int]]) -> List[List[int]]:\n        cycles = []\n        visited = [False] * (n + 1)\n\n        def dfs(room: int, path: List[int]) -> None:\n            visited[room] = True\n            path.append(room)\n\n            for corridor in corridors:\n                if corridor[0] == room and not visited[corridor[1]]:\n                    dfs(corridor[1], path)\n\n            path.pop()\n\n        for room in range(1, n + 1):\n            if not visited[room]:\n                path = []\n                dfs(room, path)\n                cycles.append(path)\n\n        return cycles\n\n    def remove_corridors(n: int, m: int, corridors: List[Tuple[int, int]]) -> List[int]:\n        cycles = find_cycles(n, m, corridors)\n        removed_corridors = []\n\n        for cycle in cycles:\n            if len(cycle) <= len(corridors) // 2:\n                for i in range(len(cycle) - 1):\n                    removed_corridors.append(corridors.index((cycle[i], cycle[i + 1])) + 1)\n                    removed_corridors.append(corridors.index((cycle[i + 1], cycle[i])) + 1)\n\n        return removed_corridors\n\n    n, m, corridors = read_input()\n    removed_corridors = remove_corridors(n, m, corridors)\n\n    print(len(removed_corridors))\n    print(\"\\n\".join(map(str, removed_corridors)))"
    },
    {
        "number": 3015,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    stdin = stdin.split('\\n')[1:]\n    tubes = [list(map(int, line.split())) for line in stdin]\n    \n    # Initialize graph\n    graph = {i: [] for i in range(n)}\n    for a, b, w in tubes:\n        graph[a].append((b, w))\n        graph[b].append((a, w))\n    \n    # Helper function to calculate time\n    def time_to_reach(start, end, visited, parent):\n        if start == end:\n            return 0\n        if start in visited:\n            return float('inf')\n        visited.add(start)\n        time = float('inf')\n        for neighbor, weight in graph[start]:\n            if neighbor != parent:\n                time = min(time, weight + time_to_reach(neighbor, end, visited, start))\n        return time\n    \n    # Calculate time to reach bed\n    time = time_to_reach(s, t, set(), -1)\n    \n    return str(time) if time != float('inf') else 'infinity'"
    },
    {
        "number": 3015,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, m, s, t = map(int, lines[0].split())\n    graph = {i: [] for i in range(n)}\n    time = {(i, j): float('inf') for i in range(n) for j in range(n)}\n\n    for i in range(1, m + 1):\n        a, b, w = map(int, lines[i].split())\n        graph[a].append((b, w))\n        time[(a, b)] = w\n\n    def min_time(s: int, t: int) -> Union[float, str]:\n        visited = {s}\n        queue = [(s, 0)]\n        while queue:\n            node, total_time = queue.pop(0)\n            for next_node, next_time in graph[node]:\n                new_time = total_time + next_time\n                if next_node in visited:\n                    continue\n                if next_node == t:\n                    return new_time\n                visited.add(next_node)\n                queue.append((next_node, new_time))\n        return \"infinity\"\n\n    left_time = min_time(s, t)\n    if left_time == \"infinity\":\n        return \"infinity\"\n    right_time = min_time(t, s)\n    return left_time + right_time\n"
    },
    {
        "number": 3015,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split('\\n')\n    n, m, s, t = map(int, lines[0].split())\n    tubes = []\n    for i in range(1, m + 1):\n        a, b, w = map(int, lines[i].split())\n        tubes.append((a, b, w))\n    \n    # Initialize distances and prev_balls\n    distances = [float('inf')] * n\n    distances[s] = 0\n    prev_balls = [None] * n\n    visited = [False] * n\n    \n    # BFS to calculate the distances and prev_balls\n    def bfs():\n        queue = [s]\n        visited[s] = True\n        while queue:\n            ball = queue.pop(0)\n            for a, b, w in tubes:\n                if a == ball:\n                    if distances[a] + w < distances[b]:\n                        distances[b] = distances[a] + w\n                        prev_balls[b] = a\n                        if not visited[b]:\n                            queue.append(b)\n                            visited[b] = True\n    \n    bfs()\n    \n    # Calculate the time to reach the bed\n    time = 0\n    ball = s\n    while ball != t:\n        time += distances[ball]\n        ball = prev_balls[ball]\n    \n    if ball == t:\n        return str(time)\n    else:\n        return \"infinity\""
    },
    {
        "number": 3015,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    graph = [[] for _ in range(n)]\n    for a, b, w in tubes:\n        graph[a].append((b, w))\n    \n    def bfs(s, t):\n        queue = [(s, 0)]\n        visited = set()\n        while queue:\n            current, time = queue.pop(0)\n            if current == t:\n                return time\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor, weight in graph[current]:\n                queue.append((neighbor, time + weight))\n        return -1\n    \n    return \"infinity\" if bfs(s, t) == -1 else str(bfs(s, t))"
    },
    {
        "number": 3015,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = []\n\n    for _ in range(m):\n        a, b, w = map(int, stdin.split()[4:])\n        tubes.append((a, b, w))\n\n    def calculate_time(ball: int) -> int:\n        left_turn = True\n        time = 0\n        balls_visited = [False] * n\n\n        while not balls_visited[t]:\n            if left_turn:\n                next_ball = None\n                for a, b, w in tubes:\n                    if a == ball and not balls_visited[b]:\n                        next_ball = b\n                        time += w\n                        balls_visited[b] = True\n                        break\n                ball = next_ball\n            else:\n                next_ball = None\n                for a, b, w in tubes:\n                    if b == ball and not balls_visited[a]:\n                        next_ball = a\n                        time += w\n                        balls_visited[a] = True\n                        break\n                ball = next_ball\n            left_turn = not left_turn\n\n        return time\n\n    return str(calculate_time(s))"
    },
    {
        "number": 3015,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, m, s, t = map(int, lines[0].split())\n    tubes = [list(map(int, line.split())) for line in lines[1:]]\n    \n    # Initialize the graph\n    graph = {i: [] for i in range(n)}\n    for a, b, w in tubes:\n        graph[a].append((b, w))\n    \n    # Helper function to find the shortest path\n    def find_shortest_path(graph: dict, start: int, end: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, dist = queue.pop(0)\n            if node == end:\n                return dist\n            if node not in visited:\n                visited.add(node)\n                for neighbor, weight in graph[node]:\n                    queue.append((neighbor, dist + weight))\n        return -1\n    \n    # Calculate the shortest path for the left hemisphere\n    path_length = find_shortest_path(graph, s, t)\n    \n    if path_length == -1:\n        return \"infinity\"\n    else:\n        return str(path_length)"
    },
    {
        "number": 3015,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    if s == t:\n        return \"0\"\n    stdin = stdin.split(\"\\n\")[1:]\n    tubes = {}\n    for line in stdin:\n        a, b, w = map(int, line.split())\n        if a not in tubes:\n            tubes[a] = [(b, w)]\n        else:\n            tubes[a].append((b, w))\n\n    def dfs(start, target, depth) -> int:\n        if depth % 2 == 0:\n            if start == target:\n                return 0\n            for end, time in tubes[start]:\n                if time > depth:\n                    return time + dfs(end, target, depth + time)\n            return float(\"inf\")\n        else:\n            if start == target:\n                return 0\n            for end, time in tubes[start]:\n                if time > depth:\n                    continue\n                res = dfs(end, target, depth + time)\n                if res != float(\"inf\"):\n                    return time + res\n            return float(\"inf\")\n\n    return str(dfs(s, t, 1))"
    },
    {
        "number": 3015,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        a, b, w = map(int, stdin.split()[4+i*3:7+i*3])\n        graph[a].append((b, w))\n\n    def dfs(node: int, time: int, visited: set) -> int:\n        if node == t:\n            return time\n\n        visited.add(node)\n        min_time = float('inf')\n\n        for neighbor, weight in graph[node]:\n            if neighbor not in visited:\n                min_time = min(min_time, dfs(neighbor, time + weight, visited))\n\n        return min_time if min_time != float('inf') else 'infinity'\n\n    return dfs(s, 0, set())"
    },
    {
        "number": 3015,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(start: int, end: int) -> int:\n        visited = [False] * n\n        visited[start] = True\n        queue = [(start, 0)]\n        while queue:\n            node, cost = queue.pop(0)\n            for i, time in enumerate(tubes[node]):\n                if not visited[i]:\n                    visited[i] = True\n                    queue.append((i, cost + time))\n                    if i == end:\n                        return cost + time\n        return float('inf')\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, w = map(int, stdin.split()[4:])\n        tubes[a].append(w)\n\n    def make_decision(node: int, turn: int) -> int:\n        if turn % 2 == 0:\n            return find_path(node, 0)\n        else:\n            min_cost = float('inf')\n            min_node = -1\n            for i in range(n):\n                if i != node and i != t:\n                    cost = find_path(node, i)\n                    if cost < min_cost:\n                        min_cost = cost\n                        min_node = i\n            return min_cost\n\n    time = 0\n    turn = 0\n    while s != t:\n        time += make_decision(s, turn)\n        turn += 1\n\n    return str(time) if time != float('inf') else 'infinity'\n\ninputs = [\n    \"4 5 0 3\\n0 1 1\\n1 2 2\\n2 0 4\\n2 3 1\\n2 3 3\",\n    \"5 5 0 4\\n0 1 1\\n1 2 1\\n2 3 1\\n3 0 1\\n2 4 1\",\n    \"2 1 0 1\\n0 1 2\",\n    \"3 3 1 2\\n0 1 1\\n1 0 1\\n1 2 1\"\n]\n\nfor input in inputs:\n    print(solution(input)) "
    },
    {
        "number": 3015,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, int, int, int]:\n        n, m, s, t = map(int, stdin.split())\n        return n, m, s, t\n\n    def read_edges(n: int) -> List[Tuple[int, int, int]]:\n        edges = []\n        for i in range(n):\n            for j in range(n):\n                line = stdin.readline().strip()\n                if not line:\n                    return edges\n                a, b, w = map(int, line.split())\n                edges.append((a, b, w))\n        return edges\n\n    def bfs(n: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> int:\n        visited = [False] * n\n        queue = deque([(s, 0)])\n        while queue:\n            curr, time = queue.popleft()\n            visited[curr] = True\n            if curr == t:\n                return time\n            for a, b, w in edges:\n                if a == curr:\n                    if not visited[b]:\n                        queue.append((b, time + w))\n        return -1\n\n    n, m, s, t = read_input()\n    edges = read_edges(n)\n    time = bfs(n, edges, s, t)\n    return \"infinity\" if time == -1 else str(time)"
    },
    {
        "number": 3016,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, balls = stdin.split()\n    n = int(n)\n    balls = list(map(int, balls.split()))\n    colors = list(range(1, n + 1))\n\n    def is_valid(arrangement):\n        exclude_colors = set()\n        for i in range(len(arrangement)):\n            if i > 0 and arrangement[i] in exclude_colors:\n                return False\n            exclude_colors.add(arrangement[i])\n        return True\n\n    def count_sequences(sequence):\n        count = 0\n        current_sequence = []\n        for ball in balls:\n            current_sequence.append(ball)\n            if current_sequence == sequence:\n                count += 1\n            if len(current_sequence) == len(sequence):\n                current_sequence.pop(0)\n        return count\n\n    valid_arrangements = []\n    for arrangement in itertools.permutations(colors):\n        if is_valid(arrangement):\n            valid_arrangements.append(arrangement)\n\n    total_count = 0\n    for arrangement in valid_arrangements:\n        sequence_count = count_sequences(arrangement[:k])\n        total_count += sequence_count\n\n    return str(total_count % (10**9 + 7))\n\nimport itertools\n\nsample_inputs = [\n    \"4 2 1 2 1\\n2 1 2\\n2 3 4\",\n    \"3 3 1 1\\n1 1\\n2 2 3\",\n    \"3 2 2 3\\n1 1\\n2 2 3\",\n    \"3 1 2 3\\n2 1 2\\n0\"\n]\n\nfor sample_input in sample_inputs:\n    print(solution(sample_input)) "
    },
    {
        "number": 3016,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # read the input\n    n, balls = stdin.split('\\n')\n    n = int(n)\n    balls = [int(b) for b in balls.split()]\n    forbidden_colors, favorite_sequence = balls[-2 * n:], balls[-n:]\n    balls = balls[:-2 * n]\n\n    # check if favorite sequence appears at least once\n    has_sequence = False\n    for i in range(n - len(favorite_sequence) + 1):\n        if balls[i:i + len(favorite_sequence)] == favorite_sequence:\n            has_sequence = True\n            break\n    if not has_sequence:\n        return '0'\n\n    # count the number of arrangements\n    arrangements = 0\n    for i in range(n - len(favorite_sequence) + 1):\n        if balls[i:i + len(favorite_sequence)] == favorite_sequence:\n            j = i + len(favorite_sequence)\n            while j < n:\n                valid = True\n                if forbidden_colors[balls[j] - 1]:\n                    valid = False\n                if valid:\n                    arrangements += 1\n                j += 1\n\n    return str(arrangements % 1000000007)"
    },
    {
        "number": 3016,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_arrangements(n: int, forbidden: list, favorite: list) -> int:\n        def backtrack(pos: int, forbidden_cache: set, favorite_cache: set) -> int:\n            if pos == n:\n                return 1\n\n            count = 0\n            color = 1\n            while color <= n:\n                if color not in forbidden and color not in favorite:\n                    if pos > 0 and color == balls[pos - 1]:\n                        continue\n\n                    if color in forbidden_cache:\n                        continue\n\n                    if pos > 0 and color == balls[pos - 1] + 1:\n                        forbidden_cache.add(color)\n                    else:\n                        forbidden_cache.discard(color)\n\n                    balls[pos] = color\n                    count += backtrack(pos + 1, forbidden_cache, favorite_cache)\n                    balls[pos] = 0\n\n                color += 1\n\n            return count\n\n        balls = [0] * n\n        forbidden_cache = set(forbidden)\n        favorite_cache = set(favorite)\n\n        return backtrack(0, forbidden_cache, favorite_cache)\n\n    n, balls = stdin.split()\n    n = int(n)\n    balls = list(map(int, balls.split()))\n\n    k, forbidden = stdin.split()\n    k = int(k)\n    forbidden = list(map(int, forbidden.split()))\n\n    l, favorite = stdin.split()\n    l = int(l)\n    favorite = list(map(int, favorite.split()))\n\n    return str(count_arrangements(n, forbidden, favorite) % 1000000007)"
    },
    {
        "number": 3016,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, balls = list(map(int, stdin.split()))\n    no_adjacent = list(map(int, input().split()))\n    favorite_sequence = list(map(int, input().split()))\n    \n    # Compute the number of arrangements\n    count = 0\n    for i in range(len(balls)):\n        for j in range(i+1, len(balls)):\n            if no_adjacent[0] == 0 or (balls[i] not in no_adjacent and balls[j] not in no_adjacent):\n                if balls[i] in favorite_sequence:\n                    if balls[j] == favorite_sequence[0] or balls[i] == favorite_sequence[-1]:\n                        count += 1\n                elif balls[j] in favorite_sequence:\n                    if balls[i] == favorite_sequence[0] or balls[j] == favorite_sequence[-1]:\n                        count += 1\n                else:\n                    count += 1\n                \n    # Output the result modulo 1000000007\n    return str(count % 1000000007)"
    },
    {
        "number": 3016,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, *frequencies = map(int, stdin.split())\n    colors_to_avoid, *favorite_sequence = map(int, stdin.split())\n    \n    def is_valid_configuration(colors_to_avoid: List[int], color_frequencies: List[int]) -> bool:\n        for color in colors_to_avoid:\n            if color_frequencies[color - 1] > 0:\n                return False\n        return True\n    \n    def count_valid_configurations(color_frequencies: List[int], favorite_sequence: List[int], position: int) -> int:\n        if position == len(favorite_sequence):\n            return 1\n        count = 0\n        for i in range(len(color_frequencies)):\n            if color_frequencies[i] > 0 and favorite_sequence[position] == i + 1:\n                new_color_frequencies = color_frequencies.copy()\n                new_color_frequencies[i] -= 1\n                count += count_valid_configurations(new_color_frequencies, favorite_sequence, position + 1)\n        return count\n    \n    def count_valid_configurations_with_avoidance(colors_to_avoid: List[int], color_frequencies: List[int], favorite_sequence: List[int]) -> int:\n        if not is_valid_configuration(colors_to_avoid, color_frequencies):\n            return 0\n        count = 1\n        for i in range(len(color_frequencies)):\n            if color_frequencies[i] > 0:\n                new_color_frequencies = color_frequencies.copy()\n                new_color_frequencies[i] -= 1\n                count += count_valid_configurations_with_avoidance(colors_to_avoid, new_color_frequencies, favorite_sequence)\n        return count\n    \n    total_count = 1\n    for i in range(len(frequencies)):\n        total_count *= (frequencies[i] + 1)\n        total_count %= 1000000007\n    \n    for color in colors_to_avoid:\n        if favorite_sequence and color == favorite_sequence[0]:\n            total_count -= 1\n            total_count %= 1000000007\n        elif colors_to_avoid.count(color) == 2:\n            total_count -= (total_count - 1)\n            total_count %= 1000000007\n    \n    favorite_sequence_count = count_valid_configurations_with_avoidance(colors_to_avoid, frequencies, favorite_sequence)\n    total_count *= favorite_sequence_count\n    total_count %= 1000000007\n    \n    return str(total_count)\n"
    },
    {
        "number": 3016,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    n, *ball_frequencies = list(map(int, stdin.split()))\n    forbidden_colors, preferred_sequence = [], []\n    k, *forbidden_colors = ball_frequencies[:n]\n    ball_frequencies = ball_frequencies[n:]\n    l, *preferred_sequence = ball_frequencies[:k]\n    \n    # Check if forbidden colors are unique and within the range\n    if len(set(forbidden_colors)) != len(forbidden_colors) or any(color < 1 or color > n for color in forbidden_colors):\n        return \"0\"\n    \n    # Check if preferred sequence is unique and within the range\n    if len(set(preferred_sequence)) != len(preferred_sequence) or any(color < 1 or color > n for color in preferred_sequence):\n        return \"0\"\n    \n    # Check if the preferred sequence is not a subset of the forbidden colors\n    if set(preferred_sequence) <= set(forbidden_colors):\n        return \"0\"\n    \n    # Calculate the number of arrangements\n    count = 0\n    for i in range(1, n+1):\n        if i not in forbidden_colors:\n            for j in range(1, n+1):\n                if j not in forbidden_colors and j not in preferred_sequence:\n                    for k in range(1, n+1):\n                        if k not in forbidden_colors and k not in preferred_sequence and k != j:\n                            if i != j and j != k and k != i:\n                                count += 1\n    \n    # Modulo the result\n    return str(count % 1000000007)"
    },
    {
        "number": 3016,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, colors = list(map(int, stdin.split()))\n    colors = [colors[i:i+n] for i in range(0, len(colors), n)]\n    no_adjacent, forbidden_colors = list(map(int, input().split()))\n    no_adjacent_colors = list(map(int, input().split()))\n    sequence, sequence_length = list(map(int, input().split()))\n    sequence_colors = list(map(int, input().split()))\n    \n    def is_valid(color):\n        for forbidden in forbidden_colors:\n            if color == forbidden:\n                return False\n        return True\n    \n    def is_sequence_valid(colors):\n        sequence_count = 0\n        sequence_index = 0\n        for color in colors:\n            if color == sequence_colors[sequence_index]:\n                sequence_count += 1\n                if sequence_count == sequence_length:\n                    sequence_index = (sequence_index + 1) % sequence_length\n                    sequence_count = 0\n            else:\n                sequence_count = 0\n                sequence_index = 0\n        return sequence_count == sequence_length\n    \n    valid_colors = [color for color in colors if is_valid(color)]\n    \n    def count_combinations(valid_colors, forbidden_colors):\n        if len(valid_colors) == 0:\n            return 1\n        first_color = valid_colors[0]\n        count = 0\n        valid_colors.pop(0)\n        for i in range(len(colors)):\n            if colors[i] == first_color and is_valid(colors[i]):\n                new_valid_colors = valid_colors[:]\n                new_forbidden_colors = forbidden_colors[:]\n                if no_adjacent == 1 and i > 0 and colors[i-1] == first_color:\n                    continue\n                if no_adjacent == 2 and i > 1 and colors[i-1] == colors[i-2]:\n                    continue\n                if colors[i] in new_forbidden_colors:\n                    continue\n                new_valid_colors.append(colors[i])\n                new_forbidden_colors.append(colors[i])\n                count += count_combinations(new_valid_colors, new_forbidden_colors)\n        return count\n    \n    count = count_combinations(valid_colors, forbidden_colors)\n    return str(count % (10**9 + 7))\n\ninput_1 = \"4 2 1 2 1\\n2 1 2\\n2 3 4\"\nprint(solution(input_1)) # Expected output: 6\n\ninput_2 = \"3 3 1 1\\n1 1\\n2 2 3\"\nprint(solution(input_2)) # Expected output: 0\n\ninput_3 = \"3 2 2 3\\n1 1\\n2 2 3\"\nprint(solution(input_3)) # Expected output: 18\n\ninput_4 = \"3 1 2 3\\n2 1 2\\n0\"\nprint(solution(input_4)) # Expected output: 12 "
    },
    {
        "number": 3016,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *freqs = list(map(int, stdin.split()))\n    colors_not_next, *favorite_seq = list(map(int, favorite_seq.split()))\n    \n    def is_valid_seq(seq: List[int]) -> bool:\n        for i in range(len(seq) - 1):\n            if seq[i] in colors_not_next and seq[i] == seq[i + 1]:\n                return False\n        return True\n    \n    def count_valid_seq(seq: List[int], pos: int) -> int:\n        if pos == len(seq):\n            return 1 if is_valid_seq(seq) else 0\n        count = 0\n        for i in range(n):\n            if i not in colors_not_next:\n                seq[pos] = i + 1\n                count += count_valid_seq(seq, pos + 1)\n        return count\n    \n    def count_arrangements() -> int:\n        total_count = 0\n        for i in range(n):\n            freq = freqs[i]\n            seq = [i + 1] * freq\n            total_count += count_valid_seq(seq, 0)\n        return total_count % 1000000007\n    \n    return str(count_arrangements())"
    },
    {
        "number": 3016,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split('\\n')\n    n = int(lines[0].split()[0])\n    num_colors = [int(x) for x in lines[0].split()[1:]]\n    not_adjacent_colors = [int(x) for x in lines[1].split()]\n    favorite_sequence = [int(x) for x in lines[2].split()]\n\n    # Create the color combinations\n    color_combinations = []\n    for i in range(n):\n        for j in range(i+1, n):\n            color_combinations.append((i+1, j+1))\n\n    # Remove colors that are not adjacent\n    valid_combinations = []\n    for combination in color_combinations:\n        if combination[0] not in not_adjacent_colors and combination[1] not in not_adjacent_colors:\n            valid_combinations.append(combination)\n\n    # Count the number of valid combinations with the favorite sequence\n    favorite_count = 0\n    for combination in valid_combinations:\n        if combination[0] == favorite_sequence[0] and combination[1] == favorite_sequence[-1]:\n            favorite_count += 1\n\n    # Calculate the total number of arrangements\n    total_combinations = len(valid_combinations) * (num_colors[favorite_sequence[0]-1] - favorite_count)\n\n    # Return the result modulo 1000000007\n    return str(total_combinations % 1000000007)"
    },
    {
        "number": 3016,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, balls = list(map(int, stdin.split()))\n    forbidden_colors, favorite_sequence = stdin.split(\"\\n\")[1:]\n    forbidden_colors = list(map(int, forbidden_colors.split()))\n    favorite_sequence = list(map(int, favorite_sequence.split()))\n    \n    # Calculate the number of arrangements\n    arrangements = 1\n    for i in range(n):\n        if i not in forbidden_colors:\n            arrangements *= balls[i]\n        else:\n            arrangements //= balls[i]\n    \n    # Calculate the number of times the favorite sequence appears\n    count = 0\n    for i in range(n):\n        if balls[i] >= len(favorite_sequence):\n            count += 1\n    \n    return str(arrangements * count % 1000000007)"
    },
    {
        "number": 3017,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        if str(e) in str(i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n\n    def count_powers_of_two(num: int) -> int:\n        count = 0\n        power_of_two = 2 ** e\n        while power_of_two <= num:\n            count += 1\n            num -= power_of_two\n            power_of_two //= 10\n        return count\n\n    count = sum(1 for i in range(n + 1) if count_powers_of_two(i))\n\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    \n    def count_power_of_two(num: int) -> int:\n        count = 0\n        power = 1\n        while power <= num:\n            if num % power == 0:\n                count += 1\n            power *= 2\n        return count\n    \n    def count_numbers_with_power_of_two(n: int, e: int) -> int:\n        count = 0\n        for i in range(1, n+1):\n            if count_power_of_two(i) == e:\n                count += 1\n        return count\n    \n    return str(count_numbers_with_power_of_two(n, e))"
    },
    {
        "number": 3017,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    \n    # Convert n and e to binary strings\n    n_binary = bin(n)[2:]\n    e_binary = bin(e)[2:]\n    \n    # Initialize variables for counting the number of integers that contain 2^e as a substring\n    count = 0\n    e_index = 0\n    n_index = 0\n    \n    # Iterate through n_binary and e_binary\n    while n_index < len(n_binary) and e_index < len(e_binary):\n        if n_binary[n_index] == e_binary[e_index]:\n            # If the current digit in n_binary is the same as the current digit in e_binary, move to the next digit in both binary strings\n            e_index += 1\n        else:\n            # If the current digit in n_binary is not the same as the current digit in e_binary, move to the next non-zero digit in n_binary\n            while n_index < len(n_binary) and n_binary[n_index] == '0':\n                n_index += 1\n        # If we have found all the digits of 2^e as a substring, increment the count\n        if e_index == len(e_binary):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    power_of_two = str(2**e)\n    count = 0\n    for i in range(n+1):\n        if power_of_two in str(i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n + 1):\n        if str(2**e) in str(i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n+1):\n        if str(2**e) in str(i):\n            count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3017,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        if str(2**e) in str(i):\n            count += 1\n    return str(count)\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 3017,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    # count the number of digits in 2^e\n    power_of_two = 1 << e\n    digits = len(str(power_of_two))\n    # count the number of integers between 0 and n that contain the digits of 2^e as a substring\n    count = 0\n    for i in range(n+1):\n        if str(power_of_two) in str(i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    total_count = 0\n    for i in range(1, n + 1):\n        binary_string = bin(i)[2:]\n        if f\"{2**e}\" in binary_string:\n            total_count += 1\n    return str(total_count)"
    },
    {
        "number": 3018,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    rolls = list(map(int, stdin.split()))[K+1:]\n    \n    def probability(dice: int, target: int) -> float:\n        if dice == 0:\n            return 0.0\n        if dice == 1:\n            return 1.0\n        \n        total_probability = 0.0\n        for i in range(min(target, 6*dice), 6*dice+1):\n            combinations = 0\n            for j in range(dice+1):\n                if i-6*j <= target:\n                    combinations += math.comb(dice, j)\n            total_probability += (1/6)**dice * combinations\n        return total_probability\n    \n    best_dice = 0\n    best_probability = 0.0\n    for dice in range(1, K+1):\n        pickup = min(K, dice)\n        probability = probability(dice, T)\n        if probability > best_probability:\n            best_dice = pickup\n            best_probability = probability\n    \n    return str(best_dice)"
    },
    {
        "number": 3018,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    K, T = map(int, stdin.split()[:2])\n    first_roll = list(map(int, stdin.split()[2:]))\n\n    # create a probability matrix\n    prob_matrix = [[0] * (T + 1) for _ in range(K + 1)]\n    for i in range(1, 7):\n        for j in range(T, 0, -1):\n            if i <= j:\n                prob_matrix[1][j] = 1\n            else:\n                prob_matrix[1][j] = prob_matrix[i - 1][j]\n\n    for i in range(2, K + 1):\n        for j in range(T, 0, -1):\n            for k in range(6, 0, -1):\n                prob_matrix[i][j] += prob_matrix[i - 1][j] * prob_matrix[1][j - k]\n\n    # calculate the best number of dice to pick up\n    max_prob = 0\n    best_num_dice = 0\n    for i in range(1, K + 1):\n        prob = prob_matrix[i][T]\n        if prob > max_prob:\n            max_prob = prob\n            best_num_dice = i\n\n    # return the result\n    return str(best_num_dice)"
    },
    {
        "number": 3018,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    K, T = list(map(int, stdin.split()))\n    nums = list(map(int, input().split()))\n    probabilities = {}\n    \n    for i in range(K + 1):\n        probability = 0\n        for comb in combinations(nums, i):\n            if sum(comb) == T:\n                probability += 1\n        probabilities[i] = probability\n    \n    max_prob = max(probabilities.values())\n    max_dice = [k for k, v in probabilities.items() if v == max_prob]\n    \n    return str(min(max_dice))\n\nimport sys\nfrom itertools import combinations\n\nstdin = sys.stdin.read()\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 3018,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[0:2])\n    dice_rolls = list(map(int, stdin.split()[2:]))\n    \n    def probability(num_dice: int) -> float:\n        combinations = math.comb(K, num_dice)\n        total_sum = 0\n        for i in range(1, 7):\n            total_sum += combinations * pow(6-i, 6-num_dice) * pow(i, num_dice)\n        return total_sum / pow(6, K)\n    \n    max_probability = 0\n    num_dice = 0\n    \n    for i in range(1, K+1):\n        current_probability = probability(i)\n        if current_probability > max_probability:\n            max_probability = current_probability\n            num_dice = i\n    \n    return str(num_dice)"
    },
    {
        "number": 3018,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    dice = list(map(int, stdin.split()))\n\n    target_range = range(K, 6 * K + 1)\n    target_sum = T\n    target_dice_count = K\n\n    for num_dice in range(K, 0, -1):\n        sum_dice = sum(dice[:num_dice])\n        if sum_dice in target_range and num_dice < target_dice_count:\n            target_dice_count = num_dice\n\n    return str(target_dice_count)"
    },
    {
        "number": 3018,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[0:2])\n    numbers = list(map(int, stdin.split()[2:]))\n\n    max_probability = 0\n    max_dice = 0\n\n    for dice in range(1, K + 1):\n        probability = sum([1 / 6] * dice + [1 / 6 * (T - dice) / (6 * (K - dice))] * (K - dice) + [1 / 6 * (T - dice) / (6 * dice)] * dice)\n        if probability > max_probability:\n            max_probability = probability\n            max_dice = dice\n\n    return str(max_dice)\n\n\ndef"
    },
    {
        "number": 3018,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    rolls = list(map(int, input().split()))\n    max_prob = 0\n    min_dice_to_pick = K\n    \n    for d in range(1, K+1):\n        roll_combinations = combinations(rolls, d)\n        for combination in roll_combinations:\n            if sum(combination) == T:\n                return str(d)\n            if sum(combination) > T:\n                continue\n            prob = 1\n            for roll in rolls:\n                prob *= (1 - (sum(combination) / (6*d))**(K-d)) / (1 - (1 - (sum(combination) / (6*d))**(K-d))**(K-d))\n            if prob > max_prob:\n                max_prob = prob\n                min_dice_to_pick = d\n                \n    return str(min_dice_to_pick)"
    },
    {
        "number": 3018,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    dice_rolls = list(map(int, stdin.split()))\n\n    def find_max_dice(k: int, t: int, rolls: List[int]) -> int:\n        rolls_count = Counter(rolls)\n        total_probability = 0\n        for i in range(1, 7):\n            if k * i <= t:\n                current_probability = 0\n                for count, value in rolls_count.items():\n                    current_probability += value * comb(count, i) * (1/6) ** i * (5/6) ** (count - i)\n                total_probability += current_probability\n        return total_probability\n\n    max_dice = 0\n    for i in range(1, K + 1):\n        max_dice = max(max_dice, find_max_dice(i, T, dice_rolls))\n\n    return str(max_dice)\n\ndef"
    },
    {
        "number": 3018,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    dice = list(map(int, input().split()))\n\n    max_prob = 0\n    max_dice = 0\n\n    for i in range(1, K + 1):\n        prob = combinations(K, i) * sum([1 for d in dice if d >= T - i * 6]) / 6 ** i\n        if prob > max_prob:\n            max_prob = prob\n            max_dice = i\n\n    return str(max_dice)\n"
    },
    {
        "number": 3018,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, input().split())\n    numbers = list(map(int, input().split()))\n    numbers.sort()\n\n    def calculate_probability(dice_count: int) -> float:\n        count = 0\n        total = 0\n        for i in range(1, 7):\n            count += dice_count\n            total += min(count, dice_count)\n            count -= i\n        return total / 6 ** dice_count\n\n    target_probability = calculate_probability(T)\n    max_dice_count = 1\n    for dice_count in range(2, K + 1):\n        probability = calculate_probability(dice_count)\n        if probability >= target_probability:\n            max_dice_count = dice_count\n        else:\n            break\n\n    return str(max_dice_count)"
    },
    {
        "number": 3019,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    S = list(map(int, lines[1].split()))\n\n    def count_prime_factors(n: int) -> int:\n        count = 0\n        while n % 2 == 0:\n            count += 1\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                count += 1\n                n //= i\n        if n > 2:\n            count += 1\n        return count\n\n    max_revenue = 0\n    for i in range(2**N):\n        indices = [j for j in range(N) if (i >> j) & 1]\n        total_sum = sum(S[j] for j in indices)\n        revenue = count_prime_factors(total_sum)\n        max_revenue = max(max_revenue, revenue)\n\n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_prime_factors(num: int) -> int:\n        count = 0\n        while num % 2 == 0:\n            count += 1\n            num //= 2\n\n        for i in range(3, int(num**0.5) + 1, 2):\n            while num % i == 0:\n                count += 1\n                num //= i\n        if num > 2:\n            count += 1\n\n        return count\n\n    N = int(stdin.readline())\n    sums = list(map(int, stdin.readline().split()))\n\n    max_revenue = 0\n    for i in range(N):\n        max_revenue = max(max_revenue, count_prime_factors(sum(sums[:i+1])))\n\n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    import math\n\n    def count_prime_factors(n):\n        count = 0\n        while n % 2 == 0:\n            count += 1\n            n //= 2\n        for i in range(3, int(math.sqrt(n)) + 1, 2):\n            while n % i == 0:\n                count += 1\n                n //= i\n        if n > 2:\n            count += 1\n        return count\n\n    n, stdin = stdin.split('\\n')\n    n = int(n)\n    data = [int(x) for x in stdin.split()]\n\n    max_revenue = 0\n    for i in range(2 ** n):\n        binary = bin(i)[2:].zfill(n)\n        total = sum([data[j] for j in range(n) if binary[j] == '1'])\n        revenue = count_prime_factors(total)\n        max_revenue = max(max_revenue, revenue)\n\n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    S = list(map(int, stdin.split('\\n')[1].split()))\n\n    def count_prime_factors(n: int) -> int:\n        count = 0\n        while n % 2 == 0:\n            count += 1\n            n //= 2\n        for i in range(3, int(n**0.5)+1, 2):\n            while n % i == 0:\n                count += 1\n                n //= i\n        if n > 2:\n            count += 1\n        return count\n\n    max_revenue = 0\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            max_revenue = max(max_revenue, count_prime_factors(S[i-1] + S[j-1]))\n\n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, stdin = int(stdin.split()[0]), stdin.split()[1:]\n    data = [int(i) for i in stdin]\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def count_factors(num):\n        factors = 0\n        for i in range(1, num+1):\n            if num % i == 0 and is_prime(i):\n                factors += 1\n        return factors\n    \n    max_revenue = 0\n    for i in range(1, N+1):\n        revenue = count_factors(sum(data[:i]))\n        if revenue > max_revenue:\n            max_revenue = revenue\n    \n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, data = stdin.split(\"\\n\")\n    N = int(N)\n    data = list(map(int, data.split()))\n    \n    def prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n //= i\n        if n > 2:\n            factors.add(n)\n        return factors\n    \n    max_revenue = 0\n    for i in range(2**N):\n        bits = bin(i)[2:].zfill(N)\n        customers = []\n        for j in range(N):\n            if bits[j] == '1':\n                customers.append(j)\n        total_sum = sum(data[j] for j in customers)\n        max_revenue = max(max_revenue, len(prime_factors(total_sum)))\n    \n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    n, s = stdin.split('\\n')\n    s = [int(x) for x in s.split()]\n\n    # Define helper functions\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def prime_factors(num: int) -> int:\n        factors = 0\n        while num % 2 == 0:\n            factors += 1\n            num = num // 2\n        for i in range(3, int(num ** 0.5) + 1, 2):\n            while num % i == 0:\n                factors += 1\n                num = num // i\n        if num > 2:\n            factors += 1\n        return factors\n\n    # Calculate the revenue for each customer\n    revenue = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                revenue[i] += prime_factors(s[i] + s[j])\n\n    # Return the maximum revenue\n    return str(max(revenue))"
    },
    {
        "number": 3019,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, stdin = int(stdin.split()[0]), stdin.split()[1:]\n    S = [int(i) for i in stdin]\n    \n    def prime_factors(n):\n        factors = set()\n        i = 2\n        while i*i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.add(i)\n        if n > 1:\n            factors.add(n)\n        return factors\n    \n    revenue = 0\n    for i in range(N):\n        revenue += len(prime_factors(sum(S[:i+1])))\n    \n    return str(revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    S = list(map(int, stdin.readline().strip().split()))\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def count_prime_factors(n: int) -> int:\n        count = 0\n        while n > 1:\n            count += 1\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0 and is_prime(i):\n                    count += 1\n                    n //= i\n                    break\n            else:\n                n -= n - 1\n        return count\n\n    max_revenue = 0\n    for i in range(2**N):\n        customer_data = []\n        for j in range(N):\n            if i & (1 << j):\n                customer_data.append(S[j])\n        revenue = count_prime_factors(sum(customer_data))\n        max_revenue = max(max_revenue, revenue)\n\n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def prime_factors(n: int) -> set:\n        factors = set()\n        for i in range(2, n + 1):\n            if n % i == 0 and is_prime(i):\n                factors.add(i)\n        return factors\n\n    N, S = stdin.split()\n    N = int(N)\n    S = list(map(int, S.split()))\n\n    max_revenue = 0\n    for i in range(2**N):\n        pieces = [[] for _ in range(N)]\n        for j in range(N):\n            if (i >> j) & 1:\n                pieces[j].append(j + 1)\n        total_factors = 0\n        for piece in pieces:\n            total_factors += len(prime_factors(sum(S[i - 1] for i in piece)))\n        max_revenue = max(max_revenue, total_factors)\n\n    return str(max_revenue)"
    },
    {
        "number": 3020,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    for i in range(1, N + 1):\n        if i * i == N:\n            return str(i)\n    return '-1'"
    },
    {
        "number": 3020,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    a = 2\n    while True:\n        if a * a >= N:\n            break\n        a += 1\n    if a * a == N:\n        return str(a)\n    else:\n        return \"-1\""
    },
    {
        "number": 3020,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for a in range(1, 10**10):\n        if a * a == N:\n            return str(a)\n    return \"-1\""
    },
    {
        "number": 3020,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for a in range(1, N + 1):\n        if a * a == N:\n            return str(a)\n    return '-1'"
    },
    {
        "number": 3020,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N <= 0:\n        return '-1'\n\n    for i in range(1, 10**len(str(N))):\n        if i * i == N:\n            return str(i)\n\n    return '-1'"
    },
    {
        "number": 3020,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    a = 1\n    result = -1\n\n    while result == -1:\n        if a * a == N:\n            result = a\n        elif a * a < N:\n            a += 1\n        else:\n            break\n\n    return str(result)\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 3020,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for a in range(1, int(N ** 0.5) + 1):\n        if a * a == N:\n            return str(a)\n    return \"-1\""
    },
    {
        "number": 3020,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    \n    def carryless_multiplication(a: int, b: int) -> int:\n        result = 0\n        while b > 0:\n            if b & 1:\n                result = (result + a) % 10\n            a = (a * 2) % 10\n            b >>= 1\n        return result\n\n    def is_square(n: int) -> bool:\n        root = 1\n        while root * root <= n:\n            if root * root == n:\n                return True\n            root += 1\n        return False\n\n    a = 1\n    while True:\n        if is_square(a * a):\n            if a * a == N:\n                return str(a)\n        a += 1"
    },
    {
        "number": 3020,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    \n    def carryless_multiplication(a, b):\n        result = 0\n        for i in range(len(a)):\n            carry = 0\n            for j in range(len(b)):\n                carry += a[i] * b[j]\n                carry //= 10\n            result += carry\n        return result % 10\n    \n    def carryless_square(a):\n        a_str = str(a)\n        a_list = [int(digit) for digit in a_str]\n        return carryless_multiplication(a_list, a_list)\n\n    a = 1\n    while True:\n        if carryless_square(a) == N:\n            return str(a)\n        a += 1\n\n    return '-1'"
    },
    {
        "number": 3020,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    a = 2\n    while True:\n        if a * a == N:\n            return str(a)\n        elif a * a < N:\n            a += 1\n        else:\n            return \"-1\""
    },
    {
        "number": 3021,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[0:2])\n    words = [word.strip() for word in stdin.split()[2:]]\n    alphabet = set('a')\n    for word in words:\n        alphabet.update(word)\n\n    if len(alphabet) > L:\n        return 'IMPOSSIBLE'\n\n    sorted_words = sorted(words)\n    derived_alphabet = ''.join([chr(ord('a') + words.index(word)) for word in sorted_words])\n    if derived_alphabet != ''.join(sorted(alphabet)):\n        return 'AMBIGUOUS'\n\n    return derived_alphabet"
    },
    {
        "number": 3021,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, input().split())\n    words = [input() for _ in range(N)]\n    \n    alphabet = {chr(ord('a') + i): None for i in range(L - ord('a') + 1)}\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            if words[i] < words[j]:\n                for k in range(min(len(words[i]), len(words[j]))):\n                    if words[i][k] != words[j][k]:\n                        alphabet[words[i][k]] = alphabet[words[j][k]] = min(words[i][k], words[j][k])\n                        break\n                    elif k == min(len(words[i]), len(words[j])) - 1:\n                        return \"IMPOSSIBLE\"\n                \n    if None in alphabet.values():\n        return \"AMBIGUOUS\"\n    \n    result = []\n    while None in alphabet.values():\n        for char, value in alphabet.items():\n            if value is None:\n                result.append(char)\n                for key, val in alphabet.items():\n                    if val is not None and char < key:\n                        alphabet[key] = min(val, char)\n                break\n        alphabet[result[-1]] = result[-1]\n        \n    return \"\".join(result)"
    },
    {
        "number": 3021,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split())\n    words = [input() for _ in range(N)]\n    \n    alphabet = []\n    for i in range(ord('a'), ord(L) + 1):\n        char = chr(i)\n        if char in alphabet:\n            continue\n        \n        for j in range(i + 1, ord(L) + 1):\n            if words.index(char + chr(j)) < words.index(chr(j) + char):\n                alphabet.append(char)\n                alphabet.append(chr(j))\n                break\n        \n        if len(alphabet) == 26:\n            return ''.join(alphabet)\n    \n    return \"IMPOSSIBLE\" if len(alphabet) == 26 else \"AMBIGUOUS\""
    },
    {
        "number": 3021,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    L, N = list(map(int, stdin.split()))\n    words = [input().strip() for _ in range(N)]\n\n    def compare_words(a: str, b: str) -> int:\n        for i in range(min(len(a), len(b))):\n            if a[i] != b[i]:\n                return ord(a[i]) - ord(b[i])\n        return len(a) - len(b)\n\n    def find_alphabet() -> str:\n        alphabet = \"\"\n        for char in range(ord('a'), ord('a') + L):\n            char_list = [word for word in words if word[0] == chr(char)]\n            if len(char_list) == 0:\n                alphabet += chr(char)\n            else:\n                char_list.sort(key=cmp_to_key(compare_words))\n                for word in char_list:\n                    words.remove(word)\n                    alphabet += word[0]\n                    break\n        return alphabet\n\n    if len(words) != 0:\n        return \"IMPOSSIBLE\"\n\n    alphabet = find_alphabet()\n    if len(alphabet) != len(set(alphabet)):\n        return \"AMBIGUOUS\"\n\n    return alphabet"
    },
    {
        "number": 3021,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[0].split())\n    words = stdin.split('\\n')[1:]\n    if N != len(words):\n        return \"IMPOSSIBLE\"\n\n    alphabet = [chr(i) for i in range(ord('a'), ord(L) + 1)]\n    if len(alphabet) != len(set(alphabet)):\n        return \"IMPOSSIBLE\"\n\n    ordered_words = sorted(words)\n    if ordered_words != words:\n        return \"IMPOSSIBLE\"\n\n    def find_position(ch: str) -> int:\n        for i, c in enumerate(alphabet):\n            if c == ch:\n                return i\n        return -1\n\n    for i in range(len(ordered_words) - 1):\n        if find_position(ordered_words[i][0]) > find_position(ordered_words[i + 1][0]):\n            return \"IMPOSSIBLE\"\n\n    if len(set(words)) != len(words):\n        return \"IMPOSSIBLE\"\n\n    return \"\".join(alphabet)"
    },
    {
        "number": 3021,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[:2])\n    words = stdin.split('\\n')[1:]\n    \n    alphabet = [chr(i) for i in range(ord('a'), ord(L) + 1)]\n    possible_orders = []\n    \n    for i in range(len(alphabet)):\n        current_order = alphabet.copy()\n        current_order.insert(0, current_order.pop(i))\n        possible_orders.append(current_order)\n    \n    for word in words:\n        for order in possible_orders:\n            if all(word[i] == order[i] for i in range(min(len(word), len(order)))):\n                break\n        else:\n            return \"IMPOSSIBLE\"\n    \n    for i in range(1, len(words)):\n        if words[i] < words[i - 1]:\n            return \"IMPOSSIBLE\"\n    \n    unique_order = None\n    for order in possible_orders:\n        if all(words[i] < words[i + 1] for i in range(len(words) - 1)):\n            if unique_order is None:\n                unique_order = order\n            elif unique_order == order:\n                continue\n            else:\n                return \"AMBIGUOUS\"\n    \n    return ''.join(unique_order)"
    },
    {
        "number": 3021,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split())\n    words = [input().strip() for _ in range(N)]\n\n    alphabet = set()\n    for word in words:\n        for letter in word:\n            alphabet.add(letter)\n\n    if len(alphabet) > L:\n        return \"IMPOSSIBLE\"\n\n    alphabet = sorted(list(alphabet))\n    sorted_words = sorted(words)\n\n    if sorted_words != words:\n        return \"IMPOSSIBLE\"\n\n    result = \"\"\n    for i in range(len(alphabet)):\n        if alphabet[i] in result:\n            return \"AMBIGUOUS\"\n        result += alphabet[i]\n\n    return result\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[0].split())\n    words = stdin.split('\\n')[1:]\n\n    # Create a dictionary to store the frequency of each character\n    freq_dict = {}\n    for word in words:\n        for char in word:\n            if char not in freq_dict:\n                freq_dict[char] = 0\n            freq_dict[char] += 1\n\n    # Initialize the alphabet with the lowest character\n    alphabet = L\n\n    # Check if the order of the alphabet is consistent\n    for char in freq_dict:\n        if char < alphabet:\n            return \"IMPOSSIBLE\"\n        elif char > alphabet:\n            return \"AMBIGUOUS\"\n\n    # Create a string of the ordered alphabet\n    ordered_alphabet = ''.join(sorted(freq_dict.keys()))\n\n    return ordered_alphabet"
    },
    {
        "number": 3021,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[0:2])\n    words = stdin.split('\\n')[1:]\n    alphabet = ''\n\n    for i in range(ord('a'), ord(L) + 1):\n        for j in range(ord('a'), ord(L) + 1):\n            if i == j:\n                continue\n            if chr(i) > chr(j):\n                continue\n            for k in range(ord('a'), ord(L) + 1):\n                if i == k or j == k:\n                    continue\n                if chr(i) > chr(k) or chr(j) > chr(k):\n                    continue\n                new_alphabet = chr(i) + chr(j) + chr(k)\n                if all(new_alphabet.index(word[0]) < new_alphabet.index(word[1]) for word in words):\n                    alphabet = new_alphabet\n                    break\n            if alphabet:\n                break\n        if alphabet:\n            break\n\n    if alphabet:\n        return alphabet\n    elif N > 1:\n        return 'AMBIGUOUS'\n    else:\n        return 'IMPOSSIBLE'"
    },
    {
        "number": 3021,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, input().split())\n    words = []\n\n    for _ in range(N):\n        word = input()\n        words.append(word)\n\n    alphabet = set(\"\".join(words))\n\n    if len(alphabet) > L:\n        return \"IMPOSSIBLE\"\n\n    if len(alphabet) < L:\n        return \"AMBIGUOUS\"\n\n    order = \"\".join(sorted(alphabet))\n    return order"
    },
    {
        "number": 3022,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    total_cookies = a + b + c\n    total_friends = n\n    max_cookies = total_cookies // total_friends\n    return str(max_cookies)\n\ndef"
    },
    {
        "number": 3022,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = [int(i) for i in stdin.split()]\n    \n    cookies = [A, B, C]\n    total_cookies = sum(cookies)\n    max_cookies = 0\n    min_cookies = total_cookies // N\n    \n    for i in range(min_cookies, total_cookies + 1):\n        if total_cookies % i == 0:\n            max_cookies = i\n    \n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    max_cookies = total_cookies // N\n    if max_cookies == 0:\n        return str(total_cookies)\n    if total_cookies % N != 0:\n        max_cookies -= 1\n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    max_cookies = (total_cookies + N - 1) // N  # integer division\n\n    for i in range(max_cookies, 0, -1):\n        if (total_cookies - (N - 1) * i) % N == 0:\n            return str(i)\n\n    return \"0\"\n"
    },
    {
        "number": 3022,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, A, B, C = map(int, stdin.split())\n\n    # Calculate the maximum number of cookies that can be distributed\n    max_cookies = min(A, B, C)\n    if max_cookies % N != 0:\n        max_cookies += N - (max_cookies % N)\n\n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    \n    total_cookies = A + B + C\n    max_cookies = total_cookies // N\n    \n    for i in range(N):\n        almond_cookies = max_cookies\n        butter_cookies = max_cookies\n        chocolate_cookies = max_cookies\n        \n        if (i % 3) == 0:\n            almond_cookies += 1\n        elif (i % 3) == 1:\n            butter_cookies += 1\n        else:\n            chocolate_cookies += 1\n        \n        if almond_cookies > A:\n            almond_cookies = A\n        if butter_cookies > B:\n            butter_cookies = B\n        if chocolate_cookies > C:\n            chocolate_cookies = C\n        \n        max_cookies = min(max_cookies, almond_cookies + butter_cookies + chocolate_cookies)\n    \n    return str(max_cookies * N)"
    },
    {
        "number": 3022,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    if N == 2:\n        return str(total_cookies)\n    elif N * 2 > total_cookies:\n        return str(total_cookies)\n    else:\n        return str(N * 2)"
    },
    {
        "number": 3022,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    max_cookies = total_cookies // N\n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = [int(x) for x in stdin.split()]\n    cookies = [(A, \"almond\"), (B, \"butter\"), (C, \"chocolate\")]\n    cookies.sort(reverse=True)\n    total_cookies = sum([x for x, _ in cookies])\n    max_cookies = total_cookies // N\n    i = 0\n    while i < len(cookies) and max_cookies > 0:\n        max_cookies -= cookies[i][0]\n        i += 1\n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    max_cookies = min(A, B, C)\n\n    for i in range(N):\n        max_cookies = min(max_cookies, total_cookies - max_cookies * (N - i - 1))\n\n    return str(max_cookies)\n\ninput_str = input(\"Enter N A B C separated by space: \")\nprint(solution(input_str)) "
    },
    {
        "number": 3023,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m, r = map(int, stdin.readline().split())\n    candles = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        candles.append((x, y))\n    cuts = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        cuts.append((a, b, c))\n\n    # Check if the cuts divide the cake\n    for cut in cuts:\n        a, b, c = cut\n        pieces = set()\n        for candle in candles:\n            x, y = candle\n            if a * x + b * y + c == 0:\n                piece = (x, y)\n                pieces.add(piece)\n        if len(pieces) != n:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.readline().split())\n    candles = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    cuts = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n    \n    def is_inside_circle(x, y, r):\n        return x**2 + y**2 <= r**2\n\n    def is_on_cut(x, y, a, b, c):\n        return abs(a*x + b*y + c) < 1e-4\n\n    for i in range(n):\n        x, y = candles[i]\n        if not is_inside_circle(x, y, r):\n            return \"no\"\n\n    for i in range(m):\n        a, b, c = cuts[i]\n        if a == 0 and b == 0:\n            return \"no\"\n        for x, y in candles:\n            if is_on_cut(x, y, a, b, c):\n                return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Get input\n    n, m, r = map(int, stdin.split()[:3])\n    candles = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[:2])\n        candles.append((x, y))\n    lines = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split()[:3])\n        lines.append((a, b, c))\n    \n    # Check if candles are in the interior of the cake\n    for candle in candles:\n        if (candle[0] ** 2 + candle[1] ** 2) ** 0.5 > r:\n            return \"no\"\n    \n    # Check if lines are outside or tangent to the cake\n    for line in lines:\n        if line[0] == 0:\n            y = (-line[2] - line[1] * x) / line[0]\n            if y ** 2 > r ** 2:\n                return \"no\"\n        else:\n            x = (-line[2] - line[0] * y) / line[1]\n            if x ** 2 > r ** 2:\n                return \"no\"\n    \n    # Check if candles are on a cut line\n    for candle in candles:\n        for line in lines:\n            if line[0] == 0:\n                if candle[1] == (-line[2] - line[1] * candle[0]) / line[0]:\n                    return \"no\"\n            else:\n                if candle[0] == (-line[2] - line[0] * candle[1]) / line[1]:\n                    return \"no\"\n    \n    # Check if candles are in the same piece of cake if their positions are shifted by at most 10^-4 in any direction\n    for i in range(n):\n        for j in range(n):\n            if i != j and (abs(candles[i][0] - candles[j][0]) <= 1e-4 and abs(candles[i][1] - candles[j][1]) <= 1e-4):\n                return \"no\"\n    \n    # Check if the number of cake pieces remains the same if any cut line is shifted by at most 10^-4 in any direction\n    for i in range(m):\n        for j in range(m):\n            if i != j and (abs(lines[i][0] - lines[j][0]) <= 1e-4 and abs(lines[i][1] - lines[j][1]) <= 1e-4 and abs(lines[i][2] - lines[j][2]) <= 1e-4):\n                return \"no\"\n    \n    # If all checks pass, output \"yes\"\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    n, m, r = map(int, stdin.split()[:3])\n    candles = [(float(x), float(y)) for x, y in map(lambda s: s.split(), stdin.split('\\n')[n+m:])]\n    lines = [(float(a), float(b), float(c)) for a, b, c in map(lambda s: s.split(), stdin.split('\\n')[n:n+m])]\n\n    # Check if the cuts successfully divide the cake\n    pieces = []\n    for line in lines:\n        new_pieces = []\n        for piece in pieces:\n            # Check if the line intersects the piece\n            a, b, c = line\n            x1, y1, x2, y2 = piece\n            if (b * (x1 * x2 + y1 * y2 - a * (x1 + x2) + c) + a * (x1 + x2) - b * (y1 + y2)) == 0:\n                # Line intersects the piece\n                continue\n            x = (b * (x1 * y2 - x2 * y1) - a * (x1 - x2) + c * (y1 - y2)) / (a * (x1 - x2) - b * (y1 - y2))\n            y = -(a * x + c) / b\n            if x**2 + y**2 > r**2:\n                # Intersection point outside the cake\n                continue\n            if x1 <= x <= x2 and y1 <= y <= y2:\n                # Intersection point inside the piece\n                new_pieces.append((x1, y1, x, y))\n            else:\n                # Intersection point outside the piece\n                continue\n        if not new_pieces:\n            # The line does not intersect any piece\n            return \"no\"\n        pieces = new_pieces\n\n    # Check if each piece has exactly one candle\n    candles_in_pieces = [0] * len(pieces)\n    for x, y in candles:\n        if x**2 + y**2 > r**2:\n            # Candle outside the cake\n            continue\n        min_dist_piece = min(pieces, key=lambda p: (x - p[0])**2 + (y - p[1])**2)\n        min_dist = (x - min_piece[0])**2 + (y - min_piece[1])**2\n        if min_dist_piece not in pieces or min_dist > 1e-4:\n            # Candle not in any piece\n            return \"no\"\n        candles_in_pieces[pieces.index(min_dist_piece)] += 1\n    if all(n == 1 for n in candles_in_pieces):\n        # Each piece has exactly one candle\n        return \"yes\"\n    else:\n        # Pieces do not have exactly one candle\n        return \"no\""
    },
    {
        "number": 3023,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.readline().split())\n    candles = []\n    for _ in range(n):\n        candles.append(tuple(map(int, stdin.readline().split())))\n    cuts = []\n    for _ in range(m):\n        cuts.append(tuple(map(int, stdin.readline().split())))\n\n    def is_on_cut(point: Tuple[int, int]) -> bool:\n        x, y = point\n        for a, b, c in cuts:\n            if abs(a * x + b * y + c) <= 10**(-4):\n                return True\n        return False\n\n    pieces = []\n    for candle in candles:\n        if not is_on_cut(candle):\n            pieces.append(candle)\n\n    if len(pieces) == n:\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3023,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split()[:3])\n    candles = []\n    cuts = []\n    \n    for i in range(n):\n        candles.append(list(map(int, stdin.split()[3 + i * 2:5 + i * 2])))\n    \n    for i in range(m):\n        cuts.append(list(map(int, stdin.split()[3 + n * 2 + i * 3:6 + n * 2 + i * 3])))\n    \n    # Check if any candles or cut lines are outside the cake\n    for candle in candles:\n        if not (0 <= candle[0] ** 2 + candle[1] ** 2 < r ** 2):\n            return \"no\"\n    \n    for cut in cuts:\n        if cut[0] ** 2 + cut[1] ** 2 == 0 or cut[2] ** 2 > 20000 ** 2:\n            return \"no\"\n    \n    # Check if any candle is on a cut line\n    for candle in candles:\n        for cut in cuts:\n            if cut[0] * candle[0] + cut[1] * candle[1] + cut[2] == 0:\n                return \"no\"\n    \n    # Check if any cut line is completely outside or tangent to the cake\n    for cut in cuts:\n        if cut[0] ** 2 + cut[1] ** 2 == 0:\n            continue\n        numerator = cut[0] * cuts[0][0] + cut[1] * cuts[0][1] + cut[2] * cuts[0][2]\n        denominator = cut[0] ** 2 + cut[1] ** 2\n        if numerator / denominator > 2 or numerator / denominator < -2:\n            return \"no\"\n    \n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m, r = list(map(int, stdin.split('\\n')[0].split()))\n    candles = []\n    for i in range(1, n+1):\n        x, y = list(map(int, stdin.split('\\n')[i].split()))\n        candles.append((x, y))\n    cuts = []\n    for i in range(n+1, n+1+m):\n        a, b, c = list(map(int, stdin.split('\\n')[i].split()))\n        cuts.append((a, b, c))\n\n    # Check if cuts divide the candles\n    for cut in cuts:\n        on_candle = False\n        for candle in candles:\n            x, y = candle\n            if cut[0] * x + cut[1] * y + cut[2] == 0:\n                on_candle = True\n        if not on_candle:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = list(map(int, stdin.split('\\n')[0].split()))\n    candles = []\n    for i in range(1, n + 1):\n        x, y = list(map(int, stdin.split('\\n')[i].split()))\n        candles.append((x, y))\n    \n    cuts = []\n    for i in range(n + 1, n + m + 1):\n        a, b, c = list(map(int, stdin.split('\\n')[i].split()))\n        cuts.append((a, b, c))\n    \n    def is_on_cut(x, y, cut):\n        a, b, c = cut\n        return abs(a * x + b * y + c) < 1e-4\n    \n    def is_candle_in_piece(candle, piece):\n        return all(not is_on_cut(*candle, cut) for cut in piece)\n    \n    def find_piece_for_candle(candle):\n        for i, piece in enumerate(pieces):\n            if is_candle_in_piece(candle, piece):\n                return i\n        return None\n    \n    pieces = [[] for _ in range(n)]\n    for candle in candles:\n        piece_index = find_piece_for_candle(candle)\n        if piece_index is not None:\n            pieces[piece_index].append(candle)\n        else:\n            return \"no\"\n    \n    if all(len(piece) == 1 for piece in pieces):\n        return \"yes\"\n    else:\n        return \"no\"\n\nwith open(\"input.txt\", \"r\") as file:\n    stdin = file.read()\n\nprint(solution(stdin)) "
    },
    {
        "number": 3023,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = [int(x) for x in stdin.readline().split()]\n    candles = []\n    for _ in range(n):\n        x, y = [int(x) for x in stdin.readline().split()]\n        candles.append((x, y))\n    cuts = []\n    for _ in range(m):\n        a, b, c = [int(x) for x in stdin.readline().split()]\n        cuts.append((a, b, c))\n    \n    def is_candle_on_cut(candle: tuple, cut: tuple) -> bool:\n        a, b, c = cut\n        x, y = candle\n        return a * x + b * y + c == 0\n    \n    for cut in cuts:\n        cut_candles = [candle for candle in candles if is_candle_on_cut(candle, cut)]\n        if len(cut_candles) != 1:\n            return \"no\"\n    \n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = list(map(int, stdin.split()[0:3]))\n    candles = []\n    cuts = []\n\n    for i in range(n):\n        x, y = list(map(int, stdin.split()[3 + i*2:5 + i*2]))\n        candles.append((x, y))\n\n    for i in range(m):\n        a, b, c = list(map(int, stdin.split()[3 + n*2 + i*3:6 + n*2 + i*3]))\n        cuts.append((a, b, c))\n\n    for candle in candles:\n        for cut in cuts:\n            a, b, c = cut\n            if a * candle[0] + b * candles[1] + c == 0:\n                return \"no\"\n\n    return \"yes\"\n\ninput_data = \"\"\nwith open(\"input.txt\", \"r\") as file:\n    input_data = file.read()\n\noutput = solution(input_data)\nprint(output) "
    },
    {
        "number": 3024,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[False] * n for _ in range(n)]\n\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = True\n        for j in range(i + 1, n):\n            if stdin[i] == stdin[j]:\n                if j - i == 1 or dp[i + 1][j - 1]:\n                    dp[i][j] = True\n\n    max_k = -1\n    for i in range(n):\n        for j in range(i + 2, n):\n            if dp[i][j]:\n                max_k = max(max_k, j - i + 1)\n\n    return max_k"
    },
    {
        "number": 3024,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def is_partitionable(s: str, k: int) -> bool:\n        if k == 1 or k >= len(s):\n            return True\n        if k * (k + 1) // 2 > len(s):\n            return False\n        for i in range(k - 1, -1, -1):\n            if is_palindrome(s[:i] + s[-i:]):\n                return True\n        return False\n\n    s = stdin\n    max_k = 1\n    for k in range(2, len(s) // 2 + 1):\n        if is_partitionable(s, k):\n            max_k = k\n        else:\n            break\n    return str(max_k)"
    },
    {
        "number": 3024,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def check_partitions(s: str, start: int, end: int, k: int) -> bool:\n        if k == 0:\n            return True\n        elif start == end:\n            return False\n        else:\n            mid = (start + end) // 2\n            s1 = s[start:mid+1]\n            s2 = s[mid+1:end+1]\n            return is_palindrome(s1) and is_palindrome(s2) and check_partitions(s, start, mid, k-2)\n\n    for k in range(len(stdin), 0, -1):\n        if check_partitions(stdin, 0, len(stdin)-1, k):\n            return str(k)\n    return \"0\"\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1\n            elif stdin[i] == stdin[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    max_k = 0\n    for i in range(n - 1, -1, -1):\n        if dp[0][i] > max_k:\n            max_k = dp[0][i]\n            if max_k >= n:\n                break\n\n    return str(max_k)"
    },
    {
        "number": 3024,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = len(stdin)\n    dp = [[False for _ in range(n)] for _ in range(n)]\n\n    max_k = 0\n\n    for length in range(n):\n        for i in range(n - length):\n            j = i + length\n            if length == 0:\n                dp[i][j] = True\n            elif length == 1:\n                dp[i][j] = stdin[i] == stdin[j]\n            else:\n                dp[i][j] = stdin[i] == stdin[j] and dp[i + 1][j - 1]\n\n            if dp[i][j]:\n                max_k = max(max_k, length + 1)\n\n    if max_k == 0:\n        return \"0\"\n\n    palindromes = []\n    for k in range(max_k, 0, -1):\n        for i in range(n - k + 1):\n            j = i + k - 1\n            if dp[i][j] and is_palindrome(stdin[i:j + 1]):\n                palindromes.append(stdin[i:j + 1])\n                break\n\n    return str(max_k) + \"\\n\" + \"\\n\".join(palindromes)\n"
    },
    {
        "number": 3024,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def check_palindrome_parts(s: str, k: int) -> bool:\n        n = len(s)\n        if n == 0:\n            return True\n        if k == 0 or k > n:\n            return False\n        for i in range(n - k + 1):\n            if is_palindrome(s[i:i+k]):\n                return True\n        return False\n\n    max_k = 0\n    n = len(stdin)\n    for k in range(1, n + 1):\n        if check_palindrome_parts(stdin, k):\n            max_k = k\n        else:\n            break\n\n    return str(max_k)"
    },
    {
        "number": 3024,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = len(stdin)\n    for k in range(n, 0, -1):\n        if k > n:\n            continue\n        for i in range(n - k + 1):\n            s = stdin[i:i+k]\n            if is_palindrome(s):\n                return str(k)\n    return \"0\""
    },
    {
        "number": 3024,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if stdin[i] == stdin[j] and (length < 3 or dp[i + 1][j - 1]):\n                dp[i][j] = 1\n    \n    max_k = 1\n    for i in range(n):\n        for j in range(i, n):\n            if dp[i][j]:\n                max_k = max(max_k, j - i + 1)\n    \n    return str(max_k)\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0], dp[0][1] = 1, 1\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][0] + 1, dp[i - 1][1] + 1)\n        dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]) + 1\n\n    return str(max(dp[n - 1]))"
    },
    {
        "number": 3024,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n == 0:\n        return \"0\"\n\n    dp = [[0] * n for _ in range(n)]\n\n    max_length = 1\n\n    for i in range(n):\n        dp[i][i] = 1\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if stdin[i] == stdin[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n                max_length = max(max_length, dp[i][j])\n\n    return str(max_length)"
    },
    {
        "number": 3025,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    gold_values = list(map(int, stdin.split()[2:]))\n    roads = []\n    for i in range(m):\n        a, b = map(int, stdin.split()[2:])\n        roads.append((a, b))\n        roads.append((b, a))\n    \n    # create a graph using adjacency list\n    graph = [[] for _ in range(n+1)]\n    for road in roads:\n        graph[road[0]].append(road[1])\n    \n    # BFS to find the shortest path from home to castle\n    queue = [(1, 0)]\n    visited = set()\n    while queue:\n        curr, dist = queue.pop(0)\n        if curr == 2:\n            return str(gold_values[1] - dist)\n        if curr in visited:\n            continue\n        visited.add(curr)\n        for neighbor in graph[curr]:\n            if neighbor != 1:\n                queue.append((neighbor, dist+1))\n    \n    # if the BFS fails to find a path, the problem is unsolvable\n    return \"0\""
    },
    {
        "number": 3025,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    gold = list(map(int, lines[1].split()))\n    roads = [tuple(map(int, lines[i+2].split())) for i in range(m)]\n    \n    def dfs(start, visited):\n        if start == 1:\n            return 0\n        if start in visited:\n            return float('inf')\n        visited.add(start)\n        return max([gold[start - 1]] + [dfs(end, visited) for end, start in roads if start == start])\n    \n    max_gold = dfs(2, set())\n    return str(max_gold)"
    },
    {
        "number": 3025,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        n, m = map(int, input().split())\n        gold = list(map(int, input().split()))\n        roads = []\n        for _ in range(m):\n            a, b = map(int, input().split())\n            roads.append((a, b))\n        return n, gold, roads\n\n    def dfs(node, visited, graph, gold, total_gold, current_gold, max_gold):\n        if node == 1:\n            return max_gold\n        if node in visited:\n            return current_gold\n        visited.add(node)\n        for neighbor in graph[node]:\n            total_gold += gold[neighbor - 1]\n            current_gold = max(current_gold, total_gold)\n            max_gold = max(max_gold, dfs(neighbor, visited, graph, gold, total_gold, current_gold, max_gold))\n            total_gold -= gold[neighbor - 1]\n        visited.remove(node)\n        return max_gold\n\n    n, gold, roads = read_input()\n    graph = [[] for _ in range(n)]\n    for a, b in roads:\n        graph[a - 1].append(b)\n        graph[b - 1].append(a)\n    return str(dfs(2, set(), graph, gold, 0, 0, 0))\n\ninput_data = \"\"\"3 3\n1\n1 2\n2 3\n1 3\"\"\"\nprint(solution(input_data)) # Output: 0 "
    },
    {
        "number": 3025,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, gold_list = stdin.split(\"\\n\", 2)\n    n, m = map(int, n.split())\n    gold_list = list(map(int, gold_list.split()))\n\n    graph = {}\n    for i in range(m):\n        a, b = map(int, input().split())\n        graph.setdefault(a, set()).add(b)\n        graph.setdefault(b, set()).add(a)\n\n    def dfs(node, visited):\n        visited.add(node)\n        if node == 2:\n            return 0\n        gold = gold_list[node - 1]\n        max_gold = 0\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                max_gold = max(max_gold, gold + dfs(neighbor, visited))\n        return max_gold\n\n    visited = set()\n    max_gold = dfs(1, visited)\n    return str(max_gold)\n"
    },
    {
        "number": 3025,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, end, visited, tribute):\n        if start == end:\n            return tribute\n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                tribute = dfs(graph, neighbor, end, visited, tribute)\n        return tribute\n\n    def find_max_tribute(graph, n):\n        max_tribute = 0\n        for i in range(1, n):\n            max_tribute = max(max_tribute, dfs(graph, 1, i, set(), 0))\n        return max_tribute\n\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.splitlines()\n        n, m = map(int, lines[0].split())\n        graph = [[] for _ in range(n + 1)]\n        for i in range(1, n):\n            graph[i] = list(map(int, lines[i].split()))\n        for i in range(m):\n            a, b = map(int, lines[i + n].split())\n            graph[a].append(b)\n            graph[b].append(a)\n        golds = list(map(int, lines[-1].split()))\n        return graph, golds\n\n    stdin = stdin.strip()\n    graph, golds = read_input(stdin)\n    max_tribute = find_max_tribute(graph, len(golds))\n    return str(max_tribute) "
    },
    {
        "number": 3025,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n, m = map(int, input().split())\n    gold_amounts = list(map(int, input().split()))\n    roads = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        roads.append((a, b))\n        roads.append((b, a))\n\n    # helper function to get the gold amount in a village\n    def get_gold_amount(village_num):\n        return gold_amounts[village_num - 1]\n\n    # calculate the maximum gold amount the bandits can steal\n    max_gold_amount = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j:\n                gold_amount = 0\n                for road in roads:\n                    if road[0] == i and road[1] == j:\n                        gold_amount += get_gold_amount(i)\n                max_gold_amount = max(max_gold_amount, gold_amount)\n\n    return str(max_gold_amount) "
    },
    {
        "number": 3025,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_input() -> Tuple[int, int, List[int], List[Tuple[int, int]]]:\n        n, m = map(int, input().split())\n        gold = list(map(int, input().split()))\n        roads = [tuple(map(int, input().split())) for _ in range(m)]\n        return n, gold, roads\n\n    def dfs(village: int, visited: Set[int], gold: int, gold_stolen: int) -> int:\n        if village == 2:\n            return max(gold_stolen, gold)\n\n        if village in visited:\n            return gold_stolen\n\n        visited.add(village)\n        for neighbor in [u for u in range(1, n + 1) if u != 1 and (village, u) in roads]:\n            if neighbor == 2:\n                continue\n            gold_stolen = dfs(neighbor, visited, gold, gold_stolen)\n\n        visited.remove(village)\n        return gold_stolen\n\n    n, gold, roads = get_input()\n    gold_stolen = dfs(1, set(), gold[0], 0)\n    return str(gold_stolen)"
    },
    {
        "number": 3025,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    gold_amounts = list(map(int, stdin.split()[2:]))\n    road_pairs = []\n    for i in range(m):\n        road_pairs.append(tuple(map(int, stdin.split()[2+n-2+i].split())))\n\n    bandit_home = 1\n    castle = 2\n    gold_in_castle = gold_amounts[1]\n\n    gold_collected = 0\n    gold_stolen = 0\n\n    # Calculate total gold collected by the bandits from all the villages except the bandit home and castle\n    for i in range(3, n):\n        gold_collected += gold_amounts[i-1]\n\n    # Calculate the maximum amount of gold the bandits can steal from each village along their path to the castle\n    for a, b in road_pairs:\n        if a == bandit_home or b == bandit_home or a == castle or b == castle:\n            continue\n        gold_amount = min(gold_amounts[a-1], gold_amounts[b-1])\n        gold_stolen += gold_amount\n        gold_amounts[a-1] -= gold_amount\n        gold_amounts[b-1] -= gold_amount\n\n    # Calculate the maximum amount of gold the bandits can steal from the castle\n    gold_stolen += gold_in_castle\n\n    # Calculate the maximum amount of gold the bandits can steal from the bandit home\n    for i in range(3, n):\n        gold_stolen += min(gold_amounts[i-1], gold_collected)\n        gold_amounts[i-1] -= min(gold_amounts[i-1], gold_collected)\n        gold_collected -= min(gold_amounts[i-1], gold_collected)\n\n    return str(gold_stolen)"
    },
    {
        "number": 3025,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    n, m = map(int, input().split())\n    gold = list(map(int, input().split()))\n    roads = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Initialize the graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Dijkstra's algorithm\n    def dijkstra(start: int) -> tuple:\n        visited = set()\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        heap = [(0, start)]\n        while heap:\n            d, u = heapq.heappop(heap)\n            if u in visited:\n                continue\n            visited.add(u)\n            for v in graph[u]:\n                alt = dist[u] + gold[v - 1]\n                if alt < dist[v]:\n                    dist[v] = alt\n                    heapq.heappush(heap, (alt, v))\n        return tuple(dist[2:])\n\n    # Calculate the maximum amount of gold\n    dist_home = dijkstra(1)\n    dist_castle = dijkstra(2)\n    dist_villages = [dijkstra(i) for i in range(3, n + 1)]\n    max_gold = 0\n    for i in range(1, n - 1):\n        for j in range(i + 1, n):\n            total_gold = 0\n            for k in range(1, n + 1):\n                if k == i or k == j:\n                    continue\n                total_gold += min(dist_home[k - 1] + gold[k - 1], dist_castle[k - 1] + gold[k - 1])\n            max_gold = max(max_gold, total_gold)\n\n    return str(max_gold) "
    },
    {
        "number": 3025,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    g = list(map(int, stdin.split()[2:]))\n    roads = []\n    for _ in range(m):\n        a, b = map(int, stdin.split()[2:])\n        roads.append((a, b))\n        roads.append((b, a))\n\n    def dfs(start: int, end: int, visited: set, gold: int) -> int:\n        if start == end:\n            return gold\n        visited.add(start)\n        max_gold = 0\n        for road in roads:\n            if road[0] == start and road[1] not in visited:\n                max_gold = max(max_gold, dfs(road[1], end, visited, gold))\n            elif road[1] == start and road[0] not in visited:\n                max_gold = max(max_gold, dfs(road[0], end, visited, gold))\n        visited.remove(start)\n        return max_gold\n\n    max_gold = dfs(1, 2, set(), 0)\n    max_gold += sum(g[2:])\n    return str(max_gold)"
    },
    {
        "number": 3026,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n = int(stdin.readline())\n    sequence = list(map(int, stdin.readline().split()))\n\n    # initialize lis_len and lis array\n    lis_len = [1] * n\n    lis = [-1] * n\n    lis[0] = sequence[0]\n\n    # compute lis and lis_len\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j] and lis_len[i] < lis_len[j] + 1:\n                lis_len[i] = lis_len[j] + 1\n                lis[i] = j\n        if lis_len[i] == 1:\n            lis[i] = -1\n\n    # compute critical elements\n    critical = set()\n    for i in range(n):\n        if lis[i] != -1 and lis_len[i] == lis_len[lis[i]] + 1:\n            critical.add(i)\n\n    # sort critical elements and output\n    return \" \".join(map(str, sorted(critical))) if critical else \"-1\""
    },
    {
        "number": 3026,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    sequence = stdin.split(\"\\n\")[1].split(\" \")\n    \n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if int(sequence[i]) > int(sequence[j]):\n                lis[i] = max(lis[i], lis[j] + 1)\n                \n    max_length = max(lis)\n    \n    critical_elements = []\n    for i in range(n):\n        if lis[i] == max_length:\n            critical_elements.append(sequence[i])\n            \n    if not critical_elements:\n        return \"-1\"\n    \n    return \" \".join(critical_elements)"
    },
    {
        "number": 3026,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n\n    # Initialize the LIS array with all 1s\n    lis = [1] * n\n\n    # Compute the LIS array\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Find the critical elements\n    critical_elements = []\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j] and lis[i] == lis[j] + 1:\n                critical_elements.append(sequence[j])\n\n    # Sort and return the critical elements\n    critical_elements.sort()\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, critical_elements))"
    },
    {
        "number": 3026,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = list(map(int, stdin.split('\\n')[1].split()))\n    \n    # Initialize the LIS array and the include array\n    lis = [1] * n\n    include = [True] * n\n    \n    # Iterate through the sequence from left to right\n    for i in range(n):\n        # Iterate through the sequence from right to left\n        for j in range(i):\n            # If the current element is greater than the previous element and the length of the LIS of the current element is less than the LIS of the previous element plus 1, update the LIS and include the current element\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n                include[i] = True\n    \n    # Initialize the critical elements list\n    critical_elements = []\n    \n    # Iterate through the sequence from left to right\n    for i in range(n):\n        # If the LIS of the current element is less than the LIS of the previous element, the current element is critical, add it to the critical elements list\n        if i > 0 and lis[i] < lis[i-1]:\n            critical_elements.append(sequence[i])\n    \n    # If there are no critical elements, output -1\n    if len(critical_elements) == 0:\n        return \"-1\"\n    \n    # Otherwise, output the critical elements in ascending order\n    return \" \".join(map(str, critical_elements))"
    },
    {
        "number": 3026,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    n = int(input_lines[0])\n    sequence = list(map(int, input_lines[1].split()))\n\n    # Helper function to compute the length of LIS\n    def lis_length(sequence):\n        tails = [0] * len(sequence)\n        size = 0\n        for x in sequence:\n            i, j = 0, size\n            while i < j:\n                mid = (i + j) // 2\n                if tails[mid] < x:\n                    i = mid + 1\n                else:\n                    j = mid\n            tails[i] = x\n            size = max(size, i + 1)\n        return size\n\n    # Helper function to check if removing an element decreases LIS length\n    def is_critical(sequence, index):\n        new_sequence = sequence[:index] + sequence[index + 1:]\n        return lis_length(new_sequence) < lis_length(sequence)\n\n    critical_elements = []\n    for i in range(len(sequence)):\n        if is_critical(sequence, i):\n            critical_elements.append(sequence[i])\n\n    if critical_elements:\n        return \" \".join(map(str, critical_elements))\n    else:\n        return \"-1\""
    },
    {
        "number": 3026,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    sequence = input_list[1:]\n\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    critical_elements = [i + 1 for i in range(n) if lis[i] == max(lis)]\n\n    if critical_elements == list(range(1, n + 1)):\n        return \"-1\"\n    else:\n        return \" \".join(map(str, critical_elements))\n"
    },
    {
        "number": 3026,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n\n    # Create an auxiliary array to store the length of LIS for each element\n    lis_length = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j]:\n                lis_length[i] = max(lis_length[i], lis_length[j] + 1)\n\n    # Find all critical elements\n    critical_elements = []\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] < sequence[j] and lis_length[i] < lis_length[j]:\n                critical_elements.append(sequence[i])\n\n    # Output result\n    if len(critical_elements) == 0:\n        return \"-1\"\n    return \" \".join(map(str, sorted(critical_elements)))"
    },
    {
        "number": 3026,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input and split it into lines\n    lines = stdin.split('\\n')\n    \n    # The first line contains the length of the sequence\n    n = int(lines[0])\n    \n    # The second line contains the sequence\n    sequence = list(map(int, lines[1].split()))\n    \n    # Initialize an empty list to store the critical elements\n    critical_elements = []\n    \n    # Initialize a variable to store the length of the longest increasing subsequence\n    lis_length = 0\n    \n    # Initialize a list to store the lengths of the longest increasing subsequences for each element\n    lis_lengths = [1] * n\n    \n    # Iterate through the sequence and update the LIS lengths for each element\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j]:\n                lis_lengths[i] = max(lis_lengths[i], lis_lengths[j] + 1)\n                \n        # If the LIS length for the current element is less than or equal to the current LIS length,\n        # it means removing the current element will cause the LIS length to decrease,\n        # so we add it to the critical elements list\n        if lis_lengths[i] <= lis_length:\n            critical_elements.append(sequence[i])\n        else:\n            lis_length = lis_lengths[i]\n    \n    # If there are no critical elements, return \"-1\"\n    if not critical_elements:\n        return \"-1\"\n    \n    # Sort the critical elements in ascending order and return them\n    return ' '.join(map(str, sorted(critical_elements))) "
    },
    {
        "number": 3026,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    sequence = list(map(int, stdin.split(\"\\n\")[1].split()))\n    \n    def lis(sequence: List[int]) -> int:\n        tails = [0] * n\n        size = 0\n        for x in sequence:\n            i, j = 0, size\n            while i < j:\n                mid = (i + j) // 2\n                if tails[mid] < x:\n                    i = mid + 1\n                else:\n                    j = mid\n            tails[i] = x\n            size = max(size, i + 1)\n        return size\n    \n    critical_elements = []\n    for i in range(n):\n        sequence_without_i = sequence[:i] + sequence[i+1:]\n        if lis(sequence_without_i) < lis(sequence):\n            critical_elements.append(sequence[i])\n    \n    if len(critical_elements) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, critical_elements))"
    },
    {
        "number": 3026,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n\n    critical_elements = []\n\n    for i in range(n):\n        lis = [0] * n\n        for j in range(n):\n            if sequence[i] < sequence[j]:\n                lis[j] = max(lis[j], lis[i] + 1)\n        max_length = max(lis)\n        if max_length == 1:\n            critical_elements.append(sequence[i])\n\n    if not critical_elements:\n        return \"-1\"\n\n    return \" \".join(map(str, sorted(critical_elements)))\n"
    },
    {
        "number": 3027,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mark = []\n    \n    for i in range(n):\n        mark.append(stdin.split()[i])\n    \n    nubs = 0\n    for i in range(n):\n        for j in range(m):\n            if mark[i][j] == '#':\n                nubs += 1\n    \n    return str(nubs)\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    mark = []\n    \n    for i in range(n):\n        mark.append(stdin.split()[i+1])\n    \n    stamp = \"..#.. .###. .###. ..#..\"\n    stamp_count = mark.count(stamp)\n    if stamp_count == 1:\n        return str(8)\n    elif stamp_count == 2:\n        return str(12)\n    else:\n        return str(0)"
    },
    {
        "number": 3027,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    stamp = stdin.splitlines()[1:]\n\n    nubs = 0\n    for i in range(n):\n        for j in range(m):\n            if stamp[i][j] == '#':\n                nubs += 1\n\n    return str(nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    mark = [list(line.strip()) for line in stdin.split('\\n')[1:n+1]]\n\n    def count_nubs(stamp: List[str]) -> int:\n        nub_count = 0\n        for i in range(len(stamp)):\n            for j in range(len(stamp[0])):\n                if stamp[i][j] == '#':\n                    nub_count += 1\n        return nub_count\n\n    def stamp_twice(stamp: List[str]) -> List[List[str]]:\n        doubled_stamp = []\n        for i in range(2):\n            for row in stamp:\n                doubled_stamp.append(row.copy())\n        return doubled_stamp\n\n    min_nub_count = float('inf')\n    stamp_height = 2\n    stamp_width = 2\n    while stamp_height <= n and stamp_width <= m:\n        for i in range(m - stamp_width + 1):\n            for j in range(n - stamp_height + 1):\n                stamp = [mark[k][j:j+stamp_height] for k in range(j, j+stamp_height)]\n                doubled_stamp = stamp_twice(stamp)\n                for k in range(n):\n                    for l in range(m):\n                        if doubled_stamp[k][l] == '#' and mark[k][l] == '.':\n                            doubled_stamp[k][l] = '.'\n                if '#' not in ''.join([''.join(row) for row in doubled_stamp]):\n                    min_nub_count = min(min_nub_count, count_nubs(stamp))\n        stamp_height += 1\n        stamp_width += 1\n\n    return str(min_nub_count)\n\ninput_str = '''4 8\n..#..#..\n.######.\n.######.\n..#..#..'''\nprint(solution(input_str)) "
    },
    {
        "number": 3027,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    mark = stdin.readlines()\n\n    # Check if the mark is made by stamping side-by-side\n    nubs = 0\n    for i in range(n):\n        for j in range(m):\n            if mark[i][j] == '#':\n                nubs += 1\n    if nubs == 2:\n        return str(nubs)\n\n    # Check if the mark is made by stamping twice in the same position\n    nubs = 0\n    for i in range(n):\n        for j in range(m):\n            if mark[i][j] == '#':\n                nubs += 1\n            else:\n                nubs += 2\n    if nubs == 4:\n        return str(nubs)\n\n    # The mark is not made by stamping twice in the same position or side-by-side\n    return str(-1)"
    },
    {
        "number": 3027,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    n, m = map(int, stdin.splitlines()[0].split())\n    stamp = [list(line) for line in stdin.splitlines()[1:n+1]]\n\n    # Calculate the number of nubs on the stamp\n    nubs = sum(line.count('#') for line in stamp)\n\n    # Calculate the number of nubs on the mark\n    nub_count = sum(line.count('#') for line in stamp)\n\n    # Calculate the minimum number of nubs\n    min_nubs = n * m - nub_count\n\n    return str(min_nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input into lines\n    lines = stdin.split(\"\\n\")\n    \n    # Get the height and width of the mark\n    n, m = map(int, lines.pop(0).split())\n    \n    # Create the mark on the paper\n    mark = [line.strip() for line in lines]\n    \n    # Check if the mark has at least two '#' symbols\n    if mark.count(\"#\") < 2:\n        return \"Invalid input\"\n    \n    # Calculate the minimum number of nubs\n    min_nubs = m * n\n    for i in range(m):\n        for j in range(n):\n            if mark[j][i] == \"#\":\n                min_nubs -= 1\n    \n    return str(min_nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mark = [list(line.strip()) for line in stdin.split('\\n')[1:n+1]]\n    \n    # Count the number of black cells in the mark\n    nubs = 0\n    for row in mark:\n        for cell in row:\n            if cell == '#':\n                nubs += 1\n    \n    # Determine the number of black cells in the stamp\n    stamp_size = (2*n+1) * (2*m+1)\n    \n    # Calculate the minimum number of nubs in the stamp\n    min_nubs = (nubs * stamp_size) // (2*n*m)\n    \n    return str(min_nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x.strip()) for x in stdin.splitlines()[0].split()]\n    stamp_1 = [x.strip() for x in stdin.splitlines()[1:n+1]]\n    stamp_2 = [x.strip() for x in stdin.splitlines()[n+1:2*n+1]]\n\n    nubs_count = 0\n    for i in range(n):\n        for j in range(m):\n            if stamp_1[i][j] != stamp_2[i][j]:\n                nubs_count += 1\n\n    return str(nubs_count)"
    },
    {
        "number": 3027,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    mark = [stdin.readline()[:m] for _ in range(n)]\n\n    nub_count = 0\n    for row in mark:\n        nub_count += row.count('#')\n\n    return str(nub_count)"
    },
    {
        "number": 3028,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def win(board):\n        for row in board:\n            if all(c == p for c in row):\n                return True\n        for col in range(m):\n            if all(board[row][col] == p for row in range(n)):\n                return True\n        return False\n\n    def next_move(board, move):\n        new_board = [row.copy() for row in board]\n        row, col = move // m, move % m\n        new_board[row][col] = (new_board[row][col] % p) + 1\n        return new_board\n\n    n, m, p = map(int, stdin.split()[:3])\n    board = [[int(x) for x in stdin.split()[3:][i * m:i * m + m]] for i in range(n)]\n    move = 0\n    while move < p * m * n and not win(board):\n        board = next_move(board, move)\n        move += 1\n\n    if win(board):\n        return str(move + 1) + \"\\n\" + \" \".join(str(move) for move in range(1, move + 1))\n    else:\n        return \"-1\""
    },
    {
        "number": 3028,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, stdin.split()[i:i+m])) for i in range(n, n+m*n, m)]\n    \n    def is_winning(board: List[List[int]]) -> bool:\n        for row in board:\n            if all(cell == p for cell in row):\n                return True\n        for col in range(m):\n            if all(board[i][col] == p for i in range(n)):\n                return True\n        return False\n\n    def move(board: List[List[int]], row: int, col: int) -> None:\n        board[row][col] += 1\n        if board[row][col] > p:\n            board[row][col] = 1\n\n    def is_valid_move(board: List[List[int]], row: int, col: int) -> bool:\n        return 0 <= row < n and 0 <= col < m and board[row][col] != p\n\n    def make_move(board: List[List[int]], row: int, col: int) -> int:\n        move(board, row, col)\n        return 1 + make_move(board, (row + 1) % n, col) + make_move(board, (row - 1) % n, col) + make_move(board, row, (col + 1) % m) + make_move(board, row, (col - 1) % m)\n\n    for row in range(n):\n        for col in range(m):\n            if is_valid_move(board, row, col):\n                if is_winning(board):\n                    return str(1)\n                result = make_move(board, row, col)\n                if result == p * m * n:\n                    return str(result)\n                return str(-1)\n    return str(-1)"
    },
    {
        "number": 3028,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, stdin.split()[3:][i*m:(i+1)*m])) for i in range(n)]\n    \n    def check_win(board: List[List[int]]) -> bool:\n        for row in board:\n            if not all(x == p for x in row):\n                return False\n        return True\n    \n    def play_move(board: List[List[int]], row: int, col: int) -> List[List[int]]:\n        new_board = [[x+1 if x+1 <= p else 1 for x in row] for row in board]\n        new_board[row][col] = p\n        return new_board\n    \n    moves = []\n    for row in range(n):\n        for col in range(m):\n            for _ in range(p):\n                board = play_move(board, row, col)\n                moves.append((row+1)*m+col+1)\n                if check_win(board):\n                    return str(len(moves)) + \"\\n\" + \" \".join(map(str, moves))\n                \n    return \"-1\" "
    },
    {
        "number": 3028,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    def next_position(pos, direction):\n        row, col = pos\n        if direction == 0:\n            return (row, col - 1) if col > 0 else (row, m - 1)\n        elif direction == 1:\n            return (row - 1, col) if row > 0 else (n - 1, col)\n        elif direction == 2:\n            return (row, col + 1) if col < m - 1 else (row, 0)\n        else:\n            return (row + 1, col) if row < n - 1 else (0, col)\n\n    def wrap_around(board, row, col, p):\n        board[row][col] = 1 if board[row][col] == p else board[row][col] + 1\n        return board\n\n    def get_winner(board, p):\n        for row in range(n):\n            if all(x == p for x in board[row]):\n                return True\n        for col in range(m):\n            if all(board[row][col] == p for row in range(n)):\n                return True\n        return False\n\n    def print_board(board):\n        for row in board:\n            print(\" \".join(map(str, row)))\n\n    def play_game(board, p):\n        moves = []\n        visited = set()\n        for row in range(n):\n            for col in range(m):\n                if board[row][col] == 1:\n                    current_position = (row, col)\n                    moves.append(current_position)\n                    visited.add(current_position)\n                    break\n        for direction in range(4):\n            current_position = moves[-1]\n            next_position = current_position\n            while next_position != current_position:\n                next_position = next_position_in_direction(next_position, direction)\n                if next_position in visited:\n                    continue\n                visited.add(next_position)\n                moves.append(next_position)\n                if get_winner(board, p):\n                    break\n        return moves if get_winner(board, p) else []\n\n    if not get_winner(board, p):\n        moves = play_game(board, p)\n        if moves:\n            print(len(moves))\n            for move in moves:\n                board = wrap_around(board, move[0], move[1], p)\n            print_board(board)\n        else:\n            print(-1)\n    else:\n        print(0)\n        print_board(board)\n\ninput_str = \"\"\"4 5 5\n2 1 1 1 2\n5 3 4 4 3\n4 3 3 3 2\n3 1 3 3 1\"\"\"\nsolution(input_str) "
    },
    {
        "number": 3028,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:n+1]]\n    \n    # Helper functions\n    def is_winning(board: List[List[int]]) -> bool:\n        return all(all(cell == p for cell in row) for row in board)\n    \n    def perform_move(board: List[List[int]], cell: int) -> List[List[int]]:\n        new_board = [row[:] for row in board]\n        row, col = divmod(cell-1, m)\n        new_board[row][col] = (new_board[row][col] % p) + 1\n        return new_board\n    \n    # Check if initial board is already a winning board\n    if is_winning(board):\n        return \"0\\n\"\n    \n    # BFS to find a winning sequence\n    visited = set()\n    queue = [(board, 0)]\n    while queue:\n        board, moves = queue.pop(0)\n        for i in range(1, m*n+1):\n            new_board = perform_move(board, i)\n            if is_winning(new_board):\n                return str(moves+1) + \"\\n\" + \" \".join(map(str, range(1, m*n+1))) + \"\\n\"\n            if (new_board, moves+1) not in visited:\n                queue.append((new_board, moves+1))\n                visited.add((new_board, moves+1))\n    \n    # If no winning sequence exists, return -1\n    return \"-1\\n\" "
    },
    {
        "number": 3028,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, line.split())) for line in stdin.split()[3:]]\n    \n    def move(x, y, board):\n        board[x][y] = (board[x][y] + 1) % (p + 1)\n        if board[x][y] == 0:\n            board[x][y] = p\n        \n        return board\n    \n    def is_winning(board):\n        for i in range(n):\n            if board[i][0] != p:\n                return False\n        for j in range(m):\n            if board[0][j] != p:\n                return False\n        return True\n    \n    for x in range(n):\n        for y in range(m):\n            new_board = move(x, y, [row.copy() for row in board])\n            if is_winning(new_board):\n                return str(x * m + y + 1) + '\\n' + ' '.join([str(i) for row in new_board for i in row])\n    return \"-1\""
    },
    {
        "number": 3028,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, row.split())) for row in stdin.split('\\n')[1:]]\n\n    def is_winning_move(i: int, j: int, move: int) -> bool:\n        row = board[i]\n        col = [board[k][j] for k in range(n)]\n\n        if row.count(move) + col.count(move) == n + m:\n            return True\n        return False\n\n    def find_winning_move() -> int:\n        for i in range(n):\n            for j in range(m):\n                for move in range(1, p + 1):\n                    if is_winning_move(i, j, move):\n                        return move\n        return -1\n\n    def apply_move(i: int, j: int, move: int) -> None:\n        row = board[i]\n        col = [board[k][j] for k in range(n)]\n\n        for k in range(n):\n            row[k] = (row[k] + move - 1) % p + 1\n\n        for k in range(n):\n            board[k][j] = (board[k][j] + move - 1) % p + 1\n\n    def print_board() -> str:\n        return ' '.join([str(x) for row in board for x in row])\n\n    move = find_winning_move()\n    if move == -1:\n        return \"-1\\n\"\n\n    count = 0\n    while move != p:\n        i, j = divmod(count, m)\n        apply_move(i, j, move)\n        count += 1\n        move = find_winning_move()\n\n    return str(count) + '\\n' + print_board()"
    },
    {
        "number": 3028,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n\n    def next_move(i: int, j: int, moves: int) -> int:\n        if board[i][j] == p:\n            board[i][j] = 1\n        else:\n            board[i][j] += 1\n        for k in range(n):\n            board[k][j] = (board[k][j] - 1) % p + 1\n        for k in range(m):\n            board[i][k] = (board[i][k] - 1) % p + 1\n        return moves + 1\n\n    def is_won(board: List[List[int]]) -> bool:\n        return all(all(cell == p for cell in row) for row in board)\n\n    def find_winning_sequence(board: List[List[int]], moves: int) -> int:\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    new_board = [row.copy() for row in board]\n                    new_moves = next_move(i, j, moves)\n                    if is_won(new_board):\n                        return new_moves\n                    else:\n                        result = find_winning_sequence(new_board, new_moves)\n                        if result != -1:\n                            return result\n        return -1\n\n    moves = find_winning_sequence(board, 0)\n    if moves != -1:\n        result = [str(move) for row in board for move in row]\n        return f\"{moves}\\n{' '.join(result)}\"\n    else:\n        return \"-1\""
    },
    {
        "number": 3028,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def prime_numbers(n):\n        primes = [True] * (n + 1)\n        primes[0] = primes[1] = False\n        for i in range(2, int(n**0.5) + 1):\n            if primes[i]:\n                for j in range(i * i, n + 1, i):\n                    primes[j] = False\n        return [i for i in range(2, n + 1) if primes[i]]\n\n    def is_winning_board(board, p):\n        return all(cell == p for row in board for cell in row)\n\n    def increment_board(board, row, col, p):\n        for i in range(len(board)):\n            board[i][col] = (board[i][col] % p) + 1\n            board[row][i] = (board[row][i] % p) + 1\n        return board\n\n    def find_winning_sequence(board, p, moves):\n        if is_winning_board(board, p):\n            return moves\n        if len(moves) >= p * len(board) * len(board[0]):\n            return -1\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] != p:\n                    new_board = [row[:] for row in board]\n                    new_board = increment_board(new_board, i, j, p)\n                    new_moves = moves + [i * len(board[0]) + j + 1]\n                    result = find_winning_sequence(new_board, p, new_moves)\n                    if result != -1:\n                        return result\n        return -1\n\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, stdin.split()[i * m:(i + 1) * m])) for i in range(n)]\n\n    winning_sequence = find_winning_sequence(board, p, [])\n    if winning_sequence == -1:\n        return \"-1\"\n    return str(len(winning_sequence)) + \"\\n\" + \" \".join(map(str, winning_sequence)) "
    },
    {
        "number": 3028,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_right(p: int, num: int) -> int:\n        return num - (num // p) * p + 1 if num % p != 0 else p\n\n    def check_winner(board: List[List[int]]) -> bool:\n        return all(row[i] == p for row in board for i in range(len(row)))\n\n    def get_moves(board: List[List[int]]) -> List[int]:\n        moves = []\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    board[i][j] += 1\n                    moves.append(i * m + j + 1)\n                    if check_winner(board):\n                        return moves\n                    board[i][j] = rotate_right(p, board[i][j])\n                else:\n                    board[i][j] = 1\n        return []\n\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:n + 1]]\n\n    if not all(1 <= num <= p for row in board for num in row):\n        return \"-1\"\n\n    moves = get_moves(board)\n    if moves:\n        return str(len(moves)) + \"\\n\" + \" \".join(map(str, moves))\n    else:\n        return \"-1\""
    },
    {
        "number": 3029,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input and parse it into variables\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    labels = [int(x) for x in lines[1:n+1]]\n    adj_list = [int(x) for x in lines[n+1:]]\n    root = 0\n    \n    # Helper function to find the parent of a node\n    def find_parent(node: int) -> int:\n        if node == root:\n            return -1\n        return adj_list[node]\n    \n    # Helper function to find the depth of a node (number of edges from root)\n    def find_depth(node: int) -> int:\n        depth = 0\n        while node != root:\n            depth += 1\n            node = find_parent(node)\n        return depth\n    \n    # Helper function to find the longest increasing path from the root\n    def find_longest_increasing_path(node: int) -> int:\n        path_length = 0\n        for child in adj_list[node]:\n            if child != find_parent(child):\n                depth = find_depth(child)\n                if labels[child] > labels[node]:\n                    path_length = max(path_length, depth + find_longest_increasing_path(child))\n        return path_length\n    \n    # Find the longest increasing path from the root\n    longest_increasing_path = find_longest_increasing_path(root)\n    \n    # Helper function to count the number of increasing paths of a certain length\n    def count_increasing_paths(length: int) -> int:\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if labels[i] < labels[j] and find_depth(i) == length and find_depth(j) == length:\n                    count += 1\n        return count\n    \n    # Count the number of increasing paths of the longest length\n    increasing_paths = count_increasing_paths(longest_increasing_path)\n    \n    # Calculate the remainder of increasing_paths modulo 11092019\n    remainder = increasing_paths % 11092019\n    \n    return f\"{longest_increasing_path} {remainder}\""
    },
    {
        "number": 3029,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def read_tree(n: int, stdin: str) -> list:\n        lines = stdin.split('\\n')\n        labels = [int(lines[i]) for i in range(1, n+1)]\n        tree = [[] for _ in range(n)]\n        for i in range(2, n+1):\n            parent = int(lines[i])\n            if parent != 0:\n                tree[parent-1].append(i-1)\n        return labels, tree\n\n    def find_jumping_paths(labels: list, tree: list) -> list:\n        def dfs(v: int, parent: int, path: list, paths: list) -> None:\n            path.append(v)\n            for u in tree[v]:\n                if u != parent:\n                    dfs(u, v, path[:], paths)\n            if len(tree[v]) == 0:\n                paths.append(path[:])\n\n        paths = []\n        for i in range(len(tree)):\n            dfs(i, -1, [], paths)\n        return paths\n\n    def longest_increasing_path(labels: list, paths: list) -> int:\n        longest = 0\n        for path in paths:\n            is_increasing = True\n            for i in range(len(path)-1):\n                if labels[path[i]] > labels[path[i+1]]:\n                    is_increasing = False\n                    break\n            longest = max(longest, is_increasing * len(path))\n        return longest\n\n    n = int(lines[0])\n    labels, tree = read_tree(n, stdin)\n    paths = find_jumping_paths(labels, tree)\n    longest = longest_increasing_path(labels, paths)\n    return f\"{longest} {len(paths) % 11092019}\""
    },
    {
        "number": 3029,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    labels = [int(line) for line in stdin.split(\"\\n\")[1:N+1]]\n    parent = [-1] * N\n    for i in range(2, N+1):\n        parent[i-1] = int(stdin.split(\"\\n\")[i])\n\n    # Calculate the depth of each vertex\n    depth = [0] * N\n    depth[0] = 0\n    for i in range(1, N):\n        depth[i] = depth[parent[i]] + 1\n\n    # Calculate the maximum depth\n    L = 0\n    for i in range(1, N):\n        L = max(L, depth[i])\n\n    # Calculate the number of paths of length L with nondecreasing labels\n    M = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if depth[i] == L and depth[j] == L:\n                if labels[i] <= labels[j]:\n                    M += 1\n\n    # Calculate the remainder of M when divided by 11092019\n    M %= 11092019\n\n    return f\"{L} {M}\""
    },
    {
        "number": 3029,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent: List[int], x: int, y: int) -> int:\n        if parent[x] == x:\n            return x\n        parent[x] = find(parent, parent[x], y)\n        return parent[x]\n\n    def union(parent: List[int], rank: List[int], x: int, y: int) -> None:\n        x_root = find(parent, x, y)\n        y_root = find(parent, y, y)\n\n        if x_root == y_root:\n            return\n\n        if rank[x_root] < rank[y_root]:\n            parent[x_root] = y_root\n        elif rank[x_root] > rank[y_root]:\n            parent[y_root] = x_root\n        else:\n            parent[y_root] = x_root\n            rank[x_root] += 1\n\n    def find_jumping_paths(parent: List[int], u: List[int]) -> List[List[int]]:\n        paths = []\n        for i in range(1, N + 1):\n            path = [i]\n            j = i\n            while j != 1:\n                j = parent[j]\n                if u[j] > u[path[-1]]:\n                    path.append(j)\n            paths.append(path[::-1])\n        return paths\n\n    def longest_increasing_path(paths: List[List[int]]) -> Tuple[int, List[int]]:\n        longest_path = []\n        for path in paths:\n            if len(longest_path) < len(path) and all(u[longest_path[i]] <= u[path[i]] for i in range(len(longest_path))):\n                longest_path = path\n        return len(longest_path), longest_path\n\n    N = int(stdin.readline())\n    u = list(map(int, stdin.readlines()))\n    parent = [i for i in range(N + 1)]\n    rank = [0] * (N + 1)\n\n    for i in range(N - 1):\n        p, c = map(int, stdin.readline().split())\n        union(parent, rank, p, c)\n\n    paths = find_jumping_paths(parent, u)\n    L, longest_path = longest_increasing_path(paths)\n    M = len([path for path in paths if path == longest_path])\n\n    return f\"{L} {M % 11092019}\""
    },
    {
        "number": 3029,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    labels = list(map(int, stdin.readline().split()))\n    adj_list = [[] for _ in range(N)]\n    for i in range(2, N):\n        parent = int(stdin.readline())\n        adj_list[parent].append(i)\n\n    def dfs(node, parent):\n        nonlocal L, M\n        visited.add(node)\n        for child in adj_list[node]:\n            if child != parent:\n                dfs(child, node)\n\n        dp = [0] * (L + 1)\n        dp[0] = 1\n        for i in range(1, L + 1):\n            for j in range(i):\n                if labels[node] - labels[a[j]] <= i - j:\n                    dp[i] += dp[j]\n\n        M += dp[L]\n\n    visited = set()\n    L = 0\n    M = 0\n    for i in range(1, N):\n        if i not in visited:\n            a = []\n            dfs(i, None)\n            if len(a) > L:\n                L = len(a)\n\n    return str(L) + \" \" + str(M % 11092019)"
    },
    {
        "number": 3029,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u, parent):\n        nonlocal tree, labels, L, M, paths\n        children = [v for v in tree[u] if v != parent]\n        for v in children:\n            dfs(v, u)\n            for path in paths[u]:\n                paths[v].append(path + [u])\n            if labels[u] <= labels[v]:\n                for path in paths[u]:\n                    if labels[u] <= labels[path[-1]]:\n                        L = max(L, len(path + [v]))\n                        M += 1\n                        paths[v].append(path + [v])\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def prime_factorization(n: int) -> int:\n        result = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0 and is_prime(i):\n                count = 0\n                while n % i == 0:\n                    n //= i\n                    count += 1\n                result *= (i**count)\n        if n != 1 and is_prime(n):\n            result *= n\n        return result\n\n    N = int(stdin.pop(0))\n    labels = list(map(int, stdin[:N]))\n    stdin = stdin[N:]\n    tree = [[] for _ in range(N)]\n    for i in range(1, N):\n        parent = int(stdin.pop(0)) - 1\n        tree[parent].append(i)\n\n    paths = [[] for _ in range(N)]\n    dfs(0, -1)\n\n    return f\"{L} {M % prime_factorization(11092019)}\""
    },
    {
        "number": 3029,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    u = [int(u) for u in lines[1:N+1]]\n    parents = [int(p) for p in lines[N+1:]]\n\n    def dfs(node: int, parent: int) -> int:\n        depth = 1\n        for child in children[node]:\n            if child != parent:\n                depth = max(depth, dfs(child, node) + 1)\n        return depth\n\n    children = [[] for _ in range(N)]\n    for i in range(1, N):\n        children[parents[i-1]].append(i)\n\n    L = max(dfs(i, -1) for i in range(1, N))\n    M = 0\n\n    def count_jumping_paths(node: int, parent: int, depth: int) -> int:\n        nonlocal M\n        M += depth\n        for child in children[node]:\n            if child != parent:\n                count_jumping_paths(child, node, depth + 1)\n\n    count_jumping_paths(1, -1, 0)\n    M %= 11092019\n\n    return f\"{L} {M}\""
    },
    {
        "number": 3029,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    labels = [int(x) for x in lines[1:N+1]]\n    parents = [int(x) - 1 for x in lines[N+1:]]\n\n    # Build the tree\n    tree = [[] for _ in range(N)]\n    for i in range(N):\n        if i > 0:\n            tree[parents[i]].append(i)\n\n    # Define a recursive function to find the longest path\n    def find_longest_path(node: int) -> int:\n        nonlocal max_path, labels\n        max_length = 1\n        for child in tree[node]:\n            child_length = find_longest_path(child)\n            if labels[node] <= labels[child]:\n                max_length = max(max_length, child_length + 1)\n        max_path[node] = max_length\n        return max_length\n\n    # Find the longest path for each node\n    max_path = [0] * N\n    for node in range(N):\n        find_longest_path(node)\n\n    # Count the number of paths of length L\n    L = max(max_path)\n    M = sum(1 for x in max_path if x == L)\n\n    # Compute the remainder of M modulo 11092019\n    prime = 11092019\n    M = M % prime\n\n    return f\"{L} {M}\" "
    },
    {
        "number": 3029,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent, graph):\n        depth[node] = depth[parent] + 1\n        for child in graph[node]:\n            if child != parent:\n                dfs(child, node, graph)\n                jumping_paths[node][child] = jumping_paths[parent][child] + [node]\n                for i in range(depth[child]):\n                    if u[node] <= u[jumping_paths[node][child][i]]:\n                        longest_path[node] = max(longest_path[node], depth[child] - i)\n                        non_decreasing_paths[node][child][i] += non_decreasing_paths[parent][child][i]\n\n    def longest_jumping_path(node):\n        if longest_path[node] > 0:\n            return longest_path[node]\n        for child in graph[node]:\n            if child != parent:\n                longest_path[node] = max(longest_path[node], longest_jumping_path(child))\n        return longest_path[node]\n\n    def count_non_decreasing_paths(node, depth):\n        if depth == 0:\n            return 1\n        count = 0\n        for child in graph[node]:\n            if child != parent:\n                count += count_non_decreasing_paths(child, depth - 1)\n        return count\n\n    N = int(stdin.readline().strip())\n    u = list(map(int, stdin.readlines()))\n    graph = [[] for _ in range(N)]\n    for i in range(N - 1):\n        parent = int(stdin.readline().strip())\n        graph[parent].append(i + 1)\n\n    depth = [0] * N\n    jumping_paths = [[[] for _ in range(N)] for _ in range(N)]\n    longest_path = [0] * N\n    non_decreasing_paths = [[[0] * N for _ in range(N)] for _ in range(N)]\n\n    dfs(1, 0, graph)\n    for i in range(2, N):\n        longest_jumping_path(i)\n\n    M = count_non_decreasing_paths(1, longest_path[1])\n    return f\"{longest_path[1]} {M % 11092019}\"\n\ninputs = [\n    \"\"\"5\n3\n3\n3\n3\n3\n1\n2\n3\n4\"\"\",\n    \"\"\"5\n4\n3\n2\n1\n0\n1\n2\n3\n4\"\"\",\n    \"\"\"4\n1\n5\n3\n6\n1\n2\n3\"\"\"\n]\n\noutputs = [\n    \"5 1\",\n    \"1 5\",\n    \"3 2\"\n]\n\nfor i, input_str in enumerate(inputs):\n    assert solution(input_str) == outputs[i] "
    },
    {
        "number": 3029,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    u = [int(x) for x in lines[1:n+1]]\n    edges = []\n    for i in range(2, n+1):\n        edges.append((int(lines[i])-1, i-1))\n    \n    def dfs(node, parent, visited):\n        visited.add(node)\n        for child in graph[node]:\n            if child != parent:\n                dfs(child, node, visited)\n        return visited\n    \n    def get_jumping_paths(node, visited):\n        nonlocal result\n        visited.add(node)\n        for child in graph[node]:\n            if child not in visited:\n                result += 1\n                get_jumping_paths(child, visited)\n        visited.remove(node)\n    \n    graph = [[] for _ in range(n)]\n    for a, b in edges:\n        graph[a].append(b)\n    \n    L = 0\n    M = 0\n    result = 0\n    for i in range(n):\n        if i not in visited:\n            visited = dfs(i, -1, set())\n            for j in range(1, len(visited)):\n                L = max(L, j)\n                get_jumping_paths(visited[j], visited)\n                M += result\n                result = 0\n    \n    return f\"{L} {M % 11092019}\""
    },
    {
        "number": 3030,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    nodes = {}\n    for i in range(1, n + 1):\n        v, p = map(int, stdin.split(\"\\n\")[i].split())\n        nodes[i] = {\"v\": v, \"p\": p}\n\n    max_heap_size = 0\n    for i in range(2, n + 1):\n        max_heap_size = max(max_heap_size, dfs(i, nodes))\n\n    return str(max_heap_size)\n\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    nodes = []\n    for i in range(1, n + 1):\n        v, p = map(int, stdin.split()[i].split())\n        nodes.append((i, v, p))\n\n    def dfs(node, subset):\n        if node not in subset:\n            subset.add(node)\n            for child in nodes:\n                if child[2] == node[0]:\n                    dfs(child, subset)\n\n    best_subset = set()\n    for i in range(1, n + 1):\n        subset = set()\n        dfs(nodes[i - 1], subset)\n        if len(subset) > len(best_subset):\n            best_subset = subset\n\n    return str(len(best_subset))"
    },
    {
        "number": 3030,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    nodes = []\n    for i in range(1, n+1):\n        value, parent = map(int, lines[i].split())\n        nodes.append((value, parent))\n    \n    max_count = 0\n    for subset in itertools.product([0, 1], repeat=n):\n        subset_count = sum(subset)\n        if subset_count > max_count and is_valid_subset(nodes, subset):\n            max_count = subset_count\n    \n    return str(max_count)\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    node_values = []\n    parents = []\n    for i in range(1, n + 1):\n        v, p = map(int, lines[i].split())\n        node_values.append(v)\n        parents.append(p)\n\n    def find_heap_nodes(node: int, visited: set) -> set:\n        if node == 0 or node in visited:\n            return visited\n        visited.add(node)\n        for child in range(1, node + 1):\n            if parents[child - 1] == node:\n                find_heap_nodes(child, visited)\n        return visited\n\n    max_nodes = 0\n    for i in range(1, n + 1):\n        heap_nodes = find_heap_nodes(i, set())\n        if len(heap_nodes) > max_nodes:\n            max_nodes = len(heap_nodes)\n\n    return str(max_nodes)"
    },
    {
        "number": 3030,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, parent: int) -> int:\n        max_value = value[node]\n        max_children = 0\n\n        for child in graph[node]:\n            if child != parent:\n                child_value, child_children = dfs(child, node)\n                if child_value > max_value or (child_value == max_value and child_children > max_children):\n                    max_value = child_value\n                    max_children = child_children\n\n        return max_value, max_children + 1\n\n    n = int(stdin.readline())\n    graph = [[] for _ in range(n)]\n    value = [0] * n\n\n    for i in range(1, n + 1):\n        v, p = map(int, stdin.readline().split())\n        value[i] = v\n        graph[p].append(i)\n\n    _, result = dfs(1, 0)\n    return str(result)"
    },
    {
        "number": 3030,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    nodes = []\n    for _ in range(n):\n        v, p = map(int, stdin.readline().strip().split())\n        nodes.append((v, p, p))\n\n    def dfs(node: int) -> int:\n        max_child = node\n        for child in range(n):\n            if nodes[child][2] == node and nodes[child][0] > nodes[max_child][0]:\n                max_child = child\n        if max_child != node:\n            nodes[node], nodes[max_child] = nodes[max_child], nodes[node]\n            dfs(max_child)\n        return max_child\n\n    max_subset = 0\n    for node in range(1, n):\n        if nodes[node][0] > nodes[dfs(node)][0]:\n            max_subset += 1\n\n    return str(max_subset)"
    },
    {
        "number": 3030,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    nodes = {}\n    for i in range(1, n+1):\n        nodes[i] = {'value': int(stdin.split('\\n')[i].split(' ')[0]), 'parent': int(stdin.split('\\n')[i].split(' ')[1]), 'children': []}\n    for i in range(1, n+1):\n        nodes[nodes[i]['parent']]['children'].append(i)\n    \n    def find_heap_subset(node):\n        max_subset = [node]\n        for child in nodes[node]['children']:\n            max_child_subset = find_heap_subset(child)\n            if len(max_child_subset) > len(max_subset) and nodes[node]['value'] > nodes[child]['value']:\n                max_subset = max_child_subset\n        return max_subset\n    \n    max_heap_subset = []\n    for i in range(1, n+1):\n        if not nodes[i]['children']:\n            max_heap_subset = find_heap_subset(i)\n            if len(max_heap_subset) > len(max_heap_subset):\n                max_heap_subset = max_heap_subset\n    \n    return str(len(max_heap_subset))"
    },
    {
        "number": 3030,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    nodes = []\n    for i in range(1, n+1):\n        v, p = map(int, stdin.split('\\n')[i].split())\n        nodes.append({\"id\": i, \"value\": v, \"parent\": p+1})\n\n    def get_heap_size(node: dict, nodes: list, visited: set) -> int:\n        if node[\"id\"] in visited:\n            return 0\n        visited.add(node[\"id\"])\n        size = 1\n        for child in nodes:\n            if child[\"parent\"] == node[\"id\"]:\n                size += get_heap_size(child, nodes, visited)\n        return size\n\n    max_size = 0\n    for i in range(1, n+1):\n        max_size = max(max_size, get_heap_size(nodes[i-1], nodes, set()))\n\n    return str(max_size)"
    },
    {
        "number": 3030,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    nodes = {}\n    for i in range(1, n + 1):\n        v, p = map(int, stdin.split('\\n')[i].split())\n        nodes[i] = {'value': v, 'parent': p + 1, 'children': []}\n\n    for i in range(1, n + 1):\n        if nodes[i]['parent'] != 0:\n            nodes[nodes[i]['parent']]['children'].append(i)\n\n    def dfs(node: int) -> int:\n        if len(nodes[node]['children']) == 0:\n            return 1\n        else:\n            return 1 + max(dfs(child) for child in nodes[node]['children'])\n\n    max_count = 0\n    for i in range(1, n + 1):\n        count = dfs(i)\n        if count > max_count:\n            max_count = count\n\n    return str(max_count)"
    },
    {
        "number": 3030,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    nodes = []\n    \n    for i in range(n):\n        v, p = map(int, stdin.readline().strip().split())\n        nodes.append((i+1, v, p+1))\n    \n    def is_heap(node):\n        for child in nodes:\n            if child[2] == node[0]:\n                if child[1] > node[1]:\n                    return False\n                if not is_heap(child):\n                    return False\n        return True\n    \n    max_heap_size = 0\n    for i in range(n):\n        node = nodes[i]\n        if is_heap(node):\n            heap_size = 1\n            for child in nodes:\n                if child[2] == node[0]:\n                    heap_size += 1\n            max_heap_size = max(max_heap_size, heap_size)\n    \n    return str(max_heap_size)"
    },
    {
        "number": 3031,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, good_nodes):\n        visited.add(node)\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, good_nodes)\n        if len(visited) == n:\n            is_rainbow = True\n            for neighbor in adj_list[node]:\n                if edges[node][neighbor] == edges[node][node]:\n                    is_rainbow = False\n                    break\n            if is_rainbow:\n                good_nodes.add(node)\n\n    stdin = stdin.split('\\n')\n    n = int(stdin[0])\n    adj_list = [[] for _ in range(n)]\n    edges = {}\n    for i in range(1, n):\n        a, b, c = map(int, stdin[i].split())\n        adj_list[a - 1].append(b - 1)\n        adj_list[b - 1].append(a - 1)\n        edges[a - 1] = {b - 1: c}\n        edges[b - 1] = {a - 1: c}\n\n    good_nodes = set()\n    dfs(0, set(), good_nodes)\n    return str(len(good_nodes)) + '\\n' + '\\n'.join(map(str, sorted(good_nodes)))"
    },
    {
        "number": 3031,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    good_nodes = set()\n\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            rainbow = True\n            path = [i]\n            while path[-1] != j:\n                neighbors = [edge[1] for edge in edges if edge[0] == path[-1]]\n                if len(neighbors) == 0:\n                    break\n                next_node = neighbors[0]\n                for neighbor in neighbors[1:]:\n                    if (path[-1], neighbor) in edges or (neighbor, path[-1]) in edges:\n                        if next_node == neighbor:\n                            rainbow = False\n                            break\n                        else:\n                            next_node = neighbor\n                path.append(next_node)\n            if rainbow:\n                good_nodes.add(i)\n                good_nodes.add(j)\n\n    return f\"{len(good_nodes)}\\n{' '.join(map(str, sorted(good_nodes)))}\"\n\ndef"
    },
    {
        "number": 3031,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    edges = [list(map(int, stdin.readline().split())) for _ in range(n - 1)]\n    graph = [[] for _ in range(n + 1)]\n    for a, b, c in edges:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    def dfs(node: int, parent: int, color: int, visited: set) -> None:\n        visited.add(node)\n        for neighbor, new_color in graph[node]:\n            if neighbor != parent and new_color != color and neighbor not in visited:\n                dfs(neighbor, node, new_color, visited)\n\n    good_nodes = []\n    for i in range(1, n + 1):\n        visited = set()\n        dfs(i, -1, -1, visited)\n        if len(visited) == n:\n            good_nodes.append(i)\n\n    return str(len(good_nodes)) + \"\\n\" + \"\\n\".join(map(str, good_nodes)) + \"\\n\"\n\nwith open(\"input.txt\", \"r\") as stdin, open(\"output.txt\", \"w\") as stdout:\n    stdout.write(solution(stdin)) "
    },
    {
        "number": 3031,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    graph = [[] for _ in range(n+1)]\n    for i in range(n-1):\n        a, b, c = map(int, stdin.splitlines()[i+1].split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n    \n    def dfs(node: int, color: int) -> bool:\n        visited[node] = True\n        good_children = 0\n        for neighbor, c in graph[node]:\n            if not visited[neighbor]:\n                if c != color:\n                    good_children += dfs(neighbor, c)\n                else:\n                    return False\n        return good_children >= 1\n    \n    good_nodes = []\n    for i in range(1, n+1):\n        if not dfs(i, 1):\n            good_nodes.append(i)\n    \n    return str(len(good_nodes)) + \"\\n\" + \"\\n\".join(map(str, sorted(good_nodes)))"
    },
    {
        "number": 3031,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    graph = [[] for _ in range(n+1)]\n    for line in stdin.split(\"\\n\")[1:]:\n        if line == \"\":\n            continue\n        a, b, c = map(int, line.split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n    \n    def dfs(node, color):\n        visited[node] = True\n        for neighbor, neighbor_color in graph[node]:\n            if not visited[neighbor]:\n                if neighbor_color == color:\n                    return False\n                if dfs(neighbor, neighbor_color):\n                    return False\n        return True\n    \n    good_nodes = []\n    for i in range(1, n+1):\n        visited = [False] * (n+1)\n        if dfs(i, 1):\n            good_nodes.append(i)\n    \n    return str(len(good_nodes)) + \"\\n\" + \"\\n\".join(map(str, good_nodes))"
    },
    {
        "number": 3031,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = stdin.split('\\n')[1:]\n    adj_list = {i: [] for i in range(1, n+1)}\n    for edge in edges:\n        u, v, c = list(map(int, edge.split()))\n        adj_list[u].append((v, c))\n        adj_list[v].append((u, c))\n    \n    def dfs(node, visited, parent, color):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor, c in adj_list[node]:\n            if neighbor != parent:\n                if c == color:\n                    return False\n                if not dfs(neighbor, visited, node, c):\n                    return False\n        return True\n    \n    good_nodes = []\n    for i in range(1, n+1):\n        if dfs(i, set(), -1, -1):\n            good_nodes.append(i)\n    \n    return str(len(good_nodes)) + '\\n' + '\\n'.join(map(str, good_nodes))"
    },
    {
        "number": 3031,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    from collections import defaultdict\n\n    def is_rainbow(path: str) -> bool:\n        colors = set()\n        for edge in path:\n            colors.add(edge)\n        return len(colors) == len(path)\n\n    def dfs(node: int, graph: defaultdict, visited: set, path: list, paths: list):\n        visited.add(node)\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, graph, visited, path, paths)\n        visited.remove(node)\n        path.pop()\n\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    graph = defaultdict(list)\n    for a, b, c in edges:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    good_nodes = []\n    for node in range(1, n + 1):\n        visited = set()\n        paths = []\n        dfs(node, graph, visited, [], paths)\n        rainbow_paths = [path for path in paths if is_rainbow(path)]\n        if len(rainbow_paths) == len(paths):\n            good_nodes.append(node)\n\n    return str(len(good_nodes)) + \"\\n\" + \"\\n\".join(map(str, good_nodes))"
    },
    {
        "number": 3031,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    n = int(stdin.split()[0])\n    edges = defaultdict(set)\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            a, b, c = map(int, line.split())\n            edges[a].add((b, c))\n            edges[b].add((a, c))\n    \n    def dfs(node, parent, color, rainbow_edges):\n        if node in rainbow_edges:\n            return False\n        rainbow_edges.add(node)\n        for neighbor, c in edges[node]:\n            if neighbor != parent and c != color:\n                if dfs(neighbor, node, c, rainbow_edges):\n                    return True\n        rainbow_edges.remove(node)\n        return False\n    \n    good_nodes = []\n    for node in range(1, n + 1):\n        if all(dfs(node, None, i, set()) for i in range(1, n + 1)):\n            good_nodes.append(node)\n    \n    return f\"{len(good_nodes)}\\n{' '.join(map(str, good_nodes))}\" "
    },
    {
        "number": 3031,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = {}\n    for edge in stdin.split('\\n')[1:]:\n        a, b, c = map(int, edge.split())\n        if a not in edges:\n            edges[a] = set()\n        if b not in edges:\n            edges[b] = set()\n        edges[a].add((b, c))\n        edges[b].add((a, c))\n\n    def dfs(node: int, visited: set, color: int, path: list) -> bool:\n        if node in visited:\n            return False\n        visited.add(node)\n        rainbow = True\n        for neighbor, next_color in edges[node]:\n            if next_color == color:\n                rainbow = False\n            else:\n                rainbow &= dfs(neighbor, visited, next_color, path)\n        if rainbow:\n            path.append(node)\n        return rainbow\n\n    good_nodes = set()\n    for node in range(1, n+1):\n        visited = set()\n        path = []\n        rainbow = dfs(node, visited, 1, path)\n        if rainbow and len(path) == n:\n            good_nodes.add(node)\n\n    return str(len(good_nodes)) + '\\n' + '\\n'.join(map(str, sorted(good_nodes)))\n\ninput_string = \"8\\n1 3 1\\n2 3 1\\n3 4 3\\n4 5 4\\n5 6 3\\n6 7 2\\n6 8 2\"\nprint(solution(input_string))\n\ninput_string = \"8\\n1 2 2\\n1 3 1\\n2 4 3\\n2 7 1\\n3 5 2\\n5 6 2\\n7 8 1\"\nprint(solution(input_string))\n\ninput_string = \"9\\n1 2 2\\n1 3 1\\n1 4 5\\n1 5 5\\n2 6 3\\n3 7 3\\n4 8 1\\n5 9 2\"\nprint(solution(input_string)) "
    },
    {
        "number": 3031,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    good_nodes = set()\n    colors = set(color for _, _, color in edges)\n\n    def dfs(node, visited):\n        if node in visited:\n            return False\n        visited.add(node)\n        colors_used = set()\n        for neighbor, color in [(a, c) for a, b, c in edges if a == node or b == node]:\n            if neighbor not in visited:\n                colors_used.add(color)\n                if dfs(neighbor, visited):\n                    return True\n        if len(colors_used) == len(colors):\n            good_nodes.add(node)\n            return True\n        return False\n\n    for i in range(1, n + 1):\n        dfs(i, set())\n\n    return f\"{len(good_nodes)}\\n\" + \"\\n\".join(map(str, sorted(good_nodes)))"
    },
    {
        "number": 3032,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, s = [int(x) for x in stdin.split()]\n    program = stdin.split()[2:]\n\n    # Initialize memory banks and instructions count\n    banks = [[] for _ in range(b)]\n    instructions_count = 0\n\n    # Process the program\n    def process_program(program):\n        nonlocal instructions_count\n        i = 0\n        while i < len(program):\n            if program[i].startswith('V'):\n                # Variable reference\n                instructions_count += 1\n                var_index = int(program[i][1:]) - 1\n                bank_index = var_index // s\n                if len(banks[bank_index]) > 0 and banks[bank_index][-1] != var_index:\n                    # Variable is not in the same bank as the previous access, need to set BSR\n                    instructions_count += 1\n            elif program[i].startswith('R'):\n                # Repetition\n                repetitions, j = int(program[i][1:]), i + 1\n                sub_program = program[j:j + repetitions]\n                process_program(sub_program)\n                i += repetitions\n            elif program[i] == 'E':\n                # End of loop\n                pass\n            i += 1\n\n    process_program(program)\n    return str(instructions_count)"
    },
    {
        "number": 3032,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.split()[0].split())\n    program = stdin.split()[1]\n\n    def parse(program):\n        parsed_program = []\n        for element in program.split():\n            if element.startswith(\"V\"):\n                parsed_program.append(int(element[1:]))\n            elif element.startswith(\"R\"):\n                n = int(element[1:])\n                loop_program, _ = parse(program[program.index(element) + 1:])\n                parsed_program.append((n, loop_program))\n            else:\n                parsed_program.append(element)\n        return parsed_program\n\n    parsed_program = parse(program)\n\n    def execute(parsed_program, b, s):\n        memory_references = 0\n        bsr_register_changes = 0\n        for element in parsed_program:\n            if isinstance(element, int):\n                memory_references += 1\n            elif isinstance(element, tuple):\n                n, loop_program = element\n                loop_memory_references, loop_bsr_register_changes = execute(loop_program, b, s)\n                memory_references += n * loop_memory_references\n                bsr_register_changes += n * loop_bsr_register_changes\n\n        if memory_references <= b * s:\n            return memory_references, bsr_register_changes\n        else:\n            return b * s, bsr_register_changes + (memory_references - b * s)\n\n    memory_references, bsr_register_changes = execute(parsed_program, b, s)\n    return str(memory_references + bsr_register_changes)"
    },
    {
        "number": 3032,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    b, s = [int(x) for x in stdin.split()]\n    program = stdin.split()[2:]\n\n    # Initialize variables\n    memory_banks = b * s\n    variables = min(memory_banks, 13)\n    max_repetitions = 10**6\n\n    # Helper function to get variable reference cost\n    def get_variable_reference_cost(variable_index: int) -> int:\n        if variable_index < b:\n            return variable_index\n        else:\n            return b + (variable_index - b) // s\n\n    # Helper function to process a program\n    def process_program(program: list) -> int:\n        cost = 0\n        i = 0\n        while i < len(program):\n            if program[i] == \"V\":\n                cost += get_variable_reference_cost(int(program[i+1]))\n                i += 2\n            elif program[i] == \"R\":\n                repetitions = int(program[i+1])\n                inner_program = program[i+2:i+2+repetitions]\n                cost += process_program(inner_program)\n                i += 2 + repetitions\n            elif program[i] == \"E\":\n                i += 1\n            else:\n                raise ValueError(\"Invalid program element\")\n        return cost\n\n    # Process the program\n    min_cost = process_program(program)\n\n    # Return the result\n    return str(min_cost)\n"
    },
    {
        "number": 3032,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    memory_banks, variables_per_bank = list(map(int, stdin.split()))\n    program = stdin.split()[2:]\n    \n    def eval_program(program: list):\n        instructions = 0\n        for i in program:\n            if i.startswith(\"R\"):\n                _, n, program, _ = i.split(\" \")\n                instructions += eval_program(program) * int(n)\n            elif i.startswith(\"V\"):\n                instructions += 1\n            elif i == \"E\":\n                continue\n        return instructions\n    \n    return str(eval_program(program))"
    },
    {
        "number": 3032,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    b, s = map(int, stdin.split()[0].split())\n    program = stdin.split()[1:]\n\n    # Define variables\n    bsr_register = -1  # BSR register value\n    min_instructions = 0  # Minimum number of instructions\n\n    # Process the program\n    for operation in program:\n        if operation.startswith(\"V\"):\n            # Variable reference\n            variable_index = int(operation[1:])\n            if bsr_register == -1:\n                # No BSR register set yet\n                min_instructions += 1\n            else:\n                # BSR register set, check if variable is in same bank\n                if variable_index // s == bsr_register:\n                    min_instructions += 1\n                else:\n                    # Variable is in different bank, set BSR register and reference\n                    min_instructions += 2\n        elif operation.startswith(\"R\"):\n            # Repetition\n            repetitions = int(operation[1:].split()[0])\n            nested_program = operation[1:].split()[1:-1]\n            for _ in range(repetitions):\n                nested_min_instructions = solution(\" \".join(nested_program))\n                min_instructions += nested_min_instructions\n        else:\n            # End of loop\n            break\n\n    return str(min_instructions)"
    },
    {
        "number": 3032,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    b, s, program = stdin.split('\\n')\n    b = int(b)\n    s = int(s)\n    program = program.split()\n    \n    # Initialize variables\n    memory_banks = b * s\n    instructions = 0\n    BSR = -1\n    \n    # Helper function to calculate the memory location and set BSR if necessary\n    def calculate_memory_location(variable: str):\n        nonlocal BSR\n        i = int(variable[1:])\n        if i <= b:\n            return i\n        bank = (i - 1) // b\n        offset = (i - 1) % b\n        if BSR != bank:\n            BSR = bank\n            instructions += 1\n        return offset\n    \n    # Traverse the program and count the number of memory references and BSR settings\n    for element in program:\n        if element.startswith('V'):\n            instructions += 1\n        elif element.startswith('R'):\n            n, _, _ = element.split('<')\n            n = int(n[1:])\n            instructions += n\n            instructions += 1  # To account for E\n        elif element == 'E':\n            pass\n        else:\n            raise ValueError(f\"Invalid element: {element}\")\n    \n    # Return the minimum number of instructions\n    return str(instructions)\n"
    },
    {
        "number": 3032,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    memory_banks, variables_per_bank = map(int, stdin.split())\n    program = stdin.split()[2:]\n    \n    def parse_program(program: List[str]) -> int:\n        stack = []\n        instructions = 0\n        for token in program:\n            if token.startswith(\"V\"):\n                variable_index = int(token[1:])\n                memory_offset = (variable_index - 1) % memory_banks\n                instructions += 1\n            elif token.startswith(\"R\"):\n                repetitions = int(token[1:])\n                stack.append((repetitions, program.index(\"R\")))\n            elif token == \"E\":\n                repetitions, start_index = stack.pop()\n                loop_program = program[start_index + 1: program.index(\"E\")]\n                loop_instructions = parse_program(loop_program) * repetitions\n                instructions += loop_instructions\n                program = program[program.index(\"E\") + 1:]\n        return instructions\n    \n    return str(parse_program(program))"
    },
    {
        "number": 3032,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    num_banks, num_vars = map(int, input_lines[0].split())\n    program = input_lines[1].split()\n\n    # Calculate the number of instructions required to run the program\n    num_instructions = 0\n    bsr_set = False\n    bsr_value = 0\n\n    for token in program:\n        if token.startswith('R'):\n            # Repetition operation\n            num_repetitions = int(token[1:])\n            nested_program = token.split('<')[1][:-1].split()\n            nested_num_instructions = solution(stdin='\\n'.join([f'{num_banks} {num_vars}', ' '.join(nested_program)]))\n            num_instructions += nested_num_instructions * num_repetitions\n        elif token.startswith('V'):\n            # Variable reference operation\n            var_index = int(token[1:])\n            num_instructions += 1\n            if not bsr_set or bsr_value != var_index // num_vars:\n                bsr_set = True\n                bsr_value = var_index // num_vars\n                num_instructions += 1\n        elif token == 'E':\n            # End of loop operation\n            pass\n        else:\n            raise ValueError(f'Invalid token: {token}')\n\n    return str(num_instructions)\n"
    },
    {
        "number": 3032,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    memory_banks, variables_per_bank = list(map(int, stdin.split()))\n    program = stdin.split()[2:]\n    variables_count = memory_banks * variables_per_bank\n    bsr_values = [0] * memory_banks\n    instructions_count = 0\n    in_loop = False\n    loop_count = 0\n    i = 0\n    while i < len(program):\n        element = program[i]\n        if element == \"R\":\n            loop_count = int(program[i + 1])\n            in_loop = True\n            i += 1\n        elif element == \"V\":\n            variable_index = int(element[1:])\n            if variable_index > variables_count:\n                raise ValueError(\"Invalid variable index\")\n            instructions_count += 1\n        elif element == \"E\":\n            if in_loop:\n                instructions_count += loop_count\n                in_loop = False\n        i += 1\n    return str(instructions_count)\n"
    },
    {
        "number": 3032,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Given the input as a string, the function returns the minimum number of instructions that must be executed to complete the program.\n    \"\"\"\n    lines = stdin.splitlines()\n    b, s = map(int, lines[0].split())\n    program = lines[1].split()\n\n    # Implement your solution here\n\n    return \"0\""
    },
    {
        "number": 3033,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    def f(x):\n        digits = [int(digit) for digit in str(x)]\n        return sum(digits)\n\n    def is_valid(x):\n        return f(x) == N\n\n    def find_smallest_x():\n        x = 1\n        while not is_valid(x):\n            x += 1\n        return x\n\n    if not (2 < B <= 10000 and 0 < N < 2 ** 63):\n        return \"impossible\"\n\n    try:\n        smallest_x = find_smallest_x()\n        return str(smallest_x)\n    except RecursionError:\n        return \"impossible\""
    },
    {
        "number": 3033,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    def f(num):\n        return sum(int(digit) for digit in str(num))\n    def reverse_f(num):\n        return int(\"\".join(str(num // B**i % B) for i in range(50, -1, -1)))\n\n    def find_smallest_x(B, N):\n        for x in range(1, B**(6*10**6)):\n            if f(x) == N:\n                return x\n        return None\n\n    x = find_smallest_x(B, N)\n    return str(x) if x is not None else \"impossible\""
    },
    {
        "number": 3033,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def digit_multiply(base: int, num: int) -> int:\n        result = 0\n        while num > 0:\n            result += num % base\n            num //= base\n        return result\n\n    def reverse_solution(base: int, target: int) -> int:\n        x = 1\n        while digit_multiply(base, x) != target:\n            x += 1\n        return x\n\n    base, target = map(int, stdin.split())\n    result = reverse_solution(base, target)\n    return str(result)\n"
    },
    {
        "number": 3033,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    def f(X):\n        return int(''.join(str(int(c) * X) for c in str(X)))\n    X = 1\n    while f(X) != N:\n        X += 1\n    if X > 2**63:\n        return \"impossible\"\n    return X"
    },
    {
        "number": 3033,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n\n    def f(x: int) -> int:\n        s = 0\n        while x > 0:\n            s += x % B\n            x //= B\n        return s\n\n    def g(x: int) -> int:\n        s = 0\n        while x > 0:\n            s += (x % 10) * B ** (len(str(x)) - 1)\n            x //= 10\n        return s\n\n    if N == 0:\n        return 0\n    if N == 1:\n        return 1\n\n    for i in range(2, B * 10 ** 6):\n        if f(i) == N:\n            return i\n\n    for i in range(2, B * 10 ** 6):\n        if g(i) == N:\n            return i\n\n    return \"impossible\""
    },
    {
        "number": 3033,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    def f(X: int) -> int:\n        result = 0\n        while X > 0:\n            result += X % B\n            X //= B\n        return result\n\n    X = 1\n    while True:\n        if f(X) == N:\n            return str(X)\n        if f(X) > N:\n            return \"impossible\"\n        X += 1"
    },
    {
        "number": 3033,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    if N == 0:\n        return \"impossible\"\n    for i in range(1, 2**63):\n        if f_B(i, B) == N:\n            return str(i)\n    return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def f(x, base):\n        result = 0\n        while x > 0:\n            result += x % base\n            x //= base\n        return result\n\n    def reverse_f(n, base):\n        x = 0\n        while n > 0:\n            x += 1\n            if f(x, base) == n:\n                return x\n            elif f(x, base) > n:\n                return \"impossible\"\n\n    base, n = map(int, stdin.split())\n    return str(reverse_f(n, base))"
    },
    {
        "number": 3033,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def f(B: int, N: int) -> int:\n        result = 0\n        while N > 0:\n            result += (N % B)\n            N //= B\n        return result\n\n    def reverse_f(B: int, N: int) -> int:\n        for i in range(1, 1000000):\n            if f(B, i) == N:\n                return i\n        return -1\n\n    B, N = map(int, stdin.split())\n    X = reverse_f(B, N)\n    if X == -1:\n        return \"impossible\"\n    else:\n        return str(X)\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 3033,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    for i in range(1, N + 1):\n        if i == f(B, i):\n            return str(i)\n    return \"impossible\"\n\ndef"
    },
    {
        "number": 3034,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import math\n\n    def rain_amount(distance: int, start: int, end: int, probability: float, intensity: int) -> float:\n        if start <= distance <= end:\n            return probability * intensity * (min(end, distance) - max(start, distance))\n        return 0\n\n    def min_expected_rain(distance: int, start: int, end: int, probability: float, intensity: int) -> float:\n        return probability * intensity * (end - start)\n\n    def roof_coverage(start: int, end: int, roofs: list) -> float:\n        covered = 0\n        for roof in roofs:\n            if roof[0] >= end:\n                continue\n            if roof[1] <= start:\n                continue\n            covered += min(end, roof[1]) - max(start, roof[0])\n        return covered / (end - start)\n\n    def main(stdin: str) -> str:\n        lines = stdin.split('\\n')\n        d, t, c, r = map(int, lines[0].split())\n        clouds = []\n        for i in range(1, c + 1):\n            s, e, p, a = map(float, lines[i].split())\n            clouds.append((s, e, p, a))\n\n        roofs = []\n        for i in range(c + 1, c + 1 + r):\n            x, y = map(int, lines[i].split())\n            roofs.append((x, y))\n\n        covered = 0\n        for roof in roofs:\n            covered += roof_coverage(0, t, [roof])\n\n        expected_rain = sum(min_expected_rain(d - x, s, e, p, a) for x, y, s, e, p, a in clouds)\n        total_rain = expected_rain * (1 - covered) + 2 * expected_rain * covered\n\n        return f\"{total_rain:.5f}\"\n\n    return main(stdin)"
    },
    {
        "number": 3034,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r = [int(x) for x in stdin.split()]\n    clouds = []\n    for _ in range(c):\n        s, e, p, a = [int(x) for x in stdin.split()]\n        clouds.append((s, e, p, a))\n\n    roofs = []\n    for _ in range(r):\n        x, y = [int(x) for x in stdin.split()]\n        roofs.append((x, y))\n\n    def get_amount_of_rain(cloud: tuple, start_time: int, end_time: int) -> int:\n        s, e, p, a = cloud\n        if s >= start_time and e <= end_time:\n            return a * (e - s)\n        elif s >= start_time and e > end_time:\n            return a * (end_time - s)\n        elif s < start_time and e <= end_time:\n            return a * (e - start_time)\n        else:\n            return 0\n\n    def get_total_rain(clouds: list, start_time: int, end_time: int) -> int:\n        total_rain = 0\n        for cloud in clouds:\n            total_rain += get_amount_of_rain(cloud, start_time, end_time)\n        return total_rain\n\n    total_rain = get_total_rain(clouds, 0, t)\n    total_rain += 2 * d\n\n    for roof in roofs:\n        if roof[0] < d and roof[1] > d:\n            total_rain += get_total_rain(clouds, roof[0], roof[1])\n\n    return round(total_rain, 5)"
    },
    {
        "number": 3034,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def parse_line(line: str) -> List[int]:\n        return [int(x) for x in line.strip().split()]\n    \n    def parse_clouds(clouds_str: str) -> List[List[int]]:\n        return [parse_line(line) for line in clouds_str.strip().split('\\n')]\n    \n    def parse_roofs(roofs_str: str) -> List[Tuple[int, int]]:\n        return [tuple(parse_line(line)) for line in roofs_str.strip().split('\\n')]\n    \n    def rain_in_range(clouds: List[List[int]], start: int, end: int) -> float:\n        total_rain = 0\n        for s, e, p, a in clouds:\n            if s >= end:\n                break\n            if e <= start:\n                continue\n            total_rain += p * (min(e, end) - max(s, start)) * a\n        return total_rain\n    \n    d, t, c, r = parse_line(stdin.split('\\n')[0])\n    clouds = parse_clouds('\\n'.join(stdin.split('\\n')[1:1 + c]))\n    roofs = parse_roofs('\\n'.join(stdin.split('\\n')[1 + c:1 + c + r]))\n    \n    min_rain = float('inf')\n    for i in range(len(roofs)):\n        for j in range(i, len(roofs)):\n            start_dist, end_dist = roofs[i][0], roofs[j][1]\n            if end_dist - start_dist <= d:\n                min_rain = min(min_rain, rain_in_range(clouds, max(0, start_dist - d), end_dist))\n    \n    for start_dist in range(d, t - d):\n        min_rain = min(min_rain, rain_in_range(clouds, start_dist - d, start_dist))\n    \n    return f\"{min_rain:.5f}\" "
    },
    {
        "number": 3034,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def rainfall_in_seconds(clouds, seconds):\n        total_rainfall = 0\n        for cloud in clouds:\n            if cloud[0] <= seconds < cloud[1]:\n                total_rainfall += cloud[3]\n        return total_rainfall\n\n    def time_to_reach_bus_stop(roofs, distance):\n        for roof in roofs:\n            if distance >= roof[0] and distance < roof[1]:\n                return distance\n        return distance\n\n    d, t, c, r = map(int, stdin.split()[:4])\n    clouds = []\n    for i in range(c):\n        s, e, p, a = map(float, stdin.split()[4 + 4*i: 8 + 4*i])\n        clouds.append((int(s), int(e), p, a))\n\n    roofs = []\n    for j in range(r):\n        x, y = map(int, stdin.split()[4 + 4*c + 2*j: 6 + 4*c + 2*j])\n        roofs.append((x, y))\n\n    distance_to_bus_stop = 0\n    total_rainfall = 0\n    for seconds in range(t):\n        distance_to_bus_stop = time_to_reach_bus_stop(roofs, distance_to_bus_stop)\n        total_rainfall += rainfall_in_seconds(clouds, seconds)\n\n    return round(total_rainfall, 5)"
    },
    {
        "number": 3034,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        d, t, c, r = map(int, stdin.split()[:4])\n        clouds = []\n        for i in range(c):\n            s, e, p, a = map(float, stdin.split()[4 + 4 * i:4 + 4 * (i + 1)])\n            clouds.append((int(s), int(e), p, int(a)))\n        roofs = []\n        for i in range(r):\n            x, y = map(int, stdin.split()[4 + c + 2 * i:4 + c + 2 * (i + 1)])\n            roofs.append((x, y))\n        return d, t, c, r, clouds, roofs\n\n    def rain_amount(d, t, c, r, clouds, roofs):\n        def is_under_roof(x, y, roofs):\n            for roof in roofs:\n                if roof[0] <= x < roof[1]:\n                    return True\n            return False\n\n        def cloud_probability(cloud, d, t, x, y):\n            if cloud[0] <= x < cloud[1]:\n                return cloud[2]\n            else:\n                return 0\n\n        def cloud_rain(cloud, x, y):\n            return cloud[3] * (x + y) / (cloud[1] - cloud[0])\n\n        total_rain = 0\n        for x in range(d + 1):\n            for y in range(d + 1 - x):\n                expected_rain = sum(cloud_probability(cloud, d, t, x, y) * cloud_rain(cloud, x, y) for cloud in clouds)\n                if is_under_roof(x, y, roofs):\n                    expected_rain *= 0.5\n                total_rain += expected_rain\n        return total_rain\n\n    d, t, c, r, clouds, roofs = read_input()\n    return str(rain_amount(d, t, c, r, clouds, roofs)) "
    },
    {
        "number": 3034,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string by newline\n    lines = stdin.split(\"\\n\")\n\n    # Extract the values for d, t, c, and r\n    d, t, c, r = map(int, lines[0].split())\n\n    # Initialize the cloud dictionary with each cloud's start, end, probability, and intensity\n    clouds = {}\n    for i in range(1, c+1):\n        s, e, p, a = map(float, lines[i].split())\n        clouds[i] = {\"start\": s, \"end\": e, \"probability\": p, \"intensity\": a}\n\n    # Initialize the roof segments list\n    roofs = []\n    for i in range(c+1, c+r+1):\n        x, y = map(int, lines[i].split())\n        roofs.append((x, y))\n\n    # Initialize the min_rain variable\n    min_rain = float(\"inf\")\n\n    # Iterate through each possible path\n    for i in range(d+1):\n        # Initialize the current path length and rain total\n        path_length = 0\n        rain_total = 0\n\n        # Iterate through each segment in the path\n        for j in range(i+1):\n            # Check if the segment is covered by a roof\n            for roof in roofs:\n                if j >= roof[0] and j < roof[1]:\n                    # If so, add the rain intensity of the cloud to the rain total\n                    cloud_id = find_cloud(clouds, t-1)\n                    rain_total += clouds[cloud_id][\"intensity\"]\n                    break\n            # Add the length of the segment to the path length\n            path_length += 1\n\n        # Check if the path length is within the allowed time\n        if path_length <= t:\n            # If so, update the min_rain if the rain total is less than the current minimum\n            min_rain = min(min_rain, rain_total)\n\n    # Return the minimum rain total\n    return f\"{min_rain:.5f}\"\n\ndef"
    },
    {
        "number": 3034,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r = map(int, stdin.split()[:4])\n    clouds = [list(map(int, stdin.split()[4+i*4:8+i*4])) for i in range(c)]\n    roofs = [list(map(int, stdin.split()[4+c*4+i*2:6+c*4+i*2])) for i in range(r)]\n\n    def rain_duration(cloud):\n        return max(0, min(t, cloud[1]) - max(0, cloud[0]))\n\n    def rain_intensity(cloud):\n        return cloud[3] * rain_duration(cloud)\n\n    def cloud_probability(cloud):\n        return cloud[2] * rain_duration(cloud)\n\n    def expected_rain_on_route(clouds):\n        total_duration = 0\n        total_rain = 0\n        for cloud in clouds:\n            total_duration += rain_duration(cloud)\n            total_rain += rain_intensity(cloud)\n        return total_rain * 1e-9\n\n    def expected_rain_on_roof(clouds, roof):\n        total_duration = 0\n        total_rain = 0\n        for cloud in clouds:\n            if cloud[0] < roof[0] or cloud[1] > roof[1]:\n                continue\n            total_duration += rain_duration(cloud)\n            total_rain += rain_intensity(cloud)\n        return total_rain * 1e-9\n\n    def minimum_rain_on_route(clouds):\n        total_rain = 0\n        for cloud in clouds:\n            total_rain += cloud_probability(cloud) * expected_rain_on_route([cloud])\n        return total_rain\n\n    if not clouds:\n        return 0\n\n    total_rain = minimum_rain_on_route(clouds)\n    for roof in roofs:\n        total_rain -= expected_rain_on_roof(clouds, roof)\n    return total_rain * 1e9"
    },
    {
        "number": 3034,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split(\"\\n\")\n    d, t, c, r = map(int, lines[0].split())\n    clouds = []\n    for i in range(1, c+1):\n        s, e, p, a = map(float, lines[i].split())\n        clouds.append({\"start\": s, \"end\": e, \"probability\": p, \"amount\": a})\n    roofs = []\n    for i in range(c+1, c+1+r):\n        x, y = map(int, lines[i].split())\n        roofs.append((x, y))\n    \n    def rainy_time(cloud: dict, time: int) -> int:\n        return cloud[\"probability\"] * (min(time, cloud[\"end\"]) - max(time, cloud[\"start\"]))\n    \n    def rain_in_segment(clouds: list, roof_segment: tuple) -> int:\n        x, y = roof_segment\n        total_rain = 0\n        for cloud in clouds:\n            if cloud[\"start\"] <= x and cloud[\"end\"] >= y:\n                total_rain += rainy_time(cloud, x) + rainy_time(cloud, y)\n            elif cloud[\"start\"] > x and cloud[\"end\"] < y:\n                total_rain += rainy_time(cloud, cloud[\"start\"]) + rainy_time(cloud, cloud[\"end\"])\n            elif cloud[\"start\"] <= x < cloud[\"end\"]:\n                total_rain += rainy_time(cloud, x)\n            elif cloud[\"start\"] < y <= cloud[\"end\"]:\n                total_rain += rainy_time(cloud, y)\n        return total_rain\n    \n    def min_total_rain(clouds: list, roofs: list) -> int:\n        total_rain = 0\n        for roof_segment in roofs:\n            total_rain += rain_in_segment(clouds, roof_segment)\n        return total_rain\n    \n    return str(min_total_rain(clouds, roofs))"
    },
    {
        "number": 3034,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r, *roof_segments = map(int, stdin.split())\n    clouds = [list(map(int, input().split())) for _ in range(c)]\n\n    def is_cloud_in_zip_code(cloud):\n        return cloud[2] > 0\n\n    def get_start_end_time(cloud):\n        return cloud[0], cloud[1]\n\n    def get_rain_intensity(cloud):\n        return cloud[3]\n\n    def get_roof_length(roof):\n        return roof[1] - roof[0]\n\n    def does_overlap(roof1, roof2):\n        return roof1[0] <= roof2[1] and roof2[0] <= roof1[1]\n\n    def get_roof_segment_length(roof):\n        return roof[1] - roof[0]\n\n    def get_roof_segment_start(roof):\n        return roof[0]\n\n    def get_roof_segment_end(roof):\n        return roof[1]\n\n    def is_roof_segment_in_range(roof_segment, start, end):\n        return start <= roof_segment[0] <= end\n\n    def is_roof_segment_covered(roof_segment, clouds):\n        start, end = get_start_end_time(roof_segment)\n        covered_clouds = [\n            cloud\n            for cloud in clouds\n            if is_cloud_in_zip_code(cloud) and is_roof_segment_in_range(roof_segment, *get_start_end_time(cloud))\n        ]\n\n        for cloud in covered_clouds:\n            if does_overlap(roof_segment, [get_start_end_time(cloud)]):\n                return True\n\n        return False\n\n    def get_rain_intensity_sum(clouds, start_time, end_time):\n        return sum(\n            get_rain_intensity(cloud)\n            for cloud in clouds\n            if is_cloud_in_zip_code(cloud)\n            and start_time <= get_start_end_time(cloud)[0] <= end_time\n        )\n\n    def get_min_expected_rain_intensity(clouds, start_time, end_time):\n        return sum(\n            get_rain_intensity(cloud) * (1 - (get_start_end_time(cloud)[1] - start_time) / (end_time - start_time))\n            for cloud in clouds\n            if is_cloud_in_zip_code(cloud)\n            and start_time <= get_start_end_time(cloud)[0] <= end_time\n        )\n\n    def get_roof_segments_in_range(roof_segments, start, end):\n        return [\n            roof\n            for roof in roof_segments\n            if is_roof_segment_in_range(roof, start, end)\n        ]\n\n    def get_min_expected_rain_intensity_with_roof_cover(clouds, start_time, end_time, roof_segments):\n        covered_roof_segments = [\n            roof\n            for roof in roof_segments\n            if is_roof_segment_covered(roof, clouds)\n        ]\n\n        if not covered_roof_segments:\n            return get_min_expected_rain_intensity(clouds, start_time, end_time)\n\n        covered_roof_segments.sort(key=lambda x: get_roof_segment_length(x))\n\n        remaining_time = end_time - start_time\n        covered_length = 0\n        total_intensity = 0\n\n        for roof in covered_roof_segments:\n            roof_length = get_roof_segment_length(roof)\n            if roof_length > remaining_time:\n                break\n\n            total_intensity += roof_length * get_rain_intensity_sum(clouds, start_time, start_time + roof_length)\n            remaining_time -= roof_length\n\n        if remaining_time > 0:\n            total_intensity += remaining_time *"
    },
    {
        "number": 3034,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    import math\n\n    def find_rain_probability(clouds, time):\n        total_probability = 0\n        for cloud in clouds:\n            start, end, probability, _ = cloud\n            if start <= time < end:\n                total_probability += probability\n        return total_probability\n\n    def find_roof_overlap(roofs, time):\n        total_roof_overlap = 0\n        for i in range(len(roofs)):\n            start_i, end_i = roofs[i]\n            for j in range(i + 1, len(roofs)):\n                start_j, end_j = roofs[j]\n                if start_i <= start_j < end_j <= end_i:\n                    total_roof_overlap += (min(end_j, end_i) - start_j)\n                elif start_j <= start_i < end_i <= end_j:\n                    total_roof_overlap += (min(end_i, end_j) - start_i)\n        return total_roof_overlap\n\n    def find_roof_coverage(roofs, distance):\n        total_coverage = 0\n        for i in range(len(roofs)):\n            start_i, end_i = roofs[i]\n            if start_i <= distance < end_i:\n                total_coverage += (end_i - distance)\n        return total_coverage\n\n    distance, time, num_clouds, num_roofs = map(int, re.split(' +', stdin.strip()))\n    clouds = []\n    for i in range(num_clouds):\n        start, end, probability, intensity = map(float, re.split(' +', stdin.readline().strip()))\n        clouds.append((int(start), int(end), probability, intensity))\n\n    roofs = []\n    for i in range(num_roofs):\n        x, y = map(int, re.split(' +', stdin.readline().strip()))\n        roofs.append((x, y))\n\n    time_until_rain = float('inf')\n    for cloud in clouds:\n        start, end, probability, intensity = cloud\n        if probability > 0:\n            time_until_rain = min(time_until_rain, start)\n\n    probability_rain = find_rain_probability(clouds, time_until_rain)\n    distance_to_bus_stop = distance\n\n    expected_rainfall = 0\n    while distance_to_bus_stop > 0:\n        probability_covered = probability_rain * find_roof_coverage(roofs, distance_to_bus_stop)\n        probability_uncovered = probability_rain * (1 - find_roof_coverage(roofs, distance_to_bus_stop))\n        expected_rainfall += probability_covered * 0 + probability_uncovered * 0.5 * (distance_to_bus_stop ** 2)\n        distance_to_bus_stop -= 1\n\n    return expected_rainfall\n\n\ntest_input = '''20 60 2 1\n5 15 0.33333 30\n22 60 0.66666 70\n0 10'''\n\nprint(solution(test_input))  # Output: 466.662 "
    },
    {
        "number": 3035,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def exchange(price: float, desired_quantity: int) -> int:\n        return max(desired_quantity - price * desired_quantity, 0)\n\n    def read_input(stdin: str) -> List[Tuple[str, str, float]]:\n        lines = stdin.split('\\n')\n        return [(lines[i], lines[i + 1], float(lines[i + 2])) for i in range(0, len(lines) - 2, 3)]\n\n    def max_blue_lemonade(offers: List[Tuple[str, str, float]]) -> float:\n        offers.sort(key=lambda x: x[2], reverse=True)\n        pink_lemonade = 1\n        blue_lemonade = 0\n\n        for offer in offers:\n            if offer[0] == 'pink':\n                pink_lemonade = exchange(offer[2], pink_lemonade)\n            elif offer[0] == 'blue':\n                blue_lemonade += exchange(offer[2], pink_lemonade)\n\n        return min(10, blue_lemonade)\n\n    offers = read_input(stdin)\n    return str(max_blue_lemonade(offers))"
    },
    {
        "number": 3035,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_lemonade_info(line: str) -> tuple:\n        offer, want, rate = line.split()\n        return offer, want, float(rate)\n    \n    def calculate_trade(offer, want, offer_amount, want_amount, offer_limit, want_limit) -> tuple:\n        if offer == \"blue\":\n            return offer_amount, min(offer_limit, want_amount / rate)\n        else:\n            return min(offer_limit, want_amount * rate), want_amount\n    \n    lines = stdin.split(\"\\n\")\n    num_children = int(lines[0])\n    blue_lemonade = 1.0\n    exchange_rates = {}\n    \n    for line in lines[1:]:\n        offer, want, rate = get_lemonade_info(line)\n        exchange_rates[(offer, want)] = rate\n    \n    for child in range(num_children):\n        offer = \"blue\"\n        want = \"pink\"\n        rate = exchange_rates[(offer, want)]\n        blue_lemonade, pink_lemonade = calculate_trade(offer, want, blue_lemonade, pink_lemonade, 10, 10)\n        \n        offer = \"pink\"\n        want = \"red\"\n        rate = exchange_rates[(offer, want)]\n        pink_lemonade, red_lemonade = calculate_trade(offer, want, pink_lemonade, red_lemonade, 10, 10)\n        \n        offer = \"red\"\n        want = \"blue\"\n        rate = exchange_rates[(offer, want)]\n        red_lemonade, blue_lemonade = calculate_trade(offer, want, red_lemonade, blue_lemonade, 10, 10)\n    \n    return str(min(10.0, blue_lemonade))"
    },
    {
        "number": 3035,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    exchanges = {}\n    for _ in range(n):\n        offer, want, rate = input().split()\n        offer, want = offer.lower(), want.lower()\n        exchanges[offer, want] = float(rate)\n\n    blue_lemonade = 0\n    pink_lemonade = 1\n\n    for i in range(n):\n        offer = \"pink\"\n        want = \"blue\"\n        rate = 1 / exchanges[\"pink\", \"blue\"]\n        blue_lemonade += min(pink_lemonade, rate * offer)\n        pink_lemonade -= rate * offer\n\n    return round(min(blue_lemonade, 10), 6)\n\ninputs = [\n    \"3\\nblue pink 1.0\\nred pink 1.5\\nblue red 1.0\",\n    \"2\\nblue red 1.0\\nred pink 1.5\",\n    \"4\\norange pink 1.9\\nyellow orange 1.9\\ngreen yellow 1.9\\nblue green 1.9\"\n]\n\nfor input in inputs:\n    stdin = input.replace(\"\\n\", os.linesep)\n    result = solution(stdin)\n    print(result) "
    },
    {
        "number": 3035,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    n, lines = int(stdin.splitlines()[0]), stdin.splitlines()[1:]\n\n    # Create the bidding matrix\n    matrix = [[0] * n for _ in range(n)]\n    for i, line in enumerate(lines):\n        offer, want, rate = line.split()\n        matrix[i][n] = float(rate)\n\n    # Sort the bidding matrix by offer\n    for i in range(n):\n        for j in range(n - 1):\n            if matrix[j][i] < matrix[j + 1][i]:\n                matrix[j], matrix[j + 1] = matrix[j + 1], matrix[j]\n\n    # Calculate the optimal solution\n    total = 0\n    for i in range(n):\n        total += matrix[i][n]\n    total *= 10  # Limit to 10 liters\n\n    # Calculate the maximum exchange rate\n    max_rate = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] > max_rate:\n                max_rate = matrix[i][j]\n\n    # Calculate the maximum amount of blue lemonade\n    max_lemonade = min(total / max_rate, 10)\n\n    return f\"{max_lemonade:.6f}\"  # Output with absolute precision 10^-6"
    },
    {
        "number": 3035,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input().strip())\n    child_offers = []\n    \n    for _ in range(n):\n        offer, want, rate = input().strip().split()\n        child_offers.append((offer, want, float(rate)))\n    \n    max_amount = 0\n    for offer in child_offers:\n        if offer[0] == \"blue\":\n            max_amount += offer[2]\n    \n    max_amount = min(max_amount, 10)\n    return f\"{max_amount:.6f}\"\n\nstdin = \"\"\nwith open(\"input.txt\", \"r\") as file:\n    stdin = file.read()\n\noutput = solution(stdin)\nwith open(\"output.txt\", \"w\") as file:\n    file.write(output) "
    },
    {
        "number": 3035,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    num_children, rows = stdin.split('\\n', 1)\n    num_children = int(num_children)\n    rows = rows.split('\\n')\n\n    # Create exchange rates dictionary\n    exchange_rates = {}\n    for row in rows:\n        if row:\n            offer, want, rate = row.split()\n            exchange_rates[(offer, want)] = float(rate)\n\n    # Calculate maximum amount of blue lemonade\n    max_blue_lemonade = 0\n    for offer, want in exchange_rates:\n        if offer == 'pink':\n            max_blue_lemonade += exchange_rates[('pink', want)]\n        elif want == 'blue':\n            max_blue_lemonade += 1 / exchange_rates[(offer, 'blue')]\n\n    # Return maximum amount of blue lemonade with absolute precision of 10^-6\n    return f\"{min(10, max_blue_lemonade):.6f}\" "
    },
    {
        "number": 3035,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    children = {}\n    \n    for _ in range(n):\n        offer, want, rate = stdin.readline().split()\n        rate = float(rate)\n        if want not in children:\n            children[want] = (offer, rate)\n        else:\n            children[want] = max(children[want], (offer, rate), key=lambda x: x[1])\n    \n    max_blue_lemonade = 0\n    for offer, rate in children.values():\n        max_blue_lemonade += rate\n    \n    max_blue_lemonade = min(10, max_blue_lemonade)\n    \n    return f\"{max_blue_lemonade:.6f}\""
    },
    {
        "number": 3035,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    import sys\n\n    def lemonade_exchange(offered, wanted, rate) -> float:\n        return offered * rate if wanted == \"blue\" else 0.0\n\n    def read_exchange_rate() -> tuple:\n        line = sys.stdin.readline().strip()\n        offered, wanted, rate = re.split(r'\\s+', line)\n        return offered, wanted, float(rate)\n\n    N = int(sys.stdin.readline().strip())\n    exchange_rates = [read_exchange_rate() for _ in range(N)]\n\n    max_blue_lemonade = 0.0\n    for offered, wanted, rate in exchange_rates:\n        max_blue_lemonade += lemonade_exchange(1, offered, rate)\n\n    max_blue_lemonade = min(max_blue_lemonade, 10)\n    return f\"{max_blue_lemonade:.6f}\""
    },
    {
        "number": 3035,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num_children, lines = stdin.split('\\n', 1)\n    num_children = int(num_children)\n\n    exchange_rates = {}\n    for line in lines.split('\\n'):\n        if not line:\n            continue\n        offer, want, rate = line.split()\n        rate = float(rate)\n        exchange_rates[(offer, want)] = rate\n\n    max_blue_lemonade = 0\n    for offer, want in exchange_rates:\n        if want == 'blue':\n            max_blue_lemonade += exchange_rates[(offer, want)]\n\n    return f\"{max_blue_lemonade:.6f}\""
    },
    {
        "number": 3035,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    children = []\n\n    for _ in range(N):\n        offer, want, rate = stdin.readline().split()\n        rate = float(rate)\n        children.append((offer, want, rate))\n\n    blue_lemonade = 0\n\n    for offer, want, rate in children:\n        if offer == \"blue\" and want == \"lemonade\":\n            blue_lemonade += rate\n\n    for offer, want, rate in children:\n        if want == \"blue\" and offer != \"blue\" and blue_lemonade < 10:\n            blue_lemonade += rate * 1000 / (rate + 1)\n            if blue_lemonade > 10:\n                blue_lemonade = 10\n\n    return f\"{blue_lemonade:.6f}\""
    },
    {
        "number": 3036,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    r, s, m, d, n = map(int, lines[0].split())\n\n    ingredient_counts = list(map(int, lines[1].split()))\n\n    # parse dish lists\n    dish_lists = []\n    for i, line in enumerate(lines[2:2 + s + m + d]):\n        k, *ingredients = map(int, line.split())\n        dish_lists.append(set(ingredients))\n\n    # parse incompatible dishes\n    incompatible_dishes = set()\n    for i in range(n):\n        dish1, dish2 = map(int, lines[2 + s + m + d + i].split())\n        incompatible_dishes.add(frozenset([dish1, dish2]))\n\n    def count_dinner_experiences():\n        experiences = 1\n        for i in range(s):\n            for j in range(s, s + m):\n                for k in range(s + m, s + m + d):\n                    if frozenset([i+1, j+1, k+1]) not in incompatible_dishes:\n                        experiences *= ingredient_counts[dish_lists[i].intersection(dish_lists[j]).intersection(dish_lists[k])]\n        return experiences\n\n    result = count_dinner_experiences()\n    return str(result) if result <= 10**18 else \"too many\""
    },
    {
        "number": 3036,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.split()[:5])\n    incompatibles = [tuple(map(int, line.split())) for line in stdin.split('\\n')[6:6 + n]]\n    brand_counts = list(map(int, stdin.split('\\n')[5].split()))\n    dishes = stdin.split('\\n')[6 + n:]\n\n    def can_combine(dish1: tuple, dish2: tuple) -> bool:\n        ingredients1, ingredients2 = set(dish1[1:]), set(dish2[1:])\n        return not any(ingredients1 & ingredients2)\n\n    def count_dinners(dishes: list, start: int, end: int) -> int:\n        count = 0\n        for i in range(start, end):\n            for j in range(i + 1, end):\n                if can_combine(dishes[i], dishes[j]):\n                    count += 1\n        return count\n\n    max_count = 1\n    for i in range(len(brand_counts)):\n        for j in range(brand_counts[i]):\n            for k in range(len(dishes)):\n                if dishes[k][0] > i + 1:\n                    continue\n                for l in range(k + 1, len(dishes)):\n                    if dishes[l][0] > i + 1:\n                        continue\n                    if can_combine(tuple(dishes[k]), tuple(dishes[l])):\n                        max_count *= 2\n            max_count *= (i + 1) * (j + 1)\n            max_count *= count_dinners(dishes, 0, len(dishes))\n\n    return max_count if max_count <= 10**18 else \"too many\"\n\nsample_input_1 = \"6 1 1 1 0\\n2 3 1 5 3 2\\n2 1 2\\n3 3 4 5\\n1 6\"\nprint(solution(sample_input_1))  # Output: 180\n\nsample_input_2 = \"3 2 2 1 1\\n2 3 2\\n1 1\\n1 2\\n1 2\\n1 3\\n1 1\\n2 3\"\nprint(solution(sample_input_2))  # Output: 22\n\nsample_input_3 = \"3 1 1 1 1\\n5 5 5\\n3 1 2 3\\n3 1 2 3\\n3 1 2 3\\n2 1\"\nprint(solution(sample_input_3))  # Output: 0 "
    },
    {
        "number": 3036,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.split()[:5])\n    ingredients = list(map(int, stdin.split()[5:5+r]))\n    brands = [ingredients]\n    for i in range(1, r):\n        brands.append(list(map(int, stdin.split()[5+r+i-1:])))\n\n    def get_combinations(available_dishes):\n        if not available_dishes:\n            return [[]]\n        return [dish + rest for dish in available_dishes[0] for rest in get_combinations(available_dishes[1:])]\n\n    def get_combinations_without_incompatibility(available_dishes):\n        if not available_dishes:\n            return [[]]\n        return [dish + rest for dish in available_dishes[0] for rest in get_combinations_without_incompatibility(available_dishes[1:]) if not any(i in incompatible_pairs for i in dish)]\n\n    starter_dishes = []\n    main_dishes = []\n    dessert_dishes = []\n    incompatible_pairs = []\n\n    for i in range(s + m + d):\n        num_ingredients, *ingredients = map(int, stdin.split()[5 + r + i].split())\n        if i < s:\n            starter_dishes.append(ingredients)\n        elif i < s + m:\n            main_dishes.append(ingredients)\n        else:\n            dessert_dishes.append(ingredients)\n\n    for _ in range(n):\n        dish1, dish2 = map(int, stdin.split()[5 + r + s + m + d].split())\n        incompatible_pairs.append((dish1, dish2))\n\n    starter_combinations = get_combinations(starter_dishes)\n    main_combinations = get_combinations(main_dishes)\n    dessert_combinations = get_combinations(dessert_dishes)\n    combinations_without_incompatibility = get_combinations_without_incompatibility(starter_dishes + main_dishes + dessert_dishes)\n\n    if len(combinations_without_incompatibility) <= 10**18:\n        return str(len(combinations_without_incompatibility))\n    else:\n        return \"too many\""
    },
    {
        "number": 3036,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_combinations(nums: List[int]) -> int:\n        count = 1\n        for num in nums:\n            count *= num\n        return count\n\n    def get_incompatible_dishes(incompatible_dishes: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        incompatible_dishes_set = set(incompatible_dishes)\n        incompatible_dishes_list = list(incompatible_dishes_set)\n        return incompatible_dishes_list\n\n    def is_compatible(dish1: List[int], dish2: List[int], incompatible_dishes: List[Tuple[int, int]]) -> bool:\n        for ingredient1, ingredient2 in itertools.product(dish1, dish2):\n            if (ingredient1, ingredient2) in incompatible_dishes or (ingredient2, ingredient1) in incompatible_dishes:\n                return False\n        return True\n\n    def count_experiences(s_dishes: List[List[int]], m_dishes: List[List[int]], d_dishes: List[List[int]], incompatible_dishes: List[Tuple[int, int]]) -> int:\n        s_count = get_combinations([len(s_dishes)] * len(s_dishes))\n        m_count = get_combinations([len(m_dishes)] * len(m_dishes))\n        d_count = get_combinations([len(d_dishes)] * len(d_dishes))\n\n        incompatible_dishes_list = get_incompatible_dishes(incompatible_dishes)\n\n        experience_count = 0\n        for s_dish1, s_dish2 in itertools.combinations(range(len(s_dishes)), 2):\n            if not is_compatible(s_dishes[s_dish1], s_dishes[s_dish2], incompatible_dishes_list):\n                continue\n            for m_dish1, m_dish2 in itertools.combinations(range(len(m_dishes)), 2):\n                if not is_compatible(m_dishes[m_dish1], m_dishes[m_dish2], incompatible_dishes_list):\n                    continue\n                for d_dish1, d_dish2 in itertools.combinations(range(len(d_dishes)), 2):\n                    if not is_compatible(d_dishes[d_dish1], d_dishes[d_dish2], incompatible_dishes_list):\n                        continue\n                    experience_count += s_count * m_count * d_count\n\n        return experience_count\n\n    lines = stdin.strip().split(\"\\n\")\n    r, s, m, d, n = map(int, lines[0].split())\n    incompatible_dishes = [(int(pair[0]), int(pair[1])) for pair in map(lambda x: x.split(), lines[-n:])]\n    brands = list(map(int, lines[1].split()))\n    s_dishes = [list(map(int, line.split()[1:])) for line in lines[2:2 + s]]\n    m_dishes = [list(map(int, line.split()[1:])) for line in lines[2 + s:2 + s + m]]\n    d_dishes = [list(map(int, line.split()[1:])) for line in lines[2 + s + m:]]\n\n    experiences = count_experiences(s_dishes, m_dishes, d_dishes, incompatible_dishes)\n    if experiences < 10**18:\n        return str(experiences)\n    else:\n        return \"too many\""
    },
    {
        "number": 3036,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.split()[:5])\n    if r == 0:\n        return \"too many\"\n\n    brands = list(map(int, stdin.split()[5:]))\n\n    dishes = stdin.split(\"\\n\")[s+m+d:]\n\n    incompatible_dishes = [tuple(map(int, line.split())) for line in dishes[:n]]\n    dishes = dishes[n:]\n\n    def is_compatible(dish1: tuple, dish2: tuple) -> bool:\n        for ingredient in dish1:\n            if ingredient in dish2:\n                return False\n        return True\n\n    def count_combinations(dish_types: list) -> int:\n        total_combinations = 1\n        for dish_type in dish_types:\n            total_combinations *= brands[dish_type - 1]\n        return total_combinations\n\n    compatible_combinations = 1\n    for dish1, dish2 in incompatible_dishes:\n        if dish1 > s+m+d or dish2 > s+m+d:\n            continue\n\n        compatible_combinations -= count_combinations(dishes[dish1-1:dish1] + dishes[dish2-1:dish2])\n\n    for dish_types in dishes:\n        compatible_combinations += count_combinations(dish_types)\n\n    return str(compatible_combinations) if compatible_combinations <= 10**18 else \"too many\""
    },
    {
        "number": 3036,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> tuple:\n        lines = input_str.split('\\n')\n        r, s, m, d, n = map(int, lines[0].split())\n        brands = list(map(int, lines[1].split()))\n        dishes = []\n        for i in range(s+m+d):\n            line = lines[i+2]\n            k, *ingredients = map(int, line.split())\n            dishes.append(ingredients)\n        incompatible_dishes = []\n        for i in range(n):\n            line = lines[i+2+s+m]\n            dish1, dish2 = map(int, line.split())\n            incompatible_dishes.append((dish1-1, dish2-1))\n        return r, s, m, d, brands, dishes, incompatible_dishes\n    \n    def count_experiences(r, s, m, d, brands, dishes, incompatible_dishes) -> int:\n        def check_compatibility(dish1, dish2):\n            for ingredient in dish1:\n                if ingredient in dish2:\n                    return False\n            return True\n        \n        compatible_dishes = [[] for _ in range(s+m+d)]\n        for i in range(s+m+d):\n            for j in range(s+m+d):\n                if i != j and (i, j) not in incompatible_dishes:\n                    compatible_dishes[i].append(j)\n        \n        def dfs(current_dishes):\n            if len(current_dishes) == 3:\n                return 1\n            count = 0\n            for dish in compatible_dishes[current_dishes[-1]]:\n                if dish not in current_dishes:\n                    count += dfs(current_dishes + [dish])\n            return count\n        \n        return dfs([])\n    \n    r, s, m, d, brands, dishes, incompatible_dishes = parse_input(stdin)\n    result = count_experiences(r, s, m, d, brands, dishes, incompatible_dishes)\n    return str(result) if result <= 10**18 else \"too many\" "
    },
    {
        "number": 3036,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def combinations(lst):\n        if len(lst) == 0:\n            return []\n        if len(lst) == 1:\n            return [lst]\n        result = []\n        for i in range(len(lst)):\n            sublist = lst[:i] + lst[i+1:]\n            subcombinations = combinations(sublist)\n            for subcombination in subcombinations:\n                result.append([lst[i]] + subcombination)\n        return result\n\n    def compatible_combinations(dish_list, incompatible_dish_pairs):\n        compatible_combinations = []\n        for dish_combination in combinations(dish_list):\n            if all(dish_combination.count(dish1) == dish_list.count(dish1) and dish_combination.count(dish2) == dish_list.count(dish2) for dish1, dish2 in incompatible_dish_pairs):\n                compatible_combinations.append(dish_combination)\n        return compatible_combinations\n\n    def count_dinner_experiences(stdin: str) -> int:\n        r, s, m, d, n = map(int, stdin.readline().split())\n        incompatible_dish_pairs = []\n        for _ in range(n):\n            incompatible_dish_pairs.append(tuple(map(int, stdin.readline().split())))\n\n        stdin.readline()\n        brands = list(map(int, stdin.readline().split()))\n\n        dish_lists = []\n        for _ in range(s+m+d):\n            dish_lists.append(list(map(int, stdin.readline().split()[1:])))\n\n        all_dishes = [dish for dish_list in dish_lists for dish in dish_list]\n        all_dishes_set = set(all_dishes)\n        all_brand_counts = [sum([dish_lists[j].count(dish) for j in range(s+m+d)]) for dish in all_dishes_set]\n\n        compatible_combinations_count = 0\n        for brand1 in range(brands[all_dishes[0]-1]):\n            for brand2 in range(brands[all_dishes[1]-1]):\n                compatible_combinations_count += len(compatible_combinations(dish_lists[:2], incompatible_dish_pairs))\n\n        for brand in range(brands[all_dishes[2]-1]):\n            compatible_combinations_count += len(compatible_combinations(dish_lists[:3], incompatible_dish_pairs))\n\n        for i in range(3, len(dish_lists)):\n            for compatible_combination in compatible_combinations(dish_lists[:i], incompatible_dish_pairs):\n                compatible_combinations_count += brands[all_dishes[i]-1] ** (i-2) * len(compatible_combinations(dish_lists[:i+1], incompatible_dish_pairs))\n\n        return compatible_combinations_count\n\n    if count_dinner_experiences(stdin) > 10**18:\n        return \"too many\"\n    else:\n        return str(count_dinner_experiences(stdin)) "
    },
    {
        "number": 3036,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.readline().split())\n    brands = list(map(int, stdin.readline().split()))\n\n    def can_combine(a, b):\n        return all(brands[i] >= 2 for i in a & b)\n\n    def count_combinations(dishes):\n        dishes = sorted(dishes)\n        count = 0\n        for i in range(len(dishes)):\n            for j in range(i + 1, len(dishes)):\n                if can_combine(dishes[i], dishes[j]):\n                    count += 1\n        return count\n\n    starter_dishes = []\n    main_dishes = []\n    dessert_dishes = []\n    incompatible_dishes = set()\n\n    for _ in range(s):\n        ingredients = list(map(int, stdin.readline().split()))\n        starter_dishes.append(set(ingredients[1:]))\n\n    for _ in range(m):\n        ingredients = list(map(int, stdin.readline().split()))\n        main_dishes.append(set(ingredients[1:]))\n\n    for _ in range(d):\n        ingredients = list(map(int, stdin.readline().split()))\n        dessert_dishes.append(set(ingredients[1:]))\n\n    for _ in range(n):\n        incompatible_dishes.add(tuple(map(int, stdin.readline().split())))\n\n    count = 0\n    for i in range(s):\n        for j in range(s, s + m):\n            for k in range(s + m, s + m + d):\n                if (i + 1, j + 1) not in incompatible_dishes and (j + 1, k + 1) not in incompatible_dishes:\n                    count += count_combinations(starter_dishes[i] | main_dishes[j - s] | dessert_dishes[k - s - m])\n\n    return str(count) if count <= 10**18 else \"too many\"\n"
    },
    {
        "number": 3036,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.readline().split())\n    brands = list(map(int, stdin.readline().split()))\n    \n    dishes = []\n    for i in range(s + m + d):\n        count, *ingredients = map(int, stdin.readline().split())\n        dishes.append(set(ingredients))\n    \n    incompatible_dishes = set()\n    for i in range(n):\n        dish1, dish2 = map(int, stdin.readline().split())\n        incompatible_dishes.add(frozenset((dish1, dish2)))\n    \n    def generate_experiences(dishes, brands, incompatible_dishes):\n        experiences = []\n        for starter in dishes[:s]:\n            for main in dishes[s:s+m]:\n                for dessert in dishes[s+m:s+m+d]:\n                    if any(dish1 in (starter | main | dessert) and dish2 in (starter | main | dessert) for dish1, dish2 in incompatible_dishes):\n                        continue\n                    experience = {\n                        \"starter\": sorted(starter),\n                        \"main\": sorted(main),\n                        \"dessert\": sorted(dessert),\n                    }\n                    experiences.append(experience)\n        return experiences\n    \n    experiences = generate_experiences(dishes, brands, incompatible_dishes)\n    \n    if len(experiences) > 10**18:\n        return \"too many\"\n    else:\n        return len(experiences)"
    },
    {
        "number": 3036,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.split()[:5])\n    ingredients = list(map(int, stdin.split()[5:]))\n    brands = [ingredients.pop(0) for _ in range(r)]\n    incompatibilities = [tuple(map(int, stdin.split()[5+2*i:5+2*(i+1)])) for i in range(n)]\n    dishes = []\n    \n    for _ in range(s + m + d):\n        k, *ingredients = list(map(int, stdin.split()))\n        dishes.append(tuple(ingredients[:k]))\n    \n    def count_dinner_experiences():\n        experiences = 0\n        for i in range(s + m + d):\n            for j in range(i+1, s + m + d):\n                if (i, j) not in incompatibilities and set(dishes[i]) != set(dishes[j]):\n                    experiences += 1\n        return experiences\n    \n    def count_ingredient_combinations():\n        combinations = 1\n        for i in range(r):\n            combinations *= brands[i]\n        return combinations\n    \n    return str(min(count_dinner_experiences() * count_ingredient_combinations(), 10**18))"
    },
    {
        "number": 3037,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[0].split())\n    target_pattern = [list(line.rstrip()) for line in stdin.split('\\n')[1:h+1]]\n    commands = []\n    for i in range(h+1, h+n+1):\n        direction, distance = stdin.split('\\n')[i].split()\n        commands.append((direction, int(distance)))\n    \n    def mark(x: int, y: int, direction: str, distance: int, dry_time: int) -> int:\n        if direction == 'up':\n            return max(0, x - distance), y, dry_time\n        elif direction == 'down':\n            return min(h-1, x + distance), y, dry_time\n        elif direction == 'left':\n            return x, max(0, y - distance), dry_time\n        else:\n            return x, min(w-1, y + distance), dry_time\n\n    min_time = max_time = -1\n    dry_time = 0\n    x, y = 0, 0\n    for command in commands:\n        x, y, dry_time = mark(x, y, command[0], command[1], dry_time)\n        if target_pattern[x][y] == '#':\n            dry_time += 1\n            if min_time == -1:\n                min_time = dry_time\n            max_time = dry_time\n        else:\n            dry_time += 1\n            if min_time == -1:\n                min_time = dry_time\n            max_time = dry_time\n        if dry_time > n*w:\n            return \"-1 -1\"\n    \n    return str(min_time) + \" \" + str(max_time)\n\ndef"
    },
    {
        "number": 3037,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(current_pos, direction, distance) -> bool:\n        if direction == 'up':\n            new_pos = (current_pos[0] - distance, current_pos[1])\n        elif direction == 'down':\n            new_pos = (current_pos[0] + distance, current_pos[1])\n        elif direction == 'left':\n            new_pos = (current_pos[0], current_pos[1] - distance)\n        elif direction == 'right':\n            new_pos = (current_pos[0], current_pos[1] + distance)\n        else:\n            return False\n        return 0 <= new_pos[0] < h and 0 <= new_pos[1] < w\n\n    def mark_board(pattern, moves):\n        board = [[False] * w for _ in range(h)]\n        pos = (0, 0)\n        for move in moves:\n            direction, distance = move.split()\n            distance = int(distance)\n            if not is_valid_move(pos, direction, distance):\n                return None\n            for i in range(distance):\n                if direction == 'up':\n                    board[pos[0] - i][pos[1]] = pattern[pos[0] - i][pos[1]]\n                elif direction == 'down':\n                    board[pos[0] + i][pos[1]] = pattern[pos[0] + i][pos[1]]\n                elif direction == 'left':\n                    board[pos[0]][pos[1] - i] = pattern[pos[0]][pos[1] - i]\n                elif direction == 'right':\n                    board[pos[0]][pos[1] + i] = pattern[pos[0]][pos[1] + i]\n            if direction == 'up':\n                pos = (pos[0] - distance, pos[1])\n            elif direction == 'down':\n                pos = (pos[0] + distance, pos[1])\n            elif direction == 'left':\n                pos = (pos[0], pos[1] - distance)\n            elif direction == 'right':\n                pos = (pos[0], pos[1] + distance)\n        return board\n\n    stdin = stdin.strip()\n    h, w, n = map(int, stdin.split()[:3])\n    pattern = stdin.split('\\n')[h:2*h]\n    moves = stdin.split('\\n')[2*h+1:]\n\n    board = mark_board(pattern, moves)\n    if not board:\n        return '-1 -1'\n\n    min_time, max_time = float('inf'), -1\n    for i in range(h):\n        for j in range(w):\n            if board[i][j]:\n                min_time = min(min_time, i * w + j)\n                max_time = max(max_time, i * w + j)\n    if min_time == float('inf'):\n        return '-1 -1'\n    return f'{min_time} {max_time}'"
    },
    {
        "number": 3037,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    dimensions, commands = stdin.split('\\n', 1)\n    h, w, n = map(int, dimensions.split())\n    target_pattern = commands.split('\\n', n)[0:h]\n    commands = commands.split('\\n', n)[h:]\n\n    # Initialize the whiteboard\n    whiteboard = [['.' for _ in range(w)] for _ in range(h)]\n\n    # Draw the target pattern\n    for i in range(h):\n        for j in range(w):\n            if target_pattern[i][j] == '#':\n                whiteboard[i][j] = '#'\n\n    # Initialize variables\n    direction_map = {'up': (-1, 0), 'down': (1, 0), 'left': (0, -1), 'right': (0, 1)}\n    min_time = 0\n    max_time = n * 1000000\n    dry_out_time = -1\n\n    # Execute the commands\n    position = (0, 0)\n    for command in commands:\n        direction, distance = command.split()\n        distance = int(distance)\n\n        # Move the turtle\n        for _ in range(distance):\n            # Check if the turtle is drying out\n            if whiteboard[position[0]][position[1]] == '#':\n                dry_out_time = max(dry_out_time, min_time)\n\n            # Mark the whiteboard if necessary\n            if whiteboard[position[0]][position[1]] == '.' and dry_out_time != -1:\n                whiteboard[position[0]][position[1]] = '#'\n\n            # Move the turtle\n            direction_vector = direction_map[direction]\n            position = (position[0] + direction_vector[0], position[1] + direction_vector[1])\n            min_time += 1\n            max_time += 1\n\n            # Check if the turtle is out of bounds\n            if position[0] < 0 or position[0] >= h or position[1] < 0 or position[1] >= w:\n                break\n\n        # Check if the turtle is drying out\n        if whiteboard[position[0]][position[1]] == '#':\n            dry_out_time = max(dry_out_time, min_time)\n\n        # Check if the turtle is out of bounds\n        if position[0] < 0 or position[0] >= h or position[1] < 0 or position[1] >= w:\n            break\n\n    # Check if the turtle is drying out\n    if whiteboard[position[0]][position[1]] == '#':\n        dry_out_time = max(dry_out_time, min_time)\n\n    # Return the result\n    return f\"{dry_out_time} {max_time}\" if dry_out_time != -1 else \"-1 -1\""
    },
    {
        "number": 3037,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.readline().split())\n    head = [list(stdin.readline().strip()) for _ in range(h)]\n    commands = [stdin.readline().strip().split() for _ in range(n)]\n    \n    def get_new_position(direction: str, distance: int, x: int, y: int) -> tuple[int, int]:\n        if direction == \"up\":\n            return x, max(y - distance, 0)\n        elif direction == \"down\":\n            return x, min(y + distance, h - 1)\n        elif direction == \"left\":\n            return max(x - distance, 0), y\n        else:\n            return min(x + distance, w - 1), y\n\n    def is_marked(x: int, y: int) -> bool:\n        return head[y][x] == \"#\"\n\n    def is_unmarked(x: int, y: int) -> bool:\n        return head[y][x] == \".\"\n\n    x, y = 0, 0\n    dry_time = -1\n    max_dry_time = -1\n    for command in commands:\n        direction, distance = command\n        new_x, new_y = get_new_position(direction, int(distance), x, y)\n        if is_unmarked(new_x, new_y):\n            dry_time += 1\n        else:\n            max_dry_time = max(max_dry_time, dry_time)\n            dry_time = -1\n        x, y = new_x, new_y\n    \n    max_dry_time = max(max_dry_time, dry_time)\n    if max_dry_time != -1:\n        return str(max_dry_time), str(max_dry_time)\n    else:\n        return \"-1\", \"-1\""
    },
    {
        "number": 3037,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    h, w, n = map(int, stdin.splitlines()[0].split())\n    pattern = [list(line) for line in stdin.splitlines()[1:h+1]]\n    commands = [line.split() for line in stdin.splitlines()[h+1:]]\n    \n    # Initialize the variables\n    min_time = max_time = 0\n    x, y = 0, 0\n    marker_dry = False\n    \n    # Execute the commands\n    for command in commands:\n        direction, distance = command\n        if direction == \"up\":\n            y -= distance\n        elif direction == \"down\":\n            y += distance\n        elif direction == \"left\":\n            x -= distance\n        elif direction == \"right\":\n            x += distance\n        \n        # Check if the marker has run dry\n        if not marker_dry and pattern[y][x] == \"#\":\n            marker_dry = True\n            min_time = max(min_time, x + y * w + 1)\n        \n        # Check if the marker has finished drawing\n        if marker_dry and x == w-1 and y == h-1:\n            max_time = min(max_time, x + y * w + 1)\n            break\n    \n    # Check if the target drawing can be achieved\n    if marker_dry and min_time <= max_time:\n        return f\"{min_time} {max_time}\"\n    else:\n        return \"-1 -1\""
    },
    {
        "number": 3037,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    h, w, n = map(int, stdin.readline().strip().split())\n    head = [list(stdin.readline().strip()) for _ in range(h)]\n    commands = [stdin.readline().strip() for _ in range(n)]\n\n    # Initialize variables\n    min_time = 0\n    max_time = 0\n    marker_x = 0\n    marker_y = h - 1\n    direction = 0  # 0 = up, 1 = right, 2 = down, 3 = left\n\n    # Execute commands\n    for command in commands:\n        action, distance = command.split()\n        distance = int(distance)\n\n        if action == \"up\":\n            direction = 0\n            marker_y -= distance\n        elif action == \"right\":\n            direction = 1\n            marker_x += distance\n        elif action == \"down\":\n            direction = 2\n            marker_y += distance\n        elif action == \"left\":\n            direction = 3\n\n        # Update min and max time\n        if direction == 0:\n            min_time = max(min_time, marker_y)\n            max_time = max(max_time, marker_y + distance - 1)\n        elif direction == 1:\n            min_time = max(min_time, marker_x)\n            max_time = max(max_time, marker_x + distance - 1)\n        elif direction == 2:\n            min_time = max(min_time, h - marker_y - 1)\n            max_time = max(max_time, h - marker_y - distance)\n        elif direction == 3:\n            min_time = max(min_time, w - marker_x - 1)\n            max_time = max(max_time, w - marker_x - distance)\n\n        # Check if marker can still draw the pattern\n        for y in range(h):\n            for x in range(w):\n                if head[y][x] == \"#\" and (marker_y != y or marker_x != x):\n                    max_time = -1\n                    min_time = -1\n                    break\n            if min_time == -1:\n                break\n\n    # Return result\n    return f\"{min_time} {max_time}\""
    },
    {
        "number": 3037,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[0].split())\n    pattern = [list(line.rstrip()) for line in stdin.split('\\n')[1:h+1]]\n    commands = [line.rstrip().split() for line in stdin.split('\\n')[h+1:h+n+1]]\n\n    def get_direction(direction: str, x: int, y: int) -> Tuple[int, int]:\n        if direction == 'up':\n            return x-1, y\n        elif direction == 'down':\n            return x+1, y\n        elif direction == 'left':\n            return x, y-1\n        else:\n            return x, y+1\n\n    def mark_board(board: List[List[str]], x: int, y: int, direction: str, distance: int) -> Tuple[int, int]:\n        x_new, y_new = get_direction(direction, x, y)\n        for i in range(distance):\n            board[x_new+i][y_new+i] = '#'\n        return x_new+distance-1, y_new+distance-1\n\n    def dry_marker(board: List[List[str]], x: int, y: int) -> int:\n        dry_timestep = -1\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == '#':\n                    dry_timestep = max(dry_timestep, i+j)\n        return dry_timestep\n\n    board = [['.' for _ in range(w)] for _ in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if pattern[i][j] == '#':\n                board[i][j] = '#'\n\n    x, y = 0, 0\n    for command in commands:\n        direction, distance = command[0], int(command[1])\n        x, y = mark_board(board, x, y, direction, distance)\n\n    dry_min = dry_marker(board, x, y)\n    if dry_min == -1:\n        return \"0 -1\"\n    dry_max = dry_marker(board, x, y)\n\n    return f\"{dry_min} {dry_max}\""
    },
    {
        "number": 3037,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.readline().strip().split())\n    head = [list(stdin.readline().strip()) for _ in range(h)]\n    commands = []\n    for _ in range(n):\n        direction, distance = stdin.readline().strip().split()\n        commands.append((direction, int(distance)))\n\n    board = [[0] * w for _ in range(h)]\n    marker = (0, 0)\n    min_time, max_time = float('inf'), -1\n    for command in commands:\n        direction, distance = command\n        dx, dy = 0, 0\n        if direction == 'up':\n            dy = -1\n        elif direction == 'down':\n            dy = 1\n        elif direction == 'left':\n            dx = -1\n        elif direction == 'right':\n            dx = 1\n        for _ in range(distance):\n            x, y = marker\n            x += dx\n            y += dy\n            if 0 <= x < h and 0 <= y < w:\n                board[x][y] = 1\n            marker = x, y\n            min_time = min(min_time, board[x][y])\n            max_time = max(max_time, board[x][y])\n\n    if min_time == float('inf'):\n        return '-1 -1'\n    return f'{min_time} {max_time}'"
    },
    {
        "number": 3037,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    h, w, n = map(int, input().split())\n    pattern = []\n    for i in range(h):\n        pattern.append(input())\n    commands = []\n    for i in range(n):\n        commands.append(input().split())\n\n    # Initialize the whiteboard and the turtle\n    whiteboard = [['#' if c == '#' else '.' for c in row] for row in pattern]\n    x, y = 0, 0\n\n    # Execute the commands\n    for command, distance in commands:\n        if command == 'up':\n            x -= distance\n        elif command == 'down':\n            x += distance\n        elif command == 'left':\n            y -= distance\n        elif command == 'right':\n            y += distance\n        whiteboard[x][y] = '*'\n\n    # Find the min and max time the marker can dry out\n    min_time, max_time = -1, -1\n    for i, row in enumerate(whiteboard):\n        for j, cell in enumerate(row):\n            if cell == '*':\n                min_time = max(min_time, i * w + j)\n                max_time = max(max_time, i * w + j)\n\n    # Check if the target drawing can be obtained\n    if all(c == '.' for row in whiteboard for c in row):\n        return f\"{min_time} {max_time}\"\n    else:\n        return \"-1 -1\""
    },
    {
        "number": 3037,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.readline().split())\n    board = [list(stdin.readline().strip()) for _ in range(h)]\n    commands = [stdin.readline().strip() for _ in range(n)]\n    \n    min_time, max_time = dry_time(h, w, board, commands)\n    \n    return f\"{min_time} {max_time}\"\n\ndef"
    },
    {
        "number": 3038,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.split('\\n')[0].split())\n    companies = []\n\n    for i in range(1, k + 1):\n        l_i, *package_sizes = map(int, stdin.split('\\n')[i].split())\n        companies.append({package_size: l_i for package_size in package_sizes})\n\n    def get_min_pack_size(target_bolts: int) -> int:\n        current_pack_size = 0\n        while target_bolts > 0:\n            for company in companies:\n                for pack_size, count in company.items():\n                    if pack_size > current_pack_size:\n                        continue\n                    target_bolts -= pack_size * count\n                    if target_bolts <= 0:\n                        return current_pack_size\n            current_pack_size += 1\n        return -1\n\n    min_pack_size = get_min_pack_size(B)\n    if min_pack_size == -1:\n        return \"impossible\"\n    return str(min_pack_size)\n\ndef"
    },
    {
        "number": 3038,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.split('\\n')[0].split())\n    stdin = stdin.split('\\n')[1:]\n    companies = []\n    \n    for i in range(k):\n        l, *sizes = list(map(int, stdin[i].split()))\n        company = {\"packs\": {}}\n        for j in range(l):\n            company[\"packs\"][sizes[j]] = 0\n        companies.append(company)\n    \n    def dfs(company_index, current_bolts, current_pack_size, packs_so_far):\n        if current_bolts >= B:\n            return current_pack_size\n        \n        if company_index == len(companies):\n            return float('inf')\n        \n        company = companies[company_index]\n        min_pack_size = float('inf')\n        \n        for pack_size, pack_count in company[\"packs\"].items():\n            if pack_count > 0:\n                company[\"packs\"][pack_size] -= 1\n                current_bolts += pack_size\n                min_pack_size = min(min_pack_size, dfs(company_index + 1, current_bolts, current_pack_size + pack_size, packs_so_far + [pack_size]))\n                current_bolts -= pack_size\n                company[\"packs\"][pack_size] += 1\n                \n        return min_pack_size\n    \n    min_pack_size = dfs(0, 0, 0, [])\n    \n    if min_pack_size == float('inf'):\n        return \"impossible\"\n    else:\n        return str(min_pack_size)"
    },
    {
        "number": 3038,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    B, k = list(map(int, stdin.split('\\n')[0].split()))\n    companies = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    # initialize data structures\n    min_pack_size = float('inf')\n    max_pack_size = float('-inf')\n    pack_sizes = {}\n    for company_id, pack_sizes_company in enumerate(companies):\n        l, *pack_sizes_list = pack_sizes_company\n        pack_sizes_list = list(set(pack_sizes_list))  # remove duplicates\n        pack_sizes_list.sort()\n        pack_sizes[company_id] = {pack_size: 0 for pack_size in pack_sizes_list}\n        \n        # update min and max pack sizes\n        min_pack_size = min(min_pack_size, pack_sizes_list[0])\n        max_pack_size = max(max_pack_size, pack_sizes_list[-1])\n        \n    # fill in pack sizes\n    for company_id, pack_sizes_company in enumerate(companies):\n        l, *pack_sizes_list = pack_sizes_company\n        for pack_size in pack_sizes_list:\n            if company_id == 0:\n                pack_sizes[company_id][pack_size] = pack_size\n            else:\n                for prev_company_id in range(company_id):\n                    prev_pack_sizes = pack_sizes[prev_company_id]\n                    for prev_pack_size in prev_pack_sizes:\n                        if prev_pack_sizes[prev_pack_size] > 0 and pack_size - prev_pack_size <= 0:\n                            pack_sizes[company_id][pack_size] += prev_pack_sizes[prev_pack_size]\n                            prev_pack_sizes[prev_pack_size] -= 1\n    \n    # find pack size with B bolts\n    for pack_size in range(min_pack_size, max_pack_size + 1):\n        bolt_count = 0\n        for company_id in range(k):\n            bolt_count += pack_sizes[company_id].get(pack_size, 0)\n        if bolt_count >= B:\n            return str(pack_size)\n    \n    return \"impossible\""
    },
    {
        "number": 3038,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.splitlines()[0].split())\n    companies = []\n    for i in range(1, k+1):\n        num_packs, *pack_sizes = map(int, stdin.splitlines()[i].split())\n        pack_sizes = [0] + pack_sizes\n        companies.append([num_packs, pack_sizes])\n\n    def check_package(company_id: int, pack_id: int) -> int:\n        company = companies[company_id]\n        pack_size = company[1][pack_id]\n        if pack_size == 0:\n            return 0\n        if company_id == len(companies) - 1:\n            return pack_size\n        min_pack_size = float(\"inf\")\n        for i in range(1, company[0] + 1):\n            if i != pack_id and company[1][i] != 0:\n                min_pack_size = min(min_pack_size, check_package(company_id + 1, i))\n        return max(pack_size, min_pack_size)\n\n    min_pack_size = float(\"inf\")\n    for i in range(len(companies)):\n        for j in range(1, companies[i][0] + 1):\n            if companies[i][1][j] != 0:\n                min_pack_size = min(min_pack_size, check_package(i, j))\n\n    if min_pack_size <= B:\n        return str(min_pack_size)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3038,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.splitlines()[0].split())\n    companies = []\n    for line in stdin.splitlines()[1:1+k]:\n        l, *packages = map(int, line.split())\n        companies.append((l, packages))\n\n    def dfs(bolts_needed, company, visited):\n        if company in visited:\n            return float('inf')\n        visited.add(company)\n        l, packages = companies[company]\n        min_pack_size = float('inf')\n        for pack in packages:\n            if pack >= bolts_needed:\n                min_pack_size = min(min_pack_size, pack)\n            else:\n                min_pack_size = min(min_pack_size, dfs(bolts_needed - pack, (company + 1) % k, visited))\n        return min_pack_size\n\n    min_pack_size = dfs(B, 0, set())\n    if min_pack_size == float('inf'):\n        return \"impossible\"\n    else:\n        return str(min_pack_size)"
    },
    {
        "number": 3038,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.split(\"\\n\")[0].split())\n    companies = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:1+k]]\n    \n    def get_real_amount(company_index: int, package_index: int) -> int:\n        company = companies[company_index]\n        pack_size = company[package_index + 1]\n        real_amount = pack_size\n        if package_index == 0:\n            return real_amount\n        for i in range(package_index):\n            if company[i + 1] <= pack_size:\n                real_amount += get_real_amount(company_index, i)\n        return real_amount\n    \n    def get_min_pack_size(B: int) -> int:\n        min_pack_size = float(\"inf\")\n        for company_index in range(k):\n            company = companies[company_index]\n            for package_index in range(company[0]):\n                pack_size = company[package_index + 1]\n                real_amount = get_real_amount(company_index, package_index)\n                if real_amount >= B and pack_size < min_pack_size:\n                    min_pack_size = pack_size\n        return min_pack_size\n    \n    min_pack_size = get_min_pack_size(B)\n    if min_pack_size == float(\"inf\"):\n        return \"impossible\"\n    else:\n        return str(min_pack_size)\n\ndef"
    },
    {
        "number": 3038,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.splitlines()[0].split())\n    companies = []\n\n    for i in range(k):\n        l, *sizes = map(int, stdin.splitlines()[i+1].split())\n        companies.append((l, sizes))\n\n    def get_minimum_pack_size(company_index: int, bolts_needed: int) -> int:\n        if company_index == 0:\n            return bolts_needed\n\n        l, sizes = companies[company_index]\n        current_bolts = 0\n        min_pack_size = float('inf')\n\n        for size in sizes:\n            if current_bolts + size <= bolts_needed:\n                current_bolts += size\n                pack_size = get_minimum_pack_size(company_index - 1, bolts_needed - current_bolts)\n                if pack_size != -1 and pack_size < min_pack_size:\n                    min_pack_size = pack_size\n            else:\n                break\n\n        return min_pack_size\n\n    min_pack_size = get_minimum_pack_size(k - 1, B)\n    return min_pack_size if min_pack_size != float('inf') else 'impossible'"
    },
    {
        "number": 3038,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    b, k = map(int, stdin.split(\"\\n\")[0].split())\n    companies = []\n    for i in range(k):\n        l, *sizes = map(int, stdin.split(\"\\n\")[i+1].split())\n        companies.append([l, sizes])\n\n    def helper(target, company_index, packages):\n        if company_index == k:\n            return min(packages, default=float(\"inf\"))\n\n        company = companies[company_index]\n        l, sizes = company\n\n        current_package = float(\"inf\")\n        for i in range(l):\n            current_package = min(current_package, helper(target, company_index+1, [sum(packages) + sizes[i]]))\n\n        return current_package\n\n    result = helper(b, 0, [])\n    return \"impossible\" if result == float(\"inf\") else str(result)"
    },
    {
        "number": 3038,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.split('\\n')[0].split())\n    stdin = stdin.split('\\n')[1:]\n\n    companies = []\n    for i in range(k):\n        l_i, *pack_sizes = map(int, stdin[i].split())\n        companies.append(pack_sizes)\n\n    total_bolts = sum([sum(companies[i]) for i in range(k)])\n\n    if B > total_bolts:\n        return \"impossible\"\n\n    smallest_pack_size = 10000\n    for pack_size in range(1, total_bolts // B + 1):\n        if total_bolts % pack_size == 0:\n            smallest_pack_size = pack_size\n            break\n\n    if smallest_pack_size == 10000:\n        return \"impossible\"\n\n    return smallest_pack_size\n"
    },
    {
        "number": 3038,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_smallest_pack_size(num_bolts, companies) -> int:\n        min_size = float('inf')\n        for company_index in range(len(companies)):\n            company = companies[company_index]\n            for pack_index in range(len(company)):\n                pack_size = company[pack_index]\n                num_bolts -= pack_size\n                if num_bolts <= 0:\n                    min_size = min(min_size, pack_size)\n                    break\n                num_bolts += pack_size\n        return min_size\n\n    num_bolts, num_companies = [int(x) for x in stdin.splitlines()[0].split()]\n    companies = []\n    for i in range(num_companies):\n        companies.append([int(x) for x in stdin.splitlines()[i+1].split()[1:]])\n\n    smallest_pack_size = find_smallest_pack_size(num_bolts, companies)\n    if smallest_pack_size == float('inf'):\n        return \"impossible\"\n    else:\n        return str(smallest_pack_size)"
    },
    {
        "number": 3039,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    grid = [list(line) for line in stdin.splitlines()]\n\n    # Check if there are exactly 6 #'s\n    if sum(line.count('#') for line in grid) != 6:\n        return \"cannot fold\"\n\n    # Check if there are no 2x2 subsquares\n    for x in range(5):\n        for y in range(5):\n            if all(grid[y + i][x + j] == '#' for i in range(2) for j in range(2)):\n                return \"cannot fold\"\n\n    # Check if the grid can be folded into a cube\n    def count_cube_folds(grid: List[List[str]]) -> int:\n        count = 0\n        for i in range(3):\n            for j in range(3):\n                if grid[i][j] == '#':\n                    count += 1\n        return count\n\n    # Check all possible foldings\n    for i in range(3):\n        for j in range(3):\n            if grid[i][j] == '#':\n                # Try to fold the cube along the x-axis\n                if i == 1:\n                    new_grid = [grid[0], grid[2], grid[3], grid[5], grid[4], grid[1]]\n                    if count_cube_folds(new_grid) == 6:\n                        return \"can fold\"\n                # Try to fold the cube along the y-axis\n                elif j == 1:\n                    new_grid = [grid[0], grid[1], grid[3], grid[4], grid[2], grid[5]]\n                    if count_cube_folds(new_grid) == 6:\n                        return \"can fold\"\n\n    return \"cannot fold\""
    },
    {
        "number": 3039,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_array = [list(line) for line in stdin.split(\"\\n\")]\n    \n    def count_hash(x1, y1, x2, y2):\n        return sum(1 for i in range(x1, x2+1) for j in range(y1, y2+1) if input_array[i][j] == \"#\")\n    \n    for i in range(6):\n        for j in range(6):\n            if input_array[i][j] == \"#\":\n                if count_hash(i-1, j, i+1, j) != 2 or count_hash(i, j-1, i, j+1) != 2:\n                    return \"cannot fold\"\n                if count_hash(i-1, j-1, i+1, j+1) == 2:\n                    return \"can fold\"\n    return \"cannot fold\"\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Given a string representing the initial arrangement of unit squares, check if the squares can be folded into a cube.\n\n    Args:\n        stdin: A string representing the input arrangement.\n\n    Returns:\n        A string indicating if the squares can be folded into a cube (\"can fold\") or not (\"cannot fold\").\n    \"\"\"\n    rows = stdin.split(\"\\n\")\n    if len(rows) != 6:\n        return \"cannot fold\"\n\n    for row in rows:\n        if len(row) != 6:\n            return \"cannot fold\"\n\n    squares = set()\n    for y in range(6):\n        for x in range(6):\n            if rows[y][x] == \"#\":\n                squares.add((x, y))\n\n    for square in squares:\n        if square[0] < 5 and (square[0] + 1, square[1]) in squares:\n            if (square[0], square[1] - 1) in squares and (square[0], square[1] + 1) in squares:\n                return \"cannot fold\"\n            elif (square[0] + 1, square[1] - 1) in squares and (square[0] + 1, square[1] + 1) in squares:\n                return \"cannot fold\"\n        if square[1] < 5 and (square[0], square[1] + 1) in squares:\n            if (square[0] - 1, square[1]) in squares and (square[0] + 1, square[1]) in squares:\n                return \"cannot fold\"\n            elif (square[0] - 1, square[1] + 1) in squares and (square[0] + 1, square[1] + 1) in squares:\n                return \"cannot fold\"\n\n    return \"can fold\""
    },
    {
        "number": 3039,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    grid = [list(row) for row in stdin.split(\"\\n\")]\n    n_rows, n_cols = len(grid), len(grid[0])\n    empty = 0\n    squares = 0\n\n    for i in range(n_rows):\n        for j in range(n_cols):\n            if grid[i][j] == \".\":\n                empty += 1\n            elif grid[i][j] == \"#\":\n                squares += 1\n\n    if squares != 6:\n        return \"cannot fold\"\n\n    def is_connected(x1, y1, x2, y2):\n        queue = [(x1, y1)]\n        visited = set()\n\n        while queue:\n            x, y = queue.pop(0)\n            visited.add((x, y))\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < n_rows and 0 <= ny < n_cols and (nx, ny) not in visited:\n                    if grid[nx][ny] == \"#\":\n                        queue.append((nx, ny))\n\n        return len(visited) == empty + squares\n\n    if not is_connected(0, 0, 0, n_cols - 1) or not is_connected(n_rows - 1, 0, n_rows - 1, n_cols - 1):\n        return \"cannot fold\"\n\n    for i in range(n_rows):\n        if \"#\" in grid[i]:\n            j = grid[i].index(\"#\")\n            if j == 0 or grid[i - 1][j - 1] == \"#\" or grid[i - 1][j] == \"#\":\n                return \"cannot fold\"\n        if \"#\" in grid[n_rows - i - 1]:\n            j = grid[n_rows - i - 1].index(\"#\")\n            if j == n_cols - 1 or grid[n_rows - i][j + 1] == \"#\" or grid[n_rows - i - 1][j + 1] == \"#\":\n                return \"cannot fold\"\n\n    if \"#\" in grid[n_rows // 2]:\n        return \"cannot fold\"\n\n    return \"can fold\""
    },
    {
        "number": 3039,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split('\\n')\n    if len(stdin) != 6:\n        return \"cannot fold\"\n\n    for row in stdin:\n        if len(row) != 6:\n            return \"cannot fold\"\n\n    # Check if the initial arrangement is valid\n    for i in range(len(stdin)):\n        for j in range(len(stdin[i])):\n            if stdin[i][j] == '#' and (i == 0 or j == 0 or i == len(stdin) - 1 or j == len(stdin[i]) - 1):\n                return \"cannot fold\"\n\n    # Check if there is a 2x2 subsquare consisting of only #\n    for i in range(len(stdin) - 1):\n        for j in range(len(stdin[i]) - 1):\n            if stdin[i][j] == '#' and stdin[i + 1][j] == '#' and stdin[i][j + 1] == '#' and stdin[i + 1][j + 1] == '#':\n                return \"cannot fold\"\n\n    return \"can fold\""
    },
    {
        "number": 3039,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(grid: List[str]) -> bool:\n        rows, cols = len(grid), len(grid[0])\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == \"#\" and (i - 1 >= 0 and grid[i - 1][j] == \"#\" or j - 1 >= 0 and grid[i][j - 1] == \"#\"):\n                    return False\n        return True\n\n    def can_fold(grid: List[str]) -> bool:\n        rows, cols = len(grid), len(grid[0])\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == \"#\":\n                    # Check if we can fold to the right\n                    if j + 1 < cols and grid[i][j + 1] == \"#\" and i + 1 < rows and grid[i + 1][j] == \".\":\n                        return True\n                    # Check if we can fold to the left\n                    if j - 1 >= 0 and grid[i][j - 1] == \"#\" and i + 1 < rows and grid[i + 1][j] == \".\":\n                        return True\n                    # Check if we can fold upwards\n                    if i - 1 >= 0 and grid[i - 1][j] == \"#\" and j + 1 < cols and grid[i][j + 1] == \".\":\n                        return True\n                    # Check if we can fold downwards\n                    if i + 1 < rows and grid[i + 1][j] == \"#\" and j + 1 < cols and grid[i][j + 1] == \".\":\n                        return True\n        return False\n\n    grid = [line.strip() for line in stdin.split(\"\\n\") if line.strip()]\n\n    if not is_valid(grid):\n        return \"cannot fold\"\n\n    if can_fold(grid):\n        return \"can fold\"\n    else:\n        return \"cannot fold\"\n\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_matrix = [list(line) for line in stdin.split(\"\\n\")[:-1]]\n\n    def find_component(matrix: List[List[str]], visited: set) -> List[Tuple[int, int]]:\n        component = []\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == \"#\" and (i, j) not in visited:\n                    visited.add((i, j))\n                    component.extend(find_component(matrix, visited))\n        return component\n\n    def can_fold(component: List[Tuple[int, int]]) -> bool:\n        min_i, min_j = min(component, key=lambda p: (p[0], p[1]))\n        max_i, max_j = max(component, key=lambda p: (p[0], p[1]))\n\n        for i in range(min_i, max_i + 1):\n            for j in range(min_j, max_j + 1):\n                if (i, j) not in component:\n                    if i == min_i or i == max_i or j == min_j or j == max_j:\n                        continue\n                    return False\n        return True\n\n    visited = set()\n    components = [find_component(input_matrix, visited) for _ in range(6)]\n\n    for component in components:\n        if can_fold(component):\n            return \"can fold\"\n    return \"cannot fold\""
    },
    {
        "number": 3039,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    for i in range(len(lines) - 1):\n        if lines[i].count(\"#\") != lines[i + 1].count(\"#\"):\n            return \"cannot fold\"\n    if \"##\" in lines[2]:\n        return \"cannot fold\"\n    return \"can fold\""
    },
    {
        "number": 3039,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Convert input to a 2D list\n    matrix = [list(row) for row in stdin.split()]\n\n    # Check if we can form a cube by folding the matrix\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == \"#\":\n                # Check if we can form a cube from the current \"#\"\n                if i == 0 or i == len(matrix) - 1 or j == 0 or j == len(matrix[0]) - 1:\n                    continue\n                if matrix[i - 1][j] == \"#\" and matrix[i + 1][j] == \"#\" and matrix[i][j - 1] == \"#\" and matrix[i][j + 1] == \"#\":\n                    return \"can fold\"\n    return \"cannot fold\""
    },
    {
        "number": 3039,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_matrix = [list(row) for row in stdin.split()]\n    height = len(input_matrix)\n    width = len(input_matrix[0])\n    \n    # Check for the pattern of a cube\n    for i in range(height - 2):\n        for j in range(width - 2):\n            if input_matrix[i][j] == '#' and input_matrix[i][j+1] == '#' and input_matrix[i][j+2] == '#' and input_matrix[i+1][j+1] == '#' and input_matrix[i+2][j] == '#' and input_matrix[i+2][j+1] == '#' and input_matrix[i+2][j+2] == '#':\n                return \"can fold\"\n                \n    # Check for the pattern of a cube with a rotation\n    for i in range(height - 2):\n        for j in range(width - 2):\n            if input_matrix[i][j] == '#' and input_matrix[i+1][j] == '#' and input_matrix[i+2][j] == '#' and input_matrix[i+1][j+1] == '#' and input_matrix[i][j+1] == '#' and input_matrix[i][j+2] == '#' and input_matrix[i][j+3] == '#':\n                return \"can fold\"\n                \n    return \"cannot fold\""
    },
    {
        "number": 3040,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Create a set to store all unique substrings\n    substrings = set()\n    max_length = 0\n    max_substring = \"\"\n    \n    for i in range(len(stdin)):\n        # Check all substrings of length 1 to len(stdin)\n        for j in range(i, len(stdin)):\n            # Add substring to set\n            substring = stdin[i:j+1]\n            if substring in substrings:\n                # If substring is already in set, update max_length and max_substring\n                if len(substring) > max_length:\n                    max_length = len(substring)\n                    max_substring = substring\n            else:\n                # If substring is not in set, add it\n                substrings.add(substring)\n    \n    # Return the longest repeated substring\n    return max_substring "
    },
    {
        "number": 3040,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    max_len = 0\n    max_substring = \"\"\n\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = stdin[i:j]\n            count = stdin.count(substring)\n            if count > 1 and len(substring) > max_len:\n                max_len = len(substring)\n                max_substring = substring\n\n    return max_substring"
    },
    {
        "number": 3040,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    longest_substring = \"\"\n    substrings = {}\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = stdin[i:j]\n            if substring in substrings:\n                substrings[substring] += 1\n                if len(substring) > len(longest_substring):\n                    longest_substring = substring\n            else:\n                substrings[substring] = 1\n    return longest_substring"
    },
    {
        "number": 3040,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    longest_substring = \"\"\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = stdin[i:j]\n            if stdin.count(substring) > 1 and len(substring) > len(longest_substring):\n                longest_substring = substring\n    return longest_substring"
    },
    {
        "number": 3040,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    longest_substring = \"\"\n    current_substring = \"\"\n\n    for char in stdin:\n        if char not in current_substring:\n            current_substring += char\n        else:\n            if len(current_substring) > len(longest_substring):\n                longest_substring = current_substring\n\n            current_substring = current_substring[current_substring.index(char) + 1:] + char\n\n    return longest_substring"
    },
    {
        "number": 3040,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    longest_substring = \"\"\n    current_substring = \"\"\n    \n    for char in stdin:\n        if char in current_substring:\n            current_substring += char\n        else:\n            current_substring = char\n        \n        if len(current_substring) > len(longest_substring):\n            longest_substring = current_substring\n    \n    return longest_substring\n\ndef"
    },
    {
        "number": 3040,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    max_len = 0\n    max_substring = \"\"\n    for i in range(len(stdin)):\n        for j in range(i+1, len(stdin)+1):\n            substring = stdin[i:j]\n            count = stdin.count(substring)\n            if count > 1 and len(substring) > max_len:\n                max_len = len(substring)\n                max_substring = substring\n    return max_substring"
    },
    {
        "number": 3040,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    longest_substring = \"\"\n    for i in range(len(stdin)):\n        for j in range(i+1, len(stdin)+1):\n            substring = stdin[i:j]\n            if stdin.count(substring) > 1:\n                if len(substring) > len(longest_substring):\n                    longest_substring = substring\n                elif len(substring) == len(longest_substring) and substring < longest_substring:\n                    longest_substring = substring\n    return longest_substring"
    },
    {
        "number": 3040,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    max_length = 0\n    max_substring = \"\"\n\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = stdin[i:j]\n            count = stdin.count(substring)\n\n            if count > 1 and len(substring) > max_length:\n                max_length = len(substring)\n                max_substring = substring\n\n    return max_substring"
    },
    {
        "number": 3040,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    max_length = 0\n    max_substring = \"\"\n    seen_substrings = set()\n\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = stdin[i:j]\n            if substring in seen_substrings and len(substring) > max_length:\n                max_length = len(substring)\n                max_substring = substring\n            if len(substring) > 1:\n                seen_substrings.add(substring)\n\n    return max_substring"
    },
    {
        "number": 3041,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    trips = []\n    lines = stdin.split(\"\\n\")\n    num_trips = int(lines[0])\n\n    for i in range(1, num_trips + 1):\n        trip = lines[i].split()\n        trips.append((int(trip[0]), int(trip[1])))\n\n    trips.sort(key=lambda x: x[1])\n    current_zone = 0\n    coupons = 0\n    start_times = []\n\n    for i in range(num_trips):\n        trip = trips[i]\n        if trip[1] - trip[0] > 10:\n            coupons += 1 + trip[1] - trip[0]\n        else:\n            while len(start_times) > 0 and trip[1] - start_times[0] > 10000:\n                start_times.pop(0)\n            coupons += 1 + len(start_times) + trip[1] - trip[0] - len(start_times)\n            start_times.append(trip[1])\n\n        current_zone = trip[0]\n\n    return str(coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    trips = []\n    for line in stdin.split('\\n')[1:]:\n        if not line:\n            break\n        zone, time = map(int, line.split())\n        trips.append((zone, time))\n\n    coupons = 0\n    current_ticket = None\n    for trip in trips:\n        zone, time = trip\n\n        if current_ticket is None or current_ticket[0] > zone:\n            start_zone = 0\n        else:\n            start_zone = current_ticket[0]\n\n        end_zone = zone\n        duration = time - current_ticket[1] if current_ticket else 0\n\n        coupons += 2 + abs(start_zone - end_zone)\n        current_ticket = (end_zone, time)\n\n    return str(coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def ticket_price(start_zone, end_zone):\n        return 2 + abs(start_zone - end_zone)\n\n    trips = []\n    for line in stdin.strip().split(\"\\n\")[1:]:\n        start_zone, end_zone = map(int, line.strip().split(\" \"))\n        trips.append((start_zone, end_zone))\n\n    coupons_spent = 0\n    prev_zone = 0\n    for trip in trips:\n        start_zone, end_zone = trip\n        if prev_zone != start_zone:\n            coupons_spent += ticket_price(prev_zone, start_zone)\n        prev_zone = end_zone\n\n    return str(coupons_spent)"
    },
    {
        "number": 3041,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    trips = []\n\n    for i in range(1, N + 1):\n        trip = lines[i].split()\n        trips.append([int(trip[0]), int(trip[1])])\n\n    trips.sort(key=lambda x: x[1])\n    coupons = 0\n    A, B = 0, 0\n\n    for trip in trips:\n        Z, T = trip\n\n        if Z > B:\n            coupons += 2 + abs(B - A)\n            A, B = Z - 1, Z + 1\n        else:\n            B = max(B, Z + 1)\n\n    return str(coupons + 2 + abs(B - A)) "
    },
    {
        "number": 3041,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    trips = []\n    for i in range(1, n + 1):\n        z, t = map(int, lines[i].split())\n        trips.append((z, t))\n\n    def cost(start_zone: int, end_zone: int) -> int:\n        return 2 + abs(start_zone - end_zone)\n\n    def valid_tickets(tickets: list, new_ticket: tuple) -> list:\n        new_start_zone, new_end_zone = new_ticket\n        valid = []\n        for ticket in tickets:\n            start_zone, end_zone = ticket\n            if new_start_zone >= start_zone and new_end_zone <= end_zone:\n                valid.append(ticket)\n        return valid\n\n    tickets = []\n    total_cost = 0\n    prev_zone = 0\n    for trip in trips:\n        end_zone, time = trip\n        if not tickets or time - prev_time >= 10000:\n            valid = valid_tickets(tickets, (prev_zone, end_zone))\n            new_cost = cost(prev_zone, end_zone)\n            if not valid:\n                tickets.append((prev_zone, end_zone))\n            else:\n                min_cost = min(cost(t[0], t[1]) for t in valid)\n                if new_cost < min_cost:\n                    tickets = valid_tickets(tickets, (prev_zone, end_zone))\n            total_cost += new_cost\n        prev_zone = end_zone\n        prev_time = time\n\n    return str(total_cost)"
    },
    {
        "number": 3041,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    trips = []\n\n    for i in range(1, n + 1):\n        trip = list(map(int, lines[i].split()))\n        trips.append(trip)\n\n    coupons = 0\n    for i in range(1, n):\n        current_zone = trips[i - 1][0]\n        next_zone = trips[i][0]\n        interval = (min(current_zone, next_zone), max(current_zone, next_zone))\n        coupons += 2 + abs(interval[0] - interval[1])\n\n    return str(coupons)\n\nstdin = \"\"\nwith open(\"input.txt\", \"r\") as file:\n    stdin = file.read()\n\noutput = solution(stdin)\nwith open(\"output.txt\", \"w\") as file:\n    file.write(output) "
    },
    {
        "number": 3041,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    trips = []\n    for line in stdin.split(\"\\n\")[1:]:\n        if not line:\n            break\n        zone, time = map(int, line.split())\n        trips.append((zone, time))\n\n    coupons = 0\n    current_zone = 0\n    current_time = 0\n\n    for zone, time in trips:\n        # If the trip starts from a different zone than the current one, buy a new ticket\n        if zone != current_zone:\n            coupons += 2 + abs(current_zone - zone)\n            current_zone = zone\n\n        # If the trip overlaps with the validity of the current ticket,\n        # extend the validity of the ticket\n        if time < 10000:\n            coupons -= 10000 - time\n\n        # If the trip ends after the validity of the current ticket,\n        # buy a new ticket for the remaining trip\n        if time > 10000:\n            coupons += time - 10000\n\n        # Update the current time and zone\n        current_time = time\n\n    return str(coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_coupons(trips: list) -> int:\n        coupons = 0\n        current_zone = 0\n        current_time = 0\n\n        for trip in trips:\n            zone, time = trip\n\n            if time < current_time:\n                raise ValueError(\"Invalid input: Time must be strictly increasing.\")\n\n            if zone < current_zone:\n                raise ValueError(\"Invalid input: Zones must be increasing.\")\n\n            if zone > current_zone:\n                coupons += 2 + abs(current_zone - zone)\n                current_zone = zone\n\n        return coupons\n\n    trips = []\n    for line in stdin.strip().split('\\n'):\n        zone, time = map(int, line.split())\n        trips.append((zone, time))\n\n    return str(get_min_coupons(trips))"
    },
    {
        "number": 3041,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    trips = []\n    lines = stdin.splitlines()\n    num_trips = int(lines[0])\n    \n    for i in range(1, num_trips + 1):\n        trip = list(map(int, lines[i].split()))\n        trips.append(trip)\n    \n    coupons = 0\n    current_zone = 0\n    for trip in trips:\n        start_zone = trip[0]\n        end_zone = trip[1]\n        interval = [current_zone, start_zone, end_zone]\n        interval.sort()\n        coupons += 2 + abs(interval[1] - interval[2])\n        current_zone = end_zone\n    \n    return str(coupons) "
    },
    {
        "number": 3041,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n = int(stdin.splitlines()[0])\n    trips = []\n    for i in range(1, n + 1):\n        trip = stdin.splitlines()[i].split()\n        trips.append((int(trip[0]), int(trip[1])))\n\n    # Sort trips by time\n    trips.sort(key=lambda x: x[1])\n\n    # Calculate minimum number of coupons\n    coupons = 0\n    current_zone = 0\n    for trip in trips:\n        if trip[0] != current_zone:\n            coupons += 2 + abs(current_zone - trip[0])\n            current_zone = trip[0]\n\n    return str(coupons)"
    },
    {
        "number": 3042,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import math\n    MOD = 1000000007\n    stdin = list(map(int, stdin.split()))\n    n = stdin[0]\n    values = stdin[1:]\n\n    def lcm(x: int, y: int) -> int:\n        return (x * y) // math.gcd(x, y)\n\n    def dfs(values: list, visited: set, parent: int, depth: int) -> int:\n        if depth == 1:\n            return 1\n        count = 0\n        for i, value in enumerate(values):\n            if i not in visited and value % parent == 0:\n                visited.add(i)\n                count += dfs(values, visited, lcm(parent, value), depth + 1)\n                visited.remove(i)\n        return count % MOD\n\n    return str(dfs(values, set(), 1, 1))"
    },
    {
        "number": 3042,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, values = stdin.split()\n    n = int(n)\n    values = list(map(int, values.split()))\n\n    def lcm(x, y):\n        return (x * y) // math.gcd(x, y)\n\n    def lcm_tree(values, start, end):\n        if start == end:\n            return 1\n\n        count = 0\n        for i in range(start, end):\n            for j in range(i + 1, end + 1):\n                count += lcm_tree(values, i, j) * lcm_tree(values, j, end + 1)\n                count %= MOD\n\n        return count\n\n    MOD = 10**9 + 7\n    return str(lcm_tree(values, 0, len(values)))"
    },
    {
        "number": 3042,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, values = stdin.split(\"\\n\")\n    n = int(n)\n    values = [int(x) for x in values.split()]\n\n    def count_ways(values: List[int], i: int, j: int) -> int:\n        if i > j:\n            return 1\n\n        count = 0\n        for k in range(i, j + 1):\n            left_lcm = values[i] * values[k] // math.gcd(values[i], values[k])\n            right_lcm = values[k + 1] * values[j] // math.gcd(values[k + 1], values[j])\n\n            if left_lcm == values[i] and right_lcm == values[j]:\n                count += count_ways(values, i + 1, k - 1) * count_ways(values, k + 2, j - 1)\n\n        return count % (10**9 + 7)\n\n    return str(count_ways(values, 0, n - 1))"
    },
    {
        "number": 3042,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, values = stdin.split()\n    n = int(n)\n    values = list(map(int, values.split()))\n    \n    def dfs(node, lcm):\n        children = [x for x in values if x % node == 0 and x != node]\n        if not children:\n            return 1\n        res = 0\n        for child in children:\n            res += dfs(child, lcm)\n        return res % (10**9 + 7)\n    \n    res = 0\n    for i in range(1, n+1):\n        if i not in values:\n            continue\n        res += dfs(i, i)\n        values.remove(i)\n    \n    return str(res % (10**9 + 7))"
    },
    {
        "number": 3042,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, values = stdin.split('\\n')\n    n = int(n)\n    values = [int(v) for v in values.split()]\n\n    def lcm_tree(values: List[int]) -> int:\n        if len(values) == 1:\n            return 1\n        if len(values) == 2:\n            return (values[0] * values[1]) // math.gcd(values[0], values[1])\n        lcms = []\n        for i in range(len(values)):\n            for j in range(i+1, len(values)):\n                lcm = (values[i] * values[j]) // math.gcd(values[i], values[j])\n                lcms.append(lcm)\n        return sum(lcms)\n\n    MOD = 10**9 + 7\n    return str(lcm_tree(values) % MOD)"
    },
    {
        "number": 3042,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    values = list(map(int, stdin.split()))\n    n = values.pop(0)\n    if n % 2 == 0 or n < 3:\n        return \"0\"\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    def build_tree(values, root_index, root_value, depth):\n        if depth == 0:\n            return root_value\n\n        left_index = 2 * root_index + 1\n        right_index = 2 * root_index + 2\n        left_value = values[left_index]\n        right_value = values[right_index] if right_index < len(values) else None\n\n        if left_value is not None and right_value is not None:\n            lcm_value = lcm(left_value, right_value)\n            if lcm_value != root_value:\n                return 0\n            return build_tree(values, left_index, left_value, depth - 1) * build_tree(values, right_index, right_value, depth - 1)\n        elif left_value is not None:\n            return build_tree(values, left_index, left_value, depth - 1)\n        elif right_value is not None:\n            return build_tree(values, right_index, right_value, depth - 1)\n        else:\n            return 0\n\n    result = build_tree(values, 0, values[0], n // 2)\n    return str(result)"
    },
    {
        "number": 3042,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string by newline characters\n    lines = stdin.split(\"\\n\")\n    # Get the number of nodes\n    n = int(lines[0])\n    # Get the values of the nodes\n    values = list(map(int, lines[1].split()))\n    # Initialize the count of LCM trees\n    count = 0\n    \n    # Iterate through the nodes\n    for i in range(n):\n        # Check if the node has zero or two children\n        if i * 2 + 1 >= n:\n            # The node has no children, so increment the count\n            count += 1\n        elif i * 2 + 2 >= n:\n            # The node has one child, so increment the count\n            count += 1\n        else:\n            # The node has two children\n            # Calculate the LCM of the values of the two children\n            lcm = values[i * 2 + 1] * values[i * 2 + 2] // math.gcd(values[i * 2 + 1], values[i * 2 + 2])\n            # Check if the value of the parent is equal to the LCM\n            if values[i] == lcm:\n                # The LCM of the two children is equal to the value of the parent, so increment the count\n                count += 1\n                \n    # Return the count modulo 10^9 + 7\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3042,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def dfs(node: int, values: List[int], visited: List[bool], graph: List[List[int]], result: List[int], multiplier: int) -> None:\n        visited[node] = True\n        for child in graph[node]:\n            if not visited[child]:\n                dfs(child, values, visited, graph, result, lcm(values[node], values[child]))\n            else:\n                result[0] += multiplier // values[child]\n\n    n = int(stdin.readline().strip())\n    values = list(map(int, stdin.readline().strip().split()))\n    graph = [[] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if gcd(values[i], values[j]) == lcm(values[i], values[j]):\n                graph[i].append(j)\n                graph[j].append(i)\n\n    visited = [False] * n\n    result = [0]\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, values, visited, graph, result, values[i])\n\n    return str(result[0] % (10**9 + 7))"
    },
    {
        "number": 3042,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, values = stdin.split()\n    n = int(n)\n    values = list(map(int, values.split()))\n\n    def count_ways(values: List[int], root_index: int) -> int:\n        if root_index >= len(values):\n            return 1\n        count = 0\n        for i in range(root_index + 1, len(values)):\n            if values[root_index] % values[i] == 0 or values[i] % values[root_index] == 0:\n                values[root_index], values[i] = values[i], values[root_index]\n                count += count_ways(values, root_index + 1)\n        return count\n\n    return str(count_ways(values, 0))"
    },
    {
        "number": 3042,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    nodes = list(map(int, stdin.split()))\n    n = nodes[0]\n    del nodes[0]\n    nodes.sort(reverse=True)\n\n    def is_lcm_tree(node: int) -> bool:\n        if node == 1:\n            return True\n        if node % 2 == 0:\n            return False\n        for i in range(3, int(node ** 0.5) + 1, 2):\n            if node % i == 0 and not is_lcm_tree(i) and not is_lcm_tree(node // i):\n                return False\n        return True\n\n    count = 0\n    for i in range(n):\n        if is_lcm_tree(nodes[i]):\n            count += 1\n\n    return str(count)\n\n\ninput_string = \"7\\n2 3 4 4 8 12 24\"\nprint(solution(input_string)) "
    },
    {
        "number": 3043,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.splitlines()[0].split())\n    grid = [list(line) for line in stdin.splitlines()[1:]]\n    S = find_position(grid, 'S')\n    G = find_position(grid, 'G')\n    if not S or not G:\n        return \"-1\"\n\n    queue = [(0, S)]\n    distances = [[float('inf')] * M for _ in range(N)]\n    distances[S[0]][S[1]] = 0\n\n    def bfs():\n        while queue:\n            day, (i, j) = queue.pop(0)\n            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < N and 0 <= nj < M and grid[ni][nj] != '#':\n                    cost = 1 if grid[ni][nj] in ['.', 'F', 'M'] else 3\n                    new_distance = distances[i][j] + cost\n                    if new_distance < distances[ni][nj]:\n                        distances[ni][nj] = new_distance\n                        queue.append((day + 1, (ni, nj)))\n\n    bfs()\n    return str(distances[G[0]][G[1]] // K)\n\ndef"
    },
    {
        "number": 3043,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, input().split())\n    grid = [list(input()) for _ in range(N)]\n    S, G = find_treasure_and_start(grid)\n    days = plan_trip(S, G, grid, K)\n    return str(days)\n\ndef"
    },
    {
        "number": 3043,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input from stdin\n    N, M, K = map(int, stdin.split('\\n')[0].split())\n    grid = stdin.split('\\n')[1:]\n\n    # Initialize variables\n    start_pos = None\n    goal_pos = None\n    treasure_found = False\n    stamina = K\n    days = 0\n\n    # Iterate through the grid and find the start and goal positions\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_pos = (i, j)\n            elif grid[i][j] == 'G':\n                goal_pos = (i, j)\n\n    # Check if start and goal positions are valid\n    if start_pos is None or goal_pos is None:\n        return \"-1\"\n\n    # Function to check if the current position is valid\n    def is_valid(pos):\n        i, j = pos\n        return 0 <= i < N and 0 <= j < M and grid[i][j] != '#'\n\n    # Function to calculate the cost of moving to a neighboring cell\n    def cost(pos):\n        i, j = pos\n        if grid[i][j] == '.':\n            return 1\n        elif grid[i][j] == 'F':\n            return 2\n        elif grid[i][j] == 'M':\n            return 3\n\n    # BFS to find the shortest path to the goal\n    queue = [(start_pos, [])]\n    visited = set()\n    while queue:\n        pos, path = queue.pop(0)\n        if pos not in visited:\n            visited.add(pos)\n            if pos == goal_pos:\n                stamina += K - cost(pos)\n                days += 2 if stamina >= K else 3\n                stamina = min(stamina, K)\n                return str(days)\n            for neighbor in [(pos[0] - 1, pos[1]), (pos[0] + 1, pos[1]), (pos[0], pos[1] - 1), (pos[0], pos[1] + 1)]:\n                if is_valid(neighbor):\n                    new_path = path + [(pos, neighbor)]\n                    queue.append((neighbor, new_path))\n            days += 1\n            stamina -= cost(pos)\n            stamina = min(stamina, K)\n\n    return \"-1\" "
    },
    {
        "number": 3043,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, input().split())\n    grid = []\n    for _ in range(N):\n        grid.append(list(input()))\n\n    s_pos = None\n    g_pos = None\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                s_pos = (i, j)\n            elif grid[i][j] == 'G':\n                g_pos = (i, j)\n\n    if not s_pos or not g_pos:\n        return \"-1\"\n\n    def get_neighbors(pos):\n        i, j = pos\n        neighbors = []\n        if i > 0 and grid[i - 1][j] != '#':\n            neighbors.append((i - 1, j))\n        if i < N - 1 and grid[i + 1][j] != '#':\n            neighbors.append((i + 1, j))\n        if j > 0 and grid[i][j - 1] != '#':\n            neighbors.append((i, j - 1))\n        if j < M - 1 and grid[i][j + 1] != '#':\n            neighbors.append((i, j + 1))\n        return neighbors\n\n    def bfs(start, target):\n        queue = [start]\n        visited = set()\n        distance = {start: 0}\n\n        while queue:\n            current = queue.pop(0)\n            if current == target:\n                return distance[current]\n\n            if current in visited:\n                continue\n            visited.add(current)\n\n            for neighbor in get_neighbors(current):\n                if neighbor not in visited and grid[neighbor[0]][neighbor[1]] in ('.', 'F', 'M'):\n                    distance[neighbor] = distance[current] + 1\n                    queue.append(neighbor)\n\n        return -1\n\n    stamina = K\n    days = 0\n\n    while stamina > 0:\n        stamina -= 1\n        days += 1\n        stamina = K if days % 2 == 1 else stamina\n\n        if days % 2 == 0:\n            if bfs(s_pos, g_pos) <= stamina:\n                return days\n            else:\n                return \"impossible\"\n\n    return solution(stdin)"
    },
    {
        "number": 3043,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[:N]\n    start_pos = None\n    treasure_pos = None\n\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_pos = (i, j)\n            elif grid[i][j] == 'G':\n                treasure_pos = (i, j)\n\n    if start_pos is None or treasure_pos is None:\n        return \"-1\"\n\n    def get_neighbors(pos):\n        i, j = pos\n        neighbors = [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]\n        return [(x, y) for x, y in neighbors if 0 <= x < N and 0 <= y < M and grid[x][y] != '#']\n\n    def get_cost(pos):\n        i, j = pos\n        return {'.': 1, 'F': 2, 'M': 3}[grid[i][j]]\n\n    def dijkstra(start, end):\n        queue = [(0, start)]\n        dist = {start: 0}\n        visited = set()\n\n        while queue:\n            (d, current) = heappop(queue)\n\n            if current == end:\n                return d\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            for neighbor in get_neighbors(current):\n                new_dist = d + get_cost(neighbor)\n\n                if neighbor not in dist or new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heappush(queue, (new_dist, neighbor))\n\n        return -1\n\n    def get_min_stamina(start, end):\n        stamina = K\n        days = 0\n        stamina_used = 0\n\n        while stamina_used < stamina:\n            days += 1\n            stamina_used = min(stamina, stamina * 2)\n            stamina = K\n\n        return days\n\n    stamina_used = 0\n    days_without_rest = 0\n\n    while stamina_used < K:\n        days_without_rest += 1\n        stamina_used = min(K, stamina_used + K * 2)\n\n    min_stamina = get_min_stamina(start_pos, treasure_pos)\n    min_stamina += days_without_rest\n\n    if min_stamina > days_without_rest * 2:\n        return str(days_without_rest + min_stamina)\n    else:\n        return \"-1\""
    },
    {
        "number": 3043,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, input().split())\n    grid = []\n    for _ in range(N):\n        grid.append(input())\n    \n    def is_passable(cell: str) -> bool:\n        return cell == '.' or cell == 'F'\n    \n    def get_adjacent_cells(cell: tuple) -> List[tuple]:\n        row, col = cell\n        adjacent_cells = []\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < N and 0 <= new_col < M:\n                adjacent_cells.append((new_row, new_col))\n        return adjacent_cells\n    \n    def bfs(start: tuple, end: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current_cell, stamina = queue.pop(0)\n            if current_cell == end:\n                return stamina\n            if current_cell in visited:\n                continue\n            visited.add(current_cell)\n            row, col = current_cell\n            stamina_cost = 1 if grid[row][col] == '.' else 2 if grid[row][col] == 'M' else 3\n            new_stamina = stamina + stamina_cost\n            if new_stamina > K:\n                return -1\n            for adjacent_cell in get_adjacent_cells(current_cell):\n                new_stamina = stamina + stamina_cost\n                if new_stamina > K:\n                    continue\n                queue.append((adjacent_cell, new_stamina))\n        return -1\n    \n    def find_treasure() -> int:\n        for row in range(N):\n            for col in range(M):\n                if grid[row][col] == 'S':\n                    start = (row, col)\n                elif grid[row][col] == 'G':\n                    end = (row, col)\n        stamina_cost = 0\n        return bfs(start, end)\n    \n    return str(find_treasure())"
    },
    {
        "number": 3043,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = list(map(int, stdin.split()[0:3]))\n    grid = [list(row) for row in stdin.split()[3:]]\n    S_pos = None\n    G_pos = None\n\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                S_pos = (i, j)\n            elif grid[i][j] == 'G':\n                G_pos = (i, j)\n\n    def get_min_distance(cell1: tuple, cell2: tuple) -> int:\n        return abs(cell1[0] - cell2[0]) + abs(cell1[1] - cell2[1])\n\n    def get_distance_cost(distance: int) -> int:\n        if distance == 0:\n            return 0\n        return distance + 1 if grid[S_pos[0]][S_pos[1]] == '.' else distance * 2\n\n    def get_min_days_to_reach_treasure(K: int) -> int:\n        queue = [(S_pos, 0, 0)]\n        visited = set()\n        visited.add(S_pos)\n\n        while queue:\n            current_cell, current_days, current_stamina = queue.pop(0)\n\n            if current_cell == G_pos:\n                return current_days\n\n            if current_stamina >= K:\n                for neighbor in [(current_cell[0] - 1, current_cell[1]), (current_cell[0] + 1, current_cell[1]), (current_cell[0], current_cell[1] - 1), (current_cell[0], current_cell[1] + 1)]:\n                    if 0 <= neighbor[0] < N and 0 <= neighbor[1] < M and grid[neighbor[0]][neighbor[1]] != '#' and neighbor not in visited:\n                        distance_cost = get_distance_cost(get_min_distance(current_cell, neighbor))\n                        new_stamina = max(0, current_stamina - distance_cost)\n\n                        queue.append((neighbor, current_days + 1, new_stamina))\n                        visited.add(neighbor)\n            else:\n                if current_stamina < K:\n                    current_stamina += K - current_stamina\n                else:\n                    current_stamina = K\n\n                current_days += 1\n\n                for neighbor in [(current_cell[0] - 1, current_cell[1]), (current_cell[0] + 1, current_cell[1]), (current_cell[0], current_cell[1] - 1), (current_cell[0], current_cell[1] + 1)]:\n                    if 0 <= neighbor[0] < N and 0 <= neighbor[1] < M and grid[neighbor[0]][neighbor[1]] != '#' and neighbor not in visited:\n                        distance_cost = get_distance_cost(get_min_distance(current_cell, neighbor))\n                        new_stamina = max(0, current_stamina - distance_cost)\n\n                        queue.append((neighbor, current_days, new_stamina))\n                        visited.add(neighbor)\n\n        return -1\n\n    min_days = get_min_days_to_reach_treasure(K)\n\n    return str(min_days)"
    },
    {
        "number": 3043,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split(\"\\n\")[1:]\n\n    def get_cost(char: str) -> int:\n        if char == \"F\" or char == \"M\":\n            return 2\n        elif char == \"G\":\n            return 0\n        else:\n            return 1\n\n    def get_position(char: str) -> tuple:\n        for i in range(N):\n            for j in range(M):\n                if grid[i][j] == char:\n                    return i, j\n\n    def bfs(start: tuple, goal: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            (x, y), days = queue.pop(0)\n\n            if (x, y) in visited:\n                continue\n\n            visited.add((x, y))\n\n            if (x, y) == goal:\n                return days\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != \"#\":\n                    queue.append(((nx, ny), days + 1))\n\n        return -1\n\n    sx, sy = get_position(\"S\")\n    gx, gy = get_position(\"G\")\n\n    stamina = K\n    days = 0\n\n    while stamina >= 0 and bfs((sx, sy), (gx, gy)) == -1:\n        days += 1\n        stamina -= get_cost(grid[sx][sy])\n\n        if stamina >= 0 and days % 2 == 1:\n            stamina = K\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = sx + dx, sy + dy\n\n            if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != \"#\":\n                cost = get_cost(grid[nx][ny])\n\n                if stamina - cost >= 0:\n                    stamina -= cost\n                    sx, sy = nx, ny\n                    break\n\n    return str(days)"
    },
    {
        "number": 3043,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_move_possible(landform: str) -> bool:\n        return landform in ['.', 'F']\n\n    def stamina_cost(landform: str) -> int:\n        return {'F': 2, 'M': 3, '.': 1, '#': 0}[landform]\n\n    def find_treasure(grid: List[List[str]]) -> Tuple[int, int]:\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 'G':\n                    return i, j\n        return -1, -1\n\n    def find_start_pos(grid: List[List[str]]) -> Tuple[int, int]:\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 'S':\n                    return i, j\n        return -1, -1\n\n    def bfs(grid: List[List[str]]) -> int:\n        start_pos = find_start_pos(grid)\n        treasure_pos = find_treasure(grid)\n        queue = deque([(start_pos, 0)])\n        visited = set()\n\n        while queue:\n            current_pos, stamina = queue.popleft()\n            if current_pos == treasure_pos:\n                return stamina\n            if current_pos in visited:\n                continue\n            visited.add(current_pos)\n\n            i, j = current_pos\n            up_pos = (i - 1, j)\n            down_pos = (i + 1, j)\n            left_pos = (i, j - 1)\n            right_pos = (i, j + 1)\n\n            for next_pos in [up_pos, down_pos, left_pos, right_pos]:\n                if 0 <= next_pos[0] < len(grid) and 0 <= next_pos[1] < len(grid[0]) and is_move_possible(grid[next_pos[0]][next_pos[1]]):\n                    queue.append((next_pos, stamina + stamina_cost(grid[next_pos[0]][next_pos[1]])))\n\n        return -1\n\n    n, m, k = stdin.split()\n    n, m, k = int(n), int(m), int(k)\n    grid = [list(input()) for _ in range(n)]\n    return str(bfs(grid))\n"
    },
    {
        "number": 3043,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[0:3])\n    grid = stdin.split('\\n')\n    s_pos = None\n    g_pos = None\n\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                s_pos = (i, j)\n            elif grid[i][j] == 'G':\n                g_pos = (i, j)\n\n    def is_valid(pos):\n        i, j = pos\n        return 0 <= i < N and 0 <= j < M and grid[i][j] != '#'\n\n    def move_cost(pos):\n        i, j = pos\n        if grid[i][j] == '.':\n            return 1\n        elif grid[i][j] == 'F':\n            return 2\n        elif grid[i][j] == 'M':\n            return 3\n        else:\n            return 0\n\n    def shortest_path(s, g):\n        visited = set()\n        queue = [(s, 0, 0)]\n        while queue:\n            pos, stam, day = queue.pop(0)\n            if pos == g:\n                return day\n            if pos in visited or day >= 2 or stam >= K:\n                continue\n            visited.add(pos)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_pos = (pos[0] + dx, pos[1] + dy)\n                if is_valid(new_pos):\n                    queue.append((new_pos, stam + move_cost(new_pos), day + (stam == 0)))\n\n        return -1\n\n    return str(shortest_path(s_pos, g_pos))"
    },
    {
        "number": 3044,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w, grid, commands = stdin.split(\"\\n\")\n    h = int(h)\n    w = int(w)\n\n    grid_matrix = [list(row) for row in grid.split(\"\\n\")]\n    start = None\n    goal = None\n\n    for i in range(h):\n        for j in range(w):\n            if grid_matrix[i][j] == \"S\":\n                start = (i, j)\n            elif grid_matrix[i][j] == \"G\":\n                goal = (i, j)\n\n    def is_valid(pos):\n        return 0 <= pos[0] < h and 0 <= pos[1] < w\n\n    def get_neighbors(pos):\n        return [(pos[0] - 1, pos[1]), (pos[0] + 1, pos[1]), (pos[0], pos[1] - 1), (pos[0], pos[1] + 1)]\n\n    def bfs(start, goal):\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            current, distance = queue.pop(0)\n            if current == goal:\n                return distance\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in get_neighbors(current):\n                if is_valid(neighbor) and grid_matrix[neighbor[0]][neighbor[1]] != \"#\":\n                    queue.append((neighbor, distance + 1))\n        return -1\n\n    def get_min_changes(commands):\n        changes = 0\n        current_pos = start\n        for command in commands:\n            if command == \"L\":\n                current_pos = (current_pos[0], current_pos[1] - 1)\n            elif command == \"R\":\n                current_pos = (current_pos[0], current_pos[1] + 1)\n            elif command == \"U\":\n                current_pos = (current_pos[0] - 1, current_pos[1])\n            elif command == \"D\":\n                current_pos = (current_pos[0] + 1, current_pos[1])\n            if not is_valid(current_pos) or grid_matrix[current_pos[0]][current_pos[1]] == \"#\":\n                changes += 1\n            if current_pos == goal:\n                break\n        return changes\n\n    min_changes = get_min_changes(commands)\n    bfs_dist = bfs(start, goal)\n    return str(min_changes + bfs_dist)\n\ninput_str = \"3 3\\nS..\\n.#.\\n..G\\nDRRDD\"\nprint(solution(input_str)) "
    },
    {
        "number": 3044,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, grid, command = stdin.split('\\n')\n    h, w = int(rows), int(cols)\n    start_pos, goal_pos = None, None\n\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'S':\n                start_pos = (i, j)\n            elif grid[i][j] == 'G':\n                goal_pos = (i, j)\n\n    def can_move(pos, direction):\n        i, j = pos\n        if direction == 'U':\n            return i > 0\n        elif direction == 'D':\n            return i < h - 1\n        elif direction == 'L':\n            return j > 0\n        elif direction == 'R':\n            return j < w - 1\n\n    def is_obstacle(pos):\n        i, j = pos\n        if grid[i][j] == '#':\n            return True\n        return False\n\n    def get_new_pos(pos, direction):\n        i, j = pos\n        if direction == 'U':\n            return (i - 1, j)\n        elif direction == 'D':\n            return (i + 1, j)\n        elif direction == 'L':\n            return (i, j - 1)\n        elif direction == 'R':\n            return (i, j + 1)\n\n    def get_distance(pos1, pos2):\n        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\n    def get_min_changes(command, start_pos, goal_pos):\n        current_pos = start_pos\n        min_changes = 0\n        for i in range(len(command)):\n            direction = command[i]\n            if can_move(current_pos, direction):\n                new_pos = get_new_pos(current_pos, direction)\n                if is_obstacle(new_pos):\n                    continue\n                current_pos = new_pos\n                if current_pos == goal_pos:\n                    return min_changes\n            else:\n                min_changes += 1\n        return min_changes\n\n    return str(get_min_changes(command, start_pos, goal_pos))"
    },
    {
        "number": 3044,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split('\\n')[0].split())\n    grid = [list(stdin.split('\\n')[i + 1]) for i in range(H)]\n    start_pos = (next(i for i, row in enumerate(grid) if 'S' in row), next(i for i, char in enumerate(grid[next(i for i, row in enumerate(grid) if 'S' in row][0]) if char == 'S')) - grid[0].index('S'))\n    goal_pos = (next(i for i, row in enumerate(grid) if 'G' in row), next(i for i, char in enumerate(grid[next(i for i, row in enumerate(grid) if 'G' in row][0]) if char == 'G')) - grid[0].index('G'))\n\n    def is_valid(pos: tuple) -> bool:\n        if pos[0] < 0 or pos[0] >= H or pos[1] < 0 or pos[1] >= W:\n            return False\n        if grid[pos[0]][pos[1]] == '#':\n            return False\n        return True\n\n    def min_changes_to_reach_goal(commands: str, current_pos: tuple, goal_pos: tuple, changes_made: int) -> int:\n        if changes_made > 1:\n            return -1\n        if current_pos == goal_pos:\n            return changes_made\n        for i, command in enumerate(commands):\n            new_pos = current_pos\n            if command == 'L':\n                new_pos = (current_pos[0], current_pos[1] - 1)\n            elif command == 'R':\n                new_pos = (current_pos[0], current_pos[1] + 1)\n            elif command == 'U':\n                new_pos = (current_pos[0] - 1, current_pos[1])\n            elif command == 'D':\n                new_pos = (current_pos[0] + 1, current_pos[1])\n            if is_valid(new_pos):\n                result = min_changes_to_reach_goal(commands[i+1:], new_pos, goal_pos, changes_made + (0 if command in {'L', 'R', 'U', 'D'} else 1))\n                if result >= 0:\n                    return result\n        return -1\n\n    commands = stdin.split('\\n')[-1]\n    return str(min_changes_to_reach_goal(commands, start_pos, goal_pos, 0))"
    },
    {
        "number": 3044,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[0].split())\n    grid = [list(row.strip()) for row in stdin.split()[1:H+1]]\n    start_pos = None\n    goal_pos = None\n    obstacles = set()\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start_pos = (i, j)\n            elif grid[i][j] == 'G':\n                goal_pos = (i, j)\n            elif grid[i][j] == '#':\n                obstacles.add((i, j))\n    \n    def is_valid_move(pos, direction):\n        next_pos = tuple(pos[i] + direction[i] for i in range(2))\n        return 0 <= next_pos[0] < H and 0 <= next_pos[1] < W and next_pos not in obstacles\n    \n    def is_goal(pos):\n        return pos == goal_pos\n    \n    def get_next_pos(pos, direction):\n        return tuple(pos[i] + direction[i] for i in range(2))\n    \n    def fix_program(program, start_pos):\n        min_changes = len(program)\n        for i in range(len(program)):\n            for j in range(len(program)):\n                if i != j:\n                    new_program = program[:i] + program[j] + program[i+1:]\n                    steps = follow_program(new_program, start_pos)\n                    min_changes = min(min_changes, steps)\n        return min_changes\n    \n    def follow_program(program, pos):\n        steps = 0\n        for command in program:\n            direction = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1)}[command]\n            if is_valid_move(pos, direction):\n                pos = get_next_pos(pos, direction)\n                steps += 1\n                if is_goal(pos):\n                    return steps\n        return steps\n    \n    program = stdin.split()[-1]\n    steps = follow_program(program, start_pos)\n    if steps == 0:\n        return 0\n    else:\n        return fix_program(program, start_pos)\n\ninput_str = \"\"\"3 3\nS..\n.#.\n..G\nDRRDD\"\"\"\nprint(solution(input_str)) "
    },
    {
        "number": 3044,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    H, W = map(int, stdin[:2])\n    grid = [list(stdin[2 + i]) for i in range(H)]\n    start, goal = None, None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n    obstacles = [(i, j) for i in range(H) for j in range(W) if grid[i][j] == '#']\n    command = stdin[-1]\n    \n    def is_valid_move(move: str, pos: tuple) -> bool:\n        i, j = pos\n        if move == 'L':\n            return (j > 0 and (i, j - 1) not in obstacles)\n        elif move == 'R':\n            return (j < W - 1 and (i, j + 1) not in obstacles)\n        elif move == 'U':\n            return (i > 0 and (i - 1, j) not in obstacles)\n        elif move == 'D':\n            return (i < H - 1 and (i + 1, j) not in obstacles)\n    \n    def get_neighbors(pos: tuple) -> list:\n        i, j = pos\n        return [(i + 1, j), (i - 1, j), (i, j - 1), (i, j + 1)]\n    \n    def bfs(start: tuple, goal: tuple, obstacles: list) -> bool:\n        queue = [start]\n        visited = set()\n        while queue:\n            current = queue.pop(0)\n            visited.add(current)\n            if current == goal:\n                return True\n            for neighbor in get_neighbors(current):\n                if is_valid_move(command[pos[0]], pos[1]) and neighbor not in visited and neighbor not in obstacles:\n                    queue.append(neighbor)\n        return False\n    \n    min_changes = 0\n    while command:\n        pos = start\n        if bfs(start, goal, obstacles):\n            break\n        min_changes += 1\n        command = command[1:]\n    \n    return min_changes"
    },
    {
        "number": 3044,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    H, W, grid, cmd = stdin.split(\"\\n\")\n    H, W = int(H), int(W)\n    goal_found = False\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == \"G\":\n                goal_pos = (i, j)\n            elif grid[i][j] == \"S\":\n                start_pos = (i, j)\n                \n    def is_valid(pos):\n        if pos[0] < 0 or pos[0] >= H or pos[1] < 0 or pos[1] >= W:\n            return False\n        return grid[pos[0]][pos[1]] != \"#\"\n    \n    def move(pos, direction):\n        if direction == \"U\":\n            return (pos[0]-1, pos[1])\n        elif direction == \"D\":\n            return (pos[0]+1, pos[1])\n        elif direction == \"L\":\n            return (pos[0], pos[1]-1)\n        else:\n            return (pos[0], pos[1]+1)\n    \n    def get_next_pos(pos, direction):\n        next_pos = move(pos, direction)\n        if is_valid(next_pos):\n            return next_pos\n        return None\n    \n    def fix_cmd(cmd):\n        changes = 0\n        for i in range(len(cmd)):\n            new_cmd = cmd[:i] + cmd[i+1:]\n            current_pos = start_pos\n            for c in new_cmd:\n                next_pos = get_next_pos(current_pos, c)\n                if next_pos is not None:\n                    current_pos = next_pos\n            if current_pos == goal_pos:\n                return changes\n            changes += 1\n        return changes\n    \n    return str(fix_cmd(cmd))\n\ninput_str = \"\"\nwith open(\"input.txt\", \"r\") as file:\n    input_str = file.read()\n\nwith open(\"output.txt\", \"w\") as file:\n    file.write(solution(input_str)) "
    },
    {
        "number": 3044,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    H, W, grid, commands = parse_input(stdin)\n    start, goal = find_start_and_goal(grid)\n    commands = fix_commands(commands, start, goal, H, W)\n    return len(commands)\n\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    H, W, grid, command = stdin.split(\"\\n\")\n    H, W = int(H), int(W)\n    start_pos = (0, 0)\n    goal_pos = (0, 0)\n\n    # Find start and goal positions\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == \"S\":\n                start_pos = (i, j)\n            elif grid[i][j] == \"G\":\n                goal_pos = (i, j)\n\n    # Define allowed moves\n    allowed_moves = {\"L\": (-1, 0), \"R\": (1, 0), \"U\": (0, -1), \"D\": (0, 1)}\n\n    # Check if moves are valid\n    def is_valid_move(pos, direction):\n        x, y = pos[0] + direction[0], pos[1] + direction[1]\n        return 0 <= x < H and 0 <= y < W and grid[x][y] != \"#\"\n\n    # Find shortest path from start to goal\n    def shortest_path(start, goal):\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            current, distance = queue.pop(0)\n            if current == goal:\n                return distance\n            if current in visited:\n                continue\n            visited.add(current)\n\n            for direction in allowed_moves.values():\n                new_pos = (current[0] + direction[0], current[1] + direction[1])\n                if is_valid_move(current, direction):\n                    queue.append((new_pos, distance + 1))\n\n        return -1\n\n    # Count number of changes needed\n    def count_changes(command):\n        changes = 0\n        for i, c in enumerate(command):\n            new_command = command[:i] + command[i + 1:]\n            shortest_path_length = shortest_path(start_pos, goal_pos)\n            if shortest_path_length == -1:\n                changes += 1\n            else:\n                new_shortest_path_length = shortest_path(start_pos, goal_pos)\n                if new_shortest_path_length == -1:\n                    changes += 1\n                elif shortest_path_length > new_shortest_path_length:\n                    changes += 1\n                else:\n                    return changes\n\n        return changes\n\n    return str(count_changes(command))"
    },
    {
        "number": 3044,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(grid, command, current_position):\n        h, w = len(grid), len(grid[0])\n        next_position = tuple(map(sum, zip(current_position, MOVEMENTS[command])))\n        return 0 <= next_position[0] < h and 0 <= next_position[1] < w and grid[next_position[0]][next_position[1]] != '#'\n\n    def find_valid_moves(grid, current_position):\n        valid_moves = [command for command in 'LRUD' if is_valid(grid, command, current_position)]\n        return ''.join(valid_moves)\n\n    H, W, grid, start_position, goal_position, program = stdin.split('\\n')\n    H, W = map(int, [H, W])\n    start_position = tuple(map(lambda x: int(x) - 1, start_position.split(',')))\n    goal_position = tuple(map(lambda x: int(x) - 1, goal_position.split(',')))\n\n    current_position = start_position\n    changes = 0\n    while current_position != goal_position and changes <= 50:\n        valid_moves = find_valid_moves(grid, current_position)\n        for command in program:\n            if command in valid_moves:\n                current_position = tuple(map(sum, zip(current_position, MOVEMENTS[command])))\n                if current_position == goal_position:\n                    return changes\n            else:\n                changes += 1\n                if changes > 50:\n                    break\n        else:\n            break\n\n    return -1\n\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    H, W = map(int, stdin.split()[0:2])\n    grid = [list(stdin.split()[2+i]) for i in range(H)]\n    original_command = stdin.split()[-1]\n\n    # Find the start and goal positions\n    start_position = None\n    goal_position = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start_position = (i, j)\n            elif grid[i][j] == 'G':\n                goal_position = (i, j)\n\n    # Check if the robot can reach the goal with the given command\n    def is_valid_command(current_position: tuple, command: str, direction: tuple) -> bool:\n        new_position = (current_position[0] + direction[0], current_position[1] + direction[1])\n        return 0 <= new_position[0] < H and 0 <= new_position[1] < W and grid[new_position[0]][new_position[1]] != '#'\n\n    def find_minimum_changes(current_position: tuple, command: str) -> int:\n        if current_position == goal_position:\n            return 0\n\n        minimum_changes = float('inf')\n        for i, direction in enumerate([(0, -1), (0, 1), (1, 0), (-1, 0)]):\n            if is_valid_command(current_position, command, direction):\n                new_position = (current_position[0] + direction[0], current_position[1] + direction[1])\n                minimum_changes = min(minimum_changes, 1 + find_minimum_changes(new_position, command[i+1:]))\n\n        return minimum_changes\n\n    return str(find_minimum_changes(start_position, original_command))"
    },
    {
        "number": 3045,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    beacons = []\n    for line in stdin.splitlines()[1:]:\n        x, y, d = map(int, line.split())\n        beacons.append((x, y, d))\n\n    if not beacons:\n        return \"impossible\"\n\n    x_min, x_max = 0, 1000000\n    y_min, y_max = 0, 1000000\n    for x, y, d in beacons:\n        x_min = max(x_min, x - d)\n        x_max = min(x_max, x + d)\n        y_min = max(y_min, y - d)\n        y_max = min(y_max, y + d)\n\n    if x_min > x_max or y_min > y_max:\n        return \"impossible\"\n\n    x_values = set()\n    y_values = set()\n    for x, y, d in beacons:\n        x_values.add(x)\n        y_values.add(y)\n\n    x_values = sorted(x_values)\n    y_values = sorted(y_values)\n\n    x_diff = x_values[1] - x_values[0]\n    y_diff = y_values[1] - y_values[0]\n\n    x_candidates = []\n    y_candidates = []\n\n    if x_diff <= y_diff:\n        for x in x_values:\n            if x_min <= x <= x_max:\n                x_candidates.append(x)\n    else:\n        for y in y_values:\n            if y_min <= y <= y_max:\n                y_candidates.append(y)\n\n    if len(x_candidates) == 1 and len(y_candidates) == 1:\n        return f\"{x_candidates[0]} {y_candidates[0]}\"\n    elif len(x_candidates) == 0 or len(y_candidates) == 0:\n        return \"impossible\"\n    else:\n        return \"uncertain\""
    },
    {
        "number": 3045,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    num_beacons = int(lines[0])\n    beacon_data = []\n    for i in range(1, num_beacons+1):\n        line = lines[i]\n        x, y, d = map(int, line.split())\n        beacon_data.append((x, y, d))\n\n    x_options = [0]\n    y_options = [0]\n    for x, y, d in beacon_data:\n        new_x_options = set()\n        new_y_options = set()\n        for x_option in x_options:\n            distance_to_x = abs(x_option - x)\n            if d >= distance_to_x:\n                new_x_options.add(x_option)\n                new_x_options.add(x_option - distance_to_x)\n                new_x_options.add(x_option + distance_to_x)\n        x_options = list(new_x_options)\n\n        for y_option in y_options:\n            distance_to_y = abs(y_option - y)\n            if d >= distance_to_y:\n                new_y_options.add(y_option)\n                new_y_options.add(y_option - distance_to_y)\n                new_y_options.add(y_option + distance_to_y)\n        y_options = list(new_y_options)\n\n    receiver_positions = []\n    for x_option in x_options:\n        for y_option in y_options:\n            if all(sum(map(abs, (x_option - x, y_option - y, d - abs(x_option - x) - abs(y_option - y))) <= 1 for x, y, d in beacon_data):\n                receiver_positions.append((x_option, y_option))\n\n    if len(receiver_positions) == 1:\n        return f\"{receiver_positions[0][0]} {receiver_positions[0][1]}\"\n    elif len(receiver_positions) > 1:\n        return \"uncertain\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    beacons = []\n    for i in range(1, n+1):\n        x, y, d = map(int, lines[i].split())\n        beacons.append((x, y, d))\n    \n    # find receiver position\n    possible_positions = set()\n    for x in range(-10**6, 10**6+1):\n        for y in range(-10**6, 10**6+1):\n            distances = [abs(x-b[0])+abs(y-b[1]) for b in beacons]\n            if all(d == distances[0] for d in distances):\n                possible_positions.add((x, y))\n    \n    # output result\n    if len(possible_positions) == 1:\n        return f\"{possible_positions.pop()[0]} {possible_positions.pop()[1]}\"\n    elif len(possible_positions) == 0:\n        return \"impossible\"\n    else:\n        return \"uncertain\""
    },
    {
        "number": 3045,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    lines = stdin.split(\"\\n\")\n    num_beacons = int(lines[0])\n    beacons = []\n    distances = []\n    for i in range(1, num_beacons + 1):\n        x, y, d = map(int, lines[i].split())\n        beacons.append((x, y))\n        distances.append(d)\n\n    # initialize variables\n    possible_positions = set()\n    for x in range(-1000000, 1000001):\n        for y in range(-1000000, 1000001):\n            possible_positions.add((x, y))\n\n    # calculate distances for all possible positions\n    min_distance = float(\"inf\")\n    for pos in possible_positions:\n        distance = sum(abs(x - pos[0]) + abs(y - pos[1]) for x, y in beacons)\n        if distance < min_distance:\n            min_distance = distance\n\n    # check if there is a unique position\n    positions = []\n    for pos in possible_positions:\n        distance = sum(abs(x - pos[0]) + abs(y - pos[1]) for x, y in beacons)\n        if distance == min_distance:\n            positions.append(pos)\n\n    # return result\n    if len(positions) == 1:\n        return str(positions[0][0]) + \" \" + str(positions[0][1])\n    elif len(positions) > 1:\n        return \"uncertain\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    beacons = []\n    for line in stdin.splitlines():\n        if line.isnumeric():\n            N = int(line)\n        else:\n            x, y, d = map(int, line.split())\n            beacons.append((x, y, d))\n\n    if not beacons:\n        return \"impossible\"\n\n    beacons.sort(key=lambda x: x[2])\n    candidates = []\n    for x, y, d in beacons:\n        new_candidates = []\n        for x_c, y_c in candidates:\n            new_candidates.append((x_c + x, y_c + y))\n        candidates = new_candidates\n        if not candidates:\n            return \"impossible\"\n\n    if len(candidates) == 1:\n        return f\"{candidates[0][0]} {candidates[0][1]}\"\n    else:\n        return \"uncertain\""
    },
    {
        "number": 3045,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_receiver_position_consistent(beacons, distances, x, y) -> bool:\n        for beacon, distance in zip(beacons, distances):\n            if abs(x - beacon[0]) + abs(y - beacon[1]) != distance:\n                return False\n        return True\n\n    def find_receiver_position(beacons, distances) -> Union[Tuple[int, int], str]:\n        for x in range(-1000000, 1000001):\n            for y in range(-1000000, 1000001):\n                if is_receiver_position_consistent(beacons, distances, x, y):\n                    return x, y\n        return \"impossible\"\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    beacons = []\n    distances = []\n\n    for i in range(1, n + 1):\n        beacon, distance = lines[i].split()\n        beacon = tuple(map(int, beacon.split(\",\")))\n        distance = int(distance)\n        beacons.append(beacon)\n        distances.append(distance)\n\n    result = find_receiver_position(beacons, distances)\n    if result == \"impossible\":\n        return \"impossible\"\n    elif len(set(result)) == 1:\n        return \"uncertain\"\n    else:\n        return f\"{result[0]} {result[1]}\"\n\ninput_1 = \"\"\"3\n999999 0 1000\n999900 950 451\n987654 123 13222\"\"\"\noutput_1 = solution(input_1)\nprint(output_1)  # Output: 1000200 799\n\ninput_2 = \"\"\"2\n100 0 101\n0 200 199\"\"\"\noutput_2 = solution(input_2)\nprint(output_2)  # Output: uncertain\n\ninput_3 = \"\"\"2\n100 0 100\n0 200 199\"\"\"\noutput_3 = solution(input_3)\nprint(output_3)  # Output: impossible "
    },
    {
        "number": 3045,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    N = int(stdin.splitlines()[0])\n    beacons = []\n    for line in stdin.splitlines()[1:]:\n        X, Y, D = map(int, line.split())\n        beacons.append((X, Y, D))\n\n    # Calculate the Manhattan distance between the receiver and each beacon\n    distances = {}\n    for i in range(N):\n        for j in range(i + 1, N):\n            Xi, Yi, Di = beacons[i]\n            Xj, Yj, Dj = beacons[j]\n            d = abs(Xi - Xj) + abs(Yi - Yj)\n            distances[(i, j)] = d\n\n    # Find all pairs of beacons that have the same Manhattan distance\n    consistent_pairs = []\n    for pair in distances:\n        d = distances[pair]\n        consistent_pairs.extend([pair] * d)\n\n    # For each pair of beacons, calculate their positions\n    beacon_positions = {}\n    for pair in consistent_pairs:\n        i, j = pair\n        Xi, Yi, Di = beacons[i]\n        Xj, Yj, Dj = beacons[j]\n        if Di + Dj == distances[pair]:\n            X = Xi - (Xi - Xj) * Di // (Di + Dj)\n            Y = Yi - (Yi - Yj) * Di // (Di + Dj)\n            beacon_positions[(X, Y)] = (Xi, Yi)\n\n    # Check if there is exactly one receiver position\n    if len(beacon_positions) == 1:\n        X, Y = next(iter(beacon_positions))\n        return f\"{X} {Y}\"\n    elif len(beacon_positions) > 1:\n        return \"uncertain\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    beacons = []\n    for i in range(1, n+1):\n        x, y, d = map(int, lines[i].split())\n        beacons.append((x, y, d))\n\n    def is_valid(x, y) -> bool:\n        for bx, by, d in beacons:\n            if abs(x - bx) + abs(y - by) != d:\n                return False\n        return True\n\n    if n == 0:\n        return \"impossible\"\n\n    for x in range(-1000000, 1000001):\n        for y in range(-1000000, 1000001):\n            if is_valid(x, y):\n                return f\"{x} {y}\"\n\n    return \"uncertain\""
    },
    {
        "number": 3045,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_valid_position(x, y, beacon_positions):\n        for beacon_x, beacon_y in beacon_positions:\n            if get_manhattan_distance(x, y, beacon_x, beacon_y) != beacon_distances[beacon_positions.index((beacon_x, beacon_y))]:\n                return False\n        return True\n\n    def get_valid_positions(beacon_positions, beacon_distances):\n        valid_positions = set()\n        for x in range(max(x for x, y in beacon_positions) + 1):\n            for y in range(max(y for x, y in beacon_positions) + 1):\n                if is_valid_position(x, y, beacon_positions):\n                    valid_positions.add((x, y))\n        return valid_positions\n\n    def find_receiver_position(beacon_positions, beacon_distances):\n        valid_positions = get_valid_positions(beacon_positions, beacon_distances)\n\n        if len(valid_positions) == 1:\n            return \" \".join(map(str, valid_positions.pop()))\n        elif len(valid_positions) == 0:\n            return \"impossible\"\n        else:\n            return \"uncertain\"\n\n    n = int(stdin.readline())\n    beacon_positions = []\n    beacon_distances = []\n\n    for _ in range(n):\n        beacon_x, beacon_y, beacon_distance = map(int, stdin.readline().split())\n        beacon_positions.append((beacon_x, beacon_y))\n        beacon_distances.append(beacon_distance)\n\n    return find_receiver_position(beacon_positions, beacon_distances)"
    },
    {
        "number": 3045,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_position(x, y):\n        return -10**6 <= x <= 10**6 and -10**6 <= y <= 10**6\n\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def get_receiver_position(beacons, distances):\n        positions = set()\n        for i, (x1, y1) in enumerate(beacons):\n            for j, (x2, y2) in enumerate(beacons):\n                if i != j:\n                    d = manhattan_distance(x1, y1, x2, y2)\n                    if d == distances[i] + distances[j]:\n                        positions.add((x1 - x2, y1 - y2))\n\n        return positions\n\n    def get_output(positions):\n        if len(positions) == 1:\n            x, y = positions.pop()\n            if is_valid_position(x, y):\n                return f\"{x + 10**6} {y + 10**6}\"\n            else:\n                return \"impossible\"\n        else:\n            return \"uncertain\"\n\n    input_lines = stdin.split(\"\\n\")\n    n = int(input_lines[0])\n    beacons = [(int(x), int(y)) for x, y, _ in map(lambda line: line.split(), input_lines[1:n+1])]\n    distances = [int(d) for _, _, d in map(lambda line: line.split(), input_lines[1:n+1])]\n\n    positions = get_receiver_position(beacons, distances)\n    return get_output(positions)"
    },
    {
        "number": 3046,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_rectangles(corners: List[List[int]]) -> List[List[int]]:\n        def get_rectangle(corner_pair: List[int]) -> List[int]:\n            top_left = corner_pair[0]\n            bottom_right = corner_pair[1]\n            rect = [[top_left[0], top_left[1]], [bottom_right[0], bottom_right[1]]]\n            while rect:\n                new_rect = []\n                for i in range(len(rect)):\n                    top_left, bottom_right = rect.pop(0)\n                    for j in range(top_left[1] + 1, bottom_right[1]):\n                        new_rect.append([[top_left[0], j], [bottom_right[0], j]])\n                rect.extend(new_rect)\n            return new_rect\n\n        rectangles = []\n        for i in range(len(corners)):\n            for j in range(i + 1, len(corners)):\n                rectangles.extend(get_rectangle([corners[i], corners[j]]))\n        return rectangles\n\n    def is_valid_matching(rectangles: List[List[int]]) -> bool:\n        def is_valid_rectangle(rectangle: List[int]) -> bool:\n            for i in range(len(rectangle)):\n                for j in range(i + 1, len(rectangle)):\n                    if rectangle[i][0] > rectangle[j][0] or rectangle[i][1] > rectangle[j][1]:\n                        return False\n            return True\n\n        for rectangle in rectangles:\n            if not is_valid_rectangle(rectangle):\n                return False\n        return True\n\n    stdin_list = [line.strip() for line in stdin.split('\\n') if line.strip()]\n    n = int(stdin_list[0])\n    corners = []\n    for i in range(1, n + 1):\n        r, c = map(int, stdin_list[i].split())\n        corners.append([r, c])\n    for i in range(n + 1, 2 * n + 1):\n        r, c = map(int, stdin_list[i].split())\n        corners.append([r, c])\n\n    rectangles = get_rectangles(corners)\n    if is_valid_matching(rectangles):\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if corners[i - 1] == rectangles[j - 1][0] and corners[n + i - 1] == rectangles[j - 1][1]:\n                    print(j)\n    else:\n        print(\"syntax error\")\n\ninput_str = \"\"\"\n2\n4 7\n9 8\n14 17\n19 18\n\"\"\"\nsolution(input_str) "
    },
    {
        "number": 3046,
        "checkpoint": "13B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    corners = [(int(line.split()[0]), int(line.split()[1])) for line in stdin.split('\\n')[1:n+1]]\n    bcorners = [(int(line.split()[0]), int(line.split()[1])) for line in stdin.split('\\n')[n+1:]]\n    \n    def match_corners(c1, c2):\n        if c1[0] == c2[0] or c1[1] == c2[1] or c1[0] == c2[1] or c1[1] == c2[0]:\n            return True\n        return False\n    \n    def find_match(c1, bcorners):\n        for i, c2 in enumerate(bcorners):\n            if match_corners(c1, c2):\n                return i+1\n        return None\n    \n    result = []\n    for i, c1 in enumerate(corners):\n        match = find_match(c1, bcorners)\n        if match is not None:\n            result.append(match)\n            bcorners.pop(match-1)\n        else:\n            return \"syntax error\"\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3046,
        "checkpoint": "13B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    n = int(stdin[0])\n    top_left = [(int(stdin[i]), int(stdin[i+n])) for i in range(1, n+1, 2)]\n    bottom_right = [(int(stdin[i]), int(stdin[i+n])) for i in range(2, n+2, 2)]\n    \n    def is_valid(p1, p2):\n        r1, c1 = p1\n        r2, c2 = p2\n        return r1 <= r2 and c1 <= c2\n    \n    def is_overlapping(p1, p2):\n        r1, c1 = p1\n        r2, c2 = p2\n        return r1 < r2 and c1 < c2\n    \n    def is_nested(p1, p2):\n        r1, c1 = p1\n        r2, c2 = p2\n        return r1 < r2 and c1 < c2\n    \n    def find_match(index, visited, match_list):\n        if index == n:\n            return True\n        for i in range(n):\n            if i not in visited:\n                p1 = top_left[index]\n                p2 = bottom_right[i]\n                if is_valid(p1, p2) and (not match_list or not is_overlapping(p1, match_list[-1]) and not is_nested(match_list[-1], (p1, p2))):\n                    visited.add(i)\n                    match_list.append((index, i))\n                    if find_match(index+1, visited, match_list):\n                        return True\n                    match_list.pop()\n                    visited.remove(i)\n        return False\n    \n    match_list = []\n    visited = set()\n    if find_match(0, visited, match_list):\n        return '\\n'.join(str(j) for i, j in match_list)\n    else:\n        return \"syntax error\""
    },
    {
        "number": 3046,
        "checkpoint": "13B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    top_left_corners = []\n    bottom_right_corners = []\n    for i in range(1, n + 1):\n        row1, col1 = map(int, lines[i].split())\n        top_left_corners.append((row1, col1))\n    for i in range(n + 1, 2 * n + 1):\n        row2, col2 = map(int, lines[i].split())\n        bottom_right_corners.append((row2, col2))\n\n    valid_matches = []\n    for i in range(n):\n        for j in range(n):\n            if is_valid_match(top_left_corners[i], bottom_right_corners[j]):\n                valid_matches.append((i + 1, j + 1))\n\n    if not valid_matches:\n        return \"syntax error\"\n\n    return \"\\n\".join(str(i) for i, j in valid_matches)\n\ndef"
    },
    {
        "number": 3046,
        "checkpoint": "13B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    top_left = [(int(stdin.splitlines()[i+1]), int(stdin.splitlines()[i+n+2])) for i in range(n)]\n    bottom_right = [(int(stdin.splitlines()[i+n+1]), int(stdin.splitlines()[i+2*n+3])) for i in range(n)]\n    corners = top_left + bottom_right\n    \n    # Check if the corners are valid\n    if len(corners) != len(set(corners)):\n        return \"syntax error\"\n    \n    # Create a list of pairs of corners\n    pairs = [(corners.index(x), corners.index(y)) for x in top_left for y in bottom_right if x == y[0] and y[1] == x[1]+1]\n    \n    # Check if the pairs are valid\n    if len(pairs) != len(set(pairs)):\n        return \"syntax error\"\n    \n    # Create a list of numbers from 1 to n\n    numbers = list(range(1, n+1))\n    \n    # Assign the numbers to the pairs in a way that results in properly nested rectangles\n    for i in range(n):\n        for j in range(n):\n            if pairs[i][0] == pairs[j][0] + 1 and pairs[i][1] == pairs[j][1]:\n                numbers[i], numbers[j] = numbers[j], numbers[i]\n    \n    return \" \".join(map(str, numbers))"
    },
    {
        "number": 3046,
        "checkpoint": "13B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    top_left_corners = [(int(line.split()[0]), int(line.split()[1])) for line in stdin.split(\"\\n\")[1:n+1]]\n    bottom_right_corners = [(int(line.split()[0]), int(line.split()[1])) for line in stdin.split(\"\\n\")[n+1:]]\n    \n    # Check if the input is valid (no overlapping rectangles)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            r1, c1 = top_left_corners[i]\n            r2, c2 = bottom_right_corners[i]\n            r3, c3 = top_left_corners[j]\n            r4, c4 = bottom_right_corners[j]\n            if r1 <= r3 <= r2 and c1 <= c3 <= c2 and r1 <= r4 <= r2 and c1 <= c4 <= c2:\n                return \"syntax error\"\n    \n    # Generate permutations of the corners\n    perms = permutations(range(1, n+1))\n    for perm in perms:\n        valid_matching = True\n        for i in range(n):\n            r1, c1 = top_left_corners[i]\n            r2, c2 = bottom_right_corners[perm[i]-1]\n            if r1 != r2 and c1 != c2:\n                valid_matching = False\n                break\n        if valid_matching:\n            return \"\\n\".join(map(str, perm))\n    \n    return \"syntax error\"\n\ndef"
    },
    {
        "number": 3046,
        "checkpoint": "13B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    rectangles = []\n\n    for i in range(1, n + 1):\n        top_left_row, top_left_col = map(int, lines[i].split())\n        bottom_right_row, bottom_right_col = map(int, lines[i + n].split())\n        rectangles.append((top_left_row, top_left_col, bottom_right_row, bottom_right_col))\n\n    def is_valid_matching(matching):\n        for i in range(len(matching)):\n            for j in range(i + 1, len(matching)):\n                if matching[i] == matching[j]:\n                    return False\n                top_left_i = rectangles[matching[i] - 1][:2]\n                bottom_right_i = rectangles[matching[i] - 1][2:]\n                top_left_j = rectangles[matching[j] - 1][:2]\n                bottom_right_j = rectangles[matching[j] - 1][2:]\n                if (top_left_i == top_left_j) or (bottom_right_i == bottom_right_j):\n                    return False\n                if (top_left_i[0] >= bottom_right_j[0] and top_left_i[1] >= bottom_right_j[1]) or \\\n                   (bottom_right_i[0] <= top_left_j[0] and bottom_right_i[1] <= top_left_j[1]):\n                    return False\n        return True\n\n    valid_matchings = []\n    for matching in itertools.permutations(range(1, n + 1)):\n        if is_valid_matching(matching):\n            valid_matchings.append(matching)\n\n    if not valid_matchings:\n        return \"syntax error\"\n    else:\n        return \"\\n\".join(str(matching) for matching in valid_matchings) "
    },
    {
        "number": 3046,
        "checkpoint": "13B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    topleft_corners = []\n    bottomright_corners = []\n\n    for i in range(n):\n        row, col = map(int, stdin.split(\"\\n\")[i + 1].split())\n        topleft_corners.append((row, col))\n\n        row, col = map(int, stdin.split(\"\\n\")[n + i + 1].split())\n        bottomright_corners.append((row, col))\n\n    permutation = list(range(1, n + 1))\n    topleft_corners.sort()\n    bottomright_corners.sort()\n\n    for i in range(n):\n        for j in range(n):\n            if topleft_corners[i] == bottomright_corners[j]:\n                permutation[i], permutation[j] = permutation[j], permutation[i]\n\n    valid = True\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (\n                topleft_corners[i][0] >= bottomright_corners[j][0]\n                or topleft_corners[i][1] >= bottomright_corners[j][1]\n                or topleft_corners[j][0] >= bottomright_corners[i][0]\n                or topleft_corners[j][1] >= bottomright_corners[i][1]\n            ):\n                valid = False\n                break\n        if not valid:\n            break\n\n    if valid:\n        return \"\\n\".join(map(str, permutation))\n    else:\n        return \"syntax error\""
    },
    {
        "number": 3046,
        "checkpoint": "13B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    coordinates = []\n    \n    for i in range(1, n*2, 2):\n        row, col = map(int, stdin.split('\\n')[i].split())\n        coordinates.append((row, col))\n    \n    for i in range(1, n*2, 2):\n        row, col = map(int, stdin.split('\\n')[i+1].split())\n        coordinates.append((row, col))\n    \n    coordinates.sort(key=lambda x: (x[0], x[1]))\n    \n    def is_valid(coord):\n        r1, c1 = coord[0]\n        r2, c2 = coord[1]\n        return r1 <= r2 and c1 <= c2\n    \n    valid_coordinates = [coord for coord in coordinates if is_valid(coord)]\n    \n    def matching_rectangles(coords):\n        n = len(coords)\n        match = [-1] * n\n        used = [False] * n\n        \n        def can_match(i, j):\n            if i == j or match[i] == j or match[j] == i:\n                return False\n            ri, ci = coords[i]\n            rj, cj = coords[j]\n            return ci < rj and cj < ci\n        \n        def dfs(v):\n            if used[v]:\n                return True\n            used[v] = True\n            for i in range(n):\n                if can_match(v, i) and dfs(i):\n                    match[v] = i\n                    match[i] = v\n                    return True\n            return False\n        \n        for i in range(n):\n            if not used[i]:\n                if not dfs(i):\n                    return None\n        \n        return match\n    \n    match = matching_rectangles(valid_coordinates)\n    \n    if match is None:\n        return \"syntax error\"\n    \n    output = [str(match[i]+1) for i in range(n) if match[i] != -1]\n    return '\\n'.join(output) "
    },
    {
        "number": 3046,
        "checkpoint": "13B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    corners = []\n    for i in range(1, n+1):\n        r1, c1 = map(int, lines[i].split())\n        r2, c2 = map(int, lines[n+i].split())\n        corners.append((r1, c1, r2, c2))\n\n    def is_valid_matching(matching: List[int]) -> bool:\n        for i in range(len(matching)):\n            for j in range(len(matching)):\n                if i != j:\n                    r11, c11, r12, c12 = corners[matching[i]-1]\n                    r21, c21, r22, c22 = corners[matching[j]-1]\n                    if (r11 < r21 < r12 or r11 < r22 < r12) and (c11 < c21 < c12 or c11 < c22 < c12):\n                        return False\n        return True\n\n    for matching in permutations(range(1, n+1)):\n        if is_valid_matching(matching):\n            return \"\\n\".join(map(str, matching))\n\n    return \"syntax error\""
    }
]