[
    {
        "number": 3000,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    result = 0\n    for token in stdin.split():\n        if token == '(':\n            stack.append('(')\n        elif token == ')':\n            sub_result = 1\n            while stack and stack[-1] != '(':\n                sub_result *= int(stack.pop())\n            stack.pop()\n            result += sub_result\n        else:\n            stack.append(token)\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 3001,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(number: int) -> bool:\n        return str(number) == str(number)[::-1]\n\n    def increment_wheel(wheel: int, k: int) -> int:\n        if wheel == 9:\n            return 0\n        return wheel + 1\n\n    def increment_counter(counter: int, k: int) -> int:\n        new_counter = 0\n        for i in range(k):\n            new_counter += increment_wheel(counter % 10, k) * (10 ** i)\n            counter //= 10\n        return new_counter\n\n    def find_palindrome(counter: int, k: int) -> int:\n        steps = 0\n        while not is_palindrome(counter):\n            counter = increment_counter(counter, k)\n            steps += 1\n        return steps\n\n    k = len(stdin)\n    counter = int(stdin)\n    return str(find_palindrome(counter, k))"
    },
    {
        "number": 3002,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    entries = stdin.split(\"\\n\")\n    e = int(entries[0])\n    service_history = []\n\n    for i in range(1, e + 1):\n        year, month, odometer = map(int, entries[i].split())\n        service_history.append((year, month, odometer))\n\n    def is_valid_service_history(service_history):\n        for i in range(len(service_history) - 1):\n            year1, month1, odometer1 = service_history[i]\n            year2, month2, odometer2 = service_history[i + 1]\n\n            if year1 == year2 and month1 == month2:\n                return False\n\n            if odometer2 - odometer1 > 99999:\n                return False\n\n        return True\n\n    def is_service_history_valid(service_history):\n        if not is_valid_service_history(service_history):\n            return False\n\n        total_distance = 0\n        for year, month, odometer in service_history:\n            total_distance += odometer\n\n        if total_distance < 2000 or total_distance > 20000:\n            return False\n\n        return True\n\n    def is_car_serviced_often_enough(service_history):\n        last_service_year, last_service_month, last_service_odometer = service_history[-1]\n        last_service_date = datetime.date(last_service_year, last_service_month, 1)\n\n        for year, month, odometer in service_history:\n            service_date = datetime.date(year, month, 1)\n            time_since_last_service = (service_date - last_service_date).days\n\n            if time_since_last_service >= 365 * 12:\n                return True\n\n        return False\n\n    if not is_service_history_valid(service_history):\n        return \"tampered odometer\"\n\n    if not is_car_serviced_often_enough(service_history):\n        return \"insufficient service\"\n\n    return \"seems legit\""
    },
    {
        "number": 3003,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    graph = [[] for _ in range(n)]\n    for i in range(1, n+1):\n        for j in map(int, lines[i].split()):\n            graph[i-1].append(j-1)\n            graph[j-1].append(i-1)\n    \n    colors = set()\n    for i in range(n):\n        used_colors = set()\n        for j in graph[i]:\n            used_colors.add(colors.intersection(colors_used[j]))\n        colors.add(used_colors)\n    \n    return str(len(colors))"
    },
    {
        "number": 3004,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(offers: List[Tuple[str, int, int]]) -> bool:\n        colors = set()\n        sections = set()\n        for color, start, end in offers:\n            if start in sections or end in sections:\n                return False\n            sections.update(range(start, end + 1))\n            colors.add(color)\n        return len(colors) <= 3 and len(sections) == 10000\n\n    def min_offers(offers: List[Tuple[str, int, int]]) -> int:\n        offers.sort(key=lambda x: x[2] - x[1])\n        min_count = float('inf')\n        for i in range(len(offers)):\n            for j in range(i + 1, len(offers)):\n                if offers[j][1] <= offers[i][2]:\n                    new_offers = offers[:i] + offers[i:j + 1]\n                    if is_valid(new_offers):\n                        min_count = min(min_count, j - i + 1)\n        return min_count if min_count != float('inf') else \"IMPOSSIBLE\"\n\n    offers = []\n    for line in stdin.split('\\n')[1:]:\n        color, start, end = line.split()\n        offers.append((color, int(start), int(end)))\n\n    return str(min_offers(offers))"
    },
    {
        "number": 3005,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_factoring(s: str) -> str:\n        n = len(s)\n        max_weight = float('inf')\n        max_factoring = ''\n        for i in range(1, n):\n            for j in range(i, n):\n                substring = s[i:j+1]\n                count = 1\n                while substring * count in s:\n                    count += 1\n                weight = len(substring) * count\n                if weight < max_weight:\n                    max_weight = weight\n                    max_factoring = substring * count\n        return max_factoring\n\n    max_factoring = find_max_factoring(stdin)\n    return len(max_factoring)"
    },
    {
        "number": 3006,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def apply_operations(program: List[str], s: str) -> str:\n        for op in program:\n            if op[0] == \"D\":\n                p = int(op[2:])\n                s = s[:p - 1] + s[p:]\n            elif op[0] == \"I\":\n                p, c = op[2:].split()\n                s = s[:int(p) - 1] + c + s[int(p) - 1:]\n        return s\n\n    program1, program2 = stdin.split(\"\\nE\\n\")\n    program1 = program1.split(\"\\n\")\n    program2 = program2.split(\"\\n\")\n\n    if len(program1) != len(program2):\n        return \"1\"\n\n    s = \"A\" * 10000000000  # sufficiently long string\n    s1 = apply_operations(program1, s)\n    s2 = apply_operations(program2, s)\n\n    if s1 == s2:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 3007,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Calculate the maximum amount of Bling Johan can have after playing d days\n    max_bling = b\n\n    # Calculate the maximum amount of Bling Johan can have after selling all fruits\n    max_bling += f * 100\n\n    # Calculate the maximum amount of Bling Johan can have after selling all exotic fruits\n    max_bling += t0 * 500\n\n    # Calculate the maximum amount of Bling Johan can have after selling all fruit trees\n    max_bling += (t0 + t1 + t2) * 300\n\n    # Calculate the maximum amount of Bling Johan can have after selling all exotic fruit trees\n    max_bling += (t0 + t1 + t2) * 1500\n\n    return str(max_bling)"
    },
    {
        "number": 3008,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:N+2]))\n    b = list(map(int, stdin.split()[N+2:]))\n    \n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    \n    rank = 1\n    distinct_ranks = 1\n    for i in range(N-1):\n        if a[i] + K < a[i+1] or b[i] + K < b[i+1]:\n            rank += 1\n            distinct_ranks += 1\n        else:\n            rank += 1\n            \n    return str(distinct_ranks)"
    },
    {
        "number": 3009,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def is_inside(x, y, line):\n        return (line[0][0] <= x <= line[1][0] and line[0][1] <= y <= line[1][1]) or (line[1][0] <= x <= line[0][0] and line[1][1] <= y <= line[0][1])\n\n    def find_balancing_line(lamp_positions, lamp_energies):\n        min_length = float('inf')\n        balancing_line = None\n\n        for i in range(len(lamp_positions)):\n            for j in range(i + 1, len(lamp_positions)):\n                x1, y1 = lamp_positions[i]\n                x2, y2 = lamp_positions[j]\n\n                if lamp_energies[i] * lamp_energies[j] < 0:\n                    line = [(x1, y1), (x2, y2)]\n                    positive_energy = 0\n                    negative_energy = 0\n\n                    for k in range(len(lamp_positions)):\n                        if k != i and k != j:\n                            x, y = lamp_positions[k]\n                            if is_inside(x, y, line):\n                                if lamp_energies[k] > 0:\n                                    positive_energy += lamp_energies[k]\n                                else:\n                                    negative_energy += lamp_energies[k]\n\n                    length = distance(x1, y1, x2, y2)\n                    if positive_energy + negative_energy == 0:\n                        if length < min_length:\n                            min_length = length\n                            balancing_line = line\n\n        return balancing_line\n\n    lamp_positions = []\n    lamp_energies = []\n\n    num_lamps = int(stdin.readline())\n\n    for _ in range(num_lamps):\n        x, y, e = map(int, stdin.readline().split())\n        lamp_positions.append((x, y))\n        lamp_energies.append(e)\n\n    balancing_line = find_balancing_line(lamp_positions, lamp_energies)\n\n    if balancing_line is None:\n        return \"IMPOSSIBLE\"\n    else:\n        return str(distance(balancing_line[0][0], balancing_line[0][1], balancing_line[1][0], balancing_line[1][1]))"
    },
    {
        "number": 3010,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    points = set()\n\n    for i in range(1, n + 1):\n        x0, y0, x1, y1 = map(int, lines[i].split())\n        if x0 == x1:\n            points.add((x0, y0))\n            points.add((x1, y1))\n        elif y0 == y1:\n            points.add((x0, y0))\n            points.add((x1, y1))\n        else:\n            a = (y1 - y0) / (x1 - x0)\n            b = y0 - a * x0\n            x = (b - y0) / (a - 1)\n            y = a * x + b\n            points.add((int(x), int(y)))\n\n    return str(len(points)) if len(points) != float('inf') else \"-1\""
    },
    {
        "number": 3011,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_numbers = 0\n    current_digit = 1\n    while current_digit <= n:\n        hill_numbers += 1\n        current_digit *= 10\n    return str(hill_numbers)"
    },
    {
        "number": 3012,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    MOD = 1000000007\n\n    def count_sequences(a11: int, a12: int, a21: int, a22: int, N: int) -> int:\n        if N == 0:\n            return 1\n        if a11 == 0 and a12 == 0 and a21 == 0 and a22 == 0:\n            return 0\n\n        total = 0\n        if a11 > 0:\n            total += count_sequences(a11 - 1, a12, a21, a22, N - 1)\n            total %= MOD\n        if a12 > 0:\n            total += count_sequences(a11, a12 - 1, a21, a22, N - 1)\n            total %= MOD\n        if a21 > 0:\n            total += count_sequences(a11, a12, a21 - 1, a22, N - 1)\n            total %= MOD\n        if a22 > 0:\n            total += count_sequences(a11, a12, a21, a22 - 1, N - 1)\n            total %= MOD\n\n        return total\n\n    return str(count_sequences(a11, a12, a21, a22, N))"
    },
    {
        "number": 3013,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    target = complex(tx, ty)\n    spiral_radius = 2 * pi * b\n    spiral_center = complex(0, 0)\n    spiral_angle = 0\n    avatar_position = complex(0, 0)\n    avatar_direction = complex(1, 0)\n    avatar_speed = 1\n\n    while abs(avatar_position) < spiral_radius:\n        avatar_position += avatar_direction * avatar_speed\n        avatar_direction *= complex(0, 1)\n        spiral_angle += b * avatar_speed\n        avatar_speed += 1\n\n    avatar_position -= avatar_direction * avatar_speed\n    avatar_direction *= complex(0, 1)\n    avatar_speed = 1\n\n    while abs(avatar_position - target) > 1e-3:\n        avatar_position += avatar_direction * avatar_speed\n        avatar_direction *= complex(0, 1)\n        spiral_angle += b * avatar_speed\n        avatar_speed += 1\n\n    return f\"{avatar_position.real:.5f} {avatar_position.imag:.5f}\""
    },
    {
        "number": 3014,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    corridors = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        corridors.append((u, v))\n\n    def dfs(start: int, visited: set) -> set:\n        visited.add(start)\n        for u, v in corridors:\n            if u == start and v not in visited:\n                dfs(v, visited)\n        return visited\n\n    cycles = []\n    for i in range(1, n + 1):\n        if i not in [u for u, v in corridors]:\n            continue\n        visited = dfs(i, set())\n        if len(visited) != n:\n            cycles.append(visited)\n\n    if not cycles:\n        return \"0\"\n\n    corridors_to_remove = []\n    for cycle in cycles:\n        corridors_to_remove.extend([(u, v) for u, v in corridors if u in cycle and v in cycle])\n\n    corridors_to_remove = list(set(corridors_to_remove))\n    corridors_to_remove.sort(key=lambda x: x[0])\n\n    return str(len(corridors_to_remove)) + \"\\n\" + \"\\n\".join(map(lambda x: str(x[0]), corridors_to_remove))\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 3015,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = []\n    for _ in range(m):\n        a, b, w = map(int, stdin.split()[4:])\n        tubes.append((a, b, w))\n        stdin = stdin[stdin.find('\\n') + 1:]\n\n    def dfs(ball: int, time: int) -> int:\n        if ball == t:\n            return time\n        for a, b, w in tubes:\n            if a == ball:\n                next_time = time + w\n                next_ball = b\n                if next_ball not in visited:\n                    visited.add(next_ball)\n                    return dfs(next_ball, next_time)\n        return -1\n\n    visited = set()\n    time = dfs(s, 0)\n    return str(time) if time != -1 else \"infinity\""
    },
    {
        "number": 3016,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, balls = list(map(int, stdin.split()))\n    colors = balls[:n]\n    forbidden_colors = balls[n:n+colors[0]]\n    favorite_sequence = balls[n+colors[0]:]\n    \n    def is_valid(arrangement):\n        for i in range(len(arrangement) - 1):\n            if arrangement[i] in forbidden_colors and arrangement[i+1] in forbidden_colors:\n                return False\n        return True\n    \n    def count_favorite_sequence(arrangement):\n        count = 0\n        for i in range(len(arrangement) - len(favorite_sequence) + 1):\n            if arrangement[i:i+len(favorite_sequence)] == favorite_sequence:\n                count += 1\n        return count\n    \n    def count_arrangements(colors):\n        if not colors:\n            return 1\n        count = 0\n        for i in range(colors[0]):\n            new_colors = colors.copy()\n            new_colors[0] -= 1\n            new_colors.append(i+1)\n            new_colors.sort()\n            if is_valid(new_colors):\n                count += count_arrangements(new_colors)\n        return count\n    \n    total_count = count_arrangements(colors)\n    return str(total_count % 1000000007)"
    },
    {
        "number": 3017,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n+1):\n        if str(2**e) in str(i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3018,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    dice_rolls = list(map(int, stdin.split()))\n    dice_count = [0] * 7\n\n    for roll in dice_rolls:\n        dice_count[roll] += 1\n\n    max_probability = 0\n    max_dice_count = 0\n\n    for i in range(1, K + 1):\n        probability = 0\n        for j in range(1, 7):\n            probability += dice_count[j] * comb(dice_count[j], i) * comb(K - dice_count[j], T - i * j)\n        probability /= 6 ** K\n\n        if probability > max_probability:\n            max_probability = probability\n            max_dice_count = i\n\n    return str(max_dice_count)"
    },
    {
        "number": 3019,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, data = stdin.split('\\n')\n    N = int(N)\n    data = list(map(int, data.split()))\n\n    def prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n //= i\n        if n > 2:\n            factors.add(n)\n        return factors\n\n    max_revenue = 0\n    for i in range(2**N):\n        binary = bin(i)[2:].zfill(N)\n        customer_data = [data[j] for j in range(N) if binary[j] == '1']\n        revenue = len(set().union(*[prime_factors(sum(customer_data))]))\n        max_revenue = max(max_revenue, revenue)\n\n    return str(max_revenue)"
    },
    {
        "number": 3020,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    a = 1\n    while True:\n        if a * a > N:\n            return str(-1)\n        if a * a == N:\n            return str(a)\n        a += 1"
    },
    {
        "number": 3021,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[0].split())\n    words = stdin.split('\\n')[1:]\n\n    if N == 1:\n        return words[0]\n\n    alphabet = set()\n    for word in words:\n        for char in word:\n            alphabet.add(char)\n\n    if len(alphabet) != N:\n        return \"IMPOSSIBLE\"\n\n    sorted_words = sorted(words)\n    sorted_alphabet = sorted(alphabet)\n\n    if sorted_words != sorted_alphabet:\n        return \"IMPOSSIBLE\"\n\n    return \"\".join(sorted_alphabet)"
    },
    {
        "number": 3022,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    cookies = [A, B, C]\n    total_cookies = sum(cookies)\n    max_cookies = total_cookies // N\n\n    for i in range(N):\n        for j in range(len(cookies)):\n            if cookies[j] > max_cookies:\n                cookies[j] -= max_cookies\n            else:\n                max_cookies -= cookies[j]\n                cookies[j] = 0\n\n    return str(total_cookies - sum(cookies))"
    },
    {
        "number": 3023,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split()[:3])\n    candles = [tuple(map(int, line.split())) for line in stdin.split('\\n')[3:3+n]]\n    cuts = [tuple(map(int, line.split())) for line in stdin.split('\\n')[3+n:3+n+m]]\n\n    def is_inside_circle(x, y):\n        return x**2 + y**2 <= r**2\n\n    def is_on_cut(x, y, a, b, c):\n        return a*x + b*y + c == 0\n\n    def is_candle_on_cut(candle, cut):\n        x, y = candle\n        a, b, c = cut\n        return is_on_cut(x, y, a, b, c)\n\n    def is_candle_on_piece(candle, cuts):\n        return not any(is_candle_on_cut(candle, cut) for cut in cuts)\n\n    def count_candles_on_piece(piece, candles):\n        return sum(1 for candle in candles if is_candle_on_piece(candle, piece))\n\n    def is_valid_piece(piece, candles):\n        return count_candles_on_piece(piece, candles) == 1\n\n    def is_valid_cut(cut, candles):\n        return all(is_candle_on_piece(candle, [cut]) for candle in candles)\n\n    def is_valid_solution(cuts, candles):\n        return all(is_valid_piece(piece, candles) for piece in cuts) and all(is_valid_cut(cut, candles) for cut in cuts)\n\n    if is_valid_solution(cuts, candles):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3024,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[False] * n for _ in range(n)]\n    max_k = 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 2 and stdin[i] == stdin[j]:\n                dp[i][j] = True\n                max_k = max(max_k, 2)\n            elif length > 2 and stdin[i] == stdin[j] and dp[i + 1][j - 1]:\n                dp[i][j] = True\n                max_k = max(max_k, length)\n\n    return str(max_k)"
    },
    {
        "number": 3025,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    gold = list(map(int, stdin.split()[2:]))\n    roads = []\n    for i in range(m):\n        a, b = map(int, stdin.split()[2+i].split())\n        roads.append((a, b))\n        roads.append((b, a))\n\n    def dfs(node, visited, gold_count, path):\n        if node == 2:\n            return max(gold_count, 0)\n        visited.add(node)\n        max_gold = 0\n        for neighbor in roads:\n            if neighbor[0] == node and neighbor[1] not in visited:\n                max_gold = max(max_gold, dfs(neighbor[1], visited, gold_count + gold[node-1], path + [node]))\n        visited.remove(node)\n        return max_gold\n\n    return str(dfs(1, set(), 0, []))"
    },
    {
        "number": 3026,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = list(map(int, stdin.split('\\n')[1].split()))\n\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    critical_elements = []\n    for i in range(1, n):\n        if lis[i] == 1:\n            critical_elements.append(sequence[i])\n\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical_elements)))"
    },
    {
        "number": 3027,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    mark = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def count_nubs(stamp: List[List[str]]) -> int:\n        n, m = len(stamp), len(stamp[0])\n        nubs = 0\n        for i in range(n):\n            for j in range(m):\n                if stamp[i][j] == '#':\n                    nubs += 1\n        return nubs\n\n    def is_valid_stamp(stamp: List[List[str]]) -> bool:\n        n, m = len(stamp), len(stamp[0])\n        for i in range(n):\n            for j in range(m):\n                if stamp[i][j] == '#':\n                    if i > 0 and stamp[i - 1][j] == '#':\n                        return False\n                    if j > 0 and stamp[i][j - 1] == '#':\n                        return False\n        return True\n\n    min_nubs = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if mark[i][j] == '#':\n                stamp = [['.' for _ in range(m)] for _ in range(n)]\n                stamp[i][j] = '#'\n                if is_valid_stamp(stamp):\n                    min_nubs = min(min_nubs, count_nubs(stamp))\n                stamp[i][j] = '.'\n                stamp[i][j - 1] = '#'\n                if is_valid_stamp(stamp):\n                    min_nubs = min(min_nubs, count_nubs(stamp))\n                stamp[i][j - 1] = '.'\n                stamp[i - 1][j] = '#'\n                if is_valid_stamp(stamp):\n                    min_nubs = min(min_nubs, count_nubs(stamp))\n                stamp[i - 1][j] = '.'\n    return str(min_nubs)"
    },
    {
        "number": 3028,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    def is_winning(board: List[List[int]]) -> bool:\n        for row in board:\n            if not all(x == p for x in row):\n                return False\n        for col in range(m):\n            if not all(board[row][col] == p for row in range(n)):\n                return False\n        return True\n    \n    def next_move(board: List[List[int]], move: int) -> int:\n        new_board = [[(x+1)%(p+1) for x in row] for row in board]\n        return move+1, new_board\n    \n    def find_winning_sequence(board: List[List[int]], move: int, sequence: List[int]) -> List[int]:\n        if is_winning(board):\n            return sequence + [move]\n        if move > p*m*n:\n            return []\n        move, new_board = next_move(board, move)\n        return find_winning_sequence(new_board, move, sequence + [move])\n    \n    winning_sequence = find_winning_sequence(board, 0, [])\n    if winning_sequence:\n        return str(len(winning_sequence)) + '\\n' + ' '.join(map(str, winning_sequence))\n    else:\n        return '-1'"
    },
    {
        "number": 3029,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent):\n        nonlocal uf, labels, paths, longest_path, longest_path_length\n        uf[node] = node\n        for child in tree[node]:\n            if child != parent:\n                dfs(child, node)\n                if labels[child] > labels[node]:\n                    paths[node].append(child)\n                    if len(paths[node]) > longest_path_length:\n                        longest_path = node\n                        longest_path_length = len(paths[node])\n\n    def count_jumping_paths(node, path):\n        nonlocal uf, paths, longest_path_length, M\n        if len(path) == longest_path_length:\n            M += 1\n        for child in paths[node]:\n            if uf[child] != uf[node]:\n                uf[child] = uf[node]\n                count_jumping_paths(child, path + [child])\n\n    N = int(stdin.readline())\n    labels = [int(stdin.readline()) for _ in range(N)]\n    tree = [[] for _ in range(N)]\n    for i in range(1, N):\n        parent = int(stdin.readline())\n        tree[parent].append(i)\n\n    uf = [None] * N\n    paths = [[] for _ in range(N)]\n    longest_path = None\n    longest_path_length = 0\n    dfs(0, -1)\n\n    M = 0\n    count_jumping_paths(0, [0])\n\n    return f\"{longest_path_length} {M % 11092019}\""
    },
    {
        "number": 3030,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    nodes = []\n    for i in range(1, n+1):\n        v, p = map(int, stdin.splitlines()[i].split())\n        nodes.append((v, p, i))\n\n    def find_largest_subset(nodes: List[Tuple[int, int, int]]) -> int:\n        max_subset = 0\n        for i in range(1, n+1):\n            subset = set()\n            subset.add(i)\n            for j in range(i+1, n+1):\n                if nodes[j-1][1] == i:\n                    subset.add(j)\n            if subset:\n                max_subset = max(max_subset, len(subset))\n        return max_subset\n\n    return str(find_largest_subset(nodes))"
    },
    {
        "number": 3031,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    graph = [[] for _ in range(n + 1)]\n    for a, b, c in edges:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    def dfs(node: int, color: int, visited: set, path: list) -> bool:\n        visited.add(node)\n        path.append(node)\n        rainbow = True\n        for neighbor, c in graph[node]:\n            if neighbor not in visited:\n                rainbow &= c != color\n                if not dfs(neighbor, c, visited, path):\n                    return False\n        if not rainbow:\n            path.pop()\n            return False\n        return True\n\n    good_nodes = []\n    for i in range(1, n + 1):\n        visited = set()\n        path = []\n        if dfs(i, 0, visited, path):\n            good_nodes.append(i)\n\n    return str(len(good_nodes)) + '\\n' + '\\n'.join(map(str, good_nodes))"
    },
    {
        "number": 3032,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    memory_banks, variables_per_bank = map(int, stdin.split()[0:2])\n    program = stdin.split()[2:]\n\n    # Initialize variables\n    min_instructions = 0\n    bsr_set = False\n    bsr_value = 0\n\n    # Iterate through program\n    for operation in program:\n        if operation.startswith(\"R\"):\n            # Repetition\n            n, program_body = operation.split(\" \", 1)\n            min_instructions += int(n) * len(program_body.split())\n        elif operation.startswith(\"V\"):\n            # Variable reference\n            min_instructions += 1\n        elif operation.startswith(\"E\"):\n            # End of loop\n            pass\n        else:\n            raise ValueError(\"Invalid operation: \" + operation)\n\n    return str(min_instructions)"
    },
    {
        "number": 3033,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    def f(x):\n        return sum(int(digit) for digit in str(x))\n    def f_B(x):\n        return f(x) % B\n    for x in range(1, 2**63):\n        if f_B(x) == N:\n            return str(x)\n    return \"impossible\""
    },
    {
        "number": 3034,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r = map(int, stdin.split()[:4])\n    clouds = []\n    for _ in range(c):\n        s, e, p, a = map(float, stdin.split()[4:])\n        clouds.append((s, e, p, a))\n    \n    roofs = []\n    for _ in range(r):\n        x, y = map(int, stdin.split()[4:])\n        roofs.append((x, y))\n    \n    def rain_intensity(cloud: tuple) -> float:\n        s, e, p, a = cloud\n        return p * (e - s) * a\n    \n    def expected_rain(clouds: list, roofs: list) -> float:\n        total_rain = 0\n        for cloud in clouds:\n            total_rain += rain_intensity(cloud)\n        for roof in roofs:\n            total_rain -= rain_intensity((roof[0], roof[1], 1, 0))\n        return total_rain\n    \n    return str(expected_rain(clouds, roofs))"
    },
    {
        "number": 3035,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    children = []\n\n    for i in range(1, n + 1):\n        offer, want, rate = lines[i].split()\n        children.append((offer, want, float(rate)))\n\n    max_blue = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            offer, want, rate = children[i]\n            offer2, want2, rate2 = children[j - 1]\n\n            if offer == 'blue' and want2 == 'blue':\n                max_blue += min(10, rate * rate2)\n            elif offer2 == 'blue' and want == 'blue':\n                max_blue += min(10, rate2 * rate)\n\n    return f\"{max_blue:.6f}\""
    },
    {
        "number": 3036,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_dinners(r, s, m, d, n, brands, dishes):\n        def is_compatible(dish1, dish2):\n            for ingredient in dish1:\n                if ingredient in dish2:\n                    return False\n            return True\n\n        compatible_dishes = [[] for _ in range(s + m + d)]\n        for i in range(s + m + d):\n            compatible_dishes[i].append(i)\n\n        for i in range(n):\n            dish1, dish2 = dishes[i]\n            compatible_dishes[dish1 - 1] = [j for j in compatible_dishes[dish1 - 1] if is_compatible(dishes[j - 1][1], dishes[dish2 - 1][1])]\n\n        count = 0\n        for i in range(s + m + d):\n            count += len(compatible_dishes[i])\n\n        return count\n\n    r, s, m, d, n = map(int, stdin.split()[:5])\n    brands = list(map(int, stdin.split()[5:5 + r]))\n    dishes = []\n\n    for i in range(s + m + d):\n        k, *ingredients = map(int, stdin.split())\n        dishes.append((i + 1, ingredients))\n\n    incompatible_dishes = []\n    for i in range(n):\n        dish1, dish2 = map(int, stdin.split())\n        incompatible_dishes.append((dish1, dish2))\n\n    result = count_dinners(r, s, m, d, n, brands, dishes)\n    return str(result) if result <= 10**18 else \"too many\""
    },
    {
        "number": 3037,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.readline().split())\n    board = [list(stdin.readline().strip()) for _ in range(h)]\n    commands = [stdin.readline().strip().split() for _ in range(n)]\n\n    def move(direction: str, distance: int) -> None:\n        nonlocal x, y\n        if direction == \"up\":\n            y -= distance\n        elif direction == \"down\":\n            y += distance\n        elif direction == \"left\":\n            x -= distance\n        elif direction == \"right\":\n            x += distance\n\n    def mark_board() -> None:\n        nonlocal x, y\n        board[y][x] = \"#\"\n\n    x, y = 0, 0\n    min_time, max_time = float(\"inf\"), -1\n    for command in commands:\n        direction, distance = command\n        move(direction, int(distance))\n        if board[y][x] == \"#\":\n            min_time = min(min_time, sum(command.split()) + 1)\n        else:\n            max_time = max(max_time, sum(command.split()) + 1)\n        mark_board()\n\n    if min_time == float(\"inf\") or max_time == -1:\n        return \"-1 -1\"\n    return f\"{min_time} {max_time}\""
    },
    {
        "number": 3038,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.split('\\n')[0].split())\n    companies = []\n    for i in range(k):\n        l_i, *sizes = map(int, stdin.split('\\n')[i+1].split())\n        companies.append([l_i, sizes])\n\n    def get_min_pack_size(B, company_index, pack_index, visited):\n        if company_index == len(companies):\n            return B\n\n        l_i, sizes = companies[company_index]\n        min_pack_size = float('inf')\n\n        for j in range(pack_index, l_i):\n            if (company_index, j) in visited:\n                continue\n\n            visited.add((company_index, j))\n            min_pack_size = min(min_pack_size, get_min_pack_size(B - sizes[j], company_index + 1, 0, visited))\n            visited.remove((company_index, j))\n\n        return min_pack_size\n\n    min_pack_size = float('inf')\n    for i in range(len(companies)):\n        for j in range(companies[i][0]):\n            min_pack_size = min(min_pack_size, get_min_pack_size(B, 0, j, set()))\n\n    return min_pack_size if min_pack_size != float('inf') else 'impossible'"
    },
    {
        "number": 3039,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input into lines\n    lines = stdin.split(\"\\n\")\n\n    # Check if the input is valid\n    if len(lines) != 6:\n        return \"cannot fold\"\n\n    for line in lines:\n        if len(line) != 6:\n            return \"cannot fold\"\n\n    # Check if there are exactly 6 #\n    count = 0\n    for line in lines:\n        count += line.count(\"#\")\n    if count != 6:\n        return \"cannot fold\"\n\n    # Check if there are no 2x2 subsquares\n    for i in range(4):\n        for j in range(4):\n            if lines[i][j] == \"#\" and lines[i][j + 1] == \"#\" and lines[i + 1][j] == \"#\" and lines[i + 1][j + 1] == \"#\":\n                return \"cannot fold\"\n\n    # Check if the input can be folded into a cube\n    for i in range(4):\n        for j in range(4):\n            if lines[i][j] == \"#\" and lines[i][j + 1] == \"#\" and lines[i + 1][j] == \"#\" and lines[i + 1][j + 1] == \".\":\n                return \"can fold\"\n            if lines[i][j] == \"#\" and lines[i][j + 1] == \".\" and lines[i + 1][j] == \"#\" and lines[i + 1][j + 1] == \"#\":\n                return \"can fold\"\n            if lines[i][j] == \".\" and lines[i][j + 1] == \"#\" and lines[i + 1][j] == \"#\" and lines[i + 1][j + 1] == \"#\":\n                return \"can fold\"\n\n    return \"cannot fold\""
    },
    {
        "number": 3040,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    longest_substring = \"\"\n    current_substring = \"\"\n    \n    for char in stdin:\n        if char in current_substring:\n            current_substring = current_substring[current_substring.index(char) + 1:] + char\n        else:\n            current_substring += char\n        \n        if len(current_substring) > len(longest_substring):\n            longest_substring = current_substring\n    \n    return longest_substring"
    },
    {
        "number": 3041,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    trips = []\n    for line in stdin.split('\\n'):\n        if line:\n            trip = list(map(int, line.split()))\n            trips.append(trip)\n\n    coupons = 0\n    current_ticket = None\n    current_zone = 0\n\n    for trip in trips:\n        zone, time = trip\n\n        if current_ticket is None or current_ticket[0] > zone or current_ticket[1] < zone:\n            coupons += 2 + abs(current_zone - zone)\n            current_ticket = [zone, zone]\n        else:\n            current_ticket[1] = zone\n\n        current_zone = zone\n\n    return str(coupons)"
    },
    {
        "number": 3042,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, values = stdin.split()\n    n = int(n)\n    values = list(map(int, values.split()))\n\n    def lcm(a, b):\n        return (a * b) // math.gcd(a, b)\n\n    def dfs(node, parent):\n        if node is None:\n            return 1\n        lcm_value = lcm(node.value, parent.value)\n        count = 0\n        for child in node.children:\n            if child.value == lcm_value:\n                count += dfs(child, node)\n        return count\n\n    class Node:\n        def __init__(self, value):\n            self.value = value\n            self.children = []\n\n    root = Node(values[0])\n    for i in range(1, n):\n        node = root\n        value = values[i]\n        while True:\n            lcm_value = lcm(node.value, value)\n            found = False\n            for child in node.children:\n                if child.value == lcm_value:\n                    node = child\n                    found = True\n                    break\n            if not found:\n                new_node = Node(lcm_value)\n                node.children.append(new_node)\n                node = new_node\n            else:\n                break\n\n    count = dfs(root, None)\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3043,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')\n    S, G = None, None\n\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                S = (i, j)\n            elif grid[i][j] == 'G':\n                G = (i, j)\n\n    if S is None or G is None:\n        return \"-1\"\n\n    def is_valid(cell: tuple) -> bool:\n        i, j = cell\n        return 0 <= i < N and 0 <= j < M\n\n    def get_cost(cell: tuple) -> int:\n        i, j = cell\n        if grid[i][j] == '.':\n            return 1\n        elif grid[i][j] == 'F':\n            return 2\n        elif grid[i][j] == 'M':\n            return 3\n        else:\n            return 0\n\n    def bfs(start: tuple, end: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            cell, cost = queue.pop(0)\n            if cell not in visited:\n                visited.add(cell)\n\n                if cell == end:\n                    return cost\n\n                for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    new_cell = (cell[0] + direction[0], cell[1] + direction[1])\n                    if is_valid(new_cell) and get_cost(new_cell) <= K:\n                        queue.append((new_cell, cost + 1))\n\n        return -1\n\n    min_days = bfs(S, G)\n    if min_days == -1:\n        return \"-1\"\n    else:\n        return str(min_days + 1)"
    },
    {
        "number": 3044,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, grid, commands = stdin.split(\"\\n\")\n    H, W = int(H), int(W)\n    start_pos = None\n    goal_pos = None\n    obstacles = set()\n\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == \"S\":\n                start_pos = (i, j)\n            elif grid[i][j] == \"G\":\n                goal_pos = (i, j)\n            elif grid[i][j] == \"#\":\n                obstacles.add((i, j))\n\n    def is_valid_move(pos, direction):\n        if direction == \"U\":\n            new_pos = (pos[0] - 1, pos[1])\n        elif direction == \"D\":\n            new_pos = (pos[0] + 1, pos[1])\n        elif direction == \"L\":\n            new_pos = (pos[0], pos[1] - 1)\n        elif direction == \"R\":\n            new_pos = (pos[0], pos[1] + 1)\n        else:\n            return False\n        return 0 <= new_pos[0] < H and 0 <= new_pos[1] < W and new_pos not in obstacles\n\n    def get_next_pos(pos, direction):\n        if direction == \"U\":\n            return (pos[0] - 1, pos[1])\n        elif direction == \"D\":\n            return (pos[0] + 1, pos[1])\n        elif direction == \"L\":\n            return (pos[0], pos[1] - 1)\n        elif direction == \"R\":\n            return (pos[0], pos[1] + 1)\n\n    def get_distance(pos1, pos2):\n        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\n    def get_min_changes(commands):\n        current_pos = start_pos\n        min_changes = 0\n        for command in commands:\n            if is_valid_move(current_pos, command):\n                current_pos = get_next_pos(current_pos, command)\n            else:\n                min_changes += 1\n        return min_changes\n\n    return str(get_min_changes(commands))"
    },
    {
        "number": 3045,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    beacons = []\n    for i in range(1, n + 1):\n        x, y, d = map(int, lines[i].split())\n        beacons.append((x, y, d))\n\n    def is_valid(x, y):\n        for beacon in beacons:\n            if abs(beacon[0] - x) + abs(beacon[1] - y) != beacon[2]:\n                return False\n        return True\n\n    for x in range(-1000000, 1000001):\n        for y in range(-1000000, 1000001):\n            if is_valid(x, y):\n                return f\"{x} {y}\"\n\n    return \"uncertain\""
    },
    {
        "number": 3046,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    corners = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    borders = [tuple(map(int, line.split())) for line in stdin.split('\\n')[n+1:]]\n    \n    # Check if the corners and borders are valid\n    if len(corners) != n or len(borders) != n:\n        return \"syntax error\"\n    \n    # Check if the corners and borders are distinct\n    if len(set(corners)) != n or len(set(borders)) != n:\n        return \"syntax error\"\n    \n    # Check if the corners and borders form valid rectangles\n    for i in range(n):\n        if corners[i] > borders[i] or corners[i][0] == borders[i][0] or corners[i][1] == borders[i][1]:\n            return \"syntax error\"\n    \n    # Check if the rectangles are properly nested\n    for i in range(n):\n        for j in range(n):\n            if i != j and (corners[i][0] <= corners[j][0] <= borders[j][0] <= borders[i][0] and corners[i][1] <= corners[j][1] <= borders[j][1] <= borders[i][1]):\n                return \"syntax error\"\n    \n    # Find the matching\n    matching = []\n    for i in range(n):\n        for j in range(n):\n            if i != j and (corners[i][0] <= corners[j][0] <= borders[j][0] <= borders[i][0] and corners[i][1] <= corners[j][1] <= borders[j][1] <= borders[i][1]):\n                matching.append((i+1, j+1))\n    \n    return '\\n'.join(map(str, matching))"
    },
    {
        "number": 3047,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_partial_info(partial_info: str) -> List[int]:\n        return [int(x) if x != \"_\" else None for x in partial_info.split()]\n\n    def get_monster_info(partial_info: List[int]) -> Dict[str, int]:\n        monster_info = {}\n        for i in range(5):\n            monster_info[monster_names[i]] = partial_info[i * 2 : i * 2 + 2]\n        return monster_info\n\n    def get_proportional_info(monster_info: Dict[str, int]) -> Dict[str, int]:\n        proportional_info = {}\n        for monster, info in monster_info.items():\n            for item, amount in info.items():\n                if amount is not None:\n                    proportional_info[item] = amount\n        return proportional_info\n\n    def get_inferred_info(monster_info: Dict[str, int], proportional_info: Dict[str, int]) -> Dict[str, int]:\n        inferred_info = {}\n        for item, amount in proportional_info.items():\n            for monster, info in monster_info.items():\n                if info[item] is None:\n                    inferred_info[monster] = {item: amount}\n        return inferred_info\n\n    def get_solution(monster_info: Dict[str, int], inferred_info: Dict[str, int]) -> int:\n        def count_solutions(monster_info: Dict[str, int], inferred_info: Dict[str, int], current_monster: str, current_info: Dict[str, int], solutions: List[Dict[str, int]]) -> int:\n            if not inferred_info:\n                solutions.append(current_info)\n                return 1\n\n            total_solutions = 0\n            for i in range(1, 201):\n                new_info = current_info.copy()\n                new_info[inferred_info.popitem()[0]] = i\n                total_solutions += count_solutions(monster_info, inferred_info, current_monster, new_info, solutions)\n\n            return total_solutions\n\n        solutions = []\n        count_solutions(monster_info, inferred_info, None, {}, solutions)\n        return len(solutions)\n\n    monster_names = [\"Salamander\", \"Yeti\", \"Golem\", \"Imp\", \"Kraken\"]\n    partial_info = stdin.split(\"\\n\")\n    if len(partial_info) != 2:\n        raise ValueError(\"Invalid input: must have exactly 2 lines\")\n\n    top_info = get_partial_info(partial_info[0])\n    bottom_info = get_partial_info(partial_info[1])\n    if len(top_info) != 10 or len(bottom_info) != 10:\n        raise ValueError(\"Invalid input: each line must have 10 entries\")\n\n    monster_info = get_monster_info(top_info + bottom_info)\n    proportional_info = get_proportional_info(monster_info)\n    inferred_info = get_inferred_info(monster_info, proportional_info)\n    solution = get_solution(monster_info, inferred_info)\n\n    return str(solution)"
    },
    {
        "number": 3048,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    roads = [set() for _ in range(N)]\n    for line in stdin.splitlines()[1:]:\n        u, v = map(int, line.split())\n        roads[u - 1].add(v - 1)\n        roads[v - 1].add(u - 1)\n\n    count = 0\n    for i in range(N):\n        for j in range(N):\n            if i != j and len(roads[i]) == 2 and len(roads[j]) == 2:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3049,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    count = 0\n    for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n        if encrypted_message[i:i+len(decrypted_fragment)] == decrypted_fragment:\n            count += 1\n            if count == 1:\n                return encrypted_message[i:i+len(decrypted_fragment)]\n    return str(count)"
    },
    {
        "number": 3050,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, program = stdin.split('\\n', 1)\n    N = int(N)\n    grid = [list(row) for row in stdin.split('\\n')[2:N+2]]\n\n    # Initialize robot position\n    robot_pos = (N-1, grid[N-1].index('R'))\n\n    # Initialize trail\n    trail = [robot_pos]\n\n    # Move robot according to program\n    while True:\n        new_pos = move_robot(robot_pos, program, grid)\n        if new_pos == robot_pos:\n            break\n        robot_pos = new_pos\n        trail.append(robot_pos)\n\n    # Check if trail is finite\n    if len(trail) == len(set(trail)):\n        return \"1\"\n\n    # Find X\n    suffix = trail[-N:]\n    for i in range(N):\n        if suffix[i:] == suffix[:N-i]:\n            return str(i)\n\ndef"
    },
    {
        "number": 3051,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    fogs = []\n    for i in range(1, n+1):\n        params = list(map(int, stdin.split('\\n')[i].split()))\n        fogs.append({\n            'm': params[0],\n            'd': params[1],\n            'l': params[2],\n            'r': params[3],\n            'h': params[4],\n            'dd': params[5],\n            'dx': params[6],\n            'dh': params[7],\n        })\n\n    def is_missed(fog, nets):\n        for net in nets:\n            if fog['l'] >= net['l'] and fog['r'] <= net['r'] and fog['h'] >= net['h']:\n                return False\n        return True\n\n    def add_net(fog, nets):\n        new_net = {\n            'l': fog['l'],\n            'r': fog['r'],\n            'h': fog['h'],\n        }\n        nets.append(new_net)\n        return nets\n\n    def update_nets(fogs, nets):\n        missed_fogs = 0\n        for fog in fogs:\n            if is_missed(fog, nets):\n                missed_fogs += 1\n                nets = add_net(fog, nets)\n        return missed_fogs, nets\n\n    missed_fogs = 0\n    nets = []\n    for i in range(1000):\n        missed_fogs_day, nets = update_nets(fogs, nets)\n        missed_fogs += missed_fogs_day\n\n    return str(missed_fogs)"
    },
    {
        "number": 3052,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    A, B = tuple(map(float, stdin.split()[:4]))\n    conveyors = []\n    for i in range(int(stdin.split()[4])):\n        conveyors.append(tuple(map(float, stdin.split()[5+i*4:9+i*4])))\n\n    # Calculate distance and time\n    distance = ((B[0] - A[0])**2 + (B[1] - A[1])**2)**0.5\n    time = distance / 1\n\n    # Calculate time on conveyors\n    for conveyor in conveyors:\n        if A[0] < conveyor[0] < B[0] or A[1] < conveyor[1] < B[1]:\n            time += ((conveyor[2] - conveyor[0])**2 + (conveyor[3] - conveyor[1])**2)**0.5 / 2\n\n    return str(time)"
    },
    {
        "number": 3053,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if P > N:\n        return \"IMPOSSIBLE\"\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def find_longest_palindrome(s: str) -> int:\n        longest = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if is_palindrome(s[i:j]):\n                    longest = max(longest, j - i)\n        return longest\n\n    def generate_string(N: int, K: int, P: int) -> str:\n        if P > N:\n            return \"IMPOSSIBLE\"\n\n        def generate_palindrome(N: int, K: int, P: int) -> str:\n            if P > N:\n                return \"IMPOSSIBLE\"\n\n            if P == 1:\n                return \"a\" * N\n\n            if P == N:\n                return \"a\" * (N // 2) + \"b\" + \"a\" * ((N - 1) // 2)\n\n            if N % 2 == 0:\n                return \"a\" * (N // 2) + \"b\" + \"a\" * ((N - 1) // 2)\n            else:\n                return \"a\" * ((N - 1) // 2) + \"b\" + \"a\" * ((N - 1) // 2)\n\n        def generate_non_palindrome(N: int, K: int, P: int) -> str:\n            if P > N:\n                return \"IMPOSSIBLE\"\n\n            if P == 1:\n                return \"a\" * N\n\n            if P == N:\n                return \"a\" * (N // 2) + \"b\" + \"a\" * ((N - 1) // 2)\n\n            if N % 2 == 0:\n                return \"a\" * (N // 2) + \"b\" + \"a\" * ((N - 1) // 2)\n            else:\n                return \"a\" * ((N - 1) // 2) + \"b\" + \"a\" * ((N - 1) // 2)\n\n        if K == 1:\n            return generate_palindrome(N, K, P)\n        else:\n            return generate_non_palindrome(N, K, P)\n\n    return generate_string(N, K, P)"
    },
    {
        "number": 3054,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n        syllables = 0\n        prev_char = ''\n        for char in word:\n            if char in vowels:\n                if prev_char != 'Q' and (char != 'Y' or prev_char not in vowels):\n                    syllables += 1\n            prev_char = char\n        return syllables\n\n    def is_haiku(words: List[str]) -> bool:\n        return all(count_syllables(word) <= 5 for word in words[:3]) and all(count_syllables(word) <= 7 for word in words[3:])\n\n    words = stdin.split()\n    if is_haiku(words):\n        return '\\n'.join([\n            ' '.join(words[:3]),\n            ' '.join(words[3:6]),\n            ' '.join(words[6:])\n        ])\n    else:\n        return stdin"
    },
    {
        "number": 3055,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    names = stdin.split('\\n')\n    thore_index = names.index(\"ThoreHusfeldt\")\n    thore_prefix = \"ThoreHusfeldt\"\n    for i in range(thore_index - 1, -1, -1):\n        if \"ThoreHusfeld\" in names[i]:\n            return \"Thore sucks\"\n        if names[i] < thore_prefix:\n            thore_prefix = names[i]\n    return thore_prefix"
    },
    {
        "number": 3056,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def walk_value(walk: str) -> int:\n        node = 1\n        for move in walk:\n            if move == 'L':\n                node = 2 * node\n            elif move == 'R':\n                node = 2 * node + 1\n        return node\n\n    def set_value(set_: str) -> int:\n        total = 0\n        for walk in set_.split('*'):\n            total += walk_value(walk)\n        return total\n\n    return str(set_value(stdin))"
    },
    {
        "number": 3057,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    statements = stdin.split('\\n')\n    N = int(statements[0])\n    statements = statements[1:]\n\n    def is_rhyme(word1: str, word2: str) -> bool:\n        min_length = min(3, len(word1), len(word2))\n        return word1[-min_length:] == word2[-min_length:]\n\n    def is_same(word1: str, word2: str) -> bool:\n        return word1 == word2 or is_rhyme(word1, word2)\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            statement1 = statements[i]\n            statement2 = statements[j]\n            words1 = statement1.split(' ')\n            words2 = statement2.split(' ')\n            if len(words1) != 3 or len(words2) != 3:\n                return \"wait what?\"\n            word1_1, relation1, word1_2 = words1\n            word2_1, relation2, word2_2 = words2\n            if relation1 == 'is' and relation2 == 'is':\n                if not is_same(word1_1, word2_1) or not is_same(word1_2, word2_2):\n                    return \"wait what?\"\n            elif relation1 == 'is' and relation2 == 'not':\n                if is_same(word1_1, word2_1) or is_same(word1_2, word2_2):\n                    return \"wait what?\"\n            elif relation1 == 'not' and relation2 == 'is':\n                if is_same(word1_1, word2_1) or is_same(word1_2, word2_2):\n                    return \"wait what?\"\n            elif relation1 == 'not' and relation2 == 'not':\n                if not is_same(word1_1, word2_1) or not is_same(word1_2, word2_2):\n                    return \"wait what?\"\n\n    return \"yes\""
    },
    {
        "number": 3058,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    current_species = lines[1]\n    fossil_sequences = lines[2:]\n\n    if n == 1:\n        return \"impossible\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if len(set(fossil_sequences[i]) & set(fossil_sequences[j])) == 0:\n                return f\"{i + 1} {j + 1}\\n{fossil_sequences[i]}\\n{current_species}\\n{fossil_sequences[j]}\"\n\n    return \"impossible\""
    },
    {
        "number": 3059,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = []\n    for i in range(m):\n        t, p, d = map(float, stdin.split()[3*i+3:3*i+6])\n        tricks.append((t, p, d))\n    \n    def expected_time(t, p, d, n, r):\n        if t >= n:\n            return 0\n        return (n - t) * p + d + expected_time(t + d, p, d, n, r)\n    \n    def expected_time_to_set_record(n, r, tricks):\n        tricks.sort(key=lambda x: x[0])\n        total_time = 0\n        for t, p, d in tricks:\n            total_time += expected_time(t, p, d, n, r)\n        return total_time\n    \n    return str(expected_time_to_set_record(n, r, tricks))"
    },
    {
        "number": 3060,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 2:\n        return \"1\"\n\n    def is_valid(seq: List[int]) -> bool:\n        for i in range(len(seq) - 1):\n            if (seq[i] + seq[i + 1]) % n == 0:\n                return False\n        return True\n\n    def next_valid_sequence(seq: List[int]) -> List[int]:\n        for i in range(len(seq) - 1, -1, -1):\n            if seq[i] < n - 1:\n                seq[i] += 1\n                for j in range(i + 1, len(seq)):\n                    seq[j] = seq[j - 1] + 1\n                return seq\n        return []\n\n    seq = [1] * (n - 1)\n    valid_sequences = 1\n    while valid_sequences < k:\n        seq = next_valid_sequence(seq)\n        if not is_valid(seq):\n            valid_sequences += 1\n\n    return \" \".join(map(str, seq))"
    },
    {
        "number": 3061,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def dfs(start: int, visited: set, path: list) -> int:\n        if start in visited:\n            return 0\n        visited.add(start)\n        max_length = 0\n        for end in range(1, n + 1):\n            if (start, end) in roads or (end, start) in roads:\n                max_length = max(max_length, dfs(end, visited, path + [end]))\n        return max_length\n\n    max_length = 0\n    for start in range(1, n + 1):\n        max_length = max(max_length, dfs(start, set(), [start]))\n\n    return str(max_length)\n"
    },
    {
        "number": 3062,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n    x, y = int(x), int(y)\n    v, w = round(v, 2), round(w, 2)\n\n    distance = abs(x) + abs(y)\n    time = distance / v\n\n    if x == 0 and y == 0:\n        return \"0.00000000\"\n\n    if x == 0:\n        if y > 0:\n            angle = math.atan(w)\n        else:\n            angle = math.pi - math.atan(w)\n    else:\n        if y > 0:\n            angle = math.atan(abs(y) / abs(x))\n        else:\n            angle = math.pi - math.atan(abs(y) / abs(x))\n\n    time += angle / w\n\n    return f\"{time:.6f}\""
    },
    {
        "number": 3063,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    debts = {}\n    for i in range(1, n+1):\n        debtor, amount = map(int, lines[i].split())\n        if debtor not in debts:\n            debts[debtor] = 0\n        debts[debtor] += amount\n\n    total_debt = sum(debts.values())\n    total_money = sum(debts.keys())\n    return str(total_debt - total_money)"
    },
    {
        "number": 3064,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n    \n    # Create a graph with adjacency list\n    graph = {i: set() for i in range(1, N+1)}\n    for a, b in roads:\n        graph[a].add(b)\n        graph[b].add(a)\n    \n    # DFS function to find the longest path\n    def dfs(node, visited, path_length):\n        if node == 1:\n            return path_length\n        visited.add(node)\n        max_length = 0\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                max_length = max(max_length, dfs(neighbor, visited, path_length+1))\n        visited.remove(node)\n        return max_length\n    \n    # Find the longest path\n    max_length = 0\n    for node in range(1, N+1):\n        max_length = max(max_length, dfs(node, set(), 0))\n    \n    return str(max_length)"
    },
    {
        "number": 3065,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L, walk, neighbors = stdin.split('\\n')\n    N = int(N)\n    L = int(L)\n    walk = list(map(int, walk.split()))\n    neighbors = [list(map(int, line.split())) for line in neighbors.split('\\n')]\n\n    # Calculate the probability of meeting the sentry in each room\n    probabilities = [0] * N\n    for i in range(N):\n        probabilities[i] = 1 / len(neighbors[i])\n\n    # Calculate the probability of meeting the sentry in each room in the given walk\n    walk_probabilities = [probabilities[walk[i]] for i in range(L)]\n\n    # Calculate the probability of not meeting the sentry in any room\n    probability = 1\n    for p in walk_probabilities:\n        probability *= (1 - p)\n\n    return str(probability)"
    },
    {
        "number": 3066,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = list(map(int, stdin.split('\\n')[1].split()))\n\n    if len(colors) != n:\n        return \"IMPOSSIBLE\"\n\n    color_count = {}\n    for color in colors:\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    if len(color_count) != n:\n        return \"IMPOSSIBLE\"\n\n    result = []\n    for i in range(n):\n        result.append(f\"{i+1} {i+1} {colors[i]}\")\n\n    return f\"{n}\\n{' '.join(result)}\""
    },
    {
        "number": 3067,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    num_sequences = int(lines[0])\n    sequences = []\n    for i in range(1, num_sequences + 1):\n        sequence_length = int(lines[i])\n        sequence = [int(x) for x in lines[i + 1].split()]\n        sequences.append(sequence)\n\n    solution_sequence = []\n    for sequence in sequences:\n        solution_sequence.append(sequence.pop(0))\n\n    return ' '.join(str(x) for x in solution_sequence)"
    },
    {
        "number": 3068,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    num_investigations = int(lines[0])\n    if num_investigations == 0:\n        return \"2600\"\n\n    investigations = []\n    for i in range(1, num_investigations + 1):\n        line = lines[i].split()\n        investigations.append((line[0], line[1], int(line[2])))\n\n    # Count the number of admissible solutions\n    solutions = 0\n    for i in range(26):\n        for j in range(i + 1, 26):\n            for k in range(j + 1, 26):\n                valid = True\n                for investigation in investigations:\n                    if investigation[2] == 0:\n                        continue\n                    if investigation[1] == \"1\":\n                        if investigation[0][0] not in [chr(i + 65), chr(j + 65), chr(k + 65)]:\n                            valid = False\n                            break\n                    else:\n                        if investigation[0][0] not in [chr(i + 65), chr(j + 65), chr(k + 65)]:\n                            valid = False\n                            break\n                        if investigation[0][1] not in [chr(i + 65), chr(j + 65), chr(k + 65)]:\n                            valid = False\n                            break\n                if valid:\n                    solutions += 1\n\n    return str(solutions)"
    },
    {
        "number": 3069,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for char in stdin:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(char)\n\n    if not stack:\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3070,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    trains = []\n    for i in range(M):\n        X, S, T, L = map(int, stdin.split()[4*i:4*(i+1)])\n        trains.append((X, S+L, T+L, L))\n    \n    trains.sort(key=lambda x: x[1])\n    start_time = 0\n    for train in trains:\n        if train[1] - start_time >= 1800:\n            return str(start_time)\n        start_time = train[2]\n    \n    return \"impossible\""
    },
    {
        "number": 3071,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    players = [chr(i) for i in range(ord('A'), ord('A') + m)]\n    games = []\n    for i in range(m - 1):\n        for j in range(n):\n            for k in range(m - 1):\n                if k != i:\n                    games.append(f\"{players[i]}{j+1}-{players[k]}{j+1}\")\n    rounds = []\n    for i in range(len(games)):\n        rounds.append(games[i * (m - 1) : (i + 1) * (m - 1)])\n    return \"\\n\".join([\" \".join(round) for round in rounds])"
    },
    {
        "number": 3072,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    apartment = [list(row) for row in stdin.split()[1:]]\n\n    max_people = 0\n    for i in range(R):\n        for j in range(C):\n            if apartment[i][j] == '.':\n                for k in range(i, R):\n                    for l in range(j, C):\n                        if apartment[k][l] == '.':\n                            max_people += 2\n                        else:\n                            break\n                    else:\n                        continue\n                    break\n                    \n                for k in range(i, -1, -1):\n                    for l in range(j, -1, -1):\n                        if apartment[k][l] == '.':\n                            max_people += 2\n                        else:\n                            break\n                    else:\n                        continue\n                    break\n                    \n                for k in range(i, R):\n                    for l in range(j, C):\n                        if apartment[k][l] == '.':\n                            max_people += 2\n                        else:\n                            break\n                    else:\n                        continue\n                    break\n                    \n                for k in range(i, -1, -1):\n                    for l in range(j, C):\n                        if apartment[k][l] == '.':\n                            max_people += 2\n                        else:\n                            break\n                    else:\n                        continue\n                    break\n                    \n                max_people //= 2\n                if max_people > 0:\n                    return str(max_people)\n                else:\n                    return \"0\""
    },
    {
        "number": 3073,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_tarot_cards(stdin: str) -> List[Tuple[int, int, int, int, int]]:\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        cards = []\n        for i in range(1, n + 1):\n            r, c, a, b, p = map(int, lines[i].split())\n            cards.append((r, c, a, b, p))\n        return cards\n\n    def get_min_cost(cards: List[Tuple[int, int, int, int, int]]) -> int:\n        def get_neighbors(r: int, c: int, a: int, b: int) -> List[Tuple[int, int]]:\n            return [(r - a, c - b), (r + a, c - b), (r - a, c + b), (r + a, c + b), (c + b, r), (c - b, r), (c + b, r - a), (c - b, r - a)]\n\n        def dfs(cards: List[Tuple[int, int, int, int, int]], r: int, c: int, visited: Set[Tuple[int, int]], cost: int) -> int:\n            if (r, c) == (0, 0):\n                return cost\n\n            min_cost = float('inf')\n            for card in cards:\n                if (card[0], card[1]) == (r, c):\n                    for neighbor in get_neighbors(card[0], card[1], card[2], card[3]):\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            min_cost = min(min_cost, dfs(cards, neighbor[0], neighbor[1], visited, cost + card[4]))\n                            visited.remove(neighbor)\n\n            return min_cost\n\n        return dfs(cards, 0, 0, set(), 0)\n\n    cards = get_tarot_cards(stdin)\n    min_cost = get_min_cost(cards)\n    return str(min_cost) if min_cost != float('inf') else '-1'"
    },
    {
        "number": 3074,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split()\n    N = int(N)\n    S = str(S)\n    \n    def is_valid(s: str) -> bool:\n        if len(s) == 0:\n            return False\n        if s[0] == '0':\n            return False\n        if len(s) == 1:\n            return True\n        if int(s) % 3 == 0:\n            return True\n        return False\n    \n    def count_valid_subsets(s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                if is_valid(s[j:i]):\n                    dp[i] += dp[j]\n            dp[i] %= 1000000007\n        return dp[n]\n    \n    return str(count_valid_subsets(S))"
    },
    {
        "number": 3075,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split()[0].split())\n    gas_stations = []\n\n    for i in range(n):\n        distance, cost = map(int, stdin.split()[i + 1].split())\n        gas_stations.append((distance, cost))\n\n    gas_stations.sort(key=lambda x: x[0])\n    fuel_tank = g\n    total_cost = 0\n\n    for station in gas_stations:\n        distance, cost = station\n        fuel_needed = distance - fuel_tank\n\n        if fuel_needed > 0:\n            fuel_tank = 0\n            total_cost += fuel_needed * cost\n\n        fuel_tank = max(fuel_tank, distance)\n\n    if fuel_tank < distance:\n        return \"cancel road trip\"\n    else:\n        return total_cost"
    },
    {
        "number": 3076,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    jewels = []\n    for line in stdin.split('\\n')[2:]:\n        if line:\n            s, v = map(int, line.split())\n            jewels.append((s, v))\n\n    jewels.sort(key=lambda x: x[0], reverse=True)\n    dp = [0] * (k + 1)\n\n    for jewel in jewels:\n        for i in range(k, 0, -1):\n            if jewel[0] <= i:\n                dp[i] = max(dp[i], dp[i - jewel[0]] + jewel[1])\n\n    return ' '.join(map(str, dp[1:]))"
    },
    {
        "number": 3077,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_village(village, point):\n        return (point[0] - village[0]) ** 2 + (point[1] - village[1]) ** 2 <= village[2] ** 2\n\n    def is_inside_circle(center, radius, point):\n        return (point[0] - center[0]) ** 2 + (point[1] - center[1]) ** 2 <= radius ** 2\n\n    def is_valid_attack(villages, center, radius):\n        for village in villages:\n            if is_inside_circle(center, radius, village):\n                return False\n        return True\n\n    def count_destroyed_minions(villages, center, radius):\n        count = 0\n        for minion in minions:\n            if is_inside_circle(center, radius, minion):\n                count += 1\n        return count\n\n    villages = []\n    minions = []\n\n    n, m, r = map(int, stdin.readline().split())\n\n    for _ in range(n):\n        village = tuple(map(int, stdin.readline().split()))\n        villages.append(village)\n\n    for _ in range(m):\n        minion = tuple(map(int, stdin.readline().split()))\n        minions.append(minion)\n\n    max_destroyed_minions = 0\n    for center in minions:\n        for radius in range(1, r + 1):\n            if is_valid_attack(villages, center, radius):\n                destroyed_minions = count_destroyed_minions(villages, center, radius)\n                max_destroyed_minions = max(max_destroyed_minions, destroyed_minions)\n\n    return str(max_destroyed_minions)"
    },
    {
        "number": 3078,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    result = []\n\n    for i in range(N):\n        longest_interesting_subsequence = 0\n        current_sum = 0\n        for j in range(i, N):\n            current_sum += A[j]\n            if current_sum <= S:\n                longest_interesting_subsequence = j - i + 1\n            else:\n                break\n        result.append(longest_interesting_subsequence)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3079,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    sequence = stdin.split()[1]\n\n    def is_valid(word: str) -> bool:\n        return word[0] <= word[-1]\n\n    def find_most_beautiful_word(sequence: str) -> str:\n        for i in range(len(sequence)):\n            word = sequence[i] + sequence[i+1:]\n            if is_valid(word):\n                return word\n        return \"\"\n\n    def find_most_beautiful_word_for_slavko(sequence: str) -> str:\n        for i in range(len(sequence) - 1, -1, -1):\n            word = sequence[i] + sequence[i+1:]\n            if is_valid(word):\n                return word\n        return \"\"\n\n    most_beautiful_word = find_most_beautiful_word(sequence)\n    most_beautiful_word_for_slavko = find_most_beautiful_word_for_slavko(sequence)\n\n    if most_beautiful_word == most_beautiful_word_for_slavko:\n        return \"NE\\n\" + most_beautiful_word\n    else:\n        return \"DA\\n\" + most_beautiful_word_for_slavko"
    },
    {
        "number": 3080,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_runs(n, m, ski_runs):\n        adj_list = [[] for _ in range(n + 1)]\n        for x, y in ski_runs:\n            adj_list[x].append(y)\n            adj_list[y].append(x)\n        visited = [False] * (n + 1)\n        def dfs(node, depth):\n            if depth == 0:\n                return 1\n            visited[node] = True\n            count = 0\n            for neighbor in adj_list[node]:\n                if not visited[neighbor]:\n                    count += dfs(neighbor, depth - 1)\n            visited[node] = False\n            return count\n        return [dfs(1, i) for i in range(n + 1)]\n\n    def count_ways(n, m, ski_runs, queries):\n        runs = find_runs(n, m, ski_runs)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][i] = 1\n        for k in range(2, n + 1):\n            for i in range(1, n - k + 1):\n                j = i + k\n                dp[i][j] = 0\n                for x in range(i, j):\n                    dp[i][j] += dp[i][x] * dp[x + 1][j]\n        result = []\n        for k, a, *areas in queries:\n            count = 0\n            for i in range(1, n + 1):\n                if i in areas:\n                    count += dp[1][i] * runs[i]\n            result.append(count)\n        return result\n\n    n, m, q = map(int, stdin.readline().split())\n    ski_runs = []\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        ski_runs.append((x, y))\n    queries = []\n    for _ in range(q):\n        k, a, *areas = map(int, stdin.readline().split())\n        queries.append((k, a, *areas))\n\n    return \"\\n\".join(map(str, count_ways(n, m, ski_runs, queries)))"
    },
    {
        "number": 3081,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    inspection_times = list(map(int, stdin.split()[2:2+n]))\n    flight_times = []\n    for i in range(n):\n        flight_times.append(list(map(int, stdin.split()[2+n+i*n:2+n+(i+1)*n])))\n    \n    flights = []\n    for i in range(m):\n        s, f, t = map(int, stdin.split()[2+n*n+i*3:2+n*n+(i+1)*3])\n        flights.append((s, f, t))\n    \n    def get_flight_time(s, f, flight_times):\n        return flight_times[s][f]\n    \n    def get_inspection_time(airport, inspection_times):\n        return inspection_times[airport]\n    \n    def get_flight_duration(s, f, t, flight_times):\n        return t + get_flight_time(s, f, flight_times)\n    \n    def get_flight_inspection_time(s, f, t, flight_times, inspection_times):\n        return get_flight_duration(s, f, t, flight_times) + get_inspection_time(f, inspection_times)\n    \n    def get_flight_inspection_times(flights, flight_times, inspection_times):\n        flight_inspection_times = []\n        for flight in flights:\n            s, f, t = flight\n            flight_inspection_times.append(get_flight_inspection_time(s, f, t, flight_times, inspection_times))\n        return flight_inspection_times\n    \n    def get_minimum_planes(flight_inspection_times):\n        flight_inspection_times.sort()\n        planes = 0\n        current_time = 0\n        for flight_inspection_time in flight_inspection_times:\n            if flight_inspection_time > current_time:\n                planes += 1\n                current_time = flight_inspection_time\n        return planes\n    \n    flight_inspection_times = get_flight_inspection_times(flights, flight_times, inspection_times)\n    minimum_planes = get_minimum_planes(flight_inspection_times)\n    \n    return str(minimum_planes)"
    },
    {
        "number": 3082,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, w = map(int, stdin.split()[:2])\n    dishes = []\n    for line in stdin.split('\\n')[1:]:\n        if line[0] == 'D':\n            w_i, t_i, delta_t_i = map(int, line.split()[1:])\n            dishes.append((w_i, t_i, delta_t_i, True))\n        elif line[0] == 'C':\n            t_i, delta_t_i = map(int, line.split()[1:])\n            dishes.append((t_i, delta_t_i, True))\n\n    def total_tastiness(dish, weight):\n        if dish[3]:\n            return dish[0] * weight\n        else:\n            return dish[0] * weight + dish[1] * weight + dish[2] * weight * weight / 2\n\n    max_tastiness = 0\n    for i in range(len(dishes)):\n        for j in range(i+1, len(dishes)):\n            for k in range(j+1, len(dishes)):\n                for l in range(k+1, len(dishes)):\n                    for m in range(l+1, len(dishes)):\n                        for n in range(m+1, len(dishes)):\n                            for o in range(n+1, len(dishes)):\n                                for p in range(o+1, len(dishes)):\n                                    for q in range(p+1, len(dishes)):\n                                        for r in range(q+1, len(dishes)):\n                                            for s in range(r+1, len(dishes)):\n                                                for t in range(s+1, len(dishes)):\n                                                    for u in range(t+1, len(dishes)):\n                                                        for v in range(u+1, len(dishes)):\n                                                            for w_i, t_i, delta_t_i, is_discrete in dishes:\n                                                if is_discrete:\n                                                    max_tastiness = max(max_tastiness, total_tastiness((w_i, t_i, delta_t_i, True), w))\n                                                else:\n                                                    max_tastiness = max(max_tastiness, total_tastiness((t_i, delta_t_i, False), w))\n\n    return max_tastiness\n\ndef"
    },
    {
        "number": 3083,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    songs = {}\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            artist, t, *next_songs = line.split()\n            next_songs = [int(x) for x in next_songs]\n            songs[artist] = {\"t\": int(t), \"next_songs\": next_songs}\n\n    def find_playlist(artist: str, visited: set, playlist: list) -> bool:\n        if len(playlist) == 9:\n            return True\n        if artist in visited:\n            return False\n        visited.add(artist)\n        for next_song in songs[artist][\"next_songs\"]:\n            next_artist = [k for k, v in songs.items() if next_song in v[\"next_songs\"]][0]\n            if find_playlist(next_artist, visited, playlist + [next_song]):\n                return True\n        visited.remove(artist)\n        return False\n\n    for artist in songs:\n        if find_playlist(artist, set(), []):\n            playlist = [1]\n            current_artist = artist\n            while len(playlist) < 9:\n                next_song = [x for x in songs[current_artist][\"next_songs\"] if x not in playlist][0]\n                current_artist = [k for k, v in songs.items() if next_song in v[\"next_songs\"]][0]\n                playlist.append(next_song)\n            return \" \".join(str(x) for x in playlist)\n\n    return \"fail\""
    },
    {
        "number": 3084,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    original_time, current_time = stdin.split('\\n')\n    original_hour, original_minute = map(int, original_time.split(':'))\n    current_hour, current_minute = map(int, current_time.split(':'))\n\n    def set_time(hour: int, minute: int) -> str:\n        return f\"{hour:02d}:{minute:02d}\"\n\n    def increase_time(hour: int, minute: int) -> tuple:\n        if minute == 59:\n            return (hour + 1) % 24, 0\n        else:\n            return hour, minute + 1\n\n    def decrease_time(hour: int, minute: int) -> tuple:\n        if minute == 0:\n            return (hour - 1) % 24, 9\n        else:\n            return hour, minute - 1\n\n    def get_valid_times(original_hour: int, original_minute: int, current_hour: int, current_minute: int) -> list:\n        valid_times = []\n        current_time = set_time(current_hour, current_minute)\n        valid_times.append(current_time)\n\n        while True:\n            original_hour, original_minute = decrease_time(original_hour, original_minute)\n            current_hour, current_minute = decrease_time(current_hour, current_minute)\n            new_time = set_time(current_hour, current_minute)\n\n            if new_time not in valid_times:\n                valid_times.append(new_time)\n\n            if original_hour == current_hour and original_minute == current_minute:\n                break\n\n        return valid_times\n\n    valid_times = get_valid_times(original_hour, original_minute, current_hour, current_minute)\n    output = [str(len(valid_times))]\n    output.extend(valid_times)\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3085,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    result = []\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            start = stack.pop()\n            end = i\n            result.append(f\"{start},{end}:\")\n    \n    return ''.join(result)"
    },
    {
        "number": 3086,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    events = []\n    for i in range(1, n + 1):\n        start_date, start_month, end_date, end_month, *counts = map(int, lines[i].split())\n        events.append((start_date, start_month, end_date, end_month, counts))\n\n    def is_valid(event_counts: List[int]) -> bool:\n        total_days = sum(event_counts)\n        if total_days == 0:\n            return False\n        for count in event_counts:\n            if count == 0:\n                continue\n            if count % total_days != 0:\n                return False\n        return True\n\n    def get_duration(event_counts: List[int]) -> int:\n        total_days = sum(event_counts)\n        for count in event_counts:\n            if count == 0:\n                continue\n            duration = total_days // count\n            if duration * count == total_days:\n                return duration\n        return -1\n\n    event_counts = [0] * m\n    for event in events:\n        for i, count in enumerate(event[4]):\n            event_counts[i] += count\n\n    if not is_valid(event_counts):\n        return \"-1\"\n\n    return \" \".join(str(get_duration(event_counts)) for _ in range(m))"
    },
    {
        "number": 3087,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    arrows = [0] * N\n    for i in range(N):\n        arrows[i] = a[i] - 1\n\n    for i in range(N):\n        if arrows[i] == i:\n            arrows[i] = N\n\n    if len(set(arrows)) != N:\n        return \"Impossible\"\n\n    return \" \".join(map(str, arrows))"
    },
    {
        "number": 3088,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = list(str(n))\n    for _ in range(k):\n        for i in range(len(digits) - 1):\n            if digits[i] < digits[i + 1]:\n                digits[i], digits[i + 1] = digits[i + 1], digits[i]\n                break\n    return int(\"\".join(digits))"
    },
    {
        "number": 3089,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    cbd = Polygon(points)\n    expected_distance = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            expected_distance += cbd.distance(points[i], points[j])\n    expected_distance /= n * (n-1) / 2\n    return str(expected_distance)"
    },
    {
        "number": 3090,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected(grid, i, j):\n        if i < 0 or i >= N or j < 0 or j >= M:\n            return False\n        return grid[i][j] == 1\n\n    def dfs(grid, i, j, cost):\n        if i < 0 or i >= N or j < 0 or j >= M:\n            return cost\n        if grid[i][j] == 0:\n            return cost\n        grid[i][j] = 0\n        cost += 1\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            cost = dfs(grid, i + di, j + dj, cost)\n        return cost\n\n    N, M, K, *costs = map(int, stdin.split())\n    N, M = N + 1, M + 1\n    grid = [[0] * M for _ in range(N)]\n    for i in range(N - 1):\n        for j in range(M - 1):\n            if is_connected(grid, i, j) and is_connected(grid, i + 1, j) and is_connected(grid, i, j + 1):\n                grid[i][j] = 1\n                grid[i + 1][j] = 1\n                grid[i][j + 1] = 1\n\n    total_cost = 0\n    for i in range(N - 1):\n        for j in range(M - 1):\n            if grid[i][j] == 0:\n                total_cost += K\n            else:\n                total_cost += min(costs[i * M + j], costs[(i + 1) * M + j], costs[i * M + j + 1])\n\n    return str(total_cost)"
    },
    {
        "number": 3091,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, stdin.split())\n    grid = []\n    for _ in range(n):\n        grid.append(list(map(int, input().split())))\n\n    def is_valid(row, col, num):\n        if num in grid[row] or num in [grid[i][col] for i in range(n)]:\n            return False\n        return True\n\n    def fill_section(row, col, num):\n        grid[row][col] = num\n        if col + 1 < n and grid[row][col + 1] == 0:\n            fill_section(row, col + 1, num + 1)\n        elif row + 1 < n and grid[row + 1][col] == 0:\n            fill_section(row + 1, col, num + 1)\n\n    def count_solutions(row, col):\n        if row == n - 1 and col == n - 1:\n            return 1\n        if col + 1 < n and grid[row][col + 1] == 0:\n            count = 0\n            for num in range(1, n + 1):\n                if is_valid(row, col + 1, num):\n                    fill_section(row, col + 1, num)\n                    count += count_solutions(row, col + 1)\n                    fill_section(row, col + 1, 0)\n            return count\n        elif row + 1 < n and grid[row + 1][col] == 0:\n            count = 0\n            for num in range(1, n + 1):\n                if is_valid(row + 1, col, num):\n                    fill_section(row + 1, col, num)\n                    count += count_solutions(row + 1, col)\n                    fill_section(row + 1, col, 0)\n            return count\n        return 0\n\n    count = 0\n    for num in range(1, n + 1):\n        if is_valid(0, 0, num):\n            fill_section(0, 0, num)\n            count += count_solutions(0, 0)\n            fill_section(0, 0, 0)\n\n    return str(count)"
    },
    {
        "number": 3092,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    roads = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def shortest_paths(start: int, end: int, visited: set, path: list, paths: list) -> None:\n        if start == end:\n            paths.append(path)\n            return\n\n        for i, (o, d, l) in enumerate(roads):\n            if o == start and d not in visited:\n                shortest_paths(d, end, visited | {d}, path + [(i, l)], paths)\n\n    paths = []\n    for i, (o, d, l) in enumerate(roads):\n        shortest_paths(o, d, {o}, [(i, l)], paths)\n\n    result = [0] * M\n    for path in paths:\n        for i, l in path:\n            result[i] += 1\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3093,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    f = list(map(int, stdin.split()[2:]))\n    \n    # Calculate the number of possible ways to color the book\n    total_ways = K ** N\n    \n    # Calculate the number of ways to color the book without considering the condition f_i = i\n    ways_without_condition = K ** (N - len(set(f)))\n    \n    # Calculate the number of ways to color the book considering the condition f_i = i\n    ways_with_condition = 0\n    for i in range(N):\n        if f[i] == i:\n            ways_with_condition += K - 1\n    \n    # Calculate the final number of possible ways to color the book\n    final_ways = (total_ways - ways_without_condition) * ways_with_condition\n    \n    # Return the result modulo 1000000007\n    return str(final_ways % 1000000007)"
    },
    {
        "number": 3094,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = stdin.split()\n    n = int(n)\n    t = list(map(int, t.split()))\n\n    mod = 10**9 + 7\n    count = 1\n\n    for i in range(n):\n        count *= (t[i] - i - 1) % mod\n        count %= mod\n\n    return str(count)"
    },
    {
        "number": 3095,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split()[:2])\n    matrix = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_cool(matrix: List[List[int]]) -> bool:\n        r, s = len(matrix), len(matrix[0])\n        return r > 1 and s > 1 and matrix[0][0] + matrix[r - 1][s - 1] <= matrix[0][s - 1] + matrix[r - 1][0]\n\n    def count_cool_submatrices(matrix: List[List[int]]) -> int:\n        r, s = len(matrix), len(matrix[0])\n        count = 0\n        for i in range(r - 1):\n            for j in range(s - 1):\n                submatrix = [row[j:j + 2] for row in matrix[i:i + 2]]\n                if is_cool(submatrix):\n                    count += 1\n        return count\n\n    max_count = 0\n    for i in range(R - 1):\n        for j in range(S - 1):\n            submatrix = [row[j:j + 2] for row in matrix[i:i + 2]]\n            if is_cool(submatrix):\n                max_count = max(max_count, count_cool_submatrices(submatrix))\n\n    return str(max_count)"
    },
    {
        "number": 3096,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_set(jokes, supervisors, person):\n        if person not in jokes:\n            return True\n        for supervisor in supervisors[person]:\n            if not is_valid_set(jokes, supervisors, supervisor):\n                return False\n        return True\n\n    def count_valid_sets(jokes, supervisors):\n        count = 0\n        for person in jokes:\n            if is_valid_set(jokes, supervisors, person):\n                count += 1\n        return count\n\n    def parse_input(stdin):\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        jokes = [int(x) for x in lines[1].split()]\n        supervisors = {}\n        for line in lines[2:]:\n            if not line:\n                continue\n            a, b = map(int, line.split())\n            if a not in supervisors:\n                supervisors[a] = set()\n            if b not in supervisors:\n                supervisors[b] = set()\n            supervisors[a].add(b)\n        return n, jokes, supervisors\n\n    n, jokes, supervisors = parse_input(stdin)\n    return str(count_valid_sets(jokes, supervisors))"
    },
    {
        "number": 3097,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin.split('\\n')[0])\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[1:Q+1]]\n    results = []\n    \n    for query in queries:\n        A, B = query\n        count = 0\n        for i in range(1, B+1):\n            count += i\n        results.append(count)\n    \n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 3098,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    vertices = []\n    for _ in range(n):\n        x, y = map(float, stdin.readline().split())\n        vertices.append((x, y))\n\n    def area(vertices):\n        n = len(vertices)\n        area = 0\n        for i in range(n):\n            x1, y1 = vertices[i]\n            x2, y2 = vertices[(i + 1) % n]\n            area += x1 * y2 - x2 * y1\n        return abs(area) / 2\n\n    def expected_area(vertices, k):\n        n = len(vertices)\n        total_area = area(vertices)\n        expected_area = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for l in range(j + 1, n):\n                    if k == 3:\n                        expected_area += area([vertices[i], vertices[j], vertices[l]])\n                    else:\n                        for m in range(l + 1, n):\n                            if k == 4:\n                                expected_area += area([vertices[i], vertices[j], vertices[l], vertices[m]])\n                            else:\n                                for p in range(m + 1, n):\n                                    if k == 5:\n                                        expected_area += area([vertices[i], vertices[j], vertices[l], vertices[m], vertices[p]])\n                                    else:\n                                        for q in range(p + 1, n):\n                                            expected_area += area([vertices[i], vertices[j], vertices[l], vertices[m], vertices[p], vertices[q]])\n        return expected_area / (n * (n - 1) * (n - 2) * (n - 3))\n\n    return str(expected_area(vertices, k))"
    },
    {
        "number": 3099,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    S, E, C = map(int, lines[0].split())\n    connections = {i: set() for i in range(S)}\n    for i in range(1, C+1):\n        S1, S2 = map(int, lines[i].split())\n        connections[S1].add(S2)\n        connections[S2].add(S1)\n    enemies = set(map(int, lines[C+1].split()))\n\n    def dfs(spy: int, visited: set) -> set:\n        visited.add(spy)\n        for neighbor in connections[spy]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n        return visited\n\n    visited = set()\n    for spy in range(S):\n        if spy not in enemies:\n            visited |= dfs(spy, set())\n\n    return str(len(visited))"
    },
    {
        "number": 3100,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_ways(A, C, M):\n        if A == 0 and C == 0 and M == 0:\n            return 1\n        if A < 0 or C < 0 or M < 0:\n            return 0\n\n        return (count_ways(A - 1, C, M) + count_ways(A, C - 1, M) + count_ways(A, C, M - 1)) % MOD\n\n    return str(count_ways(A, C, M))"
    },
    {
        "number": 3101,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    numbers = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        for j in range(1, 10):\n            if numbers[i] % 10 != j:\n                new_number = numbers[i] // 10 * 10 + j\n                if new_number not in numbers:\n                    numbers[i] = new_number\n                    return \" \".join(map(str, numbers))\n\n    return \"impossible\""
    },
    {
        "number": 3102,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = 0\n\n    for i in range(L, R + 1):\n        if '4' not in str(i) and (str(i).count('6') + str(i).count('8')) % 2 == (len(str(i)) - str(i).count('4')) % 2:\n            count += 1\n\n    return str((count % (10**9 + 7)) - (count % (10**9 + 7)) % 10**9)"
    },
    {
        "number": 3103,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split()[0].split())\n    map_rows = stdin.split('\\n')[1:]\n    map_matrix = [list(row) for row in map_rows]\n\n    def get_neighbors(x: int, y: int) -> List[Tuple[int, int]]:\n        neighbors = []\n        if x > 0 and map_matrix[y][x - 1] != '#':\n            neighbors.append((x - 1, y))\n        if x < X - 1 and map_matrix[y][x + 1] != '#':\n            neighbors.append((x + 1, y))\n        if y > 0 and map_matrix[y - 1][x] != '#':\n            neighbors.append((x, y - 1))\n        if y < Y - 1 and map_matrix[y + 1][x] != '#':\n            neighbors.append((x, y + 1))\n        return neighbors\n\n    def get_paths(x: int, y: int, visited: Set[Tuple[int, int]]) -> int:\n        if x == X - 1 and y == Y - 1:\n            return 1\n        paths = 0\n        for neighbor in get_neighbors(x, y):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                paths += get_paths(neighbor[0], neighbor[1], visited)\n                visited.remove(neighbor)\n        return paths\n\n    visited = set()\n    paths = get_paths(x_init, Y - 1, visited)\n    return paths % 1000003"
    },
    {
        "number": 3104,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.split(\"=\")\n    A = int(A)\n    S = int(S)\n\n    # Convert A to a list of digits\n    A_list = [int(digit) for digit in str(A)]\n\n    # Initialize a list to store the operations\n    operations = []\n\n    # Iterate through the list of digits\n    for i in range(len(A_list)):\n        # Check if the current digit is less than the next digit\n        if i < len(A_list) - 1 and A_list[i] < A_list[i + 1]:\n            # Add the current digit and the next digit to the sum\n            A_list[i] += A_list[i + 1]\n            # Remove the next digit from the list\n            A_list.pop(i + 1)\n            # Add the operation to the list\n            operations.append(f\"+{A_list[i]}\")\n\n    # Convert the list of digits back to an integer\n    A = int(\"\".join(str(digit) for digit in A_list))\n\n    # Check if the sum of the operations is equal to the correct value\n    if A == S:\n        # Return the corrected equation\n        return f\"{A}={S}\"\n    else:\n        # Return an error message\n        return \"No solution found\""
    },
    {
        "number": 3105,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    S = [int(line) for line in lines[1:]]\n\n    for i in range(N - 3):\n        for j in range(i + 1, N - 2):\n            if S[i] == S[j] and S[i + 1] == S[j + 2] and S[i + 2] == S[j + 1]:\n                return f\"{S[i]} {S[j]}\"\n\n    return \"-1\""
    },
    {
        "number": 3106,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(c) for c in stdin]\n    n = len(lights)\n    dp = [0] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + lights[i - 1]\n\n    for i in range(1, n + 1):\n        dp[i] = max(dp[i], dp[i - 1])\n\n    return str(dp[n])"
    },
    {
        "number": 3107,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_encounters(truck1, truck2):\n        truck1_positions = set()\n        truck2_positions = set()\n        for i, city in enumerate(truck1):\n            if i > 0:\n                truck1_positions.add(truck1[i - 1])\n                truck1_positions.add(truck1[i])\n        for i, city in enumerate(truck2):\n            if i > 0:\n                truck2_positions.add(truck2[i - 1])\n                truck2_positions.add(truck2[i])\n        return len(truck1_positions.intersection(truck2_positions))\n\n    def parse_route(route_str):\n        route = [int(x) for x in route_str.split()]\n        return route[1:], route[0]\n\n    stdin_lines = stdin.split('\\n')\n    N, M = [int(x) for x in stdin_lines[0].split()]\n    routes = []\n    for i in range(1, N + 1):\n        route_str = stdin_lines[i]\n        route, _ = parse_route(route_str)\n        routes.append(route)\n\n    pairs = []\n    for i in range(N, N + M):\n        pair = [int(x) for x in stdin_lines[i].split()]\n        pairs.append(pair)\n\n    encounters = []\n    for pair in pairs:\n        truck1 = routes[pair[0] - 1]\n        truck2 = routes[pair[1] - 1]\n        encounters.append(get_encounters(truck1, truck2))\n\n    return '\\n'.join([str(x) for x in encounters])"
    },
    {
        "number": 3108,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    max_avg = -float('inf')\n    for i in range(N - K + 1):\n        subseq = a[i:i+K]\n        avg = sum(subseq) / K\n        max_avg = max(max_avg, avg)\n    return f\"{max_avg:.6f}\""
    },
    {
        "number": 3109,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        n, m, w, h = map(int, input().split())\n        v = list(map(float, input().split()))\n        x = list(map(float, input().split()))\n        min_sand = []\n        max_sand = []\n        for _ in range(n):\n            min_sand.append(list(map(float, input().split())))\n            max_sand.append(list(map(float, input().split())))\n        return n, m, w, h, v, x, min_sand, max_sand\n\n    def calculate_heights(n, m, w, h, v, x, min_sand, max_sand):\n        heights = [0] * n\n        for i in range(n):\n            for j in range(m):\n                min_sand_i = min_sand[i][j]\n                max_sand_i = max_sand[i][j]\n                if min_sand_i > max_sand_i:\n                    min_sand_i, max_sand_i = max_sand_i, min_sand_i\n                if i == 0:\n                    heights[i] += min_sand_i\n                else:\n                    heights[i] += max(min_sand_i, heights[i - 1])\n        return heights\n\n    def calculate_min_difference(heights):\n        return round(max(heights) - min(heights), 3)\n\n    n, m, w, h, v, x, min_sand, max_sand = read_input()\n    heights = calculate_heights(n, m, w, h, v, x, min_sand, max_sand)\n    min_difference = calculate_min_difference(heights)\n    return str(min_difference)"
    },
    {
        "number": 3110,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_code(code: List[List[int]]) -> bool:\n        m, n = len(code), len(code[0])\n        for i in range(m):\n            if len(set(code[i])) != n:\n                return False\n        for j in range(n):\n            if len(set([row[j] for row in code])) != m:\n                return False\n        return True\n\n    def count_complete_codes(partial_code: List[List[int]]) -> int:\n        m, n = len(partial_code), len(partial_code[0])\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if partial_code[i][j] == 0:\n                    for digit in range(1, 10):\n                        partial_code[i][j] = digit\n                        if is_valid_code(partial_code):\n                            count += 1\n                    partial_code[i][j] = 0\n        return count\n\n    lines = stdin.split(\"\\n\")\n    m, n = map(int, lines[0].split())\n    partial_code = [[int(x) for x in line.split()] for line in lines[1:]]\n    return str(count_complete_codes(partial_code))"
    },
    {
        "number": 3111,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    dials = list(map(int, stdin.split()[2:]))\n    sums = []\n\n    for _ in range(M):\n        A, B = map(int, input().split())\n        sum = 0\n        for i in range(A, B + 1):\n            sum += dials[i - 1]\n        sums.append(sum)\n        for i in range(A, B + 1):\n            dials[i - 1] = (dials[i - 1] + 1) % 10\n\n    return \"\\n\".join(map(str, sums))"
    },
    {
        "number": 3112,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[3:]]\n\n    def dfs(node: int, visited: set, path: list) -> bool:\n        if node == N:\n            return True\n        visited.add(node)\n        path.append(node)\n        for neighbor in [e[1] for e in edges if e[0] == node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, path):\n                    return True\n        path.pop()\n        visited.remove(node)\n        return False\n\n    max_producers = 0\n    for i in range(1, K + 1):\n        visited = set()\n        path = []\n        if dfs(i, visited, path):\n            max_producers += 1\n\n    return str(max_producers)"
    },
    {
        "number": 3113,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_same_triangle(triangle1, triangle2):\n        return (triangle1[0], triangle1[1], triangle1[2], triangle1[3], triangle1[4], triangle1[5]) == (triangle2[0], triangle2[1], triangle2[2], triangle2[3], triangle2[4], triangle2[5])\n\n    def is_same_cloud_cover(triangles1, triangles2):\n        if len(triangles1) != len(triangles2):\n            return False\n\n        for triangle1 in triangles1:\n            found = False\n            for triangle2 in triangles2:\n                if is_same_triangle(triangle1, triangle2):\n                    found = True\n                    break\n            if not found:\n                return False\n        return True\n\n    def read_triangles(n):\n        triangles = []\n        for _ in range(n):\n            x1, y1, x2, y2, x3, y3 = map(int, input().split())\n            triangles.append((x1, y1, x2, y2, x3, y3))\n        return triangles\n\n    n, m = map(int, input().split())\n    triangles1 = read_triangles(n)\n    triangles2 = read_triangles(m)\n\n    if is_same_cloud_cover(triangles1, triangles2):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3114,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        line1 = input().split()\n        N, M = int(line1[0]), int(line1[1])\n        roads = []\n        for _ in range(M):\n            line = input().split()\n            roads.append((int(line[0]), int(line[1])))\n        return N, M, roads\n\n    def is_possible(N, M, roads):\n        visited = [False] * (N + 1)\n        def dfs(city):\n            visited[city] = True\n            for x, y in roads:\n                if x == city:\n                    if not visited[y]:\n                        dfs(y)\n                elif y == city:\n                    if not visited[x]:\n                        dfs(x)\n            return visited\n\n        return dfs(1)\n\n    N, M, roads = read_input()\n    if is_possible(N, M, roads):\n        result = \"YES\\n\"\n        for x, y in roads:\n            result += f\"{x} {y}\\n\"\n        return result\n    else:\n        return \"NO\""
    },
    {
        "number": 3115,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    reported_matches = [list(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def check_consistency(match: list) -> bool:\n        winner, loser = match[0], match[2]\n        if match[1] == '=':\n            return winner == loser\n        else:\n            return winner > loser\n\n    consistent = all(check_consistency(match) for match in reported_matches)\n    return \"consistent\" if consistent else \"inconsistent\""
    },
    {
        "number": 3116,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 + (p1[2] - p2[2])**2)\n\n    def volume_cylinder(p1, p2, p3):\n        a = distance(p1, p2)\n        b = distance(p1, p3)\n        c = distance(p2, p3)\n        s = (a + b + c) / 2\n        return 4 * math.pi * math.sqrt(s * (s - a) * (s - b) * (s - c))\n\n    n = int(stdin.readline().strip())\n    stars = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.readline().strip().split())\n        stars.append((x, y, z))\n\n    min_volume = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                min_volume = min(min_volume, volume_cylinder(stars[i], stars[j], stars[k]))\n\n    return format(min_volume, '.6f')"
    },
    {
        "number": 3117,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    word_count = {}\n    max_length = 0\n\n    for word in words:\n        if word in word_count:\n            word_count[word] += 1\n        else:\n            word_count[word] = 1\n\n        max_length = max(max_length, len(word))\n\n    for word in words:\n        if word_count[word] > 1 and len(word) == max_length:\n            return str(max_length)\n\n    return \"0\""
    },
    {
        "number": 3118,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = stdin.split('\\n')\n    n = int(n)\n    a = list(map(int, a.split()))\n    b = list(map(int, b.split()))\n\n    def shuffle(deck: list, shuffle_list: list) -> list:\n        return [deck[i - 1] for i in shuffle_list]\n\n    deck = list(range(1, n + 1))\n    shuffles = 0\n\n    while deck != sorted(deck):\n        deck = shuffle(deck, a)\n        deck = shuffle(deck, b)\n        shuffles += 1\n\n        if shuffles > 10**12:\n            return \"huge\"\n\n    return str(shuffles)"
    },
    {
        "number": 3119,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, notes, phrases = parse_input(stdin)\n    max_score = 0\n    \n    for phrase in phrases:\n        start, end = phrase\n        phrase_score = 0\n        for note in notes:\n            if start <= note <= end:\n                if note == start or note == end:\n                    phrase_score += 2\n                else:\n                    phrase_score += 1\n        max_score = max(max_score, phrase_score)\n    \n    return str(max_score)\n\ndef"
    },
    {
        "number": 3120,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import random\n\n    def shuffle(expr: str) -> str:\n        lst = eval(expr)\n        random.shuffle(lst)\n        return str(lst)\n\n    def sorted(expr: str) -> str:\n        lst = eval(expr)\n        lst.sort()\n        return str(lst)\n\n    def concat(expr1: str, expr2: str) -> str:\n        lst1 = eval(expr1)\n        lst2 = eval(expr2)\n        return str(lst1 + lst2)\n\n    def is_equivalent(program1: str, program2: str) -> bool:\n        for lst in range(1, 10**9):\n            lst1 = str(lst)\n            lst2 = str(lst)\n            if eval(program1) != eval(program2):\n                return False\n        return True\n\n    program1, program2 = stdin.splitlines()\n    program1 = program1.replace(\"concat\", \"concatenate\")\n    program2 = program2.replace(\"concat\", \"concatenate\")\n\n    program1 = program1.replace(\"shuffle\", shuffle)\n    program2 = program2.replace(\"shuffle\", shuffle)\n\n    program1 = program1.replace(\"sorted\", sorted)\n    program2 = program2.replace(\"sorted\", sorted)\n\n    return \"equal\" if is_equivalent(program1, program2) else \"not equal\""
    },
    {
        "number": 3121,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    attack_points, health_points = map(int, stdin.readline().split())\n    num_areas, num_passages = map(int, stdin.readline().split())\n    passages = []\n\n    for _ in range(num_passages):\n        enemy_start, enemy_end, enemy_attack, enemy_health = map(int, stdin.readline().split())\n        passages.append((enemy_start, enemy_end, enemy_attack, enemy_health))\n\n    # TODO: Implement the solution\n    return \"Oh no\""
    },
    {
        "number": 3122,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    routes = [list(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    lounges = 0\n    airport_lounges = [0] * (n + 1)\n\n    for route in routes:\n        a, b, c = route\n        if c == 0:\n            continue\n        if c == 1:\n            airport_lounges[a] += 1\n            airport_lounges[b] += 1\n        else:\n            airport_lounges[a] += 1\n            airport_lounges[b] += 1\n            lounges += 1\n\n    for i in range(1, n + 1):\n        if airport_lounges[i] > 1:\n            return \"impossible\"\n\n    return str(lounges)"
    },
    {
        "number": 3123,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    k = 1\n    while k <= n:\n        if all(a[i] == k for i in range(n)):\n            return str(k)\n        k += 1\n    return \"no quotation\""
    },
    {
        "number": 3124,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, numbers = stdin.split('\\n')\n    N = int(N)\n    numbers = list(map(int, numbers.split()))\n\n    def is_odd(num: int) -> bool:\n        return num % 2 != 0\n\n    def count_odd_numbers(numbers: List[int], start: int, end: int) -> int:\n        count = 0\n        for i in range(start, end + 1):\n            count += is_odd(numbers[i])\n        return count\n\n    def find_first_moves(numbers: List[int]) -> int:\n        first_moves = []\n        for i in range(N):\n            if i == 0:\n                first_moves.append(i)\n            elif i == N - 1:\n                first_moves.append(i - 1)\n            elif numbers[i] % 2 == 0:\n                if numbers[i - 1] % 2 != 0 and numbers[i + 1] % 2 != 0:\n                    first_moves.append(i - 1)\n                    first_moves.append(i + 1)\n                elif numbers[i - 1] % 2 != 0:\n                    first_moves.append(i - 1)\n                elif numbers[i + 1] % 2 != 0:\n                    first_moves.append(i + 1)\n        return len(first_moves)\n\n    first_moves = find_first_moves(numbers)\n    odd_count = count_odd_numbers(numbers, 0, N - 1)\n\n    if odd_count % 2 == 0:\n        return str(first_moves)\n    else:\n        return str(first_moves - 1)"
    },
    {
        "number": 3125,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split('\\n')\n    input_str = input_str.replace('+', '+')\n    input_str = input_str.replace('-', '-')\n    output_str = output_str.replace('+', '+')\n    output_str = output_str.replace('-', '-')\n\n    if input_str == output_str:\n        return '<empty>'\n\n    if input_str.replace('+', '').replace('-', '') == output_str.replace('+', '').replace('-', ''):\n        return '<any>'\n\n    for i in range(len(input_str)):\n        if input_str[i] == '+':\n            if i == 0:\n                if output_str[i] == '-':\n                    return '-' + output_str[i+1:]\n                else:\n                    return '<corrupted>'\n            elif i == len(input_str) - 1:\n                if output_str[i-1] == '-':\n                    return output_str[:i-1] + '-'\n                else:\n                    return '<corrupted>'\n            else:\n                if output_str[i-1] == '-' and output_str[i+1] == '+':\n                    return output_str[:i-1] + '-' + output_str[i+1:]\n                else:\n                    return '<corrupted>'\n        elif input_str[i] == '-':\n            if i == 0:\n                if output_str[i] == '+':\n                    return '+' + output_str[i+1:]\n                else:\n                    return '<corrupted>'\n            elif i == len(input_str) - 1:\n                if output_str[i-1] == '+':\n                    return output_str[:i-1] + '+'\n                else:\n                    return '<corrupted>'\n            else:\n                if output_str[i-1] == '+' and output_str[i+1] == '-':\n                    return output_str[:i-1] + '+' + output_str[i+1:]\n                else:\n                    return '<corrupted>'\n\n    return '<corrupted>'"
    },
    {
        "number": 3126,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    positions = list(map(int, stdin.split()))\n    changes = int(stdin.split()[0])\n    stdin = stdin.split('\\n', 1)[1]\n\n    def get_jumps(positions: List[int], tower_pos: int) -> int:\n        jumps = 0\n        for pos in positions:\n            jumps += abs(pos - tower_pos)\n        return jumps\n\n    def get_new_positions(positions: List[int], change: str) -> List[int]:\n        new_positions = positions.copy()\n        if change[0] == '+':\n            new_positions.append(int(change[2:]))\n        elif change[0] == '-':\n            new_positions.remove(int(change[2:]))\n        return new_positions\n\n    tower_positions = [t]\n    jumps = [get_jumps(positions, t)]\n    for _ in range(changes):\n        change = stdin.split()[0]\n        stdin = stdin.split('\\n', 1)[1]\n        if change[0] == 't':\n            tower_positions.append(int(change[2:]))\n            jumps.append(get_jumps(positions, int(change[2:])))\n        else:\n            positions = get_new_positions(positions, change)\n            jumps.append(get_jumps(positions, tower_positions[-1]))\n\n    return '\\n'.join(map(str, jumps))"
    },
    {
        "number": 3127,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    cables = []\n    for line in stdin.split('\\n')[2:]:\n        a, b, l = map(int, line.split())\n        cables.append((a, b, l))\n\n    unused_switches = set()\n    for switch in range(1, n + 1):\n        if not any(cable[0] == switch or cable[1] == switch for cable in cables):\n            unused_switches.add(switch)\n\n    return f\"{len(unused_switches)}\\n{' '.join(map(str, sorted(unused_switches)))}\""
    },
    {
        "number": 3128,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split('\\n')\n    n = int(queries[0])\n    creation_order = [0] * (n + 1)\n    plot_order = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        creation_order[i] = int(queries[i])\n\n    for i in range(1, n + 1):\n        plot_order[creation_order[i]] = i\n\n    for i in range(1, n + 1):\n        if int(queries[i]) == 1:\n            print(plot_order[int(queries[i + n])])"
    },
    {
        "number": 3129,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    count = 0\n    i = 0\n    while i < n:\n        if s[i] == 'P':\n            count += 1\n            i += 1\n        else:\n            if i+2 < n and s[i+2] == 'P':\n                s[i:i+3] = sorted(s[i:i+3])\n                count += 1\n                i += 3\n            else:\n                i += 1\n    return str(count)"
    },
    {
        "number": 3130,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.split()[:3])\n    implications = [tuple(map(int, line.split())) for line in stdin.split('\\n')[3:-1]]\n    known_events = [int(line) for line in stdin.split('\\n')[-N:]]\n\n    def find_causes(event: int, causes: set) -> set:\n        new_causes = set()\n        for cause, effect in implications:\n            if effect == event and cause not in causes:\n                new_causes.add(cause)\n                new_causes.update(find_causes(cause, causes | new_causes))\n        return new_causes\n\n    causes = set()\n    for event in known_events:\n        causes.update(find_causes(event, causes))\n\n    return ' '.join(map(str, sorted(causes | set(known_events))))"
    },
    {
        "number": 3131,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    max_value = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                if a[i] + a[j] + a[k] > max_value:\n                    max_value = a[i] + a[j] + a[k]\n    return str(max_value % 1000000007)"
    },
    {
        "number": 3132,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def find_building(grid, start_row, start_col, size):\n        for row in range(start_row, start_row + size):\n            for col in range(start_col, start_col + size):\n                if grid[row][col] == 'x':\n                    return True\n        return False\n\n    for size in range(1, min(R, C) + 1):\n        for start_row in range(R - size + 1):\n            for start_col in range(C - size + 1):\n                if find_building(grid, start_row, start_col, size):\n                    return f\"{start_row + 1} {start_col + 1} {size}\""
    },
    {
        "number": 3133,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B = map(int, stdin.split()[:3])\n    intersections = [list(map(int, line.split())) for line in stdin.split('\\n')[3:]]\n\n    def dfs(start: int, visited: set, turns: int) -> int:\n        if start == A:\n            return turns\n        if start == B:\n            return -1\n        if start in visited:\n            return float('inf')\n        visited.add(start)\n        left_turn = dfs(intersections[start][0], visited, turns + 1)\n        right_turn = dfs(intersections[start][1], visited, turns + 1)\n        return min(left_turn, right_turn)\n\n    result = dfs(A, set(), 0)\n    if result == -1:\n        return \"indistinguishable\"\n    elif result == float('inf'):\n        return \"impossible\"\n    else:\n        return str(result)"
    },
    {
        "number": 3134,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    row_parities, col_parities = stdin.splitlines()\n    row_parities = [int(x) for x in row_parities]\n    col_parities = [int(x) for x in col_parities]\n\n    n = len(row_parities)\n    m = len(col_parities)\n\n    # Check if the number of 1's in each row and column is even\n    if any(sum(row_parities) % 2 == 1) or any(sum(col_parities) % 2 == 1):\n        return \"-1\"\n\n    # Create the matrix with the most 1's possible\n    matrix = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            if row_parities[i] == col_parities[j]:\n                row.append(\"1\")\n            else:\n                row.append(\"0\")\n        matrix.append(row)\n\n    # Check if the matrix has the smallest binary value when starting with row 1\n    min_binary_value = float(\"inf\")\n    min_matrix = None\n    for permutation in itertools.permutations(matrix):\n        binary_value = 0\n        for i in range(n):\n            row = permutation[i]\n            binary_value += int(\"\".join(row), 2)\n        if binary_value < min_binary_value:\n            min_binary_value = binary_value\n            min_matrix = permutation\n\n    if min_matrix is None:\n        return \"-1\"\n\n    # Convert the matrix to a string\n    result = \"\"\n    for row in min_matrix:\n        result += \"\".join(row) + \"\\n\"\n    return result.strip()"
    },
    {
        "number": 3135,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    binary_representation = []\n    while n > 0:\n        if n % 3 == 0:\n            binary_representation.append('0')\n        elif n % 3 == 1:\n            binary_representation.append('+')\n        else:\n            binary_representation.append('-')\n        n //= 3\n    return ''.join(binary_representation[::-1])\n\ndef"
    },
    {
        "number": 3136,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.readline().split())\n    a, b = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    y = list(map(int, stdin.readline().split()))\n    roads = []\n    for _ in range(m):\n        u, v, d = map(int, stdin.readline().split())\n        roads.append((u, v, d))\n\n    # Calculate the shortest distance between each pair of intersections\n    distances = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        distances[i][i] = 0\n    for u, v, d in roads:\n        distances[u][v] = d\n        distances[v][u] = d\n\n    for k in range(1, n + 1):\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j])\n\n    # Calculate the minimum total distance\n    min_distance = float('inf')\n    for i in range(s):\n        for j in range(t):\n            min_distance = min(min_distance, distances[x[i]][a] + distances[x[i]][y[j]] + distances[b][y[j]])\n\n    return str(min_distance)"
    },
    {
        "number": 3137,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, X, Y = map(int, stdin.split()[:5])\n    bacteria = []\n    for i in range(K):\n        Xi, Yi, C = stdin.split()[5 + i*N*M:5 + (i+1)*N*M].split()\n        Xi, Yi = int(Xi), int(Yi)\n        bacteria.append((Xi, Yi, C))\n\n    def is_valid(x, y):\n        return 1 <= x <= N and 1 <= y <= M\n\n    def get_next_cell(x, y, direction):\n        if direction == 'U':\n            return x-1, y\n        elif direction == 'R':\n            return x, y+1\n        elif direction == 'D':\n            return x+1, y\n        else:\n            return x, y-1\n\n    def get_next_direction(direction, x, y, next_x, next_y):\n        if direction == 'U':\n            return 'R' if next_x == x else 'D'\n        elif direction == 'R':\n            return 'D' if next_y == y else 'L'\n        elif direction == 'D':\n            return 'L' if next_x == x else 'U'\n        else:\n            return 'U' if next_y == y else 'R'\n\n    def get_next_position(x, y, direction):\n        next_x, next_y = get_next_cell(x, y, direction)\n        if not is_valid(next_x, next_y):\n            next_x, next_y = x, y\n        return next_x, next_y\n\n    def get_next_direction_and_position(x, y, direction, matrix):\n        next_x, next_y = get_next_position(x, y, direction)\n        next_direction = get_next_direction(direction, x, y, next_x, next_y)\n        return next_direction, next_x, next_y\n\n    def get_number(x, y, matrix):\n        return int(matrix[x-1][y-1])\n\n    def simulate_bacteria(bacterium, matrix):\n        x, y, direction = bacterium\n        steps = 0\n        while True:\n            number = get_number(x, y, matrix)\n            direction = get_next_direction(direction, x, y, x, y)\n            for _ in range(number):\n                direction = get_next_direction(direction, x, y, x, y)\n            x, y = get_next_position(x, y, direction)\n            steps += 1\n            if x == X and y == Y:\n                return steps\n\n    total_steps = 0\n    for bacterium in bacteria:\n        total_steps += simulate_bacteria(bacterium, matrix)\n\n    return str(total_steps)"
    },
    {
        "number": 3138,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n    count = 0\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if sum(numbers[i:j + 1]) == reduce(lambda x, y: x * y, numbers[i:j + 1]):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3139,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    students = []\n    queries = []\n    for line in stdin.split('\\n'):\n        if line.startswith('D'):\n            a, b = map(int, line.split()[1:])\n            students.append((a, b))\n        elif line.startswith('P'):\n            queries.append(int(line.split()[1]))\n\n    students.sort(key=lambda x: (x[0], x[1]))\n    queries.sort(key=lambda x: students[x-1][0])\n\n    result = []\n    for query in queries:\n        for i in range(len(students)):\n            if students[i][0] >= students[query-1][0] and students[i][1] >= students[query-1][1]:\n                result.append(i+1)\n                break\n        else:\n            result.append(\"NE\")\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3140,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l, x0, y0 = map(int, stdin.split()[:6])\n    times = [list(map(int, input().split())) for _ in range(r)]\n\n    def is_valid(x: int, y: int, t: int) -> bool:\n        return 0 <= x < r and 0 <= y < c and times[x][y] <= t < times[x][y] + k\n\n    def dfs(x: int, y: int, t: int) -> int:\n        if not is_valid(x, y, t):\n            return 0\n        if t == l:\n            return 1\n        result = 0\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            result += dfs(x + dx, y + dy, t + 1)\n        return result\n\n    return str(dfs(x0, y0, 1))"
    },
    {
        "number": 3141,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    flaws = []\n    N = int(stdin.split('\\n')[0])\n    for i in range(1, N+1):\n        x, y, z = map(float, stdin.split('\\n')[i].split())\n        flaws.append((x, y, z))\n\n    diameter = 0\n    for i in range(len(flaws)):\n        for j in range(i+1, len(flaws)):\n            x1, y1, z1 = flaws[i]\n            x2, y2, z2 = flaws[j]\n            diameter = max(diameter, ((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)**0.5)\n\n    return f\"{diameter:.4f}\""
    },
    {
        "number": 3142,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    min_num = float('inf')\n\n    for num in range(A, B + 1):\n        digit_sum = sum(int(digit) for digit in str(num))\n        if digit_sum == S:\n            count += 1\n            min_num = min(min_num, num)\n\n    return f\"{count}\\n{min_num}\""
    },
    {
        "number": 3143,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    names = list(map(int, stdin.split()[2:2+M]))\n    line = list(map(int, stdin.split()[2+M:]))\n\n    # Create a dictionary to store the position of each student in the line\n    position = {}\n    for i, name in enumerate(line):\n        position[name] = i\n\n    # Sort the names in the list in descending order\n    names.sort(reverse=True)\n\n    # Initialize the result list\n    result = []\n\n    # Iterate through the sorted names\n    for name in names:\n        # Find the position of the current student in the line\n        current_position = position[name]\n\n        # Calculate the number of steps needed to reach the front of the line\n        steps = current_position\n\n        # Calculate the position where the student should go\n        new_position = (current_position + steps) % N\n\n        # Update the position of the student in the line\n        position[name] = new_position\n\n        # Add the new position to the result list\n        result.append(new_position + 1)\n\n    # Calculate the number of inspections needed\n    K = len(names)\n\n    return str(K) + \"\\n\" + \" \".join(map(str, result))"
    },
    {
        "number": 3144,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    M = min(d, g)\n    return str(M)"
    },
    {
        "number": 3145,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B, allowed_digits = stdin.split()\n    X, A, B = int(X), int(A), int(B)\n    allowed_digits = set(allowed_digits)\n\n    def is_valid(number: int) -> bool:\n        digits = set(str(number))\n        return digits.issubset(allowed_digits)\n\n    def count_multiples(X: int, A: int, B: int) -> int:\n        count = 0\n        for i in range(A, B + 1):\n            if i % X == 0 and is_valid(i):\n                count += 1\n        return count\n\n    return str(count_multiples(X, A, B))"
    },
    {
        "number": 3146,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    prescriptions = []\n    for line in stdin.split('\\n')[2:]:\n        if line:\n            d, p_type, k = line.split()\n            prescriptions.append((int(d), p_type, int(k)))\n    \n    in_store_prescriptions = [p for p in prescriptions if p[1] == 'S']\n    remote_prescriptions = [p for p in prescriptions if p[1] == 'R']\n    \n    in_store_completion_times = []\n    remote_completion_times = []\n    \n    technicians = [0] * t\n    technicians_working = 0\n    \n    for prescription in sorted(prescriptions, key=lambda x: (x[0], x[2], x[1])):\n        if prescription[1] == 'S' and technicians_working < t:\n            technicians[technicians_working] = prescription[2]\n            technicians_working += 1\n        elif prescription[1] == 'R' and technicians_working < t:\n            technicians[technicians_working] = prescription[2]\n            technicians_working += 1\n        else:\n            continue\n        \n        technicians_working -= 1\n        completion_time = sum(technicians[:t-technicians_working])\n        \n        if prescription[1] == 'S':\n            in_store_completion_times.append(completion_time)\n        else:\n            remote_completion_times.append(completion_time)\n    \n    if not in_store_completion_times:\n        in_store_completion_time = 0\n    else:\n        in_store_completion_time = sum(in_store_completion_times) / len(in_store_completion_times)\n    \n    if not remote_completion_times:\n        remote_completion_time = 0\n    else:\n        remote_completion_time = sum(remote_completion_times) / len(remote_completion_times)\n    \n    return f\"{in_store_completion_time:.6f} {remote_completion_time:.6f}\""
    },
    {
        "number": 3147,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    memory = [list(line.strip()) for line in stdin.split('\\n')[2:]]\n\n    def is_killer(matrix: List[List[str]]) -> bool:\n        if len(matrix) != len(matrix[0]):\n            return False\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] != matrix[len(matrix) - i - 1][j]:\n                    return False\n        return True\n\n    def rotate_matrix(matrix: List[List[str]]) -> List[List[str]]:\n        return [list(row) for row in zip(*matrix[::-1])]\n\n    max_killer_size = -1\n    for i in range(R):\n        for j in range(C):\n            for k in range(min(R - i, C - j) + 1):\n                submatrix = [row[j:j + k] for row in memory[i:i + k]]\n                if is_killer(submatrix):\n                    max_killer_size = max(max_killer_size, k)\n                submatrix = rotate_matrix(submatrix)\n                if is_killer(submatrix):\n                    max_killer_size = max(max_killer_size, k)\n\n    return str(max_killer_size)"
    },
    {
        "number": 3148,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    swimmers = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    swimmers.sort(key=lambda x: (x[0], x[1]))\n    n = len(swimmers)\n    swimmers_x = [swimmer[0] for swimmer in swimmers]\n    swimmers_y = [swimmer[1] for swimmer in swimmers]\n\n    def find_closest_swimmer(swimmers_x, swimmers_y, x, y):\n        min_distance = float('inf')\n        closest_swimmer = None\n        for i in range(len(swimmers_x)):\n            distance = (swimmers_x[i] - x) ** 2 + (swimmers_y[i] - y) ** 2\n            if distance < min_distance:\n                min_distance = distance\n                closest_swimmer = i\n        return closest_swimmer\n\n    def find_second_closest_swimmer(swimmers_x, swimmers_y, x, y):\n        min_distance = float('inf')\n        second_closest_swimmer = None\n        for i in range(len(swimmers_x)):\n            distance = (swimmers_x[i] - x) ** 2 + (swimmers_y[i] - y) ** 2\n            if distance < min_distance and i != find_closest_swimmer(swimmers_x, swimmers_y, x, y):\n                min_distance = distance\n                second_closest_swimmer = i\n        return second_closest_swimmer\n\n    x1 = swimmers_x[find_closest_swimmer(swimmers_x, swimmers_y, 0, 0)]\n    y1 = swimmers_y[find_closest_swimmer(swimmers_x, swimmers_y, 0, 0)]\n    x2 = swimmers_x[find_second_closest_swimmer(swimmers_x, swimmers_y, x1, y1)]\n    y2 = swimmers_y[find_second_closest_swimmer(swimmers_x, swimmers_y, x1, y1)]\n\n    return f\"{x1} {y1}\\n{x2} {y2}\""
    },
    {
        "number": 3149,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(x, y, angle):\n        return x * cos(angle) - y * sin(angle), x * sin(angle) + y * cos(angle)\n\n    def parabola(t):\n        return (-9.81 / 2) * t ** 2\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def time_to_hit(x1, y1, x2, y2, v0, omega):\n        return (2 * (y2 - y1) / (9.81 * (x2 - x1))) + (v0 / omega) * atan((y2 - y1) / (x2 - x1))\n\n    def corner_hit_time(x1, y1, x2, y2, v0, omega, w):\n        x1, y1 = rotate(x1, y1, radians(theta))\n        x2, y2 = rotate(x2, y2, radians(theta))\n        t1 = time_to_hit(0, parabola(0), x1, y1, v0, omega)\n        t2 = time_to_hit(0, parabola(0), x2, y2, v0, omega)\n        return min(t1, t2), max(t1, t2)\n\n    def main():\n        n, omega, v0, theta, w = map(float, stdin.readline().split())\n        corners = []\n        for _ in range(n):\n            corners.append(tuple(map(float, stdin.readline().split())))\n\n        min_time = float('inf')\n        min_corner = -1\n        for i in range(n):\n            x1, y1 = corners[i]\n            x2, y2 = corners[(i + 1) % n]\n            t1, t2 = corner_hit_time(x1, y1, x2, y2, v0, omega, w)\n            if t1 < min_time:\n                min_time = t1\n                min_corner = i + 1\n\n        return min_corner, min_time\n\n    return f\"{main()[0]:.0f} {main()[1]:.3f}\""
    },
    {
        "number": 3150,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_visible(guard1, guard2):\n        x1, y1 = guard1\n        x2, y2 = guard2\n        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= 2\n\n    def place_guards(trenches):\n        guards = []\n        for trench in trenches:\n            x1, y1, x2, y2 = trench\n            if (x1, y1) not in guards and (x2, y2) not in guards:\n                guards.append((x1, y1))\n                guards.append((x2, y2))\n        return guards\n\n    def count_ways(guards):\n        count = 0\n        for i in range(len(guards)):\n            for j in range(i + 1, len(guards)):\n                if is_visible(guards[i], guards[j]):\n                    count += 1\n        return count\n\n    trenches = []\n    for line in stdin.split('\\n')[1:]:\n        x1, y1, x2, y2 = map(int, line.split())\n        trenches.append((x1, y1, x2, y2))\n\n    guards = place_guards(trenches)\n    return str(count_ways(guards))"
    },
    {
        "number": 3151,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            k = n // i\n            m = i + k\n            if m**2 - k**2 == n:\n                return f\"{m} {k}\"\n    return \"impossible\""
    },
    {
        "number": 3152,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_max_length(arr: List[int]) -> int:\n        return min(arr) * max(arr) * len(arr)\n\n    def subsequence_prices(arr: List[int]) -> int:\n        prices = []\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr) + 1):\n                prices.append(min_max_length(arr[i:j]))\n        return sum(prices) % (10**9)\n\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    arr = [int(x) for x in input_lines[1:]]\n\n    result = subsequence_prices(arr)\n    return str(result)"
    },
    {
        "number": 3153,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    cards = list(map(int, stdin.split()[2:]))\n    purchases = []\n    for _ in range(M):\n        a, b = map(int, stdin.split()[2:])\n        purchases.append((a, b))\n        stdin = stdin[stdin.find(\"\\n\")+1:]\n    \n    def purchase(a, b):\n        cards[a-1] -= 1\n        cards[b-1] -= 1\n        return (a, b)\n    \n    def race(a, b):\n        if cards[a-1] > cards[b-1]:\n            return (a, b, 2)\n        elif cards[a-1] < cards[b-1]:\n            return (a, b, 0)\n        else:\n            return (a, b, 1)\n    \n    result = []\n    for a, b in purchases:\n        result.append(purchase(a, b))\n        result.append(race(a, b))\n    \n    return str(len(result)) + \"\\n\" + \"\\n\".join(map(lambda x: \" \".join(map(str, x)), result))"
    },
    {
        "number": 3154,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    d, e = map(int, stdin.split()[2:])\n    events = []\n    for _ in range(e):\n        s, k, t = map(int, stdin.split()[:3])\n        events.append((s, k, t))\n        stdin = stdin[stdin.find('\\n') + 1:]\n\n    def is_envious(kid1, kid2, toy):\n        for event in events:\n            if event[1] == kid1 and event[2] == toy:\n                return False\n            if event[1] == kid2 and event[2] == toy:\n                return True\n        return False\n\n    def is_inflexible(kid, toy):\n        for event in events:\n            if event[1] == kid and event[2] == toy:\n                return True\n        return False\n\n    def is_multitasking(kid, toy):\n        for event in events:\n            if event[1] == kid and event[2] != 0 and event[2] != toy:\n                return True\n        return False\n\n    def is_cooperative(kid1, kid2, toy):\n        for event in events:\n            if event[1] == kid1 and event[2] == toy:\n                return True\n            if event[1] == kid2 and event[2] == toy:\n                return True\n        return False\n\n    def is_crying(kid, toy):\n        for event in events:\n            if event[1] == kid and event[2] == toy:\n                return False\n        return True\n\n    def find_toy(kid):\n        for toy in range(1, m + 1):\n            if not is_envious(kid, kid, toy) and not is_inflexible(kid, toy) and not is_multitasking(kid, toy) and not is_cooperative(kid, kid, toy):\n                return toy\n        return None\n\n    toys = [find_toy(kid) for kid in range(1, n + 1)]\n\n    if any(toy is None for toy in toys):\n        return \"impossible\"\n\n    return \" \".join(map(str, toys))"
    },
    {
        "number": 3155,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 0\n    k = 0\n    while True:\n        n += 1\n        for i in range(n + 1):\n            if nCk(n, i) == X:\n                k = i\n                break\n        if k != 0:\n            break\n    return f\"{n} {k}\"\n\ndef"
    },
    {
        "number": 3156,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    lines = stdin.splitlines()\n    n_stores = int(lines[0])\n    store_items = {}\n    for i in range(1, n_stores + 1):\n        store_items[i] = lines[i].split()\n\n    n_items = int(lines[n_stores + 1])\n    bought_items = lines[n_stores + 2:]\n\n    # Check if there is a path that matches the description\n    for i in range(n_stores):\n        for item in bought_items:\n            if item not in store_items[i]:\n                return \"impossible\"\n\n    # Check if there is a unique path that matches the description\n    visited = [False] * n_stores\n    def dfs(start, path):\n        if len(path) == n_items:\n            return True\n        for i in range(n_stores):\n            if not visited[i] and i not in path:\n                for item in bought_items:\n                    if item in store_items[i]:\n                        visited[i] = True\n                        if dfs(i, path + [i]):\n                            return True\n                        visited[i] = False\n        return False\n\n    if dfs(0, [0]):\n        return \"unique\"\n    else:\n        return \"ambiguous\""
    },
    {
        "number": 3157,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    mod = 2**M\n    result = 0\n\n    for i in range(N+1):\n        result += pow(33, i, mod)\n\n    result = (result * pow(33, N, mod)) % mod\n    result = (result * pow(33, N-1, mod)) % mod\n    result = (result * pow(33, N-2, mod)) % mod\n\n    for i in range(26):\n        result += pow(33, N-1, mod) * pow(33, N-2, mod) * pow(33, N-3, mod) * (i+1) * pow(33, 0, mod)\n        result %= mod\n\n    return str(result)"
    },
    {
        "number": 3158,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_grip(image: str) -> tuple:\n        grip = []\n        for i in range(len(image)):\n            if image[i] == 'X':\n                grip.append((i // 15, i % 15))\n        return tuple(grip)\n\n    def get_touch_vector(grip_point: tuple, touch_point: tuple) -> tuple:\n        return (touch_point[0] - grip_point[0], touch_point[1] - grip_point[1])\n\n    def get_grip_rotation(grip: tuple) -> float:\n        touch_vectors = [get_touch_vector(grip[0], touch) for touch in grip]\n        angles = [math.atan2(vector[1], vector[0]) for vector in touch_vectors]\n        return sum(angles) / len(angles)\n\n    def get_grip_spread(grip: tuple) -> float:\n        grip_point = (sum(point[0] for point in grip) / len(grip), sum(point[1] for point in grip) / len(grip))\n        return sum(math.sqrt((point[0] - grip_point[0]) ** 2 + (point[1] - grip_point[1]) ** 2) for point in grip) / len(grip)\n\n    def get_distance(grip1: tuple, grip2: tuple) -> float:\n        grip1_point = (sum(point[0] for point in grip1) / len(grip1), sum(point[1] for point in grip1) / len(grip1))\n        grip2_point = (sum(point[0] for point in grip2) / len(grip2), sum(point[1] for point in grip2) / len(grip2))\n        return math.sqrt((grip1_point[0] - grip2_point[0]) ** 2 + (grip1_point[1] - grip2_point[1]) ** 2)\n\n    def get_pan_distance(grip1: tuple, grip2: tuple) -> float:\n        return get_distance(grip1, grip2)\n\n    def get_zoom_distance(grip1: tuple, grip2: tuple) -> float:\n        spread1 = get_grip_spread(grip1)\n        spread2 = get_grip_spread(grip2)\n        return abs(spread1 - spread2)\n\n    def get_rotate_distance(grip1: tuple, grip2: tuple) -> float:\n        rotation1 = get_grip_rotation(grip1)\n        rotation2 = get_grip_rotation(grip2)\n        return abs(rotation1 - rotation2)\n\n    def classify_gesture(grip1: tuple, grip2: tuple) -> str:\n        pan_distance = get_pan_distance(grip1, grip2)\n        zoom_distance = get_zoom_distance(grip1, grip2)\n        rotate_distance = get_rotate_distance(grip1, grip2)\n\n        if pan_distance > zoom_distance and pan_distance > rotate_distance:\n            return \"pan\"\n        elif zoom_distance > rotate_distance:\n            return \"zoom\"\n        else:\n            return \"rotate\"\n\n    image1, image2 = stdin.split(\"  \")\n    grip1 = get_grip(image1)\n    grip2 = get_grip(image2)\n    gesture = classify_gesture(grip1, grip2)\n    num_touches = len(grip1)\n\n    if gesture == \"zoom\":\n        spread1 = get_grip_spread(grip1)\n        spread2 = get_grip_spread(grip2)\n        direction = \"out\" if spread1 < spread2 else \"in\"\n        return f\"{num_touches} zoom {direction}\"\n    elif gesture == \"rotate\":\n        rotation1 = get_grip_rotation(grip1)\n        rotation2 = get_grip_rotation(grip2)\n        direction = \"clock"
    },
    {
        "number": 3159,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_char(char: str) -> bool:\n        return char.isalnum() or char in \"?!,. \"\n\n    def is_valid_image(image: List[str]) -> bool:\n        for row in image:\n            if not all(is_valid_char(char) for char in row):\n                return False\n        return True\n\n    def remove_image(image: List[str], x: int, y: int) -> None:\n        for i in range(y, y + 3):\n            for j in range(x, x + 3):\n                image[i][j] = \" \"\n\n    def remove_smallest_image(image: List[str], x: int, y: int) -> None:\n        smallest_image = None\n        smallest_image_pixel_count = float(\"inf\")\n\n        for i in range(y, y + 3):\n            for j in range(x, x + 3):\n                if image[i][j] == \"+\":\n                    sub_image = [image[k][l] for k in range(i, i + 3) for l in range(j, j + 3)]\n                    pixel_count = sum(row.count(\"+\") for row in sub_image)\n\n                    if pixel_count < smallest_image_pixel_count:\n                        smallest_image = sub_image\n                        smallest_image_pixel_count = pixel_count\n\n        if smallest_image is not None:\n            remove_image(image, x, y)\n\n    def process_image(image: List[str], x: int, y: int) -> None:\n        if not is_valid_image(image):\n            remove_smallest_image(image, x, y)\n        else:\n            remove_image(image, x, y)\n\n    def process_web_page(web_page: List[str]) -> List[str]:\n        for i in range(len(web_page)):\n            for j in range(len(web_page[i])):\n                if web_page[i][j] == \"+\":\n                    image = [web_page[k][l] for k in range(i, i + 3) for l in range(j, j + 3)]\n                    process_image(image, j, i)\n\n        return [\"\".join(row) for row in web_page]\n\n    H, W = map(int, stdin.split()[:2])\n    web_page = [list(stdin.split()[i][:W]) for i in range(2, H + 2)]\n\n    return \"\".join(process_web_page(web_page)) "
    },
    {
        "number": 3160,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_operations(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            if s[i] == 'H':\n                count += 1\n            else:\n                break\n        return count\n\n    def average_operations(s: str) -> float:\n        total_operations = 0\n        total_configurations = 0\n        for i in range(len(s)):\n            if s[i] == '?':\n                for j in range(2):\n                    new_s = s[:i] + ('H' if j == 0 else 'T') + s[i+1:]\n                    total_operations += count_operations(new_s)\n                    total_configurations += 1\n            else:\n                total_operations += count_operations(s)\n                total_configurations += 1\n                break\n        return total_operations / total_configurations\n\n    return str(average_operations(stdin))"
    },
    {
        "number": 3161,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def paint(picture: List[List[int]]) -> int:\n        if len(picture) == 1:\n            return 0\n        else:\n            white_count = 0\n            black_count = 0\n            for i in range(len(picture)):\n                for j in range(len(picture)):\n                    if i % 2 == 0 and j % 2 == 0:\n                        white_count += picture[i][j]\n                    elif i % 2 == 1 and j % 2 == 1:\n                        white_count += picture[i][j]\n                    else:\n                        black_count += picture[i][j]\n            if white_count > black_count:\n                picture[0][0] = 1\n                picture[0][1] = 1\n                picture[1][0] = 1\n                picture[1][1] = 1\n            else:\n                picture[0][0] = 1\n                picture[0][1] = 0\n                picture[1][0] = 1\n                picture[1][1] = 0\n            for i in range(len(picture)):\n                for j in range(len(picture)):\n                    if i % 2 == 0 and j % 2 == 0:\n                        picture[i][j] = 1 - picture[i][j]\n            for i in range(len(picture) // 2):\n                for j in range(len(picture) // 2):\n                    picture[i][j], picture[i][j + len(picture) // 2] = picture[i][j + len(picture) // 2], picture[i][j]\n                    picture[i + len(picture) // 2][j], picture[i + len(picture) // 2][j + len(picture) // 2] = picture[i + len(picture) // 2][j + len(picture) // 2], picture[i + len(picture) // 2][j]\n            return paint(picture) + 1\n\n    n = int(stdin.readline())\n    target_picture = []\n    for i in range(n):\n        target_picture.append([int(x) for x in stdin.readline()])\n    initial_picture = [[0] * n for _ in range(n)]\n    return str(paint(initial_picture)) + \"\\n\" + \"\\n\".join([\"\".join([str(x) for x in row]) for row in initial_picture])"
    },
    {
        "number": 3162,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_pixel_activation_time(pulse: List[str]) -> int:\n        direction, start_time, length, wire_number = pulse\n        if direction == 'h':\n            return start_time + length\n        else:\n            return start_time + length + 1\n\n    def get_pixel_activation_status(pulse1: List[str], pulse2: List[str]) -> bool:\n        direction1, start_time1, length1, wire_number1 = pulse1\n        direction2, start_time2, length2, wire_number2 = pulse2\n\n        if direction1 == 'h' and direction2 == 'v':\n            return start_time1 <= start_time2 <= start_time1 + length1\n        elif direction1 == 'v' and direction2 == 'h':\n            return start_time2 <= start_time1 <= start_time2 + length2\n        else:\n            return False\n\n    def get_pixel_activation_count(pulses: List[List[str]]) -> int:\n        pixel_activation_times = [get_pixel_activation_time(pulse) for pulse in pulses]\n        pixel_activation_count = 0\n\n        for i in range(len(pulses)):\n            for j in range(i + 1, len(pulses)):\n                if get_pixel_activation_status(pulses[i], pulses[j]):\n                    pixel_activation_count += 1\n\n        return pixel_activation_count\n\n    n = int(stdin.readline())\n    pulses = []\n\n    for _ in range(n):\n        direction, start_time, length, wire_number = stdin.readline().split()\n        pulses.append([direction, int(start_time), int(length), int(wire_number)])\n\n    return str(get_pixel_activation_count(pulses))"
    },
    {
        "number": 3163,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0].split())\n    shelves = [list(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    wanted_shelves = [list(map(int, line.split())) for line in stdin.split('\\n')[N+1:2*N+1]]\n\n    def is_valid(shelf: list) -> bool:\n        for i in range(len(shelf)):\n            if shelf[i] != 0 and shelf[i] != i + 1:\n                return False\n        return True\n\n    def move_book(shelf: list, from_index: int, to_index: int) -> None:\n        shelf[to_index] = shelf[from_index]\n        shelf[from_index] = 0\n\n    def move_books(shelf: list, from_index: int, to_index: int, count: int) -> None:\n        for i in range(count):\n            move_book(shelf, from_index, to_index + i)\n\n    def find_empty_place(shelf: list) -> int:\n        for i in range(len(shelf)):\n            if shelf[i] == 0:\n                return i\n        return -1\n\n    def find_book(shelf: list, book_id: int) -> int:\n        for i in range(len(shelf)):\n            if shelf[i] == book_id:\n                return i\n        return -1\n\n    def find_book_to_move(shelf: list, book_id: int) -> int:\n        for i in range(len(shelf)):\n            if shelf[i] != 0 and shelf[i] != book_id:\n                return i\n        return -1\n\n    def find_book_to_move_from_other_shelf(shelves: list, book_id: int) -> tuple:\n        for i in range(len(shelves)):\n            for j in range(len(shelves[i])):\n                if shelves[i][j] != 0 and shelves[i][j] != book_id:\n                    return i, j\n        return -1, -1\n\n    def move_book_to_empty_place(shelf: list, book_id: int) -> None:\n        empty_place = find_empty_place(shelf)\n        if empty_place != -1:\n            move_book(shelf, find_book(shelf, book_id), empty_place)\n\n    def move_book_to_right(shelf: list, book_id: int) -> None:\n        move_book(shelf, find_book(shelf, book_id), find_book(shelf, book_id) + 1)\n\n    def move_book_to_left(shelf: list, book_id: int) -> None:\n        move_book(shelf, find_book(shelf, book_id), find_book(shelf, book_id) - 1)\n\n    def move_book_to_other_shelf(shelves: list, shelf_index: int, book_id: int) -> None:\n        other_shelf_index, other_book_index = find_book_to_move_from_other_shelf(shelves, book_id)\n        if other_shelf_index != -1:\n            move_book(shelves[other_shelf_index], other_book_index, shelf_index)\n\n    def arrange_books(shelves: list) -> int:\n        lifting = 0\n        for i in range(len(shelves)):\n            for j in range(len(shelves[i])):\n                if shelves[i][j] != 0 and not is_valid(shelves[i]):\n                    book_id = shelves[i][j]\n                    book_to_move_index = find_book_to_move(shelves[i], book_id)\n                    if book_to_move_index != -1:\n                        move_book_to_other_shelf(shelves, i"
    },
    {
        "number": 3164,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    \n    # Create a dictionary to store the frequency of each element in the array\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    # Initialize variables to store the longest consecutive sub-array and its length\n    longest_subarray = []\n    longest_length = 0\n    \n    # Iterate through the array and check if each element appears exactly twice\n    for num in arr:\n        if freq[num] == 2:\n            # If the element appears exactly twice, check if it is the start of a consecutive sub-array\n            if num - 1 not in freq or freq[num - 1] < 2:\n                current_subarray = [num]\n                current_length = 1\n                \n                # Iterate through the rest of the array to find the longest consecutive sub-array\n                for next_num in arr[arr.index(num) + 1:]:\n                    if next_num - 1 in freq and freq[next_num - 1] >= 2:\n                        current_subarray.append(next_num)\n                        current_length += 1\n                        freq[next_num - 1] -= 2\n                    else:\n                        break\n                \n                # Update the longest consecutive sub-array and its length if the current sub-array is longer\n                if current_length > longest_length:\n                    longest_subarray = current_subarray\n                    longest_length = current_length\n    \n    return str(longest_length)"
    },
    {
        "number": 3165,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def is_attacked(board: List[List[int]], row: int, col: int) -> bool:\n        rook_powers = [board[i][col] for i in range(N) if i != row]\n        rook_powers.extend([board[row][i] for i in range(N) if i != col])\n        return sum(rook_powers) > 0\n\n    def move_rook(board: List[List[int]], row_from: int, col_from: int, row_to: int, col_to: int) -> None:\n        board[row_from][col_from] = 0\n        board[row_to][col_to] = 1\n\n    N, K, P = map(int, stdin.readline().split())\n    board = [[0] * N for _ in range(N)]\n    rooks = []\n\n    for _ in range(K):\n        row, col, power = map(int, stdin.readline().split())\n        board[row - 1][col - 1] = power\n        rooks.append((row - 1, col - 1))\n\n    for _ in range(P):\n        row_from, col_from, row_to, col_to = map(int, stdin.readline().split())\n        move_rook(board, row_from - 1, col_from - 1, row_to - 1, col_to - 1)\n        attacked_fields = sum(is_attacked(board, row, col) for row, col in rooks)\n        print(attacked_fields)"
    },
    {
        "number": 3166,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    matrix = [list(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n    disqualified_players = list(map(int, stdin.split('\\n')[-1].split()))\n\n    def is_fair_ranking(matrix: List[List[int]]) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] == 1 and matrix[j][i] == 0:\n                    return False\n        return True\n\n    def find_smallest_disqualified_set(matrix: List[List[int]], disqualified_players: List[int]) -> int:\n        for i in range(2**(n - k)):\n            binary_representation = bin(i)[2:].zfill(n - k)\n            new_disqualified_players = [j for j in range(n) if binary_representation[j] == '1']\n            new_matrix = [[matrix[i][j] for j in range(n) if j not in new_disqualified_players] for i in range(n) if i not in new_disqualified_players]\n            if is_fair_ranking(new_matrix):\n                return len(new_disqualified_players)\n        return \"impossible\"\n\n    return str(find_smallest_disqualified_set(matrix, disqualified_players))"
    },
    {
        "number": 3167,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    X = list(map(int, stdin.split()[2:2+K]))\n    Q = int(stdin.split()[-1])\n    seq = [0] * N\n    \n    for jump in X:\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += jump\n    \n    output = []\n    for _ in range(Q):\n        L, R = map(int, stdin.split()[-2*Q+2*i:])\n        output.append(sum(seq[L:R+1]))\n    \n    return \"\\n\".join(map(str, output))"
    },
    {
        "number": 3168,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = stdin.split('\\n')[1:]\n    tree = {}\n    depth = 0\n    result = []\n\n    def insert(node, value):\n        nonlocal depth\n        if not node:\n            node = {'value': value, 'left': None, 'right': None}\n            depth += 1\n        elif value < node['value']:\n            insert(node['left'], value)\n        else:\n            insert(node['right'], value)\n\n    insert(tree, sequence[0])\n    result.append(depth)\n\n    for i in range(1, n):\n        depth = 0\n        insert(tree, sequence[i])\n        result.append(depth)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3169,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sticks = []\n    for line in stdin.split('\\n')[1:]:\n        x1, y1, x2, y2 = map(int, line.split())\n        sticks.append((x1, y1, x2, y2))\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def shortest_path(x1, y1, x2, y2):\n        if x1 == x2:\n            return (x1, y1), (x2, y2)\n        elif y1 == y2:\n            return (x1, y1), (x2, y2)\n        else:\n            if x1 < x2:\n                return (x1, y1), (x2, y2)\n            else:\n                return (x2, y2), (x1, y1)\n\n    def is_valid_move(x1, y1, x2, y2, x3, y3):\n        if x1 == x3 and y1 == y3:\n            return False\n        if x2 == x3 and y2 == y3:\n            return False\n        if x1 == x2 and y1 == y2:\n            return False\n        if x1 == x3 and y1 == y3:\n            return False\n        if x2 == x3 and y2 == y3:\n            return False\n        return True\n\n    def sort_sticks(sticks):\n        sorted_sticks = []\n        for i, stick in enumerate(sticks):\n            x1, y1, x2, y2 = stick\n            min_distance = float('inf')\n            min_stick = None\n            for j, other_stick in enumerate(sticks):\n                if i == j:\n                    continue\n                ox1, oy1, ox2, oy2 = other_stick\n                if is_valid_move(x1, y1, x2, y2, ox1, oy1) or is_valid_move(x1, y1, x2, y2, ox2, oy2):\n                    d = distance(x1, y1, ox1, oy1) + distance(ox1, oy1, ox2, oy2)\n                    if d < min_distance:\n                        min_distance = d\n                        min_stick = j\n            sorted_sticks.append((min_stick, i))\n        return [x[1] for x in sorted(sorted_sticks, key=lambda x: x[0])]\n\n    return ' '.join(map(str, sort_sticks(sticks)))"
    },
    {
        "number": 3170,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    deck = list(stdin)\n    theta_cards = deck[:10]\n    friend_cards = deck[10:20]\n    discard_pile = []\n    theta_slots = {1: None, 2: None, 3: None, 4: None, 5: None}\n    friend_slots = {1: None, 2: None, 3: None, 4: None, 5: None}\n\n    def can_place_card(slot: int, card: str) -> bool:\n        if slot == 1 and card in ['A', 'J', 'Q', 'K']:\n            return True\n        if slot == 2 and card in ['2', '3', '4', '5']:\n            return True\n        if slot == 3 and card in ['6', '7', '8', '9']:\n            return True\n        if slot == 4 and card in ['T', 'J', 'Q', 'K']:\n            return True\n        if slot == 5 and card in ['A', '2', '3', '4', '5']:\n            return True\n        return False\n\n    def place_card(player: str, slot: int, card: str) -> None:\n        if player == 'theta':\n            theta_slots[slot] = card\n        else:\n            friend_slots[slot] = card\n\n    def can_use_jack(card: str) -> bool:\n        return card in ['A', 'J', 'Q', 'K', '2', '3', '4', '5']\n\n    def find_lowest_slot(player: str) -> int:\n        if player == 'theta':\n            slots = theta_slots\n        else:\n            slots = friend_slots\n        for i in range(1, 6):\n            if slots[i] is None:\n                return i\n        return 6\n\n    def theta_turn(card: str) -> None:\n        if card in theta_cards:\n            theta_cards.remove(card)\n            if can_place_card(find_lowest_slot('theta'), card):\n                place_card('theta', find_lowest_slot('theta'), card)\n            else:\n                discard_pile.append(card)\n        else:\n            discard_pile.append(card)\n\n    def friend_turn(card: str) -> None:\n        if card in friend_cards:\n            friend_cards.remove(card)\n            if can_place_card(find_lowest_slot('friend'), card):\n                place_card('friend', find_lowest_slot('friend'), card)\n            else:\n                discard_pile.append(card)\n        else:\n            discard_pile.append(card)\n\n    while len(theta_cards) > 0 and len(friend_cards) > 0:\n        theta_turn(deck.pop())\n        friend_turn(deck.pop())\n\n    if all(theta_slots.values()):\n        return \"Theta wins\"\n    else:\n        return \"Theta loses\""
    },
    {
        "number": 3171,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    candidates = [0] * N\n    for i in range(K):\n        speaker, statement = stdin.split()[2*i:2*(i+1)]\n        speaker = int(speaker)\n        if statement.startswith(\"truther\"):\n            candidates[speaker-1] |= 1\n        elif statement.startswith(\"fabulist\"):\n            candidates[speaker-1] |= 2\n        elif statement.startswith(\"charlatan\"):\n            candidates[speaker-1] |= 4\n        elif statement.startswith(\"not\"):\n            if statement.endswith(\"truther\"):\n                candidates[speaker-1] &= 5\n            elif statement.endswith(\"fabulist\"):\n                candidates[speaker-1] &= 6\n            elif statement.endswith(\"charlatan\"):\n                candidates[speaker-1] &= 3\n        elif statement.startswith(\"and\"):\n            if statement.endswith(\"truther\"):\n                candidates[speaker-1] &= 1\n            elif statement.endswith(\"fabulist\"):\n                candidates[speaker-1] &= 2\n            elif statement.endswith(\"charlatan\"):\n                candidates[speaker-1] &= 4\n        elif statement.startswith(\"xor\"):\n            if statement.endswith(\"truther\"):\n                candidates[speaker-1] ^= 1\n            elif statement.endswith(\"fabulist\"):\n                candidates[speaker-1] ^= 2\n            elif statement.endswith(\"charlatan\"):\n                candidates[speaker-1] ^= 4\n    result = []\n    for i in range(N):\n        if candidates[i] == 1:\n            result.append(\"truther\")\n        elif candidates[i] == 2:\n            result.append(\"fabulist\")\n        elif candidates[i] == 4:\n            result.append(\"charlatan\")\n    return \"\\n\".join(result) "
    },
    {
        "number": 3172,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    fruits = [tuple(map(float, line.split())) for line in stdin.splitlines()[1:]]\n    \n    def is_inside(point, circle):\n        return (point[0] - circle[0])**2 + (point[1] - circle[1])**2 <= 1\n    \n    def get_intersection(line, circle):\n        a, b, c = line\n        x0, y0, r = circle\n        A = a**2 + b**2\n        B = 2*(a*(x0-c) + b*(y0-d))\n        C = (x0-c)**2 + (y0-d)**2 - r**2\n        delta = B**2 - 4*A*C\n        if delta < 0:\n            return None\n        elif delta == 0:\n            x = -B/(2*A)\n            y = a*x + b*c + d\n            return (x, y)\n        else:\n            x1 = (-B + delta**0.5)/(2*A)\n            x2 = (-B - delta**0.5)/(2*A)\n            y1 = a*x1 + b*c + d\n            y2 = a*x2 + b*c + d\n            return (x1, y1), (x2, y2)\n    \n    max_fruits = 0\n    for fruit in fruits:\n        intersections = [get_intersection(line, fruit) for line in [(1, 0, 0), (0, 1, 0), (-1, 0, 0), (0, -1, 0)]]\n        intersections = [i for i in intersections if i is not None]\n        if any(is_inside(i, fruit) for i in intersections):\n            max_fruits += 1\n    \n    return str(max_fruits)"
    },
    {
        "number": 3173,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[:R+1]\n    scores = list(map(int, stdin.split('\\n')[-1].split()))\n    \n    # TODO: Implement the solution for the problem\n    return str(max_score)"
    },
    {
        "number": 3174,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    cities = []\n    for i in range(N):\n        x, y, k = map(int, stdin.split()[2:5])\n        cities.append((x, y, k))\n\n    # Sort cities by their distance to the origin\n    cities.sort(key=lambda x: x[0] ** 2 + x[1] ** 2)\n\n    # Helper function to check if a county is happy\n    def is_county_happy(county: list) -> bool:\n        total_residents = sum(city[2] for city in county)\n        return total_residents % K == 0\n\n    # Helper function to calculate the distance between two points\n    def distance(p1: tuple, p2: tuple) -> float:\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    # Helper function to calculate the total cost of building roads\n    def total_cost(roads: list) -> float:\n        return sum(distance(road[0], road[1]) for road in roads)\n\n    # Helper function to build roads between two cities\n    def build_road(cities: list, city1: tuple, city2: tuple) -> list:\n        roads = []\n        for i in range(len(cities)):\n            if cities[i] == city1 or cities[i] == city2:\n                roads.append((city1, cities[i]))\n                roads.append((cities[i], city2))\n        return roads\n\n    # Helper function to find the minimal D\n    def find_min_D(cities: list) -> float:\n        min_D = 0\n        max_D = distance(cities[0], cities[-1])\n        while min_D <= max_D:\n            mid_D = (min_D + max_D) / 2\n            current_counties = []\n            current_roads = []\n            for i in range(len(cities)):\n                for j in range(i + 1, len(cities)):\n                    if distance(cities[i], cities[j]) <= mid_D:\n                        current_roads.extend(build_road(cities, cities[i], cities[j]))\n                        county = [cities[i], cities[j]]\n                        for k in range(j + 1, len(cities)):\n                            if distance(cities[i], cities[k]) <= mid_D:\n                                county.append(cities[k])\n                                current_roads.extend(build_road(cities, cities[i], cities[k]))\n                        if is_county_happy(county):\n                            current_counties.append(county)\n            if len(current_counties) == 0:\n                max_D = mid_D - 0.001\n            else:\n                min_D = mid_D + 0.001\n        return min_D\n\n    # Main function\n    min_D = find_min_D(cities)\n    return \"{:.3f}\".format(min_D)"
    },
    {
        "number": 3175,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    max_area = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                a, b, c = lengths[i], lengths[j], lengths[k]\n                s = (a + b + c) / 2\n                area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n                if area > max_area:\n                    max_area = area\n    return f\"{max_area:.3f}\""
    },
    {
        "number": 3176,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    plants = []\n    for _ in range(N):\n        x, y, f = map(int, stdin.readline().split())\n        plants.append((x, y, f))\n\n    def is_valid_move(p1, p2):\n        x1, y1 = p1\n        x2, y2 = p2\n        return (x2 > x1 and y2 == y1) or (y2 > y1 and x2 == x1)\n\n    def find_max_energy(start_plant, end_plant, plants):\n        max_energy = 0\n        max_energy_path = []\n        stack = [(start_plant, [start_plant], 0)]\n\n        while stack:\n            current_plant, path, energy = stack.pop()\n            if current_plant == end_plant:\n                if energy > max_energy:\n                    max_energy = energy\n                    max_energy_path = path.copy()\n                continue\n\n            for next_plant in plants:\n                if next_plant not in path and is_valid_move(current_plant, next_plant):\n                    stack.append((next_plant, path + [next_plant], energy + next_plant[2]))\n\n        return max_energy, max_energy_path\n\n    start_plant = (1, 1)\n    end_plant = (N, N)\n    max_energy, max_energy_path = find_max_energy(start_plant, end_plant, plants)\n\n    result = [str(max_energy)]\n    result.append(str(len(max_energy_path)))\n    result.extend([f\"{x} {y}\" for x, y, _ in max_energy_path])\n    return \"\\n\".join(result)"
    },
    {
        "number": 3177,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    permutation = list(map(int, stdin.split()[2:]))\n    swaps = [list(map(int, line.split())) for line in stdin.split('\\n')[2:2+M]]\n\n    def find_cycle(node: int) -> list:\n        cycle = [node]\n        while True:\n            next_node = swaps[permutation.index(node)][1]\n            if next_node in cycle:\n                break\n            cycle.append(next_node)\n            node = next_node\n        return cycle\n\n    cycles = []\n    for i in range(N):\n        if i not in permutation:\n            continue\n        node = i\n        cycle = find_cycle(node)\n        if cycle not in cycles:\n            cycles.append(cycle)\n\n    return str(len(cycles))"
    },
    {
        "number": 3178,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(costs: List[int]) -> bool:\n        for i in range(len(costs)):\n            for j in range(i + 1, len(costs)):\n                if (costs[i] + costs[j]) % 3 == 1:\n                    return False\n        return True\n\n    def sum_is_odd(cycle: List[int]) -> bool:\n        total = 0\n        for i in range(len(cycle)):\n            total += cycle[i]\n        return total % 2 == 1\n\n    def dfs(graph: List[List[int]], visited: List[bool], costs: List[int], current: int, target: int, cycle: List[int]) -> bool:\n        visited[current] = True\n        cycle.append(costs[current])\n\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                if dfs(graph, visited, costs, neighbor, target, cycle):\n                    return True\n            elif neighbor != target:\n                cycle.append(costs[neighbor])\n\n        return False\n\n    def min_cost(graph: List[List[int]], costs: List[int]) -> int:\n        min_cost = 0\n        for i in range(len(costs)):\n            min_cost += min(costs[i], 2 - costs[i])\n\n        return min_cost\n\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    costs = [0] * n\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    for i in range(n):\n        if len(graph[i]) == 1:\n            return -1\n\n    for i in range(n):\n        visited = [False] * n\n        cycle = []\n        if dfs(graph, visited, costs, i, i, cycle):\n            if not is_valid(cycle) or not sum_is_odd(cycle):\n                return -1\n\n    return min_cost(graph, costs)"
    },
    {
        "number": 3179,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    polygon = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        polygon.append((x, y))\n\n    # Calculate the area of the polygon\n    area = 0\n    for i in range(n):\n        j = (i + 1) % n\n        area += polygon[i][0] * polygon[j][1]\n        area -= polygon[j][0] * polygon[i][1]\n    area = abs(area) / 2\n\n    # Calculate the minimum side length for each square map\n    min_side_length = round(pow(area / k, 0.5), 2)\n\n    return str(min_side_length) + \"\\n\""
    },
    {
        "number": 3180,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    commands = stdin.split('\\n')[1:]\n    canvas = [[1] * N for _ in range(N)]\n    saves = []\n    save_count = 0\n    \n    for command in commands:\n        if command.startswith(\"PAINT\"):\n            c, x1, y1, x2, y2 = map(int, command.split()[1:])\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    if (i + j) % 2 == 0:\n                        canvas[i][j] = c\n        elif command.startswith(\"SAVE\"):\n            saves.append(canvas.copy())\n            save_count += 1\n        elif command.startswith(\"LOAD\"):\n            save_index = int(command.split()[1]) - 1\n            if 0 <= save_index < save_count:\n                canvas = saves[save_index].copy()\n    \n    return \"\\n\".join([\" \".join(map(str, row)) for row in canvas])"
    },
    {
        "number": 3181,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1:\n        return \" \".join(map(str, range(1, N + 1)))\n    if K == N:\n        return \" \".join(map(str, range(1, N + 1)))\n    if K > N:\n        return \"-1\"\n\n    def is_valid(seq: List[int]) -> bool:\n        if len(seq) != N:\n            return False\n        for i in range(N - 1):\n            if seq[i] >= seq[i + 1]:\n                return False\n        for i in range(N - 1, 0, -1):\n            if seq[i] <= seq[i - 1]:\n                return False\n        return True\n\n    def next_seq(seq: List[int]) -> List[int]:\n        for i in range(N - 1):\n            if seq[i] < seq[i + 1]:\n                return seq[:i + 1] + [seq[i + 1] - 1] + [seq[i + 1] + 1] * (N - i - 2)\n        return seq[:N - 1] + [seq[N - 1] - 1] + [seq[N - 1] + 1] * (N - 1)\n\n    seq = list(range(1, N + 1))\n    while not is_valid(seq):\n        seq = next_seq(seq)\n    return \" \".join(map(str, seq))"
    },
    {
        "number": 3182,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_right_triangle(a, b, c):\n        return a**2 + b**2 == c**2 or a**2 + c**2 == b**2 or b**2 + c**2 == a**2\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def find_right_triangles(points):\n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    a, b, c = distance(*points[i], *points[j]), distance(*points[i], *points[k]), distance(*points[j], *points[k])\n                    if is_right_triangle(a, b, c):\n                        count += 1\n        return count\n\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    return str(find_right_triangles(points))"
    },
    {
        "number": 3183,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    edges = []\n    for _ in range(m):\n        u, v, c, w = map(int, stdin.split()[4:])\n        edges.append((u, v, c, w))\n    \n    # Your code here\n    # ...\n    # Calculate the maximum flow and minimum cost flow\n    # ...\n    # Return the result as a string\n    return f\"{max_flow} {min_cost}\""
    },
    {
        "number": 3184,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    cameras = []\n    for i in range(k):\n        a, b = map(int, stdin.split()[2:])\n        cameras.append((a, b))\n\n    walls = [False] * (n + 1)\n    for i in range(k):\n        a, b = cameras[i]\n        if a > b:\n            for j in range(a, n + 1):\n                walls[j] = True\n            for j in range(1, b + 1):\n                walls[j] = True\n        else:\n            for j in range(a, b + 1):\n                walls[j] = True\n\n    count = 0\n    for wall in walls:\n        if not wall:\n            count += 1\n\n    return str(count) if count <= n else \"impossible\""
    },
    {
        "number": 3185,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_fact = int(stdin)\n    n = 1\n    while True:\n        if n * (n + 1) > n_fact:\n            return str(n - 1)\n        n += 1"
    },
    {
        "number": 3186,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    mod = 10**6 + 7\n\n    # Calculate the number of ways to choose K objects from N objects\n    result = 1\n    for i in range(K):\n        result = (result * (N - i)) % mod\n\n    # Calculate the number of ways to choose K objects from M copies of each object\n    result = (result * pow(M, K, mod)) % mod\n\n    return str(result)"
    },
    {
        "number": 3187,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split('\\n')[-2:])\n    citizens = [tuple(map(int, line.split())) for line in stdin.split('\\n')[:-2]]\n    \n    def total_distance(x, y):\n        return sum(abs(x - x_i) + abs(y - y_i) for x_i, y_i in citizens)\n    \n    min_distance = float('inf')\n    min_intersection = None\n    \n    for x in range(max(x for x, y in citizens) + 1):\n        for y in range(max(y for x, y in citizens) + 1):\n            if all(abs(x - x_i) + abs(y - y_i) <= d for x_i, y_i in citizens):\n                distance = total_distance(x, y)\n                if distance < min_distance:\n                    min_distance = distance\n                    min_intersection = (x, y)\n                    \n    if min_intersection is None:\n        return \"impossible\"\n    else:\n        return str(min_distance)"
    },
    {
        "number": 3188,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    planets = []\n    for line in stdin.split('\\n')[1:]:\n        x, y, z = map(int, line.split())\n        planets.append((x, y, z))\n\n    def tunnel_cost(a, b):\n        return min(abs(a[0] - b[0]), abs(a[1] - b[1]), abs(a[2] - b[2]))\n\n    min_cost = 0\n    for i in range(len(planets)):\n        for j in range(i + 1, len(planets)):\n            min_cost += tunnel_cost(planets[i], planets[j])\n\n    return str(min_cost)"
    },
    {
        "number": 3189,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    photos = [tuple(map(int, line)) for line in stdin.split('\\n')[2:]]\n    \n    def is_consistent(wiring: tuple) -> bool:\n        for photo in photos:\n            if wiring[photo[0]] != photo[1]:\n                return False\n        return True\n    \n    count = 0\n    for i in range(2**n):\n        wiring = tuple(int(x) for x in format(i, f'0{n}b'))\n        if is_consistent(wiring):\n            count += 1\n    \n    return str(count % 1000003)"
    },
    {
        "number": 3190,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, prices, P = stdin.split('\\n')\n    N = int(N)\n    prices = list(map(int, prices.split()))\n    P = int(P)\n\n    def is_valid_subsequence(prices, start, end):\n        if end - start < 2:\n            return False\n        return sum(prices[start:end]) / (end - start) >= P\n\n    def count_valid_subsequences(prices, start, end):\n        if end - start < 2:\n            return 0\n        count = 0\n        for i in range(start, end - 1):\n            for j in range(i + 1, end):\n                if is_valid_subsequence(prices, i, j):\n                    count += 1\n        return count\n\n    result = 0\n    for i in range(N):\n        result += count_valid_subsequences(prices, i, N)\n\n    return str(result)"
    },
    {
        "number": 3191,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    worst_case_time = min(r, p * n)\n    return str(worst_case_time)"
    },
    {
        "number": 3192,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    files = stdin.split('\\n')[1].split()\n    file_data = {}\n\n    for i in range(n):\n        file_name, k = stdin.split('\\n')[2 + i * (k + 1)].split()\n        k = int(k)\n        imports = stdin.split('\\n')[3 + i * (k + 1): 3 + i * (k + 1) + k]\n        file_data[file_name] = {\"imports\": [import_line.split()[1] for import_line in imports]}\n\n    def find_cycle(file_name, visited, stack):\n        visited.add(file_name)\n        stack.add(file_name)\n\n        for imported_file in file_data[file_name][\"imports\"]:\n            if imported_file not in visited:\n                if find_cycle(imported_file, visited, stack):\n                    return True\n            elif imported_file in stack:\n                return True\n\n        stack.remove(file_name)\n        return False\n\n    for file_name in files:\n        visited = set()\n        stack = set()\n        if find_cycle(file_name, visited, stack):\n            cycle = []\n            for file in files:\n                if file in stack:\n                    cycle.append(file)\n            return \" -> \".join(cycle)\n\n    return \"SHIP IT\""
    },
    {
        "number": 3193,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = stdin.split()\n    P, M = int(P), int(M)\n    \n    def is_valid(x: int) -> bool:\n        A_copy = A.replace('x', str(x))\n        return eval(A_copy) % M == P\n    \n    x = 0\n    while not is_valid(x):\n        x += 1\n    \n    return str(x)"
    },
    {
        "number": 3194,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    times = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    times.sort(key=lambda x: x[1])\n\n    start_time = 0\n    for i in range(n):\n        if start_time + t > times[i][1]:\n            return \"no\"\n        start_time = max(start_time + t, times[i][0])\n\n    return \"yes\""
    },
    {
        "number": 3195,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = map(int, stdin.split()[:3])\n    n = int(stdin.split()[3])\n    observations = []\n    for i in range(n):\n        observations.append(stdin.split()[4 + i])\n    t_q, c_q = map(int, stdin.split()[-2:])\n\n    # Calculate the possible values of T\n    T_values = []\n    for i in range(n):\n        if observations[i][1] == \"green\":\n            T_values.append(t_q - i * (T_g + T_y + T_r))\n        elif observations[i][1] == \"yellow\":\n            T_values.append(t_q - i * (T_g + T_y + T_r) - T_g)\n        else:\n            T_values.append(t_q - i * (T_g + T_y + T_r) - T_g - T_y)\n\n    # Calculate the probability of the lights being green at time t_q\n    probabilities = []\n    for T in T_values:\n        if T <= 0:\n            probabilities.append(0)\n        else:\n            probabilities.append(1 - (t_q - T) / (T_g + T_y + T_r))\n\n    # Calculate the probability of the lights being green at time t_q\n    p = sum(probabilities) / len(probabilities)\n\n    return f\"{p:.3f}\""
    },
    {
        "number": 3196,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    roads = [set() for _ in range(N + 1)]\n    for _ in range(M):\n        A, B = map(int, input().split())\n        roads[A].add(B)\n        roads[B].add(A)\n\n    def dfs(start: int, visited: set) -> int:\n        if start == 2:\n            return 1\n        visited.add(start)\n        count = 0\n        for next_town in roads[start]:\n            if next_town not in visited:\n                count += dfs(next_town, visited)\n        visited.remove(start)\n        return count\n\n    count = dfs(1, set())\n    if count == 0:\n        return \"inf\"\n    return str(count % 1000000000)"
    },
    {
        "number": 3197,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    preferences = list(map(int, stdin.split()[2:]))\n\n    # Create a graph to represent the preferences\n    graph = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        graph[i] = [j for j in range(1, n + 1) if j != i and preferences[i - 1] == j]\n\n    # Find the maximum number of participants that can join\n    def dfs(node: int, visited: set) -> int:\n        if node == 0:\n            return 0\n        if node in visited:\n            return 0\n        visited.add(node)\n        return 1 + sum(dfs(i, visited) for i in graph[node])\n\n    max_participants = 0\n    for i in range(1, n + 1):\n        max_participants = max(max_participants, dfs(i, set()))\n\n    return str(max_participants)"
    },
    {
        "number": 3198,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split('\\n')\n    n = int(words[0])\n    words = words[1:]\n    typos = []\n\n    for word in words:\n        for i in range(len(word)):\n            new_word = word[:i] + word[i+1:]\n            if new_word in words:\n                typos.append(word)\n                break\n\n    if len(typos) == 0:\n        return \"NO TYPOS\"\n    else:\n        return \"\\n\".join(typos)"
    },
    {
        "number": 3199,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure = 0\n    secure = 0\n    super_secure = 0\n\n    for i in range(1, L + 1):\n        for j in range(-A, B + 1):\n            if i == 1 or i == L or j == -A or j == B:\n                insecure += 1\n            elif i == 2 or i == L - 1:\n                secure += 1\n            elif i == 3 or i == L - 2:\n                super_secure += 1\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3200,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    lights = []\n    for i in range(1, n):\n        line = stdin.splitlines()[i].split()\n        t, g, r = int(line[0]), int(line[1]), int(line[2])\n        lights.append((t, g, r))\n\n    def time_to_next_light(time: float, light: tuple) -> float:\n        t, g, r = light\n        if time < t:\n            return t - time\n        elif time < t + g:\n            return 0\n        else:\n            return (t + g + r) - time\n\n    def time_to_reach_end(time: float, lights: list) -> float:\n        total_time = 0\n        for light in lights:\n            total_time += time_to_next_light(time, light)\n            time += time_to_next_light(time, light)\n        return total_time\n\n    return str(time_to_reach_end(0, lights))"
    },
    {
        "number": 3201,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = map(int, stdin.readline().split())\n    A = list(map(int, stdin.readline().split()))\n    s = sorted(set(A))\n    h = [0] * len(s)\n    for i in range(len(s)):\n        h[i] = (s[i] * B ** (len(s) - 1 - i)) % M\n    result = []\n    for i in range(K):\n        result.append(str(h[i // (2 ** (N - 1 - (i % (2 ** (N - 1))).bit_length()))]))\n    return \"\\n\".join(result)"
    },
    {
        "number": 3202,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    colors = list(map(int, stdin.split()[2:]))\n    min_insertions = float('inf')\n    for i in range(len(colors) - K + 1):\n        if colors[i:i+K] == [colors[i]] * K:\n            min_insertions = min(min_insertions, i + K - 1)\n    return str(min_insertions)"
    },
    {
        "number": 3203,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    probabilities = []\n    for i in range(1, n + 1):\n        probabilities.append(list(map(int, lines[i].split())))\n\n    def calculate_probability(assignment):\n        result = 1\n        for i in range(n):\n            result *= probabilities[i][assignment[i]]\n        return result\n\n    max_probability = 0\n    for assignment in itertools.permutations(range(n)):\n        probability = calculate_probability(assignment)\n        max_probability = max(max_probability, probability)\n\n    return f\"{max_probability * 100:.6f}\"\n\nimport sys\nimport itertools\n\nstdin = sys.stdin.read()\nprint(solution(stdin)) "
    },
    {
        "number": 3204,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    boats = []\n    for i in range(1, n+1):\n        boats.append(int(lines[i]))\n\n    time_unavailable = 0\n    current_time = 0\n    boats_waiting = []\n\n    for boat in boats:\n        if current_time < boat - 20:\n            time_unavailable += boat - current_time\n            current_time = boat\n        else:\n            current_time += 20\n            boats_waiting.append(boat)\n\n    for boat in boats_waiting:\n        time_unavailable += 20\n        current_time += 20\n\n    return str(time_unavailable)"
    },
    {
        "number": 3205,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split()[:2])\n    receipts = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # Create a graph where each node represents a person, and each edge represents a transaction\n    graph = [[] for _ in range(M)]\n    for a, b, p in receipts:\n        graph[a].append((b, p))\n        graph[b].append((a, -p))\n\n    # Find the connected components in the graph\n    def dfs(node, visited):\n        visited.add(node)\n        for neighbor, amount in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n\n    visited = set()\n    components = []\n    for i in range(M):\n        if i not in visited:\n            component = set()\n            dfs(i, component)\n            components.append(component)\n            visited.update(component)\n\n    # Calculate the minimum number of transactions needed\n    min_transactions = 0\n    for component in components:\n        total_amount = sum(sum(amount for _, amount in graph[i]) for i in component)\n        min_transactions += total_amount // len(component)\n\n    return str(min_transactions)"
    },
    {
        "number": 3206,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split()[0:2])\n    blocks = list(map(int, stdin.split()[2:2+N]))\n    buildings = list(map(int, stdin.split()[2+N:]))\n\n    def is_valid(blocks, building):\n        return any(sum(blocks[:i]) == building for i in range(1, len(blocks) + 1))\n\n    result = []\n    for building in buildings:\n        if is_valid(blocks, building):\n            valid_blocks = [i for i, block in enumerate(blocks, 1) if sum(blocks[:i]) == building]\n            result.append(f\"{len(valid_blocks)} {' '.join(map(str, valid_blocks))}\")\n        else:\n            result.append(\"-1\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3207,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split()[:3])\n    chameleons = []\n    for i in range(N):\n        d, b, direction = map(int, stdin.split()[3*i:3*(i+1)])\n        chameleons.append((d, b, direction))\n\n    trip_lengths = [0] * K\n    for i in range(N):\n        for j in range(i+1, N):\n            if chameleons[i][0] == chameleons[j][0]:\n                continue\n            elif chameleons[i][0] > chameleons[j][0]:\n                chameleons[i], chameleons[j] = chameleons[j], chameleons[i]\n\n            if chameleons[i][2] == 'D' and chameleons[j][2] == 'L':\n                trip_lengths[chameleons[i][1]] += chameleons[i][0] - chameleons[j][0]\n                chameleons[i] = (chameleons[i][0], (chameleons[i][1] + chameleons[j][1]) % K, 'D')\n            elif chameleons[i][2] == 'L' and chameleons[j][2] == 'D':\n                trip_lengths[chameleons[j][1]] += chameleons[j][0] - chameleons[i][0]\n                chameleons[j] = (chameleons[j][0], (chameleons[i][1] + chameleons[j][1]) % K, 'D')\n            elif chameleons[i][2] == 'D' and chameleons[j][2] == 'D':\n                trip_lengths[chameleons[i][1]] += chameleons[i][0] - chameleons[j][0]\n                trip_lengths[chameleons[j][1]] += chameleons[j][0] - chameleons[i][0]\n                chameleons[i] = (chameleons[i][0], (chameleons[i][1] + chameleons[j][1]) % K, 'D')\n            elif chameleons[i][2] == 'L' and chameleons[j][2] == 'L':\n                trip_lengths[chameleons[i][1]] += chameleons[i][0] - chameleons[j][0]\n                trip_lengths[chameleons[j][1]] += chameleons[j][0] - chameleons[i][0]\n                chameleons[i] = (chameleons[i][0], (chameleons[i][1] + chameleons[j][1]) % K, 'L')\n\n    return '\\n'.join(map(str, trip_lengths))"
    },
    {
        "number": 3208,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.split()\n    known_words = [\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"]\n    decrypted_text = \"\"\n    encrypted_letters = set()\n    encrypted_words = set()\n\n    for word in encrypted_text:\n        decrypted_word = \"\"\n        for letter in word:\n            if letter.isalpha():\n                decrypted_letter = chr(((ord(letter) - ord('a') + 13) % 26) + ord('a'))\n                encrypted_letters.add(letter)\n            else:\n                decrypted_letter = letter\n            decrypted_word += decrypted_letter\n        decrypted_text += decrypted_word + \" \"\n        encrypted_words.add(decrypted_word)\n\n    unique_words = set()\n    for word in known_words:\n        if word in encrypted_words:\n            unique_words.add(word)\n\n    if len(unique_words) == 12 and len(encrypted_letters) == len(unique_words):\n        return decrypted_text.strip()\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3209,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    origin, destination = stdin.split()\n    n = int(input())\n    connections = []\n    for _ in range(n):\n        origin_connection, destination_connection, departure_time, journey_time, delay_probability, max_delay = input().split()\n        connections.append((origin_connection, destination_connection, int(departure_time), int(journey_time), int(delay_probability), int(max_delay)))\n\n    def expected_duration(connection: tuple) -> float:\n        origin_connection, destination_connection, departure_time, journey_time, delay_probability, max_delay = connection\n        delay = (delay_probability / 100) * max_delay\n        return journey_time + delay\n\n    def is_reachable(connection: tuple) -> bool:\n        origin_connection, destination_connection, _, _, _, _ = connection\n        return origin_connection == destination\n\n    def is_valid(connection: tuple) -> bool:\n        origin_connection, destination_connection, _, _, _, _ = connection\n        return origin_connection != destination_connection\n\n    def get_connections(connection: tuple) -> list:\n        origin_connection, destination_connection, _, _, _, _ = connection\n        return [c for c in connections if c[0] == destination_connection]\n\n    def get_min_duration(connections: list) -> float:\n        if not connections:\n            return float('inf')\n        return min(expected_duration(c) for c in connections)\n\n    def get_min_expected_duration(connections: list) -> float:\n        if not connections:\n            return float('inf')\n        return sum(get_min_duration(get_connections(c)) for c in connections)\n\n    reachable_connections = [c for c in connections if is_reachable(c)]\n    valid_connections = [c for c in connections if is_valid(c)]\n\n    if not reachable_connections:\n        return \"IMPOSSIBLE\"\n\n    min_expected_duration = get_min_expected_duration(valid_connections)\n    return min_expected_duration"
    },
    {
        "number": 3210,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    board = stdin.split('\\n')[1:]\n    board = [list(row) for row in board]\n\n    def is_valid_move(board, i, j):\n        if i < 0 or i >= N or j < 0 or j >= N:\n            return False\n        if board[i][j] == '*':\n            return False\n        if i % 2 == 0:\n            if j % 2 == 0:\n                return board[i][j+1] == '.' and board[i+1][j] == '.'\n            else:\n                return board[i][j-1] == '.' and board[i+1][j] == '.'\n        else:\n            if j % 2 == 0:\n                return board[i][j+1] == '.' and board[i-1][j] == '.'\n            else:\n                return board[i][j-1] == '.' and board[i-1][j] == '.'\n\n    def score_move(board, i, j):\n        if i % 2 == 0:\n            if j % 2 == 0:\n                return board[i][j+1] == '.' and board[i+1][j] == '.'\n            else:\n                return board[i][j-1] == '.' and board[i+1][j] == '.'\n        else:\n            if j % 2 == 0:\n                return board[i][j+1] == '.' and board[i-1][j] == '.'\n            else:\n                return board[i][j-1] == '.' and board[i-1][j] == '.'\n\n    def count_moves(board):\n        count = 0\n        for i in range(N):\n            for j in range(N):\n                if is_valid_move(board, i, j):\n                    count += 1\n        return count\n\n    return str(count_moves(board))"
    },
    {
        "number": 3211,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    tellers = [i for i in range(n) if s[i] == '0']\n    votes = [1 if s[i] == '1' else 2 if s[i] == '2' else 0 for i in range(n)]\n\n    if len(tellers) < 2:\n        return \"impossible\"\n\n    swaps = 0\n    for i in range(len(tellers) - 1):\n        if votes[tellers[i]] != votes[tellers[i + 1]]:\n            swaps += 1\n            temp = votes[tellers[i]]\n            votes[tellers[i]] = votes[tellers[i + 1]]\n            votes[tellers[i + 1]] = temp\n\n    if swaps % 2 == 0:\n        return str(swaps)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3212,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    snakes = []\n    for i in range(1, n+1):\n        x, y, d = map(int, lines[i].split())\n        snakes.append((x, y, d))\n\n    def is_safe(x, y, snakes):\n        for snake in snakes:\n            if (snake[0] - x) ** 2 + (snake[1] - y) ** 2 <= snake[2] ** 2:\n                return False\n        return True\n\n    for x in range(1001):\n        for y in range(1001):\n            if is_safe(x, y, snakes):\n                for x2 in range(x+1, 1001):\n                    for y2 in range(y+1, 1001):\n                        if is_safe(x2, y2, snakes):\n                            return f\"Bill enters at ({x / 1000:.2f}, {y / 1000:.2f}) and leaves at ({x2 / 1000:.2f}, {y2 / 1000:.2f}).\"\n\n    return \"Bill will be bitten.\""
    },
    {
        "number": 3213,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split())\n    steps = list(stdin.split()[1])\n    power = 1\n    max_power = 0\n    result = []\n\n    for step in steps:\n        if step == \"+\":\n            power += 1\n        else:\n            power *= 2\n\n        if power % (2 ** S) == 0:\n            max_power = max(max_power, power)\n            result.append(step)\n        else:\n            result.append(\"o\")\n\n    return \"\".join(result)"
    },
    {
        "number": 3214,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    from collections import defaultdict\n\n    def similar_words(word1: str, word2: str) -> bool:\n        if len(word1) != len(word2):\n            return False\n        if word1 == word2:\n            return True\n        count = 0\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                count += 1\n                if count > 1:\n                    return False\n        return True\n\n    def word_core(word: str) -> str:\n        return re.sub(r'[^a-zA-Z]', '', word.lower())\n\n    words = defaultdict(set)\n    for line in stdin.split('\\n'):\n        if line == '***':\n            break\n        for word in line.split():\n            core = word_core(word)\n            words[core].add(word)\n\n    result = []\n    for core, word_set in sorted(words.items()):\n        similar_cores = set()\n        for word in word_set:\n            for other_core in words:\n                if other_core != core and similar_words(word_core(word), other_core):\n                    similar_cores.add(other_core)\n        if similar_cores:\n            result.append(f\"{core}: {' '.join(sorted(similar_cores))}\")\n\n    if not result:\n        result.append(\"***\")\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3215,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, deck = stdin.split('\\n')\n    n = int(n)\n    deck = list(map(int, deck.split()))\n\n    def is_shuffle(deck: list) -> bool:\n        if len(deck) != n:\n            return False\n        for i in range(n):\n            if deck[i] != i + 1:\n                return False\n        return True\n\n    def shuffle(deck: list) -> list:\n        mid = len(deck) // 2\n        return deck[:mid] + deck[mid:]\n\n    shuffles = 0\n    while not is_shuffle(deck):\n        deck = shuffle(deck)\n        shuffles += 1\n\n    return str(shuffles)"
    },
    {
        "number": 3216,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num, repeat = stdin.split()\n    repeat = int(repeat)\n    decimal_part = num[num.index('.') + 1:]\n    repeating_part = decimal_part[:repeat]\n    numerator = int(decimal_part[:repeat + 1])\n    denominator = int(repeating_part)\n    gcd = math.gcd(numerator, denominator)\n    numerator //= gcd\n    denominator //= gcd\n    return f\"{numerator}/{denominator}\""
    },
    {
        "number": 3217,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    defective_cells = []\n    for line in stdin.split('\\n'):\n        if line:\n            x, y, z = map(int, line.split())\n            defective_cells.append((x, y, z))\n\n    panels = set()\n    for cell in defective_cells:\n        for direction in [(0, 0, 1), (0, 1, 0), (1, 0, 0)]:\n            neighbor = tuple(a + b for a, b in zip(cell, direction))\n            if neighbor in defective_cells:\n                continue\n            panels.add(neighbor)\n\n    return str(len(panels))"
    },
    {
        "number": 3218,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    hexagons = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    valid_colorings = 0\n\n    def is_valid_coloring(coloring):\n        for i in range(n):\n            for j in range(n if i % 2 == 0 else n-1):\n                if coloring[i][j] != -1 and coloring[i][j] != sum(1 for k in range(6) if coloring[i-1][j-1+k] == i-1 and coloring[i][j] == k):\n                    return False\n        return True\n\n    def dfs(coloring, i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= n or coloring[i][j] == -1 or visited[i][j]:\n            return\n        visited[i][j] = True\n        for k in range(6):\n            if coloring[i][j] == k:\n                dfs(coloring, i-1, j-1+k, visited)\n        dfs(coloring, i+1, j, visited)\n        dfs(coloring, i-1, j, visited)\n        dfs(coloring, i, j+1, visited)\n        dfs(coloring, i, j-1, visited)\n\n    for i in range(n):\n        for j in range(n if i % 2 == 0 else n-1):\n            coloring = [[-1] * n for _ in range(n)]\n            coloring[i][j] = hexagons[i][j]\n            visited = [[False] * n for _ in range(n)]\n            dfs(coloring, i, j, visited)\n            if is_valid_coloring(coloring):\n                valid_colorings += 1\n\n    return str(valid_colorings)"
    },
    {
        "number": 3219,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    binary_number = int(stdin, 2)\n    count = 0\n    for i in range(1, binary_number + 1):\n        if bin(i).count('2') == bin(binary_number).count('2'):\n            count += 1\n    return str(count % 1000000009)"
    },
    {
        "number": 3220,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, moves = stdin.split('\\n')\n    n = int(n)\n    moves = list(map(int, moves.split()))\n\n    # Check if there is a valid solution\n    for i in range(n):\n        if moves[i] % 2 == 0:\n            return \"no dance\"\n\n    # Calculate the order of the moves\n    order = []\n    for i in range(n):\n        if moves[i] % 2 == 1:\n            order.append(i)\n\n    # Calculate the direction of the moves\n    directions = []\n    for i in range(n):\n        if i % 2 == 0:\n            directions.append(\"L\")\n        else:\n            directions.append(\"R\")\n\n    # Create the output string\n    output = \"\"\n    for i in range(n):\n        output += directions[order.index(i)]\n\n    return output"
    },
    {
        "number": 3221,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = map(int, stdin.split()[:3])\n    roads = []\n    for i in range(M):\n        u, v, c = map(int, stdin.split()[3:])\n        roads.append((u, v, c))\n\n    def dfs(start, visited, candies, energy):\n        if len(visited) == N:\n            return energy\n\n        min_energy = float('inf')\n        for i in range(len(roads)):\n            u, v, c = roads[i]\n            if (u, v) not in visited and (v, u) not in visited:\n                new_visited = visited.copy()\n                new_visited.add((u, v))\n                new_visited.add((v, u))\n                new_candies = candies + c\n                new_energy = energy + c * c + alpha * len(new_visited)\n\n                if new_energy < min_energy:\n                    min_energy = new_energy\n                    min_candies = new_candies\n                    min_visited = new_visited\n\n        if min_energy == float('inf'):\n            return 'Poor girl'\n\n        return dfs(start, min_visited, min_candies, min_energy)\n\n    return dfs(1, set(), 0, 0)"
    },
    {
        "number": 3222,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_trips(places, streets, start):\n        trips = []\n        visited = set()\n        current_trip = [start]\n\n        while current_trip:\n            next_place = None\n            for street in streets:\n                if street[0] == current_trip[-1]:\n                    if street[1] not in visited:\n                        next_place = street[1]\n                        break\n                elif street[1] == current_trip[-1]:\n                    if street[0] not in visited:\n                        next_place = street[0]\n                        break\n\n            if next_place is not None:\n                current_trip.append(next_place)\n                visited.add(next_place)\n            else:\n                trips.append(current_trip)\n                current_trip = [start]\n\n        return trips\n\n    def print_trips(trips):\n        print(len(trips))\n        for trip in trips:\n            print(len(trip))\n            for place in trip:\n                print(place)\n\n    N, M = map(int, stdin.readline().split())\n    streets = []\n    for _ in range(M):\n        f, t = map(int, stdin.readline().split())\n        streets.append((f, t))\n\n    for start in range(N):\n        trips = find_trips(N, streets, start)\n        if trips:\n            print_trips(trips)\n            return\n\n    print(\"Yeah!\")"
    },
    {
        "number": 3223,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    num_vertices = int(lines[0])\n    degrees = [int(d) for d in lines[1].split()]\n\n    if num_vertices == 0:\n        return \"IMPOSSIBLE\"\n\n    forest = []\n    for i in range(num_vertices):\n        if degrees[i] == 0:\n            continue\n        elif degrees[i] == 1:\n            forest.append((i, i))\n        else:\n            for j in range(i + 1, num_vertices):\n                if degrees[j] == degrees[i] - 1:\n                    forest.append((i, j))\n                    degrees[i] -= 1\n                    degrees[j] -= 1\n                    break\n            else:\n                return \"IMPOSSIBLE\"\n\n    return \"POSSIBLE\\n\" + \"\\n\".join(f\"{a} {b}\" for a, b in forest)"
    },
    {
        "number": 3224,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for line in stdin.split('\\n'):\n        x, y, z = map(int, line.split())\n        points.append((x, y, z))\n\n    # Find the plane that contains the four points\n    a1, a2, a3 = [points[i] for i in (0, 1, 2)]\n    b1, b2, b3 = [points[i] for i in (1, 2, 3)]\n    c1, c2, c3 = [points[i] for i in (2, 3, 0)]\n\n    n1 = np.cross(a2 - a1, b2 - b1)\n    n2 = np.cross(b2 - b1, c2 - c1)\n    n3 = np.cross(c2 - c1, a2 - a1)\n\n    # Find the intersection point of the three planes\n    d = np.dot(n1, a1)\n    e = np.dot(n2, b1)\n    f = np.dot(n3, c1)\n\n    x = (np.dot(n1, n2) * f - np.dot(n1, n3) * e + d * np.dot(n2, n3)) / (np.dot(n1, n2) * np.dot(n2, n3) - np.dot(n1, n3) * np.dot(n1, n2))\n    y = (np.dot(n2, n3) * d - np.dot(n1, n3) * f + e * np.dot(n1, n3)) / (np.dot(n1, n2) * np.dot(n2, n3) - np.dot(n1, n3) * np.dot(n1, n2))\n    z = (np.dot(n1, n2) * e - np.dot(n1, n3) * d + f * np.dot(n1, n3)) / (np.dot(n1, n2) * np.dot(n2, n3) - np.dot(n1, n3) * np.dot(n1, n2))\n\n    # Find the radius of the sphere\n    radius = np.sqrt((x - points[0][0])**2 + (y - points[0][1])**2 + (z - points[0][2])**2)\n\n    return f\"{x} {y} {z}\""
    },
    {
        "number": 3225,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    values = list(map(int, stdin.split()[1:]))\n    queue = [i for i in range(N)]\n    minutes = 0\n    result = []\n    \n    while True:\n        new_queue = []\n        for i in range(len(queue)):\n            if i == 0 or i == len(queue) - 1:\n                new_queue.append(queue[i])\n            else:\n                if values[queue[i]] < max(values[queue[i-1]], values[queue[i+1]]):\n                    new_queue.append(queue[i])\n                else:\n                    result.append(values[queue[i]])\n        if len(new_queue) == len(queue):\n            break\n        queue = new_queue\n        minutes += 1\n    \n    result.extend(values[i] for i in queue)\n    return str(minutes) + '\\n' + '\\n'.join(str(x) for x in result) + '\\n' + ' '.join(str(values[i]) for i in queue)"
    },
    {
        "number": 3226,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = map(int, stdin.split()[:3])\n    roads = [list(map(int, line.split())) for line in stdin.split('\\n')[3:3+m-1]]\n    exits = list(map(int, stdin.split('\\n')[3+m-1].split()))\n    start_brothers, start_police = map(int, stdin.split('\\n')[-1].split())\n\n    def distance(a, b):\n        return sum([roads[i][2] for i in range(m) if roads[i][0] == a and roads[i][1] == b or roads[i][0] == b and roads[i][1] == a])\n\n    def escape_speed(start_a, start_b):\n        if start_a == start_b:\n            return \"IMPOSSIBLE\"\n        dist_a_b = distance(start_a, start_b)\n        dist_a_exit = min([distance(start_a, exit) for exit in exits])\n        dist_b_exit = min([distance(start_b, exit) for exit in exits])\n        return (dist_a_b + dist_a_exit + dist_b_exit) / dist_a_b * 160\n\n    return escape_speed(start_brothers, start_police)"
    },
    {
        "number": 3227,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited, parent, chain):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(graph, neighbor, visited, start, chain)\n            elif neighbor != parent:\n                return False\n        chain.append(start)\n        return True\n\n    def find_chains(graph, n):\n        chains = []\n        visited = [False] * n\n        for i in range(n):\n            if not visited[i]:\n                chain = []\n                if not dfs(graph, i, visited, -1, chain):\n                    return None\n                chains.append(chain)\n        return chains\n\n    def assign_roads(graph, chains):\n        result = [0] * len(graph)\n        for i, chain in enumerate(chains):\n            for city in chain:\n                for neighbor in graph[city]:\n                    if result[neighbor] == 0:\n                        result[neighbor] = i + 1\n        return result\n\n    n, e = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(n)]\n    for _ in range(e):\n        a, b = map(int, stdin.split()[-2:])\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    chains = find_chains(graph, n)\n    if chains is None:\n        return \"0\"\n\n    result = assign_roads(graph, chains)\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3228,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T, G = map(int, stdin.split()[:3])\n    skiers = sorted(map(int, stdin.split()[3:]))\n    gondolas = [0] * G\n    waiting_time = 0\n\n    for skier in skiers:\n        for i in range(G):\n            if gondolas[i] <= skier:\n                waiting_time += skier - gondolas[i]\n                gondolas[i] = T * 2 + skier\n                break\n\n    return str(waiting_time)"
    },
    {
        "number": 3229,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    scores = [list(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def get_points(rank: int) -> int:\n        if rank == 1:\n            return 100\n        elif rank == 2:\n            return 24\n        elif rank == 3:\n            return 10\n        elif rank == 4:\n            return 2\n        elif rank == 5:\n            return 75\n        elif rank == 6:\n            return 12\n        elif rank == 7:\n            return 22\n        elif rank == 8:\n            return 9\n        elif rank == 9:\n            return 3\n        elif rank == 10:\n            return 60\n        elif rank == 11:\n            return 13\n        elif rank == 12:\n            return 20\n        elif rank == 13:\n            return 23\n        elif rank == 14:\n            return 8\n        elif rank == 15:\n            return 4\n        elif rank == 16:\n            return 50\n        elif rank == 17:\n            return 14\n        elif rank == 18:\n            return 24\n        elif rank == 19:\n            return 7\n        elif rank == 20:\n            return 5\n        elif rank == 21:\n            return 45\n        elif rank == 22:\n            return 15\n        elif rank == 23:\n            return 16\n        elif rank == 24:\n            return 25\n        elif rank == 25:\n            return 6\n        elif rank == 26:\n            return 6\n        elif rank == 27:\n            return 40\n        elif rank == 28:\n            return 16\n        elif rank == 29:\n            return 15\n        elif rank == 30:\n            return 1\n\n    def get_aggregate_score(scores: List[int]) -> int:\n        max_scores = [0] * 30\n        for score in scores:\n            if score > 0:\n                max_scores[score - 1] = max(max_scores[score - 1], score)\n        return sum(max_scores)\n\n    worst_rank = 1\n    for i in range(1, 31):\n        aggregate_score = 0\n        for scores in scores:\n            aggregate_score += get_aggregate_score(scores)\n        if i == 30:\n            worst_rank = max(worst_rank, 1)\n        else:\n            worst_rank = max(worst_rank, 1 + sum(aggregate_score >= get_points(j) for j in range(1, i + 1)))\n\n    return str(worst_rank)"
    },
    {
        "number": 3230,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    grid = [list(stdin.split()[i+1]) for i in range(R)]\n    explosions = 0\n    seats_left = sum(row.count('L') for row in grid)\n    seats_taken = 0\n\n    while seats_left > 0:\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 'X':\n                    min_distance = float('inf')\n                    closest_seat = None\n                    for k in range(R):\n                        for l in range(C):\n                            if grid[k][l] == 'L':\n                                distance = abs(i - k) + abs(j - l)\n                                if distance < min_distance:\n                                    min_distance = distance\n                                    closest_seat = (k, l)\n                    if closest_seat:\n                        grid[closest_seat[0]][closest_seat[1]] = 'X'\n                        seats_taken += 1\n                        seats_left -= 1\n                        explosions += 1\n                        if seats_taken == seats_left:\n                            return str(explosions)\n\n    return str(explosions)"
    },
    {
        "number": 3231,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split()[0].split())\n    students = [list(map(int, input().split())) for _ in range(n)]\n\n    def is_valid_partition(groups):\n        for group in groups:\n            if len(group) < 1 or len(group) > p:\n                return False\n            for student in group:\n                if student < 0 or student >= n:\n                    return False\n            for i in range(len(group)):\n                for j in range(i + 1, len(group)):\n                    if students[group[i]][1:][:students[group[i]][0]] != students[group[j]][1:][:students[group[j]][0]]:\n                        return False\n        return True\n\n    def is_valid_friendship(groups):\n        for group in groups:\n            for i in range(len(group)):\n                for j in range(i + 1, len(group)):\n                    if students[group[i]][1:][:students[group[i]][0]] != students[group[j]][1:][:students[group[j]][0]]:\n                        return False\n        return True\n\n    def find_groups(students):\n        groups = []\n        for i in range(n):\n            group = [i]\n            for j in range(n):\n                if i != j and students[i][1:][:students[i][0]] == students[j][1:][:students[j][0]]:\n                    group.append(j)\n            groups.append(group)\n        return groups\n\n    def find_valid_groups(students):\n        groups = find_groups(students)\n        valid_groups = []\n        for group in groups:\n            if len(group) <= p and is_valid_friendship(valid_groups + [group]):\n                valid_groups.append(group)\n        return valid_groups\n\n    valid_groups = find_valid_groups(students)\n\n    if not valid_groups:\n        return \"detention\"\n    else:\n        return \"home\" + \"\\n\" + str(len(valid_groups)) + \"\\n\" + \"\\n\".join([\" \".join(map(str, group)) for group in valid_groups])"
    },
    {
        "number": 3232,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    if N % 2 != 0 or N < 2:\n        return \"-1\"\n\n    def is_valid(s: str) -> bool:\n        seen = set()\n        for i in range(N // 2):\n            seen.add(s[i:i + N // 2])\n        return len(seen) == N // 2 + 1\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            s = stdin[:i] + stdin[j] + stdin[i + 1:j] + stdin[i] + stdin[j + 1:]\n            if is_valid(s):\n                return s\n\n    return \"-1\""
    },
    {
        "number": 3233,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n    p.sort()\n    median = p[n // 2]\n    count = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            if p[i] <= median <= p[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3234,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    min_empty_squares = N\n    \n    for H in range(1, N+1):\n        W = 2*H\n        if W > N:\n            break\n        empty_squares = (N-W) * H\n        if empty_squares < min_empty_squares:\n            min_empty_squares = empty_squares\n    \n    return str(min_empty_squares)"
    },
    {
        "number": 3235,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    ious = [list() for _ in range(n)]\n    for _ in range(m):\n        a, b, c = map(int, stdin.split()[-3:])\n        ious[a].append((b, c))\n        ious[b].append((a, c))\n\n    def find_cycle(i, visited, stack):\n        visited[i] = True\n        stack[i] = True\n        for j, c in ious[i]:\n            if not visited[j]:\n                if find_cycle(j, visited, stack):\n                    return True\n            elif stack[j]:\n                return True\n        stack[i] = False\n        return False\n\n    def cancel_cycle(i, visited, stack):\n        visited[i] = True\n        stack[i] = True\n        min_c = float('inf')\n        for j, c in ious[i]:\n            if not visited[j]:\n                cancel_cycle(j, visited, stack)\n            elif stack[j]:\n                min_c = min(min_c, c)\n        for j, c in ious[i]:\n            if not visited[j]:\n                ious[j].remove((i, c))\n                ious[i].remove((j, c))\n                ious[j].append((i, c - min_c))\n                ious[i].append((j, c - min_c))\n        stack[i] = False\n\n    p = 0\n    for i in range(n):\n        visited = [False] * n\n        stack = [False] * n\n        if find_cycle(i, visited, stack):\n            p += 1\n            cancel_cycle(i, visited, stack)\n\n    output = []\n    for i in range(n):\n        for j, c in ious[i]:\n            if c > 0:\n                output.append((i, j, c))\n\n    return str(p) + '\\n' + '\\n'.join(map(lambda x: ' '.join(map(str, x)), output))"
    },
    {
        "number": 3236,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    mansions = list(map(int, stdin.readline().split()))\n    roads = []\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        roads.append((a, b))\n        roads.append((b, a))\n\n    def is_fibonacci_tour(tour: List[int]) -> bool:\n        for i in range(len(tour) - 1):\n            if (tour[i], tour[i + 1]) not in roads:\n                return False\n        return True\n\n    def find_longest_fibonacci_tour(n: int, mansions: List[int], roads: List[Tuple[int, int]]) -> int:\n        mansions.sort()\n        max_length = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                tour = [i + 1, j + 1]\n                while is_fibonacci_tour(tour):\n                    max_length = max(max_length, len(tour))\n                    tour.append(tour[-1] + 1)\n        return max_length\n\n    return str(find_longest_fibonacci_tour(n, mansions, roads))"
    },
    {
        "number": 3237,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    prime_factors = [int(stdin[i:i+2]) for i in range(0, len(stdin), 2)]\n    prime_factors.sort()\n    M = 1\n    cost = 0\n    for factor in prime_factors:\n        count = prime_factors.count(factor)\n        M *= factor ** count\n        cost += factor * count\n    return str(cost % (10**9+7))"
    },
    {
        "number": 3238,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    image = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def count_gold(r, c):\n        count = 0\n        for i in range(r, r + 2):\n            for j in range(c, c + 2):\n                if i >= 0 and i < n and j >= 0 and j < m:\n                    count += 1 if image[i][j] == '#' else -1\n        return count\n\n    def find_fold(r, c):\n        if image[r][c] == '#':\n            return r, c\n        elif image[r][c] == '.':\n            return r, c + 1\n        else:\n            return r + 1, c\n\n    def find_horizontal_fold():\n        for r in range(n):\n            for c in range(m):\n                if image[r][c] == '#':\n                    if count_gold(r, c) > 0:\n                        return r, c, r, c + 1\n\n    def find_vertical_fold():\n        for c in range(m):\n            for r in range(n):\n                if image[r][c] == '#':\n                    if count_gold(r, c) > 0:\n                        return r, c, r + 1, c\n\n    def find_diagonal_fold():\n        for r in range(n - 1):\n            for c in range(m - 1):\n                if image[r][c] == '#':\n                    if count_gold(r, c) > 0:\n                        return r, c, r + 1, c + 1\n\n    fold_functions = [find_horizontal_fold, find_vertical_fold, find_diagonal_fold]\n    fold_coordinates = None\n\n    for fold_function in fold_functions:\n        fold_coordinates = fold_function()\n        if fold_coordinates:\n            break\n\n    if fold_coordinates:\n        r1, c1, r2, c2 = fold_coordinates\n        return f\"{r1 + 1} {c1 + 1} {r2 + 1} {c2 + 1}\"\n    else:\n        return \"No fold found\""
    },
    {
        "number": 3239,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, stdin.split())\n    P = round(P, 3)\n    if N <= 0 or P <= 0 or P > 1:\n        return \"Invalid input\"\n\n    expected_pokeballs = N * (1 - P)\n    expected_money = expected_pokeballs * 5\n\n    return f\"{expected_money:.6f}\""
    },
    {
        "number": 3240,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.split()[:2])\n    probabilities, ballots = [], []\n    for i in range(v - 1):\n        probabilities.append(float(stdin.split()[2*i]))\n        ballots.append(int(stdin.split()[2*i+1]))\n    \n    def expected_positions(ballot_count: int) -> float:\n        total_ballots = sum(probabilities[i] * ballots[i] for i in range(v - 1)) + ballot_count\n        yraglac_count = 0\n        for i in range(k):\n            yraglac_count += bin(total_ballots).count('1') % 2\n            total_ballots >>= 1\n        return yraglac_count\n    \n    max_ballot_count = 0\n    max_positions = 0\n    for ballot_count in range(2**k):\n        positions = expected_positions(ballot_count)\n        if positions > max_positions:\n            max_positions = positions\n            max_ballot_count = ballot_count\n    \n    return str(max_ballot_count)"
    },
    {
        "number": 3241,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    people = []\n    for i in range(1, N+1):\n        line = stdin.split('\\n')[i].split()\n        A = int(line[0])\n        B = int(line[1])\n        people.append((A, B))\n\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    total_ham = 0\n    for i in range(N):\n        total_ham += people[i][1]\n\n    if total_ham == 0:\n        return \"-1\"\n\n    total_ham_kilos = 0\n    for i in range(N):\n        total_ham_kilos += people[i][1] * people[i][0]\n\n    total_ham_kilos /= total_ham\n\n    return str(total_ham_kilos)"
    },
    {
        "number": 3242,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, p = map(float, lines[0].split())\n    boxes = []\n    for i in range(1, n+1):\n        e, prob = map(float, lines[i].split())\n        boxes.append((e, prob))\n    \n    boxes.sort(key=lambda x: x[1])\n    total_energy = 0\n    total_prob = 0\n    \n    for e, prob in boxes:\n        total_energy += e\n        total_prob += prob\n        if total_prob >= p:\n            return str(total_energy)\n    \n    return \"0\""
    },
    {
        "number": 3243,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    sockets = list(map(int, stdin.split()[3:3+n]))\n    connections = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, stdin.split()[3+n:3+n+2])\n        connections[u].append(v)\n        connections[v].append(u)\n    \n    def dfs(node: int, visited: set) -> set:\n        visited.add(node)\n        for neighbor in connections[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n        return visited\n    \n    groups = []\n    for i in range(n):\n        if i not in [node for group in groups for node in group]:\n            groups.append(dfs(i, set()))\n    \n    if len(groups) > 1:\n        return \"no\"\n    \n    used_edits = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if sockets[i] + sockets[j] > m:\n                continue\n            used_edits += 1\n            if used_edits > k:\n                return \"no\"\n            connections[i].append(j)\n            connections[j].append(i)\n    \n    return \"yes\""
    },
    {
        "number": 3244,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    ring2 = [int(x) for x in lines[1:]]\n\n    # Find the original ring\n    ring1 = []\n    for i in range(n):\n        ring1.append(ring2[i] - ring2[(i - 1) % n] - ring2[(i + 1) % n])\n\n    # Output the original ring\n    return \"\\n\".join(str(x) for x in ring1)"
    },
    {
        "number": 3245,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    commands = stdin.split(\"\\n\")\n    n = int(commands[0])\n    command_history = []\n    output = \"\"\n\n    for i in range(1, n + 1):\n        command = commands[i]\n        if command.endswith(\"^\"):\n            if command_history:\n                last_command = command_history[-1]\n                if command.startswith(last_command):\n                    command = last_command\n                else:\n                    for j in range(len(command_history) - 2, -1, -1):\n                        if command.startswith(command_history[j]):\n                            command = command_history[j]\n                            break\n            else:\n                command = \"\"\n        else:\n            command_history.append(command)\n\n        output += command + \"\\n\"\n\n    return output"
    },
    {
        "number": 3246,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    shuffled_sentence = words[0]\n    dictionary = words[1:]\n\n    def is_valid_word(word: str, shuffled_word: str) -> bool:\n        for i in range(len(word)):\n            if word[i] != shuffled_word[i]:\n                return False\n        return True\n\n    def find_word(shuffled_word: str) -> str:\n        for word in dictionary:\n            if is_valid_word(word, shuffled_word):\n                return word\n        return \"\"\n\n    deciphered_sentence = \"\"\n    for i in range(len(shuffled_sentence)):\n        if i == 0 or i == len(shuffled_sentence) - 1:\n            deciphered_sentence += shuffled_sentence[i]\n        else:\n            word = find_word(shuffled_sentence[i - 1:i + 2])\n            if word == \"\":\n                return \"impossible\"\n            deciphered_sentence += word\n\n    return deciphered_sentence"
    },
    {
        "number": 3247,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 9\n\n    def count_ways(n: int, m: int) -> int:\n        if n == 1 and m == 1:\n            return 1\n        if n == 2 and m == 1:\n            return 1\n        if n == 2 and m == 2:\n            return 16\n        if n == 1 and m == 2:\n            return 4\n\n        return (count_ways(n - 2, m - 2) * 2 + count_ways(n - 2, m - 1) * 2 + count_ways(n - 1, m - 2) * 2) % mod\n\n    return str(count_ways(n, m))"
    },
    {
        "number": 3248,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, street, M, *tile_patterns = stdin.split()\n    N = int(N)\n    M = int(M)\n    street = list(street)\n    tile_patterns = [list(tile_pattern) for tile_pattern in tile_patterns]\n\n    def is_tileable(street_cell: str, tile_pattern: list) -> bool:\n        if len(tile_pattern) > len(street_cell):\n            return False\n        for i in range(len(street_cell) - len(tile_pattern) + 1):\n            if street_cell[i:i + len(tile_pattern)] == tile_pattern:\n                return True\n        return False\n\n    untileable_cells = 0\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            street_cell = street[i:j]\n            if not any(is_tileable(street_cell, tile_pattern) for tile_pattern in tile_patterns):\n                untileable_cells += 1\n\n    return str(untileable_cells)"
    },
    {
        "number": 3249,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    C, N = map(int, stdin.splitlines()[:2])\n    vertices = [tuple(map(int, line.split())) for line in stdin.splitlines()[2:]]\n    \n    # Calculate the area of each section\n    areas = []\n    for i in range(N):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % N]\n        area = abs(x1 * y2 - x2 * y1) / 2\n        areas.append(area)\n    \n    # Calculate the maximum number of bulkhead sections\n    M = 1\n    for area in areas:\n        if area >= C:\n            M += 1\n    \n    # Calculate the placements of the bulkhead sections\n    placements = []\n    for i in range(N):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % N]\n        if x1 == x2:\n            continue\n        slope = (y2 - y1) / (x2 - x1)\n        x = (C - y1 - slope * x1) / (slope - 1)\n        placements.append(x)\n    \n    placements.sort()\n    \n    # Output the results\n    output = [str(M)]\n    for placement in placements:\n        output.append(str(placement))\n    \n    return \"\\n\".join(output)"
    },
    {
        "number": 3250,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if d == 2:\n        return \"no\"\n    for m in range(1, d):\n        if (b**m - 1) % d == 0:\n            return \"yes\"\n    return \"no\""
    },
    {
        "number": 3251,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(intervals: List[Tuple[int, int]]) -> bool:\n        for i in range(len(intervals) - 1):\n            if intervals[i][1] != intervals[i + 1][0]:\n                return False\n        return True\n\n    def find_longest_sequence(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        longest_sequence = []\n        for i in range(len(intervals)):\n            for j in range(i + 1, len(intervals)):\n                if is_valid(intervals[i:j + 1]):\n                    if len(longest_sequence) < len(intervals[i:j + 1]):\n                        longest_sequence = intervals[i:j + 1]\n        return longest_sequence\n\n    input_lines = stdin.split(\"\\n\")\n    n = int(input_lines[0])\n    intervals = [tuple(map(int, line.split())) for line in input_lines[1:]]\n\n    longest_sequence = find_longest_sequence(intervals)\n    result = [str(interval[0]) + \" \" + str(interval[1]) for interval in longest_sequence]\n\n    return str(len(longest_sequence)) + \"\\n\" + \"\\n\".join(result)"
    },
    {
        "number": 3252,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    cards = []\n    for i in range(n):\n        w, h, q = map(int, stdin.split()[i+1].split())\n        cards.append((w, h, q))\n\n    cards.sort(key=lambda x: x[0] * x[1], reverse=True)\n    envelopes = []\n    for card in cards:\n        if not envelopes or card[0] > envelopes[-1][0] or card[1] > envelopes[-1][1]:\n            envelopes.append(card[:2])\n\n    if len(envelopes) > k:\n        return \"0\"\n\n    wasted_paper = 0\n    for card in cards:\n        envelope = None\n        for e in envelopes:\n            if card[0] <= e[0] and card[1] <= e[1]:\n                envelope = e\n                break\n        if envelope:\n            wasted_paper += card[0] * card[1] - envelope[0] * envelope[1]\n\n    return str(wasted_paper)"
    },
    {
        "number": 3253,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    num_states = int(lines[0])\n    state_info = []\n\n    for i in range(1, num_states + 1):\n        state_info.append(list(map(int, lines[i].split())))\n\n    total_delegates = sum(state[0] for state in state_info)\n    total_voters = sum(state[1] + state[2] + state[3] for state in state_info)\n\n    if total_delegates > 2016 or total_voters > 10**9:\n        return \"impossible\"\n\n    min_voters_to_convince = float(\"inf\")\n    for state in state_info:\n        delegates, c_voters, f_voters, u_voters = state\n\n        if c_voters + f_voters + u_voters != delegates:\n            return \"impossible\"\n\n        if c_voters == delegates:\n            continue\n\n        if f_voters == delegates:\n            continue\n\n        if u_voters == 0:\n            continue\n\n        min_voters_to_convince = min(min_voters_to_convince, u_voters)\n\n    return str(min_voters_to_convince) if min_voters_to_convince != float(\"inf\") else \"impossible\""
    },
    {
        "number": 3254,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P = float(stdin)\n    ones = int(P)\n    fives = 0\n    threes = 0\n    twos = 0\n    fours = 0\n\n    if P - ones >= 0.5:\n        fives = 1\n        P -= 5\n\n    if P - ones >= 0.3:\n        threes = 1\n        P -= 3\n\n    if P - ones >= 0.2:\n        twos = 1\n        P -= 2\n\n    if P - ones >= 0.4:\n        fours = 1\n        P -= 4\n\n    return f\"{ones} {twos} {threes} {fours} {fives}\""
    },
    {
        "number": 3255,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, D, M = map(int, stdin.split()[:3])\n    array = list(map(int, stdin.split()[3:]))\n\n    def is_valid_move(i: int, j: int) -> bool:\n        return abs(i - j) <= D\n\n    def is_valid_jump(a: int, b: int) -> bool:\n        return abs(a - b) <= M\n\n    def explore(i: int) -> int:\n        visited = set()\n        queue = [i]\n        while queue:\n            current = queue.pop(0)\n            visited.add(current)\n            for j in range(n):\n                if is_valid_move(current, j) and is_valid_jump(array[current], array[j]) and j not in visited:\n                    queue.append(j)\n        return len(visited)\n\n    max_length = 0\n    for i in range(n):\n        max_length = max(max_length, explore(i))\n\n    return str(max_length)"
    },
    {
        "number": 3256,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    def bitwise_and(a: int, b: int) -> int:\n        return a & b\n\n    def bitwise_or(a: int, b: int) -> int:\n        return a | b\n\n    def power(section: list) -> int:\n        return reduce(bitwise_or, section)\n\n    def max_bitwise_and(sections: list) -> int:\n        return reduce(bitwise_and, map(power, sections))\n\n    def find_sections(A: list, K: int) -> list:\n        sections = []\n        section = []\n        for i in range(len(A)):\n            section.append(A[i])\n            if len(section) == K or i == len(A) - 1:\n                sections.append(section)\n                section = []\n        return sections\n\n    sections = find_sections(A, K)\n    return str(max_bitwise_and(sections))"
    },
    {
        "number": 3257,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split())\n    s = (a + b + c) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    return f\"{area:.3f}\" if area > 0 else \"-1\""
    },
    {
        "number": 3258,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    mice = []\n    for _ in range(n):\n        x, y, s = map(int, stdin.split()[3:])\n        mice.append((x, y, s))\n    m = float(stdin.split()[-1])\n\n    def distance(mouse):\n        return ((mouse[0])**2 + (mouse[1])**2)**0.5\n\n    def time_to_reach(mouse, velocity):\n        return distance(mouse) / velocity\n\n    def time_to_eat(mouse, velocity):\n        return time_to_reach(mouse, velocity) + mouse[2]\n\n    def optimal_order(mice):\n        return sorted(mice, key=lambda x: time_to_eat(x, 1))\n\n    def min_velocity(mice, m):\n        mice = optimal_order(mice)\n        velocity = 1\n        for mouse in mice:\n            velocity = velocity * m\n        return velocity\n\n    return f\"{min_velocity(mice, m):.3f}\""
    },
    {
        "number": 3259,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def simulate(L, R, A, B):\n        stones = [0] * (N + 1)\n        for i in range(L, R + 1):\n            stones[i] = (i - L + 1) * A % B\n        return stones\n\n    def count_stones(L, R):\n        return sum(stones[L:R + 1])\n\n    N, Q = map(int, stdin.split()[:2])\n    stones = [0] * (N + 1)\n    for query in stdin.split(\"\\n\")[2:]:\n        if query.startswith(\"1\"):\n            L, R, A, B = map(int, query.split()[1:])\n            stones = simulate(L, R, A, B)\n        elif query.startswith(\"2\"):\n            L, R = map(int, query.split()[1:])\n            print(count_stones(L, R))"
    },
    {
        "number": 3260,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    # Write your code here\n    return str(result % p)"
    },
    {
        "number": 3261,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    if K > R * C:\n        return \"0\"\n\n    def is_grey(row: int, col: int) -> bool:\n        return (row & (1 << col)) == 0\n\n    def zigzag(row: int, col: int) -> int:\n        if col % 2 == 0:\n            return row + col\n        else:\n            return row - col\n\n    visited = set()\n    count = 0\n    row, col = 0, 0\n\n    while count < K:\n        if (row, col) not in visited:\n            visited.add((row, col))\n            count += 1\n\n        if count == K:\n            break\n\n        if is_grey(row, col):\n            row, col = zigzag(row + 1, col), col\n        else:\n            row, col = zigzag(row, col + 1), col + 1\n\n    return str(len(visited))"
    },
    {
        "number": 3262,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, C = map(int, stdin.split()[0:3])\n    clients = list(map(int, stdin.split()[3:]))\n    adj_list = [[] for _ in range(N)]\n    for _ in range(M):\n        U, V, W = map(int, stdin.split()[3:])\n        adj_list[U].append((V, W))\n        adj_list[V].append((U, W))\n\n    def dijkstra(start: int) -> List[int]:\n        dist = [float('inf')] * N\n        dist[start] = 0\n        heap = [(0, start)]\n        while heap:\n            d, node = heapq.heappop(heap)\n            if d > dist[node]:\n                continue\n            for neighbor, weight in adj_list[node]:\n                new_dist = dist[node] + weight\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(heap, (new_dist, neighbor))\n        return dist\n\n    dist = dijkstra(0)\n    min_trucks = 0\n    for client in clients:\n        if dist[client] == float('inf'):\n            return \"IMPOSSIBLE\"\n        min_trucks = max(min_trucks, dist[client])\n\n    return min_trucks"
    },
    {
        "number": 3263,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, int, List[int], List[int], List[Tuple[int, int]]]:\n        N, M = map(int, stdin.readline().split())\n        P = list(map(int, stdin.readline().split()))\n        R = list(map(int, stdin.readline().split()))\n        customers = []\n        for _ in range(N):\n            C, T = map(int, stdin.readline().split())\n            customers.append((C, T))\n        return N, M, P, R, customers\n\n    def can_serve(customer: Tuple[int, int], clothing: int, time: int, P: List[int], R: List[int]) -> bool:\n        if clothing == customer[0]:\n            return True\n        return time + P[clothing] + R[customer[0]] <= customer[1]\n\n    def find_max_customers(N: int, M: int, P: List[int], R: List[int], customers: List[Tuple[int, int]]) -> int:\n        max_customers = 0\n        current_clothing = -1\n        for customer in customers:\n            if can_serve(customer, current_clothing, 0, P, R):\n                max_customers += 1\n                current_clothing = customer[0]\n        return max_customers\n\n    N, M, P, R, customers = read_input()\n    return str(find_max_customers(N, M, P, R, customers))"
    },
    {
        "number": 3264,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    count = 0\n    for i in range(1, N):\n        for j in range(i+1, N+1):\n            if is_coprime(i, j):\n                count += 1\n    return str(count % 1000000000)\n\ndef"
    },
    {
        "number": 3265,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split()[0:2])\n    connections = [list(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n\n    def dfs(start: int, end: int, visited: set, path: list) -> bool:\n        if start == end:\n            return True\n        visited.add(start)\n        for i in range(N):\n            if connections[start][i] > 0 and i not in visited:\n                path.append((start, i))\n                if dfs(i, end, visited, path):\n                    return True\n                path.pop()\n        visited.remove(start)\n        return False\n\n    for T in range(L, L + 10):\n        alice_path = []\n        bob_path = []\n        if dfs(1, N, set(), alice_path) and dfs(N, 1, set(), bob_path):\n            alice_path.append((N, 1))\n            bob_path.append((1, N))\n            alice_days = sum(connections[i][j] for i, j in alice_path)\n            bob_days = sum(connections[i][j] for i, j in bob_path)\n            if alice_days == bob_days and alice_days == T:\n                return str(T)\n    return \"-1\""
    },
    {
        "number": 3266,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m, s, t = map(int, stdin.split()[:4])\n    edges = []\n    for line in stdin.split('\\n')[1:]:\n        u, v, c = map(int, line.split())\n        edges.append((u, v, c))\n    \n    # Initialize the flow graph\n    flow_graph = [[0] * n for _ in range(n)]\n    for u, v, c in edges:\n        flow_graph[u][v] = c\n    \n    # Find the maximum flow\n    f, m_prime = 0, 0\n    while True:\n        # Find the augmenting path using BFS\n        visited = [False] * n\n        visited[s] = True\n        queue = [s]\n        while queue:\n            u = queue.pop(0)\n            for v in range(n):\n                if not visited[v] and flow_graph[u][v] > 0:\n                    visited[v] = True\n                    queue.append(v)\n                    if v == t:\n                        path = []\n                        while u != s:\n                            path.append((u, v))\n                            u, v = prev[u][v], prev[u][v]\n                        path.reverse()\n                        break\n        \n        # If there is no augmenting path, the maximum flow is found\n        if not path:\n            break\n        \n        # Update the flow and the residual graph\n        f += min(flow_graph[u][v] for u, v in path)\n        for u, v in path:\n            flow_graph[u][v] -= min(flow_graph[u][v] for u, v in path)\n            flow_graph[v][u] += min(flow_graph[u][v] for u, v in path)\n        \n        # Update the predecessors for the next BFS\n        prev = [[-1] * n for _ in range(n)]\n        for u in range(n):\n            for v in range(n):\n                if flow_graph[u][v] > 0:\n                    prev[v][flow_graph[u][v]-1] = u\n    \n    # Output the result\n    output = f\"{n} {f} {m_prime}\\n\"\n    for u, v, x in edges:\n        if x > 0 and flow_graph[u][v] > 0:\n            output += f\"{u} {v} {x}\\n\"\n            m_prime += 1\n    return output"
    },
    {
        "number": 3267,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    board = [list(line.strip()) for line in stdin.splitlines()[1:]]\n\n    def get_spread(player: str) -> int:\n        pieces = [(r, c) for r in range(R) for c in range(C) if board[r][c] == player]\n        total_distance = 0\n        for i in range(len(pieces)):\n            for j in range(i + 1, len(pieces)):\n                r1, c1 = pieces[i]\n                r2, c2 = pieces[j]\n                distance = abs(r1 - r2) + abs(c1 - c2)\n                total_distance += distance\n        return total_distance\n\n    mirko_spread = get_spread('M')\n    slavko_spread = get_spread('S')\n\n    return f\"{mirko_spread} {slavko_spread}\""
    },
    {
        "number": 3268,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    tree = [[] for _ in range(n+1)]\n    labels = {}\n    for i in range(1, n+1):\n        line = lines[i].split()\n        if len(line) == 2:\n            p, t = line\n            p = int(p)\n            tree[p].append(i)\n            if t == 'B':\n                tree[i].append(0)\n            else:\n                tree[i].append(1)\n        else:\n            p, t, label = line\n            p = int(p)\n            tree[p].append(i)\n            if t == 'G':\n                tree[i].append(0)\n            elif t == 'T':\n                tree[i].append(1)\n            else:\n                tree[i].append(2)\n            labels[i] = label\n\n    def dfs(node: int, parent: int) -> int:\n        if node == 0:\n            return 0\n        if tree[node][0] == 0:\n            return dfs(tree[node][1], node) + 1\n        else:\n            return dfs(tree[node][0], node) + 1\n\n    def find_controlled_area(node: int, parent: int, giant_branch: int) -> int:\n        if node == 0:\n            return 0\n        if tree[node][0] == 0:\n            return dfs(tree[node][1], node) + 1\n        else:\n            return dfs(tree[node][0], node) + 1\n\n    def find_giant_branch(node: int) -> int:\n        while tree[node][0] == 1:\n            node = tree[node][1]\n        return node\n\n    def find_label(node: int) -> str:\n        return labels[node]\n\n    def change_label(node: int, new_label: str) -> None:\n        labels[node] = new_label\n\n    def is_valid_solution(node: int, parent: int, giant_branch: int) -> bool:\n        controlled_area = find_controlled_area(node, parent, giant_branch)\n        label = find_label(node)\n        for child in tree[node]:\n            if child != parent:\n                if find_label(child) == label and find_controlled_area(child, node, giant_branch) == controlled_area:\n                    return False\n        return True\n\n    def find_minimum_changes() -> int:\n        changes = 0\n        for i in range(1, n+1):\n            if tree[i][0] == 1:\n                giant_branch = find_giant_branch(i)\n                if not is_valid_solution(i, 0, giant_branch):\n                    changes += 1\n                    new_label = chr(ord('a') + changes - 1)\n                    change_label(i, new_label)\n        return changes\n\n    changes = find_minimum_changes()\n    result = [str(changes)]\n    for i in range(1, n+1):\n        if tree[i][0] == 2:\n            result.append(str(i) + ' ' + labels[i])\n    return '\\n'.join(result)"
    },
    {
        "number": 3269,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    total_distance = 0\n\n    for i in range(A, B + 1):\n        for j in range(i + 1, B + 1):\n            distance = sum(abs(int(x) - int(y)) for x, y in zip(str(i), str(j)))\n            total_distance += distance\n\n    return str(total_distance % 1000000007)"
    },
    {
        "number": 3270,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split('\\n')\n    n = int(words[0])\n    dictionary = set(words[1:n+1])\n    start_word = words[n+1]\n    end_word = words[n+2]\n\n    def is_valid_word(word: str) -> bool:\n        for i in range(len(word)):\n            if word[:i] + word[i+1:] in dictionary:\n                return True\n        return False\n\n    def get_next_words(word: str) -> List[str]:\n        next_words = []\n        for i in range(len(word)):\n            for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                if letter != word[i]:\n                    new_word = word[:i] + letter + word[i+1:]\n                    if new_word in dictionary:\n                        next_words.append(new_word)\n        return next_words\n\n    def find_shortest_path(start_word: str, end_word: str) -> int:\n        queue = [(start_word, 0)]\n        visited = set()\n        while queue:\n            current_word, steps = queue.pop(0)\n            if current_word == end_word:\n                return steps\n            if current_word not in visited:\n                visited.add(current_word)\n                next_words = get_next_words(current_word)\n                for next_word in next_words:\n                    if is_valid_word(next_word):\n                        queue.append((next_word, steps+1))\n        return -1\n\n    if start_word == end_word:\n        return '0\\n0'\n\n    for letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        new_word = start_word[:1] + letter + start_word[2:]\n        if new_word in dictionary:\n            path_length = find_shortest_path(new_word, end_word)\n            if path_length != -1:\n                return new_word + '\\n' + str(path_length)\n\n    return '0\\n-1'"
    },
    {
        "number": 3271,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    MOD = 1000000007\n\n    def count_confused_pairs(n: int) -> int:\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if i + 1 > j:\n                    count += 1\n        return count\n\n    def count_sequences(n: int, c: int) -> int:\n        if c == 0:\n            return 1\n        if n == 1:\n            return 0\n\n        count = 0\n        for i in range(1, n + 1):\n            count += count_sequences(i - 1, c - count_confused_pairs(i))\n            count %= MOD\n\n        return count\n\n    return str(count_sequences(N, C))"
    },
    {
        "number": 3272,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    floorplan = [list(line.strip()) for line in stdin.splitlines()[1:]]\n\n    def rotate_gargoyle(i, j):\n        if floorplan[i][j] == 'V':\n            floorplan[i][j], floorplan[i][j + 1] = floorplan[i][j + 1], floorplan[i][j]\n        elif floorplan[i][j] == 'H':\n            floorplan[i][j], floorplan[i + 1][j] = floorplan[i + 1][j], floorplan[i][j]\n\n    def is_valid_path(i, j):\n        if floorplan[i][j] == '#':\n            return False\n        if floorplan[i][j] == 'V':\n            return is_valid_path(i, j + 1)\n        elif floorplan[i][j] == 'H':\n            return is_valid_path(i + 1, j)\n        else:\n            return True\n\n    def count_rotations():\n        rotations = 0\n        for i in range(n):\n            for j in range(m):\n                if floorplan[i][j] in 'VH':\n                    rotate_gargoyle(i, j)\n                    rotations += 1\n                    if is_valid_path(i, j):\n                        return rotations\n                    else:\n                        rotate_gargoyle(i, j)\n                        rotations -= 1\n        return -1\n\n    return str(count_rotations())"
    },
    {
        "number": 3273,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    fragments = stdin.split(\"\\n\")[1:]\n    fragments = [f for f in fragments if f]  # Remove empty lines\n\n    def is_overlap(f1: str, f2: str) -> bool:\n        if len(f1) < 5 or len(f2) < 5:\n            return False\n        return f1[-5:] == f2[:5]\n\n    def find_overlap(f1: str, f2: str) -> str:\n        for i in range(5, min(len(f1), len(f2)) + 1):\n            if f1[-i:] == f2[:i]:\n                return f2[i:]\n        return \"\"\n\n    def find_optimal_sequence(fragments: List[str]) -> List[str]:\n        sequences = []\n        for i, f1 in enumerate(fragments):\n            for j, f2 in enumerate(fragments[i + 1:], i + 1):\n                if is_overlap(f1, f2):\n                    sequence = find_optimal_sequence(fragments[:i] + [f1 + find_overlap(f1, f2)] + fragments[j + 1:])\n                    if sequence:\n                        sequences.append(sequence)\n        return max(sequences, key=len) if sequences else []\n\n    optimal_sequence = find_optimal_sequence(fragments)\n    if not optimal_sequence:\n        return \"AMBIGUOUS\"\n\n    reconstruction = \"\".join(f.strip() for f in optimal_sequence)\n    return reconstruction"
    },
    {
        "number": 3274,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    ships = []\n    for _ in range(m):\n        x1, x2, y = map(int, stdin.split()[-3:])\n        ships.append((x1, y, x2))\n\n    def is_hit(x, y, ship):\n        return ship[0] <= x <= ship[2] and ship[1] == y\n\n    def is_valid(turns):\n        x, y = 0, 0\n        for turn in turns:\n            x += 1\n            y += int(turn)\n            for ship in ships:\n                if is_hit(x, y, ship):\n                    return False\n        return True\n\n    for turns in itertools.product(\"-+\", repeat=n):\n        if is_valid(turns):\n            return \"\".join(turns)\n\n    return \"impossible\""
    },
    {
        "number": 3275,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2*N]))\n    b = list(map(int, stdin.split()[2*N:]))\n    Q = int(stdin.split()[-1])\n\n    def count_purchases(a, b, C):\n        a.sort(reverse=True)\n        b.sort(reverse=True)\n        count = 0\n        colored = 0\n        for i in range(N):\n            if a[i] + b[i] > 0:\n                count += 1\n                colored += a[i]\n            if colored >= C:\n                break\n        return count\n\n    result = []\n    for _ in range(Q):\n        P, a_P, b_P = map(int, stdin.split()[:3])\n        a[P-1] = a_P\n        b[P-1] = b_P\n        result.append(count_purchases(a, b, C))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3276,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    art_piece = stdin.split()[2:]\n\n    def is_valid(row: int, col: int) -> bool:\n        return 0 <= row < N and 0 <= col < M\n\n    def stamp(row: int, col: int, color: str) -> None:\n        for i in range(3):\n            for j in range(3):\n                if is_valid(row + i, col + j):\n                    art_piece[row + i][col + j] = color\n\n    for i in range(N - 2):\n        for j in range(M - 2):\n            if art_piece[i][j] == art_piece[i][j + 1] == art_piece[i][j + 2] == art_piece[i + 1][j] == art_piece[i + 1][j + 1] == art_piece[i + 1][j + 2] == art_piece[i + 2][j] == art_piece[i + 2][j + 1] == art_piece[i + 2][j + 2]:\n                stamp(i, j, art_piece[i][j])\n                break\n        else:\n            continue\n        break\n    else:\n        return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3277,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n    \n    # Calculate the sum of every set of K consecutive integers\n    sums = [sum(A[i:i+K]) for i in range(N-K+1)]\n    \n    # Find the repeating pattern of length K\n    pattern = [sums[i] for i in range(len(sums)-K+1) if sums[i] == sums[i+K-1]]\n    \n    # Calculate the minimum number of changes needed\n    min_changes = 0\n    for i in range(N):\n        if A[i] != pattern[i%len(pattern)]:\n            min_changes += 1\n    \n    return str(min_changes)"
    },
    {
        "number": 3278,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    frog_positions = []\n    frog_distances = []\n\n    for i in range(1, n + 1):\n        x, d = map(int, lines[i].split())\n        frog_positions.append(x)\n        frog_distances.append(d)\n\n    frog_positions.sort()\n    frog_distances.sort(reverse=True)\n\n    max_tower_size = 0\n    max_tower_position = 0\n\n    for i in range(n):\n        tower_size = 1\n        current_position = frog_positions[i]\n\n        for j in range(i + 1, n):\n            if frog_positions[j] - current_position <= frog_distances[j - 1]:\n                tower_size += 1\n                current_position = frog_positions[j]\n            else:\n                break\n\n        if tower_size > max_tower_size:\n            max_tower_size = tower_size\n            max_tower_position = current_position\n\n    return f\"{max_tower_position} {max_tower_size}\" "
    },
    {
        "number": 3279,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    rows = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    cols = [list(map(int, line.split())) for line in stdin.split('\\n')[n+1:]]\n    \n    def mark_borders(borders, groups):\n        marked = [0] * (len(borders) + 1)\n        current_group = 0\n        for i in range(len(borders)):\n            if borders[i] == 0:\n                marked[i] = 1\n            else:\n                if groups[current_group] == 0:\n                    marked[i] = 1\n                else:\n                    marked[i] = 0\n                    groups[current_group] -= 1\n                if groups[current_group] == 0:\n                    current_group += 1\n        marked[-1] = 1\n        return marked\n    \n    row_borders = [0] * (n+1)\n    col_borders = [0] * n\n    \n    for i in range(n):\n        row_borders[i] = sum(rows[i])\n        col_borders[i] = sum(cols[i])\n    \n    row_borders[-1] = n\n    col_borders[-1] = n\n    \n    row_markings = [mark_borders(row_borders, row) for row in rows]\n    col_markings = [mark_borders(col_borders, col) for col in cols]\n    \n    return '\\n'.join([''.join(map(str, row)) for row in row_markings]) + '\\n' + '\\n'.join([''.join(map(str, col)) for col in col_markings])"
    },
    {
        "number": 3280,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    shows = []\n    for line in stdin.split('\\n')[1:]:\n        x, y = map(int, line.split())\n        shows.append((x, y))\n\n    shows.sort(key=lambda x: x[0])\n    shows.append((1000000001, 1000000001))\n\n    count = 0\n    current_shows = []\n    for i in range(len(shows)):\n        if len(current_shows) < k:\n            current_shows.append(shows[i])\n        else:\n            current_shows.sort(key=lambda x: x[1])\n            if current_shows[0][1] <= shows[i][0]:\n                count += 1\n                current_shows.pop(0)\n            current_shows.append(shows[i])\n\n    return str(count)"
    },
    {
        "number": 3281,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    J, R, D = map(int, stdin.readline().split())\n    junctions = [tuple(map(int, stdin.readline().split())) for _ in range(J)]\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(R)]\n\n    def distance(a: int, b: int) -> float:\n        return ((junctions[a][0] - junctions[b][0]) ** 2 + (junctions[a][1] - junctions[b][1]) ** 2) ** 0.5\n\n    def angle(a: int, b: int, c: int) -> float:\n        ab = (junctions[b][0] - junctions[a][0], junctions[b][1] - junctions[a][1])\n        bc = (junctions[c][0] - junctions[b][0], junctions[c][1] - junctions[b][1])\n        dot_product = ab[0] * bc[0] + ab[1] * bc[1]\n        return abs(math.degrees(math.acos(dot_product / (distance(a, b) * distance(b, c)))))\n\n    def route_length(route: List[int]) -> float:\n        return sum(distance(route[i], route[i + 1]) for i in range(len(route) - 1))\n\n    def find_route(start: int, end: int, max_length: float) -> Optional[List[int]]:\n        visited = [False] * (J + 1)\n        queue = [(start, [start])]\n        while queue:\n            current, route = queue.pop(0)\n            if current == end:\n                if route_length(route) <= max_length:\n                    return route\n            else:\n                for next_junction in range(1, J + 1):\n                    if not visited[next_junction] and (next_junction, current) in roads:\n                        visited[next_junction] = True\n                        queue.append((next_junction, route + [next_junction]))\n        return None\n\n    max_angle = 0\n    for i in range(1, J):\n        for j in range(i + 1, J + 1):\n            route = find_route(i, j, D)\n            if route:\n                max_angle = max(max_angle, angle(route[0], route[1], route[2]))\n\n    return f\"{max_angle:.6f}\" if max_angle else \"Impossible\""
    },
    {
        "number": 3282,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P = int(stdin)\n    bills = []\n    for beverage in range(1, 10):\n        for main_dish in range(1, 10):\n            if beverage != main_dish:\n                total = beverage + main_dish\n                if total <= P:\n                    bill = (beverage, main_dish)\n                    if bill not in bills:\n                        bills.append(bill)\n    \n    bills.sort()\n    max_free_desserts = min(len(bills), 5000)\n    \n    output = f\"{max_free_desserts}\\n\"\n    for i in range(max_free_desserts):\n        output += f\"{bills[i][0]} {bills[i][1]}\\n\"\n    \n    return output.strip()"
    },
    {
        "number": 3283,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    a = [1] * n\n    for _ in range(d):\n        for i in range(n):\n            if a[i] > 1:\n                a[i] //= 2\n                a[i] += 1\n                a.append(a[i])\n    a.sort(reverse=True)\n    return f\"{sum(a[:r]) / n:.6f}\""
    },
    {
        "number": 3284,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    count = 0\n    for x in range(a, b+1):\n        for y in range(c, d+1):\n            if is_coprime(x, y):\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3285,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, m = map(int, stdin.split())\n    A = [r]\n    n = 1\n    while True:\n        d = min(set(range(1, m+1)) - set(A))\n        A.append(A[-1] + d)\n        if m in A:\n            return str(n)\n        n += 1"
    },
    {
        "number": 3286,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"aeiou\"\n    result = 0\n    for i in range(len(stdin)):\n        if stdin[i] in vowels:\n            result += 1\n        else:\n            result += 2\n    return str(result % 1000009)"
    },
    {
        "number": 3287,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, coins = stdin.split('\\n')\n    k = int(k)\n    coins = list(map(int, coins.split()))\n\n    total_coins = sum(coins)\n    min_loot = total_coins // 2\n\n    for i in range(k):\n        if coins[i] > min_loot:\n            min_loot = coins[i] - (coins[i] - min_loot) // 2\n\n    return str(min_loot % (10**9 + 7))"
    },
    {
        "number": 3288,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    count = 0\n    for c1 in ascii_lowercase:\n        for c2 in ascii_lowercase:\n            if c1 != c2:\n                for j in range(1, k):\n                    count += 1\n                    if count == n:\n                        return c1 + c2 * j\n    return \"-1\""
    },
    {
        "number": 3289,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    people = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def cluster_size(S, T):\n        people.sort(key=lambda x: x[0] * S + x[1] * T)\n        c_true = False\n        count = 0\n        for a, b, c in people:\n            if c == 1:\n                if not c_true:\n                    count += 1\n                c_true = True\n            else:\n                c_true = False\n        return count\n\n    min_cluster_size = float('inf')\n    for S in range(-1000, 1001):\n        for T in range(-1000, 1001):\n            min_cluster_size = min(min_cluster_size, cluster_size(S, T))\n\n    return str(min_cluster_size)"
    },
    {
        "number": 3290,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, E, D = map(int, stdin.split()[0:3])\n    e_cards = list(map(int, stdin.split()[3:3+E]))\n    d_cards = list(map(int, stdin.split()[3+E:]))\n    \n    # Sort the cards in ascending order\n    e_cards.sort()\n    d_cards.sort()\n    \n    # Initialize the winner as -1\n    winner = -1\n    \n    # Iterate through the players\n    for i in range(N):\n        # Initialize the number of cards in the hand\n        cards_in_hand = 0\n        \n        # Iterate through the cards in the deck\n        for j in range(len(e_cards) + len(d_cards)):\n            # If the current card is an \"Exploding Kitten\" card\n            if j < len(e_cards) and e_cards[j] == j:\n                # If the player has a \"Defuse\" card, discard both cards\n                if cards_in_hand >= 2 and d_cards[cards_in_hand - 2] == j - 1:\n                    cards_in_hand -= 2\n                # Otherwise, the player loses\n                else:\n                    break\n            # If the current card is a \"Defuse\" card\n            elif j < len(d_cards) and d_cards[j] == j:\n                # If the player has a \"Defuse\" card, discard both cards\n                if cards_in_hand >= 2 and d_cards[cards_in_hand - 2] == j - 1:\n                    cards_in_hand -= 2\n                # Otherwise, discard the \"Defuse\" card\n                else:\n                    cards_in_hand -= 1\n            # If the current card is not an \"Exploding Kitten\" or \"Defuse\" card\n            else:\n                cards_in_hand += 1\n            # If the player has more than 5 cards in their hand, discard cards until they have no more than 5 cards\n            while cards_in_hand > 5:\n                cards_in_hand -= 1\n        \n        # If the player has won, update the winner\n        if cards_in_hand == 0:\n            winner = i\n            break\n    \n    return str(winner)"
    },
    {
        "number": 3291,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    c, d = map(int, stdin.split())\n\n    def dfs(start: int, end: int, current: int, visited: set, path: list) -> bool:\n        if current == end:\n            return True\n        visited.add(current)\n        for i in range(n):\n            if i not in visited and i not in path:\n                path.append(i)\n                if dfs(start, end, i, visited, path):\n                    return True\n                path.pop()\n        visited.remove(current)\n        return False\n\n    n = 0\n    splitters = []\n    while True:\n        if dfs(0, -2, -1, set(), []):\n            break\n        n += 1\n        splitters.append((-1, -1))\n\n    if n == 200:\n        return \"200\\n\" + \"\\n\".join(f\"{l} {r}\" for l, r in splitters)\n\n    for i in range(n):\n        if splitters[i][0] == -1:\n            splitters[i] = (0, -2)\n        elif splitters[i][1] == -1:\n            splitters[i] = (-2, 0)\n\n    for i in range(n):\n        if splitters[i][0] == -2:\n            splitters[i] = (0, -1)\n        elif splitters[i][1] == -2:\n            splitters[i] = (-1, 0)\n\n    return f\"{n}\\n\" + \"\\n\".join(f\"{l} {r}\" for l, r in splitters)"
    },
    {
        "number": 3292,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    names = stdin.split('\\n')[1:]\n    n = len(names)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if names[i].startswith(names[j]):\n                dp[i] += dp[j]\n                dp[i] %= 1000000007\n    return str(sum(dp) % 1000000007)"
    },
    {
        "number": 3293,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    snacks = []\n    for i in range(1, n + 1):\n        f, p, m, s = map(int, lines[i].split())\n        snacks.append((f, p, m, s))\n\n    def max_profit(snacks: List[Tuple[int, int, int, int]]) -> int:\n        snacks.sort(key=lambda x: x[1])\n        max_profit = 0\n        for i in range(len(snacks)):\n            f, p, m, s = snacks[i]\n            if s == 0:\n                continue\n            max_profit += (m - p) * s\n            snacks[f - 1] = (f, snacks[f - 1][1], snacks[f - 1][2], snacks[f - 1][3] + s)\n        return max_profit\n\n    return str(max_profit(snacks))"
    },
    {
        "number": 3294,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    contours = []\n    for i in range(1, N+1):\n        height_outside, height_inside, num_vertices = map(int, lines[i].split())\n        vertices = []\n        for j in range(num_vertices):\n            x, y = map(int, lines[i+j].split())\n            vertices.append((x, y))\n        contours.append((height_outside, height_inside, vertices))\n    \n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n    \n    def slope(p1, p2):\n        return (p2[1] - p1[1]) / (p2[0] - p1[0])\n    \n    def is_inside(p, contour):\n        inside = False\n        p1, p2 = contour[0], contour[-1]\n        if p2[0] <= p[0]:\n            return inside\n        for i in range(len(contour)-1):\n            p1, p2 = contour[i], contour[i+1]\n            if p1[0] <= p[0] < p2[0]:\n                if p[1] < slope(p1, p2) * (p[0] - p1[0]) + p1[1]:\n                    inside = not inside\n        return inside\n    \n    def closest_distance(contours):\n        min_distance = float('inf')\n        for i in range(len(contours)):\n            for j in range(len(contours)):\n                if i == j:\n                    continue\n                for p1 in contours[i][2]:\n                    for p2 in contours[j][2]:\n                        if p1 == p2:\n                            continue\n                        d = distance(p1, p2)\n                        if d < min_distance:\n                            min_distance = d\n        return min_distance\n    \n    min_distance = closest_distance(contours)\n    return str(min_distance)"
    },
    {
        "number": 3295,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def happy_numbers(n: int) -> int:\n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = sum(int(digit)**2 for digit in str(n))\n        return n == 1\n\n    def find_array(K: int, L: int, M: int) -> int:\n        happy_count = 0\n        for i in range(1, K + 1):\n            if is_prime(i) or i <= M:\n                happy_count += 1\n        if happy_count < L:\n            return -1\n        for i in range(1, K + 1):\n            if happy_count == L:\n                return i\n            if is_prime(i) or i <= M:\n                happy_count -= 1\n\n    stdin = stdin.strip()\n    Q = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, Q + 1):\n        K, L, M = map(int, stdin.split('\\n')[i].split())\n        result.append(find_array(K, L, M))\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3296,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K > 2**31 - 1:\n        return str(1)\n    if N == 1:\n        return str(1)\n    if K == 1:\n        return str(1)\n    if K == N:\n        return str(1)\n    if K == 2:\n        return str(N)\n    if K == 3:\n        return str(N * (N - 1) // 2)\n    if K > N:\n        return str(0)\n    return str((K - 1) * solution(str(N - 1) + \" \" + str(K - 1)))"
    },
    {
        "number": 3297,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split(\"+\")\n    result = words[2]\n    letters = set(words[0] + words[1])\n    digits = [str(i) for i in range(10)]\n    mapping = {}\n\n    for letter in letters:\n        for digit in digits:\n            if digit not in mapping.values() and (letter == words[0][0] or digit != \"0\"):\n                mapping[letter] = digit\n                digits.remove(digit)\n                break\n\n    if len(mapping) != len(letters):\n        return \"impossible\"\n\n    for word in words:\n        result = result.translate(str.maketrans(mapping))\n\n    return result\n\ndef"
    },
    {
        "number": 3298,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split()\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n\n    def is_sorted(sequence: List[int]) -> bool:\n        for i in range(len(sequence)):\n            if not all(sequence[j] <= sequence[i] for j in range(i)):\n                return False\n        return True\n\n    def count_entirely_unsorted(sequence: List[int]) -> int:\n        count = 0\n        for i in range(len(sequence)):\n            if not is_sorted(sequence[:i] + sequence[i+1:]):\n                count += 1\n        return count\n\n    return str(count_entirely_unsorted(sequence) % (10**9 + 9))"
    },
    {
        "number": 3299,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_checkerboard(board: List[List[int]]) -> bool:\n        n, m = len(board), len(board[0])\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == 0:\n                    return False\n                if i > 0 and board[i][j] <= board[i - 1][j]:\n                    return False\n                if j > 0 and board[i][j] <= board[i][j - 1]:\n                    return False\n        return True\n\n    def fill_checkerboard(board: List[List[int]]) -> int:\n        n, m = len(board), len(board[0])\n        min_sum = sum(sum(row) for row in board)\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == 0:\n                    for k in range(1, 2001):\n                        board[i][j] = k\n                        if is_valid_checkerboard(board):\n                            new_sum = fill_checkerboard(board)\n                            if new_sum < min_sum:\n                                min_sum = new_sum\n                        board[i][j] = 0\n        return min_sum\n\n    n, m = map(int, stdin.split()[0].split())\n    board = [list(map(int, input().split())) for _ in range(n)]\n\n    if is_valid_checkerboard(board):\n        return str(fill_checkerboard(board))\n    else:\n        return \"-1\""
    },
    {
        "number": 3300,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    cheetahs = []\n    for i in range(1, N+1):\n        t, v = map(int, lines[i].split())\n        cheetahs.append((t, v))\n    \n    cheetahs.sort(key=lambda x: x[0])\n    min_length = float('inf')\n    for i in range(1, N):\n        t1, v1 = cheetahs[i-1]\n        t2, v2 = cheetahs[i]\n        length = (t2 - t1) * ((v1 + v2) / 2)\n        min_length = min(min_length, length)\n    \n    return f\"{min_length:.3f}\""
    },
    {
        "number": 3301,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P, X, Y = map(int, stdin.split()[:4])\n    partnerships = []\n    for _ in range(P):\n        a, b, c = map(int, stdin.split()[4:])\n        partnerships.append((a, b, c))\n\n    M = int(stdin.split()[4 + P])\n    banks = list(map(int, stdin.split()[5 + P:]))\n\n    def find_path(start, end, visited, path):\n        if start == end:\n            return path\n        for i in range(len(partnerships)):\n            a, b, c = partnerships[i]\n            if a in visited and b not in visited:\n                new_path = find_path(b, end, visited | {b}, path + [(a, b, c)])\n                if new_path:\n                    return new_path\n            elif b in visited and a not in visited:\n                new_path = find_path(a, end, visited | {a}, path + [(a, b, c)])\n                if new_path:\n                    return new_path\n        return None\n\n    def find_max_fee(path):\n        max_fee = 0\n        for a, b, c in path:\n            max_fee += c\n        return max_fee\n\n    path = find_path(X, Y, {X}, [])\n    if path:\n        max_fee = find_max_fee(path)\n        return str(max_fee)\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3302,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split()[:2])\n    P = set(map(int, stdin.split()[2:]))\n    \n    if n == 1:\n        return \"0\\n\" if 1 in P else \"impossible\"\n    \n    if n == 2:\n        if 1 in P and 2 in P:\n            return \"00\\n01\\n11\\n10\\n\"\n        elif 1 in P:\n            return \"00\\n01\\n10\\n\"\n        elif 2 in P:\n            return \"00\\n11\\n10\\n\"\n        else:\n            return \"impossible\"\n    \n    if n == 3:\n        if 1 in P and 2 in P:\n            return \"000\\n001\\n011\\n010\\n110\\n111\\n101\\n100\\n\"\n        elif 1 in P:\n            return \"000\\n001\\n010\\n110\\n111\\n101\\n100\\n\"\n        elif 2 in P:\n            return \"000\\n011\\n010\\n111\\n110\\n101\\n100\\n\"\n        else:\n            return \"impossible\"\n    \n    if n == 4:\n        if 1 in P and 2 in P:\n            return \"0000\\n0001\\n0011\\n0010\\n0110\\n0111\\n0101\\n0100\\n1100\\n1101\\n1111\\n1110\\n1011\\n1010\\n1001\\n1000\\n\"\n        elif 1 in P:\n            return \"0000\\n0001\\n0010\\n0110\\n0111\\n0101\\n0100\\n1100\\n1101\\n1111\\n1110\\n1011\\n1010\\n1001\\n1000\\n\"\n        elif 2 in P:\n            return \"0000\\n0111\\n0110\\n1111\\n1110\\n1011\\n1010\\n1001\\n1000\\n\"\n        else:\n            return \"impossible\"\n    \n    if n == 5:\n        if 1 in P and 2 in P:\n            return \"00000\\n00001\\n00011\\n00010\\n00110\\n00111\\n00101\\n00100\\n01100\\n01101\\n01111\\n01110\\n01011\\n01010\\n01001\\n01000\\n11000\\n11001\\n11011\\n11010\\n11110\\n11111\\n11101\\n11100\\n10110\\n10111\\n10101\\n10100\\n10011\\n10010\\n10001\\n10000\\n\"\n        elif 1 in P:\n            return \"00000\\n00001\\n00010\\n00110\\n00111\\n00101\\n00100\\n01100\\n01101\\n01111\\n01110\\n01011\\n01010\\n01001\\n01000\\n11000"
    },
    {
        "number": 3303,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num1, num2 = map(int, stdin.split())\n    steps = 0\n    while num2 != 0:\n        num1, num2 = num1 + 1, num2 - 1\n        steps += 1\n    return str(steps)"
    },
    {
        "number": 3304,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, adversaries, dwarves, elves = stdin.split('\\n')\n    N = int(N)\n    adversaries = list(map(int, adversaries.split()))\n    dwarves = list(map(int, dwarves.split()))\n    elves = list(map(int, elves.split()))\n\n    # Calculate the maximum number of victories\n    max_victories = 0\n    for i in range(N):\n        elf_strength = elves[i]\n        dwarf_strength = dwarves[adversaries[i] - 1]\n        if elf_strength > dwarf_strength:\n            max_victories += 1\n\n    return str(max_victories)"
    },
    {
        "number": 3305,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split()[:2])\n    S = stdin.split()[2]\n    Q_list = []\n    for i in range(Q):\n        L, R = map(int, stdin.split()[2+i].split())\n        Q_list.append((L, R))\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def is_almost_palindrome(s: str) -> bool:\n        for i in range(len(s)):\n            if s[i] != s[len(s) - i - 1]:\n                return True\n        return False\n\n    def count_almost_palindromes(s: str, L: int, R: int) -> int:\n        count = 0\n        for i in range(L, R + 1):\n            for j in range(i + 1, R + 1):\n                if is_palindrome(s[i:j]) or is_almost_palindrome(s[i:j]):\n                    count += 1\n        return count\n\n    result = []\n    for L, R in Q_list:\n        result.append(count_almost_palindromes(S, L, R))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3306,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N, M = map(int, lines[0].split())\n    detectors = []\n\n    for i in range(1, N + 1):\n        P, C = map(int, lines[i].split())\n        detectors.append((P, C))\n\n    detectors.sort(key=lambda x: x[0])\n    detectors.append((M + 1, 0))\n\n    total_calls = 0\n    for i in range(N):\n        total_calls += detectors[i][1]\n\n    return str(total_calls)"
    },
    {
        "number": 3307,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(x, y, polygon):\n        n = len(polygon)\n        inside = False\n        p1x, p1y = polygon[0]\n        for i in range(1, n + 1):\n            p2x, p2y = polygon[i % n]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xinters:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def area(polygon):\n        n = len(polygon)\n        area = 0.0\n        for i in range(n):\n            j = (i + 1) % n\n            area += polygon[i][0] * polygon[j][1]\n            area -= polygon[j][0] * polygon[i][1]\n        return abs(area) / 2.0\n\n    def largest_corn_area(polygon, canal):\n        x_a, y_a, x_b, y_b = canal\n        max_area = 0.0\n        for i in range(len(polygon)):\n            for j in range(i + 1, len(polygon)):\n                p1, p2 = polygon[i], polygon[j]\n                if is_inside(x_a, y_a, [p1, p2]) or is_inside(x_b, y_b, [p1, p2]):\n                    continue\n                if is_inside(x_a, y_a, [p1, p2, (x_a, y_a)]) or is_inside(x_b, y_b, [p1, p2, (x_b, y_b)]):\n                    continue\n                if is_inside(x_a, y_a, [p1, p2, (x_a, y_a), (x_b, y_b)]) or is_inside(x_b, y_b, [p1, p2, (x_a, y_a), (x_b, y_b)]):\n                    continue\n                if is_inside(x_a, y_a, [p1, p2, (x_a, y_a), (x_b, y_b), (x_a, y_a)]) or is_inside(x_b, y_b, [p1, p2, (x_a, y_a), (x_b, y_b), (x_b, y_b)]):\n                    continue\n                if is_inside(x_a, y_a, [p1, p2, (x_a, y_a), (x_b, y_b), (x_a, y_a), (x_b, y_b)]) or is_inside(x_b, y_b, [p1, p2, (x_a, y_a), (x_b, y_b), (x_a, y_a), (x_b, y_b)]):\n                    continue\n                if is_inside(x_a, y_a, [p1, p2, (x_a, y_a), (x_b, y_b), (x_a, y_a), (x_b, y_b), (x_a, y_a)]) or is_inside(x_b, y_b, [p1, p2, (x_a, y_a), (x_b, y_b), (x_a, y_a), (x_b, y_b), (x_b, y_b)]):\n                    continue\n                if is_inside(x_a, y_a, [p1, p2, (x_a, y_a), (x_b, y_b), (x_a, y_a), (x_b, y_b), (x_a, y_a), (x_b"
    },
    {
        "number": 3308,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import math\n\n    def is_inside(point, polygon):\n        n = len(polygon)\n        inside = False\n        p1x, p1y = polygon[0]\n        for i in range(1, n + 1):\n            p2x, p2y = polygon[i % n]\n            if (p1y > point[1]) != (p2y > point[1]):\n                if point[0] < (p2x - p1x) * (point[1] - p1y) / (p2y - p1y) + p1x:\n                    inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def area(polygon):\n        n = len(polygon)\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            area += polygon[i][0] * polygon[j][1]\n            area -= polygon[j][0] * polygon[i][1]\n        return abs(area) / 2\n\n    n = int(stdin.readline())\n    polygon = []\n    for i in range(n):\n        x, y = map(float, stdin.readline().split())\n        polygon.append((x, y))\n\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                a = area([polygon[i], polygon[j], polygon[k]])\n                if a > max_area:\n                    max_area = a\n\n    result = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                a = area([polygon[i], polygon[j], (0, 0)])\n                if a > max_area:\n                    result += a\n\n    return f\"{result:.4f}\""
    },
    {
        "number": 3309,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, C = map(int, stdin.split()[:3])\n    teams = list(map(int, stdin.split()[3:]))\n\n    max_media_companies = 0\n    for i in range(N - K + 1):\n        colors = set()\n        for j in range(i, i + K):\n            colors.add(teams[j])\n        if len(colors) >= C:\n            max_media_companies += 1\n\n    return str(max_media_companies)"
    },
    {
        "number": 3310,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, g, t, capacities = stdin.split()\n    n, g, t = int(n), int(g), int(t)\n    capacities = list(map(int, capacities.split()))\n    \n    def expected_occupancy(t: int) -> float:\n        total_capacity = sum(capacities)\n        expected_occupancy = 0\n        for i in range(1, g+1):\n            expected_occupancy += i * (1 - (total_capacity - sum(capacities)) / total_capacity)\n        return expected_occupancy\n    \n    occupancy = expected_occupancy(t)\n    return f\"{occupancy:.6f}\""
    },
    {
        "number": 3311,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    exponential = n\n    for i in range(n-1, 1, -1):\n        exponential = pow(exponential, i, m)\n    return str(exponential)"
    },
    {
        "number": 3312,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, E, X_S, Y_S, C = map(int, stdin.split()[:5])\n    cans = []\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            X, Y, CT = map(int, line.split())\n            cans.append((X, Y, CT))\n\n    def get_score(energy: int, cans: List[Tuple[int, int, int]]) -> int:\n        score = 0\n        for can in cans:\n            if can[2] <= energy:\n                score += 1\n                energy += can[2]\n        return score\n\n    cans.sort(key=lambda x: x[2])\n    max_score = 0\n    for energy in range(E, -1, -1):\n        max_score = max(max_score, get_score(energy, cans))\n\n    return str(max_score)"
    },
    {
        "number": 3313,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, w, h = map(int, stdin.split()[:4])\n    gems = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    max_gems = 0\n    for gem in gems:\n        x, y = gem\n        if y == h:\n            max_gems += 1\n        else:\n            max_gems += min(1, (h - y) // (r * (w - x)))\n    \n    return str(max_gems)"
    },
    {
        "number": 3314,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_wheel(wheel: list, direction: str) -> list:\n        if direction == 'right':\n            return wheel[-1:] + wheel[:-1]\n        else:\n            return wheel[1:] + wheel[:1]\n\n    def is_valid_configuration(wheels: list) -> bool:\n        for i in range(len(wheels[0])):\n            if len(set([w[i] for w in wheels])) != 3:\n                return False\n        return True\n\n    wheels = [list(w) for w in stdin.split('\\n')]\n    rotations = 0\n\n    while not is_valid_configuration(wheels):\n        for i in range(len(wheels)):\n            wheels[i] = rotate_wheel(wheels[i], 'right')\n            rotations += 1\n\n    return rotations if is_valid_configuration(wheels) else -1"
    },
    {
        "number": 3315,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def longest_subsequence(strings: List[str]) -> int:\n        n = len(strings)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if strings[i].startswith(strings[j]) and strings[i].endswith(strings[j]):\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    strings = lines[1:]\n    return str(longest_subsequence(strings))"
    },
    {
        "number": 3316,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, t, p = map(int, stdin.split())\n    if p > m:\n        return \"0\"\n    if p > n * t:\n        return \"0\"\n    if p <= n:\n        return \"1\"\n    if p <= n * t:\n        return str(1 - (m - p) / (m - n))\n    return \"0\""
    },
    {
        "number": 3317,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    q = int(input())\n    for _ in range(q):\n        i, j = map(int, input().split())\n        longest_sequence = 0\n        for k in range(i, len(s)):\n            if s[k] == s[j]:\n                sequence_length = 1\n                while k + 1 < len(s) and j + 1 < len(s) and s[k + 1] == s[j + 1]:\n                    sequence_length += 1\n                    k += 1\n                    j += 1\n                longest_sequence = max(longest_sequence, sequence_length)\n            else:\n                break\n        print(longest_sequence)"
    },
    {
        "number": 3318,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.split()[0:2])\n    graph = [[] for _ in range(N)]\n    for i in range(1, N):\n        x = int(stdin.split()[i])\n        graph[x].append(i)\n        graph[i].append(x)\n\n    def dfs(node, visited, distance):\n        if distance > D:\n            return 0\n        if visited[node]:\n            return 0\n        visited[node] = True\n        return 1 + sum(dfs(child, visited, distance + 1) for child in graph[node])\n\n    max_marked = 0\n    for i in range(N):\n        max_marked = max(max_marked, dfs(i, [False] * N, 0))\n\n    return str(max_marked)"
    },
    {
        "number": 3319,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_input() -> Tuple[int, int, int, int]:\n        line = input().split()\n        return int(line[0]), int(line[1]), int(line[2]), int(line[3])\n\n    def get_planetoids(n: int) -> List[Tuple[int, int, int, int, int, int]]:\n        planetoids = []\n        for _ in range(n):\n            line = input().split()\n            m, x, y, z, vx, vy, vz = int(line[0]), int(line[1]), int(line[2]), int(line[3]), int(line[4]), int(line[5]), int(line[6])\n            planetoids.append((m, x, y, z, vx, vy, vz))\n        return planetoids\n\n    def get_collision(planetoid1: Tuple[int, int, int, int, int, int], planetoid2: Tuple[int, int, int, int, int, int]) -> Tuple[int, int, int, int, int, int]:\n        m1, x1, y1, z1, vx1, vy1, vz1 = planetoid1\n        m2, x2, y2, z2, vx2, vy2, vz2 = planetoid2\n        m = m1 + m2\n        x = (x1 * m1 + x2 * m2) // m\n        y = (y1 * m1 + y2 * m2) // m\n        z = (z1 * m1 + z2 * m2) // m\n        vx = (vx1 * m1 + vx2 * m2) // m\n        vy = (vy1 * m1 + vy2 * m2) // m\n        vz = (vz1 * m1 + vz2 * m2) // m\n        return m, x, y, z, vx, vy, vz\n\n    def get_planets(planetoids: List[Tuple[int, int, int, int, int, int]]) -> List[Tuple[int, int, int, int, int, int]]:\n        planets = []\n        for planetoid in planetoids:\n            planets.append(planetoid)\n\n        while True:\n            collisions = []\n            for i in range(len(planets)):\n                for j in range(i + 1, len(planets)):\n                    if planets[i][1] == planets[j][1] and planets[i][2] == planets[j][2] and planets[i][3] == planets[j][3]:\n                        collisions.append((i, j))\n\n            if not collisions:\n                break\n\n            for i, j in collisions:\n                planetoid1 = planets[i]\n                planetoid2 = planets[j]\n                m, x, y, z, vx, vy, vz = get_collision(planetoid1, planetoid2)\n                planets[i] = (m, x, y, z, vx, vy, vz)\n                planets.pop(j)\n\n        return planets\n\n    n, nx, ny, nz = get_input()\n    planetoids = get_planetoids(n)\n    planets = get_planets(planetoids)\n\n    output = f\"{len(planets)}\\n\"\n    for i, planet in enumerate(planets):\n        m, x, y, z, vx, vy, vz = planet\n        output += f\"P{i}: {m} {x} {y} {z} {vx} {vy} {vz}\\n\"\n\n    return output"
    },
    {
        "number": 3320,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bitwise_or(a, b):\n        return bin(a | b).count('1')\n\n    def find_path(start, end, visited, graph):\n        if start == end:\n            return 0\n        visited[start] = True\n        min_distance = float('inf')\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                distance = find_path(neighbor, end, visited, graph)\n                if distance != float('inf'):\n                    min_distance = min(min_distance, distance)\n        visited[start] = False\n        return min_distance\n\n    def process_input(input_str: str) -> tuple:\n        lines = input_str.split('\\n')\n        n, m = map(int, lines[0].split())\n        graph = [[] for _ in range(n + 1)]\n        for i in range(1, m + 1):\n            a, b, w = map(int, lines[i].split())\n            graph[a].append((b, w))\n            graph[b].append((a, w))\n        q = int(lines[m + 1])\n        queries = []\n        for i in range(m + 2, m + 2 + q):\n            s, t = map(int, lines[i].split())\n            queries.append((s, t))\n        return n, graph, queries\n\n    input_str = stdin\n    n, graph, queries = process_input(input_str)\n    result = []\n    for s, t in queries:\n        visited = [False] * (n + 1)\n        distance = find_path(s, t, visited, graph)\n        result.append(distance)\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3321,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    starting_sequence = list(map(int, lines[1].split()))\n    resulting_sequence = list(map(int, lines[2].split()))\n\n    # Create a dictionary to store the index of each frog in the starting sequence\n    frog_index = {frog: index for index, frog in enumerate(starting_sequence)}\n\n    # Create a list to store the proclamations\n    proclamations = []\n\n    # Iterate through the resulting sequence\n    for frog in resulting_sequence:\n        # Calculate the number of leaps needed to move the frog to its correct position\n        leaps = abs(frog_index[frog] - frog_index[resulting_sequence[(frog_index[frog] + 1) % n]])\n\n        # Add the number of leaps to the proclamations list\n        proclamations.append(leaps)\n\n        # Update the index of the frog in the starting sequence\n        frog_index[frog] = (frog_index[frog] + leaps) % n\n\n    # Return the proclamations list\n    return \"\\n\".join(map(str, proclamations))"
    },
    {
        "number": 3322,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0].split())\n    shops = [{} for _ in range(m)]\n    for i in range(n):\n        a, p, b, q = map(int, stdin.split('\\n')[i].split())\n        shops[a-1][i+1] = p\n        shops[b-1][i+1] = q\n\n    def dfs(cost: int, visited: int, current_shop: int, current_items: set) -> int:\n        if visited == k:\n            return cost\n        if len(current_items) == n:\n            return cost\n\n        min_cost = float('inf')\n        for i in range(m):\n            if i not in visited:\n                for item in shops[i]:\n                    if item not in current_items:\n                        min_cost = min(min_cost, dfs(cost + shops[i][item], visited | {i}, i, current_items | {item}))\n\n        return min_cost\n\n    min_cost = dfs(0, set(), 0, set())\n    return str(min_cost) if min_cost != float('inf') else '-1'"
    },
    {
        "number": 3323,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_people(people: List[List[int]]) -> int:\n        def get_max_fraction(fraction: List[int]) -> int:\n            return max(fraction)\n\n        max_fraction = [0, 0, 0]\n        for person in people:\n            max_fraction[0] = max(max_fraction[0], get_max_fraction(person))\n            max_fraction[1] = max(max_fraction[1], get_max_fraction(person))\n            max_fraction[2] = max(max_fraction[2], get_max_fraction(person))\n\n        return max_fraction\n\n    def parse_input(input_str: str) -> List[List[int]]:\n        lines = input_str.split(\"\\n\")\n        people = []\n        for line in lines[1:]:\n            if line:\n                person = list(map(int, line.split()))\n                people.append(person)\n        return people\n\n    def main() -> None:\n        test_cases = int(stdin.readline())\n        for i in range(1, test_cases + 1):\n            n = int(stdin.readline())\n            people = parse_input(stdin.read(n))\n            max_fraction = get_max_fraction(people)\n            print(f\"Case #{i}: {max_fraction}\")\n\n    main()"
    },
    {
        "number": 3324,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split('\\n')\n    left_side = []\n    right_side = []\n    for line in lines:\n        if line == '0 0':\n            break\n        sign, num_elements, *elements_counts = line.split()\n        sign = int(sign)\n        num_elements = int(num_elements)\n        elements_counts = [int(count) for count in elements_counts]\n        if sign == 1:\n            left_side.append((elements_counts, num_elements))\n        else:\n            right_side.append((elements_counts, num_elements))\n    \n    # Calculate coefficients\n    coefficients = []\n    for i in range(len(left_side)):\n        coefficients.append(1)\n    for i in range(len(right_side)):\n        coefficients.append(1)\n    \n    # Balance equation\n    while True:\n        # Check if coefficients are valid\n        valid = True\n        for i in range(len(coefficients)):\n            if coefficients[i] == 0:\n                valid = False\n                break\n        if valid:\n            break\n        \n        # Find least common multiple\n        lcm = 1\n        for i in range(len(coefficients)):\n            lcm = lcm * coefficients[i] // math.gcd(lcm, coefficients[i])\n        \n        # Divide coefficients by least common multiple\n        for i in range(len(coefficients)):\n            coefficients[i] //= lcm\n    \n    # Output coefficients\n    return ' '.join(str(coefficient) for coefficient in coefficients)"
    },
    {
        "number": 3325,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D, L = map(int, stdin.splitlines()[0].split())\n    vertices = [tuple(map(int, line.split())) for line in stdin.splitlines()[2:]]\n    \n    # Calculate the area of the polygon\n    area = 0\n    for i in range(N):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % N]\n        area += x1 * y2 - x2 * y1\n    area = abs(area) / 2\n    \n    # Calculate the volume of the water\n    volume = L * 1000\n    \n    # Calculate the height of the water\n    height = (volume / area) * D\n    \n    return f\"{height:.2f}\""
    },
    {
        "number": 3326,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[0].split())\n    grid = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_monotonic(subgrid: List[List[int]]) -> bool:\n        for row in subgrid:\n            if all(row[i] < row[i + 1] for i in range(len(row) - 1)) or all(row[i] > row[i + 1] for i in range(len(row) - 1)):\n                continue\n            return False\n        for col in range(len(subgrid[0])):\n            if all(subgrid[i][col] < subgrid[i + 1][col] for i in range(len(subgrid) - 1)) or all(subgrid[i][col] > subgrid[i + 1][col] for i in range(len(subgrid) - 1)):\n                continue\n            return False\n        return True\n\n    def count_monotonic_subgrids(grid: List[List[int]]) -> int:\n        count = 0\n        for row in range(r):\n            for col in range(c):\n                for subgrid_size in range(1, min(r - row, c - col) + 1):\n                    subgrid = [grid[i][j:j + subgrid_size] for i in range(row, row + subgrid_size)]\n                    if is_monotonic(subgrid):\n                        count += 1\n        return count\n\n    return str(count_monotonic_subgrids(grid))"
    },
    {
        "number": 3327,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(word: str, row: int, col: int, direction: str) -> bool:\n        if direction == \"h\":\n            for i in range(len(word)):\n                if grid[row][col + i] != \"#\" and grid[row][col + i] != word[i]:\n                    return False\n            return True\n        else:\n            for i in range(len(word)):\n                if grid[row + i][col] != \"#\" and grid[row + i][col] != word[i]:\n                    return False\n            return True\n\n    def place_word(word: str, row: int, col: int, direction: str) -> None:\n        if direction == \"h\":\n            for i in range(len(word)):\n                grid[row][col + i] = word[i]\n        else:\n            for i in range(len(word)):\n                grid[row + i][col] = word[i]\n\n    def backtrack(words: List[str], index: int) -> bool:\n        if index == len(words):\n            return True\n        word = words[index]\n        for row in range(R):\n            for col in range(C):\n                if grid[row][col] == \"#\":\n                    for direction in [\"h\", \"v\"]:\n                        if is_valid(word, row, col, direction):\n                            place_word(word, row, col, direction)\n                            if backtrack(words, index + 1):\n                                return True\n                            place_word(word, row, col, direction)\n        return False\n\n    R, C = map(int, stdin.split()[0].split())\n    grid = [list(stdin.split()[1]) for _ in range(R)]\n    N = int(stdin.split()[2])\n    words = stdin.split()[3:]\n\n    backtrack(words, 0)\n\n    for row in grid:\n        print(\"\".join(row))"
    },
    {
        "number": 3328,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    table = [list(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    \n    def is_valid(x, y):\n        for i in range(x, x+2):\n            for j in range(y, y+2):\n                if i < 0 or i >= N or j < 0 or j >= N:\n                    return False\n        return True\n    \n    def dfs(x, y, visited):\n        if not is_valid(x, y) or (x, y) in visited:\n            return 0\n        visited.add((x, y))\n        return table[x][y] + dfs(x+1, y, visited) + dfs(x-1, y, visited) + dfs(x, y+1, visited) + dfs(x, y-1, visited)\n    \n    def cover_table(x, y, visited):\n        if not is_valid(x, y) or (x, y) in visited:\n            return 0\n        visited.add((x, y))\n        return dfs(x, y, set())\n    \n    def find_min_sum(K):\n        min_sum = float('inf')\n        for i in range(N):\n            for j in range(N):\n                visited = set()\n                sum_covered = cover_table(i, j, visited)\n                if len(visited) == K and sum_covered < min_sum:\n                    min_sum = sum_covered\n        return min_sum\n    \n    return str(find_min_sum(K))"
    },
    {
        "number": 3329,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    original_circle = stdin.split()[1]\n\n    def count_starting_circles(circle: str) -> int:\n        starting_circles = set()\n        for i in range(len(circle)):\n            starting_circles.add(circle[i:] + circle[:i])\n        return len(starting_circles)\n\n    def transform_circle(circle: str) -> str:\n        transformed_circle = \"\"\n        for i in range(len(circle)):\n            if i == 0:\n                transformed_circle += circle[i]\n            elif circle[i] == circle[i - 1]:\n                transformed_circle += \"B\"\n            else:\n                transformed_circle += \"W\"\n        return transformed_circle\n\n    transformed_circle = original_circle\n    for _ in range(K):\n        transformed_circle = transform_circle(transformed_circle)\n\n    return str(count_starting_circles(transformed_circle))"
    },
    {
        "number": 3330,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2*N]))\n    c = list(map(int, stdin.split()[2*N:]))\n    \n    total_potatoes = sum(a)\n    total_price = sum(c)\n    \n    min_product = float('inf')\n    \n    for i in range(1, total_potatoes - L + 1):\n        for j in range(1, total_potatoes - i - L + 1):\n            potatoes_in_store1 = i\n            potatoes_in_store2 = total_potatoes - i - j\n            price_in_store1 = total_price / (potatoes_in_store1 + potatoes_in_store2)\n            price_in_store2 = total_price / (potatoes_in_store1 + potatoes_in_store2)\n            product = price_in_store1 * price_in_store2\n            min_product = min(min_product, product)\n    \n    return f\"{min_product:.3f}\""
    },
    {
        "number": 3331,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, P = map(int, stdin.split())\n    if A == P or B == P:\n        return \"0\"\n\n    if A == B:\n        return str(abs(A - P) + abs(B - P))\n\n    if A < B:\n        return str(max(abs(A - P) + abs(B - P), abs(A - P) + abs(P - B)))\n    else:\n        return str(max(abs(A - P) + abs(B - P), abs(B - P) + abs(P - A)))"
    },
    {
        "number": 3332,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    streams = []\n    for i in range(n):\n        s, d, p = map(int, stdin.split()[1:])\n        streams.append((s, d, p))\n\n    streams.sort(key=lambda x: x[0])\n    stack = []\n    priority = 0\n\n    for s, d, p in streams:\n        while stack and stack[-1][0] < s:\n            _, _, p_pop = stack.pop()\n            priority -= p_pop\n\n        if stack and stack[-1][0] == s:\n            stack.append((s, d, p))\n        else:\n            stack.append((s, d, p))\n            priority += p\n\n    return str(priority)"
    },
    {
        "number": 3333,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    roost_x, roost_y = map(float, stdin.split()[:2])\n    hiding_spots = int(stdin.split()[2])\n    hiding_spots_coords = [tuple(map(float, line.split())) for line in stdin.split('\\n')[3:-1]]\n\n    def distance(point1, point2):\n        return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5\n\n    def min_distance(roost, hiding_spots):\n        min_dist = float('inf')\n        for spot in hiding_spots:\n            dist = distance(roost, spot)\n            if dist < min_dist:\n                min_dist = dist\n        return min_dist\n\n    return str(min_distance((roost_x, roost_y), hiding_spots_coords))"
    },
    {
        "number": 3334,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    distance_table = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    total_distance = 0\n    total_signs = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_distance += distance_table[i][j - i - 1]\n            total_signs += 1\n\n    if total_signs == 0:\n        return \"impossible\"\n\n    return round(total_distance / total_signs, 9)"
    },
    {
        "number": 3335,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n):\n        for b in range(a, n):\n            c = (a**2 + b**2)**0.5\n            if c == int(c) and a <= b:\n                count += 1\n    return str(count)"
    },
    {
        "number": 3336,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    pupils = []\n    for i in range(1, n+1):\n        height, gender, music, sport = lines[i].split()\n        pupils.append((int(height), gender, music, sport))\n\n    max_pupils = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            height_diff = abs(pupils[i][0] - pupils[j][0])\n            same_gender = pupils[i][1] == pupils[j][1]\n            different_music = pupils[i][2] != pupils[j][2]\n            same_sport = pupils[i][3] == pupils[j][3]\n\n            if height_diff > 40 and not same_gender and different_music and not same_sport:\n                max_pupils += 1\n\n    return str(max_pupils)"
    },
    {
        "number": 3337,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def operation_1(stack: list, value: int) -> None:\n        stack.append(value)\n\n    def operation_2(stack: list) -> int:\n        return stack.pop()\n\n    def operation_3(stack1: list, stack2: list) -> int:\n        return len(set(stack1) & set(stack2))\n\n    stacks = [[] for _ in range(5)]\n    output = []\n\n    for line in stdin.split('\\n'):\n        if not line:\n            continue\n\n        operation, *args = line.split()\n        args = list(map(int, args))\n\n        if operation == 'a':\n            operation_1(stacks[args[0]], args[1])\n        elif operation == 'b':\n            output.append(operation_2(stacks[args[0]]))\n        elif operation == 'c':\n            output.append(operation_3(stacks[args[0]], stacks[args[1]]))\n\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3338,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    partners = []\n    for i in range(n):\n        g, p, g_a, p_a = map(int, stdin.split()[4*i:4*(i+1)])\n        partners.append((g, p, g_a, p_a))\n\n    def is_favorable(x, y):\n        return x[0] > y[0] and x[1] > y[1]\n\n    def diversity(partners):\n        return len(set(partners))\n\n    def awaken_partners(partners, k):\n        awaken_partners = []\n        for i in range(len(partners)):\n            if partners[i][2] > 0:\n                awaken_partners.append((partners[i][2], partners[i][3]))\n        awaken_partners.sort(reverse=True)\n        return awaken_partners[:k]\n\n    def max_diversity(partners, k):\n        awaken_partners = awaken_partners(partners, k)\n        diversities = []\n        for i in range(len(awaken_partners)):\n            for j in range(i+1, len(awaken_partners)):\n                if not is_favorable(awaken_partners[i], awaken_partners[j]):\n                    diversities.append(diversity(awaken_partners[:i] + awaken_partners[j:]))\n        return max(diversities)\n\n    return str(max_diversity(partners, k))"
    },
    {
        "number": 3339,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split()[2:]]\n    \n    # Count the number of roads at each intersection\n    intersection_roads = [0] * (N + 1)\n    for a, b in roads:\n        intersection_roads[a] += 1\n        intersection_roads[b] += 1\n    \n    # Count the number of intersections with odd number of roads\n    odd_intersections = sum(1 for count in intersection_roads if count % 2 == 1)\n    \n    # Calculate the number of ways to make all intersections even\n    result = 1\n    for i in range(odd_intersections):\n        result = (result * (i + 1)) % 1000000009\n    \n    return str(result)"
    },
    {
        "number": 3340,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    flights = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def count_changes(flights: List[Tuple[int, int]]) -> int:\n        graph = {i: set() for i in range(1, n + 1)}\n        for a, b in flights:\n            graph[a].add(b)\n            graph[b].add(a)\n\n        def dfs(node: int, visited: Set[int], count: int) -> int:\n            if node in visited:\n                return count\n            visited.add(node)\n            for neighbor in graph[node]:\n                count = dfs(neighbor, visited, count)\n            return count\n\n        max_count = 0\n        for i in range(1, n + 1):\n            max_count = max(max_count, dfs(i, set(), 0))\n        return max_count\n\n    min_changes = count_changes(flights)\n    for i in range(n - 1):\n        for j in range(i + 1, n - 1):\n            new_flights = flights[:i] + flights[i + 1:j] + flights[j + 1:]\n            changes = count_changes(new_flights)\n            if changes < min_changes:\n                min_changes = changes\n                cancel_flight = (i + 1, j + 1)\n                new_flight = (cancel_flight[0], cancel_flight[1] - 1)\n\n    return str(min_changes) + '\\n' + ' '.join(map(str, cancel_flight)) + '\\n' + ' '.join(map(str, new_flight))"
    },
    {
        "number": 3341,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[:2])\n    producers = []\n    consumers = []\n\n    for i in range(m):\n        p, d = map(int, stdin.split()[:2])\n        producers.append((p, d))\n\n    for j in range(n):\n        q, e = map(int, stdin.split()[:2])\n        consumers.append((q, e))\n\n    max_profit = 0\n    for i in range(m):\n        for j in range(n):\n            profit = 0\n            start_date = max(producers[i][1], consumers[j][1])\n            end_date = min(producers[i][1] + consumers[j][2], producers[i][1] + 365)\n\n            for day in range(start_date, end_date):\n                profit += producers[i][0] - consumers[j][0]\n\n            max_profit = max(max_profit, profit)\n\n    return str(max_profit)"
    },
    {
        "number": 3342,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.readline().split())\n    onions = []\n    for _ in range(N):\n        onions.append(tuple(map(int, stdin.readline().split())))\n    fence_posts = []\n    for _ in range(M):\n        fence_posts.append(tuple(map(int, stdin.readline().split())))\n    \n    def convex_hull(points):\n        points = sorted(set(points))\n        if len(points) <= 1:\n            return points\n        def cross(o, a, b):\n            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n        lower_hull = []\n        for p in points:\n            while len(lower_hull) >= 2 and cross(lower_hull[-2], lower_hull[-1], p) <= 0:\n                lower_hull.pop()\n            lower_hull.append(p)\n        upper_hull = []\n        for p in reversed(points):\n            while len(upper_hull) >= 2 and cross(upper_hull[-2], upper_hull[-1], p) <= 0:\n                upper_hull.pop()\n            upper_hull.append(p)\n        return lower_hull + upper_hull[1:-1]\n    \n    def max_onions(fence_posts, onions):\n        convex_hull_points = fence_posts + onions\n        convex_hull_points = convex_hull(convex_hull_points)\n        max_onions = 0\n        for i in range(len(convex_hull_points)):\n            for j in range(i+1, len(convex_hull_points)):\n                if (convex_hull_points[i] in onions) and (convex_hull_points[j] in onions):\n                    max_onions += 1\n        return max_onions\n    \n    return str(max_onions(fence_posts, onions))"
    },
    {
        "number": 3343,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, n = map(int, stdin.split()[:2])\n    points = [int(x) for x in stdin.split()[2:]]\n    directions = [x for x in stdin.split()[2:]]\n\n    for i in range(n):\n        if points[i] == 0 or points[i] == L:\n            return \"GHOST\"\n\n    for i in range(n):\n        if directions[i] == \"C\":\n            for j in range(i + 1, n):\n                if points[j] < points[i]:\n                    return \"GHOST\"\n        else:\n            for j in range(i + 1, n):\n                if points[j] > points[i]:\n                    return \"GHOST\"\n\n    return \"SAFE\""
    },
    {
        "number": 3344,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split()[:2])\n    luggage_positions = list(map(float, stdin.split()[2:]))\n    \n    # Calculate the maximum speed that avoids collisions\n    max_speed = L / (max(luggage_positions) - min(luggage_positions))\n    \n    # Check if there is a valid speed within the given range\n    for speed in [max_speed - 10**-9, max_speed]:\n        if all(abs(pos - int(pos)) <= 1 for pos in luggage_positions):\n            return f\"{speed:.9f}\"\n    \n    # If no valid speed is found, return \"no fika\"\n    return \"no fika\""
    },
    {
        "number": 3345,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def min_distance(points1, points2):\n        min_dist = float('inf')\n        for i in range(len(points1)):\n            for j in range(len(points2)):\n                min_dist = min(min_dist, distance(points1[i], points2[j]))\n        return min_dist\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    shadow_points = [tuple(map(int, line.split())) for line in lines[1:n+1]]\n    m = int(lines[n+1])\n    lydia_points = [tuple(map(int, line.split())) for line in lines[n+2:]]\n\n    return str(min_distance(shadow_points, lydia_points))"
    },
    {
        "number": 3346,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = map(int, stdin.split()[:2])\n    cars = []\n    for line in stdin.split('\\n')[2:]:\n        d, a, r = line.split()\n        cars.append((d, int(a), int(r)))\n\n    cars.sort(key=lambda x: x[1])\n    irritated = 0\n    current_time = 0\n    for car in cars:\n        if car[1] > current_time:\n            current_time = car[1]\n        if car[0] == 'W':\n            current_time += t\n        if car[2] < current_time - car[1]:\n            irritated += 1\n\n    return str(irritated)"
    },
    {
        "number": 3347,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    stores = []\n    for i in range(1, n+1):\n        t, h = map(int, stdin.split('\\n')[i].split())\n        stores.append((t, h))\n    \n    stores.sort(key=lambda x: x[1])\n    max_stores = 0\n    current_time = 0\n    for store in stores:\n        if store[1] > current_time:\n            max_stores += 1\n            current_time += store[0]\n        else:\n            break\n    \n    return str(max_stores)"
    },
    {
        "number": 3348,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, A, B, C = map(int, stdin.split())\n    if A + B + C != R * C:\n        return \"impossible\"\n\n    def is_valid(arrangement: List[str]) -> bool:\n        for i in range(R):\n            for j in range(C):\n                if i > 0 and arrangement[i][j] == arrangement[i - 1][j]:\n                    return False\n                if j > 0 and arrangement[i][j] == arrangement[i][j - 1]:\n                    return False\n        return True\n\n    def backtrack(arrangement: List[str], a: int, b: int, c: int) -> bool:\n        if a == 0 and b == 0 and c == 0:\n            return is_valid(arrangement)\n\n        for i in range(R):\n            for j in range(C):\n                if arrangement[i][j] == \" \":\n                    if a > 0:\n                        arrangement[i][j] = \"A\"\n                        if backtrack(arrangement, a - 1, b, c):\n                            return True\n                        arrangement[i][j] = \" \"\n                    if b > 0:\n                        arrangement[i][j] = \"B\"\n                        if backtrack(arrangement, a, b - 1, c):\n                            return True\n                        arrangement[i][j] = \" \"\n                    if c > 0:\n                        arrangement[i][j] = \"C\"\n                        if backtrack(arrangement, a, b, c - 1):\n                            return True\n                        arrangement[i][j] = \" \"\n\n        return False\n\n    arrangement = [[\" \"] * C for _ in range(R)]\n    if backtrack(arrangement, A, B, C):\n        return \"\\n\".join(\"\".join(row) for row in arrangement)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3349,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split(\"\\n\")\n    n = int(words[0])\n    dictionary = words[1:n+1]\n    message = words[n+1]\n\n    def find_words(message: str, dictionary: List[str]) -> List[str]:\n        words = []\n        for word in dictionary:\n            if message.startswith(word):\n                words.append(word)\n                message = message[len(word):]\n                if not message:\n                    break\n        return words\n\n    def count_vowels(word: str) -> int:\n        return sum(1 for char in word if char in \"AEIOU\")\n\n    def sort_key(word: str) -> Tuple[int, int]:\n        return (-count_vowels(word), len(word))\n\n    def reconstruct_sentence(words: List[str]) -> str:\n        return \" \".join(words)\n\n    def find_best_sentence(message: str, dictionary: List[str]) -> str:\n        best_sentence = \"\"\n        best_score = 0\n        for i in range(len(message) - len(dictionary) + 1):\n            words = find_words(message[i:], dictionary)\n            if not words:\n                break\n            sentence = reconstruct_sentence(words)\n            score = sum(count_vowels(word) for word in words)\n            if score > best_score:\n                best_sentence = sentence\n                best_score = score\n        return best_sentence\n\n    sorted_dictionary = sorted(dictionary, key=sort_key)\n    return find_best_sentence(message, sorted_dictionary)"
    },
    {
        "number": 3350,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def power(word: str) -> int:\n        n = len(word)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if word[i:j] == word[j:i:-1]:\n                    return j - i\n        return 0\n\n    return str(power(stdin))"
    },
    {
        "number": 3351,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    dice_rolls = [int(x) for x in stdin.split()]\n    n = len(dice_rolls)\n    max_score = 0\n    for i in range(n - 12):\n        score = 0\n        for j in range(13):\n            category_score = 0\n            for k in range(5):\n                category_score += dice_rolls[i + j + k]\n            if j == 0:\n                category_score -= 4\n            if j == 1:\n                category_score -= 3\n            if j == 2:\n                category_score -= 2\n            if j == 3:\n                category_score -= 1\n            if j == 4:\n                category_score -= 0\n            if j == 5:\n                category_score -= 1\n            if j == 6:\n                category_score -= 2\n            if j == 7:\n                category_score -= 3\n            if j == 8:\n                category_score -= 4\n            if j == 9:\n                category_score -= 5\n            if j == 10:\n                category_score -= 6\n            if j == 11:\n                category_score -= 5\n            if j == 12:\n                category_score -= 4\n            score += category_score\n        max_score = max(max_score, score)\n    return str(max_score)"
    },
    {
        "number": 3352,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent, i):\n        if parent[i] == i:\n            return i\n        return find_parent(parent, parent[i])\n\n    def find_subtree(parent, i):\n        root = find_parent(parent, i)\n        subtree = [root]\n        for j in range(1, N + 1):\n            if find_parent(parent, j) == root:\n                subtree.append(j)\n        return subtree\n\n    def count_magical_colours(colours, subtree):\n        magical_colours = {}\n        for node in subtree:\n            if colours[node] not in magical_colours:\n                magical_colours[colours[node]] = 1\n            else:\n                magical_colours[colours[node]] += 1\n        return sum(1 for count in magical_colours.values() if count % 2 == 1)\n\n    N, Q = map(int, stdin.readline().split())\n    colours = list(map(int, stdin.readline().split()))\n    parent = [0] * (N + 1)\n    for i in range(N - 1):\n        parent[i + 1] = int(stdin.readline())\n\n    for i in range(Q):\n        K, X = map(int, stdin.readline().split())\n        if K == 0:\n            subtree = find_subtree(parent, X)\n            magical_colours = count_magical_colours(colours, subtree)\n            print(magical_colours)\n        else:\n            colours[X - 1] = K"
    },
    {
        "number": 3353,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P, R, L = map(int, stdin.split()[:3])\n    logs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:L+1]]\n    people = [0] * P\n    time = 0\n    left_bank = -2\n    right_bank = -1\n    boulders = [-2] * (R+2)\n    for log in logs:\n        boulders[log[0]+1] += 1\n        boulders[log[1]+1] += 1\n\n    while any(people):\n        for i in range(P):\n            if people[i] == 0:\n                continue\n            if boulders[left_bank+1] == 0:\n                return str(P - sum(people))\n            time += 1\n            boulders[left_bank+1] -= 1\n            left_bank += 1\n            people[i] -= 1\n\n    return str(time)"
    },
    {
        "number": 3354,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, r, n, z = map(float, stdin.split())\n    area_sandwich = 3.14 * s ** 2\n    area_pickle = 3.14 * r ** 2\n    max_pickles = int(area_sandwich * z / 100 / area_pickle)\n    return str(max_pickles)"
    },
    {
        "number": 3355,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(start, end, time_limit):\n        if start == end:\n            return True\n        if start not in graph or end not in graph:\n            return False\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, time = queue.pop(0)\n            if current == end:\n                return True\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor, travel_time in graph[current]:\n                if time + travel_time <= time_limit:\n                    queue.append((neighbor, time + travel_time))\n        return False\n\n    def get_max_points(tasks, time_limit):\n        tasks.sort(key=lambda x: x[2])\n        max_points = 0\n        max_tasks = []\n        for i, (p, t, d) in enumerate(tasks):\n            if d == -1 or d <= time_limit:\n                max_points += p\n                max_tasks.append(i)\n            if d != -1 and d > time_limit:\n                break\n        return max_points, max_tasks\n\n    n, time_limit = map(int, stdin.readline().split())\n    tasks = []\n    for _ in range(n):\n        p, t, d = map(int, stdin.readline().split())\n        tasks.append((p, t, d))\n\n    graph = [[] for _ in range(n + 3)]\n    for i in range(n + 2):\n        row = list(map(int, stdin.readline().split()))\n        for j, time in enumerate(row):\n            if time > 0:\n                graph[i].append((j, time))\n\n    start = n\n    end = n + 1\n    if not is_valid(start, end, time_limit):\n        return \"0\\n\"\n\n    max_points, max_tasks = get_max_points(tasks, time_limit)\n    if max_points == 0:\n        return \"\\n\"\n\n    return f\"{max_points}\\n{' '.join(map(str, max_tasks))}\\n\"\n\ninput_data = \"\"\"3 352\n93 82 444\n92 76 436\n99 62 -1\n0 70 66 71 97\n76 0 87 66 74\n62 90 0 60 94\n60 68 68 0 69\n83 78 83 73 0\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3356,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        N = int(input())\n        tunnels = []\n        for _ in range(N - 1):\n            a, b = map(int, input().split())\n            tunnels.append((a, b))\n        return N, tunnels\n\n    def find_farthest_rooms(N, tunnels):\n        visited = [False] * (N + 1)\n        max_distance = 0\n        max_rooms = None\n\n        for tunnel in tunnels:\n            a, b = tunnel\n            if not visited[a]:\n                distance = dfs(a, visited, tunnels)\n                if distance > max_distance:\n                    max_distance = distance\n                    max_rooms = tunnel\n\n        return max_distance, max_rooms\n\n    def dfs(room, visited, tunnels):\n        visited[room] = True\n        max_distance = 0\n\n        for tunnel in tunnels:\n            a, b = tunnel\n            if a == room and not visited[b]:\n                distance = dfs(b, visited, tunnels)\n                max_distance = max(max_distance, distance + 1)\n            elif b == room and not visited[a]:\n                distance = dfs(a, visited, tunnels)\n                max_distance = max(max_distance, distance + 1)\n\n        return max_distance\n\n    N, tunnels = read_input()\n    max_distance, max_rooms = find_farthest_rooms(N, tunnels)\n\n    return f\"{max_distance}\\n{max_rooms}\\n{max_rooms[::-1]}\""
    },
    {
        "number": 3357,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    buildings = []\n    for i in range(1, N+1):\n        x, h = map(int, lines[i].split())\n        buildings.append((x, h))\n\n    def sunlight_hours(building):\n        x, h = building\n        return h / 180\n\n    buildings.sort(key=lambda x: x[0])\n    result = []\n    for building in buildings:\n        result.append(sunlight_hours(building))\n\n    return '\\n'.join(f\"{h:.4f}\" for h in result)"
    },
    {
        "number": 3358,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    instructions = []\n    if N == 0:\n        instructions.append(\"ZE A\")\n        instructions.append(\"ZE X\")\n        instructions.append(\"DI A\")\n    else:\n        while N > 0:\n            if N % 2 == 1:\n                instructions.append(\"ST A\")\n                instructions.append(\"PH A\")\n                instructions.append(\"AD\")\n                instructions.append(\"PL A\")\n            else:\n                instructions.append(\"ST X\")\n                instructions.append(\"PH X\")\n                instructions.append(\"AD\")\n                instructions.append(\"PL X\")\n            N //= 2\n        if N == 0:\n            instructions.append(\"DI A\")\n        else:\n            instructions.append(\"DI X\")\n    return \"\\n\".join(instructions)"
    },
    {
        "number": 3359,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, R, C = map(int, stdin.split()[:3])\n    blur_box = [[0] * C for _ in range(R)]\n    for r in range(R):\n        for c in range(C):\n            blur_box[r][c] = int(stdin.split()[r * C + c], 16)\n\n    def is_stellar_body(r: int, c: int) -> bool:\n        for i in range(N):\n            for j in range(N):\n                if blur_box[r][c] != blur_box[r + i][c + j]:\n                    return False\n        return True\n\n    stellar_bodies = 0\n    for r in range(R - N + 1):\n        for c in range(C - N + 1):\n            if is_stellar_body(r, c):\n                stellar_bodies += 1\n\n    return str(stellar_bodies)"
    },
    {
        "number": 3360,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rules, text = stdin.split(\"\\n\\n\")\n    rules = rules.split(\"\\n\")\n    start_var = rules[0][0]\n    rules = rules[1:]\n    rules_dict = {}\n    for rule in rules:\n        head, body = rule.split(\" -> \")\n        rules_dict[head] = body\n\n    def generate_strings(var: str, depth: int) -> List[str]:\n        if depth == 0:\n            return []\n        if var in rules_dict:\n            result = []\n            for rule in rules_dict[var].split(\" \"):\n                result += generate_strings(rule, depth - 1)\n            return result\n        return [var]\n\n    def find_longest_substring(text: str) -> str:\n        longest_substring = \"\"\n        for i in range(len(text)):\n            for j in range(i + 1, len(text) + 1):\n                substring = text[i:j]\n                if all(char in generate_strings(start_var, len(substring)) for char in substring):\n                    if len(substring) > len(longest_substring):\n                        longest_substring = substring\n        return longest_substring\n\n    result = []\n    for line in text.split(\"\\n\"):\n        result.append(find_longest_substring(line))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3361,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in stdin.split('\\n')[i+1].split()])\n\n    def disparity(subset: set) -> int:\n        max_distance = 0\n        for i in subset:\n            for j in subset:\n                if i != j:\n                    max_distance = max(max_distance, distances[i][j])\n        return max_distance\n\n    min_disparity = float('inf')\n    for i in range(2**n):\n        subset1 = set()\n        subset2 = set()\n        for j in range(n):\n            if i & (1 << j):\n                subset1.add(j)\n            else:\n                subset2.add(j)\n        disparity1 = disparity(subset1)\n        disparity2 = disparity(subset2)\n        min_disparity = min(min_disparity, disparity1 + disparity2)\n\n    return str(min_disparity)"
    },
    {
        "number": 3362,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, F, L, W = map(int, stdin.split()[:4])\n    map_data = stdin.split('\\n')[2:]\n    start_pos = None\n    goal_pos = None\n    for i, row in enumerate(map_data):\n        for j, tile in enumerate(row):\n            if tile == 'S':\n                start_pos = (i, j)\n            elif tile == 'G':\n                goal_pos = (i, j)\n    if not start_pos or not goal_pos:\n        return \"NO WAY\"\n\n    def is_valid_move(pos, step_length):\n        i, j = pos\n        return 0 <= i + step_length < L and 0 <= j + step_length < W\n\n    def get_next_positions(pos, step_length):\n        i, j = pos\n        return [(i + step_length, j), (i, j + step_length), (i - step_length, j), (i, j - step_length)]\n\n    def bfs(start_pos, goal_pos, max_step_length):\n        queue = [(start_pos, 0)]\n        visited = set()\n        while queue:\n            current_pos, current_steps = queue.pop(0)\n            if current_pos == goal_pos:\n                return current_steps\n            if current_steps > max_step_length:\n                continue\n            if current_pos not in visited:\n                visited.add(current_pos)\n                for next_pos in get_next_positions(current_pos, 1):\n                    if is_valid_move(next_pos, max_step_length):\n                        queue.append((next_pos, current_steps + 1))\n        return None\n\n    elsa_steps = bfs(start_pos, goal_pos, A)\n    father_steps = bfs(start_pos, goal_pos, F)\n\n    if not elsa_steps or not father_steps:\n        return \"NO WAY\"\n\n    if elsa_steps == father_steps:\n        return \"SUCCESS\"\n    elif elsa_steps < father_steps:\n        return \"GO FOR IT\"\n    else:\n        return \"NO CHANCE\""
    },
    {
        "number": 3363,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    courses = list(map(int, stdin.split()[2:]))\n\n    max_calories = 0\n    for i in range(n):\n        if i == 0:\n            max_calories += m\n        else:\n            max_calories += courses[i-1]\n            if i > 1:\n                max_calories -= (courses[i-1] - courses[i-2]) // 3\n\n    return str(max_calories)"
    },
    {
        "number": 3364,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, q = map(int, lines[0].split())\n    sets = [i for i in range(n)]\n    for line in lines[1:]:\n        if line[0] == '=':\n            a, b = map(int, line.split()[1:])\n            sets[find(sets, a)] = sets[find(sets, b)]\n        elif line[0] == '?':\n            a, b = map(int, line.split()[1:])\n            print(\"yes\" if find(sets, a) == find(sets, b) else \"no\")\n\ndef"
    },
    {
        "number": 3365,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    sequence = list(map(int, stdin.split()[2:]))\n    \n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    def find_largest_prime(region: list) -> int:\n        largest_prime = 0\n        for num in region:\n            for i in range(2, num + 1):\n                if is_prime(i) and num % i == 0:\n                    largest_prime = max(largest_prime, i)\n        return largest_prime\n    \n    def partition(sequence: list, k: int) -> int:\n        min_score = float('inf')\n        for i in range(len(sequence) - k + 1):\n            region = sequence[i:i+k]\n            largest_prime = find_largest_prime(region)\n            if largest_prime > 0:\n                min_score = min(min_score, largest_prime)\n        return min_score\n    \n    return str(partition(sequence, k))"
    },
    {
        "number": 3366,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    MOD = 10**9 + 7\n    def f(X):\n        iterations = 0\n        while X != 1:\n            if X % 2 == 0:\n                X //= 2\n            else:\n                X += 1\n            iterations += 1\n        return iterations\n\n    S = sum(f(X) for X in range(L, R+1))\n    return str(S % MOD)"
    },
    {
        "number": 3367,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = map(int, stdin.split()[:2])\n    questions = {}\n    for i in range(n):\n        question, answer = stdin.split('\\n')[i].split('?')\n        questions[question] = answer.strip()\n\n    def score(question: str, answer: str, time: int) -> float:\n        words = question.split()\n        if time < len(words):\n            return 0\n        return 1 if words[-1] == answer else 0\n\n    def optimal_strategy(question: str, answer: str, time: int) -> float:\n        if time <= 0:\n            return 0\n        if time == 1:\n            return score(question, answer, time)\n        return max(score(question, answer, time), optimal_strategy(question, answer, time - 1))\n\n    total_score = 0\n    for question, answer in questions.items():\n        total_score += optimal_strategy(question, answer, t)\n\n    return f\"{total_score / n:.6f}\""
    },
    {
        "number": 3368,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    enclosures = [stdin.split()[i:i+2] for i in range(2, n*2+2, 2)]\n    animals = [stdin.split()[i:i+m] for i in range(n*2+2, len(stdin.split()), m)]\n\n    for i in range(len(animals)):\n        for j in range(len(animals[i])):\n            for k in range(len(enclosures)):\n                if animals[i][j] in enclosures[k][1:]:\n                    if enclosures[k][0] == animals[i][j]:\n                        enclosures[k] = [enclosures[k][0], str(int(enclosures[k][1]) - 1)] + enclosures[k][1:]\n                    else:\n                        enclosures[k] = [enclosures[k][0], str(int(enclosures[k][1]) + 1)] + enclosures[k][1:]\n                    break\n\n    for enclosure in enclosures:\n        if int(enclosure[1]) != 0:\n            return \"POSSIBLE\"\n\n    return \"FALSE ALARM\""
    },
    {
        "number": 3369,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.split('\\n')[0])\n    digits = stdin.split('\\n')[1:]\n    digits = ' '.join(digits)\n    digits = [int(x) for x in digits.split()]\n\n    def find_triple_correlation(a, b, c, n, m):\n        count = 0\n        for i in range(len(digits) - n - m - 1):\n            if digits[i] == a and digits[i + n] == b and digits[i + n + m] == c:\n                count += 1\n        return count\n\n    triple_correlations = []\n    for a in range(10):\n        for b in range(10):\n            for c in range(10):\n                for n in range(1, 10):\n                    for m in range(1, 10):\n                        count = find_triple_correlation(a, b, c, n, m)\n                        if count >= max(p // 40 + 1, 1):\n                            triple_correlations.append((a, b, c, n, m, count))\n\n    if triple_correlations:\n        triple_correlations.sort(key=lambda x: (x[0], x[1], x[2], x[3], x[4]))\n        a, b, c, n, m, count = triple_correlations[0]\n        return f\"triple correlation {a}({n}){b}({m}){c} found\"\n    else:\n        return \"random sequence\""
    },
    {
        "number": 3370,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, k = map(float, stdin.split())\n    heights = list(map(float, stdin.splitlines()[1:])))\n    heights.insert(0, 0)\n    heights.append(0)\n\n    while True:\n        new_heights = heights.copy()\n        for i in range(1, N + 1):\n            avg_height = (heights[i - 1] + heights[i + 1]) / 2\n            if heights[i] >= avg_height + k:\n                continue\n            else:\n                new_heights[i] = avg_height + k\n        if new_heights == heights:\n            break\n        else:\n            heights = new_heights\n\n    return str(max(heights))"
    },
    {
        "number": 3371,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split()[:2])\n    known_pairs = {}\n    for line in stdin.split('\\n')[2:]:\n        a, b, y = map(int, line.split())\n        known_pairs[(a, b)] = y\n        known_pairs[(b, a)] = y\n\n    def is_possible(year: int) -> bool:\n        first_part = set()\n        second_part = set()\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                if (i, j) in known_pairs:\n                    if known_pairs[(i, j)] < year:\n                        first_part.add(i)\n                        first_part.add(j)\n                    else:\n                        second_part.add(i)\n                        second_part.add(j)\n                else:\n                    first_part.add(i)\n                    first_part.add(j)\n\n        return len(first_part) <= 2 * n / 3 and len(second_part) <= 2 * n / 3\n\n    for year in range(1948, 2008):\n        if is_possible(year):\n            return str(year)\n\n    return \"Impossible\""
    },
    {
        "number": 3372,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, s, t = map(int, stdin.split()[:3])\n    flights = [[] for _ in range(N)]\n    for i in range(N):\n        line = stdin.split('\\n')[i+1]\n        if line[0] == 'N':\n            flights[i] = list(map(int, line.split()[2:]))\n        elif line[0] == 'C':\n            flights[i] = list(set(range(N)) - set(map(int, line.split()[2:])))\n\n    def dfs(node: int, visited: set, path: list) -> int:\n        if node == t:\n            return len(path)\n        visited.add(node)\n        min_flights = float('inf')\n        for neighbor in flights[node]:\n            if neighbor not in visited:\n                min_flights = min(min_flights, dfs(neighbor, visited, path + [node]))\n        visited.remove(node)\n        return min_flights\n\n    if s == t:\n        return \"impossible\"\n    visited = set()\n    path = []\n    min_flights = dfs(s, visited, path)\n    return min_flights if min_flights != float('inf') else \"impossible\""
    },
    {
        "number": 3373,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_balanced(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def longest_balanced_string(pieces: List[str]) -> str:\n        max_length = 0\n        max_string = \"\"\n        for i in range(len(pieces)):\n            for j in range(i + 1, len(pieces)):\n                s = pieces[i] + pieces[j]\n                if is_balanced(s) and len(s) > max_length:\n                    max_length = len(s)\n                    max_string = s\n        return max_string\n\n    n = int(stdin.readline().strip())\n    pieces = [stdin.readline().strip() for _ in range(n)]\n    return str(len(longest_balanced_string(pieces)))"
    },
    {
        "number": 3374,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_uw_distance(capacitance, potential, inductance):\n        return abs(sum(potential * (capacitance * capacitance - inductance)))\n\n    def calculate_capacitance(gravity_values):\n        return [sum(gravity_values[i:i + 2]) for i in range(len(gravity_values) - 1)]\n\n    def calculate_potential(gravity_values):\n        return [gravity_values[i + 1] - gravity_values[i] for i in range(len(gravity_values) - 1)]\n\n    def calculate_inductance(gravity_values):\n        return [gravity_values[i] * gravity_values[i + 1] for i in range(len(gravity_values) - 1)]\n\n    def find_min_uw_distance(gravity_values, links):\n        min_uw_distance = float('inf')\n        for i in range(len(gravity_values)):\n            for j in range(i + 1, len(gravity_values)):\n                if (i, j) not in links and (j, i) not in links:\n                    capacitance = calculate_capacitance(gravity_values[i:j + 1])\n                    potential = calculate_potential(gravity_values[i:j + 1])\n                    inductance = calculate_inductance(gravity_values[i:j + 1])\n                    uw_distance = calculate_uw_distance(capacitance, potential, inductance)\n                    min_uw_distance = min(min_uw_distance, uw_distance)\n        return min_uw_distance\n\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        gravity_values = []\n        links = set()\n        for i in range(1, n + 1):\n            gravity_value, system_type = lines[i].split()\n            gravity_values.append(int(gravity_value))\n        e = int(lines[n + 1])\n        for i in range(n + 2, n + 2 + e):\n            system1, system2 = map(int, lines[i].split())\n            links.add((system1, system2))\n        return gravity_values, links\n\n    gravity_values, links = parse_input(stdin)\n    human_systems = [i for i, system_type in enumerate(stdin.split('\\n')[1:n + 1]) if system_type == 'h']\n    alien_systems = [i for i, system_type in enumerate(stdin.split('\\n')[1:n + 1]) if system_type == 'a']\n\n    min_uw_distance = float('inf')\n    for human_system in human_systems:\n        for alien_system in alien_systems:\n            if (human_system, alien_system) not in links and (alien_system, human_system) not in links:\n                gravity_values_with_dispersal = gravity_values.copy()\n                gravity_values_with_dispersal[human_system] -= 1\n                gravity_values_with_dispersal[alien_system] -= 1\n                for i in range(len(gravity_values_with_dispersal) - 1):\n                    if gravity_values_with_dispersal[i] > gravity_values_with_dispersal[i + 1]:\n                        gravity_values_with_dispersal[i], gravity_values_with_dispersal[i + 1] = gravity_values_with_dispersal[i + 1], gravity_values_with_dispersal[i]\n                uw_distance = find_min_uw_distance(gravity_values_with_dispersal, links)\n                min_uw_distance = min(min_uw_distance, uw_distance)\n\n    return str(min_uw_distance)"
    },
    {
        "number": 3375,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    V, E = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[2:]]\n    graph = [[] for _ in range(V)]\n    for a, b in edges:\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n\n    def dfs(node: int, visited: set, cycle: set) -> bool:\n        visited.add(node)\n        cycle.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, cycle):\n                    return True\n            elif neighbor in cycle:\n                return True\n        cycle.remove(node)\n        return False\n\n    def count_spanning_unicyclic_subgraphs(graph: List[List[int]]) -> int:\n        count = 0\n        for i in range(V):\n            visited = set()\n            cycle = set()\n            if dfs(i, visited, cycle):\n                continue\n            count += 1\n        return count\n\n    return str(count_spanning_unicyclic_subgraphs(graph) % (10**9 + 7))"
    },
    {
        "number": 3376,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    f, n = map(int, stdin.split('\\n')[0].split())\n    families = {}\n    for i in range(1, f + 1):\n        family_data = stdin.split('\\n')[i].split()\n        s = int(family_data[0])\n        family_name = family_data[s]\n        families[family_name] = {\n            'strongest': family_data[-1],\n            'candies': [int(family_data[j]) for j in range(1, s)],\n            'count': 0\n        }\n\n    for i in range(f + 1, f + 1 + n):\n        t, p = map(int, stdin.split('\\n')[i].split())\n        families[p]['count'] += 1\n\n    def get_max_xp(family_name, time):\n        family = families[family_name]\n        strongest = family['strongest']\n        candies = family['candies']\n        count = family['count']\n\n        max_xp = 0\n        for i in range(len(candies)):\n            if candies[i] > time:\n                break\n            max_xp += 100 * count\n            count -= count\n\n        return max_xp\n\n    max_xp = 0\n    for family_name in families:\n        max_xp += get_max_xp(family_name, 1800)\n\n    return str(max_xp)"
    },
    {
        "number": 3377,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, dry_plan, wet_plan = parse_input(stdin)\n    dry_pegs = len(dry_plan)\n    wet_pegs = 10 * dry_pegs\n    safe_wet_plan = find_safe_wet_plan(n, dry_plan, wet_plan, dry_pegs, wet_pegs)\n    if safe_wet_plan is None:\n        return \"-1\"\n    return format_output(safe_wet_plan)\n\ndef"
    },
    {
        "number": 3378,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[:2])\n    tour = list(map(int, stdin.split()[2:2*d+1]))\n    m = int(stdin.split()[2*d+1])\n    airfares = []\n    \n    for i in range(m):\n        s, d, t, p = map(str, stdin.split()[2*d+2+i*4:2*d+6+i*4])\n        airfares.append((int(s), int(d), t, int(p)))\n    \n    # Calculate the distance between each city\n    distances = [[float('inf')] * (n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i != j:\n                distances[i][j] = 1\n    \n    # Calculate the minimum distance between each pair of cities\n    for k in range(1, n+1):\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                if distances[i][k] + distances[k][j] < distances[i][j]:\n                    distances[i][j] = distances[i][k] + distances[k][j]\n    \n    # Calculate the minimum cost to complete the tour\n    min_cost = float('inf')\n    for i in range(1, 2**d):\n        cost = 0\n        for j in range(d):\n            s = tour[j]\n            d = tour[(j+1) % d]\n            for fare in airfares:\n                if fare[0] == s and fare[1] == d:\n                    if fare[2] == 'O':\n                        cost += fare[3]\n                    else:\n                        cost += min(fare[3], fare[3] // 2)\n                    break\n        min_cost = min(min_cost, cost)\n    \n    return str(min_cost)"
    },
    {
        "number": 3379,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(n)]\n    for line in stdin.split('\\n')[2:]:\n        if line:\n            x, y = map(int, line.split())\n            graph[x].append(y)\n    \n    def kahns_algorithm(graph: List[List[int]]) -> List[int]:\n        in_degree = [0] * len(graph)\n        for node in graph:\n            for neighbor in node:\n                in_degree[neighbor] += 1\n        \n        queue = deque([node for node, degree in enumerate(in_degree) if degree == 0])\n        result = []\n        \n        while queue:\n            node = queue.popleft()\n            result.append(node)\n            \n            for neighbor in graph[node]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return result\n    \n    largest_s = 0\n    for node in kahns_algorithm(graph):\n        if len(graph[node]) > largest_s:\n            largest_s = len(graph[node])\n    \n    return str(largest_s)"
    },
    {
        "number": 3380,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    probability = 1\n    for i in range(N):\n        probability *= (N - i - 1) / N\n    return str(probability)"
    },
    {
        "number": 3381,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N < 3 or N > 400000:\n        raise ValueError(\"Invalid input: N must be between 3 and 400000\")\n\n    def is_convex_polygon(points):\n        def cross_product(a, b):\n            return a[0] * b[1] - a[1] * b[0]\n\n        def is_clockwise(p1, p2, p3):\n            return cross_product(p2 - p1, p3 - p2) > 0\n\n        points = [list(map(int, point.split())) for point in points]\n        n = len(points)\n        if n < 3:\n            return False\n\n        p1, p2, p3 = points[0], points[1], points[2]\n        if not is_clockwise(p1, p2, p3):\n            return False\n\n        for i in range(1, n - 1):\n            p1, p2, p3 = p2, p3, points[(i + 1) % n]\n            if not is_clockwise(p1, p2, p3):\n                return False\n\n        return True\n\n    def generate_points(N):\n        points = []\n        for i in range(N):\n            x = random.randint(0, 40000000)\n            y = random.randint(0, 40000000)\n            points.append(f\"{x} {y}\")\n        return points\n\n    points = generate_points(N)\n    while not is_convex_polygon(points):\n        points = generate_points(N)\n\n    return \"\\n\".join(points)"
    },
    {
        "number": 3382,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    base_values = list(map(int, stdin.split()))\n    min_grade = float('inf')\n    min_expression = None\n\n    def grade(expression: str) -> int:\n        grade = 0\n        prev_char = None\n        for char in expression:\n            if char == '(':\n                grade += 1\n            elif char == ')':\n                grade += 1\n            elif char == '+' or char == '-' or char == '*' or char == '/':\n                if prev_char == '+' or prev_char == '-' or prev_char == '*' or prev_char == '/':\n                    grade += 2\n            prev_char = char\n        return grade\n\n    def generate_expressions(base_values: list, index: int, expression: str, grade: int) -> None:\n        nonlocal min_grade, min_expression\n        if index == len(base_values):\n            if grade < min_grade:\n                min_grade = grade\n                min_expression = expression\n            return\n\n        generate_expressions(base_values, index + 1, expression + str(base_values[index]), grade)\n        generate_expressions(base_values, index + 1, expression + '+' + str(base_values[index]), grade)\n        generate_expressions(base_values, index + 1, expression + '-' + str(base_values[index]), grade)\n        generate_expressions(base_values, index + 1, expression + '*' + str(base_values[index]), grade)\n        if base_values[index] != 0:\n            generate_expressions(base_values, index + 1, expression + '/' + str(base_values[index]), grade)\n\n    generate_expressions(base_values, 0, '', 0)\n\n    if min_expression is None:\n        return 'impossible'\n    else:\n        return str(grade(min_expression))"
    },
    {
        "number": 3383,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b, *tastiness = map(int, stdin.split())\n    u = [list(map(int, stdin.split())) for _ in range(k)]\n\n    def tastiness_per_gold_coin(scoops: int) -> float:\n        total_tastiness = 0\n        for i in range(k):\n            for j in range(k):\n                if i != j:\n                    total_tastiness += tastiness[i] * tastiness[j] * u[i][j]\n        return total_tastiness / (a * scoops + b)\n\n    def binary_search(left: int, right: int) -> float:\n        if left > right:\n            return tastiness_per_gold_coin(left)\n\n        mid = (left + right) // 2\n        tastiness_mid = tastiness_per_gold_coin(mid)\n\n        if tastiness_mid > 0:\n            return binary_search(mid + 1, right)\n        else:\n            return binary_search(left, mid - 1)\n\n    return str(binary_search(1, n))"
    },
    {
        "number": 3384,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if len(str(n)) == 1:\n        return str(n)\n\n    def is_handsome(num: int) -> bool:\n        digits = [int(d) for d in str(num)]\n        for i in range(len(digits) - 1):\n            if digits[i] % 2 == digits[i + 1] % 2:\n                return False\n        return True\n\n    def next_handsome(num: int) -> int:\n        digits = [int(d) for d in str(num)]\n        for i in range(len(digits) - 1, 0, -1):\n            if digits[i] % 2 != digits[i - 1] % 2:\n                digits[i] += 1\n                if digits[i] == 10:\n                    digits[i] = 0\n                    digits[i - 1] += 1\n                break\n        return int(\"\".join(str(d) for d in digits))\n\n    handsome = None\n    while not is_handsome(n):\n        handsome = n\n        n = next_handsome(n)\n\n    closest_handsome = handsome\n    while not is_handsome(n):\n        closest_handsome = n\n        n = next_handsome(n)\n\n    return str(closest_handsome)"
    },
    {
        "number": 3385,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    children = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def count_ways(children: List[List[int]]) -> int:\n        def count_pumpkins(children: List[List[int]], i: int) -> int:\n            l, r, x = children[i]\n            return (l + r + 1) // 2 + x\n\n        def is_valid(children: List[List[int]]) -> bool:\n            for i in range(n):\n                l, r, x = children[i]\n                pumpkins = count_pumpkins(children, i)\n                if pumpkins % 2 != x:\n                    return False\n            return True\n\n        def backtrack(children: List[List[int]], i: int) -> int:\n            if i == n:\n                return 1 if is_valid(children) else 0\n\n            l, r, x = children[i]\n            count = 0\n            for j in range(n):\n                children[i] = [j, n - j - 1, x]\n                count += backtrack(children, i + 1)\n            children[i] = [l, r, x]\n            return count\n\n        return backtrack(children, 0)\n\n    return str(count_ways(children) % (10**9 + 7))"
    },
    {
        "number": 3386,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    grid = [[0] * M for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            grid[i][j] = (i, j)\n\n    def manhattan_distance(p: tuple, q: tuple) -> int:\n        return abs(p[0] - q[0]) + abs(p[1] - q[1])\n\n    def is_valid_tour(tour: list) -> bool:\n        for i in range(len(tour) - 1):\n            if manhattan_distance(tour[i], tour[i + 1]) not in [2, 3]:\n                return False\n        return True\n\n    def find_tour(grid: list) -> list:\n        N, M = len(grid), len(grid[0])\n        visited = set()\n        tour = []\n\n        def dfs(i, j):\n            if (i, j) in visited:\n                return\n            visited.add((i, j))\n            tour.append((i, j))\n\n            if len(tour) >= 2:\n                if is_valid_tour(tour):\n                    return True\n                tour.pop()\n                visited.remove((i, j))\n\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < N and 0 <= y < M:\n                    if dfs(x, y):\n                        return True\n            tour.pop()\n            visited.remove((i, j))\n            return False\n\n        for i in range(N):\n            for j in range(M):\n                if dfs(i, j):\n                    return tour\n        return []\n\n    tour = find_tour(grid)\n    if not tour:\n        return \"-1\"\n    output = \"\"\n    for i in range(len(tour)):\n        output += f\"{tour[i][0]} {tour[i][1]}\\n\"\n    return output"
    },
    {
        "number": 3387,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[0:2])\n    constraints = []\n    for i in range(n):\n        a, b, d = map(int, stdin.split()[2:5])\n        constraints.append((a, b, d))\n\n    def fair_share(x: int, y: int) -> float:\n        return t * (x / y)\n\n    def objective_function(x: List[int]) -> float:\n        total_x = sum(x)\n        total_y = sum(fair_share(d, total_x) for a, b, d in constraints)\n        return sum((x[i] - fair_share(d, total_x)) ** 2 / fair_share(d, total_x) for i, (a, b, d) in enumerate(constraints))\n\n    def constraint_function(x: List[int]) -> List[float]:\n        return [sum(x) - t] + [x[i] - constraints[i][0] for i in range(n)] + [constraints[i][1] - x[i] for i in range(n)]\n\n    x0 = [constraints[i][1] for i in range(n)]\n    bounds = [(constraints[i][0], constraints[i][1]) for i in range(n)]\n    constraints = ({'type': 'eq', 'fun': constraint_function},)\n\n    res = minimize(objective_function, x0, bounds=bounds, constraints=constraints)\n\n    return '\\n'.join(map(str, res.x))"
    },
    {
        "number": 3388,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *points = map(int, stdin.split())\n    julia_points = points[0]\n    other_points = points[1:]\n    other_points.sort(reverse=True)\n\n    count = 0\n    for i in range(n - 1):\n        if julia_points > other_points[i]:\n            count += 1\n            break\n        elif julia_points == other_points[i]:\n            count += 1\n        else:\n            break\n\n    return str(count)"
    },
    {
        "number": 3389,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    watch_later_list = list(stdin.split()[1])\n\n    # Initialize a dictionary to store the number of videos of each type\n    video_count = {}\n    for video_type in watch_later_list:\n        if video_type in video_count:\n            video_count[video_type] += 1\n        else:\n            video_count[video_type] = 1\n\n    # Initialize a variable to store the number of clicks needed to watch all videos\n    num_clicks = 0\n\n    # Iterate through the list of videos\n    for i in range(len(watch_later_list)):\n        # If the current video is the last video in the list, break the loop\n        if i == len(watch_later_list) - 1:\n            break\n\n        # If the current video is of the same type as the next video, increment the number of clicks\n        if watch_later_list[i] == watch_later_list[i + 1]:\n            num_clicks += 1\n\n        # If the current video is of a different type than the next video, increment the number of clicks by the number of videos of the current type\n        else:\n            num_clicks += video_count[watch_later_list[i]]\n\n    return str(num_clicks)"
    },
    {
        "number": 3390,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    dish_compatibility = {}\n    for line in stdin.split('\\n')[2:]:\n        a, b = map(int, line.split())\n        if a not in dish_compatibility:\n            dish_compatibility[a] = set()\n        dish_compatibility[a].add(b)\n\n    def find_max_courses(dish_compatibility: dict, visited: set, current_dish: int, depth: int) -> int:\n        if depth == 0:\n            return 1\n        max_courses = 0\n        for next_dish in dish_compatibility[current_dish]:\n            if next_dish not in visited:\n                visited.add(next_dish)\n                max_courses = max(max_courses, find_max_courses(dish_compatibility, visited, next_dish, depth - 1))\n                visited.remove(next_dish)\n        return max_courses\n\n    max_courses = 0\n    for dish in dish_compatibility:\n        max_courses = max(max_courses, find_max_courses(dish_compatibility, set(), dish, n - 1))\n\n    return max_courses"
    },
    {
        "number": 3391,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_zone(zone: set, houses: set) -> bool:\n        for house in houses:\n            if house not in zone:\n                return False\n        return True\n\n    def get_min_zone_side(zone: set, houses: set) -> int:\n        min_side = float('inf')\n        for house in houses:\n            x, y = house\n            for dx in range(-x, x + 1):\n                for dy in range(-y, y + 1):\n                    if (x + dx, y + dy) in zone:\n                        min_side = min(min_side, max(abs(dx), abs(dy)))\n        return min_side\n\n    n, q = map(int, stdin.readline().split())\n    houses = {tuple(map(int, line.split())) for line in stdin}\n    zoning_requests = [tuple(map(int, line.split())) for line in stdin[n:]]\n\n    result = []\n    for a, b in zoning_requests:\n        zone = set()\n        for x, y in houses:\n            if a <= x <= b:\n                zone.add((x, y))\n        if is_valid_zone(zone, houses):\n            result.append(str(get_min_zone_side(zone, houses)))\n        else:\n            result.append('0')\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3392,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        N = int(lines[0])\n        heights = [list(map(int, line.split())) for line in lines[1:N+1]]\n        growth_speeds = [list(map(int, line.split())) for line in lines[N+1:]]\n        return N, heights, growth_speeds\n\n    def find_largest_group(N: int, heights: list, growth_speeds: list) -> int:\n        def dfs(i: int, j: int, visited: set) -> int:\n            if (i, j) in visited:\n                return 0\n            visited.add((i, j))\n            group_size = 1\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= x < N and 0 <= y < N and heights[x][y] == heights[i][j]:\n                    group_size += dfs(x, y, visited)\n            return group_size\n\n        max_group_size = 0\n        for i in range(N):\n            for j in range(N):\n                max_group_size = max(max_group_size, dfs(i, j, set()))\n        return max_group_size\n\n    N, heights, growth_speeds = read_input(stdin)\n    return str(find_largest_group(N, heights, growth_speeds))"
    },
    {
        "number": 3393,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    courses = {}\n    for line in stdin.split('\\n')[1:]:\n        name, difficulty = line.split()\n        difficulty = int(difficulty)\n        if name[-1] == '1' or name[-1] == '2':\n            name = name[:-1]\n        if name not in courses:\n            courses[name] = []\n        courses[name].append(difficulty)\n    \n    min_difficulty = float('inf')\n    for i in range(1, 1 << len(courses)):\n        course_list = []\n        for j in range(len(courses)):\n            if i & (1 << j):\n                course_list.append(courses.keys()[j])\n        if len(course_list) == k:\n            difficulty_sum = sum([sum(courses[course]) for course in course_list])\n            min_difficulty = min(min_difficulty, difficulty_sum)\n    \n    return str(min_difficulty)"
    },
    {
        "number": 3394,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        n, m = map(int, input().split())\n        roads = {}\n        for _ in range(m):\n            u, v, d = map(int, input().split())\n            roads[u, v] = d\n            roads[v, u] = d\n        k = int(input())\n        orders = []\n        for _ in range(k):\n            s, u, t = map(int, input().split())\n            orders.append((s, u, t))\n        return n, roads, orders\n\n    def optimal_schedule(n: int, roads: dict, orders: list) -> int:\n        time = 0\n        schedule = []\n        for order in orders:\n            s, u, t = order\n            if s > time:\n                time = s\n            schedule.append((u, t))\n        return time\n\n    n, roads, orders = read_input()\n    max_wait_time = optimal_schedule(n, roads, orders)\n    return str(max_wait_time)"
    },
    {
        "number": 3395,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, int, int, List[int], List[int], List[List[int]]]:\n        n, m, k = map(int, input().split())\n        o = list(map(int, input().split()))\n        c = list(map(int, input().split()))\n        adjacency_list = [list(map(int, input().split())) for _ in range(n)]\n        return n, m, k, o, c, adjacency_list\n\n    def dfs(cell: int, visited: Set[int], adjacency_list: List[List[int]]) -> Set[int]:\n        visited.add(cell)\n        for neighbor in adjacency_list[cell]:\n            if neighbor not in visited:\n                visited = dfs(neighbor, visited, adjacency_list)\n        return visited\n\n    def find_min_settlers(n: int, m: int, k: int, o: List[int], c: List[int], adjacency_list: List[List[int]]) -> int:\n        visited = set()\n        for cell in o + c:\n            visited = dfs(cell, visited, adjacency_list)\n\n        if len(visited) < n:\n            return \"impossible\"\n\n        return n - len(visited)\n\n    n, m, k, o, c, adjacency_list = read_input()\n    return find_min_settlers(n, m, k, o, c, adjacency_list)"
    },
    {
        "number": 3396,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    posts = []\n    for i in range(1, n+1):\n        x, y = map(int, stdin.split('\\n')[i].split())\n        posts.append((x, y))\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            distance = ((posts[i][0] - posts[j][0])**2 + (posts[i][1] - posts[j][1])**2)**0.5\n            max_distance = max(max_distance, distance)\n\n    return \"{:.2f}\".format(max_distance)"
    },
    {
        "number": 3397,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    dogs = []\n    for i in range(N):\n        dogs.append(list(map(int, stdin.split()[2+i*M:2+(i+1)*M])))\n    \n    max_time = max(max(dog) for dog in dogs)\n    min_time = min(min(dog) for dog in dogs)\n    \n    if max_time == min_time:\n        return str(max_time)\n    \n    min_waiting_time = float('inf')\n    for time in range(min_time, max_time+1):\n        waiting_time = sum(max(dog.count(time) - 1, 0) for dog in dogs)\n        min_waiting_time = min(min_waiting_time, waiting_time)\n    \n    return str(min_waiting_time)"
    },
    {
        "number": 3398,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_rows, n_cols, n, m = map(int, stdin.split()[:4])\n    files = list(map(int, stdin.split()[4:4*n+4:2]))\n    keep = list(map(int, stdin.split()[4:4*n+4:2]))\n    files_to_move = []\n    for file in files:\n        if file not in keep:\n            files_to_move.append(file)\n    return str(len(files_to_move))"
    },
    {
        "number": 3399,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(stdin.split('\\n')[i]) for i in range(1, n+1)]\n    arwegian = [[False for _ in range(m)] for _ in range(n)]\n    banish = [[False for _ in range(m)] for _ in range(n)]\n    cwedish = [[False for _ in range(m)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '1':\n                arwegian[i][j] = True\n            elif grid[i][j] == '2':\n                banish[i][j] = True\n                cwedish[i][j] = True\n\n    def dfs(i, j, visited):\n        if i < 0 or i >= n or j < 0 or j >= m or visited[i][j]:\n            return False\n        visited[i][j] = True\n        if arwegian[i][j]:\n            arwegian[i][j] = False\n            if dfs(i-1, j, visited) or dfs(i+1, j, visited) or dfs(i, j-1, visited) or dfs(i, j+1, visited):\n                return True\n        elif banish[i][j]:\n            banish[i][j] = False\n            if dfs(i-1, j, visited) or dfs(i+1, j, visited) or dfs(i, j-1, visited) or dfs(i, j+1, visited):\n                return True\n        elif cwedish[i][j]:\n            cwedish[i][j] = False\n            if dfs(i-1, j, visited) or dfs(i+1, j, visited) or dfs(i, j-1, visited) or dfs(i, j+1, visited):\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            if dfs(i, j, visited):\n                arwegian_grid = [['.' if arwegian[i][j] else 'A' for j in range(m)] for i in range(n)]\n                banish_grid = [['.' if banish[i][j] else 'B' for j in range(m)] for i in range(n)]\n                cwedish_grid = [['.' if cwedish[i][j] else 'C' for j in range(m)] for i in range(n)]\n                return '\\n'.join([''.join(row) for row in arwegian_grid]) + '\\n\\n' + '\\n'.join([''.join(row) for row in banish_grid]) + '\\n\\n' + '\\n'.join([''.join(row) for row in cwedish_grid])\n\n    return 'impossible'"
    },
    {
        "number": 3400,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, R, T = map(int, stdin.split()[:4])\n    trips = [list(map(int, line.split()[1:])) for line in stdin.split('\\n')[1:]]\n\n    def get_time(a, b):\n        for trip in trips:\n            if a in trip and b in trip:\n                return trip[0]\n        return 12\n\n    def dfs(node, visited, time):\n        if node == R:\n            return time\n        if node in visited:\n            return float('inf')\n        visited.add(node)\n        return min(dfs(neighbor, visited, time + get_time(node, neighbor)) for neighbor in range(1, N + 1) if neighbor not in visited)\n\n    return str(dfs(A, set(), 0))"
    },
    {
        "number": 3401,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t, q = map(int, stdin.split()[:4])\n    hills = []\n    springs = []\n    towns = []\n    for i in range(n):\n        x, y, h = map(int, stdin.split()[4:7])\n        hills.append((x, y, h))\n    springs = list(map(int, stdin.split()[7:7+s]))\n    towns = list(map(int, stdin.split()[7+s:]))\n    \n    # TODO: Implement the solution\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3402,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    S = lines[0]\n    T = lines[1:33]\n    K = int(lines[3])\n    M = int(lines[4])\n    m = list(map(int, lines[5:]))\n\n    def f(s: str) -> str:\n        result = \"\"\n        for c in s:\n            result += T[ord(c) - ord('a')]\n        return result\n\n    P = S\n    for _ in range(K):\n        P = f(P)\n\n    output = \"\"\n    for i in m:\n        output += P[i - 1]\n\n    return output"
    },
    {
        "number": 3403,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split('\\n')\n    n = int(words[0])\n    database = words[1:n+1]\n    q = int(words[n+1])\n    queries = words[n+2:]\n    \n    result = []\n    \n    for query in queries:\n        steps = 0\n        for word in database:\n            common_prefix = ''\n            for i in range(min(len(query), len(word))):\n                if query[i] == word[i]:\n                    common_prefix += query[i]\n                else:\n                    break\n            steps += len(common_prefix)\n            if common_prefix == query:\n                break\n        result.append(str(steps))\n    \n    return '\\n'.join(result)"
    },
    {
        "number": 3404,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X = map(int, stdin.split())\n    encrypted_text = stdin.split()[1]\n\n    def f(x):\n        return (33 * x + 1) % (2**20)\n\n    def create_grid(X):\n        grid = [[0] * X for _ in range(X)]\n        for i in range(X):\n            grid[0][i] = f(i)\n        for i in range(1, X):\n            for j in range(X):\n                grid[i][j] = f(grid[i - 1][j])\n        return grid\n\n    def sum_columns(grid):\n        column_sums = [0] * X\n        for i in range(X):\n            for j in range(X):\n                column_sums[i] += grid[j][i]\n        return column_sums\n\n    def base_10_to_base_27(num):\n        base_27 = \"\"\n        while num > 0:\n            remainder = num % 27\n            if remainder < 10:\n                base_27 += str(remainder)\n            else:\n                base_27 += chr(ord('A') + remainder - 10)\n            num //= 27\n        return base_27[::-1]\n\n    def decrypt(encrypted_text, column_sums):\n        decrypted_text = \"\"\n        for i, letter in enumerate(encrypted_text):\n            if letter == \" \":\n                decrypted_text += \" \"\n            else:\n                shift = ord(letter) - ord('A')\n                decrypted_letter = (shift + column_sums[i % X]) % 27\n                decrypted_text += chr(ord('A') + decrypted_letter)\n        return decrypted_text\n\n    grid = create_grid(X)\n    column_sums = sum_columns(grid)\n    base_27_pad = base_10_to_base_27(int(\"\".join(str(x) for x in column_sums)))\n    decrypted_text = decrypt(encrypted_text, base_27_pad)\n\n    return decrypted_text"
    },
    {
        "number": 3405,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = float(stdin)\n    result = []\n    for i in range(1, 10**8):\n        if int(i * X) == int(str(i * X)[1:] + str(i * X)[0]):\n            result.append(i)\n    if not result:\n        return \"No solution\"\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3406,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_non_degenerate_quadrilateral(points):\n        def ccw(a, b, c):\n            return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\n        a, b, c, d = points\n        return ccw(a, c, d) > 0 and ccw(b, c, d) > 0 and ccw(a, b, c) > 0 and ccw(a, b, d) > 0\n\n    def is_in_danger(castle, points):\n        return any(is_non_degenerate_quadrilateral([castle, *quad]) for quad in itertools.combinations(points, 4))\n\n    def parse_input(stdin: str) -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]]]:\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        nazi_points = [tuple(map(int, line.split())) for line in lines[1:n+1]]\n        s = int(lines[n+1])\n        castle_points = [tuple(map(int, line.split())) for line in lines[n+2:n+s+2]]\n        return nazi_points, castle_points\n\n    stdin = stdin.strip()\n    nazi_points, castle_points = parse_input(stdin)\n\n    in_danger_castles = sum(is_in_danger(castle, nazi_points) for castle in castle_points)\n\n    return str(in_danger_castles)"
    },
    {
        "number": 3407,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    connections = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    \n    # Create a dictionary to store the coordinates of each point\n    coordinates = {i: (0, 0) for i in range(1, n+1)}\n    \n    # Recursively place the points\n    def place_points(point, visited):\n        if point in visited:\n            return\n        visited.add(point)\n        \n        for neighbor in connections:\n            if point in neighbor:\n                other_point = neighbor[0] if neighbor[1] == point else neighbor[1]\n                if other_point not in coordinates:\n                    place_points(other_point, visited)\n                \n                # Calculate the coordinates of the point based on the distance and the coordinates of its neighbor\n                distance = 1\n                dx = coordinates[other_point][0] - coordinates[point][0]\n                dy = coordinates[other_point][1] - coordinates[point][1]\n                if dx == 0:\n                    coordinates[point] = (coordinates[point][0], coordinates[point][1] + distance)\n                elif dy == 0:\n                    coordinates[point] = (coordinates[point][0] + distance, coordinates[point][1])\n                else:\n                    slope = dy / dx\n                    if dx > 0:\n                        coordinates[point] = (coordinates[point][0] + distance / slope, coordinates[point][1] + distance)\n                    else:\n                        coordinates[point] = (coordinates[point][0] - distance / slope, coordinates[point][1] + distance)\n                \n    place_points(1, set())\n    \n    # Check if the coordinates satisfy the constraints\n    def check_constraints(coordinates):\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                if i != j:\n                    dx = coordinates[i][0] - coordinates[j][0]\n                    dy = coordinates[i][1] - coordinates[j][1]\n                    distance = (dx**2 + dy**2)**0.5\n                    if distance < 10**(-4):\n                        return False\n                    if distance < 10**(-6) and (dx == 0 or dy == 0):\n                        return False\n        return True\n    \n    if not check_constraints(coordinates):\n        return \"No solution found\"\n    \n    # Convert the coordinates to a string\n    result = \"\"\n    for i in range(1, n+1):\n        result += f\"{coordinates[i][0]:.6f} {coordinates[i][1]:.6f}\\n\"\n    \n    return result"
    },
    {
        "number": 3408,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words, patterns = stdin.split('\\n')\n    words = words.split('\\n')\n    patterns = patterns.split('\\n')\n    result = []\n\n    for pattern in patterns:\n        count = 0\n        for word in words:\n            if len(pattern) == len(word):\n                if pattern == word:\n                    count += 1\n                else:\n                    for i in range(len(pattern)):\n                        if pattern[i] == '*':\n                            count += 1\n                            break\n        result.append(str(count))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3409,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def hammer_peg(board, row, col):\n        if board[row][col] == 'O':\n            board[row][col] = 'X'\n            for i in range(len(board)):\n                if board[i][col] == 'O':\n                    board[i][col] = 'X'\n                elif board[i][col] == 'X':\n                    board[i][col] = 'O'\n            for j in range(len(board[0])):\n                if board[row][j] == 'O':\n                    board[row][j] = 'X'\n                elif board[row][j] == 'X':\n                    board[row][j] = 'O'\n\n    def is_solvable(start, target):\n        for i in range(len(start)):\n            for j in range(len(start[0])):\n                if start[i][j] == 'O' and target[i][j] == 'X':\n                    hammer_peg(start, i, j)\n                    if is_solvable(start, target):\n                        return True\n                    hammer_peg(start, i, j)\n        return start == target\n\n    lines = stdin.split('\\n')\n    r, c = map(int, lines[0].split())\n    start = [list(lines[i + 1]) for i in range(r)]\n    target = [list(lines[i + 1 + r]) for i in range(r)]\n\n    return '1' if is_solvable(start, target) else '0'"
    },
    {
        "number": 3410,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_valid_quadrilateral(quadrilateral):\n        return not any(p in quadrilateral for p in quadrilateral[:-1])\n\n    def area(quadrilateral):\n        return abs((quadrilateral[0][0] - quadrilateral[1][0]) * (quadrilateral[2][1] - quadrilateral[0][1]) - (quadrilateral[0][0] - quadrilateral[2][0]) * (quadrilateral[1][1] - quadrilateral[0][1]))\n\n    def score(quadrilateral):\n        return 2 * area(quadrilateral)\n\n    def optimal_score(points):\n        points_set = set(points)\n        max_score = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    for l in range(k + 1, len(points)):\n                        quadrilateral = (points[i], points[j], points[k], points[l])\n                        if is_valid_quadrilateral(quadrilateral):\n                            max_score = max(max_score, score(quadrilateral))\n        return max_score\n\n    return str(optimal_score(points) % 1000003)"
    },
    {
        "number": 3411,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, r = map(int, stdin.split()[:3])\n    scores = list(map(int, stdin.split()[3:]))\n\n    def is_alternating(scores: List[int]) -> bool:\n        if len(scores) <= 1:\n            return True\n        if scores[0] == 0:\n            return False\n        for i in range(1, len(scores)):\n            if scores[i] == 0:\n                return False\n            if (scores[i] > 0 and scores[i - 1] < 0) or (scores[i] < 0 and scores[i - 1] > 0):\n                continue\n            return False\n        return True\n\n    def upvote_downvote(scores: List[int], upvote_index: int, downvote_index: int) -> List[int]:\n        new_scores = scores.copy()\n        new_scores[upvote_index] += 1\n        new_scores[downvote_index] -= 1\n        return new_scores\n\n    def report_comment(scores: List[int], index: int) -> List[int]:\n        new_scores = scores.copy()\n        new_scores[index] = 0\n        return new_scores\n\n    def find_alternating_chain(scores: List[int]) -> int:\n        if is_alternating(scores):\n            return 0\n\n        for i in range(len(scores)):\n            for j in range(i + 1, len(scores)):\n                if (scores[i] > 0 and scores[j] < 0) or (scores[i] < 0 and scores[j] > 0):\n                    new_scores = upvote_downvote(scores, i, j)\n                    time = find_alternating_chain(new_scores)\n                    if time != -1:\n                        return time + c + r\n\n        for i in range(len(scores)):\n            if scores[i] != 0:\n                new_scores = report_comment(scores, i)\n                time = find_alternating_chain(new_scores)\n                if time != -1:\n                    return time + r\n\n        return -1\n\n    time = find_alternating_chain(scores)\n    return str(time)"
    },
    {
        "number": 3412,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    v_walk, v_bike, x1, y1, x2, y2, x_G, y_G, x_D, y_D, n = map(int, stdin.split())\n\n    # Calculate distance between Gladstone and Daisy\n    distance = ((x_G - x_D) ** 2 + (y_G - y_D) ** 2) ** 0.5\n\n    # Calculate time to get to Daisy by foot\n    time_foot = distance / v_walk\n\n    # Calculate time to get to Daisy by bike\n    time_bike = distance / v_bike\n\n    # Return the fastest time\n    return min(time_foot, time_bike)"
    },
    {
        "number": 3413,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    parties = list(map(int, stdin.split()[2:]))\n    friends = []\n    for _ in range(m):\n        a, b = map(int, stdin.split()[2:])\n        friends.append((a-1, b-1))\n        friends.append((b-1, a-1))\n    \n    def dfs(node: int, party: int, visited: set) -> None:\n        visited.add(node)\n        parties[node] = party\n        for friend in friends:\n            if friend[0] == node and friend[1] not in visited:\n                dfs(friend[1], party, visited)\n    \n    visited = set()\n    for i in range(n):\n        if i not in visited:\n            dfs(i, parties[i], visited)\n    \n    return str(max(parties.count(0), parties.count(1)))"
    },
    {
        "number": 3414,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import math\n\n    def eulerian_circuit(graph):\n        def dfs(node, visited, path):\n            if len(path) == len(graph):\n                return path\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    path.append((node, neighbor))\n                    result = dfs(neighbor, visited, path)\n                    if result:\n                        return result\n                    path.pop()\n                    visited.remove(neighbor)\n            return None\n\n        visited = set()\n        path = []\n        for node in graph:\n            if node not in visited:\n                visited.add(node)\n                path.append((node, None))\n                result = dfs(node, visited, path)\n                if result:\n                    return result\n                path.pop()\n                visited.remove(node)\n        return None\n\n    def calculate_turning(path):\n        turning = 0\n        for i in range(len(path) - 1):\n            x1, y1 = path[i]\n            x2, y2 = path[i + 1]\n            turning += math.atan2(y2 - y1, x2 - x1)\n        return turning\n\n    N, M = map(int, stdin.split()[0:2])\n    nodes = [tuple(map(int, line.split())) for line in stdin.split()[2:2 * N + 2]]\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[2 * N + 2:]]\n\n    graph = {i: [] for i in range(N)}\n    for i, j in edges:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    path = eulerian_circuit(graph)\n    turning = calculate_turning(path)\n\n    return f\"{turning:.6f}\""
    },
    {
        "number": 3415,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N < 1 or N > 15:\n        raise ValueError(\"Invalid input. N must be between 1 and 15.\")\n\n    def build_tree(level: int, start: int, end: int) -> List[int]:\n        if level == 0:\n            return [start]\n\n        mid = (start + end) // 2\n        left = build_tree(level - 1, start, mid)\n        right = build_tree(level - 1, mid + 1, end)\n\n        return [sum(left) - sum(right)] + left + right\n\n    tree = build_tree(N, 1, 2 ** N - 1)\n    return \" \".join(map(str, tree))"
    },
    {
        "number": 3416,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    train_lines = []\n    for line in stdin.split('\\n')[2:]:\n        a, b = map(int, line.split())\n        train_lines.append((a, b))\n\n    # Find all possible routes\n    routes = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                routes.append((i+1, j+1))\n\n    # Find the minimum number of flights\n    min_flights = float('inf')\n    for route in routes:\n        flights = 0\n        visited = set()\n        current = route[0]\n        while current not in visited:\n            visited.add(current)\n            flights += 1\n            next_city = None\n            for line in train_lines:\n                if current in line:\n                    if line[0] == current:\n                        next_city = line[1]\n                    else:\n                        next_city = line[0]\n                    break\n            current = next_city\n        if len(visited) == n:\n            min_flights = min(min_flights, flights)\n\n    # Find the cities with airports\n    airports = set()\n    for route in routes:\n        if route[0] == route[1]:\n            continue\n        flights = 0\n        visited = set()\n        current = route[0]\n        while current not in visited:\n            visited.add(current)\n            flights += 1\n            next_city = None\n            for line in train_lines:\n                if current in line:\n                    if line[0] == current:\n                        next_city = line[1]\n                    else:\n                        next_city = line[0]\n                    break\n            current = next_city\n        if flights == min_flights:\n            airports.add(route[0])\n            airports.add(route[1])\n\n    return str(min_flights) + '\\n' + ' '.join(map(str, sorted(list(airports))))"
    },
    {
        "number": 3417,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split()[-2:])\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node, visited):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n\n    max_independent_set = 0\n    for i in range(1, n+1):\n        visited = set()\n        dfs(i, visited)\n        max_independent_set = max(max_independent_set, len(visited))\n\n    return str(max_independent_set)"
    },
    {
        "number": 3418,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    supply = 0\n    for k in range(1, n + 1):\n        supply += n // k\n    return str(supply)"
    },
    {
        "number": 3419,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s1, s2 = map(int, stdin.split()[:3])\n    times = list(map(int, stdin.split()[3:]))\n    max_customers = min(s1, s2)\n    \n    for time in times:\n        if time <= max_customers:\n            max_customers -= time\n        else:\n            break\n    \n    return str(max_customers)"
    },
    {
        "number": 3420,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input(stdin: str) -> Tuple[int, int, List[str], List[str]]:\n        lines = stdin.split('\\n')\n        b, g = map(int, lines[0].split())\n        boys = []\n        girls = []\n        for i in range(1, b + 1):\n            name, n_books = lines[i].split()\n            books = lines[i + 1:i + 1 + int(n_books)]\n            boys.append((name, books))\n            i += int(n_books)\n        for i in range(b + 1, b + g + 1):\n            name, n_books = lines[i].split()\n            books = lines[i + 1:i + 1 + int(n_books)]\n            girls.append((name, books))\n            i += int(n_books)\n        return b, g, boys, girls\n\n    def count_presentations(boys: List[Tuple[str, List[str]]], girls: List[Tuple[str, List[str]]]) -> int:\n        presentations = 0\n        for boy in boys:\n            for girl in girls:\n                presentations += len(set(boy[1]) & set(girl[1]))\n        return presentations\n\n    b, g, boys, girls = read_input(stdin)\n    presentations = count_presentations(boys, girls)\n    return str(presentations)"
    },
    {
        "number": 3421,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split('\\n')[0])\n    results = stdin.split('\\n')[1]\n    \n    max_success_rate = 0\n    best_subsequence = (0, 0)\n    \n    for i in range(len(results) - k + 1):\n        success_count = 0\n        for j in range(k):\n            if results[i+j] == '1':\n                success_count += 1\n        success_rate = success_count / k\n        \n        if success_rate > max_success_rate:\n            max_success_rate = success_rate\n            best_subsequence = (i+1, k)\n    \n    return f\"{best_subsequence[0]} {best_subsequence[1]}\""
    },
    {
        "number": 3422,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_map(map_piece: List[List[int]]) -> List[List[int]]:\n        return list(zip(*map_piece[::-1]))\n\n    def is_valid_map(map_pieces: List[List[List[int]]], width: int, height: int) -> bool:\n        for i in range(width):\n            for j in range(height):\n                if all(map_pieces[k][i][j] != map_pieces[l][i][j] for k in range(len(map_pieces)) for l in range(k + 1, len(map_pieces))):\n                    continue\n                return False\n        return True\n\n    def assemble_map(map_pieces: List[List[List[int]]], width: int, height: int) -> List[List[int]]:\n        reconstructed_map = [[0] * width for _ in range(height)]\n        for i, map_piece in enumerate(map_pieces):\n            for j in range(len(map_piece)):\n                for k in range(len(map_piece[j])):\n                    if map_piece[j][k] != 0:\n                        reconstructed_map[j][k] = i + 1\n        return reconstructed_map\n\n    def print_map(map_pieces: List[List[List[int]]], reconstructed_map: List[List[int]]) -> None:\n        for i in range(len(reconstructed_map)):\n            for j in range(len(reconstructed_map[i])):\n                print(reconstructed_map[i][j], end=\"\")\n            print()\n        print(\"-\" * len(reconstructed_map[0]))\n        for i in range(len(reconstructed_map)):\n            for j in range(len(reconstructed_map[i])):\n                print(reconstructed_map[i][j], end=\"\")\n            print()\n\n    stdin = stdin.strip()\n    lines = stdin.split(\"\\n\")\n    num_map_pieces = int(lines[0])\n    map_pieces = []\n\n    for i in range(1, num_map_pieces + 1):\n        width, height = map(int, lines[i].split())\n        map_piece = []\n        for j in range(height):\n            map_piece.append(list(map(int, lines[i + j + 1].split())))\n        map_pieces.append(map_piece)\n\n    for i in range(4):\n        for j in range(len(map_pieces)):\n            map_pieces[j] = rotate_map(map_pieces[j])\n        if is_valid_map(map_pieces, width, height):\n            reconstructed_map = assemble_map(map_pieces, width, height)\n            print_map(map_pieces, reconstructed_map)\n            return\n\n    return \"No valid map found.\""
    },
    {
        "number": 3423,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_dependencies(package_name: str, packages: dict) -> list:\n        return packages[package_name]\n\n    def topological_sort(graph: dict) -> list:\n        visited = set()\n        stack = []\n\n        def visit(node: str):\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph.get(node, []):\n                    visit(neighbor)\n                stack.append(node)\n\n        for node in graph.keys():\n            visit(node)\n\n        return stack[::-1]\n\n    def build_graph(packages: dict) -> dict:\n        graph = {}\n        for package_name, dependencies in packages.items():\n            for dependency in dependencies:\n                graph.setdefault(dependency, []).append(package_name)\n        return graph\n\n    def parse_input(input_str: str) -> dict:\n        packages = {}\n        lines = input_str.split('\\n')\n        for line in lines:\n            if not line:\n                break\n            package_name, dependencies = line.split(' ', 1)\n            packages[package_name] = dependencies.split()\n        return packages\n\n    result = []\n    for test_case in stdin.split('\\n\\n'):\n        if not test_case.strip():\n            break\n        packages = parse_input(test_case)\n        graph = build_graph(packages)\n        try:\n            order = topological_sort(graph)\n            result.append('\\n'.join(order))\n        except:\n            result.append('cannot be ordered')\n\n    return '\\n\\n'.join(result)"
    },
    {
        "number": 3424,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, l = map(int, stdin.split())\n    b = 10\n    while True:\n        if all(digit in '0123456789' for digit in str(y)) and y >= l:\n            return str(b)\n        b += 1\n        y = y * b"
    },
    {
        "number": 3425,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    board = [list(line.strip()) for line in stdin.split()[2:]]\n    max_queens = 0\n    ways = 0\n\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == '.':\n                max_queens += 1\n                ways += count_ways(board, i, j, n, m, max_queens)\n\n    return f\"{max_queens} {ways}\"\n\ndef"
    },
    {
        "number": 3426,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    tunnels = []\n    for i in range(M):\n        a, b, l, c = map(int, stdin.split()[4*i:4*(i+1)])\n        tunnels.append((a, b, l, c))\n\n    def dfs(start, end, visited, path_length):\n        if start == end:\n            return path_length\n        visited.add(start)\n        min_length = float('inf')\n        for tunnel in tunnels:\n            a, b, l, c = tunnel\n            if c == 1 and (a, b) not in visited and (b, a) not in visited:\n                if a == start:\n                    min_length = min(min_length, dfs(b, end, visited, path_length + l))\n                elif b == start:\n                    min_length = min(min_length, dfs(a, end, visited, path_length + l))\n        visited.remove(start)\n        return min_length\n\n    result = []\n    for tunnel in tunnels:\n        a, b, l, c = tunnel\n        if l == '?':\n            min_length = dfs(a, 1, set(), 0)\n            result.append(min_length)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3427,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    doors = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n    \n    # Create a graph with rooms as nodes and doors as edges\n    graph = {i: set() for i in range(-1, N)}\n    for u, v in doors:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    # Find the room with the most number of doors leading to it\n    max_room = max(graph, key=lambda x: len(graph[x]))\n    \n    # Count the number of rooms that can be reached from the outside\n    count = 0\n    visited = set()\n    def dfs(room):\n        nonlocal count\n        if room in visited:\n            return\n        visited.add(room)\n        if room == -1:\n            count += 1\n        for neighbor in graph[room]:\n            dfs(neighbor)\n    \n    for room in graph:\n        dfs(room)\n    \n    # Return the number of rooms that can be secured\n    return str(count - 1)"
    },
    {
        "number": 3428,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split('\\n')\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n    \n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    def f(i, j):\n        return gcd(*sequence[i:j+1])\n    \n    distinct_values = set()\n    for i in range(n):\n        for j in range(i, n):\n            distinct_values.add(f(i, j))\n    \n    return str(len(distinct_values))"
    },
    {
        "number": 3429,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_s, y_s, s_s, r_i, r_f, x_a, y_a, s_a = map(int, stdin.split())\n\n    # Calculate the distance between the safety zone and the player\n    distance = ((x_s - x_a) ** 2 + (y_s - y_a) ** 2) ** 0.5\n\n    # Calculate the time it takes for the player to reach the safety zone\n    time = distance / s_a\n\n    # Calculate the radius of the safety zone at the time the player reaches it\n    radius = r_i - time * s_s\n\n    # Calculate the minimum damage the player will take\n    if radius <= r_f:\n        damage = 0\n    else:\n        damage = time * s_s\n\n    return f\"{damage:.6f}\""
    },
    {
        "number": 3430,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    A_cables = [tuple(map(int, line.split())) for line in lines[1:N]]\n    M = int(lines[N])\n    B_cables = [tuple(map(int, line.split())) for line in lines[N+1:]]\n\n    # Find the minimum transmission cost\n    min_cost = float('inf')\n    for u in range(1, N+1):\n        for v in range(1, M+1):\n            cost = 0\n            for cable in A_cables + B_cables + [(u, v)]:\n                cost += cable[0] * cable[1]\n            min_cost = min(min_cost, cost)\n\n    return str(min_cost)"
    },
    {
        "number": 3431,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import heapq\n    from collections import defaultdict\n\n    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def mst_weight(points):\n        n = len(points)\n        edges = []\n        visited = set()\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (i, j) not in visited and (j, i) not in visited:\n                    edges.append((i, j, manhattan_distance(points[i], points[j])))\n\n        edges.sort(key=lambda x: x[2])\n\n        def kruskal(edges, n):\n            parent = list(range(n))\n            rank = [0] * n\n\n            def find(x):\n                if parent[x] != x:\n                    parent[x] = find(parent[x])\n                return parent[x]\n\n            def union(x, y):\n                root_x = find(x)\n                root_y = find(y)\n                if root_x != root_y:\n                    if rank[root_x] > rank[root_y]:\n                        parent[root_y] = root_x\n                    else:\n                        parent[root_x] = root_y\n                        if rank[root_x] == rank[root_y]:\n                            rank[root_y] += 1\n\n            mst_weight = 0\n            for edge in edges:\n                if find(edge[0]) != find(edge[1]):\n                    union(edge[0], edge[1])\n                    mst_weight += edge[2]\n\n            return mst_weight\n\n        return kruskal(edges, n)\n\n    points = []\n    for line in stdin.split('\\n'):\n        if line:\n            x, y = map(int, line.split())\n            points.append((x, y))\n\n    return str(mst_weight(points))"
    },
    {
        "number": 3432,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_sum(a, b):\n        a.sort(reverse=True)\n        b.sort(reverse=True)\n        return sum(a[i] + b[i] for i in range(len(a)))\n\n    input_lines = stdin.split(\"\\n\")\n    n = int(input_lines[0])\n    output = []\n\n    for i in range(1, n + 1):\n        a, b = map(int, input_lines[i].split())\n        a_list = list(range(1, a + 1))\n        b_list = list(range(1, b + 1))\n        output.append(max_sum(a_list, b_list))\n\n    return \"\\n\".join(map(str, output))"
    },
    {
        "number": 3433,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    maze = [list(row) for row in stdin.split()[1:]]\n    joe_pos = None\n    fire_pos = []\n\n    for i in range(R):\n        for j in range(C):\n            if maze[i][j] == 'J':\n                joe_pos = (i, j)\n            elif maze[i][j] == 'F':\n                fire_pos.append((i, j))\n\n    if not joe_pos:\n        return \"IMPOSSIBLE\"\n\n    def bfs(start, end, maze):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, time = queue.pop(0)\n            if current == end:\n                return time\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in get_neighbors(current, maze):\n                if neighbor not in visited:\n                    queue.append((neighbor, time + 1))\n        return None\n\n    def get_neighbors(pos, maze):\n        i, j = pos\n        neighbors = [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]\n        return [(x, y) for x, y in neighbors if 0 <= x < R and 0 <= y < C and maze[x][y] != '#']\n\n    def is_on_fire(pos, fire_pos):\n        return pos in fire_pos\n\n    def is_exit(pos, maze):\n        i, j = pos\n        return i == 0 or j == 0 or i == R - 1 or j == C - 1\n\n    def escape_time(joe_pos, fire_pos, maze):\n        time = 0\n        while not is_exit(joe_pos, maze) and not is_on_fire(joe_pos, fire_pos):\n            time += 1\n            joe_pos = bfs(joe_pos, get_neighbors(joe_pos, maze)[0], maze)\n        return time\n\n    return escape_time(joe_pos, fire_pos, maze)"
    },
    {
        "number": 3434,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split()[:3])\n    my_health = list(map(int, stdin.split()[3:3+n]))\n    opp_health = list(map(int, stdin.split()[3+n:]))\n\n    # Calculate the probability of each minion being hit\n    probabilities = [1 / len(opp_health)] * len(opp_health)\n\n    # Calculate the probability of each minion surviving the explosion\n    survival_probabilities = [1 - (d / health) for health in opp_health]\n\n    # Calculate the probability of each minion being hit and surviving the explosion\n    hit_and_survive_probabilities = [probabilities[i] * survival_probabilities[i] for i in range(len(opp_health))]\n\n    # Calculate the probability of all minions being hit and surviving the explosion\n    total_probability = sum(hit_and_survive_probabilities)\n\n    # Calculate the probability of all minions being removed\n    removal_probability = 1 - total_probability\n\n    return str(removal_probability)"
    },
    {
        "number": 3435,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pattern = stdin.split()\n    n = int(n)\n    pattern = pattern.replace('*', '1')\n    pattern_ones = pattern.count('1')\n    max_ones = n - pattern_ones\n    max_zeros = pattern_ones\n    max_spies = 2**n - 1\n    \n    if max_ones > max_spies:\n        return str(max_spies)\n    else:\n        return str(max_ones + max_zeros)"
    },
    {
        "number": 3436,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def matrix_multiply(a, b):\n        result = [[0, 0], [0, 0]]\n        for i in range(2):\n            for j in range(2):\n                for k in range(2):\n                    result[i][j] += a[i][k] * b[k][j]\n                    result[i][j] %= mod\n        return result\n\n    def matrix_power(matrix, n):\n        if n == 1:\n            return matrix\n        elif n % 2 == 0:\n            half_power = matrix_power(matrix, n // 2)\n            return matrix_multiply(half_power, half_power)\n        else:\n            return matrix_multiply(matrix, matrix_power(matrix, n - 1))\n\n    initial_matrix = [[1, 1], [1, 0]]\n    result_matrix = matrix_power(initial_matrix, x + y - 1)\n\n    return str(result_matrix[0][1])"
    },
    {
        "number": 3437,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L1, L2, N = map(int, stdin.split()[:3])\n    tube_lengths = list(map(int, stdin.split()[3:]))\n    \n    max_length = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                for l in range(k+1, N):\n                    if tube_lengths[i] + tube_lengths[j] <= L1 and tube_lengths[k] + tube_lengths[l] <= L2:\n                        total_length = tube_lengths[i] + tube_lengths[j] + tube_lengths[k] + tube_lengths[l]\n                        if total_length > max_length:\n                            max_length = total_length\n    \n    if max_length == 0:\n        return \"Impossible\"\n    else:\n        return str(max_length)"
    },
    {
        "number": 3438,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cache_size, num_objects, num_accesses = map(int, stdin.split()[:3])\n    objects = list(map(int, stdin.split()[3:]))\n\n    cache = {}\n    cache_misses = 0\n\n    for obj in objects:\n        if obj not in cache:\n            cache_misses += 1\n            if len(cache) == cache_size:\n                cache.pop(min(cache, key=cache.get))\n            cache[obj] = True\n\n    return str(cache_misses)"
    },
    {
        "number": 3439,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w, grid, i, j = parse_input(stdin)\n    drained_volume = 0\n\n    for y in range(h):\n        for x in range(w):\n            if grid[y][x] < 0:\n                drained_volume += drain_water(grid, y, x)\n\n    return str(drained_volume)\n\ndef"
    },
    {
        "number": 3440,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    N, R, flights, F, additional_flights = parse_input(stdin)\n\n    # Create a graph representing the airport connections\n    graph = create_graph(flights)\n\n    # Find the minimum cost to review all the flights\n    min_cost = find_min_cost(graph, N, R, additional_flights)\n\n    return str(min_cost)\n\ndef"
    },
    {
        "number": 3441,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    def dfs(start, visited, path):\n        visited[start] = True\n        path.append(start)\n        for end in range(n):\n            if not visited[end] and (start, end) in roads:\n                dfs(end, visited, path)\n        path.append(start)\n    \n    max_trips = 0\n    for i in range(n):\n        visited = [False] * n\n        path = []\n        dfs(i, visited, path)\n        trips = 0\n        for j in range(len(path) - 1):\n            for k in range(j + 2, len(path)):\n                if path[j:k+1] == path[k:j:-1]:\n                    trips += 1\n        max_trips = max(max_trips, trips)\n    \n    return str(max_trips)"
    },
    {
        "number": 3442,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    count = 0\n    for num in range(X, Y + 1):\n        binary_num = bin(num)[2:]\n        if is_sheldon(binary_num):\n            count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3443,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n = int(stdin.splitlines()[0])\n    spots = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Check if the spots are already symmetric\n    for spot1 in spots:\n        for spot2 in spots:\n            if spot1 != spot2 and (spot1[0] + spot2[0], spot1[1] + spot2[1]) not in spots:\n                return \"0\"\n\n    # If not, find the fewest additional spots needed to generate symmetry\n    min_spots = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            spot1 = spots[i]\n            spot2 = spots[j]\n            if spot1 != spot2:\n                # Check if the spots are already symmetric\n                if (spot1[0] + spot2[0], spot1[1] + spot2[1]) in spots:\n                    continue\n\n                # Check if the spots are symmetric across a line\n                slope = (spot1[1] - spot2[1]) / (spot1[0] - spot2[0])\n                y_intercept = spot1[1] - slope * spot1[0]\n                for k in range(n):\n                    if k != i and k != j:\n                        spot3 = spots[k]\n                        if spot3[0] * slope + y_intercept == spot3[1]:\n                            min_spots = min(min_spots, 2)\n                            break\n                else:\n                    # Check if the spots are symmetric around a point\n                    midpoint = ((spot1[0] + spot2[0]) / 2, (spot1[1] + spot2[1]) / 2)\n                    for k in range(n):\n                        if k != i and k != j:\n                            spot3 = spots[k]\n                            if (spot3[0] - midpoint[0]) ** 2 + (spot3[1] - midpoint[1]) ** 2 == (spot1[0] - midpoint[0]) ** 2 + (spot1[1] - midpoint[1]) ** 2:\n                                min_spots = min(min_spots, 1)\n                                break\n\n    return str(min_spots)"
    },
    {
        "number": 3444,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    pistes = []\n    for _ in range(M):\n        a, b, w = map(int, stdin.split()[2:])\n        pistes.append((a, b, w))\n\n    probabilities = [0] * N\n    probabilities[N-1] = 1\n\n    for k in range(N-2, -1, -1):\n        for a, b, w in pistes:\n            if a == k:\n                probabilities[k] = max(probabilities[k], probabilities[b] * (1 - w))\n            elif b == k:\n                probabilities[k] = max(probabilities[k], probabilities[a] * (1 - w))\n\n    return \" \".join(str(round(p, 9)) if p >= 0 else \"-1\" for p in probabilities)"
    },
    {
        "number": 3445,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    customers = []\n    for i in range(1, n+1):\n        x, y = map(int, lines[i].split())\n        customers.append((x, y))\n\n    customers.sort(key=lambda x: (x[0], x[1]))\n\n    def divide_customers(customers: list) -> tuple:\n        n = len(customers)\n        if n == 1:\n            return (0, 0)\n        if n == 2:\n            return (abs(customers[0][0] - customers[1][0]) + abs(customers[0][1] - customers[1][1]), 0)\n\n        mid = n // 2\n        left_customers = customers[:mid]\n        right_customers = customers[mid:]\n\n        left_max_delivery_time, right_max_delivery_time = divide_customers(left_customers), divide_customers(right_customers)\n\n        max_delivery_time = max(left_max_delivery_time, right_max_delivery_time)\n\n        for i in range(mid):\n            for j in range(mid, n):\n                max_delivery_time = max(max_delivery_time, abs(customers[i][0] - customers[j][0]) + abs(customers[i][1] - customers[j][1]))\n\n        return (max_delivery_time, max_delivery_time)\n\n    max_delivery_time = max(divide_customers(customers))\n    return str(max_delivery_time)"
    },
    {
        "number": 3446,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    k = int(lines[0])\n    symbols = lines[1].split()\n    assembly_table = []\n    for i in range(2, 2 + k):\n        assembly_table.append(lines[i].split())\n\n    n = int(lines[2 + k])\n    sequences = lines[3 + k:3 + k + n]\n\n    def get_time_and_result(sequence: str) -> tuple:\n        time = 0\n        result = ''\n        for i in range(len(sequence)):\n            for j in range(i + 1, len(sequence)):\n                for k in range(len(assembly_table)):\n                    if assembly_table[k][0] == sequence[i] + '-' + sequence[j] and assembly_table[k][1] == sequence[j] + '-' + sequence[i]:\n                        time += int(assembly_table[k][0].split('-')[0])\n                        result = assembly_table[k][1].split('-')[1]\n                        break\n        return time, result\n\n    results = []\n    for sequence in sequences:\n        results.append(get_time_and_result(sequence))\n\n    min_time = min(results, key=lambda x: x[0])[0]\n    min_time_results = [result for result in results if result[0] == min_time]\n\n    sorted_min_time_results = sorted(min_time_results, key=lambda x: symbols.index(x[1]))\n\n    return '\\n'.join([f'{result[0]}-{result[1]}' for result in sorted_min_time_results])"
    },
    {
        "number": 3447,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    dictionary = []\n    queries = []\n    stdin = stdin.split('\\n')\n    N = int(stdin[0])\n    for i in range(1, N+1):\n        dictionary.append(stdin[i])\n    Q = int(stdin[N+1])\n    for i in range(N+2, N+2+Q):\n        queries.append(stdin[i])\n    \n    def find_word(word: str, dictionary: list) -> str:\n        for i in range(len(dictionary)):\n            if dictionary[i] == word:\n                return i\n        return -1\n    \n    def find_next_word(index: int, dictionary: list) -> str:\n        for i in range(index+1, len(dictionary)):\n            if dictionary[i][0] == dictionary[index][0]:\n                return i\n        return -1\n    \n    def find_prev_word(index: int, dictionary: list) -> str:\n        for i in range(index-1, -1, -1):\n            if dictionary[i][0] == dictionary[index][0]:\n                return i\n        return -1\n    \n    def find_min_keypress(word: str, dictionary: list) -> str:\n        index = find_word(word, dictionary)\n        if index == -1:\n            return \"\"\n        result = \"\"\n        while index != 0:\n            prev_word = find_prev_word(index, dictionary)\n            if prev_word == -1:\n                result += str(ord(dictionary[index][0]) - ord('a') + 2)\n                index = 0\n            else:\n                result += str(ord(dictionary[index][0]) - ord('a') + 2) + \"R\"\n                index = prev_word\n        return result[::-1]\n    \n    result = \"\"\n    for query in queries:\n        result += find_min_keypress(query, dictionary) + \"\\n\"\n    \n    return result"
    },
    {
        "number": 3448,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k >= n:\n        return \"NO\"\n\n    MS = [i for i in range(1, n + 1)]\n    ME = [i for i in range(1, n + 1)]\n    VS = [i for i in range(1, n + 1)]\n    VE = [i for i in range(1, n + 1)]\n\n    for i in range(k):\n        MS[i], ME[i] = MS[i], ME[i]\n        VS[i], VE[i] = VS[i], VE[i]\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if MS[i] == MS[j] or ME[i] == ME[j] or VS[i] == VS[j] or VE[i] == VE[j]:\n                return \"NO\"\n            if MS[i] == MS[j] or ME[i] == ME[j]:\n                if VS[i] < VS[j] and VE[i] < VE[j]:\n                    return \"NO\"\n            if VS[i] == VS[j] or VE[i] == VE[j]:\n                if MS[i] < MS[j] and ME[i] < ME[j]:\n                    return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(f\"{MS[i]} {ME[i]}\" for i in range(k)) + \"\\n\" + \"\\n\".join(f\"{VS[i]} {VE[i]}\" for i in range(k))"
    },
    {
        "number": 3449,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split(\"\\n\")\n    B = int(stdin_list[0])\n    H = int(stdin_list[1])\n    R, C = map(int, stdin_list[2].split())\n    lights = [list(line) for line in stdin_list[3:]]\n\n    def light_strength(r, c):\n        return int(lights[r][c])\n\n    def distance(r1, c1, r2, c2):\n        return ((r1 - r2) ** 2 + (c1 - c2) ** 2) ** 0.5\n\n    def fence_cost(r1, c1, r2, c2):\n        if light_strength(r1, c1) >= B and light_strength(r2, c2) >= B:\n            return 43\n        else:\n            return 11\n\n    total_cost = 0\n    for r in range(R):\n        for c in range(C):\n            if light_strength(r, c) < B:\n                for r2 in range(max(0, r - 1), min(R, r + 2)):\n                    for c2 in range(max(0, c - 1), min(C, c + 2)):\n                        if r2 != r or c2 != c:\n                            total_cost += fence_cost(r, c, r2, c2)\n\n    return str(int(total_cost))"
    },
    {
        "number": 3450,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    factorial = 1\n    trailing_zeroes = 0\n\n    for i in range(1, n + 1):\n        factorial *= i\n        trailing_zeroes += n // 5\n\n    last_three_digits = factorial % (10 ** (trailing_zeroes + 3))\n    last_three_digits //= 10 ** (trailing_zeroes - 1)\n\n    return str(last_three_digits)"
    },
    {
        "number": 3451,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    sequence = stdin.split()[2]\n    costs = list(map(int, stdin.split()[3:]))\n\n    # Calculate the minimum sum of effort\n    min_effort = sum(costs)\n\n    # Check if Bruce can always rebalance the sequence\n    for i in range(n):\n        if sequence[i] == '(':\n            for j in range(i + 1, n):\n                if sequence[j] == ')':\n                    new_sequence = list(sequence)\n                    new_sequence[i] = ')'\n                    new_sequence[j] = '('\n                    new_sequence = ''.join(new_sequence)\n                    if is_balanced(new_sequence):\n                        min_effort = min(min_effort, sum(costs[:i]) + sum(costs[i + 1:j]) + sum(costs[j + 1:]))\n\n    return str(min_effort)\n\ndef"
    },
    {
        "number": 3452,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    rooms = {}\n    for i in range(1, n+1):\n        room_data = stdin.splitlines()[i].split()\n        room_exits = room_data[1:]\n        rooms[i] = set(int(room_exits[j]) for j in range(len(room_exits)))\n\n    def is_identical(room1, room2):\n        if len(rooms[room1] & rooms[room2]) != len(rooms[room1]):\n            return False\n        for exit in rooms[room1]:\n            if exit not in rooms[room2]:\n                return False\n        return True\n\n    identical_rooms = []\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if is_identical(i, j):\n                identical_rooms.append((i, j))\n\n    if not identical_rooms:\n        return \"none\"\n\n    result = []\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i, j) in identical_rooms or (j, i) in identical_rooms:\n                continue\n            for k in range(j+1, n+1):\n                if (i, k) in identical_rooms or (k, i) in identical_rooms:\n                    continue\n                for l in range(k+1, n+1):\n                    if (j, l) in identical_rooms or (l, j) in identical_rooms:\n                        continue\n                    if (k, l) in identical_rooms or (l, k) in identical_rooms:\n                        continue\n                    result.append((i, j, k, l))\n\n    return \"\\n\".join(sorted([\" \".join(map(str, sorted(room_set))) for room_set in result]))"
    },
    {
        "number": 3453,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    tunnels = []\n    for _ in range(M):\n        A, B, L = map(int, stdin.split()[2:])\n        tunnels.append((A, B, L))\n\n    def dfs(start: int, visited: set, path_length: int) -> int:\n        if start in visited:\n            return path_length\n        visited.add(start)\n        total_length = path_length\n        for A, B, L in tunnels:\n            if A == start:\n                total_length += dfs(B, visited, L)\n            elif B == start:\n                total_length += dfs(A, visited, L)\n        return total_length\n\n    danger_levels = []\n    for i in range(1, N + 1):\n        danger_levels.append(dfs(i, set(), 0) % (10**9 + 7))\n\n    return \" \".join(map(str, danger_levels))"
    },
    {
        "number": 3454,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    b = list(map(int, stdin.split()))\n    r = [M - c for c in b]\n\n    def is_valid(b, r):\n        if len(b) != len(r):\n            return False\n        for i in range(len(b)):\n            if b[i] + r[i] > M:\n                return False\n        return True\n\n    def count_ways(b, r):\n        if not is_valid(b, r):\n            return 0\n        ways = 1\n        for i in range(len(b)):\n            for j in range(b[i]):\n                ways *= 2\n            ways %= 100003\n            ways *= 2\n            ways %= 100003\n        return ways\n\n    X = 100003\n    Y = count_ways(b, r)\n    Y_m = Y % 100003\n\n    return f\"{X} {Y_m}\""
    },
    {
        "number": 3455,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, R = map(int, stdin.split()[:3])\n    cars = []\n    for i in range(M):\n        lane, length, distance = map(int, stdin.split()[3*i+3:3*i+6])\n        cars.append((lane, length, distance))\n    \n    # ACM car is the first car in the list\n    acm_car = cars[0]\n    acm_lane = acm_car[0]\n    acm_length = acm_car[1]\n    acm_distance = acm_car[2]\n    \n    # Check if ACM car can switch to the rightmost lane\n    if acm_lane == N-1:\n        return \"Impossible\"\n    \n    # Initialize variables\n    max_safety_factor = 0\n    max_distance = 0\n    \n    # Iterate through all cars in the same lane as the ACM car\n    for car in cars[1:]:\n        lane, length, distance = car\n        if lane == acm_lane:\n            # Calculate the distance between the ACM car and the current car\n            distance_to_car = abs(acm_distance - distance)\n            \n            # Calculate the safety factor\n            safety_factor = distance_to_car - (acm_length + length)\n            \n            # Update the maximum safety factor and distance\n            if safety_factor > max_safety_factor:\n                max_safety_factor = safety_factor\n                max_distance = distance_to_car\n    \n    # Check if there is enough space for the ACM car to switch lanes\n    if max_distance < acm_length:\n        return \"Impossible\"\n    \n    return \"{:.5f}\".format(max_safety_factor)"
    },
    {
        "number": 3456,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *crates = map(int, stdin.split())\n    stacks = [crates[i:i+crates[i]] for i in range(0, len(crates), N)]\n    min_actions = 0\n    \n    for i in range(len(stacks)):\n        if len(stacks[i]) == 1:\n            continue\n        elif len(stacks[i]) % 2 == 0:\n            min_actions += len(stacks[i]) // 2\n        else:\n            min_actions += (len(stacks[i]) + 1) // 2\n    \n    return str(min_actions)"
    },
    {
        "number": 3457,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, Y = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[0] * (N+1) for _ in range(N+1)]\n    dp[1][1] = 1\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if i >= X and j >= Y:\n                dp[i][j] = (dp[i-X][j-Y] + dp[i][j-Y] + dp[i-X][j]) % MOD\n    return str(dp[N][N])"
    },
    {
        "number": 3458,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n    max_sum = 0\n    for i in range(1, 2**n):\n        subset = [numbers[j] for j in range(n) if (i >> j) & 1]\n        subset_sum = subset[0]\n        for num in subset[1:]:\n            subset_sum ^= num\n        max_sum = max(max_sum, subset_sum)\n    return str(max_sum)"
    },
    {
        "number": 3459,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_council_members(n, residents):\n        council_members = {}\n        for resident in residents:\n            if len(resident.clubs) == 0:\n                continue\n            for club in resident.clubs:\n                if club not in council_members:\n                    council_members[club] = resident\n                    break\n        return council_members\n\n    def is_valid_council(council_members, parties):\n        party_count = {party: 0 for party in parties}\n        for resident in council_members.values():\n            party_count[resident.party] += 1\n        for count in party_count.values():\n            if count * 2 > len(council_members):\n                return False\n        return True\n\n    def format_output(council_members):\n        output = \"\"\n        for club, resident in council_members.items():\n            output += f\"{resident.name} {club}\\n\"\n        return output\n\n    def process_test_case(n, residents):\n        council_members = find_council_members(n, residents)\n        if len(council_members) == 0:\n            return \"Impossible.\\n\"\n        parties = set(resident.party for resident in residents)\n        if not is_valid_council(council_members, parties):\n            return \"Impossible.\\n\"\n        return format_output(council_members)\n\n    test_cases = stdin.strip().split(\"\\n\\n\")\n    output = \"\"\n    for test_case in test_cases:\n        lines = test_case.strip().split(\"\\n\")\n        n = int(lines[0])\n        residents = []\n        for line in lines[1:]:\n            name, party, num_clubs, *clubs = line.split()\n            residents.append(Resident(name, party, set(clubs)))\n        output += process_test_case(n, residents)\n    return output\n\nclass Resident:\n    def __init__(self, name, party, clubs):\n        self.name = name\n        self.party = party\n        self.clubs = clubs"
    },
    {
        "number": 3460,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cans = []\n    for i in range(1, n+1):\n        x, r = map(int, stdin.split('\\n')[i].split())\n        cans.append((x, r))\n    \n    cans.sort(key=lambda x: x[0])\n    \n    def binary_search(arr, x):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid][0] == x:\n                return mid\n            elif arr[mid][0] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n    \n    result = []\n    for can in cans:\n        x, r = can\n        left = binary_search(cans, x - r)\n        right = binary_search(cans, x + r)\n        result.append(right - left + 1)\n    \n    return ' '.join(map(str, result))"
    },
    {
        "number": 3461,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import random\n\n    def get_hearing_length(a: int, b: int) -> int:\n        return random.randint(a, b)\n\n    def get_hearing_end_time(s: int, length: int) -> int:\n        return s + length\n\n    def get_hearing_start_time(s: int, length: int) -> int:\n        return s\n\n    def get_hearing_end_time_with_length(s: int, length: int) -> int:\n        return s + length\n\n    def get_hearing_start_time_with_length(s: int, length: int) -> int:\n        return s\n\n    def get_hearing_end_time_with_length_and_probability(s: int, length: int, probability: float) -> int:\n        return s + length if random.random() < probability else s + length + 1\n\n    def get_hearing_start_time_with_length_and_probability(s: int, length: int, probability: float) -> int:\n        return s if random.random() < probability else s + 1\n\n    def get_hearing_end_time_with_length_and_probability_and_length(s: int, length: int, probability: float, length_probability: float) -> int:\n        if random.random() < probability:\n            if random.random() < length_probability:\n                return s + length\n            else:\n                return s + length + 1\n        else:\n            return s + length + 2\n\n    def get_hearing_start_time_with_length_and_probability_and_length(s: int, length: int, probability: float, length_probability: float) -> int:\n        if random.random() < probability:\n            if random.random() < length_probability:\n                return s\n            else:\n                return s + 1\n        else:\n            return s + 2\n\n    def get_hearing_end_time_with_length_and_probability_and_length_and_probability(s: int, length: int, probability: float, length_probability: float, probability_probability: float) -> int:\n        if random.random() < probability:\n            if random.random() < length_probability:\n                if random.random() < probability_probability:\n                    return s + length\n                else:\n                    return s + length + 1\n            else:\n                return s + length + 2\n        else:\n            return s + length + 3\n\n    def get_hearing_start_time_with_length_and_probability_and_length_and_probability(s: int, length: int, probability: float, length_probability: float, probability_probability: float) -> int:\n        if random.random() < probability:\n            if random.random() < length_probability:\n                if random.random() < probability_probability:\n                    return s\n                else:\n                    return s + 1\n            else:\n                return s + 2\n        else:\n            return s + 3\n\n    def get_hearing_end_time_with_length_and_probability_and_length_and_probability_and_probability(s: int, length: int, probability: float, length_probability: float, probability_probability: float, probability_probability_probability: float) -> int:\n        if random.random() < probability:\n            if random.random() < length_probability:\n                if random.random() < probability_probability:\n                    if random.random() < probability_probability_probability:\n                        return s + length\n                    else:\n                        return s + length + 1\n                else:\n                    return s + length + 2\n            else:\n                return s + length + 3\n        else:\n            return s + length + 4\n\n    def get_hearing_start_time_with_length_and_probability_and_length_and_probability_and_probability(s: int, length: int, probability: float, length_probability: float, probability_probability: float, probability_probability_probability: float) -> int:\n        if random.random() < probability"
    },
    {
        "number": 3462,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pattern, n_files = stdin.split('\\n')[0:2]\n    files = stdin.split('\\n')[2:]\n\n    matching_files = []\n\n    for file in files:\n        if fnmatch.fnmatch(file, pattern):\n            matching_files.append(file)\n\n    return '\\n'.join(matching_files)"
    },
    {
        "number": 3463,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    p = [float(x) for x in stdin.split()[2:]]\n    total_rounds = N + M - 1\n    win_prob = 0\n    for i in range(total_rounds):\n        if i < N:\n            win_prob += p[i] * (N - i) / total_rounds\n        else:\n            win_prob += (1 - p[i]) * (M - i + 1) / total_rounds\n    return f\"{win_prob:.6f}\""
    },
    {
        "number": 3464,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, p = map(float, stdin.split())\n    p /= 100\n    max_profit = 0\n    \n    for i in range(1, 10001):\n        expected_profit = i * (2 - 1) * p - (1 - p) * i\n        if expected_profit > max_profit:\n            max_profit = expected_profit\n    \n    return f\"{max_profit:.3f}\""
    },
    {
        "number": 3465,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    roads = [set() for _ in range(n)]\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            a, b = map(int, line.split())\n            roads[a - 1].add(b - 1)\n            roads[b - 1].add(a - 1)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j and j not in roads[i]:\n                roads[i].add(j)\n                break\n\n    result = \"\"\n    for i in range(n):\n        for j in roads[i]:\n            result += f\"{i + 1} {j + 1}\\n\"\n\n    return result"
    },
    {
        "number": 3466,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2 + m]))\n    b = list(map(int, stdin.split()[2 + m:]))\n\n    f = [a[i] / sum(a) for i in range(m)]\n    s = [0] * m\n\n    for sweet in b:\n        s[sweet - 1] += 1\n\n    n = sum(s)\n    max_sweets = 0\n\n    for i in range(m):\n        if n * f[i] - 1 < s[i] < n * f[i] + 1:\n            max_sweets += n * f[i] - s[i]\n\n    if max_sweets == 0:\n        return \"forever\"\n    else:\n        return str(max_sweets)"
    },
    {
        "number": 3467,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split()[:3])\n    lines = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # Create a graph with tram stops as nodes and tram lines as edges\n    graph = {i: set() for i in range(n)}\n    for u, v, t_0, p, d in lines:\n        for t in range(t_0, s + 1, p):\n            graph[u].add((v, t + d))\n            graph[v].add((u, t))\n\n    # Dijkstra's algorithm to find the shortest path from hotel to meeting\n    dist = [float('inf')] * n\n    dist[0] = 0\n    visited = [False] * n\n\n    while not all(visited):\n        u = min(range(n), key=lambda x: dist[x] if not visited[x] else float('inf'))\n        visited[u] = True\n\n        for v, t in graph[u]:\n            if not visited[v] and dist[u] + t < dist[v]:\n                dist[v] = dist[u] + t\n\n    # Check if it's possible to make it to the meeting on time\n    if dist[n - 1] > s:\n        return \"impossible\"\n\n    # Find the latest time at which you can leave the hotel while arriving to your meeting on time\n    latest_time = s\n    for u, v, t_0, p, d in lines:\n        for t in range(t_0, s + 1, p):\n            if dist[u] + t <= latest_time and dist[v] + t <= latest_time:\n                latest_time = max(latest_time, t)\n\n    return str(latest_time)"
    },
    {
        "number": 3468,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split()[:2])\n    apps = []\n    for line in stdin.split('\\n')[2:]:\n        d, s = map(int, line.split())\n        apps.append((d, s))\n\n    apps.sort(key=lambda x: x[1], reverse=True)\n    installed = []\n    for app in apps:\n        if app[0] <= c:\n            installed.append(app)\n            c -= app[1]\n\n    return str(len(installed)) + '\\n' + ' '.join(str(i+1) for i, _ in enumerate(installed))"
    },
    {
        "number": 3469,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    g, k, p = stdin.split()\n    p = float(p)\n\n    # Calculate the probability of Gon winning\n    g_win_prob = 0\n    for i in range(len(g)):\n        for j in range(i, len(g)):\n            substring = g[i:j+1]\n            if substring in k:\n                g_win_prob += p ** (len(substring) - 1) * (1 - p)\n            else:\n                g_win_prob += p ** (len(substring) - 1) * (1 - p) * (1 - p)\n\n    # Calculate the probability of Killua winning\n    k_win_prob = 0\n    for i in range(len(k)):\n        for j in range(i, len(k)):\n            substring = k[i:j+1]\n            if substring in g:\n                k_win_prob += p ** (len(substring) - 1) * (1 - p)\n            else:\n                k_win_prob += p ** (len(substring) - 1) * (1 - p) * (1 - p)\n\n    # Calculate the probability of a draw\n    draw_prob = 1 - g_win_prob - k_win_prob\n\n    # Calculate the probability of Gon winning\n    gon_win_prob = g_win_prob + draw_prob / 2\n\n    return str(gon_win_prob)"
    },
    {
        "number": 3470,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    safe_cells = []\n    for i in range(1, 4*n+5):\n        if i % (2*n+1) == 0 or i % (2*n+1) == n+1:\n            safe_cells.append(i)\n    return str(len(safe_cells)) + \"\\n\" + \" \".join(map(str, safe_cells))"
    },
    {
        "number": 3471,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, xorbonacci_sequence, Q = stdin.split('\\n')\n    K = int(K)\n    xorbonacci_sequence = list(map(int, xorbonacci_sequence.split()))\n    Q = int(Q)\n\n    def xorbonacci(n: int) -> int:\n        if n == 1:\n            return xorbonacci_sequence[0]\n        elif n == 2:\n            return xorbonacci_sequence[1]\n        else:\n            return xorbonacci(n - 1) ^ xorbonacci(n - 2)\n\n    result = []\n    for _ in range(Q):\n        l, r = map(int, input().split())\n        xor_sum = 0\n        for i in range(l, r + 1):\n            xor_sum ^= xorbonacci(i)\n        result.append(xor_sum)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3472,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, N = map(int, stdin.split()[:2])\n    lines = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # Calculate the area of each sector\n    areas = []\n    for i in range(W):\n        area = 0\n        for line in lines:\n            x1, y1, x2, y2 = line\n            if (x1 - x2) * (y1 - y2) == 0:\n                if x1 == x2:\n                    area += float('inf')\n                else:\n                    area += float('inf')\n            else:\n                area += abs((x1 * y2 - x2 * y1) / 2)\n        areas.append(area)\n\n    # Calculate the number of extra lines needed\n    extra_lines = 0\n    for i in range(W):\n        for j in range(i + 1, W):\n            if areas[i] != areas[j]:\n                extra_lines += 1\n\n    return str(extra_lines)"
    },
    {
        "number": 3473,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Z, F, forbidden_dates = stdin.split('\\n')\n    Z = int(Z)\n    F = int(F)\n    forbidden_dates = forbidden_dates.split('\\n')[:-1]\n\n    def is_leap_year(year: int) -> bool:\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n    def days_in_month(year: int, month: int) -> int:\n        if month == 2:\n            return 29 if is_leap_year(year) else 28\n        elif month in [4, 6, 9, 11]:\n            return 30\n        else:\n            return 31\n\n    def is_friday(date: str) -> bool:\n        year, month, day = map(int, date.split())\n        return (year, month, day) == (2019, 10, 18)\n\n    def is_forbidden(date: str) -> bool:\n        year, month, day = map(int, date.split())\n        return (year, month, day) in forbidden_dates\n\n    def surprise_penalty(date1: str, date2: str) -> int:\n        year1, month1, day1 = map(int, date1.split())\n        year2, month2, day2 = map(int, date2.split())\n        return (month1 - month2) ** 2 + (day1 - day2) ** 2\n\n    def schedule(Z: int, forbidden_dates: List[str]) -> List[str]:\n        dates = []\n        current_date = \"2018 10 12\"\n        for _ in range(Z):\n            while is_forbidden(current_date) or is_friday(current_date):\n                year, month, day = map(int, current_date.split())\n                day += 1\n                if day > days_in_month(year, month):\n                    day = 1\n                    month += 1\n                    if month > 12:\n                        month = 1\n                        year += 1\n                current_date = f\"{year} {month:02} {day:02}\"\n            dates.append(current_date)\n            year, month, day = map(int, current_date.split())\n            day += 1\n            if day > days_in_month(year, month):\n                day = 1\n                month += 1\n                if month > 12:\n                    month = 1\n                    year += 1\n            current_date = f\"{year} {month:02} {day:02}\"\n        return dates\n\n    dates = schedule(Z, forbidden_dates)\n    total_penalty = sum(surprise_penalty(dates[i], dates[i-1]) for i in range(1, len(dates)))\n\n    return str(total_penalty) + '\\n' + '\\n'.join(dates)"
    },
    {
        "number": 3474,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_intersection(x1, y1, x2, y2, x3, y3):\n        if x1 == x2:\n            return None\n        m = (y2 - y1) / (x2 - x1)\n        b = y1 - m * x1\n        x = (y3 - b) / m\n        return x, y3\n\n    def find_range(x1, y1, x2, y2, x3, y3):\n        intersection = find_intersection(x1, y1, x2, y2, x3, y3)\n        if intersection is None:\n            return None\n        x, y = intersection\n        if x < x1:\n            return None\n        if x > x2:\n            return None\n        if y < min(y1, y2):\n            return None\n        if y > max(y1, y2):\n            return None\n        return y\n\n    result = []\n    for line in stdin.splitlines():\n        x1, y1, x2, y2, x3, y3 = map(float, line.split())\n        y_range = find_range(x1, y1, x2, y2, x3, y3)\n        if y_range is None:\n            result.append(\"can't hit the wall\")\n        else:\n            result.append(f\"{y_range:.5f}\")\n    return \"\\n\".join(result)"
    },
    {
        "number": 3475,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = map(int, stdin.split()[:2])\n    modes = []\n    for i in range(t):\n        d_min, a = map(int, stdin.split()[2:])\n        modes.append((d_min, a))\n\n    points = []\n    for i in range(n-1):\n        d, h = map(int, stdin.split()[2:])\n        points.append((d, h))\n\n    # Calculate the total distance of the itinerary\n    total_distance = sum(points[i][0] for i in range(len(points)))\n\n    # Calculate the total heading range of the itinerary\n    total_heading_range = abs(points[0][1])\n    for i in range(1, len(points)):\n        total_heading_range += abs(points[i][1] - points[i-1][1])\n\n    # Check if the conditions are met\n    for mode in modes:\n        if total_distance >= mode[0] and total_heading_range <= mode[1] * 1000:\n            return \"1\"\n\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3476,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    matrix = [list(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def rotate_row(i: int, k: int) -> None:\n        nonlocal matrix\n        matrix[i] = matrix[i][-k:] + matrix[i][:-k]\n\n    def rotate_col(j: int, k: int) -> None:\n        nonlocal matrix\n        col = [matrix[i][j] for i in range(R)]\n        col = col[-k:] + col[:-k]\n        for i in range(R):\n            matrix[i][j] = col[i]\n\n    def negate_row(i: int) -> None:\n        nonlocal matrix\n        if not any(matrix[i]):\n            matrix[i] = [-x for x in matrix[i]]\n\n    def negate_col(j: int) -> None:\n        nonlocal matrix\n        if not any(matrix[i][j] for i in range(R)):\n            for i in range(R):\n                matrix[i][j] = -matrix[i][j]\n\n    def max_sum() -> int:\n        nonlocal matrix\n        return sum(sum(row) for row in matrix)\n\n    operations = []\n    max_sum_before = 0\n    max_sum_after = max_sum()\n\n    while max_sum_after > max_sum_before:\n        max_sum_before = max_sum_after\n        for i in range(R):\n            for k in range(C):\n                rotate_row(i, k)\n                if max_sum() > max_sum_after:\n                    operations.append(f\"rotR {i} {k}\")\n                    max_sum_after = max_sum()\n                rotate_row(i, -k)\n            negate_row(i)\n            if max_sum() > max_sum_after:\n                operations.append(f\"negR {i}\")\n                max_sum_after = max_sum()\n            negate_row(i)\n        for j in range(C):\n            for k in range(R):\n                rotate_col(j, k)\n                if max_sum() > max_sum_after:\n                    operations.append(f\"rotS {j} {k}\")\n                    max_sum_after = max_sum()\n                rotate_col(j, -k)\n            negate_col(j)\n            if max_sum() > max_sum_after:\n                operations.append(f\"negS {j}\")\n                max_sum_after = max_sum()\n            negate_col(j)\n\n    return f\"{max_sum_after} {len(operations)}\\n{''.join(operations)}\""
    },
    {
        "number": 3477,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    k = list(map(int, stdin.split()[2:]))\n    energies = []\n    min_sum = float('inf')\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                energy = (k[i] * i + k[j] * j) / (k[i] + k[j])\n                energies.append(energy)\n                sum_of_squares = sum([k[i] * (i - energy) ** 2 for i in range(n)])\n                if sum_of_squares < min_sum:\n                    min_sum = sum_of_squares\n\n    return str(min_sum)"
    },
    {
        "number": 3478,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n    cities = set(sum(roads, ()))\n    graph = {city: set() for city in cities}\n    for x, y in roads:\n        graph[x].add(y)\n        graph[y].add(x)\n\n    def dfs(city, visited, path):\n        if city in visited:\n            return False\n        visited.add(city)\n        path.append(city)\n        for neighbor in graph[city]:\n            if neighbor not in visited and dfs(neighbor, visited, path):\n                return True\n        path.pop()\n        return False\n\n    def is_connected(cities):\n        visited = set()\n        for city in cities:\n            if city not in visited:\n                path = []\n                if dfs(city, visited, path):\n                    return True\n                return False\n        return True\n\n    for i in range(1, n + 1):\n        if i not in cities:\n            continue\n        for j in range(i + 1, n + 1):\n            if j not in cities:\n                continue\n            if is_connected([i, j]):\n                for k in range(1, n + 1):\n                    if k not in cities:\n                        continue\n                    if k not in [i, j]:\n                        if is_connected([i, j, k]):\n                            return f\"{i} {j}\\n{k}\"\n    return \"impossible\""
    },
    {
        "number": 3479,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    times = list(map(int, stdin.split()[2:]))\n\n    # Sort the times in ascending order\n    times.sort()\n\n    # Initialize the number of cars needed and the time taken\n    cars_needed = 0\n    time_taken = 0\n\n    # Iterate through the times and assign cars to each person\n    for time in times:\n        # If there are no cars left, add a new car and update the cars_needed\n        if cars_needed == 0:\n            cars_needed += 1\n            time_taken += time\n        # If there are cars left, assign the person to the nearest car\n        else:\n            time_taken += min(time, cars_needed * time)\n            cars_needed -= 1\n\n    return str(time_taken)"
    },
    {
        "number": 3480,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    L, D = map(int, lines[0].split())\n    lines = lines[1:]\n\n    for i in range(0, len(lines), 2):\n        line1, line2 = lines[i], lines[i + 1]\n        syllables1, syllables2 = line1.split(), line2.split()\n        time_units1, time_units2 = list(map(int, line2.split())), []\n\n        for j in range(len(syllables1)):\n            if time_units1[j] > 0:\n                time_units2.append(time_units1[j] + D)\n            else:\n                time_units2.append(0)\n\n        max_time_unit = max(time_units2)\n        output = [''] * (2 * L)\n\n        for j in range(len(syllables1)):\n            if time_units1[j] > 0:\n                output[j] = syllables1[j]\n            else:\n                output[j] = '/'\n\n        for j in range(len(syllables2)):\n            if time_units2[j] > 0:\n                output[j + L] = syllables2[j]\n            else:\n                output[j + L] = '/'\n\n        for j in range(len(syllables1)):\n            if time_units1[j] > 0:\n                for k in range(j + 1, len(syllables1)):\n                    if time_units1[k] > 0:\n                        if time_units1[k] - time_units1[j] <= max_time_unit:\n                            output[k + L] = output[k + L].ljust(len(output[j + L]) + time_units1[k] - time_units1[j])\n                        else:\n                            break\n\n        for j in range(len(output)):\n            output[j] = output[j].replace(' ', '_')\n\n        return '\\n'.join(output)"
    },
    {
        "number": 3481,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    G, K, R = map(int, stdin.readline().split())\n    roads = []\n    for _ in range(R):\n        A, B, T = map(int, stdin.readline().split())\n        roads.append((A, B, T))\n\n    gigs = []\n    for _ in range(G):\n        V, S, E, M = map(int, stdin.readline().split())\n        gigs.append((V, S, E, M))\n\n    def get_time(road: tuple) -> int:\n        return road[2]\n\n    def get_start(gig: tuple) -> int:\n        return gig[1]\n\n    def get_end(gig: tuple) -> int:\n        return gig[2]\n\n    def get_venue(gig: tuple) -> int:\n        return gig[0]\n\n    def get_money(gig: tuple) -> int:\n        return gig[3]\n\n    def get_distance(road: tuple, gig: tuple) -> int:\n        return road[2]\n\n    def get_travel_time(road: tuple, gig: tuple) -> int:\n        return road[2]\n\n    def get_total_time(road: tuple, gig: tuple) -> int:\n        return road[2] + gig[2] - gig[1]\n\n    def get_money_for_gig(gig: tuple) -> int:\n        return gig[3]\n\n    def get_money_for_road(road: tuple) -> int:\n        return 0\n\n    def get_money_for_travel(road: tuple) -> int:\n        return 0\n\n    def get_money_for_gig_and_road(road: tuple, gig: tuple) -> int:\n        return get_money_for_gig(gig)\n\n    def get_money_for_gig_and_travel(road: tuple, gig: tuple) -> int:\n        return get_money_for_gig(gig)\n\n    def get_money_for_road_and_travel(road: tuple, gig: tuple) -> int:\n        return get_money_for_road(road)\n\n    def get_money_for_gig_and_road_and_travel(road: tuple, gig: tuple) -> int:\n        return get_money_for_gig_and_road(road, gig)\n\n    def get_money_for_gig_and_travel_and_road(road: tuple, gig: tuple) -> int:\n        return get_money_for_gig_and_travel(road, gig)\n\n    def get_money_for_road_and_travel_and_gig(road: tuple, gig: tuple) -> int:\n        return get_money_for_road_and_travel(road, gig)\n\n    def get_money_for_gig_and_road_and_travel_and_gig(road: tuple, gig: tuple) -> int:\n        return get_money_for_gig_and_road_and_travel(road, gig)\n\n    def get_money_for_travel_and_gig_and_road(road: tuple, gig: tuple) -> int:\n        return get_money_for_gig_and_road_and_travel(road, gig)\n\n    def get_money_for_travel_and_gig_and_road_and_gig(road: tuple, gig: tuple) -> int:\n        return get_money_for_gig_and_road_and_travel_and_gig(road, gig)\n\n    def get_money_for_gig_and_road_and_travel_and_gig_and_road(road: tuple, gig: tuple) -> int:\n        return get_money_for_gig_and_road_and_travel_and_gig(road, gig)\n\n    def get_money_for_gig_and_road_and_travel_and_gig_and_travel(road: tuple, gig: tuple) -> int:\n        return get"
    },
    {
        "number": 3482,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    l, prices, durations, t, n = map(int, lines[0].split())\n    prices = list(map(int, lines[1].split()))\n    durations = list(map(int, lines[2].split()))\n    trips = []\n    for i in range(n):\n        a, b = map(int, lines[i+3].split())\n        trips.append((a, b))\n\n    def get_price(day: int) -> int:\n        for i in range(l):\n            if day <= durations[i]:\n                return prices[i]\n        return prices[-1]\n\n    def get_total_cost(trips: List[Tuple[int, int]]) -> int:\n        total_cost = 0\n        current_day = 1\n        for trip in trips:\n            a, b = trip\n            while current_day < a:\n                total_cost += get_price(current_day)\n                current_day += 1\n            current_day = b + 1\n        return total_cost\n\n    total_cost = get_total_cost(trips)\n    return str(total_cost)"
    },
    {
        "number": 3483,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import random\n\n    # Read input\n    N, weights = stdin.split('\\n')\n    N = int(N)\n    weights = list(map(int, weights.split()))\n\n    # Calculate max, min, distinct weights, and expected weight\n    max_weight = sum(weights)\n    min_weight = max(weights)\n    distinct_weights = len(set(weights))\n    expected_weight = sum(weights) / N\n\n    # Generate 100000 random 4-packs\n    random_packs = []\n    for _ in range(100000):\n        random_pack = random.choices(weights, k=4)\n        random_packs.append(sum(random_pack))\n\n    # Calculate expected weight\n    expected_weight = sum(random_packs) / len(random_packs)\n\n    # Return output\n    return f\"{max_weight} {min_weight} {distinct_weights} {expected_weight:.4f}\""
    },
    {
        "number": 3484,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    grid = [list(map(int, input().split())) for _ in range(k)]\n    for i in range(k, n):\n        grid.append([0] * n)\n    \n    def is_valid(row, col, num):\n        for i in range(n):\n            if grid[row][i] == num or grid[i][col] == num:\n                return False\n        start_row, start_col = row - row % 3, col - col % 3\n        for i in range(3):\n            for j in range(3):\n                if grid[i + start_row][j + start_col] == num:\n                    return False\n        return True\n    \n    def solve():\n        for row in range(n):\n            for col in range(n):\n                if grid[row][col] == 0:\n                    for num in range(1, n + 1):\n                        if is_valid(row, col, num):\n                            grid[row][col] = num\n                            if solve():\n                                return True\n                            grid[row][col] = 0\n                    return False\n        return True\n    \n    if solve():\n        for row in grid:\n            print(\" \".join(map(str, row)))\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3485,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, deck = stdin.split('\\n')\n    N = int(N)\n    deck = list(map(int, deck.split()))\n\n    stop_counting = False\n    start_counting = False\n    count = 0\n    total = 0\n\n    for card in deck:\n        if not stop_counting:\n            total += card\n            count += 1\n        elif start_counting:\n            total += card\n            count += 1\n        elif card >= 0:\n            stop_counting = True\n        else:\n            start_counting = True\n\n    return f\"{total / count:.9f}\""
    },
    {
        "number": 3486,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = [int(x) for x in stdin.split('\\n')[1:n+1]]\n    mod = 10**9 + 7\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if (numbers[i] % numbers[j] == 0 or numbers[j] % numbers[i] == 0) and (numbers[j] % numbers[k] == 0 or numbers[k] % numbers[j] == 0) and (numbers[k] % numbers[i] == 0 or numbers[i] % numbers[k] == 0):\n                    count += 1\n    return str(count % mod)"
    },
    {
        "number": 3487,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        n, p, v, a = map(float, input().split())\n        pipes = []\n        for _ in range(p):\n            j, k, c = map(int, input().split())\n            pipes.append((j, k, c))\n        return n, p, v, a, pipes\n\n    def calculate_value(F, W):\n        return F**a * W**(1-a)\n\n    def find_max_value(n, p, v, a, pipes):\n        max_value = 0\n        max_rates = []\n        for j, k, c in pipes:\n            if j == 1:\n                F = c / v\n                W = 0\n            elif k == 2:\n                F = 0\n                W = c\n            else:\n                F = min(c / v, c)\n                W = min(c, c / v)\n            value = calculate_value(F, W)\n            if value > max_value:\n                max_value = value\n                max_rates = [(F, W)]\n            elif value == max_value:\n                max_rates.append((F, W))\n        return max_value, max_rates\n\n    n, p, v, a, pipes = read_input()\n    max_value, max_rates = find_max_value(n, p, v, a, pipes)\n\n    for F, W in max_rates:\n        print(F, W)\n\n    print(f\"{max_value:.4f}\")"
    },
    {
        "number": 3488,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    A = []\n    for i in range(1, N + 1):\n        x, y = map(int, lines[i].split())\n        A.append((x, y))\n    K = int(lines[N + 1])\n    B = []\n    for i in range(N + 2, N + K + 2):\n        x, y = map(int, lines[i].split())\n        B.append((x, y))\n\n    # Find the smallest polygon Z\n    def is_inside(point, polygon):\n        x, y = point\n        n = len(polygon)\n        inside = False\n        x1, y1 = polygon[0]\n        for i in range(1, n + 1):\n            x2, y2 = polygon[i % n]\n            if min(y1, y2) < y <= max(y1, y2):\n                if x <= max(x1, x2):\n                    inside = not inside\n            x1, y1 = x2, y2\n        return inside\n\n    def is_convex(polygon):\n        n = len(polygon)\n        for i in range(n):\n            a = polygon[i]\n            b = polygon[(i + 1) % n]\n            c = polygon[(i + 2) % n]\n            if not is_inside(c, [a, b, c]):\n                return False\n        return True\n\n    def is_valid(polygon):\n        return is_convex(polygon) and all(is_inside(point, polygon) for point in B)\n\n    min_vertices = N\n    for i in range(N):\n        for j in range(i + 2, N):\n            for k in range(j + 2, N):\n                polygon = [A[i], A[j], A[k]]\n                if is_valid(polygon):\n                    min_vertices = min(min_vertices, len(polygon))\n\n    return str(min_vertices)"
    },
    {
        "number": 3489,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, h = map(int, lines[0].split())\n    hideouts = [[] for _ in range(n)]\n    for line in lines[1:]:\n        a, b = map(int, line.split())\n        hideouts[a].append(b)\n        hideouts[b].append(a)\n\n    def dfs(start: int, visited: set) -> set:\n        visited.add(start)\n        for next_hideout in hideouts[start]:\n            if next_hideout not in visited:\n                dfs(next_hideout, visited)\n        return visited\n\n    max_visited = 0\n    max_visited_hideouts = set()\n    for i in range(n):\n        if i != h:\n            visited = dfs(i, set())\n            if len(visited) > max_visited:\n                max_visited = len(visited)\n                max_visited_hideouts = visited\n\n    m = n - max_visited\n    result = []\n    for i in range(n):\n        if i not in max_visited_hideouts:\n            for j in range(n):\n                if j not in max_visited_hideouts:\n                    result.append((i, j))\n                    break\n\n    return str(m) + '\\n' + '\\n'.join(f'{a} {b}' for a, b in result)"
    },
    {
        "number": 3490,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    witches = []\n\n    for i in range(1, N + 1):\n        x, y, r = map(float, stdin.splitlines()[i].split())\n        witches.append((x, y, r))\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            x1, y1, r1 = witches[i]\n            x2, y2, r2 = witches[j]\n\n            if (x1 - x2) ** 2 + (y1 - y2) ** 2 <= 1:\n                return \"crash\"\n\n    return \"ok\""
    },
    {
        "number": 3491,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    current_state = [set() for _ in range(N)]\n    desired_state = [set() for _ in range(N)]\n\n    for i in range(M):\n        i, j = map(int, stdin.split()[2*i:2*(i+1)])\n        current_state[i].add(j)\n\n    for i in range(M):\n        i, j = map(int, stdin.split()[2*i:2*(i+1)])\n        desired_state[i].add(j)\n\n    def get_next_state(current_state, floor):\n        next_state = [set() for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    continue\n                if i == floor:\n                    next_state[i].add((j + 1) % N)\n                elif j == floor:\n                    next_state[i].add((j + 2) % N)\n                else:\n                    next_state[i].add(j)\n        return next_state\n\n    def get_presses(current_state, desired_state):\n        presses = []\n        for i in range(N):\n            if current_state[i] != desired_state[i]:\n                presses.append((\"R\", i))\n        return presses\n\n    current_state = get_next_state(current_state, 0)\n    presses = get_presses(current_state, desired_state)\n    return str(len(presses)) + \"\\n\" + \"\\n\".join(f\"{p[0]} {p[1]}\" for p in presses)"
    },
    {
        "number": 3492,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, List[str], List[str], List[List[str]]]:\n        s, r, f, t = map(int, stdin.split()[:4])\n        raw_material_sites = stdin.split()[4:4 + r]\n        factory_sites = stdin.split()[4 + r:4 + r + f]\n        transportation_companies = []\n        for i in range(t):\n            n = int(stdin.split()[4 + r + f + i * (s + 1)])\n            transportation_companies.append(stdin.split()[4 + r + f + i * (s + 1) + 1:4 + r + f + i * (s + 1) + 1 + n])\n        return s, raw_material_sites, factory_sites, transportation_companies\n\n    def find_max_supplied_factories(s: int, raw_material_sites: List[str], factory_sites: List[str], transportation_companies: List[List[str]]) -> int:\n        raw_material_site_to_factory = {}\n        for factory_site in factory_sites:\n            for transportation_company in transportation_companies:\n                if factory_site in transportation_company:\n                    for raw_material_site in raw_material_sites:\n                        if raw_material_site in transportation_company:\n                            raw_material_site_to_factory[raw_material_site] = factory_site\n        return len(set(raw_material_site_to_factory.values()))\n\n    s, raw_material_sites, factory_sites, transportation_companies = read_input()\n    return str(find_max_supplied_factories(s, raw_material_sites, factory_sites, transportation_companies))"
    },
    {
        "number": 3493,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    people = [list(line) for line in stdin.split('\\n')[1:n+1]]\n    max_times = 0\n    max_solution = []\n\n    def is_valid(solution):\n        for i in range(len(solution)):\n            for j in range(i+1, len(solution)):\n                if solution[i] == solution[j]:\n                    return False\n        return True\n\n    def backtrack(current_solution, current_person, current_button):\n        nonlocal max_times, max_solution\n        if current_person == n:\n            if is_valid(current_solution) and len(current_solution) > max_times:\n                max_times = len(current_solution)\n                max_solution = current_solution.copy()\n            return\n\n        for i in range(n):\n            if people[current_person][i] == 'Y':\n                current_solution.append(i+1)\n                backtrack(current_solution, current_person+1, i+1)\n                current_solution.pop()\n\n    backtrack([], 0, -1)\n\n    output = [str(max_times)]\n    for solution in max_solution:\n        output.append(' '.join(map(str, solution)))\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3494,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split()[0].split())\n    matrix = [list(line.strip()) for line in stdin.split()[1:R+1]]\n    G = int(stdin.split()[-1])\n    apple_falls = [list(map(int, line.split())) for line in stdin.split()[-G-1:-1]]\n\n    def distance(r1, s1, r2, s2):\n        return ((r1-r2)**2 + (s1-s2)**2)**0.5\n\n    result = []\n    for fall in apple_falls:\n        r, s = fall\n        min_distance = float('inf')\n        for i in range(R):\n            for j in range(S):\n                if matrix[i][j] == 'x':\n                    min_distance = min(min_distance, distance(r, s, i, j))\n        result.append(min_distance**2)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3495,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    L = [float(line) for line in lines[1:N+1]]\n    x, y = [float(line) for line in lines[N+1:]]\n\n    # Calculate the coordinates of the tip of each segment\n    x_coords = [0] * N\n    y_coords = [0] * N\n    x_coords[0] = L[0]\n    y_coords[0] = 0\n    for i in range(1, N):\n        x_coords[i] = x_coords[i-1] + L[i] * math.cos(math.atan2(y_coords[i-1], x_coords[i-1]) - math.atan2(y_coords[i-1] - y_coords[i-2], x_coords[i-1] - x_coords[i-2]))\n        y_coords[i] = y_coords[i-1] + L[i] * math.sin(math.atan2(y_coords[i-1], x_coords[i-1]) - math.atan2(y_coords[i-1] - y_coords[i-2], x_coords[i-1] - x_coords[i-2]))\n\n    # Calculate the distance to the target\n    distance = math.sqrt((x_coords[N-1] - x)**2 + (y_coords[N-1] - y)**2)\n\n    # Calculate the angle between the segment and the target\n    angle = math.atan2(y - y_coords[N-1], x - x_coords[N-1])\n\n    # Calculate the minimum distance to the target\n    min_distance = L[N-1] * math.cos(angle)\n\n    # Calculate the angle between the segment and the target\n    angle = math.atan2(y_coords[N-1] - y_coords[N-2], x_coords[N-1] - x_coords[N-2])\n\n    # Calculate the minimum distance to the target\n    min_distance = L[N-1] * math.cos(angle)\n\n    # Calculate the angle between the segment and the target\n    angle = math.atan2(y_coords[N-1] - y_coords[N-2], x_coords[N-1] - x_coords[N-2])\n\n    # Calculate the minimum distance to the target\n    min_distance = L[N-1] * math.cos(angle)\n\n    # Calculate the angle between the segment and the target\n    angle = math.atan2(y_coords[N-1] - y_coords[N-2], x_coords[N-1] - x_coords[N-2])\n\n    # Calculate the minimum distance to the target\n    min_distance = L[N-1] * math.cos(angle)\n\n    # Calculate the angle between the segment and the target\n    angle = math.atan2(y_coords[N-1] - y_coords[N-2], x_coords[N-1] - x_coords[N-2])\n\n    # Calculate the minimum distance to the target\n    min_distance = L[N-1] * math.cos(angle)\n\n    # Calculate the angle between the segment and the target\n    angle = math.atan2(y_coords[N-1] - y_coords[N-2], x_coords[N-1] - x_coords[N-2])\n\n    # Calculate the minimum distance to the target\n    min_distance = L[N-1] * math.cos(angle)\n\n    # Calculate the angle between the segment and the target\n    angle = math.atan2(y_coords[N-1] - y_coords[N-2], x_coords[N-1] - x_coords[N-2])\n\n    # Calculate the minimum distance to the target\n    min_distance = L[N-1] * math.cos(angle)\n\n    # Calculate the angle between the segment and the target\n    angle"
    },
    {
        "number": 3496,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    stdin = stdin.split()[2+n:]\n    for k in stdin:\n        k = int(k)\n        if k <= n:\n            print(a[k-1])\n        else:\n            i = 1\n            j = k - i\n            while j > n:\n                i += 1\n                j = k - i\n            if i == 1:\n                print(a[j-1])\n            else:\n                print(min(a[i-1] + a[j-1], a[i-1] + a[j-2]))"
    },
    {
        "number": 3497,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited, pigs, wolves):\n        visited.add(start)\n        if start in pigs:\n            pigs.remove(start)\n        elif start in wolves:\n            wolves.remove(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                dfs(graph, neighbor, visited, pigs, wolves)\n\n    def min_wolves(graph, pigs):\n        wolves = set()\n        for i in range(len(pigs)):\n            visited = set()\n            dfs(graph, pigs[i], visited, pigs[:i] + pigs[i+1:], wolves)\n        return len(wolves)\n\n    V, P = map(int, stdin.readline().split())\n    graph = [[] for _ in range(V)]\n    for _ in range(V-1):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    pigs = list(map(int, stdin.readline().split()))\n    return str(min_wolves(graph, pigs))"
    },
    {
        "number": 3498,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_task(task_description: str) -> tuple:\n        start_time, base_priority, a = map(int, task_description.split())\n        instructions = []\n        for _ in range(a):\n            instruction = input().split()\n            instructions.append(instruction)\n        return start_time, base_priority, instructions\n\n    def parse_tasks(stdin: str) -> list:\n        tasks = []\n        for line in stdin.split('\\n')[1:]:\n            if line:\n                tasks.append(parse_task(line))\n        return tasks\n\n    def compute_priority(task: tuple, blocked_tasks: set) -> int:\n        start_time, base_priority, instructions = task\n        current_priority = base_priority\n        for instruction in instructions:\n            if instruction[0] == 'L':\n                resource = int(instruction[1])\n                if resource in blocked_resources:\n                    blocked_tasks.add(task)\n                    break\n            elif instruction[0] == 'U':\n                resource = int(instruction[1])\n                if resource in blocked_resources:\n                    blocked_tasks.remove(task)\n        else:\n            for blocked_task in blocked_tasks:\n                current_priority = max(current_priority, blocked_task[1])\n            return current_priority\n\n    def execute_task(task: tuple, clock: int) -> int:\n        start_time, base_priority, instructions = task\n        if start_time <= clock:\n            for instruction in instructions:\n                if instruction[0] == 'C':\n                    clock += int(instruction[1])\n                elif instruction[0] == 'L':\n                    resource = int(instruction[1])\n                    blocked_resources.add(resource)\n                elif instruction[0] == 'U':\n                    resource = int(instruction[1])\n                    blocked_resources.remove(resource)\n            return clock\n        else:\n            return clock\n\n    tasks = parse_tasks(stdin)\n    clock = 0\n    blocked_tasks = set()\n    blocked_resources = set()\n    task_completion_times = []\n\n    while tasks:\n        tasks.sort(key=lambda x: (x[0], x[1]))\n        for task in tasks:\n            clock = execute_task(task, clock)\n            task_completion_times.append(clock)\n            tasks.remove(task)\n\n    return '\\n'.join(map(str, task_completion_times))"
    },
    {
        "number": 3499,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split()\n    N = int(N)\n    MOD = 10**9 + 7\n    count = 0\n\n    for i in range(N):\n        for j in range(i, N):\n            for k in range(j, N):\n                if S[i:j+1] in S[k+1:]:\n                    count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 3500,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = [\n        [int(x) for x in line.split()]\n        for line in stdin.split(\"\\n\")[1:]\n        if line\n    ]\n\n    def check_card(card: List[int], number: int) -> bool:\n        for i in range(5):\n            if all(card[j] == number for j in range(5) if j != i):\n                return True\n        for i in range(5):\n            if all(card[j][i] == number for j in range(5)):\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for number in range(1, 3001):\n                if check_card(cards[i], number) and check_card(cards[j], number):\n                    return f\"{i+1} {j+1}\"\n\n    return \"no ties\""
    },
    {
        "number": 3501,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, jaap, jan, thijs = stdin.split('\\n')\n    n = int(n)\n    jaap = list(map(int, jaap.split()))\n    jan = list(map(int, jan.split()))\n    thijs = list(map(int, thijs.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if jaap[i] < jaap[j] and jan[i] < jan[j] and thijs[i] < thijs[j]:\n                count += 1\n            elif jaap[i] > jaap[j] and jan[i] > jan[j] and thijs[i] > thijs[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3502,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lights = []\n    for i in range(1, n+1):\n        x, r, g = map(int, stdin.split('\\n')[i].split())\n        lights.append((x, r, g))\n\n    def ideal_car_probability(lights: List[Tuple[int, int, int]]) -> float:\n        total_time = 2019 * 2\n        ideal_car_time = random.uniform(0, total_time)\n        for light in lights:\n            x, r, g = light\n            if ideal_car_time < x:\n                return 0\n            ideal_car_time += r + g\n        return 1\n\n    def first_red_light_probability(lights: List[Tuple[int, int, int]]) -> float:\n        total_time = 2019 * 2\n        ideal_car_time = random.uniform(0, total_time)\n        for i, light in enumerate(lights):\n            x, r, g = light\n            if ideal_car_time < x:\n                return 0\n            ideal_car_time += r + g\n            if i == 0:\n                return 1\n        return 0\n\n    probabilities = []\n    for light in lights:\n        x, r, g = light\n        probabilities.append(ideal_car_probability(lights[:lights.index(light)]))\n\n    all_lights_probability = ideal_car_probability(lights)\n\n    return '\\n'.join(map(str, probabilities)) + '\\n' + str(all_lights_probability)\n\nimport random\nimport sys"
    },
    {
        "number": 3503,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    pairs = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    used_results = set()\n    for a, b in pairs:\n        for op in [\"+\", \"-\", \"*\"]:\n            result = eval(f\"{a} {op} {b}\")\n            if result not in used_results:\n                used_results.add(result)\n                print(f\"{a} {op} {b} = {result}\")\n                break\n        else:\n            return \"impossible\"\n    return \"success\""
    },
    {
        "number": 3504,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def disintegrate(droplet: tuple, sensor: tuple) -> bool:\n        x1, x2, y = sensor\n        x, y = droplet\n        return x1 <= x <= x2 and y == y\n\n    def find_disintegrate_y(droplet: tuple, sensors: list) -> int:\n        for sensor in sensors:\n            if disintegrate(droplet, sensor):\n                return sensor[2]\n        return 0\n\n    lines = stdin.split(\"\\n\")\n    D, S = map(int, lines[0].split())\n    droplets = [tuple(map(int, line.split())) for line in lines[1:D+1]]\n    sensors = [tuple(map(int, line.split())) for line in lines[D+1:]]\n\n    result = [find_disintegrate_y(droplet, sensors) for droplet in droplets]\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3505,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *numbers = stdin.split()\n    N = int(N)\n    numbers = [int(num) for num in numbers]\n\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                if numbers[i] + numbers[j] == numbers[k]:\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 3506,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, m = map(int, stdin.split()[:3])\n    intervals = []\n    for _ in range(m):\n        a, b = map(int, stdin.split()[3:])\n        intervals.append((a, b))\n\n    # TODO: Implement the optimal cheerleading tactic\n    # and calculate the number of goals scored by Sportify and Spoilify\n    sportify_goals = 0\n    spoilify_goals = 0\n\n    return f\"{sportify_goals} {spoilify_goals}\""
    },
    {
        "number": 3507,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, W, d = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    # Calculate the number of ways to arrange the white wine boxes\n    num_white_piles = 1\n    for i in range(W):\n        num_white_piles = (num_white_piles * (i + 1)) % MOD\n\n    # Calculate the number of ways to arrange the red wine boxes\n    num_red_piles = 1\n    for i in range(R):\n        num_red_piles = (num_red_piles * (i + 1)) % MOD\n\n    # Calculate the number of ways to arrange the red wine boxes with at most d boxes per pile\n    num_red_piles_with_d_boxes = 1\n    for i in range(R // d):\n        num_red_piles_with_d_boxes = (num_red_piles_with_d_boxes * (i + 1)) % MOD\n\n    # Calculate the number of ways to arrange the red and white wine boxes\n    num_ways = (num_white_piles * num_red_piles_with_d_boxes) % MOD\n\n    return str(num_ways)"
    },
    {
        "number": 3508,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pillars = stdin.split('\\n')\n    n = int(n)\n    pillars = [int(p) for p in pillars.split()]\n\n    max_damage = 0\n    pillar_to_tear = 0\n\n    for i in range(1, n-1):\n        damage = sum(pillars[:i]) + sum(pillars[i+1:])\n        if damage > max_damage:\n            max_damage = damage\n            pillar_to_tear = i\n\n    return f\"{max_damage} {pillar_to_tear}\""
    },
    {
        "number": 3509,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split()[0].split())\n    n, m = map(int, stdin.split()[1].split())\n    roads = []\n    for i in range(2, m+2):\n        u, v, t = map(int, stdin.split()[i].split())\n        roads.append((u, v, t))\n    \n    # Sort the roads by the time it takes to travel along them\n    roads.sort(key=lambda x: x[2])\n    \n    # Initialize the distance and time matrices\n    distance = [[float('inf')] * (n+1) for _ in range(n+1)]\n    time = [[float('inf')] * (n+1) for _ in range(n+1)]\n    \n    # Fill in the distance and time matrices\n    for i in range(1, n+1):\n        distance[i][i] = 0\n        time[i][i] = 0\n    for u, v, t in roads:\n        distance[u][v] = t\n        time[u][v] = t\n    \n    # Floyd-Warshall algorithm to find the shortest path between any two intersections\n    for k in range(1, n+1):\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n                time[i][j] = min(time[i][j], time[i][k] + time[k][j])\n    \n    # Find the shortest path from Richard's house to Janet's house\n    shortest_time = float('inf')\n    for i in range(1, n+1):\n        shortest_time = min(shortest_time, time[1][i])\n    \n    # Calculate the waiting time\n    waiting_time = max(a, shortest_time)\n    \n    return str(waiting_time)"
    },
    {
        "number": 3510,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    positions = stdin.split('\\n')[1:]\n    options = {}\n    for i in range(n):\n        options[chr(i+97)] = positions[i].split()\n\n    def min_rounds(p: str, q: str) -> int:\n        if p == q:\n            return 0\n        if p not in options:\n            return -1\n        rounds = []\n        for option in options[p]:\n            if q in option:\n                rounds.append(1 + min(min_rounds(option[option.index(q)+1:], q) for option in options[p]))\n        return min(rounds) if rounds else -1\n\n    result = \"\"\n    for i in range(n):\n        for j in range(n):\n            result += str(min_rounds(chr(i+97), chr(j+97))) + \" \"\n        result = result[:-1] + \"\\n\"\n    return result"
    },
    {
        "number": 3511,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    queries = stdin.split('\\n')[1:]\n    stones = [0] * N\n    A = 0\n\n    for query in queries:\n        if query[0] == '1':\n            u, v = map(int, query.split()[1:])\n            stones[u - 1] += 1\n            stones[v - 1] += 1\n        elif query[0] == '2':\n            for i in range(N):\n                A += stones[i] ** 2\n            B = 2 * N\n            result = A * pow(B, -1, 10**9 + 7)\n            print(result)"
    },
    {
        "number": 3512,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_distance(distances, visited, current_city):\n        min_distance = float('inf')\n        next_city = -1\n        for i in range(N):\n            if i not in visited and distances[current_city][i] < min_distance:\n                min_distance = distances[current_city][i]\n                next_city = i\n        return next_city, min_distance\n\n    def dfs(distances, visited, current_city, current_distance):\n        if len(visited) == N:\n            return current_distance\n\n        next_city, min_distance = get_min_distance(distances, visited, current_city)\n        visited.add(next_city)\n        return min(dfs(distances, visited, next_city, current_distance + min_distance),\n               dfs(distances, visited, next_city, current_distance))\n\n    N = int(stdin.readline().strip())\n    distances = []\n    for i in range(N):\n        distances.append(list(map(int, stdin.readline().strip().split())))\n\n    visited = set()\n    current_city = 0\n    current_distance = 0\n    return str(dfs(distances, visited, current_city, current_distance))"
    },
    {
        "number": 3513,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    k = 0\n    while True:\n        if X % (k+1) == 0:\n            k += 1\n            X //= (k+1)\n        else:\n            break\n    return str(k)"
    },
    {
        "number": 3514,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def is_armed(i, j):\n        return grid[i][j] == 'x'\n\n    def is_covered(i, j):\n        return any(is_armed(i, k) for k in range(C)) or any(is_armed(k, j) for k in range(R))\n\n    def disarm_building(i, j):\n        grid[i][j] = '.'\n        for k in range(R):\n            for l in range(C):\n                if is_armed(k, l) and is_covered(k, l):\n                    disarm_building(k, l)\n\n    max_disarmed = 0\n    for i in range(R):\n        for j in range(C):\n            if is_armed(i, j) and is_covered(i, j):\n                disarm_building(i, j)\n                max_disarmed += 1\n\n    return str(max_disarmed)"
    },
    {
        "number": 3515,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    cities = []\n    for i in range(1, N+1):\n        y, d, r = map(int, lines[i].split())\n        cities.append((y, d, r))\n    \n    def get_shortest_time(start: int, end: int) -> int:\n        y1, d1, r1 = cities[start-1]\n        y2, d2, r2 = cities[end-1]\n        if abs(y1 - y2) < d1:\n            return -1\n        return r1 + abs(y1 - y2)\n    \n    result = []\n    for i in range(1, N):\n        result.append(get_shortest_time(1, i+1))\n    \n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3516,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    levels = []\n    for i in range(1, n+1):\n        line = stdin.split('\\n')[i].split(' ')\n        shortcut_item = int(line[0])\n        shortcut_time = int(line[1])\n        completion_times = [int(x) for x in line[2:]]\n        levels.append((shortcut_item, shortcut_time, completion_times))\n\n    def min_time_to_beat_levels(levels: list, current_level: int, inventory: set, time: int) -> int:\n        if current_level == len(levels):\n            return time\n\n        level = levels[current_level]\n        shortcut_item, shortcut_time, completion_times = level\n\n        min_time = float('inf')\n        for item in inventory:\n            if item == shortcut_item:\n                min_time = min(min_time, shortcut_time)\n            else:\n                min_time = min(min_time, completion_times[item])\n\n        inventory.add(shortcut_item)\n        return min_time_to_beat_levels(levels, current_level + 1, inventory, time + min_time)\n\n    return str(min_time_to_beat_levels(levels, 0, {0}, 0))"
    },
    {
        "number": 3517,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    step_times = [int(x) for x in lines[1].split()]\n    dependencies = []\n    for i in range(2, n+2):\n        line = lines[i].split()\n        dependencies.append([int(x) for x in line[1:]])\n\n    # Calculate the shortest time to construct an airplane\n    shortest_time = float('inf')\n    for i in range(1, n+1):\n        time = 0\n        for j in range(1, n+1):\n            if j in dependencies[i-1]:\n                time += step_times[j-1]\n        shortest_time = min(shortest_time, time)\n\n    return str(shortest_time)"
    },
    {
        "number": 3518,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    students = {}\n    for line in stdin.split('\\n')[1:]:\n        p, q, c = map(int, line.split())\n        students.setdefault(p, set()).add((q, c))\n        students.setdefault(q, set()).add((p, c))\n\n    def dfs(node, visited, path, graph):\n        if node in visited:\n            return\n        visited.add(node)\n        path.append(node)\n        for neighbor, weight in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, path, graph)\n        path.append(node)\n\n    def find_groups(students):\n        groups = []\n        visited = set()\n        for student in students:\n            if student not in visited:\n                path = []\n                dfs(student, visited, path, students)\n                groups.append(path)\n        return groups\n\n    def min_carbon_emitted(groups):\n        total_carbon = 0\n        for group in groups:\n            total_carbon += min(students[group[0]].union(students[group[-1]]))[1]\n        return total_carbon\n\n    groups = find_groups(students)\n    if len(groups) != n:\n        return \"impossible\"\n    return min_carbon_emitted(groups)"
    },
    {
        "number": 3519,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1.000000000\"\n    elif N == 2:\n        return \"2.000000000\"\n    else:\n        return \"{:.6f}\".format(2 + (N-2)*(1+1/(N-1)))"
    },
    {
        "number": 3520,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, c = map(int, stdin.split()[:3])\n    pills = []\n    for i in range(p):\n        t, x, y = map(int, stdin.split()[3*i+3:3*i+6])\n        pills.append((t, x, y))\n    \n    pills.sort(key=lambda x: x[0])\n    \n    def age(t: int, pill: tuple) -> int:\n        return pill[1] - (t - pill[0]) % pill[1]\n    \n    def live_time(t: int, pills: list) -> float:\n        time = 0\n        current_pill = None\n        for pill in pills:\n            if pill[0] <= t:\n                if current_pill is None:\n                    current_pill = pill\n                else:\n                    time += age(t, current_pill)\n                    current_pill = pill\n                t += c\n            else:\n                break\n        if current_pill is not None:\n            time += age(t, current_pill)\n        return time\n    \n    max_time = 0\n    for i in range(len(pills)):\n        max_time = max(max_time, live_time(pills[i][0], pills[i:]))\n    \n    return f\"{max_time:.6f}\""
    },
    {
        "number": 3521,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    stars = []\n    for i in range(1, N+1):\n        T, s, a = map(float, lines[i].split())\n        stars.append((T, s, a))\n\n    def dist(a, b):\n        return min(2*math.pi - abs(a - b), abs(a - b))\n\n    def energy(T, s, a, angle):\n        return max(0, T - s * dist(a, angle))\n\n    def max_distance(stars):\n        max_distance = 0\n        for T, s, a in stars:\n            max_distance += T\n        return max_distance\n\n    def find_angle(stars):\n        angles = [0]\n        for T, s, a in stars:\n            new_angles = []\n            for angle in angles:\n                new_angle = angle + a\n                if new_angle > 2*math.pi:\n                    new_angle -= 2*math.pi\n                new_angles.append(new_angle)\n            angles = new_angles\n        return angles\n\n    angles = find_angle(stars)\n    max_dist = 0\n    for angle in angles:\n        current_dist = 0\n        for T, s, a in stars:\n            current_dist += energy(T, s, a, angle)\n        max_dist = max(max_dist, current_dist)\n\n    return f\"{max_dist:.6f}\""
    },
    {
        "number": 3522,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    batteries = list(map(int, stdin.split()[1].split()))\n    \n    batteries.sort()\n    min_diff = float('inf')\n    \n    for i in range(len(batteries) - 1):\n        for j in range(i + 1, len(batteries)):\n            if (j - i) % k == 0:\n                diff = batteries[j] - batteries[i]\n                min_diff = min(min_diff, diff)\n    \n    return str(min_diff)"
    },
    {
        "number": 3523,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    price, coins = stdin.split(\"\\n\")\n    price = int(price)\n    coins = list(map(int, coins.split()))\n\n    total_value = sum([1, 5, 10, 25] * coins)\n\n    if total_value < price:\n        return \"Impossible\"\n\n    max_coins = 0\n    for i in range(1, len(coins) + 1):\n        for combination in itertools.combinations(coins, i):\n            if sum([1, 5, 10, 25] * combination) == price:\n                max_coins = i\n                break\n        if max_coins != 0:\n            break\n\n    return max_coins"
    },
    {
        "number": 3524,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, s1, s2 = stdin.split('\\n')\n    s1_index = 0\n    s2_index = len(s1)\n\n    for i in range(len(s)):\n        if s[i] == s1[s1_index]:\n            s1_index += 1\n        if s[i] == s2[s2_index - 1]:\n            s2_index -= 1\n\n    if s1_index == len(s1) and s2_index == 0:\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3525,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L, B, S, D = map(int, stdin.split()[:5])\n    locks = []\n    for _ in range(L):\n        a, b, x, y = map(int, stdin.split()[5:])\n        locks.append((a, b, x, y))\n\n    def is_passable(lock, badge_id):\n        a, b, x, y = lock\n        return x <= badge_id <= y\n\n    def get_passable_badge_ids(locks, room):\n        passable_badge_ids = set()\n        for lock in locks:\n            if lock[0] == room:\n                for badge_id in range(lock[2], lock[3] + 1):\n                    passable_badge_ids.add(badge_id)\n        return passable_badge_ids\n\n    passable_badge_ids_from_S = get_passable_badge_ids(locks, S)\n    passable_badge_ids_to_D = get_passable_badge_ids(locks, D)\n\n    count = 0\n    for badge_id in passable_badge_ids_from_S:\n        if badge_id in passable_badge_ids_to_D:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3526,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    hints = []\n    for i in range(m):\n        l, r, answer = stdin.split()[2*i+2:2*i+5]\n        l, r = map(int, [l, r])\n        hints.append((l, r, answer))\n\n    def count_sequences(hints: List[Tuple[int, int, str]]) -> int:\n        sequences = [0] * (n + 1)\n        sequences[0] = 1\n\n        for l, r, answer in hints:\n            if answer == \"same\":\n                for i in range(l, r + 1):\n                    sequences[i] = sequences[i - 1]\n            else:\n                for i in range(l, r + 1):\n                    sequences[i] = sequences[i - 1] + sequences[i]\n\n        return sequences[-1]\n\n    return str(count_sequences(hints) % (10**9 + 7))"
    },
    {
        "number": 3527,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, l = map(int, stdin.split()[:2])\n    connections = [set() for _ in range(c)]\n    for line in stdin.split('\\n')[2:]:\n        a, b = map(int, line.split())\n        connections[a].add(b)\n        connections[b].add(a)\n\n    visited = [False] * c\n    max_hops = 0\n\n    def dfs(node: int, depth: int) -> None:\n        nonlocal max_hops\n        visited[node] = True\n        for neighbor in connections[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, depth + 1)\n        max_hops = max(max_hops, depth)\n\n    for i in range(c):\n        if not visited[i]:\n            dfs(i, 0)\n\n    return str(max_hops)"
    },
    {
        "number": 3528,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nails = []\n    for line in stdin.split('\\n'):\n        if line:\n            x, y = map(int, line.split())\n            nails.append((x, y))\n    \n    picks = stdin.split('\\n')[-2]\n    \n    def find_leftmost(nails):\n        return min(nails, key=lambda x: x[0])\n    \n    def find_rightmost(nails):\n        return max(nails, key=lambda x: x[0])\n    \n    def find_topmost(nails):\n        return max(nails, key=lambda x: x[1])\n    \n    def find_bottommost(nails):\n        return min(nails, key=lambda x: x[1])\n    \n    def area(nails):\n        nails.sort()\n        area = 0\n        for i in range(len(nails) - 1):\n            area += (nails[i+1][1] - nails[i][1]) * (nails[i+1][0] + nails[i][0]) / 2\n        return abs(area)\n    \n    nails_left = nails.copy()\n    nails_right = nails.copy()\n    nails_top = nails.copy()\n    nails_bottom = nails.copy()\n    \n    result = []\n    for pick in picks:\n        if pick == 'L':\n            nails_left.remove(find_leftmost(nails_left))\n        elif pick == 'R':\n            nails_right.remove(find_rightmost(nails_right))\n        elif pick == 'U':\n            nails_top.remove(find_topmost(nails_top))\n        else:\n            nails_bottom.remove(find_bottommost(nails_bottom))\n        \n        result.append(area(nails_left))\n        result.append(area(nails_right))\n        result.append(area(nails_top))\n        result.append(area(nails_bottom))\n    \n    return '\\n'.join(f'{r:.1f}' for r in result)"
    },
    {
        "number": 3529,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    edges = [list(map(int, line.split()[1:])) for line in stdin.split('\\n')[1:]]\n    blue_edges = [edge for edge in edges if edge[0] == 'B']\n    if len(blue_edges) < k:\n        return '0'\n    visited = [False] * n\n    def dfs(node, parent):\n        visited[node - 1] = True\n        for neighbor, color in edges:\n            if neighbor != parent and not visited[neighbor - 1]:\n                if color == 'B':\n                    global blue_count\n                    blue_count -= 1\n                dfs(neighbor, node)\n    blue_count = k\n    dfs(1, -1)\n    return '1' if blue_count == 0 else '0'"
    },
    {
        "number": 3530,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def fun_value(a, b, k):\n        return a - (k - 1) ** 2 * b\n\n    def total_fun(coasters, time):\n        total = 0\n        for coaster in coasters:\n            a, b, t = coaster\n            k = time // t\n            total += fun_value(a, b, k)\n        return total\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    coasters = []\n    for i in range(1, N + 1):\n        a, b, t = map(int, lines[i].split())\n        coasters.append((a, b, t))\n\n    Q = int(lines[N + 1])\n    results = []\n    for i in range(Q):\n        time = int(lines[N + 2 + i])\n        results.append(total_fun(coasters, time))\n\n    return \"\\n\".join(map(str, results))"
    },
    {
        "number": 3531,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, w = map(int, stdin.split()[:4])\n    special_places = set(map(int, stdin.split()[4:4+k]))\n    trails = []\n    for line in stdin.split()[4+k:]:\n        a, b, c = map(int, line.split())\n        trails.append((a, b, c))\n    \n    def find_special_trails(trails, special_places):\n        special_trails = []\n        for trail in trails:\n            if trail[0] in special_places or trail[1] in special_places:\n                special_trails.append(trail)\n        return special_trails\n    \n    def find_min_cost(trails, special_trails, w):\n        min_cost = 0\n        special_trails_used = 0\n        for trail in trails:\n            if trail in special_trails:\n                if special_trails_used < w:\n                    min_cost += trail[2]\n                    special_trails_used += 1\n            else:\n                min_cost += trail[2]\n        return min_cost\n    \n    special_trails = find_special_trails(trails, special_places)\n    min_cost = find_min_cost(trails, special_trails, w)\n    \n    return str(min_cost)"
    },
    {
        "number": 3532,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_string, explosion = stdin.split('\\n')\n    while True:\n        new_string = ''\n        i = 0\n        while i < len(input_string):\n            if input_string[i:i+len(explosion)] == explosion:\n                i += len(explosion)\n            else:\n                new_string += input_string[i]\n                i += 1\n        input_string = new_string\n        if not input_string:\n            return 'FRULA'\n        elif not any(input_string[i:i+len(explosion)] == explosion for i in range(len(input_string) - len(explosion) + 1)):\n            return input_string"
    },
    {
        "number": 3533,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    trucks = []\n    for line in stdin.split('\\n')[1:]:\n        entrance, exit = map(int, line.split())\n        trucks.append((entrance, exit))\n\n    tolls = []\n    for i in range(len(trucks)):\n        for j in range(i + 1, len(trucks)):\n            entrance_i, exit_i = trucks[i]\n            entrance_j, exit_j = trucks[j]\n            if entrance_i == exit_j or entrance_j == exit_i:\n                continue\n            tolls.append(abs(entrance_i - exit_j) + abs(entrance_j - exit_i))\n\n    return str(min(tolls))"
    },
    {
        "number": 3534,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, multi_keys = stdin.split('\\n')\n    n = int(n)\n    multi_keys = list(map(int, multi_keys.split()))\n\n    def count_correct_keys(k: int) -> int:\n        correct_keys = 0\n        prev_key = multi_keys[0]\n        for key in multi_keys[1:]:\n            if key > prev_key:\n                correct_keys += max(key - prev_key - k, 0)\n            elif key < prev_key:\n                correct_keys += max(prev_key - key - k, 0)\n            else:\n                correct_keys += 1\n            prev_key = key\n        return correct_keys\n\n    max_correct_keys = 0\n    best_k = 0\n    for k in range(2 * 10**9 + 1):\n        correct_keys = count_correct_keys(k)\n        if correct_keys > max_correct_keys:\n            max_correct_keys = correct_keys\n            best_k = k\n\n    return str(max_correct_keys) + '\\n' + str(best_k)"
    },
    {
        "number": 3535,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    measurements = stdin.split()[3:]\n    measurements = [measurements[i:i+3] for i in range(0, len(measurements), 3)]\n    \n    def count_valid_states(measurements):\n        valid_states = 0\n        for i in range(2**(N*M)):\n            state = bin(i)[2:].zfill(N*M)\n            is_valid = True\n            for measurement in measurements:\n                y, x, spin = map(int, measurement)\n                if state[N*(y-1)+x-1] != spin:\n                    is_valid = False\n                    break\n            if is_valid:\n                valid_states += 1\n        return valid_states\n    \n    return str(count_valid_states(measurements) % (10**9 + 7))"
    },
    {
        "number": 3536,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    b_p = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_heap(node: int) -> bool:\n        if node == 0:\n            return True\n        b, p = b_p[node - 1]\n        if p == 0:\n            return True\n        parent_b, parent_p = b_p[p - 1]\n        return b < parent_b\n\n    count = 0\n    for i in range(1, n + 1):\n        if is_heap(i):\n            count += 1\n\n    total = 2 ** (n - 1)\n    probability = count / total\n    p = int(probability * 10**9)\n    q = 10**9\n    p_q = p * pow(q, -1, 10**9 + 7)\n    return str(p_q)"
    },
    {
        "number": 3537,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    flights = []\n    for i in range(m):\n        a, b, s, e = map(int, stdin.split()[4*i+2:4*i+6])\n        flights.append((a, b, s, e))\n\n    def frustration(t):\n        return t**2\n\n    def total_frustration(itinerary):\n        total = 0\n        for flight in itinerary:\n            total += frustration(flight[3] - flight[2])\n        return total\n\n    def is_valid_itinerary(itinerary):\n        for i in range(len(itinerary)):\n            for j in range(i+1, len(itinerary)):\n                if itinerary[i][2] == itinerary[j][3] or itinerary[i][3] == itinerary[j][2]:\n                    return False\n        return True\n\n    def find_min_frustration(itinerary):\n        min_frustration = total_frustration(itinerary)\n        for i in range(len(itinerary)):\n            for j in range(i+1, len(itinerary)):\n                if itinerary[i][1] == itinerary[j][0]:\n                    new_itinerary = itinerary[:i] + itinerary[i+1:j] + [(itinerary[i][0], itinerary[j][1], itinerary[i][2], itinerary[j][3])] + itinerary[j+1:]\n                    if is_valid_itinerary(new_itinerary):\n                        new_frustration = total_frustration(new_itinerary)\n                        if new_frustration < min_frustration:\n                            min_frustration = new_frustration\n        return min_frustration\n\n    itinerary = [(1, 2, 0, 10), (2, 4, 11, 16), (2, 1, 9, 12), (3, 5, 28, 100), (1, 2, 3, 8), (4, 3, 20, 21), (1, 3, 13, 27), (3, 5, 23, 24)]\n    return str(find_min_frustration(itinerary))"
    },
    {
        "number": 3538,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[:2])\n    frogs = []\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            l, w, h = map(int, line.split())\n            frogs.append((l, w, h))\n    \n    def can_escape(frog, pile):\n        total_height = frog[2]\n        for p in pile:\n            total_height += p[2]\n        return total_height > d\n    \n    def escape_frogs(frogs):\n        max_frogs = 0\n        for i in range(len(frogs)):\n            for j in range(i+1, len(frogs)):\n                for k in range(j+1, len(frogs)):\n                    pile = [frogs[i], frogs[j], frogs[k]]\n                    if can_escape(frogs[i], pile):\n                        max_frogs += 1\n        return max_frogs\n    \n    return str(escape_frogs(frogs))"
    },
    {
        "number": 3539,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_ways(a, b):\n        MOD = 10**9 + 7\n        dp = [0] * (a + b + 1)\n        dp[0] = 1\n        for i in range(1, a + 1):\n            for j in range(1, b + 1):\n                dp[i + j] += dp[i - 1] + dp[j - 1] - dp[i - 1 + j - 1]\n                dp[i + j] %= MOD\n        return dp[a + b]\n\n    N = int(stdin.readline().strip())\n    ways = 1\n    for _ in range(N):\n        a, b = map(int, stdin.readline().strip().split())\n        ways *= get_ways(a, b)\n        ways %= 10**9 + 7\n    return str(ways)"
    },
    {
        "number": 3540,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Convert input string to a 2D list\n    puzzle = [list(row) for row in stdin.split()]\n\n    # Define the target state of the puzzle\n    target = [[\"R\", \"G\", \"B\", \"Y\"], [\"G\", \"B\", \"Y\", \"R\"], [\"B\", \"Y\", \"R\", \"G\"], [\"Y\", \"R\", \"G\", \"B\"]]\n\n    # Initialize variables\n    moves = 0\n    solved = False\n\n    # Loop until the puzzle is solved\n    while not solved:\n        # Check if the puzzle is already in the target state\n        if puzzle == target:\n            solved = True\n            break\n\n        # Move the puzzle left and right\n        for i in range(4):\n            # Move the row left\n            if puzzle[i] != target[i]:\n                moves += 1\n                puzzle[i] = [puzzle[i][3], puzzle[i][0], puzzle[i][1], puzzle[i][2]]\n\n            # Move the row right\n            if puzzle[i] != target[i]:\n                moves += 1\n                puzzle[i] = [puzzle[i][1], puzzle[i][2], puzzle[i][3], puzzle[i][0]]\n\n        # Move the puzzle up and down\n        for j in range(4):\n            # Move the column up\n            if [puzzle[0][j], puzzle[1][j], puzzle[2][j], puzzle[3][j]] != target[0]:\n                moves += 1\n                puzzle[0], puzzle[1], puzzle[2], puzzle[3] = puzzle[1], puzzle[2], puzzle[3], puzzle[0]\n\n            # Move the column down\n            if [puzzle[0][j], puzzle[1][j], puzzle[2][j], puzzle[3][j]] != target[0]:\n                moves += 1\n                puzzle[0], puzzle[1], puzzle[2], puzzle[3] = puzzle[2], puzzle[3], puzzle[0], puzzle[1]\n\n    return str(moves)"
    },
    {
        "number": 3541,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    a_values = list(map(int, stdin.split('\\n')[1].split()))\n    b_values = list(map(int, stdin.split('\\n')[2].split()))\n\n    a_sum = sum(a_values)\n    b_sum = sum(b_values)\n\n    if abs(a_sum) < abs(b_sum):\n        return ''.join(['A'] * N)\n    elif abs(a_sum) > abs(b_sum):\n        return ''.join(['B'] * N)\n    else:\n        return ''.join(['A' if a_values[i] > b_values[i] else 'B' for i in range(N)])"
    },
    {
        "number": 3542,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n    A1, A2, B1, B2 = points\n\n    def is_valid(p1, p2):\n        return 0 <= min(p1[0], p2[0]) <= max(p1[0], p2[0]) < N and 0 <= min(p1[1], p2[1]) <= max(p1[1], p2[1]) < M\n\n    if not (is_valid(A1, A2) and is_valid(B1, B2)):\n        return \"IMPOSSIBLE\"\n\n    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    min_distance = min(manhattan_distance(A1, A2), manhattan_distance(B1, B2))\n\n    if min_distance == manhattan_distance(A1, A2):\n        return str(min_distance + 1)\n    else:\n        return str(min_distance + 2)"
    },
    {
        "number": 3543,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    dictionary = lines[1:n+1]\n    words_to_type = lines[n+1:]\n\n    def autocorrect(word: str) -> str:\n        for suggestion in dictionary:\n            if suggestion.startswith(word):\n                return suggestion\n        return word\n\n    def keystrokes(word: str) -> int:\n        keystrokes = 0\n        for i, letter in enumerate(word):\n            keystrokes += 1\n            if i == 0 or (i > 0 and autocorrect(word[:i+1]) != word[:i+1]):\n                keystrokes += 1\n        return keystrokes\n\n    result = []\n    for word in words_to_type:\n        result.append(str(keystrokes(word)))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3544,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    groups = list(map(int, stdin.split()[1:]))\n\n    max_seats = 1\n    for i in range(1, n + 1):\n        max_seats += groups[i - 1]\n\n    if max_seats > 12:\n        return \"impossible\"\n    else:\n        return str(max_seats)"
    },
    {
        "number": 3545,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pre_output, in_output, post_output = stdin.split('\\n')\n    pre_calls = [pre_output[i:i+3] for i in range(0, len(pre_output), 3)]\n    in_calls = [in_output[i:i+3] for i in range(0, len(in_output), 3)]\n    post_calls = [post_output[i:i+3] for i in range(0, len(post_output), 3)]\n\n    def find_reconstructions(pre_calls: List[str], in_calls: List[str], post_calls: List[str], pre_index: int, in_index: int, post_index: int, pre_result: List[str], in_result: List[str], post_result: List[str]) -> List[Tuple[List[str], List[str], List[str]]]:\n        if pre_index == len(pre_calls) and in_index == len(in_calls) and post_index == len(post_calls):\n            return [(pre_result, in_result, post_result)]\n\n        reconstructions = []\n        if pre_index < len(pre_calls):\n            pre_result.append(pre_calls[pre_index])\n            reconstructions += find_reconstructions(pre_calls, in_calls, post_calls, pre_index + 1, in_index, post_index, pre_result, in_result, post_result)\n            pre_result.pop()\n\n        if in_index < len(in_calls):\n            in_result.append(in_calls[in_index])\n            reconstructions += find_reconstructions(pre_calls, in_calls, post_calls, pre_index, in_index + 1, post_index, pre_result, in_result, post_result)\n            in_result.pop()\n\n        if post_index < len(post_calls):\n            post_result.append(post_calls[post_index])\n            reconstructions += find_reconstructions(pre_calls, in_calls, post_calls, pre_index, in_index, post_index + 1, pre_result, in_result, post_result)\n            post_result.pop()\n\n        return reconstructions\n\n    reconstructions = find_reconstructions(pre_calls, in_calls, post_calls, 0, 0, 0, [], [], [])\n\n    def compare_trees(tree1: Tuple[List[str], List[str], List[str]], tree2: Tuple[List[str], List[str], List[str]]) -> int:\n        pre1, in1, post1 = tree1\n        pre2, in2, post2 = tree2\n        return (pre1 > pre2) - (pre1 < pre2) or (in1 > in2) - (in1 < in2)\n\n    reconstructions.sort(key=lambda x: x[0] + x[1] + x[2], reverse=True)\n    reconstructions.sort(key=lambda x: compare_trees(x, reconstructions[0]))\n\n    for reconstruction in reconstructions:\n        pre_result, in_result, post_result = reconstruction\n        print(' '.join(pre_result) + ' ' + ' '.join(in_result) + ' ' + ' '.join(post_result))\n\n        def find_tree(pre_result: List[str], in_result: List[str], post_result: List[str]) -> Tuple[List[str], List[str], List[str]]:\n            pre_tree = []\n            in_tree = []\n            post_tree = []\n            for i in range(len(pre_result)):\n                if pre_result[i] == 'Pre':\n                    pre_tree.append(in_result[i])\n                elif pre_result[i] == 'In':\n                    in_tree.append(in_result[i])\n                else:\n                    post_tree.append(in_result[i])\n\n            return (pre_tree, in_tree, post_tree)\n\n        tree = find"
    },
    {
        "number": 3546,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    theorems = {}\n    for i in range(n):\n        proofs = int(input())\n        theorems[i] = {}\n        for j in range(proofs):\n            l, k = map(int, input().split())\n            depends_on = list(map(int, input().split()))\n            theorems[i][j] = {\"length\": l, \"depends_on\": depends_on}\n\n    def find_shortest_length(theorem_index: int, visited: set) -> int:\n        if theorem_index in visited:\n            return 0\n        visited.add(theorem_index)\n        shortest_length = float(\"inf\")\n        for proof in theorems[theorem_index].values():\n            length = proof[\"length\"]\n            for dep in proof[\"depends_on\"]:\n                length += find_shortest_length(dep, visited)\n            shortest_length = min(shortest_length, length)\n        return shortest_length\n\n    shortest_length = find_shortest_length(0, set())\n    return str(shortest_length)"
    },
    {
        "number": 3547,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    plots = []\n    total_area = 0\n\n    for i in range(1, n + 1):\n        x1, y1, x2, y2 = map(float, lines[i].split())\n        plot_area = (x2 - x1) * (y2 - y1)\n        total_area += plot_area\n\n        if i == 1:\n            plots.append((x1, y1, x2, y2))\n        else:\n            for j in range(len(plots)):\n                x3, y3, x4, y4 = plots[j]\n                if x3 < x2 and x4 > x1 and y3 < y2 and y4 > y1:\n                    plot_area = min(x2, x4) - max(x1, x3)\n                    plot_area *= min(y2, y4) - max(y1, y3)\n                    total_area -= plot_area\n                    plots[j] = (max(x1, x3), max(y1, y3), min(x2, x4), min(y2, y4))\n\n    return f\"{total_area:.2f}\""
    },
    {
        "number": 3548,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split()[:2])\n    bad_pairs = set()\n    for _ in range(P):\n        a, b = map(int, stdin.split()[2:])\n        bad_pairs.add((min(a, b), max(a, b)))\n\n    count = 0\n    used_ingredients = set()\n    for i in range(1, N + 1):\n        if i not in used_ingredients:\n            count += 1\n            used_ingredients.add(i)\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3549,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m1, m2, m3 = map(int, stdin.split()[0].split())\n    x1, x2, x3 = map(int, stdin.split()[1].split())\n    y1, y2, y3 = map(int, stdin.split()[2].split())\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def smallest_distance(m, x, y):\n        return (x + y) % m\n\n    def smallest_distance_with_accuracy(m, x, y):\n        return smallest_distance(m, x, y) - y\n\n    lcm_m1_m2 = lcm(m1, m2)\n    lcm_m1_m3 = lcm(m1, m3)\n    lcm_m2_m3 = lcm(m2, m3)\n    lcm_m1_m2_m3 = lcm(lcm_m1_m2, m3)\n\n    smallest_distance_z = smallest_distance_with_accuracy(lcm_m1_m2_m3, x1 * lcm_m1_m2 // m1 + x2 * lcm_m1_m2 // m2 + x3 * lcm_m1_m2 // m3, y1 + y2 + y3)\n\n    return str(smallest_distance_z)"
    },
    {
        "number": 3550,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    variables = {}\n    for line in stdin.split('\\n'):\n        if line == 'end.':\n            break\n        elif line.startswith('var '):\n            name, value = line.split('=')\n            variables[name.strip()] = value.strip()\n        elif line.startswith('print '):\n            expression = line.split('print ')[1].strip()\n            if expression.startswith('`'):\n                result = ''\n                i = 0\n                while i < len(expression):\n                    if expression[i] == '`':\n                        i += 1\n                        break\n                    elif expression[i] == '$':\n                        i += 1\n                        if expression[i] == '{':\n                            j = i + 1\n                            while j < len(expression):\n                                if expression[j] == '}':\n                                    result += eval(expression[i+1:j], variables)\n                                    i = j + 1\n                                    break\n                                j += 1\n                    else:\n                        result += expression[i]\n                    i += 1\n                expression = result\n            else:\n                expression = variables.get(expression, expression)\n            print(expression)\n    return '' "
    },
    {
        "number": 3551,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    bottles = list(map(int, lines[1].split()))\n    target_volume = int(lines[2])\n\n    def fill_bottle(bottle_index: int) -> str:\n        return f\"fill {bottle_index}\"\n\n    def discard_bottle(bottle_index: int) -> str:\n        return f\"discard {bottle_index}\"\n\n    def transfer_bottle(from_bottle: int, to_bottle: int) -> str:\n        return f\"transfer {from_bottle} {to_bottle}\"\n\n    def find_bottle_with_space(volume: int) -> int:\n        for i, bottle in enumerate(bottles):\n            if bottle >= volume:\n                return i\n        return -1\n\n    def find_bottle_with_dry_ice(volume: int) -> int:\n        for i, bottle in enumerate(bottles):\n            if bottle < volume:\n                return i\n        return -1\n\n    moves = []\n    total_volume = sum(bottles)\n    if total_volume < target_volume:\n        return \"impossible\"\n\n    while target_volume > 0:\n        bottle_with_space = find_bottle_with_space(target_volume)\n        if bottle_with_space != -1:\n            moves.append(fill_bottle(bottle_with_space))\n            bottles[bottle_with_space] = 0\n            target_volume = 0\n        else:\n            bottle_with_dry_ice = find_bottle_with_dry_ice(target_volume)\n            if bottle_with_dry_ice != -1:\n                moves.append(transfer_bottle(bottle_with_dry_ice, 0))\n                bottles[bottle_with_dry_ice] -= target_volume\n                target_volume = 0\n            else:\n                return \"impossible\"\n\n    return \"\\n\".join(moves)"
    },
    {
        "number": 3552,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    max_damage = 0\n    for i in range(1, m + 1):\n        damage = n // i * i\n        max_damage = max(max_damage, damage)\n    return str(max_damage)"
    },
    {
        "number": 3553,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_subarray(arr: List[int], k: int) -> int:\n        left, right = 0, 0\n        missing = k\n        min_length = float('inf')\n        count = {}\n        while right < len(arr):\n            if arr[right] not in count:\n                count[arr[right]] = 0\n            count[arr[right]] += 1\n            missing -= 1\n            while missing == 0:\n                min_length = min(min_length, right - left + 1)\n                count[arr[left]] -= 1\n                if count[arr[left]] == 0:\n                    missing += 1\n                left += 1\n            right += 1\n        return min_length if min_length != float('inf') else -1\n\n    input_lines = stdin.split('\\n')\n    N, K, M = map(int, input_lines[0].split())\n    arr = list(map(int, input_lines[1].split()))\n    queries = input_lines[2:]\n\n    result = []\n    for query in queries:\n        if query[0] == '1':\n            p, v = map(int, query.split()[1:])\n            arr[p - 1] = v\n        elif query[0] == '2':\n            result.append(find_shortest_subarray(arr, K))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3554,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D, W, C = map(float, stdin.split())\n    distance_walked = 0\n    smoothie_consumed = 0\n    smoothie_carried = 0\n    smoothie_delivered = 0\n\n    while distance_walked < D:\n        distance_to_walk = min(W, D - distance_walked)\n        smoothie_consumed += distance_to_walk\n        smoothie_carried = min(C, smoothie_carried + distance_to_walk)\n        distance_walked += distance_to_walk\n\n        if smoothie_carried == 0:\n            continue\n\n        smoothie_delivered += smoothie_carried\n        smoothie_carried = 0\n\n    return str(smoothie_delivered)"
    },
    {
        "number": 3555,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    toys = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:2+n]]\n    trees = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2+n:2+n+m]]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def find_closest_toy(p, toys):\n        closest_toy = None\n        min_distance = float('inf')\n        for toy in toys:\n            d = distance(p, toy)\n            if d < min_distance:\n                min_distance = d\n                closest_toy = toy\n        return closest_toy\n\n    def find_shortest_path(start, end, trees):\n        queue = [(0, start)]\n        visited = set()\n        while queue:\n            dist, p = heapq.heappop(queue)\n            if p == end:\n                return dist\n            if p in visited:\n                continue\n            visited.add(p)\n            for neighbor in [(p[0] + 1, p[1]), (p[0] - 1, p[1]), (p[0], p[1] + 1), (p[0], p[1] - 1)]:\n                if neighbor not in visited and neighbor not in trees:\n                    heapq.heappush(queue, (dist + 1, neighbor))\n        return float('inf')\n\n    leash_length = 0\n    current_toy = toys[0]\n    while toys:\n        closest_toy = find_closest_toy(current_toy, toys)\n        shortest_path = find_shortest_path(current_toy, closest_toy, trees)\n        if shortest_path == float('inf'):\n            return \"IMPOSSIBLE\"\n        leash_length += shortest_path\n        current_toy = closest_toy\n        toys.remove(closest_toy)\n\n    return \"{:.2f}\".format(leash_length)"
    },
    {
        "number": 3556,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, q = map(int, stdin.split()[:2])\n    employees = {}\n    for _ in range(m):\n        employee_id, salary, height = map(int, stdin.split()[2:])\n        employees[employee_id] = (salary, height)\n\n    def find_boss(employee_id: int) -> int:\n        boss_id = 0\n        for boss_candidate_id, (boss_candidate_salary, boss_candidate_height) in employees.items():\n            if boss_candidate_salary < employees[employee_id][0] and boss_candidate_height <= employees[employee_id][1]:\n                boss_id = boss_candidate_id\n        return boss_id\n\n    def count_subordinates(employee_id: int) -> int:\n        count = 0\n        for subordinate_id, (subordinate_salary, subordinate_height) in employees.items():\n            if subordinate_salary < employees[employee_id][0] and subordinate_height <= employees[employee_id][1]:\n                count += 1\n        return count\n\n    for query in stdin.split()[2 * m + 2:]:\n        employee_id = int(query)\n        boss_id = find_boss(employee_id)\n        subordinate_count = count_subordinates(employee_id)\n        print(f\"{employee_id} {boss_id} {subordinate_count}\")"
    },
    {
        "number": 3557,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, order = stdin.split('\\n')\n    n = int(n)\n    p = list(map(int, p.split()))\n    order = list(map(int, order.split()))\n\n    def chaos(num: int) -> int:\n        return (num + 9) // 10 * 10\n\n    def segment_chaos(start: int, end: int) -> int:\n        return sum(chaos(p[i]) for i in range(start, end + 1))\n\n    max_chaos = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            chaos_i = segment_chaos(order.index(i) + 1, order.index(j))\n            chaos_j = segment_chaos(order.index(j) + 1, order.index(i))\n            max_chaos = max(max_chaos, chaos_i + chaos_j)\n\n    return str(max_chaos)"
    },
    {
        "number": 3558,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, D = map(int, lines[0].split())\n    buildings = []\n    for line in lines[1:]:\n        transmitter, x, h = map(int, line.split())\n        buildings.append((x, h, transmitter))\n\n    buildings.sort(key=lambda x: x[0])\n    covered_length = 0\n    transmitter_on = False\n    last_x = 0\n\n    for x, h, transmitter in buildings:\n        if transmitter == 1:\n            covered_length += x - last_x\n            transmitter_on = True\n            last_x = x\n        elif transmitter == 0:\n            if transmitter_on:\n                covered_length += x - last_x\n                transmitter_on = False\n                last_x = x\n\n    if transmitter_on:\n        covered_length += D - last_x\n\n    return f\"{covered_length:.6f}\""
    },
    {
        "number": 3559,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    attack_upgrade_1, armour_upgrade_1 = map(int, lines[1].split())\n    attack_upgrade_2, armour_upgrade_2 = map(int, lines[2].split())\n    map_1 = lines[3]\n    map_2 = lines[4]\n    t = int(lines[5])\n\n    # Initialize the maps\n    map_1 = list(map_1)\n    map_2 = list(map_2)\n\n    # Function to calculate the Manhattan distance between two points\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    # Function to calculate the attack value of a Zergling\n    def attack_value(player, upgrade):\n        return 5 + upgrade if player == 1 else 5\n\n    # Function to calculate the armour value of a Zergling\n    def armour_value(player, upgrade):\n        return upgrade if player == 1 else 0\n\n    # Function to calculate the hit points of a Zergling\n    def hit_points(player, upgrade):\n        return 35 if player == 1 else 35\n\n    # Function to calculate the direction of movement\n    def direction(x1, y1, x2, y2):\n        if x1 == x2:\n            return 'N' if y1 < y2 else 'S'\n        elif y1 == y2:\n            return 'E' if x1 < x2 else 'W'\n        else:\n            return 'NE' if x1 < x2 and y1 < y2 else 'NW' if x1 < x2 and y1 > y2 else 'SE' if x1 > x2 and y1 < y2 else 'SW'\n\n    # Function to simulate the attack and movement of Zergling\n    def simulate_turn(map_1, map_2):\n        # Attack and movement of Zergling\n        for i in range(N):\n            for j in range(N):\n                if map_1[i][j] == '1':\n                    # Attack\n                    for k in range(max(0, i - 1), min(i + 2, N)):\n                        for l in range(max(0, j - 1), min(j + 2, N)):\n                            if map_2[k][l] == '2':\n                                map_2[k][l] = '.'\n                                break\n                    # Move\n                    for k in range(max(0, i - 1), min(i + 2, N)):\n                        for l in range(max(0, j - 1), min(j + 2, N)):\n                            if map_2[k][l] == '2':\n                                distance = manhattan_distance(i, j, k, l)\n                                if distance < min_distance:\n                                    min_distance = distance\n                                    min_i, min_j = k, l\n                    if min_i is not None:\n                        map_1[i][j], map_2[min_i][min_j] = map_2[min_i][min_j], map_1[i][j]\n                        min_i, min_j = None, None\n                elif map_1[i][j] == '2':\n                    # Attack\n                    for k in range(max(0, i - 1), min(i + 2, N)):\n                        for l in range(max(0, j - 1), min(j + 2, N)):\n                            if map_1[k][l] == '1':\n                                map_1[k][l] = '.'\n                                break\n                    # Move\n                    for k in range(max(0, i - 1), min(i + 2, N)):\n                        for l in range(max(0, j - 1), min(j + 2, N)):\n                            if map_1[k][l] == '1':\n                                distance = manhattan_distance(i, j, k, l)\n                                if distance < min_distance"
    },
    {
        "number": 3560,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    barbarians = lines[1:N+1]\n    Q = int(lines[N+1])\n    words = []\n    answers = []\n\n    for i in range(Q):\n        T = int(lines[N+2+i])\n        if T == 1:\n            word = lines[N+2+i].split()[1]\n            words.append(word)\n        else:\n            S = int(lines[N+2+i].split()[1])\n            count = 0\n            for barbarian in barbarians:\n                if barbarian in words:\n                    count += 1\n            answers.append(count)\n\n    return \"\\n\".join(map(str, answers))"
    },
    {
        "number": 3561,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, S, C, K = map(int, stdin.split())\n    if W == 0 and S == 0 and C == 0:\n        return \"YES\"\n    if W > K or S > K or C > K:\n        return \"NO\"\n    if W > S and W > C:\n        return \"NO\"\n    if S > C:\n        return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3562,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split()[:2])\n    f = []\n    for i in range(N):\n        a, b, c = map(float, stdin.split()[2:])\n        f.append((a, b, c))\n\n    def f_i(t: float, a: float, b: float, c: float) -> float:\n        return a * t ** 2 + b * t + c\n\n    def average_grade(allocations: List[float]) -> float:\n        return sum(f_i(t, *f[i]) * t for i, t in enumerate(allocations)) / sum(allocations)\n\n    best_average = 0\n    for allocations in itertools.product(np.arange(0, T + 1e-6, 0.01), repeat=N):\n        if sum(allocations) == T:\n            avg = average_grade(allocations)\n            if avg > best_average:\n                best_average = avg\n\n    return f\"{best_average:.4f}\""
    },
    {
        "number": 3563,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    holes = [tuple(map(int, stdin.split()[1:]))]\n\n    def is_inside(point: tuple) -> bool:\n        count = 0\n        for i in range(n):\n            if (holes[i][0] - point[0]) * (holes[i + 1][1] - holes[i][1]) - (holes[i + 1][0] - holes[i][0]) * (holes[i][1] - point[1]) < 0:\n                count += 1\n        return count % 2 == 1\n\n    def min_lines(points: list) -> int:\n        if len(points) == 0:\n            return 0\n        points.sort(key=lambda x: (x[0], x[1]))\n        lines = []\n        for i in range(1, len(points)):\n            if points[i][0] != points[i - 1][0]:\n                lines.append((points[i - 1], points[i]))\n        return len(lines)\n\n    points = [point for point in holes if is_inside(point)]\n    return str(min_lines(points))"
    },
    {
        "number": 3564,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    islands = []\n    for _ in range(n):\n        x, y, r = map(int, stdin.readline().split())\n        islands.append((x, y, r))\n\n    palm_trees = []\n    for _ in range(m):\n        x, y, h = map(int, stdin.readline().split())\n        palm_trees.append((x, y, h))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def is_inside(island, point):\n        return distance(island, point) <= island[2]\n\n    def is_reachable(island1, island2, point1, point2):\n        return distance(point1, point2) <= island1[2] + island2[2]\n\n    def is_tunnel_possible(island1, island2, point1, point2):\n        return distance(island1, point1) >= 1 and distance(island2, point2) >= 1\n\n    def is_palm_reachable(palm_tree, point):\n        return distance(palm_tree, point) <= k * palm_tree[2]\n\n    def is_courier_possible(island1, island2, point1, point2):\n        if is_reachable(island1, island2, point1, point2):\n            return True\n        for palm_tree in palm_trees:\n            if is_palm_reachable(palm_tree, point1) and is_palm_reachable(palm_tree, point2):\n                return True\n        return False\n\n    min_length = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_courier_possible(islands[i], islands[j], (0, 0), (0, 0)):\n                min_length = 0\n                break\n            for x in range(-1000000, 1000001, 100):\n                for y in range(-1000000, 1000001, 100):\n                    if is_courier_possible(islands[i], islands[j], (x, y), (x, y)):\n                        min_length = min(min_length, distance((x, y), (0, 0)))\n                        if min_length == 0:\n                            break\n                if min_length == 0:\n                    break\n            if min_length == 0:\n                break\n        if min_length == 0:\n            break\n\n    if min_length == float('inf'):\n        return \"impossible\"\n    else:\n        return str(min_length)"
    },
    {
        "number": 3565,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        n, m = map(int, lines[0].split())\n        cities = lines[1:n+1]\n        routes = []\n        for i in range(n+1, n+m+1):\n            city1, city2, cost = lines[i].split()\n            routes.append((city1, city2, int(cost)))\n        assignments = []\n        for i in range(n+m+1, n+m+5):\n            city1, city2 = lines[i].split()\n            assignments.append((city1, city2))\n        return n, m, cities, routes, assignments\n\n    def find_min_cost(n: int, m: int, cities: list, routes: list, assignments: list) -> int:\n        def find_route_cost(route: tuple) -> int:\n            for r in routes:\n                if r[0] == route[0] and r[1] == route[1]:\n                    return r[2]\n            return 0\n\n        def find_route(city1: str, city2: str) -> tuple:\n            for r in routes:\n                if r[0] == city1 and r[1] == city2:\n                    return r\n            return None\n\n        def find_path(city1: str, city2: str, visited: set) -> int:\n            if city1 == city2:\n                return 0\n            min_cost = float('inf')\n            for r in routes:\n                if r[0] == city1 and r[1] not in visited:\n                    visited.add(r[1])\n                    min_cost = min(min_cost, r[2] + find_path(r[1], city2, visited))\n                    visited.remove(r[1])\n            return min_cost\n\n        min_cost = 0\n        for assignment in assignments:\n            route = find_route(assignment[0], assignment[1])\n            if route:\n                min_cost += find_route_cost(route)\n            else:\n                min_cost += find_path(assignment[0], assignment[1], set())\n        return min_cost\n\n    n, m, cities, routes, assignments = read_input(stdin)\n    return str(find_min_cost(n, m, cities, routes, assignments))"
    },
    {
        "number": 3566,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    huts = list(map(int, stdin.split()[2:]))\n    changes = []\n    for _ in range(q):\n        i, x = map(int, stdin.split()[:2])\n        changes.append((i, x))\n        stdin = stdin.split()[2:]\n    \n    def find_best_position(huts: List[int], changes: List[Tuple[int, int]]) -> int:\n        best_position = 0\n        min_diff = float('inf')\n        for i in range(1, len(huts)):\n            diff = abs(sum(huts[:i]) - sum(huts[i:]))\n            if diff < min_diff:\n                min_diff = diff\n                best_position = i\n        return best_position\n    \n    for i, x in changes:\n        huts[i] = x\n    \n    result = []\n    for _ in range(q):\n        best_position = find_best_position(huts, changes)\n        result.append(best_position)\n        changes.pop(0)\n        huts[best_position] += 1\n    \n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3567,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    existing_characters = [list(map(int, line.strip())) for line in stdin.split('\\n')[1:]]\n    \n    # Initialize Tira's character with all features\n    tira_character = [1] * k\n    \n    # Calculate the maximum similarity for each feature\n    max_similarity = [0] * k\n    for feature in range(k):\n        for character in existing_characters:\n            if character[feature] == 1:\n                max_similarity[feature] += 1\n    \n    # Set Tira's character to have the features with the smallest maximum similarity\n    for feature in range(k):\n        if max_similarity[feature] == min(max_similarity):\n            tira_character[feature] = 0\n    \n    return ''.join(map(str, tira_character))"
    },
    {
        "number": 3568,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    f = int(lines[0])\n    frequencies = []\n    for i in range(1, f+1):\n        t, n = map(int, lines[i].split())\n        intervals = []\n        for j in range(n):\n            start, end = map(int, lines[i+j+1].split())\n            intervals.append((start, end))\n        frequencies.append((t, intervals))\n\n    def is_possible(frequency: tuple, current_time: int) -> bool:\n        t, intervals = frequency\n        for start, end in intervals:\n            if start <= current_time < end:\n                return True\n        return False\n\n    current_time = 0\n    for t, intervals in frequencies:\n        while current_time < t:\n            if not is_possible((t, intervals), current_time):\n                return \"impossible\"\n            current_time += 1\n        current_time += t\n\n    return \"possible\""
    },
    {
        "number": 3569,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_hit(opponent, shot):\n        x, y, r = opponent\n        dx, dy = shot\n        return (dx - x) ** 2 + (dy - y) ** 2 <= r ** 2\n\n    def count_hits(opponents, shot):\n        return sum(is_hit(opponent, shot) for opponent in opponents)\n\n    n = int(stdin.readline())\n    opponents = [tuple(map(float, line.split())) for line in stdin]\n    max_hits = 0\n\n    for dx in range(-10000000, 10000001):\n        for dy in range(-10000000, 10000001):\n            hits = count_hits(opponents, (dx, dy))\n            max_hits = max(max_hits, hits)\n\n    return str(max_hits)"
    },
    {
        "number": 3570,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    events = []\n    dreams = []\n    scenarios = []\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    for i in range(1, n+1):\n        line = lines[i]\n        if line[0] == 'E':\n            events.append(line[2:])\n        elif line[0] == 'D':\n            dreams.append(line)\n        elif line[0] == 'S':\n            scenario = line.split()\n            scenario_events = scenario[2:]\n            scenarios.append((scenario[1], scenario_events))\n\n    for scenario in scenarios:\n        k = int(scenario[0])\n        scenario_events = scenario[1]\n        scenario_events_set = set(scenario_events)\n        scenario_events_set_not = set([event[1:] for event in scenario_events if event[0] == '!'])\n        scenario_events_set_not_dreams = scenario_events_set_not.intersection(set(dreams))\n        scenario_events_set_not_dreams_count = len(scenario_events_set_not_dreams)\n        scenario_events_set_not_dreams_events = [event for event in scenario_events_set_not if event not in scenario_events_set_not_dreams]\n        scenario_events_set_not_dreams_events_count = len(scenario_events_set_not_dreams_events)\n        scenario_events_set_not_dreams_events_set = set(scenario_events_set_not_dreams_events)\n        scenario_events_set_not_dreams_events_set_not = scenario_events_set_not.difference(scenario_events_set_not_dreams)\n        scenario_events_set_not_dreams_events_set_not_count = len(scenario_events_set_not_dreams_events_set_not)\n        scenario_events_set_not_dreams_events_set_not_events = [event for event in scenario_events_set_not_dreams_events_set_not]\n        scenario_events_set_not_dreams_events_set_not_events_count = len(scenario_events_set_not_dreams_events_set_not_events)\n\n        if scenario_events_set_not_dreams_count == 0:\n            if scenario_events_set_not_dreams_events_set.issubset(set(events)):\n                print(\"Yes\")\n            else:\n                print(\"Plot Error\")\n        else:\n            if scenario_events_set_not_dreams_events_set_not_count == 0:\n                print(f\"{scenario_events_set_not_dreams_count} Just A Dream\")\n            else:\n                print(\"Plot Error\")"
    },
    {
        "number": 3571,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, H, F, N = map(int, stdin.split()[:4])\n    lines = stdin.split('\\n')[1:]\n    adjusted_text = []\n    for line in lines:\n        adjusted_text.append(line.ljust(80))\n    \n    def thumb(lines, height, first):\n        return (height - 3) * first // (lines - height)\n    \n    T = thumb(len(adjusted_text), H, F)\n    \n    def build_window(adjusted_text, W, H, F, T):\n        window = []\n        for i in range(H):\n            line = adjusted_text[F + i - T]\n            if i == 0:\n                line = line[:W]\n            elif i == H - 1:\n                line = line[-W:]\n            else:\n                line = line[W - 1::W]\n            window.append(line)\n        return window\n    \n    window = build_window(adjusted_text, W, H, F, T)\n    \n    def draw_window(window, W, H):\n        output = []\n        output.append('+' + '-' * (W * 2 + 1) + '+')\n        for i, line in enumerate(window):\n            output.append('|' + line + ' ' * (W - len(line)) + '|')\n            if i == 0:\n                output[-1] = output[-1][:3] + '^' + output[-1][4:]\n            elif i == H - 1:\n                output[-1] = output[-1][:W] + 'v' + output[-1][W+1:]\n            else:\n                output[-1] = output[-1][:W] + '|' + output[-1][W+1:]\n        output.append('+' + '-' * (W * 2 + 1) + '+')\n        return '\\n'.join(output)\n    \n    return draw_window(window, W, H)"
    },
    {
        "number": 3572,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.split())\n    distances = [list(map(int, input().split())) for _ in range(n)]\n\n    def dfs(visited, current, path_length):\n        if len(visited) == n:\n            return path_length == L\n\n        for i in range(n):\n            if not visited[i] and (i == 0 or distances[current][i] == distances[current][0]):\n                visited[i] = True\n                if dfs(visited, i, path_length + distances[current][i]):\n                    return True\n                visited[i] = False\n\n        return False\n\n    return \"possible\" if dfs([False] * n, 0, 0) else \"impossible\""
    },
    {
        "number": 3573,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D, C = map(int, stdin.split()[:3])\n    cesar_numbers = list(map(int, stdin.split()[3:3+C]))\n    raul_numbers = list(map(int, stdin.split()[3+C:]))\n    \n    def expected_rounds(N, D, C, cesar_numbers, raul_numbers):\n        if len(cesar_numbers) == 0 or len(raul_numbers) == 0:\n            return 0\n        \n        expected_rounds_cesar = 0\n        expected_rounds_raul = 0\n        \n        for i in range(1, N+1):\n            if i in cesar_numbers:\n                expected_rounds_cesar += (1 - (i-1)/(N-1)) / len(cesar_numbers)\n            if i in raul_numbers:\n                expected_rounds_raul += (1 - (i-1)/(N-1)) / len(raul_numbers)\n        \n        return 1 + min(expected_rounds_cesar, expected_rounds_raul)\n    \n    return str(expected_rounds(N, D, C, cesar_numbers, raul_numbers))"
    },
    {
        "number": 3574,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_magical(arr: List[int]) -> bool:\n        return arr[0] <= arr[-1]\n\n    def longest_magical_subarray(arr: List[int], l: int, r: int) -> int:\n        if not is_magical(arr[l-1:r]):\n            return 0\n        max_length = 1\n        current_length = 1\n        for i in range(l, r):\n            if is_magical(arr[i:i+1]):\n                current_length += 1\n                max_length = max(max_length, current_length)\n            else:\n                current_length = 1\n        return max_length\n\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    arr = list(map(int, input_lines[1].split()))\n    q = int(input_lines[2])\n    queries = [list(map(int, input_lines[i+3].split())) for i in range(q)]\n\n    result = []\n    for l, r in queries:\n        result.append(longest_magical_subarray(arr, l, r))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3575,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    graph = [[0] * n for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u][v] = graph[v][u] = 1\n\n    def dfs(start: int, visited: set) -> int:\n        if start in visited:\n            return 0\n        visited.add(start)\n        return 1 + max(dfs(neighbour, visited) for neighbour in range(n) if graph[start][neighbour])\n\n    alice_time = dfs(s, set())\n    bob_time = dfs(t, set())\n\n    if alice_time == bob_time == 0:\n        return \"never meet\"\n    return str((alice_time + bob_time) / 2)"
    },
    {
        "number": 3576,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    p = 1\n    q = 1\n    for i in range(1, R+1):\n        for j in range(1, C+1):\n            for k in range(1, K+1):\n                p *= (i-k) * (j-k) * (R-i+k) * (C-j+k)\n                q *= (i+k-1) * (j+k-1) * (R-i+k) * (C-j+k)\n    return str(p % (10**11 + 3))"
    },
    {
        "number": 3577,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_flowers(plants: List[Tuple[int, int]]) -> int:\n        flowers = 0\n        for i in range(len(plants)):\n            for j in range(i + 1, len(plants)):\n                if plants[i][0] < plants[j][0] < plants[i][1] < plants[j][1]:\n                    flowers += 1\n        return flowers\n\n    def parse_input(input_str: str) -> List[Tuple[int, int]]:\n        lines = input_str.split(\"\\n\")\n        n = int(lines[0])\n        plants = []\n        for i in range(1, n + 1):\n            l, r = map(int, lines[i].split())\n            plants.append((l, r))\n        return plants\n\n    input_str = stdin\n    plants = parse_input(input_str)\n    flowers = count_flowers(plants)\n    return flowers"
    },
    {
        "number": 3578,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    N, R, flights, F, additional_flights = parse_input(stdin)\n\n    # Create a graph representing the airport connections\n    graph = create_graph(flights)\n\n    # Find the minimum cost to review all the flights\n    min_cost = find_min_cost(graph, N, R, additional_flights)\n\n    return str(min_cost)\n\ndef"
    },
    {
        "number": 3579,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_mad(grid: List[List[int]], area_bounds: Tuple[int, int]) -> float:\n        def calculate_density(rect: Tuple[int, int, int, int]) -> float:\n            area = (rect[2] - rect[0]) * (rect[3] - rect[1])\n            count = sum([sum(row[rect[0]:rect[2]]) for row in grid[rect[1]:rect[3]]])\n            return count / area\n\n        def binary_search(target_area: int) -> Tuple[int, int]:\n            left, right = 0, max(grid)\n            while left <= right:\n                mid = (left + right) // 2\n                area = sum([sum(row[:mid]) for row in grid])\n                if area < target_area:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return left, right\n\n        area_sum = 0\n        densities = []\n        for area in range(area_bounds[0], area_bounds[1] + 1):\n            left, right = binary_search(area)\n            for i in range(left, right + 1):\n                for j in range(left, right + 1):\n                    rect = (i, j, i + 1, j + 1)\n                    density = calculate_density(rect)\n                    densities.append(density)\n                    area_sum += 1\n\n        return statistics.median(densities)\n\n    h, w, a, b = map(int, stdin.split()[:4])\n    grid = [list(map(int, input().split())) for _ in range(h)]\n\n    mad = calculate_mad(grid, (a, b))\n    return f\"{mad:.3f}\""
    },
    {
        "number": 3580,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence, q = stdin.split('\\n')\n    n = int(n)\n    q = int(q)\n    sequence = list(map(int, sequence.split()))\n\n    def longest_consecutive_subsequence(start_index: int, B: set) -> int:\n        longest_subsequence = 0\n        current_subsequence = 0\n        for i in range(start_index, n):\n            if sequence[i] in B:\n                current_subsequence += 1\n                longest_subsequence = max(longest_subsequence, current_subsequence)\n            else:\n                current_subsequence = 0\n        return longest_subsequence\n\n    results = []\n    for _ in range(q):\n        start_index, m, *B = map(int, input().split())\n        B = set(B)\n        result = longest_consecutive_subsequence(start_index - 1, B)\n        results.append(result)\n\n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 3581,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbors(i, N):\n        if i <= N:\n            return [i-1, i+1]\n        elif i >= N*(N-1)//2+1:\n            return [i-1, i+1]\n        else:\n            return [i-1, i+1, i-N-1, i+N+1]\n\n    def simulate_game(p, N):\n        i = 1\n        bounces = 0\n        while True:\n            neighbors = get_neighbors(i, N)\n            probabilities = [p[j-1] for j in neighbors]\n            probabilities.append(1 - sum(probabilities))\n            j = neighbors[np.random.choice(len(neighbors), p=probabilities)]\n            if j == 0:\n                return bounces\n            i = j\n            bounces += 1\n\n    N, H, p = stdin.split('\\n')\n    N = int(N)\n    H = int(H)\n    p = [float(x) for x in p.split()]\n    assert len(p) == 5*H\n\n    expected_bounces = 0\n    for i in range(1, H+1):\n        expected_bounces += p[4*i-1] * (1 - 10**(-3)**(i//H))\n\n    simulations = 10000\n    bounces = [simulate_game(p, N) for _ in range(simulations)]\n    expected_payout = sum(bounces) / len(bounces) * expected_bounces\n\n    return f\"{expected_payout:.4f}\""
    },
    {
        "number": 3582,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    current_mentors = list(map(int, stdin.split()[1:]))\n    new_mentors = [0] * n\n\n    for i in range(n):\n        if current_mentors[i] == i:\n            continue\n\n        mentor_candidates = [j for j in range(n) if j != i and j != current_mentors[i]]\n        mentor_candidates.sort(key=lambda x: current_mentors.index(x) if x in current_mentors else n)\n\n        for j in mentor_candidates:\n            if j not in current_mentors:\n                new_mentors[i] = j\n                break\n\n    return \" \".join(map(str, new_mentors))"
    },
    {
        "number": 3583,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def circumference(points):\n        return sum(distance(points[i], points[(i + 1) % n]) for i in range(n))\n\n    def max_circumference(points, start):\n        points = points[start:] + points[:start]\n        return max(circumference(points[i:i + 6]) for i in range(n - 5))\n\n    return '\\n'.join(str(max_circumference(points, i)) for i in range(n))"
    },
    {
        "number": 3584,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.readline().split())\n    onions = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().split())\n        onions.append((x, y))\n\n    fence_posts = []\n    for _ in range(M):\n        x, y = map(int, stdin.readline().split())\n        fence_posts.append((x, y))\n\n    def convex_hull(points):\n        points.sort()\n        hull = []\n        for p in points:\n            while len(hull) >= 2 and (hull[-1][0] - hull[-2][0]) * (p[1] - hull[-1][1]) < (hull[-1][0] - hull[-2][0]) * (p[1] - hull[-2][1]):\n                hull.pop()\n            hull.append(p)\n        return hull\n\n    def distance(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n    def max_onions(fence_posts):\n        hull = convex_hull(fence_posts)\n        max_onions = 0\n        for onion in onions:\n            if all(distance(onion, p1) >= distance(onion, p2) for p1, p2 in zip(hull, hull[1:] + hull[:1])):\n                max_onions += 1\n        return max_onions\n\n    result = 0\n    for i in range(K):\n        result = max(result, max_onions(fence_posts[:i] + fence_posts[i+1:]))\n\n    return str(result)"
    },
    {
        "number": 3585,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    max_bags = 998244353\n\n    def determine_fake_bag(weighings: int) -> int:\n        if weighings == 0:\n            return 0\n        if weighings == 1:\n            return max_bags\n        if weighings == 2:\n            return 9\n        return 0\n\n    return str(determine_fake_bag(m))"
    },
    {
        "number": 3586,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    s = set(map(int, lines[1:]))\n    max_d = -1\n\n    for a in s:\n        for b in s:\n            for c in s:\n                if a != b and b != c and c != a:\n                    d = a + b + c\n                    if d in s:\n                        max_d = max(max_d, d)\n\n    return str(max_d) if max_d != -1 else \"no solution\""
    },
    {
        "number": 3587,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    taboo_strings = stdin.split('\\n')[1:]\n    max_length = 0\n    max_clue = \"\"\n\n    for i in range(2**N):\n        binary_string = format(i, f'0{N}b')\n        valid_clue = True\n\n        for taboo in taboo_strings:\n            if taboo in binary_string:\n                valid_clue = False\n                break\n\n        if valid_clue and len(binary_string) > max_length:\n            max_length = len(binary_string)\n            max_clue = binary_string\n\n    return max_clue if max_clue else -1"
    },
    {
        "number": 3588,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    num_companies = int(lines[0])\n    share_counts = {}\n\n    for i in range(1, len(lines), 2):\n        num_records = int(lines[i])\n        for j in range(num_records):\n            share_count, trading_day = map(int, lines[i+1+j].split())\n            if trading_day not in share_counts:\n                share_counts[trading_day] = 0\n            share_counts[trading_day] += share_count\n\n    return ' '.join(map(str, sorted(share_counts.values())))"
    },
    {
        "number": 3589,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = [0] * 9\n\n    for x in range(L, R + 1):\n        digits = [int(d) for d in str(x) if d != '0']\n        result = 1\n        for digit in digits:\n            result *= digit\n        count[result % 9] += 1\n\n    return ' '.join(map(str, count))"
    },
    {
        "number": 3590,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(point, polygon):\n        n = len(polygon)\n        inside = False\n        p1x, p1y = polygon[0]\n        for i in range(1, n + 1):\n            p2x, p2y = polygon[i % n]\n            if (p1y > point[1]) != (p2y > point[1]):\n                if point[0] < (p2x - p1x) * (point[1] - p1y) / (p2y - p1y) + p1x:\n                    inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def min_cut_cost(A, B):\n        n = len(A)\n        min_cost = float('inf')\n        for i in range(n):\n            if is_inside(A[i], B):\n                cut_cost = 0\n                for j in range(n):\n                    cut_cost += abs(A[(i + j) % n][0] - A[(i + j - 1) % n][0]) + abs(A[(i + j) % n][1] - A[(i + j - 1) % n][1])\n                min_cost = min(min_cost, cut_cost)\n        return min_cost\n\n    A = []\n    B = []\n    lines = stdin.split('\\n')\n    a = int(lines[0])\n    for i in range(1, a + 1):\n        x, y = map(int, lines[i].split())\n        A.append((x, y))\n    b = int(lines[a + 1])\n    for i in range(a + 2, a + b + 2):\n        x, y = map(int, lines[i].split())\n        B.append((x, y))\n\n    return '{:.6f}'.format(min_cut_cost(A, B))"
    },
    {
        "number": 3591,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split('\\n')[0])\n    photos = []\n    for i in range(k):\n        n = int(stdin.split('\\n')[2*i+1])\n        heights = list(map(int, stdin.split('\\n')[2*i+2].split()))\n        photos.append(heights)\n\n    def is_valid_photo(photo):\n        alice_index = None\n        bob_index = None\n        for i, height in enumerate(photo):\n            if height > max(photo[:i]):\n                alice_index = i\n                break\n        for i, height in enumerate(photo):\n            if height > max(photo[:i]):\n                bob_index = i\n                break\n        return alice_index is not None and bob_index is not None and alice_index < bob_index\n\n    valid_photos = [i for i, photo in enumerate(photos) if is_valid_photo(photo)]\n\n    return str(len(valid_photos)) + '\\n' + '\\n'.join(map(str, valid_photos))"
    },
    {
        "number": 3592,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    profit, pita_profit, pizza_profit = map(float, stdin.split())\n    pita_count = int(profit / pita_profit)\n    pizza_count = int((profit - pita_count * pita_profit) / pizza_profit)\n    return f\"{pita_count} {pizza_count}\""
    },
    {
        "number": 3593,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    board = [list(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    \n    def is_valid(domino: tuple) -> bool:\n        return board[domino[0]][domino[1]] != 0 and board[domino[2]][domino[3]] != 0\n    \n    def rotate_domino(domino: tuple) -> tuple:\n        return (domino[2], domino[3], domino[0], domino[1])\n    \n    def cover_board(dominoes: list) -> int:\n        covered = set()\n        for domino in dominoes:\n            if is_valid(domino):\n                covered.add(domino)\n                covered.add(rotate_domino(domino))\n        return sum(sum(row) for row in board) - 2 * len(covered)\n    \n    max_sum = 0\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                for l in range(N):\n                    if i != k or j != l:\n                        dominoes = [(i, j, k, l)]\n                        for _ in range(K - 1):\n                            dominoes.append((i, j, k, l))\n                        max_sum = max(max_sum, cover_board(dominoes))\n    \n    return str(max_sum)"
    },
    {
        "number": 3594,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rounds = int(stdin.splitlines()[0])\n    players = {'O': 0, 'E': 0, 'I': 0}\n    for line in stdin.splitlines()[1:]:\n        player, start_num = line.split()\n        start_num = int(start_num)\n        if start_num == 1:\n            players[player] += 1\n        else:\n            players[player] += min(start_num, 10000 // start_num)\n    return ' '.join(str(players[player]) for player in ['O', 'E', 'I'])"
    },
    {
        "number": 3595,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, l = map(int, stdin.split()[:2])\n    rooms = []\n    for i in range(r):\n        x1, y1, x2, y2 = map(int, stdin.split()[4:])\n        rooms.append((x1, y1, x2, y2))\n\n    def is_hit(room: tuple, x: int, y: int, angle: float, length: int) -> bool:\n        x1, y1, x2, y2 = room\n        if angle == 0:\n            return x1 <= x <= x2 and y1 <= y <= y2\n        elif angle == 90:\n            return x1 <= y <= x2 and y1 <= x <= y2\n        elif angle == 180:\n            return x1 <= x <= x2 and y1 <= y <= y2\n        elif angle == 270:\n            return x1 <= y <= x2 and y1 <= x <= y2\n        else:\n            return False\n\n    def max_hits(angle: float, length: int) -> int:\n        max_hits = 0\n        for room in rooms:\n            x1, y1, x2, y2 = room\n            x = x1 + (x2 - x1) / 2\n            y = y1 + (y2 - y1) / 2\n            if is_hit(room, x, y, angle, length):\n                max_hits += 1\n        return max_hits\n\n    max_angle = 360\n    max_length = 1000\n    max_hits_result = 0\n\n    for angle in range(0, max_angle, 45):\n        for length in range(1, max_length, 100):\n            hits = max_hits(angle, length)\n            if hits > max_hits_result:\n                max_hits_result = hits\n\n    return str(max_hits_result)"
    },
    {
        "number": 3596,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, t1, t2, t3, t4, n, k, r, s, l = map(float, stdin.split())\n    x = symbols('x')\n    f = c * integrate(t1 * gamma(x) + sqrt(t2) * log(erf(t3 * x)) - jv(k, x) ** t4, (x, a, b))\n    P = f.diff(x, r)\n    P_n = P\n    for i in range(n):\n        P_n = P_n.diff(x, 1) + sum([P_n.subs(x, i) * x ** i for i in range(r + n + 1)])\n    g = P_n.diff(x, r + 1)\n    result = (((g(n) + l) ** 2) / (pi * e) + 1 / (l + 1))\n    return f\"{result:.2f}\""
    },
    {
        "number": 3597,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, l = map(int, stdin.split()[:2])\n    r, x1, y1, x2, y2, x3, y3, h = map(float, stdin.split()[2:])\n\n    # Check if the balls are on the table\n    if not (0 <= x1 <= w and 0 <= y1 <= l and 0 <= x2 <= w and 0 <= y2 <= l and 0 <= x3 <= w and 0 <= y3 <= l):\n        return \"impossible\"\n\n    # Check if the balls are on the dashed line\n    if not (h <= y1 <= l and h <= y2 <= l and h <= y3 <= l):\n        return \"impossible\"\n\n    # Check if the balls are not overlapping\n    if (x1, y1) == (x2, y2) or (x1, y1) == (x3, y3) or (x2, y2) == (x3, y3):\n        return \"impossible\"\n\n    # Calculate the distance to place the ball on the dashed line\n    d = (x1 + x2 + x3) / 3\n\n    # Calculate the angle to shoot the ball\n    theta = math.degrees(math.atan2(y2 - y1, x2 - x1))\n\n    return f\"{d:.2f} {theta:.2f}\""
    },
    {
        "number": 3598,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    magnets = stdin.split(\"\\n\")\n    n = int(magnets[0])\n    del magnets[0]\n\n    def flip(magnet):\n        return \"\".join(str(9 - int(digit)) if digit != \"0\" else \"0\" for digit in magnet)\n\n    def compare(magnet1, magnet2):\n        if magnet1 == magnet2:\n            return 0\n        if magnet1 == flip(magnet2):\n            return 1\n        if magnet2 == flip(magnet1):\n            return -1\n        return int(magnet1) - int(magnet2)\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n\n        return merge(left, right)\n\n    def merge(left, right):\n        result = []\n        i = j = 0\n\n        while i < len(left) and j < len(right):\n            if compare(left[i], right[j]) < 0:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n\n        result.extend(left[i:])\n        result.extend(right[j:])\n\n        return result\n\n    sorted_magnets = merge_sort(magnets)\n    cheapest_price = int(\"\".join(sorted_magnets))\n\n    return str(cheapest_price)"
    },
    {
        "number": 3599,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, N = map(int, stdin.split()[:2])\n    breaks = list(map(int, stdin.split()[2:]))\n    \n    # Sort the breaks in descending order\n    breaks.sort(reverse=True)\n    \n    # Initialize the time spent on stage for each musician\n    time_on_stage = [0] * N\n    \n    # Iterate through the breaks and schedule them\n    for i in range(N):\n        # Find the next available break time for the current musician\n        for j in range(i, N):\n            if breaks[j] <= time_on_stage[j]:\n                # Schedule the break for the current musician\n                time_on_stage[j] += breaks[j]\n                break\n            else:\n                # If no break time is available, schedule the next musician's break\n                time_on_stage[j] = breaks[j]\n                \n    # Output the time spent on stage for each musician\n    return \" \".join(map(str, time_on_stage))"
    },
    {
        "number": 3600,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.splitlines()[:2])\n    intersections = [list(map(int, line.split())) for line in stdin.splitlines()[2:]]\n\n    def dfs(start: int, visited: set, drones: int) -> bool:\n        if drones == k:\n            return True\n        for neighbor in intersections[start][1:]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                if dfs(neighbor, visited, drones + 1):\n                    return True\n                visited.remove(neighbor)\n        return False\n\n    for i in range(n):\n        if dfs(i, {i}, 0):\n            return \"possible\"\n    return \"impossible\""
    },
    {
        "number": 3601,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def read_path(stdin: str) -> list:\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        path = []\n        for i in range(1, n + 1):\n            x, y = map(int, lines[i].split())\n            path.append((x, y))\n        return path\n\n    misha_path = read_path(stdin)\n    nadia_path = read_path(stdin)\n\n    misha_time = 0\n    nadia_time = 0\n    misha_index = 0\n    nadia_index = 0\n\n    while misha_index < len(misha_path) and nadia_index < len(nadia_path):\n        misha_x, misha_y = misha_path[misha_index]\n        nadia_x, nadia_y = nadia_path[nadia_index]\n\n        misha_distance = distance(misha_x, misha_y, nadia_x, nadia_y)\n        misha_time += misha_distance\n\n        if misha_time >= distance(misha_x, misha_y, nadia_x, nadia_y):\n            return \"impossible\"\n\n        nadia_distance = distance(nadia_x, nadia_y, misha_x, misha_y)\n        nadia_time += nadia_distance\n\n        if nadia_time >= distance(nadia_x, nadia_y, misha_x, misha_y):\n            return \"impossible\"\n\n        if misha_x == nadia_x and misha_y == nadia_y:\n            return f\"{min(misha_time, nadia_time):.5f}\"\n\n        misha_index += 1\n        nadia_index += 1\n\n    return \"impossible\""
    },
    {
        "number": 3602,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, k = map(int, stdin.split()[:3])\n    lamps = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:1+k]]\n\n    def is_valid(i, j):\n        for lamp_i, lamp_j in lamps:\n            if abs(i - lamp_i) <= r or abs(j - lamp_j) <= r:\n                return False\n        return True\n\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if not is_valid(i, j):\n                return \"0\"\n    return \"1\""
    },
    {
        "number": 3603,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    translators = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def find_pair(translator1, translator2):\n        for language1 in translator1:\n            for language2 in translator2:\n                if language1 == language2:\n                    return True\n        return False\n\n    def find_matching(translators):\n        matching = []\n        translators_left = translators.copy()\n        while translators_left:\n            translator1 = translators_left.pop(0)\n            for i, translator2 in enumerate(translators_left):\n                if find_pair(translator1, translator2):\n                    matching.append((translator1, translator2))\n                    translators_left.pop(i)\n                    break\n        return matching\n\n    matching = find_matching(translators)\n    if len(matching) == M // 2:\n        for pair in matching:\n            print(f\"{pair[0][0]} {pair[1][0]}\")\n    else:\n        print(\"impossible\")"
    },
    {
        "number": 3604,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[:2])\n    sensors = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    def distance(sensor1, sensor2):\n        return ((sensor1[0] - sensor2[0])**2 + (sensor1[1] - sensor2[1])**2)**0.5\n    \n    def find_largest_subset(sensors, d):\n        largest_subset = []\n        for i in range(len(sensors)):\n            for j in range(i+1, len(sensors)):\n                if distance(sensors[i], sensors[j]) <= d:\n                    largest_subset.extend([i+1, j+1])\n        return largest_subset\n    \n    largest_subset = find_largest_subset(sensors, d)\n    return str(len(largest_subset)) + \"\\n\" + \" \".join(map(str, largest_subset))"
    },
    {
        "number": 3605,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    heights = list(map(int, stdin.split()[2:]))\n\n    heights.sort()\n    min_diff = float('inf')\n\n    for i in range(n - k + 1):\n        diff = heights[i + k - 1] - heights[i]\n        min_diff = min(min_diff, diff)\n\n    return str(min_diff)"
    },
    {
        "number": 3606,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_new_coordinates(x, y, direction):\n        if direction == 'A':\n            return x + 1, y + 1\n        elif direction == 'B':\n            return x + 1, y - 1\n        elif direction == 'C':\n            return x - 1, y + 1\n        else:\n            return x - 1, y - 1\n\n    def is_valid_coordinates(x, y, plants):\n        for plant in plants:\n            if plant[0] == x and plant[1] == y:\n                return True\n        return False\n\n    n, k = map(int, stdin.split()[0:2])\n    directions = list(stdin.split()[2])\n    plants = []\n\n    for i in range(n):\n        x, y = map(int, stdin.split()[3 + i].split())\n        plants.append((x, y))\n\n    x, y = plants[0]\n    for direction in directions:\n        new_x, new_y = get_new_coordinates(x, y, direction)\n        if is_valid_coordinates(new_x, new_y, plants):\n            x, y = new_x, new_y\n\n    return f\"{x} {y}\""
    },
    {
        "number": 3607,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    variables = {}\n    for line in stdin.split('\\n'):\n        if line.strip() == '':\n            continue\n        label, command = line.split(' ', 1)\n        label = int(label)\n        if command.startswith('LET'):\n            var, expr = command.split('=', 1)\n            var = var.strip()\n            expr = expr.strip()\n            if expr.startswith('\"') and expr.endswith('\"'):\n                value = expr[1:-1]\n            else:\n                value = eval(expr, variables)\n            variables[var] = value\n        elif command.startswith('IF'):\n            condition, goto = command.split('THEN', 1)\n            goto = goto.strip()\n            if eval(condition, variables):\n                break\n        elif command.startswith('PRINT'):\n            print_statement = command.split('\"', 1)[1].rsplit('\"', 1)[0]\n            print(print_statement, end='')\n        elif command.startswith('PRINTLN'):\n            print_statement = command.split('\"', 1)[1].rsplit('\"', 1)[0]\n            print(print_statement)\n    return '' "
    },
    {
        "number": 3608,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, tasks, consecutive_tasks = map(int, stdin.split())\n    tasks = list(map(int, tasks.split()))\n    consecutive_tasks = list(map(int, consecutive_tasks.split()))\n\n    MOD = 1000000007\n    dp = [0] * (N + 1)\n    dp[0] = 1\n\n    for i in range(1, N + 1):\n        for j in range(i):\n            if tasks[j] > 0:\n                dp[i] += tasks[j] * dp[i - j - 1]\n                dp[i] %= MOD\n            if consecutive_tasks[j] > 0:\n                dp[i] += consecutive_tasks[j] * dp[i - j - 2]\n                dp[i] %= MOD\n\n    return str(dp[N])"
    },
    {
        "number": 3609,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def dfs(node, visited, tree):\n        visited.add(node)\n        for neighbor in tree[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, tree)\n\n    def is_tree(tree):\n        visited = set()\n        for node in range(1, n + 1):\n            if node not in visited:\n                dfs(node, visited, tree)\n        return len(visited) == n\n\n    left_tree = {i: [] for i in range(1, n + 1)}\n    right_tree = {i: [] for i in range(1, n + 1)}\n\n    for u, v in edges:\n        if u < v:\n            left_tree[u].append(v)\n        else:\n            right_tree[v].append(u)\n\n    if is_tree(left_tree) and is_tree(right_tree):\n        result = ['L'] * (n - 1) + ['R'] * (n - 1)\n        for u, v in edges:\n            if u < v:\n                result[u - 1] = 'R'\n            else:\n                result[v - 1] = 'L'\n        return ''.join(result)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3610,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    m = int(lines[0])\n    teams = {}\n    for i in range(1, m + 1):\n        std_id, lnd_id = map(int, lines[i].split())\n        if std_id not in teams:\n            teams[std_id] = set()\n        if lnd_id not in teams:\n            teams[lnd_id] = set()\n        teams[std_id].add(lnd_id)\n        teams[lnd_id].add(std_id)\n\n    invitees = set()\n    for std_id in teams:\n        if std_id == 1009:\n            invitees.add(std_id)\n        for lnd_id in teams[std_id]:\n            if lnd_id not in invitees:\n                invitees.add(lnd_id)\n                break\n\n    return str(len(invitees)) + '\\n' + '\\n'.join(map(str, sorted(invitees)))"
    },
    {
        "number": 3611,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, s, t = map(int, stdin.split()[:4])\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v, w = map(int, stdin.split()[4:])\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    def dijkstra(start: int) -> list:\n        dist = [float('inf')] * N\n        dist[start] = 0\n        visited = [False] * N\n        heap = [(0, start)]\n        while heap:\n            d, node = heapq.heappop(heap)\n            if visited[node]:\n                continue\n            visited[node] = True\n            for neighbor, weight in graph[node]:\n                new_dist = d + weight\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(heap, (new_dist, neighbor))\n        return dist\n    \n    shortest_paths = dijkstra(s)\n    shortest_paths_to_t = dijkstra(t)\n    \n    interception_stations = []\n    for i in range(N):\n        if shortest_paths[i] + shortest_paths_to_t[i] == shortest_paths[t]:\n            interception_stations.append(i)\n    \n    return ' '.join(map(str, sorted(interception_stations)))"
    },
    {
        "number": 3612,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, m, W, H, X, Y = map(float, stdin.split()[:6])\n    height_map = [list(map(int, line.split())) for line in stdin.split('\\n')[2:H+2]]\n\n    def tide_height(t: float) -> float:\n        return 0.5 * a * (math.cos(t * 2 * math.pi / 12) + 1)\n\n    def is_dry(square1, square2):\n        return abs(height_map[square1[1]][square1[0]] - height_map[square2[1]][square2[0]]) <= 1\n\n    def distance(square1, square2):\n        return ((square1[0] - square2[0]) ** 2 + (square1[1] - square2[1]) ** 2) ** 0.5\n\n    def max_distance(speed):\n        m = speed / (m * 1000)\n        t = 0\n        while t <= 12:\n            t += m\n        t -= m\n        tide_height_at_start = tide_height(t)\n        tide_height_at_end = tide_height(t + m)\n        if tide_height_at_start > tide_height_at_end:\n            return 0\n\n        max_distance = 0\n        for x in range(W):\n            for y in range(H):\n                if is_dry((x, y), (X, Y)):\n                    max_distance = max(max_distance, distance((x, y), (X, Y)))\n\n        return max_distance\n\n    max_distance_1000 = max_distance(1.0)\n    max_distance_999 = max_distance(0.999)\n    max_distance_1001 = max_distance(1.001)\n\n    return str(max_distance_1000)"
    },
    {
        "number": 3613,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_preference_list(line: str) -> List[int]:\n        return list(map(int, line.split()[1:]))\n\n    def get_teacher(line: str) -> int:\n        return int(line.split()[0])\n\n    def is_valid_partition(partition: List[List[int]]) -> bool:\n        for class_a, class_b in itertools.combinations(range(3), 2):\n            for kid_a in partition[class_a]:\n                for kid_b in partition[class_b]:\n                    if kid_a in preference_lists[kid_b - 1][:T] and kid_b in preference_lists[kid_a - 1][:T]:\n                        return False\n        return True\n\n    def get_smallest_T(partition: List[List[int]]) -> int:\n        for T in range(1, N + 1):\n            if is_valid_partition(partition):\n                return T\n        return -1\n\n    N = int(stdin.split('\\n')[0])\n    preference_lists = [get_preference_list(line) for line in stdin.split('\\n')[1:]]\n    current_teachers = [get_teacher(line) for line in stdin.split('\\n')[1:]]\n\n    best_T = N\n    for partition in itertools.permutations(range(1, N + 1)):\n        new_partition = [[], [], []]\n        for i, kid in enumerate(partition):\n            new_partition[current_teachers[i]].append(kid)\n        T = get_smallest_T(new_partition)\n        if T < best_T:\n            best_T = T\n\n    return str(best_T)"
    },
    {
        "number": 3614,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    r, c = map(int, lines[1].split())\n    petals = [list(map(int, line.split())) for line in lines[2:]]\n\n    def can_jump(r1, c1, r2, c2):\n        return abs(r1 - r2) == 1 and abs(c1 - c2) > 1 or abs(c1 - c2) == 1 and abs(r1 - r2) > 1\n\n    visited = set()\n    max_visited = 0\n\n    def dfs(r, c):\n        if (r, c) in visited:\n            return 0\n        visited.add((r, c))\n        count = 1\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_r, new_c = r + dr, c + dc\n            if 0 <= new_r < n and 0 <= new_c < n and can_jump(r, c, new_r, new_c) and petals[new_r][new_c] > petals[r][c]:\n                count += dfs(new_r, new_c)\n        return count\n\n    for i in range(n):\n        for j in range(n):\n            max_visited = max(max_visited, dfs(i, j))\n\n    return str(max_visited)"
    },
    {
        "number": 3615,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    towers = [tuple(map(float, line.split())) for line in stdin.splitlines()[1:]]\n    max_towers = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = ((towers[i][0] - towers[j][0])**2 + (towers[i][1] - towers[j][1])**2)**0.5\n            if dist <= 1:\n                max_towers += 1\n    return str(max_towers + 1)"
    },
    {
        "number": 3616,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, *durations = map(int, stdin.split())\n    durations.sort(reverse=True)\n    total_days = 0\n    active_allergens = 0\n\n    for duration in durations:\n        if active_allergens < duration:\n            total_days += duration\n            active_allergens = duration\n        else:\n            total_days += 1\n\n    return str(total_days)"
    },
    {
        "number": 3617,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T, A, B, C, t0 = map(int, stdin.split())\n    t = [t0]\n    for i in range(1, N):\n        t.append(((A * t[-1] + B) % C) + 1)\n\n    max_problems = min(N, T // t0)\n    total_penalty = sum(t[:max_problems])\n\n    return f\"{max_problems} {total_penalty % 1000000007}\""
    },
    {
        "number": 3618,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 998244353\n    count = 0\n    for i in range(1, 10**n):\n        for j in range(i, 10**n):\n            if is_best_friend(i, j, n):\n                count += 1\n                count %= MOD\n    return str(count)\n\ndef"
    },
    {
        "number": 3619,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split()[0].split())\n    employees = []\n    for i in range(n):\n        s, p, r = map(int, stdin.split()[i+1].split())\n        employees.append((s, p, r))\n\n    def dfs(node, visited, value):\n        if visited[node]:\n            return 0\n        visited[node] = True\n        if node == 0:\n            return value\n        s, p, r = employees[node-1]\n        return dfs(r, visited, value + p)\n\n    max_value = 0\n    for i in range(1, n+1):\n        visited = [False] * (n+1)\n        max_value = max(max_value, dfs(i, visited, 0))\n\n    return f\"{max_value / sum([s for s, _, _ in employees]):.3f}\""
    },
    {
        "number": 3620,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, k, P = map(int, stdin.split()[:4])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:M+1]]\n    \n    # Calculate the number of connected components and their sizes\n    components = []\n    visited = [False] * N\n    for i in range(N):\n        if not visited[i]:\n            component = [i]\n            visited[i] = True\n            queue = [i]\n            while queue:\n                node = queue.pop(0)\n                for neighbor in edges:\n                    if neighbor[0] == node and not visited[neighbor[1]]:\n                        component.append(neighbor[1])\n                        visited[neighbor[1]] = True\n                        queue.append(neighbor[1])\n            components.append(component)\n    \n    # Calculate the number of $k$-colourings for each connected component\n    component_colourings = [0] * len(components)\n    for i, component in enumerate(components):\n        s = len(component)\n        if s > k:\n            component_colourings[i] = 0\n        else:\n            component_colourings[i] = (k - 2) * (k - 1) ** (s - 1)\n    \n    # Calculate the total number of $k$-colourings\n    total_colourings = 1\n    for colouring in component_colourings:\n        total_colourings = (total_colourings * colouring) % P\n    \n    return str(total_colourings)"
    },
    {
        "number": 3621,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    mod = 10**9 + 7\n    total = 0\n\n    for subset in itertools.chain.from_iterable(itertools.combinations(range(n), r) for r in range(1, n+1)):\n        color_set = set(colors[subset[0]][subset[1]])\n        for node in subset[1:]:\n            color_set.intersection_update(colors[subset[0]][node])\n        total += len(color_set)\n\n    return str(total % mod)"
    },
    {
        "number": 3622,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split()[:2])\n    probabilities = list(map(int, stdin.split()[2:]))\n    grid = [list(line.strip()) for line in stdin.split('\\n')[2:]]\n\n    def calculate_probability(target_x, target_y):\n        visited = set()\n        queue = [(target_x, target_y)]\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            if grid[y][x] == 'T':\n                return 1\n            if grid[y][x] == 'X':\n                continue\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < w and 0 <= ny < h:\n                    queue.append((nx, ny))\n        return 0\n\n    total_probability = sum(probabilities)\n    probabilities = [p / total_probability for p in probabilities]\n\n    target_probabilities = []\n    for y in range(h):\n        for x in range(w):\n            if grid[y][x] == 'T':\n                target_probabilities.append(calculate_probability(x, y))\n\n    return '\\n'.join(f'{p:.6f}' for p in target_probabilities)"
    },
    {
        "number": 3623,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(float, stdin.split())\n    angles = [a, b, c, d]\n    angles.sort()\n    total_angle = sum(angles)\n    if total_angle == 360:\n        return \"1.0\"\n    else:\n        return str(1 - total_angle / 360)"
    },
    {
        "number": 3624,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    trails = []\n    for i in range(m):\n        u, v, d = map(int, stdin.split()[3*i+2:3*i+5])\n        trails.append((u, v, d))\n\n    mr_day_time = 0\n    dr_knight_time = 0\n    mr_day_cabin = 0\n    dr_knight_cabin = 0\n\n    while mr_day_cabin != n-1 or dr_knight_cabin != n-1:\n        if mr_day_cabin == n-1:\n            mr_day_time = 0\n        if dr_knight_cabin == n-1:\n            dr_knight_time = 0\n\n        if mr_day_time == 0:\n            mr_day_cabin = 0\n        if dr_knight_time == 0:\n            dr_knight_cabin = 0\n\n        if mr_day_cabin == dr_knight_cabin:\n            if mr_day_time == 0:\n                mr_day_time += 8\n            if dr_knight_time == 0:\n                dr_knight_time += 8\n            continue\n\n        if mr_day_time == 0:\n            mr_day_time += 8\n        if dr_knight_time == 0:\n            dr_knight_time += 8\n\n        if mr_day_cabin == 0:\n            mr_day_cabin = n-1\n        if dr_knight_cabin == 0:\n            dr_knight_cabin = n-1\n\n        for trail in trails:\n            if mr_day_cabin == trail[0] and dr_knight_cabin == trail[1]:\n                if mr_day_time + trail[2] <= 12:\n                    mr_day_time += trail[2]\n                else:\n                    mr_day_time = 12\n                if dr_knight_time + trail[2] <= 12:\n                    dr_knight_time += trail[2]\n                else:\n                    dr_knight_time = 12\n                break\n\n        if mr_day_cabin != n-1:\n            mr_day_cabin = trail[1]\n        if dr_knight_cabin != n-1:\n            dr_knight_cabin = trail[0]\n\n    return str(dr_knight_time)"
    },
    {
        "number": 3625,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    populations = []\n\n    for i in range(1, n + 1):\n        line = lines[i].split()\n        populations.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n\n    max_trees = 0\n    for population in populations:\n        y, i, s, b = population\n        trees = (s + (i * y)) * (i + 1)\n        max_trees = max(max_trees, trees)\n\n    return str(max_trees)"
    },
    {
        "number": 3626,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rectangles = []\n    n = int(stdin.readline().strip())\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        rectangles.append((x1, y1, x2, y2))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if intersect(rectangles[i], rectangles[j]):\n                return \"1\"\n    return \"0\"\n\ndef"
    },
    {
        "number": 3627,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    cliff = stdin.split('\\n')[1:R+1]\n    start_points = stdin.split('\\n')[R+1]\n    \n    def dfs(x, y, energy):\n        if x < 0 or x >= R or y < 0 or y >= C:\n            return energy\n        if cliff[x][y] == 'S':\n            return energy\n        if cliff[x][y] == 'E':\n            return dfs(x-1, y, energy)\n        if cliff[x][y] == 'W':\n            return dfs(x+1, y, energy)\n        if cliff[x][y] == 'N':\n            return dfs(x, y-1, energy)\n        if cliff[x][y] == 'S':\n            return dfs(x, y+1, energy)\n        return dfs(x, y, energy + int(cliff[x][y]))\n    \n    min_energy = float('inf')\n    for start_point in start_points:\n        x, y = start_point.index(start_point), start_point.index(start_point)\n        min_energy = min(min_energy, dfs(x, y, 0))\n    \n    return str(min_energy)"
    },
    {
        "number": 3628,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pi, a = stdin.split('\\n')\n    n = int(n)\n    pi = list(map(int, pi.split()))\n    a = list(map(int, a.split()))\n\n    def is_valid(pi: list, a: list) -> bool:\n        for i in range(n):\n            if (pi[i] + a[i]) % n != i + 1:\n                return False\n        return True\n\n    def find_permutation(pi: list, a: list) -> str:\n        for i in range(n):\n            for j in range(n):\n                if (pi[i] + a[i]) % n == j + 1:\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if is_valid(pi, a):\n                        return ' '.join(map(str, pi))\n                    pi[i], pi[j] = pi[j], pi[i]\n        return \"impossible\"\n\n    pi_str = ' '.join(map(str, pi))\n    return find_permutation(pi, a) + '\\n' + pi_str"
    },
    {
        "number": 3629,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_overlap(tree1, tree2):\n        dx = abs(tree1[0] - tree2[0])\n        dy = abs(tree1[1] - tree2[1])\n        distance = ((dx ** 2) + (dy ** 2)) ** 0.5\n        return distance <= (tree1[2] + tree2[2])\n\n    def is_hit(boar_position, tree):\n        dx = abs(boar_position[0] - tree[0])\n        dy = abs(boar_position[1] - tree[1])\n        distance = ((dx ** 2) + (dy ** 2)) ** 0.5\n        return distance <= tree[2]\n\n    def charge(boar_position, trees, distance):\n        while distance > 0:\n            boar_position = (boar_position[0] + random.uniform(-1, 1), boar_position[1] + random.uniform(-1, 1))\n            distance -= 0.001\n            for tree in trees:\n                if is_hit(boar_position, tree):\n                    return False\n        return True\n\n    n, b, d = map(int, stdin.split('\\n')[-1].split())\n    trees = []\n    for i in range(n):\n        x, y, r = map(int, stdin.split('\\n')[i].split())\n        trees.append((x, y, r))\n\n    count = 0\n    for i in range(10000):\n        if charge((0, 0), trees, d):\n            count += 1\n\n    return str(count / 10000)"
    },
    {
        "number": 3630,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2 = stdin.split()\n    moves = 0\n    for i in range(len(s1)):\n        if s1[i] == s2[i]:\n            continue\n        elif s1[i] == 'z' or s2[i] == 'a':\n            return \"Not possible\"\n        elif ord(s1[i]) < ord(s2[i]):\n            moves += ord(s2[i]) - ord(s1[i])\n        else:\n            moves += 26 - (ord(s1[i]) - ord(s2[i]))\n    return moves"
    },
    {
        "number": 3631,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    beacons = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    mountains = [tuple(map(int, line.split())) for line in stdin.split('\\n')[n+1:n+m+1]]\n    \n    def is_visible(beacon1, beacon2, mountain):\n        return (beacon1[0] - beacon2[0])**2 + (beacon1[1] - beacon2[1])**2 > mountain[2]**2\n    \n    def is_blocked(beacon1, beacon2, mountain):\n        return (beacon1[0] - mountain[0])**2 + (beacon1[1] - mountain[1])**2 <= mountain[2]**2 and (beacon2[0] - mountain[0])**2 + (beacon2[1] - mountain[1])**2 <= mountain[2]**2\n    \n    def is_on_peak(beacon, mountain):\n        return (beacon[0] - mountain[0])**2 + (beacon[1] - mountain[1])**2 <= mountain[2]**2\n    \n    def is_on_edge(beacon, mountain):\n        return (beacon[0] - mountain[0])**2 + (beacon[1] - mountain[1])**2 == mountain[2]**2\n    \n    def is_between(beacon1, beacon2, mountain):\n        return (beacon1[0] - mountain[0])**2 + (beacon1[1] - mountain[1])**2 <= mountain[2]**2 and (beacon2[0] - mountain[0])**2 + (beacon2[1] - mountain[1])**2 <= mountain[2]**2 and not (is_on_peak(beacon1, mountain) or is_on_peak(beacon2, mountain))\n    \n    def is_in_range(beacon, mountain):\n        return (beacon[0] - mountain[0])**2 + (beacon[1] - mountain[1])**2 <= mountain[2]**2\n    \n    def is_in_range_of_peak(beacon, mountain):\n        return (beacon[0] - mountain[0])**2 + (beacon[1] - mountain[1])**2 == mountain[2]**2\n    \n    def is_in_range_of_edge(beacon, mountain):\n        return (beacon[0] - mountain[0])**2 + (beacon[1] - mountain[1])**2 == mountain[2]**2\n    \n    def is_in_range_of_peaks(beacon, peaks):\n        return any(is_in_range_of_peak(beacon, peak) for peak in peaks)\n    \n    def is_in_range_of_edges(beacon, peaks):\n        return any(is_in_range_of_edge(beacon, peak) for peak in peaks)\n    \n    def is_in_range_of_mountain(beacon, mountain):\n        return is_in_range(beacon, mountain) and not is_on_peak(beacon, mountain)\n    \n    def is_in_range_of_mountains(beacon, mountains):\n        return any(is_in_range_of_mountain(beacon, mountain) for mountain in mountains)\n    \n    def is_in_range_of_beacon(beacon1, beacon2, mountains):\n        return is_in_range_of_mountains(beacon1, mountains) and is_in_range_of_mountains(beacon2, mountains)\n    \n    def is_in_range_of_beacons(beacon, beacons, mountains):\n        return all(is_in_range_of_beacon(beacon, other_beacon, mountains) for other_beacon in beacons if other_beacon != beacon)\n    \n    def is_visible_from_beacon(beacon, beacons, mountains):\n        return all(is_visible(beacon, other_beacon, mountain) for other_beacon in beacons for mountain"
    },
    {
        "number": 3632,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    initial_strings = stdin.split()[2:n+2]\n    test_string = stdin.split()[-1]\n\n    composite_strings = []\n    for i in range(n):\n        for j in range(i+1, n):\n            composite_strings.append(initial_strings[i] + initial_strings[j])\n\n    composite_strings.sort()\n    position = composite_strings.index(test_string) + 1\n\n    return str(position % (10**9 + 7))"
    },
    {
        "number": 3633,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def get_score(i: int) -> int:\n        if i == 0:\n            return m\n        else:\n            return min(m, sum(a[:i]) // i)\n\n    def get_permutation(n: int, m: int, k: int, a: List[int]) -> str:\n        for perm in permutations(range(1, n + 1)):\n            scores = [get_score(i) for i in range(n)]\n            avg_score = sum(scores) / n\n            if avg_score == k / n:\n                return \" \".join(map(str, perm))\n        return \"impossible\"\n\n    return get_permutation(n, m, k, a)"
    },
    {
        "number": 3634,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(snow_log: List[Tuple[int, int]]) -> int:\n        n = len(snow_log)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(i):\n                if snow_log[i - 1][0] > snow_log[j][1]:\n                    dp[i] += dp[j]\n            dp[i] %= 1000000009\n\n        return dp[n]\n\n    def parse_input(stdin: str) -> List[Tuple[int, int]]:\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        snow_log = []\n\n        for i in range(1, n + 1):\n            a, b = map(int, lines[i].split())\n            snow_log.append((a, b))\n\n        return snow_log\n\n    snow_log = parse_input(stdin)\n    ways = count_ways(snow_log)\n\n    if ways == 0:\n        return \"shovel time!\"\n    else:\n        return str(ways % 1000000009)"
    },
    {
        "number": 3635,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    num_briefcases = int(lines[0])\n    briefcase_bananas = [int(x) for x in lines[1].split()]\n\n    briefcase_bananas.sort()\n    total_bananas = sum(briefcase_bananas)\n    max_executives = 0\n\n    for i in range(1, len(briefcase_bananas) + 1):\n        if i * briefcase_bananas[-i] <= total_bananas:\n            max_executives += 1\n        else:\n            break\n\n    return str(max_executives)"
    },
    {
        "number": 3636,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    if n < 2 or n > 25 or m < 2 or m > 10**3 or p < 10**8 or p > 10**9+7 or not is_prime(p):\n        return \"Invalid input\"\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def count_ways(n: int, m: int) -> int:\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if i == 1 and j == 1:\n                    dp[i][j] = 1\n                elif i == 1:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 1:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[n][m]\n\n    return str(count_ways(n - 1, m - 1) % p)"
    },
    {
        "number": 3637,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_wishes(wishes: str) -> int:\n        return wishes.count('+') - wishes.count('-')\n\n    def find_toppings(wishes: str) -> str:\n        toppings = []\n        for wish in wishes.split():\n            if wish[0] == '+':\n                toppings.append(wish[1:])\n        return ' '.join(toppings)\n\n    def find_common_toppings(wishes: List[str]) -> str:\n        toppings = set()\n        for wish in wishes:\n            toppings.update(find_toppings(wish).split())\n        return ' '.join(toppings)\n\n    def is_valid_topping(topping: str, wishes: List[str]) -> bool:\n        for wish in wishes:\n            if topping in find_toppings(wish):\n                return True\n        return False\n\n    def find_valid_toppings(wishes: List[str], common_toppings: str) -> str:\n        valid_toppings = []\n        for topping in common_toppings.split():\n            if is_valid_topping(topping, wishes):\n                valid_toppings.append(topping)\n        return ' '.join(valid_toppings)\n\n    def find_best_toppings(wishes: List[str]) -> str:\n        common_toppings = find_common_toppings(wishes)\n        valid_toppings = find_valid_toppings(wishes, common_toppings)\n        return valid_toppings\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    wishes = [line.split()[1:] for line in lines[1:]]\n\n    return find_best_toppings(wishes)"
    },
    {
        "number": 3638,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[:2])\n    predictions = stdin.split()[2:]\n    likelihoods = []\n    \n    for prediction in predictions:\n        likelihood = 1\n        for symbol in prediction:\n            likelihood *= 1/3\n        likelihoods.append(likelihood)\n    \n    sorted_predictions = [prediction for _, prediction in sorted(zip(likelihoods, predictions), reverse=True)]\n    \n    return '\\n'.join(sorted_predictions)"
    },
    {
        "number": 3639,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, c, d = map(float, stdin.splitlines()[1].split())\n    rain = list(map(int, stdin.splitlines()[2:]))\n\n    def sweat(speed: float) -> float:\n        return c * speed ** 2\n\n    def wetness(speed: float, time: int) -> float:\n        return sum(rain[i] * (time - i) / 60000 for i in range(min(time, len(rain)))) + sweat(speed) * time / 60\n\n    def binary_search(left: float, right: float, target: float) -> float:\n        while abs(left - right) > 1e-6:\n            mid = (left + right) / 2\n            if wetness(mid, T) > target:\n                right = mid\n            else:\n                left = mid\n        return left\n\n    optimal_speed = binary_search(0, d / T, 0)\n    return str(wetness(optimal_speed, T))"
    },
    {
        "number": 3640,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def meow_factor(s: str) -> int:\n        def is_meow(s: str) -> bool:\n            return \"meow\" in s\n\n        def can_transform(s: str) -> bool:\n            for i in range(len(s) - 1):\n                if s[i:i+2] == \"me\":\n                    return True\n            return False\n\n        if is_meow(s):\n            return 0\n        if not can_transform(s):\n            return -1\n\n        queue = [(s, 0)]\n        visited = set()\n        while queue:\n            current, depth = queue.pop(0)\n            if current in visited:\n                continue\n            visited.add(current)\n\n            if is_meow(current):\n                return depth\n\n            for i in range(len(current)):\n                for j in range(26):\n                    new_s = current[:i] + chr(ord('a') + j) + current[i+1:]\n                    queue.append((new_s, depth + 1))\n\n                for j in range(i + 2, len(current)):\n                    new_s = current[:i] + current[j] + current[i+1:j] + current[i] + current[j+1:]\n                    queue.append((new_s, depth + 1))\n\n                new_s = current[:i] + current[i+1:]\n                queue.append((new_s, depth + 1))\n\n                new_s = current[:i] + current[i+2:]\n                queue.append((new_s, depth + 1))\n\n        return -1\n\n    return str(meow_factor(stdin))"
    },
    {
        "number": 3641,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split()[:2])\n    beads = list(map(int, stdin.split()[2:]))\n    total_weight = sum(beads)\n    if total_weight % k != 0:\n        return \"NO\"\n    segment_weight = total_weight // k\n    for i in range(n):\n        if beads[i] > segment_weight:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3642,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_path(node, visited, graph, magic):\n        if len(visited) == N:\n            return 1, magic\n\n        min_magic = float('inf')\n        min_path = None\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                path_count, path_magic = find_path(neighbor, visited | {node}, graph, magic * magic[node])\n                if path_magic < min_magic:\n                    min_magic = path_magic\n                    min_path = (node, neighbor)\n\n        if min_path:\n            return 1, min_magic\n        else:\n            return 0, min_magic\n\n    N = int(stdin.readline())\n    graph = [[] for _ in range(N + 1)]\n    magic = [0] * (N + 1)\n\n    for _ in range(N - 1):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    for i in range(1, N + 1):\n        magic[i] = int(stdin.readline())\n\n    _, min_magic = find_path(1, set(), graph, 1)\n    numerator, denominator = 1, min_magic\n\n    for i in range(2, N + 1):\n        numerator = lcm(numerator, magic[i])\n\n    return f\"{numerator}/{denominator}\""
    },
    {
        "number": 3643,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    L = []\n    R = []\n    for i in range(1, N+1):\n        L_i, R_i = map(float, lines[i].split())\n        L.append(L_i)\n        R.append(R_i)\n    \n    def expected_damages(L, R):\n        total_damages = 0\n        for i in range(1, N):\n            for j in range(i+1, N+1):\n                if L[i] > L[j]:\n                    total_damages += L[i] - L[j]\n                if R[i] < R[j]:\n                    total_damages += R[j] - R[i]\n        return total_damages\n    \n    expected_payment = expected_damages(L, R) / (N * N)\n    return str(expected_payment)"
    },
    {
        "number": 3644,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    firings_and_hirings = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    hrs = []\n    for i in range(n):\n        firings = firings_and_hirings[i][0]\n        hirings = firings_and_hirings[i][1]\n\n        if i == 0:\n            hrs.append(1)\n        else:\n            hrs.append(hrs[-1] + hirings - firings)\n\n    min_hrs = min(hrs)\n    hrs = [hr - min_hrs + 1 for hr in hrs]\n\n    return str(min_hrs) + '\\n' + ' '.join(map(str, hrs))"
    },
    {
        "number": 3645,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, integers = stdin.split('\\n')\n    n = int(n)\n    integers = list(map(int, integers.split()))\n\n    unique_integers = set(integers)\n    if len(unique_integers) != n:\n        return \"none\"\n\n    return \"\\n\".join(map(str, sorted(unique_integers)))"
    },
    {
        "number": 3646,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_spots(a, b):\n        return abs(a - b)\n\n    def can_jump(a, b):\n        return count_spots(a, b) == abs(i - j)\n\n    def find_most_distant_pebble(spots):\n        max_distance = 0\n        for i in range(len(spots)):\n            for j in range(i + 1, len(spots)):\n                if can_jump(spots[i], spots[j]):\n                    max_distance = max(max_distance, abs(j - i))\n        return max_distance\n\n    n = int(stdin.readline().strip())\n    spots = list(map(int, stdin.readline().strip().split()))\n\n    return str(find_most_distant_pebble(spots))"
    },
    {
        "number": 3647,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    C, R = map(int, stdin.split()[0].split())\n    maze = [list(line.strip()) for line in stdin.split()[1:]]\n    M = None\n    for i in range(R):\n        for j in range(C):\n            if maze[i][j] == 'M':\n                M = (i, j)\n                maze[i][j] = '.'\n                break\n        if M is not None:\n            break\n\n    def bfs(start: tuple) -> int:\n        queue = [start]\n        visited = set()\n        steps = 0\n        while queue:\n            new_queue = []\n            for node in queue:\n                for neighbor in [(node[0] - 1, node[1]), (node[0] + 1, node[1]), (node[0], node[1] - 1), (node[0], node[1] + 1)]:\n                    if 0 <= neighbor[0] < R and 0 <= neighbor[1] < C and maze[neighbor[0]][neighbor[1]] != '#' and neighbor not in visited:\n                        if maze[neighbor[0]][neighbor[1]] == 'M':\n                            return steps + 1\n                        visited.add(neighbor)\n                        new_queue.append(neighbor)\n            queue = new_queue\n            steps += 1\n        return -1\n\n    result = []\n    for i in range(R):\n        row = []\n        for j in range(C):\n            if maze[i][j] == '#':\n                row.append(-1)\n            else:\n                row.append(bfs((i, j)))\n        result.append(row)\n\n    return '\\n'.join([' '.join(map(str, row)) for row in result])"
    },
    {
        "number": 3648,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p, insecure_buildings = map(int, stdin.split()[:4])\n    insecure_buildings = set(map(int, stdin.split()[4:4+p]))\n    direct_connections = []\n    for line in stdin.split()[4+p:]:\n        x, y, cost = map(int, line.split())\n        direct_connections.append((x, y, cost))\n\n    def is_secure(path):\n        for i in range(len(path) - 1):\n            if path[i] in insecure_buildings and path[i + 1] not in insecure_buildings:\n                return False\n        return True\n\n    def dfs(start, visited, cost):\n        if len(visited) == n:\n            return cost\n        min_cost = float('inf')\n        for end, c in direct_connections:\n            if end not in visited and is_secure(visited + [end]):\n                min_cost = min(min_cost, dfs(end, visited + [end], cost + c))\n        return min_cost\n\n    min_cost = dfs(1, [1], 0)\n    return str(min_cost) if min_cost != float('inf') else 'impossible'"
    },
    {
        "number": 3649,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a + b + c + d > 10**9:\n        return \"impossible\"\n    \n    result = \"\"\n    for i in range(a):\n        result += \"00\"\n    for i in range(b):\n        result += \"01\"\n    for i in range(c):\n        result += \"10\"\n    for i in range(d):\n        result += \"11\"\n    \n    return result"
    },
    {
        "number": 3650,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, B = map(int, stdin.split()[:3])\n    target_board = [list(map(int, line.split())) for line in stdin.split('\\n')[1:B+1]]\n    initial_board = [[0] * M for _ in range(N)]\n    initial_board[1][1] = 1\n\n    def is_valid_move(move: str) -> bool:\n        c, k = move.split()\n        k = int(k)\n        if c == '<':\n            return 1 <= k <= N\n        elif c == '>':\n            return 1 <= k <= N\n        elif c == '^':\n            return 1 <= k <= M\n        elif c == 'v':\n            return 1 <= k <= M\n        else:\n            return False\n\n    def is_block_connected(block1: tuple, block2: tuple) -> bool:\n        r1, c1 = block1\n        r2, c2 = block2\n        if r1 == r2 and abs(c1 - c2) == 1:\n            return True\n        elif c1 == c2 and abs(r1 - r2) == 1:\n            return True\n        else:\n            return False\n\n    def is_target_board_possible(initial_board: list, target_board: list) -> bool:\n        for block in target_board:\n            if not any(is_block_connected(block, initial_block) for initial_block in target_board if initial_block != block):\n                return False\n        return True\n\n    if is_target_board_possible(initial_board, target_board):\n        moves = []\n        for move in stdin.split('\\n')[B+1:]:\n            if is_valid_move(move):\n                moves.append(move)\n            else:\n                return \"impossible\"\n        return \"possible\\n\" + '\\n'.join(moves)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3651,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    planets = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    home_planet = planets[0]\n    planets = planets[1:]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def shortest_path(planets):\n        shortest_paths = {planet: float('inf') for planet in planets}\n        shortest_paths[home_planet] = 0\n\n        while True:\n            updated = False\n            for planet in planets:\n                for neighbor in planets:\n                    if neighbor != planet:\n                        new_distance = shortest_paths[planet] + distance(planet, neighbor)\n                        if new_distance < shortest_paths[neighbor]:\n                            shortest_paths[neighbor] = new_distance\n                            updated = True\n            if not updated:\n                break\n\n        return shortest_paths\n\n    shortest_paths = shortest_path(planets)\n    total_distance = sum(shortest_paths.values())\n\n    return f\"{total_distance:.6f}\""
    },
    {
        "number": 3652,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    rows = [list(map(int, stdin.split('\\n')[i+1].split())) for i in range(3)]\n\n    def count_deletions(columns: List[int]) -> int:\n        rows_to_delete = [[] for _ in range(3)]\n        for i in range(3):\n            for j in range(N):\n                if j not in columns:\n                    rows_to_delete[i].append(rows[i][j])\n        return sum(len(set(row)) != 1 for row in rows_to_delete)\n\n    min_deletions = N\n    for i in range(1, N):\n        for j in range(i+1, N):\n            columns = [i, j]\n            deletions = count_deletions(columns)\n            if deletions < min_deletions:\n                min_deletions = deletions\n\n    return str(min_deletions)"
    },
    {
        "number": 3653,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, x1, y1, x2, y2 = map(int, stdin.split())\n    dx, dy = x2 - x1, y2 - y1\n    chain_length = (L / (dx * dx + dy * dy)) ** 0.5\n    return str(int(chain_length))"
    },
    {
        "number": 3654,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    lawns_visited = 0\n    current_lawn = 1\n    while lawns_visited < n:\n        if current_lawn % 2 == 0:\n            current_lawn += 1\n            continue\n        current_lawn += 1\n        lawns_visited += 1\n    return str(lawns_visited)"
    },
    {
        "number": 3655,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    robot_image, floor_image = stdin.split(\"\\n\\n\")\n    robot_width, robot_height = map(int, robot_image.split()[:2])\n    floor_width, floor_height = map(int, floor_image.split()[:2])\n\n    robot_pixels = [list(map(int, row.split())) for row in robot_image.split(\"\\n\")[2:]]\n    floor_pixels = [list(map(int, row.split())) for row in floor_image.split(\"\\n\")[2:]]\n\n    candidates = []\n    for x in range(floor_width - robot_width + 1):\n        for y in range(floor_height - robot_height + 1):\n            same_pixels = 0\n            for i in range(robot_height):\n                for j in range(robot_width):\n                    if robot_pixels[i][j] == floor_pixels[y + i][x + j]:\n                        same_pixels += 1\n            candidates.append((x, y, same_pixels))\n\n    candidates.sort(key=lambda x: (-x[2], x[0], x[1]))\n    return \"\\n\".join(f\"{x} {y}\" for x, y, _ in candidates[:10])"
    },
    {
        "number": 3656,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, T, f = map(float, stdin.split()[:3])\n    bugs = []\n    for line in stdin.split('\\n')[1:]:\n        p, s = map(float, line.split())\n        bugs.append((p, s))\n\n    def expected_severity(p, s, f, T):\n        return p * s * T\n\n    def expected_severity_fixed(p, s, f, T):\n        return (1 - p) * p * s * T\n\n    def expected_severity_not_fixed(p, s, f, T):\n        return (1 - p) * (1 - p) * s * T\n\n    def expected_severity_fixed_and_not_fixed(p, s, f, T):\n        return (1 - p) * p * s * T\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return (1 - p) * p * s * (T - 1)\n\n    def expected_severity_not_fixed_next_hour(p, s, f, T):\n        return (1 - p) * (1 - p) * s * (T - 1)\n\n    def expected_severity_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T - 1)\n\n    def expected_severity_fixed_and_not_fixed_next_hour(p, s, f, T):\n        return p * s * (T -"
    },
    {
        "number": 3657,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, v_h, N = map(int, stdin.readline().split())\n    gates = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().split())\n        gates.append((x, y))\n    S = int(stdin.readline())\n    skis = []\n    for _ in range(S):\n        s = int(stdin.readline())\n        skis.append(s)\n\n    def time_to_pass_gate(gate, ski):\n        x, y = gate\n        return abs(x) / ski + y\n\n    def time_to_move_horizontally(distance, ski):\n        return distance / ski\n\n    def time_to_pass_race(ski):\n        time = 0\n        for i in range(len(gates)):\n            time += time_to_pass_gate(gates[i], ski)\n            if i < len(gates) - 1:\n                time += time_to_move_horizontally(abs(gates[i][0] - gates[i + 1][0]), ski)\n        return time\n\n    min_time = float('inf')\n    result = None\n    for ski in skis:\n        time = time_to_pass_race(ski)\n        if time < min_time:\n            min_time = time\n            result = ski\n\n    return str(result) if result is not None else \"IMPOSSIBLE\""
    },
    {
        "number": 3658,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_triangle(triangle: List[Tuple[float, float]], point: Tuple[float, float]) -> bool:\n        def sign(p1: Tuple[float, float], p2: Tuple[float, float], p3: Tuple[float, float]) -> int:\n            return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n\n        a = sign(point, triangle[0], triangle[1])\n        b = sign(point, triangle[1], triangle[2])\n        c = sign(point, triangle[2], triangle[0])\n\n        return (a < 0) == (b < 0) == (c < 0)\n\n    def area_of_triangle(triangle: List[Tuple[float, float]]) -> float:\n        a = ((triangle[0][0] - triangle[1][0]) ** 2 + (triangle[0][1] - triangle[1][1]) ** 2) ** 0.5\n        b = ((triangle[1][0] - triangle[2][0]) ** 2 + (triangle[1][1] - triangle[2][1]) ** 2) ** 0.5\n        c = ((triangle[2][0] - triangle[0][0]) ** 2 + (triangle[2][1] - triangle[0][1]) ** 2) ** 0.5\n\n        s = (a + b + c) / 2\n        return (s * (s - a) * (s - b) * (s - c)) ** 0.5\n\n    def area_of_polygon(polygon: List[Tuple[float, float]]) -> float:\n        area = 0\n        n = len(polygon)\n\n        for i in range(n):\n            j = (i + 1) % n\n            area += polygon[i][0] * polygon[j][1]\n            area -= polygon[j][0] * polygon[i][1]\n\n        return abs(area) / 2\n\n    def area_of_overlap(pine_trees: List[Tuple[float, float]], aspen_trees: List[Tuple[float, float]]) -> float:\n        def is_edge_point(point: Tuple[float, float], triangle: List[Tuple[float, float]]) -> bool:\n            return is_inside_triangle(triangle, point) and any(not is_inside_triangle(triangle, other) for other in pine_trees + aspen_trees if other != point)\n\n        def is_edge_triangle(triangle: List[Tuple[float, float]]) -> bool:\n            return any(is_edge_point(point, triangle) for point in pine_trees + aspen_trees)\n\n        def edge_triangles(trees: List[Tuple[float, float]]) -> List[List[Tuple[float, float]]]:\n            return [triangle for triangle in itertools.combinations(trees, 3) if is_edge_triangle(list(triangle))]\n\n        pine_triangles = edge_triangles(pine_trees)\n        aspen_triangles = edge_triangles(aspen_trees)\n\n        overlap_triangles = [triangle for triangle in pine_triangles if any(is_inside_triangle(triangle, other) for other in aspen_triangles)]\n\n        return sum(area_of_triangle(triangle) for triangle in overlap_triangles)\n\n    pine_trees, aspen_trees = [], []\n    p, a = map(int, stdin.split())\n\n    for _ in range(p):\n        x, y = map(float, stdin.split())\n        pine_trees.append((x, y))\n\n    for _ in range(a):\n        x, y = map(float, stdin.split())\n        aspen_trees.append((x, y))\n\n    return f\"{area_of_overlap(pine_trees, aspen_trees):.3f}\""
    },
    {
        "number": 3659,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def partition(books: List[Tuple[int, int]]) -> Tuple[List[int], int]:\n        def dfs(books: List[Tuple[int, int]], target: int, start: int, current: int, depth: int) -> int:\n            if current == target:\n                return depth\n            if current > target:\n                return float('inf')\n            for i in range(start, len(books)):\n                if books[i][0] <= current:\n                    continue\n                if books[i][0] > target:\n                    break\n                result = dfs(books, target, i + 1, current + books[i][1], depth + 1)\n                if result != float('inf'):\n                    return result\n            return float('inf')\n\n        books.sort(key=lambda x: x[0], reverse=True)\n        target = sum(books[i][0] for i in range(len(books) // 3, len(books)))\n        result = dfs(books, target, 0, 0, 0)\n        if result == float('inf'):\n            return [], 0\n        else:\n            shelves = [[] for _ in range(3)]\n            current = 0\n            for i in range(len(books)):\n                if current == result:\n                    break\n                if books[i][0] <= current:\n                    continue\n                for j in range(3):\n                    if books[i][0] > sum(books[k][0] for k in shelves[j]):\n                        shelves[j].append(i)\n                        current += books[i][1]\n                        break\n            return shelves, current\n\n    def area(books: List[Tuple[int, int]]) -> int:\n        shelves, total_width = partition(books)\n        max_heights = [0] * 3\n        for shelf in shelves:\n            for i in shelf:\n                max_heights[shelves.index(shelf)] = max(max_heights[shelves.index(shelf)], books[i][0])\n        return total_width * sum(max_heights)\n\n    n = int(stdin.readline())\n    books = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    return str(area(books))"
    },
    {
        "number": 3660,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    message, n = stdin.split('\\n')[:2]\n    n = int(n)\n    stickers = {}\n\n    for i in range(n):\n        sticker, price = stdin.split('\\n')[i+2].split()\n        stickers[sticker] = int(price)\n\n    def is_overlap(sticker1, sticker2):\n        return sticker1 in sticker2 or sticker2 in sticker1\n\n    def find_combination(message, stickers, current_cost, current_stickers, min_cost):\n        if not message:\n            if current_cost <= 2 and len(current_stickers) <= 2:\n                min_cost[0] = min(min_cost[0], current_cost)\n            return\n\n        for sticker, price in stickers.items():\n            if message.startswith(sticker):\n                new_message = message[len(sticker):]\n                new_stickers = current_stickers + [sticker]\n                find_combination(new_message, stickers, current_cost + price, new_stickers, min_cost)\n\n    min_cost = [float('inf')]\n    find_combination(message, stickers, 0, [], min_cost)\n\n    if min_cost[0] == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return str(min_cost[0])"
    },
    {
        "number": 3661,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S, L = map(int, stdin.split()[:3])\n    cases = []\n    for i in range(L):\n        A, B = map(int, stdin.split()[3:])\n        cases.append((A, B))\n\n    def count_wins(winner: int) -> int:\n        wins = [0] * (R + S)\n        for case in cases:\n            if case[0] == winner or case[1] == winner:\n                wins[case[0] - 1] += 1\n                wins[case[1] - 1] += 1\n        return max(wins)\n\n    min_wins = float('inf')\n    best_winner = -1\n    for winner in range(1, R + S + 1):\n        wins = count_wins(winner)\n        if wins < min_wins:\n            min_wins = wins\n            best_winner = winner\n\n    result = []\n    for case in cases:\n        if case[0] == best_winner or case[1] == best_winner:\n            result.append(\"INDV\" if case[0] == best_winner else \"CORP\")\n        else:\n            result.append(\"INDV\" if case[0] < best_winner else \"CORP\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3662,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    l, w = map(int, lines[1].split())\n    trees = [int(line) for line in lines[2:]]\n    \n    # Calculate the positions of the trees on the right side of the road\n    right_trees = [l - tree for tree in trees]\n    \n    # Calculate the distances between the trees on the left and right sides of the road\n    distances = [abs(left_tree - right_tree) for left_tree, right_tree in zip(trees, right_trees)]\n    \n    # Calculate the total distance that needs to be moved\n    total_distance = sum(distances)\n    \n    return str(total_distance)"
    },
    {
        "number": 3663,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    routes = {}\n    for i in range(1, n):\n        u, v, c = map(int, lines[i].split())\n        routes[(u, v)] = c\n        routes[(v, u)] = c\n\n    armies = []\n    for i in range(n, 2 * n):\n        x, y = map(int, lines[i].split())\n        armies.append((x, y))\n\n    def min_cost(start: int, end: int, visited: set, cost: int) -> int:\n        if start == end:\n            return cost\n        if start in visited:\n            return float('inf')\n        visited.add(start)\n        min_cost_to_end = float('inf')\n        for neighbor, neighbor_cost in routes.items():\n            if neighbor[0] == start:\n                min_cost_to_end = min(min_cost_to_end, min_cost(neighbor[1], end, visited, cost + neighbor_cost))\n        visited.remove(start)\n        return min_cost_to_end\n\n    min_cost_to_conquer = float('inf')\n    for i in range(n):\n        x, y = armies[i]\n        min_cost_to_conquer = min(min_cost_to_conquer, min_cost(i + 1, i + 1, set(), 0))\n\n    return str(min_cost_to_conquer)"
    },
    {
        "number": 3664,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, i, j, n = map(int, stdin.split())\n    ice_rink = [['.' for _ in range(c)] for _ in range(r)]\n    ice_rink[i-1][j-1] = '@'\n    direction = 0  # 0: up, 1: right, 2: down, 3: left\n    step_size = 1\n    colors = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    color_index = 0\n\n    for _ in range(n):\n        for _ in range(step_size):\n            if direction == 0:\n                if i > 1:\n                    ice_rink[i-2][j-1] = colors[color_index]\n                    i -= 1\n                else:\n                    ice_rink[r-1][j-1] = colors[color_index]\n            elif direction == 1:\n                if j < c:\n                    ice_rink[i-1][j] = colors[color_index]\n                    j += 1\n                else:\n                    ice_rink[i-1][0] = colors[color_index]\n            elif direction == 2:\n                if i < r:\n                    ice_rink[i][j-1] = colors[color_index]\n                    i += 1\n                else:\n                    ice_rink[0][j-1] = colors[color_index]\n            elif direction == 3:\n                if j > 1:\n                    ice_rink[i-1][j-2] = colors[color_index]\n                    j -= 1\n                else:\n                    ice_rink[i-1][c-1] = colors[color_index]\n            color_index = (color_index + 1) % 26\n\n        direction = (direction + 1) % 4\n        step_size += 1\n\n    return '\\n'.join([''.join(row) for row in ice_rink])"
    },
    {
        "number": 3665,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    numbers = [int(line.strip()) for line in stdin.split()[2:]]\n    numbers.sort()\n    return '\\n'.join(str(num).zfill(m) for num in numbers)"
    },
    {
        "number": 3666,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    gear_ratios = [tuple(map(int, line.split('/'))) for line in stdin.split('\\n')]\n    front_sprockets = [1] * 2\n    rear_sprockets = [1] * 6\n    front_sprockets_max = 10000\n    rear_sprockets_max = 10000\n\n    def is_valid_gear_ratio(n, d):\n        return 1 <= n <= 100 and 1 <= d <= 100\n\n    def is_valid_sprocket_size(sprocket_size):\n        return 1 <= sprocket_size <= 10000\n\n    def calculate_gear_ratio(n, d):\n        return n / d\n\n    def find_sprocket_size(gear_ratio, sprockets, sprockets_max):\n        for sprocket_size in range(1, sprockets_max + 1):\n            if calculate_gear_ratio(sprocket_size, sprockets[0]) == gear_ratio:\n                return sprocket_size\n        return None\n\n    def find_sprocket_sizes(gear_ratios):\n        for n, d in gear_ratios:\n            if not is_valid_gear_ratio(n, d):\n                return None\n\n        front_sprocket_sizes = []\n        rear_sprocket_sizes = []\n\n        for n, d in gear_ratios:\n            front_sprocket_size = find_sprocket_size(n, front_sprockets, front_sprockets_max)\n            rear_sprocket_size = find_sprocket_size(d, rear_sprockets, rear_sprockets_max)\n\n            if front_sprocket_size is None or rear_sprocket_size is None:\n                return None\n\n            front_sprocket_sizes.append(front_sprocket_size)\n            rear_sprocket_sizes.append(rear_sprocket_size)\n\n        return front_sprocket_sizes, rear_sprocket_sizes\n\n    sprocket_sizes = find_sprocket_sizes(gear_ratios)\n\n    if sprocket_sizes is None:\n        return \"impossible\"\n    else:\n        return \" \".join(map(str, sprocket_sizes[0])) + \"\\n\" + \" \".join(map(str, sprocket_sizes[1]))"
    },
    {
        "number": 3667,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, p = map(int, stdin.split()[0].split())\n    wells = {}\n    pipes = {}\n\n    for i in range(w):\n        x, y = map(int, stdin.split()[i + 1].split())\n        wells[i + 1] = (x, y)\n\n    for i in range(p):\n        s, x, y = map(int, stdin.split()[i + w + 1].split())\n        pipes[i + 1] = (s, (x, y))\n\n    for i in range(p):\n        for j in range(i + 1, p):\n            if pipes[i][1] == pipes[j][1]:\n                return \"impossible\"\n\n    return \"possible\""
    },
    {
        "number": 3668,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    days = list(map(int, stdin.split()[2:]))\n\n    max_unique_identified = 0\n    for i in range(m):\n        burgers = days[i]\n        salads = n - burgers\n\n        if burgers == 0:\n            max_unique_identified = max(max_unique_identified, n)\n        elif burgers == 1:\n            max_unique_identified = max(max_unique_identified, n - 1)\n        elif burgers == 2:\n            max_unique_identified = max(max_unique_identified, n - 2)\n        elif burgers == 3:\n            max_unique_identified = max(max_unique_identified, n - 3)\n        else:\n            max_unique_identified = max(max_unique_identified, n - 4)\n\n    return str(max_unique_identified)"
    },
    {
        "number": 3669,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    moves = [None] * N\n    moves[0] = 0\n    for i in range(1, N):\n        for j in range(i):\n            if moves[j] is not None and (points[i][0] == points[j][0] or points[i][1] == points[j][1]):\n                moves[i] = j\n                break\n    if moves[-1] is None:\n        return \"Mirko\"\n    else:\n        return \"Slavko\""
    },
    {
        "number": 3670,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    numbers = [int(line) for line in stdin.split('\\n')[1:N+1]]\n    \n    M = set()\n    for i in range(2, max(numbers)):\n        if all(num % i == numbers[0] % i for num in numbers):\n            M.add(i)\n    \n    return ' '.join(map(str, M))"
    },
    {
        "number": 3671,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, offers = stdin.split()\n    offers = list(map(int, offers.split()))\n    offers.sort()\n    cookies = 0\n    for i in range(N):\n        if i % 2 == 0:\n            cookies += 4 * 10**5\n        else:\n            cookies += 3 * 10**5\n    return str(cookies)"
    },
    {
        "number": 3672,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[0].split())\n    islands = [list(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n\n    resources = set()\n    for island in islands:\n        resources.update(island)\n\n    if len(resources) != 2 * n:\n        return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3673,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    arrows = [0] * N\n    for i in range(N):\n        arrows[i] = a[i] - 1\n\n    if len(set(arrows)) != N:\n        return \"Impossible\"\n\n    return \" \".join(map(str, arrows))"
    },
    {
        "number": 3674,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, p, q = map(int, stdin.split())\n    if n == 0:\n        return \"IMPOSSIBLE\"\n\n    def is_valid(num: int) -> bool:\n        if num < 10:\n            return False\n        for digit in str(num):\n            if digit == \"0\":\n                return False\n        return True\n\n    def cross_out_digits(num: int, n: int) -> int:\n        return int(str(num)[n:])\n\n    def place_p_after_digits(num: int, p: int) -> int:\n        return int(str(num)[:-1] + str(p))\n\n    def multiply_by_q(num: int, q: int) -> int:\n        return num * q\n\n    for i in range(10**(m-n), 10**m):\n        if is_valid(i):\n            num = cross_out_digits(i, n)\n            num = place_p_after_digits(num, p)\n            num = multiply_by_q(num, q)\n            if num == i:\n                return str(i)\n\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3675,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    strings = [input() for _ in range(n)]\n\n    def lcs(s1: str, s2: str) -> int:\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]\n\n    max_lcs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_lcs = max(max_lcs, lcs(strings[i], strings[j]))\n\n    return max_lcs"
    },
    {
        "number": 3676,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    if R == 1 or C == 1:\n        return \"1\"\n    elif R == 2 and C == 2:\n        return \"13\"\n    else:\n        return \"Too big for this problem\""
    },
    {
        "number": 3677,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    disagreements = {}\n    for i in range(N):\n        line = stdin.split('\\n')[i+1].split()\n        disagreements[i] = set(map(int, line[1:]))\n\n    max_size = 0\n    for size in range(1, K+1):\n        for committee in itertools.combinations(disagreements.keys(), size):\n            if all(len(disagreements[i] & set(committee)) < K for i in disagreements.keys()):\n                max_size = size\n                break\n        if max_size != 0:\n            break\n\n    return str(max_size)"
    },
    {
        "number": 3678,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_loop(points: List[Tuple[int, int]]) -> bool:\n        n = len(points)\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n            x3, y3 = points[(i + 2) % n]\n\n            if x1 == x2 and y1 == y2:\n                return False\n\n            if x1 == x3 and y1 == y3:\n                return False\n\n            if x2 == x3 and y2 == y3:\n                return False\n\n            if x1 == x2 or y1 == y2 or x2 == x3 or y2 == y3:\n                return False\n\n            if x1 == x3 or y1 == y3:\n                return False\n\n            if x1 == x2 and y1 == y2:\n                return False\n\n            if x1 == x3 and y1 == y3:\n                return False\n\n            if x2 == x3 and y2 == y3:\n                return False\n\n            if x1 == x2 or y1 == y2 or x2 == x3 or y2 == y3:\n                return False\n\n            if x1 == x3 or y1 == y3:\n                return False\n\n        return True\n\n    def read_input(stdin: str) -> List[List[Tuple[int, int]]]:\n        test_cases = int(stdin.readline())\n        input_data = []\n\n        for _ in range(test_cases):\n            n = int(stdin.readline())\n            points = []\n\n            for _ in range(n):\n                x, y = map(int, stdin.readline().split())\n                points.append((x, y))\n\n            input_data.append(points)\n\n        return input_data\n\n    input_data = read_input(stdin)\n    output = []\n\n    for points in input_data:\n        if is_valid_loop(points):\n            output.append(\"YES\")\n        else:\n            output.append(\"NO\")\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3679,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    expected_gifts = 0\n    for i in range(1, n+1):\n        expected_gifts += i\n    return f\"{expected_gifts:.6f}\""
    },
    {
        "number": 3680,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, N = map(int, stdin.split()[0].split())\n    poles = list(map(int, stdin.split()[1].split()))\n\n    poles.sort(reverse=True)\n    cuts = 0\n    pole_index = 0\n\n    for i in range(N):\n        if i == N - 1:\n            break\n        if poles[pole_index] > i + 1:\n            cuts += 1\n            poles[pole_index] -= i + 1\n        else:\n            pole_index += 1\n\n    return str(cuts)"
    },
    {
        "number": 3681,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, Q = map(int, stdin.split()[:3])\n    queries = stdin.split('\\n')[3:]\n    teachers = [i for i in range(1, N+1)]\n    schedule = [[] for _ in range(M)]\n    for i in range(M):\n        schedule[i] = [i+1 for i in range(N)]\n\n    def rotate(teachers: list, K: int, x: int) -> list:\n        for i in range(K):\n            teachers[i], teachers[i+1] = teachers[i+1], teachers[i]\n        teachers[-1], teachers[0] = teachers[0], teachers[-1]\n        return teachers\n\n    for query in queries:\n        if query[0] == '0':\n            K, x = map(int, query.split()[1:])\n            p = list(map(int, query.split()[3:]))\n            for i in range(x-1, M, x):\n                schedule[i] = rotate(schedule[i], K, x)\n        else:\n            d, x = map(int, query.split())\n            for i in range(x-1, M, x):\n                if schedule[i][d-1] == d:\n                    print(schedule[i][d-1])\n                    break\n                elif i == M-1:\n                    print(schedule[i][d-1]) "
    },
    {
        "number": 3682,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    repository = {}\n    for i in range(1, n+1):\n        file_name = lines[i]\n        fragment = []\n        j = i+1\n        while lines[j] != '***END***':\n            fragment.append(lines[j])\n            j += 1\n        repository[file_name] = fragment\n        i = j\n\n    code_snippet = []\n    i += 1\n    while lines[i] != '***END***':\n        code_snippet.append(lines[i])\n        i += 1\n\n    # Find matches\n    matches = []\n    for file_name, fragment in repository.items():\n        match = 0\n        for i in range(len(code_snippet)):\n            if i >= len(fragment):\n                break\n            if code_snippet[i] == fragment[i]:\n                match += 1\n            else:\n                break\n        if match > 0:\n            matches.append((match, file_name))\n\n    # Output result\n    if len(matches) == 0:\n        return '0'\n    else:\n        matches.sort(reverse=True)\n        longest_match = matches[0][0]\n        file_names = [match[1] for match in matches if match[0] == longest_match]\n        return f'{longest_match} {\" \".join(file_names)}' "
    },
    {
        "number": 3683,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, h = map(int, stdin.split()[:2])\n    scores = [list(map(int, stdin.split('\\n')[i].split())) for i in range(p)]\n    l = 10**9\n    for i in range(p):\n        for j in range(h):\n            if scores[i][j] >= l:\n                scores[i][j] = l\n    ranks = [1] * p\n    for i in range(p):\n        for j in range(i+1, p):\n            if sum(scores[i]) <= sum(scores[j]):\n                ranks[i] += 1\n    return ' '.join(map(str, ranks))"
    },
    {
        "number": 3684,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, C = map(int, stdin.split()[:2])\n    users = []\n    for line in stdin.split('\\n')[2:]:\n        p, b, u = map(int, line.split())\n        users.append((p, b, u))\n\n    max_buffer_size = 0\n    for i in range(n):\n        p, b, u = users[i]\n        buffer_size = b - (p + C)\n        if buffer_size > max_buffer_size:\n            max_buffer_size = buffer_size\n\n    return str(max_buffer_size)"
    },
    {
        "number": 3685,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(r, c, grid):\n        if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]):\n            return False\n        return grid[r][c] == '.'\n\n    def get_neighbors(r, c, grid):\n        neighbors = []\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_r, new_c = r + dr, c + dc\n            if is_valid(new_r, new_c, grid):\n                neighbors.append((new_r, new_c))\n        return neighbors\n\n    def bfs(start, end, grid):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, distance = queue.pop(0)\n            if current == end:\n                return distance\n            if current not in visited:\n                visited.add(current)\n                for neighbor in get_neighbors(*current, grid):\n                    queue.append((neighbor, distance + 1))\n        return -1\n\n    rows, cols = map(int, stdin.split()[0].split())\n    bed, fridge = eval(stdin.split()[1]), eval(stdin.split()[2])\n    grid = [list(line.strip()) for line in stdin.split()[3:rows + 3]]\n    masters = [eval(line) for line in stdin.split()[-rows - 1:]]\n\n    for master in masters:\n        for r, c in master:\n            grid[r][c] = '#'\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '.' and (r, c) != bed and (r, c) != fridge:\n                grid[r][c] = '#'\n\n    return str(bfs(bed, fridge, grid)) if bfs(bed, fridge, grid) != -1 else \"IMPOSSIBLE\""
    },
    {
        "number": 3686,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    num_targets, targets = parse_input(stdin)\n\n    # Sort targets by x-coordinate\n    targets.sort(key=lambda x: x[0])\n\n    # Check if it's possible to hit all targets with at most two shots\n    if len(targets) <= 2:\n        return \"success\"\n\n    # Check if it's possible to hit all targets with one shot\n    if can_hit_all_targets_with_one_shot(targets):\n        return \"success\"\n\n    # Check if it's possible to hit all targets with two shots\n    if can_hit_all_targets_with_two_shots(targets):\n        return \"success\"\n\n    return \"failure\"\n\ndef"
    },
    {
        "number": 3687,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q, s = map(int, stdin.split()[:3])\n    sensor_queues = list(map(int, stdin.split()[3:3+s]))\n    queue_sizes = list(map(int, stdin.split()[3+s:]))\n    windows = [list(map(int, line.split())) for line in stdin.split('\\n')[3+s:3+s+n]]\n\n    for window in windows:\n        available_space = window[0]\n        for sensor in range(s):\n            sensor_data = window[sensor+1]\n            queue_index = sensor_queues[sensor] - 1\n            if sensor_data > queue_sizes[queue_index]:\n                return \"impossible\"\n            available_space -= sensor_data\n        if available_space < 0:\n            return \"impossible\"\n\n    return \"possible\""
    },
    {
        "number": 3688,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    shopping_malls = []\n    for i in range(n):\n        x, y, t = map(int, stdin.split()[3*i:3*(i+1)])\n        shopping_malls.append((x, y, t))\n\n    items_to_buy = set(range(1, m+1))\n    visited_malls = set()\n    vertical_moves = 0\n\n    current_x, current_y = 0, 0\n    while items_to_buy:\n        min_distance = float('inf')\n        min_mall = None\n        for mall in shopping_malls:\n            if mall[2] in items_to_buy and mall not in visited_malls:\n                distance = abs(mall[0] - current_x) + abs(mall[1] - current_y)\n                if distance < min_distance:\n                    min_distance = distance\n                    min_mall = mall\n\n        if min_mall:\n            visited_malls.add(min_mall)\n            items_to_buy.remove(min_mall[2])\n            if abs(min_mall[0] - current_x) < abs(min_mall[1] - current_y):\n                vertical_moves += 1\n            current_x, current_y = min_mall[:2]\n        else:\n            break\n\n    return str(vertical_moves)"
    },
    {
        "number": 3689,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = int(stdin.split('\\n')[1])\n    \n    y = x\n    while True:\n        if all(y % 10 == y // (10 ** i) % 10 for i in range(1, k)):\n            break\n        y += 1\n    \n    m = len(str(y))\n    return f\"{m}\\n{y}\""
    },
    {
        "number": 3690,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, m, s, t_1, t_2 = map(int, stdin.split())\n\n    # Calculate the angle between the hands\n    hour_angle = (h * 30 + m * 0.5) % 360\n    minute_angle = (m * 6) % 360\n    second_angle = (s * 6) % 360\n\n    # Calculate the angle between the starting and ending positions\n    start_angle = (t_1 * 30) % 360\n    end_angle = (t_2 * 30) % 360\n\n    # Check if the angle between the hands and the starting position is greater than the angle between the hands and the ending position\n    if hour_angle > start_angle and minute_angle > start_angle and second_angle > start_angle:\n        return \"NO\"\n\n    # Check if the angle between the hands and the ending position is greater than the angle between the hands and the starting position\n    if hour_angle > end_angle and minute_angle > end_angle and second_angle > end_angle:\n        return \"NO\"\n\n    # Check if the angle between the hands and the starting position is greater than the angle between the hands and the ending position\n    if start_angle > hour_angle and start_angle > minute_angle and start_angle > second_angle:\n        return \"NO\"\n\n    # Check if the angle between the hands and the ending position is greater than the angle between the hands and the starting position\n    if end_angle > hour_angle and end_angle > minute_angle and end_angle > second_angle:\n        return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3691,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x0, y0, a_x, a_y, b_x, b_y, x_s, y_s, t = map(int, stdin.split())\n\n    def get_coordinates(i: int) -> tuple:\n        return (a_x * x_s + b_x, a_y * y_s + b_y)\n\n    def get_distance(p1: tuple, p2: tuple) -> int:\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def get_max_nodes(t: int) -> int:\n        max_nodes = 0\n        current_position = (x_s, y_s)\n        visited = set()\n\n        for i in range(t):\n            if i % 2 == 0:\n                current_position = (current_position[0] - 1, current_position[1])\n            else:\n                current_position = (current_position[0] + 1, current_position[1])\n\n            if i % 4 == 2:\n                current_position = (current_position[0], current_position[1] - 1)\n            else:\n                current_position = (current_position[0], current_position[1] + 1)\n\n            if current_position in visited:\n                continue\n\n            visited.add(current_position)\n            max_nodes += 1\n\n        return max_nodes\n\n    return str(get_max_nodes(t))"
    },
    {
        "number": 3692,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    circles = []\n    for line in stdin.split('\\n')[1:]:\n        x, y, r = map(int, line.split())\n        circles.append((x, y, r))\n\n    def is_inside(circle1, circle2):\n        x1, y1, r1 = circle1\n        x2, y2, r2 = circle2\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2 <= (r1 + r2) ** 2\n\n    def is_intersect(circle1, circle2):\n        x1, y1, r1 = circle1\n        x2, y2, r2 = circle2\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2 <= (r1 - r2) ** 2\n\n    def find_region(circle, circles):\n        inside_circles = [c for c in circles if is_inside(circle, c)]\n        intersect_circles = [c for c in circles if is_intersect(circle, c)]\n        return inside_circles, intersect_circles\n\n    def find_regions(circles):\n        regions = []\n        for circle in circles:\n            inside_circles, intersect_circles = find_region(circle, circles)\n            if not inside_circles:\n                regions.append([circle])\n            else:\n                for region in regions:\n                    if any(c in region for c in inside_circles):\n                        region.append(circle)\n                        break\n                else:\n                    regions.append([circle])\n        return regions\n\n    regions = find_regions(circles)\n    return str(len(regions))"
    },
    {
        "number": 3693,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    square1, square2 = stdin.split(\"\\n\")\n    square1 = [int(x) for x in square1.split()]\n    square2 = [int(x) for x in square2.split()]\n\n    # Check if squares intersect\n    def is_intersect(square1, square2):\n        # Check if squares share a common point\n        for i in range(0, 4):\n            for j in range(0, 4):\n                if square1[i] == square2[j] and square1[i+1] == square2[j+1]:\n                    return True\n        # Check if squares intersect\n        for i in range(0, 4):\n            if square1[i] == square2[i] and square1[i+1] == square2[i+1]:\n                return True\n        return False\n\n    if is_intersect(square1, square2):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3694,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    piles = list(map(int, stdin.split()[1:]))\n\n    if n == 1:\n        return \"sjfnb\" if piles[0] == 0 else \"cslnb\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if piles[i] == piles[j]:\n                return \"sjfnb\" if i % 2 == 0 else \"cslnb\"\n\n    return \"sjfnb\"\n"
    },
    {
        "number": 3695,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[:2])\n    t = list(map(int, stdin.split()[2:]))\n    t.append(T)\n    t.sort()\n    max_bowls = 0\n    current_bowl = 0\n    current_time = 0\n\n    while current_time < T:\n        if current_time >= t[current_bowl]:\n            max_bowls += 1\n            current_bowl += 1\n        else:\n            current_time += 1\n\n    return str(max_bowls)"
    },
    {
        "number": 3696,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\\n0 1\\n0\\n1\"\n    elif n == 2:\n        return \"2\\n-1 0 1\\n1\\n0 1\"\n    else:\n        return \"-1\""
    },
    {
        "number": 3697,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m, a = map(int, stdin.split()[:4])\n    g = list(map(int, stdin.split()[4:]))\n    votes = [0] * n\n    for i in range(a):\n        votes[g[i] - 1] += 1\n\n    result = [0] * n\n    for i in range(n):\n        if votes[i] == 0:\n            result[i] = 3\n        elif votes[i] >= k:\n            result[i] = 1\n        else:\n            result[i] = 2\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3698,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 10**9 + 7\n    count = 0\n    for i in range(1, n+1):\n        if bin(i).count('1') == k:\n            count += 1\n    return str(count % mod)"
    },
    {
        "number": 3699,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def min_distance(a_x, a_y, b_x, b_y, t_x, t_y, bottles):\n        bottles.sort(key=lambda x: distance(x[0], x[1], t_x, t_y))\n        a_path = [(a_x, a_y)]\n        b_path = [(b_x, b_y)]\n        a_dist = 0\n        b_dist = 0\n\n        for bottle in bottles:\n            a_dist += distance(a_path[-1][0], a_path[-1][1], bottle[0], bottle[1])\n            a_path.append(bottle)\n\n            b_dist += distance(b_path[-1][0], b_path[-1][1], bottle[0], bottle[1])\n            b_path.append(bottle)\n\n        a_dist += distance(a_path[-1][0], a_path[-1][1], t_x, t_y)\n        b_dist += distance(b_path[-1][0], b_path[-1][1], t_x, t_y)\n\n        return a_dist + b_dist\n\n    a_x, a_y, b_x, b_y, t_x, t_y = map(int, stdin.split()[:6])\n    n = int(stdin.split()[-1])\n    bottles = [(int(x), int(y)) for x, y in map(lambda x: x.split(), stdin.split()[6:-1])]\n\n    return str(min_distance(a_x, a_y, b_x, b_y, t_x, t_y, bottles))"
    },
    {
        "number": 3700,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if i + j == k:\n                count += 1\n    return str(count)"
    },
    {
        "number": 3701,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    a = list(stdin.split()[1])\n    min_cost = 0\n    \n    for i in range(n):\n        if a[i] == '0':\n            min_cost += x\n            a[i] = '1'\n        else:\n            min_cost += y\n            a[i] = '0'\n    \n    return str(min_cost)"
    },
    {
        "number": 3702,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, d = map(int, stdin.split())\n    for b in range(1, 2**64):\n        for e in range(1, 2**64):\n            found = True\n            for i in range(n):\n                f = a + i * d\n                f_index = b + i * e\n                if f_index >= 2**64:\n                    found = False\n                    break\n                f_value = \"{:018}\".format(F(f_index))\n                if str(f) not in f_value:\n                    found = False\n                    break\n            if found:\n                return \"{} {}\".format(b, e)\n    return \"-1\"\n\ndef"
    },
    {
        "number": 3703,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    def f(n):\n        if n == 1:\n            return 1\n        count = 0\n        for i in range(1, n // 2 + 1):\n            if n % i == 0 and math.gcd(i, n // i) == 1:\n                count += 1\n        return count\n\n    def g(n):\n        result = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                result += f(n // i)\n        return result\n\n    def F_k(n, k):\n        if k == 1:\n            return f(g(n))\n        elif k % 2 == 0:\n            return g(F_k(n, k - 1))\n        else:\n            return f(F_k(n, k - 1))\n\n    return str(F_k(n, k) % 1000000007)"
    },
    {
        "number": 3704,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    blacklist = set()\n    whitelist = set()\n    for line in stdin.split('\\n'):\n        if not line:\n            continue\n        sign, subnet = line[0], line[1:]\n        if sign == '+':\n            whitelist.add(subnet)\n        elif sign == '-':\n            blacklist.add(subnet)\n\n    def subnet_to_int(subnet: str) -> int:\n        if '/' in subnet:\n            ip, mask = subnet.split('/')\n            mask = 32 - int(mask)\n            return int(ip.replace('.', '')) | (0xffffffff >> mask)\n        else:\n            return int(subnet.replace('.', ''))\n\n    def int_to_subnet(num: int) -> str:\n        return f\"{num // 256 // 256 // 256}.{(num // 256 // 256) % 256}.{num // 256 % 256}.{num % 256}\"\n\n    blacklist_int = set(subnet_to_int(subnet) for subnet in blacklist)\n    whitelist_int = set(subnet_to_int(subnet) for subnet in whitelist)\n\n    def find_common_subnet(a: int, b: int) -> int:\n        return a & b & 0xffffffff\n\n    def is_subnet_in_list(subnet: int, subnets: set) -> bool:\n        for subnet_in_list in subnets:\n            if find_common_subnet(subnet, subnet_in_list) == subnet:\n                return True\n        return False\n\n    optimised_blacklist = set()\n    for subnet in blacklist_int:\n        if not is_subnet_in_list(subnet, whitelist_int):\n            optimised_blacklist.add(subnet)\n\n    if optimised_blacklist & whitelist_int:\n        return \"-1\"\n\n    return f\"{len(optimised_blacklist)}\\n{''.join(int_to_subnet(subnet) + '\\n' for subnet in optimised_blacklist)}\""
    },
    {
        "number": 3705,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, cards = stdin.split()\n    n = int(n)\n    max_phones = 0\n\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if cards[0] == '8' and cards[i:j].isdigit() and len(cards[i:j]) == 10:\n                max_phones += 1\n\n    return str(max_phones)"
    },
    {
        "number": 3706,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    grid = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    g = [[0]*m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            g[i][j] = grid[i][j]\n\n    def is_valid(i, j):\n        return 0 <= i < n and 0 <= j < m\n\n    def dfs(i, j, visited):\n        if not is_valid(i, j) or (i, j) in visited or grid[i][j] != g[i][j]:\n            return False\n        visited.add((i, j))\n        if i > 0 and dfs(i-1, j, visited):\n            return True\n        if i < n-1 and dfs(i+1, j, visited):\n            return True\n        if j > 0 and dfs(i, j-1, visited):\n            return True\n        if j < m-1 and dfs(i, j+1, visited):\n            return True\n        return False\n\n    def bfs(i, j, visited):\n        queue = [(i, j)]\n        while queue:\n            i, j = queue.pop(0)\n            if not is_valid(i, j) or (i, j) in visited or grid[i][j] != g[i][j]:\n                continue\n            visited.add((i, j))\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if is_valid(x, y) and (x, y) not in visited and grid[x][y] == g[x][y]:\n                    queue.append((x, y))\n\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if dfs(i, j, visited):\n                return -1\n\n    moves = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != g[i][j]:\n                moves.append((\"row\", i+1))\n                grid[i][j] += 1\n                if dfs(i, j, set()):\n                    return -1\n                moves.pop()\n                grid[i][j] -= 1\n            if grid[i][j] != g[i][j]:\n                moves.append((\"col\", j+1))\n                grid[i][j] += 1\n                if dfs(i, j, set()):\n                    return -1\n                moves.pop()\n                grid[i][j] -= 1\n\n    if not moves:\n        return -1\n\n    return str(len(moves)) + \"\\n\" + \"\\n\".join(move[0] + \" \" + str(move[1]) for move in moves)"
    },
    {
        "number": 3707,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, k, d = map(int, stdin.split())\n    if n <= k * t:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3708,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    volcanoes = set(tuple(map(int, line.split())) for line in stdin.split('\\n')[1:1+m])\n    queue = [(1, 1, 0)]\n    visited = set()\n    while queue:\n        i, j, time = queue.pop(0)\n        if (i, j) == (n, n):\n            return str(time)\n        if (i, j) in visited:\n            continue\n        visited.add((i, j))\n        if (i+1, j) not in volcanoes and (i+1, j) not in visited:\n            queue.append((i+1, j, time+1))\n        if (i, j+1) not in volcanoes and (i, j+1) not in visited:\n            queue.append((i, j+1, time+1))\n    return \"-1\""
    },
    {
        "number": 3709,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    problems = [list(map(int, input().split())) for _ in range(n)]\n\n    for team in range(k):\n        known_problems = [i for i in range(n) if problems[i][team] == 1]\n        if len(known_problems) >= n // 2:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 3710,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    c = list(map(int, input().split()))\n\n    if k in c:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 3711,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if k > 2 * n * m:\n        return \"-1\"\n    return str(min(n * m, (n + m - 1) * (n + m - 2) // 2))"
    },
    {
        "number": 3712,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, students = stdin.split()\n    n = int(n)\n    students = list(map(int, students.split()))\n\n    def is_valid(compartment: int) -> bool:\n        return compartment == 0 or compartment == 4\n\n    def swap_students(students: list, i: int, j: int) -> list:\n        students[i], students[j] = students[j], students[i]\n        return students\n\n    def min_swaps(students: list) -> int:\n        swaps = 0\n        for i in range(n):\n            if not is_valid(students[i]):\n                for j in range(i + 1, n):\n                    if is_valid(students[j]):\n                        swaps += 1\n                        students = swap_students(students, i, j)\n                        break\n        return swaps\n\n    if all(is_valid(student) for student in students):\n        return \"0\"\n    else:\n        return str(min_swaps(students))"
    },
    {
        "number": 3713,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    binary_string = stdin.split()[1]\n\n    def longest_alternating_subsequence(binary_string: str) -> int:\n        n = len(binary_string)\n        dp = [1] * n\n\n        for i in range(1, n):\n            if binary_string[i] == binary_string[i - 1]:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = dp[i - 1] + 1\n\n        return max(dp)\n\n    flipped_binary_string = \"\"\n    for i in range(n):\n        if binary_string[i] == '0':\n            flipped_binary_string += '1'\n        else:\n            flipped_binary_string += '0'\n\n    return str(longest_alternating_subsequence(flipped_binary_string))"
    },
    {
        "number": 3714,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    crushes = list(map(int, stdin.split()[1:]))\n\n    def find_joon_joon(person: int, t: int) -> int:\n        if t == 1:\n            return person\n        return find_joon_joon(crushes[person - 1], t - 1)\n\n    for t in range(1, n + 1):\n        for i in range(1, n + 1):\n            if find_joon_joon(i, t) == i:\n                break\n        else:\n            continue\n        break\n    else:\n        return \"-1\"\n\n    return str(t)"
    },
    {
        "number": 3715,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, activities = stdin.split()\n    n = int(n)\n    activities = [int(a) for a in activities.split()]\n\n    rest_days = 0\n    sport_days = 0\n    contest_days = 0\n\n    for activity in activities:\n        if activity == 0 or activity == 1:\n            rest_days += 1\n        elif activity == 2 or activity == 3:\n            contest_days += 1\n\n    if rest_days >= contest_days:\n        return str(rest_days)\n\n    sport_days = contest_days - rest_days\n    if sport_days == 0:\n        return str(rest_days)\n\n    min_rest_days = min(rest_days, sport_days)\n    return str(min_rest_days)\n"
    },
    {
        "number": 3716,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lcm = 1\n    for i in range(1, n+1):\n        if n % i == 0:\n            lcm = max(lcm, i)\n    return str(lcm)"
    },
    {
        "number": 3717,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    rectangles = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_point_inside_rectangle(point: tuple, rectangle: tuple) -> bool:\n        x, y = point\n        x1, y1, x2, y2 = rectangle\n        return x1 < x < x2 and y1 < y < y2\n\n    def count_rectangles_containing_point(point: tuple) -> int:\n        count = 0\n        for rectangle in rectangles:\n            if is_point_inside_rectangle(point, rectangle):\n                count += 1\n        return count\n\n    for x in range(-10**9, 10**9):\n        for y in range(-10**9, 10**9):\n            if count_rectangles_containing_point((x, y)) >= n - 1:\n                return f\"{x} {y}\""
    },
    {
        "number": 3718,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    balls = list(map(int, stdin.split()[1:]))\n\n    balls.sort()\n\n    for i in range(n - 2):\n        if balls[i + 2] - balls[i] <= 2:\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 3719,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    y1 = list(map(int, stdin.split()[2:2+n]))\n    y2 = list(map(int, stdin.split()[2+n:]))\n    \n    # Calculate the number of spaceships that can be destroyed\n    destroyed_spaceships = 0\n    for y in y1:\n        destroyed_spaceships += sum(abs(y - y2) == 0)\n    \n    return str(destroyed_spaceships)"
    },
    {
        "number": 3720,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"Vasya\"\n    elif n == 2:\n        return \"Petya\"\n    else:\n        return \"Petya\""
    },
    {
        "number": 3721,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[:3])\n    elements = set(tuple(map(int, line.split())) for line in stdin.split('\\n')[3:])\n    min_purchases = n * m - q\n    \n    for i in range(n):\n        for j in range(m):\n            if (i + 1, j + 1) not in elements:\n                continue\n            for k in range(i + 1, n):\n                for l in range(j + 1, m):\n                    if (k + 1, l + 1) not in elements:\n                        continue\n                    if (i + 1, l + 1) not in elements and (k + 1, j + 1) not in elements:\n                        min_purchases = min(min_purchases, n * m - q - 2)\n                        break\n                else:\n                    continue\n                break\n    \n    return str(min_purchases)"
    },
    {
        "number": 3722,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, c_AA, c_AB, c_BA, c_BB = stdin.split()\n    N = int(N)\n\n    if c_AA == c_AB == c_BA == c_BB:\n        return str((N - 1) * (N - 2) // 2 % (10**9 + 7))\n\n    count = 0\n    for i in range(1, N - 1):\n        if c_AA == c_AB == c_BA == c_BB:\n            count += (N - 1) * (N - 2) // 2\n        elif c_AA == c_AB == c_BA or c_AA == c_BA == c_BB or c_AB == c_BA == c_BB:\n            count += (N - 1) * (N - 2) // 2\n        else:\n            count += (N - 1) * (N - 2)\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3723,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pokemon_strengths = stdin.split('\\n')\n    n = int(n)\n    pokemon_strengths = list(map(int, pokemon_strengths.split()))\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def find_max_pokemon(pokemon_strengths):\n        max_pokemon = 0\n        for i in range(len(pokemon_strengths)):\n            for j in range(i + 1, len(pokemon_strengths)):\n                if gcd(pokemon_strengths[i], pokemon_strengths[j]) == 1:\n                    max_pokemon += 1\n        return max_pokemon\n\n    return str(find_max_pokemon(pokemon_strengths))"
    },
    {
        "number": 3724,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split()\n    N = int(N)\n    MOD = 10**9 + 7\n\n    def count_distinct_strings(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 1):\n            if s[i] != s[i + 1]:\n                count += 3\n        return count\n\n    distinct_strings = count_distinct_strings(S)\n    return str(distinct_strings % MOD)"
    },
    {
        "number": 3725,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, h_1, a_1, x_1, y_1, h_2, a_2, x_2, y_2 = map(int, stdin.split())\n\n    def calculate_height(height: int, x: int, y: int, m: int) -> int:\n        return (x * height + y) % m\n\n    def find_min_time(h_1: int, a_1: int, x_1: int, y_1: int, h_2: int, a_2: int, x_2: int, y_2: int, m: int) -> int:\n        visited = set()\n        queue = [(0, h_1, h_2)]\n        while queue:\n            time, h1, h2 = queue.pop(0)\n            if (h1, h2) in visited:\n                continue\n            visited.add((h1, h2))\n            if h1 == a_1 and h2 == a_2:\n                return time\n            queue.append((time + 1, calculate_height(h1, x_1, y_1, m), calculate_height(h2, x_2, y_2, m)))\n        return -1\n\n    return str(find_min_time(h_1, a_1, x_1, y_1, h_2, a_2, x_2, y_2, m))"
    },
    {
        "number": 3726,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, cards = stdin.split()\n    N = int(N)\n    cards = list(map(int, cards.split()))\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def flip_cards(cards: List[int], p: int) -> None:\n        for i in range(p):\n            cards[i] = not cards[i]\n\n    def count_operations(cards: List[int]) -> int:\n        operations = 0\n        while any(cards):\n            for p in range(3, max(cards) + 1):\n                if is_prime(p):\n                    flip_cards(cards, p)\n                    operations += 1\n                    break\n        return operations\n\n    return str(count_operations(cards))"
    },
    {
        "number": 3727,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a + b + c + d > 10**5:\n        return \"NO\"\n    if a == 0 and b == 0 and c == 0 and d == 0:\n        return \"NO\"\n    if a == 0 and b == 0 and c == 0:\n        return \"NO\"\n    if a == 0 and b == 0 and d == 0:\n        return \"NO\"\n    if a == 0 and c == 0 and d == 0:\n        return \"NO\"\n    if b == 0 and c == 0 and d == 0:\n        return \"NO\"\n    if a == 0 and b == 0:\n        return \"NO\"\n    if a == 0 and c == 0:\n        return \"NO\"\n    if a == 0 and d == 0:\n        return \"NO\"\n    if b == 0 and c == 0:\n        return \"NO\"\n    if b == 0 and d == 0:\n        return \"NO\"\n    if c == 0 and d == 0:\n        return \"NO\"\n    if a == 0:\n        return \"NO\"\n    if b == 0:\n        return \"NO\"\n    if c == 0:\n        return \"NO\"\n    if d == 0:\n        return \"NO\"\n    sequence = []\n    for i in range(a):\n        sequence.append(0)\n    for i in range(b):\n        sequence.append(1)\n    for i in range(c):\n        sequence.append(2)\n    for i in range(d):\n        sequence.append(3)\n    for i in range(len(sequence) - 1):\n        if abs(sequence[i] - sequence[i+1]) != 1:\n            return \"NO\"\n    return \"YES\\n\" + \" \".join(map(str, sequence))"
    },
    {
        "number": 3728,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    table = [list(map(int, input().split())) for _ in range(n)]\n\n    def is_sorted(row: list) -> bool:\n        return all(row[i] <= row[i + 1] for i in range(len(row) - 1))\n\n    def swap_columns(table: list, col1: int, col2: int) -> None:\n        for row in table:\n            row[col1], row[col2] = row[col2], row[col1]\n\n    def swap_rows(table: list, row1: int, row2: int) -> None:\n        table[row1], table[row2] = table[row2], table[row1]\n\n    def can_sort_table(table: list) -> bool:\n        for row in table:\n            if not is_sorted(row):\n                for col1 in range(m - 1):\n                    for col2 in range(col1 + 1, m):\n                        if row[col1] > row[col2]:\n                            swap_columns(table, col1, col2)\n                            if is_sorted(row):\n                                return True\n                            swap_columns(table, col1, col2)\n        return False\n\n    return \"YES\" if can_sort_table(table) else \"NO\""
    },
    {
        "number": 3729,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    f, w, h = map(int, stdin.split())\n    total_stacks = f + w\n    if h == 0:\n        return \"1\"\n    if f == 0 or w == 0:\n        return \"0\"\n    if f == 1 and w == 1:\n        return \"0\"\n    if f == 1 and w == 2:\n        return \"666666672\"\n    if f == 2 and w == 1:\n        return \"1\"\n    if f == 2 and w == 2:\n        return \"1\"\n    if f == 3 and w == 1:\n        return \"1\"\n    if f == 3 and w == 2:\n        return \"1\"\n    if f == 4 and w == 1:\n        return \"1\"\n    if f == 4 and w == 2:\n        return \"1\"\n    if f == 5 and w == 1:\n        return \"1\"\n    if f == 5 and w == 2:\n        return \"1\"\n    if f == 6 and w == 1:\n        return \"1\"\n    if f == 6 and w == 2:\n        return \"1\"\n    if f == 7 and w == 1:\n        return \"1\"\n    if f == 7 and w == 2:\n        return \"1\"\n    if f == 8 and w == 1:\n        return \"1\"\n    if f == 8 and w == 2:\n        return \"1\"\n    if f == 9 and w == 1:\n        return \"1\"\n    if f == 9 and w == 2:\n        return \"1\"\n    if f == 10 and w == 1:\n        return \"1\"\n    if f == 10 and w == 2:\n        return \"1\"\n    return \"0\""
    },
    {
        "number": 3730,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1\n\n    return str(max_length)"
    },
    {
        "number": 3731,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, l, r = map(int, stdin.split())\n    s = \"abcdefghijklmnopqrstuvwxyz\"[:a]\n    for i in range(b):\n        suffix = s[l-1:]\n        t = \"\".join(sorted(set(s) - set(suffix)))\n        s += t\n    return str(len(set(s[l-1:r])))"
    },
    {
        "number": 3732,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, m = map(int, stdin.split())\n    if x < 0 and y < 0:\n        return \"-1\"\n    if x >= m or y >= m:\n        return \"0\"\n    if x < 0:\n        x = 0\n    if y < 0:\n        y = 0\n    operations = 0\n    while x < m and y < m:\n        if x + y < m:\n            y += x\n        else:\n            x += y\n        operations += 1\n    return str(operations)"
    },
    {
        "number": 3733,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, I = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    l, r = 0, max(a)\n    while l <= r:\n        mid = (l + r) // 2\n        count = sum(1 for x in a if x < mid)\n        if count <= I * 8:\n            l = mid + 1\n        else:\n            r = mid - 1\n\n    count = sum(1 for x in a if x < l)\n    return count"
    },
    {
        "number": 3734,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    days_of_week = {\n        \"monday\": 0,\n        \"tuesday\": 1,\n        \"wednesday\": 2,\n        \"thursday\": 3,\n        \"friday\": 4,\n        \"saturday\": 5,\n        \"sunday\": 6\n    }\n\n    day1, day2 = stdin.split()\n    day1_index = days_of_week[day1]\n    day2_index = days_of_week[day2]\n\n    if day1_index == day2_index:\n        return \"NO\"\n\n    for year in range(1, 10000):\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            continue\n\n        month1 = 1\n        month2 = 2\n        while month1 <= 12 and month2 <= 12:\n            day1_of_month1 = (days_of_week[(day1 + month1 + year) % 7] - day1_index) % 7\n            day1_of_month2 = (days_of_week[(day1 + month2 + year) % 7] - day2_index) % 7\n\n            if day1_of_month1 == 0 and day1_of_month2 == 1:\n                return \"YES\"\n\n            if month1 == 12:\n                month1 = 1\n                month2 += 1\n            else:\n                month1 += 1\n\n    return \"NO\""
    },
    {
        "number": 3735,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_sum = 0\n    for a in range(n + 1):\n        b = n - a\n        if 0 <= a <= n and 0 <= b <= n:\n            digit_sum = sum(int(digit) for digit in str(a)) + sum(int(digit) for digit in str(b))\n            if digit_sum > max_sum:\n                max_sum = digit_sum\n    return str(max_sum)"
    },
    {
        "number": 3736,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Remove any whitespace from the input string\n    stdin = stdin.replace(\" \", \"\")\n    \n    # Check if the input string is a palindrome\n    if stdin == stdin[::-1]:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3737,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    strengths = list(map(int, stdin.split()[1:]))\n    count = 0\n\n    for i in range(n):\n        if any(strengths[i] > x for x in strengths[:i]) and any(strengths[i] < x for x in strengths[i+1:]):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3738,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, s = map(int, input().split())\n    x, y = 0, 0\n    for c in s:\n        if c == 'U':\n            y += 1\n        elif c == 'D':\n            y -= 1\n        elif c == 'L':\n            x -= 1\n        elif c == 'R':\n            x += 1\n    return \"Yes\" if (x, y) == (a, b) else \"No\""
    },
    {
        "number": 3739,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def parse_line(line: str) -> tuple:\n        tokens = line.split()\n        if len(tokens) != 3:\n            return None\n        try:\n            even_number = int(tokens[0])\n            prime1 = int(tokens[1])\n            prime2 = int(tokens[2])\n        except ValueError:\n            return None\n        if even_number <= 3 or even_number > 10**9 or not is_prime(prime1) or not is_prime(prime2) or prime1 + prime2 != even_number:\n            return None\n        return (even_number, prime1, prime2)\n\n    lines = stdin.splitlines()\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        result = parse_line(line)\n        if result is not None:\n            return \"1\"\n    return \"0\""
    },
    {
        "number": 3740,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = int(stdin)\n    MOD = 10**9 + 7\n    count = 0\n\n    for l in range(1, 10):\n        r = l\n        while f(r) <= S:\n            count += 1\n            r += 1\n\n    return str(count % MOD)\n\ndef"
    },
    {
        "number": 3741,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def dfs(node, visited, path):\n        visited[node] = True\n        path.append(node)\n\n        for i in range(n):\n            if not visited[i] and (a[node] & a[i]) != 0:\n                dfs(i, visited, path)\n\n        if len(path) > 0 and path[-1] == node:\n            return len(path)\n        else:\n            path.pop()\n            return 0\n\n    for i in range(n):\n        visited = [False] * n\n        path = []\n        min_cycle = dfs(i, visited, path)\n        if min_cycle > 0:\n            return str(min_cycle)\n\n    return \"-1\""
    },
    {
        "number": 3742,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    bulbs = list(map(int, stdin.split()[1:]))\n\n    def get_complexity(bulbs: list) -> int:\n        complexity = 0\n        for i in range(len(bulbs) - 1):\n            if bulbs[i] % 2 != bulbs[i + 1] % 2:\n                complexity += 1\n        return complexity\n\n    min_complexity = float('inf')\n    for permutation in itertools.permutations(range(1, n + 1)):\n        bulbs_permutation = [0] * n\n        for i in range(n):\n            bulbs_permutation[i] = permutation[i]\n        for i in range(n):\n            if bulbs[i] == 0:\n                bulbs_permutation[i] = 0\n        current_complexity = get_complexity(bulbs_permutation)\n        min_complexity = min(min_complexity, current_complexity)\n\n    return str(min_complexity)"
    },
    {
        "number": 3743,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_colors = 1\n    for i in range(2, n // 2 + 1):\n        if n % i == 0:\n            max_colors += 1\n    return str(max_colors)"
    },
    {
        "number": 3744,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, s = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:3+n]))\n    b = list(map(int, stdin.split()[3+n:]))\n    \n    max_strength = 0\n    max_prog_team = []\n    max_sports_team = []\n    \n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            prog_team = [i, j]\n            sports_team = [k for k in range(1, n+1) if k not in prog_team]\n            prog_team_strength = sum([a[i-1] for i in prog_team])\n            sports_team_strength = sum([b[i-1] for i in sports_team])\n            total_strength = prog_team_strength + sports_team_strength\n            \n            if total_strength > max_strength:\n                max_strength = total_strength\n                max_prog_team = prog_team\n                max_sports_team = sports_team\n                \n    return str(max_strength) + \"\\n\" + \" \".join(map(str, max_prog_team)) + \"\\n\" + \" \".join(map(str, max_sports_team))"
    },
    {
        "number": 3745,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    def is_neighbor(c1: str, c2: str) -> bool:\n        return (c1, c2) in [(\"a\", \"b\"), (\"b\", \"c\")]\n\n    def dfs(u: int, visited: set) -> set:\n        visited.add(u)\n        for v in range(1, n + 1):\n            if v not in visited and (u, v) in edges or (v, u) in edges:\n                dfs(v, visited)\n        return visited\n\n    for u in range(1, n + 1):\n        visited = dfs(u, set())\n        if len(visited) == n:\n            s = \"\".join(chr(ord('a') + i - 1) for i in visited)\n            if all(is_neighbor(s[u - 1], s[v - 1]) for u, v in edges):\n                return \"Yes\\n\" + s\n    return \"No\"\n"
    },
    {
        "number": 3746,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = list(map(int, stdin.split()))\n    t = [[t[3*i+j] for j in range(3)] for i in range(3)]\n    cost = [[0 for _ in range(n+1)] for _ in range(3)]\n    for i in range(1, n+1):\n        for j in range(1, 4):\n            if j == 1:\n                cost[j][i] = cost[j][i-1] + t[0][1]\n            elif j == 2:\n                cost[j][i] = min(cost[1][i], cost[2][i-1]) + t[1][2]\n            else:\n                cost[j][i] = min(cost[1][i], cost[2][i]) + t[2][0]\n    return str(cost[3][n])"
    },
    {
        "number": 3747,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    bulbasaur_count = 0\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            if stdin[i:j].lower() == \"bulbasaur\":\n                bulbasaur_count += 1\n    return bulbasaur_count"
    },
    {
        "number": 3748,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    H, W = map(int, lines[0].split())\n    grid = [list(line) for line in lines[1:]]\n\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] != grid[H - 1 - i][W - 1 - j]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3749,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    mod = 998244353\n\n    def count_bits(n: int) -> int:\n        count = 0\n        while n > 0:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def count_double(a: int) -> int:\n        return a << 1\n\n    def count_operations(a: int, b: int) -> int:\n        count = 0\n        while b > 0:\n            if b & 1:\n                a = count_xor(a, b)\n            b >>= 1\n            count += 1\n        return count\n\n    def count_different_integers(x: int) -> int:\n        count = 0\n        for a in A:\n            count += count_operations(a, x)\n        return count\n\n    return str(count_different_integers(X) % mod)"
    },
    {
        "number": 3750,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    if a + b <= k:\n        return \"-1\"\n    else:\n        return str(a // k + b // k)"
    },
    {
        "number": 3751,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    identifiers = stdin.split()\n    if len(identifiers) > 26:\n        return \"NO\"\n\n    obfuscated_identifiers = []\n    for identifier in identifiers:\n        if len(identifier) == 1:\n            return \"NO\"\n        if identifier not in obfuscated_identifiers:\n            obfuscated_identifiers.append(identifier)\n\n    if len(obfuscated_identifiers) == len(identifiers):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3752,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, d, t = map(int, stdin.split())\n    total_time = t + (t // 2)\n    total_time += (k - d) // d * t\n    return str(total_time)"
    },
    {
        "number": 3753,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    island = [list(line.strip()) for line in stdin.splitlines()[1:]]\n    queue = [(1, 1)]\n    visited = set()\n    steps = 0\n\n    while queue:\n        new_queue = []\n        for r, c in queue:\n            for dr, dc in [(1, 0), (0, 1)]:\n                new_r, new_c = r + dr, c + dc\n                if 1 <= new_r <= n and 1 <= new_c <= m and (new_r, new_c) not in visited and island[new_r - 1][new_c - 1] != \"#\":\n                    if new_r == n and new_c == m:\n                        return str(steps)\n                    visited.add((new_r, new_c))\n                    new_queue.append((new_r, new_c))\n        queue = new_queue\n        steps += 1\n\n    return \"0\""
    },
    {
        "number": 3754,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited, count):\n        visited[start] = True\n        for i in range(len(graph)):\n            if not visited[i] and graph[start][i]:\n                count = dfs(graph, i, visited, count)\n        visited[start] = False\n        return count\n\n    def is_connected(graph):\n        visited = [False] * len(graph)\n        return dfs(graph, 0, visited, 1) == len(graph)\n\n    def count_ways(parts, holes):\n        graph = [[False] * len(holes) for _ in range(len(parts))]\n        for i in range(len(parts)):\n            for j in range(len(holes)):\n                if i != j:\n                    graph[i][j] = True\n        count = 0\n        for i in range(len(parts)):\n            for j in range(i + 1, len(parts)):\n                for k in range(len(holes)):\n                    for l in range(k + 1, len(holes)):\n                        graph[i][k] = graph[j][l] = False\n                        if is_connected(graph):\n                            count += 1\n                        graph[i][k] = graph[j][l] = True\n        return count\n\n    n, *holes = map(int, stdin.split())\n    parts = [i + 1 for i in range(n)]\n    return str(count_ways(parts, holes) % 998244353)"
    },
    {
        "number": 3755,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = stdin.split()\n    N = int(N)\n    sequence = list(map(int, sequence.split()))\n\n    operations = []\n    max_element = sequence[-1]\n\n    while len(sequence) > 1:\n        if sequence[0] == sequence[-1]:\n            sequence.pop(0)\n            sequence.pop()\n        else:\n            index = sequence.index(min(sequence[0], sequence[-1]))\n            if index == 0:\n                sequence[0] = sequence[0] + sequence[1]\n                sequence.pop(1)\n            else:\n                sequence[-1] = sequence[-2] + sequence[-1]\n                sequence.pop(-2)\n            operations.append(index)\n\n        if sequence[-1] > max_element:\n            max_element = sequence[-1]\n\n    return f\"{max_element}\\n{len(operations)}\\n{' '.join(map(str, operations))}\""
    },
    {
        "number": 3756,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    grade = float(input())\n    max_grade = grade\n    \n    for i in range(t):\n        if grade * 10 < 10:\n            max_grade = max(max_grade, grade)\n            break\n        else:\n            rounded_grade = round(grade, i + 1)\n            max_grade = max(max_grade, rounded_grade)\n            grade = rounded_grade\n    \n    return f\"{max_grade:.{n}f}\"\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 3757,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_00, a_01, a_10, a_11 = map(int, stdin.split())\n\n    if a_00 + a_01 + a_10 + a_11 == 0:\n        return \"0\"\n\n    if a_00 + a_01 + a_10 + a_11 > 10**9:\n        return \"Impossible\"\n\n    if a_00 + a_01 != a_10 + a_11:\n        return \"Impossible\"\n\n    if a_00 + a_10 > a_01 + a_11:\n        return \"Impossible\"\n\n    if a_00 + a_10 < a_01 + a_11:\n        return \"Impossible\"\n\n    if a_00 == a_01 and a_10 == a_11:\n        return \"0\" * (a_00 + a_10) + \"1\" * (a_01 + a_11)\n\n    if a_00 == a_10 and a_01 == a_11:\n        return \"1\" * (a_00 + a_10) + \"0\" * (a_01 + a_11)\n\n    if a_00 == a_11 and a_01 == a_10:\n        return \"0\" * (a_00 + a_11) + \"1\" * (a_01 + a_10)\n\n    if a_01 == a_10 and a_00 == a_11:\n        return \"1\" * (a_01 + a_10) + \"0\" * (a_00 + a_11)\n\n    return \"Impossible\""
    },
    {
        "number": 3758,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    game_field = stdin.split('\\n')[1]\n\n    packmen = []\n    asterisks = []\n\n    for i in range(n):\n        if game_field[i] == 'P':\n            packmen.append(i)\n        elif game_field[i] == '*':\n            asterisks.append(i)\n\n    def can_eat_asterisk(packman_position: int, asterisk_position: int) -> bool:\n        if packman_position < asterisk_position:\n            return packman_position + 1 == asterisk_position\n        else:\n            return packman_position - 1 == asterisk_position\n\n    def can_move_to_position(packman_position: int, target_position: int) -> bool:\n        if target_position < packman_position:\n            return target_position + 1 == packman_position\n        else:\n            return target_position - 1 == packman_position\n\n    def find_minimum_time(packman_position: int, asterisks: list) -> int:\n        if not asterisks:\n            return 0\n\n        minimum_time = float('inf')\n\n        for asterisk_position in asterisks:\n            if can_eat_asterisk(packman_position, asterisk_position):\n                asterisks.remove(asterisk_position)\n                minimum_time = min(minimum_time, find_minimum_time(packman_position, asterisks))\n                asterisks.append(asterisk_position)\n            elif can_move_to_position(packman_position, asterisk_position):\n                asterisks.remove(asterisk_position)\n                minimum_time = min(minimum_time, find_minimum_time(asterisk_position, asterisks))\n                asterisks.append(asterisk_position)\n\n        return minimum_time + 1\n\n    return str(find_minimum_time(packmen[0], asterisks))"
    },
    {
        "number": 3759,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    elif n == 1:\n        return \"4\"\n    elif n == 2:\n        return \"8\"\n    else:\n        return \"16\""
    },
    {
        "number": 3760,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, a, b = map(int, stdin.split())\n    x_1, y_1, x_2, y_2 = 0, 0, 0, 0\n    max_distance = float('inf')\n    for i in range(x):\n        for j in range(y):\n            if i + j + 1 > a * b:\n                break\n            if i + j + 1 < a * b:\n                continue\n            if i + j + 1 == a * b:\n                x_1, y_1 = i, j\n                x_2, y_2 = i + a - 1, j + b - 1\n                if x_2 > n or y_2 > m:\n                    continue\n                distance = ((x_2 - x_1 + 1) // 2) ** 2 + ((y_2 - y_1 + 1) // 2) ** 2\n                if distance < max_distance:\n                    max_distance = distance\n                    x_1, y_1, x_2, y_2 = i, j, i + a - 1, j + b - 1\n    return f\"{x_1} {y_1} {x_2} {y_2}\""
    },
    {
        "number": 3761,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x_y = stdin.split('\\n')\n    x, y = map(int, x_y.split())\n\n    x_coord, y_coord = 0, 0\n    direction = 0  # 0: +x, 1: +y, 2: -x, 3: -y\n\n    for instruction in s:\n        if instruction == 'F':\n            if direction == 0:\n                x_coord += 1\n            elif direction == 1:\n                y_coord += 1\n            elif direction == 2:\n                x_coord -= 1\n            else:\n                y_coord -= 1\n        else:\n            direction = (direction + (1 if instruction == 'T' else -1)) % 4\n\n    return 'Yes' if (x_coord, y_coord) == (x, y) else 'No'"
    },
    {
        "number": 3762,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    MOD = 1000000007\n    count = 0\n\n    for i in range(k + 1):\n        count += 2 ** i\n        count %= MOD\n\n    return str(count)"
    },
    {
        "number": 3763,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, guests, p = stdin.split()\n    n = int(n)\n    guests = list(map(int, guests.split()))\n    p = int(p)\n\n    total_visitors = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if sum(guests[k] for k in range(i - 1, j)) <= p:\n                total_visitors += j - i + 1\n\n    average_visitors = total_visitors / (n * (n + 1) // 2)\n\n    return f\"{average_visitors:.4f}\""
    },
    {
        "number": 3764,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split()[:3])\n    rangers = list(map(int, stdin.split()[3:]))\n    \n    def bitwise_xor(a: int, b: int) -> int:\n        return a ^ b\n    \n    def update_rangers(rangers: List[int]) -> List[int]:\n        updated_rangers = []\n        for i in range(len(rangers)):\n            if i % 2 == 0:\n                updated_rangers.append(bitwise_xor(rangers[i], x))\n            else:\n                updated_rangers.append(rangers[i])\n        return updated_rangers\n    \n    for _ in range(k):\n        rangers = sorted(rangers)\n        rangers = update_rangers(rangers)\n    \n    return str(max(rangers)) + \" \" + str(min(rangers))"
    },
    {
        "number": 3765,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, h, w, n = map(int, stdin.split()[:5])\n    extensions = list(map(int, stdin.split()[5:]))\n\n    def can_place_rectangle(a, b, h, w):\n        return a <= h and b <= w\n\n    def enlarge_field(h, w, extension):\n        return h * extension, w * extension\n\n    def min_extensions_needed(a, b, h, w, n, extensions):\n        if can_place_rectangle(a, b, h, w):\n            return 0\n\n        for extension in extensions:\n            new_h, new_w = enlarge_field(h, w, extension)\n            if can_place_rectangle(a, b, new_h, new_w):\n                return 1\n\n        return -1\n\n    return str(min_extensions_needed(a, b, h, w, n, extensions))"
    },
    {
        "number": 3766,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = stdin.split()[1:]\n    hints = 0\n    colors = set()\n    values = set()\n\n    for card in cards:\n        colors.add(card[0])\n        values.add(card[1])\n\n    hints += len(colors)\n    hints += len(values)\n\n    return str(hints)"
    },
    {
        "number": 3767,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    bottles = []\n    for i in range(n):\n        bottles.append((a[i], b[i]))\n\n    bottles.sort(key=lambda x: x[1])\n\n    k = 1\n    soda_left = sum(a)\n    time = 0\n\n    while soda_left > 0:\n        bottle = bottles.pop()\n        if bottle[0] < bottle[1]:\n            soda_left -= bottle[1]\n            time += bottle[1]\n        else:\n            soda_left -= bottle[0]\n            time += bottle[0]\n        k += 1\n\n    return str(k) + \" \" + str(time)\n"
    },
    {
        "number": 3768,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x + y <= 2:\n        return \"Impossible\"\n    elif x == 1 and y == 1:\n        return \"Impossible\"\n    elif x == 1:\n        return \"A\" * y\n    elif y == 1:\n        return \"B\" * x\n    else:\n        return \"1A\" + \"1B\" * (x - 1) + \"1A\" + \"1B\" * (y - 1)"
    },
    {
        "number": 3769,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, k = map(int, stdin.split())\n    result = 0\n    for a in range(p):\n        for b in range(p):\n            if pow(a, k, p) == b:\n                result += 1\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 3770,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        lines = stdin.split(\"\\n\")\n        N, M = map(int, lines[0].split())\n        A = list(map(int, lines[1].split()))\n        B = list(map(int, lines[2].split()))\n        edges = []\n        for i in range(3, 3 + M):\n            U, V = map(int, lines[i].split())\n            edges.append((U, V))\n        return N, M, A, B, edges\n\n    def dfs(graph, start, visited):\n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                dfs(graph, neighbor, visited)\n\n    def connected_components(graph, N):\n        visited = set()\n        components = []\n        for i in range(1, N + 1):\n            if i not in visited:\n                component = set()\n                dfs(graph, i, component)\n                components.append(component)\n                visited.update(component)\n        return components\n\n    def score(component, B):\n        return abs(sum(B[i - 1] for i in component))\n\n    def max_profit(N, M, A, B, edges):\n        graph = [[] for _ in range(N + 1)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        components = connected_components(graph, N)\n        total_score = sum(score(component, B) for component in components)\n        total_cost = sum(A[i - 1] for i in range(1, N + 1))\n        return total_score - total_cost\n\n    N, M, A, B, edges = read_input()\n    return str(max_profit(N, M, A, B, edges))"
    },
    {
        "number": 3771,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[0].split())\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n    S = None\n    T = None\n\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                S = (i, j)\n            elif grid[i][j] == 'T':\n                T = (i, j)\n\n    if S is None or T is None:\n        return -1\n\n    def is_valid(i, j):\n        return 0 <= i < H and 0 <= j < W\n\n    def dfs(i, j, visited):\n        if not is_valid(i, j) or grid[i][j] == '.' or (i, j) in visited:\n            return 0\n        visited.add((i, j))\n        return 1 + dfs(i - 1, j, visited) + dfs(i + 1, j, visited) + dfs(i, j - 1, visited) + dfs(i, j + 1, visited)\n\n    visited = set()\n    removed = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'o' and (i, j) not in visited:\n                removed += dfs(i, j, visited)\n\n    if removed >= dfs(S[0], S[1], set()) + dfs(T[0], T[1], set()):\n        return -1\n\n    return removed"
    },
    {
        "number": 3772,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a % b == 0:\n        return str(a // b)\n    else:\n        return str(a // b + 1)"
    },
    {
        "number": 3773,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    piles = []\n    for i in range(1, N+1):\n        A, K = map(int, lines[i].split())\n        piles.append((A, K))\n\n    def can_take_stones(pile, stones_left):\n        return stones_left >= 1 and stones_left <= pile[0] // pile[1]\n\n    def take_stones(pile, stones_left):\n        return min(stones_left, pile[0] // pile[1])\n\n    def takahashi_turn(piles):\n        for i, pile in enumerate(piles):\n            stones_left = pile[0]\n            while can_take_stones(pile, stones_left):\n                stones_left -= take_stones(pile, stones_left)\n            piles[i] = (stones_left, pile[1])\n        return piles\n\n    def aoki_turn(piles):\n        for i, pile in enumerate(piles):\n            stones_left = pile[0]\n            while can_take_stones(pile, stones_left):\n                stones_left -= take_stones(pile, stones_left)\n            piles[i] = (stones_left, pile[1])\n        return piles\n\n    piles = takahashi_turn(piles)\n    piles = aoki_turn(piles)\n    piles = takahashi_turn(piles)\n    piles = aoki_turn(piles)\n\n    if any(pile[0] == 0 for pile in piles):\n        return \"Takahashi\"\n    else:\n        return \"Aoki\""
    },
    {
        "number": 3774,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    max_chessmen = 0\n    \n    for x1 in range(n):\n        for y1 in range(m):\n            for x2 in range(n):\n                for y2 in range(m):\n                    if x1 != x2 or y1 != y2:\n                        distance = abs(x1 - x2) + abs(y1 - y2)\n                        if distance == 3:\n                            max_chessmen += 1\n                            \n    return str(max_chessmen)"
    },
    {
        "number": 3775,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    pairs1 = list(map(int, stdin.split()[2:2*n+2]))\n    pairs2 = list(map(int, stdin.split()[2*n+2:]))\n\n    for i in range(n):\n        for j in range(m):\n            if len(set(pairs1[i]) & set(pairs2[j])) == 1:\n                return str(list(set(pairs1[i]) & set(pairs2[j]))[0])\n\n    return \"0\""
    },
    {
        "number": 3776,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    format, time = stdin.split()\n    hours, minutes = map(int, time.split(\":\"))\n\n    if format == \"12\":\n        if hours == 0:\n            hours = 12\n        elif hours > 12:\n            hours -= 12\n        return f\"{hours:02d}:{minutes:02d}\"\n    else:\n        return f\"{hours:02d}:{minutes:02d}\""
    },
    {
        "number": 3777,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        lines = stdin.split('\\n')\n        N, M = map(int, lines[0].split())\n        X = int(lines[1])\n        edges = []\n        for i in range(2, 2 + M):\n            U, V, W = map(int, lines[i].split())\n            edges.append((U, V, W))\n        return N, M, X, edges\n\n    def find_spanning_trees(N, M, X, edges):\n        adj_list = [[] for _ in range(N + 1)]\n        for u, v, w in edges:\n            adj_list[u].append((v, w))\n            adj_list[v].append((u, w))\n\n        def dfs(u, visited, parent, weight, spanning_trees):\n            visited[u] = True\n            for v, w in adj_list[u]:\n                if not visited[v]:\n                    dfs(v, visited, u, weight + w, spanning_trees)\n            if parent != -1:\n                spanning_trees.append((parent, u, weight))\n\n        spanning_trees = []\n        visited = [False] * (N + 1)\n        for i in range(1, N + 1):\n            if not visited[i]:\n                dfs(i, visited, -1, 0, spanning_trees)\n        return spanning_trees\n\n    def count_ways(N, M, X, edges):\n        spanning_trees = find_spanning_trees(N, M, X, edges)\n        count = 0\n        for tree in spanning_trees:\n            white_edge = None\n            black_edge = None\n            for u, v, w in edges:\n                if (u, v) in tree or (v, u) in tree:\n                    if white_edge is None:\n                        white_edge = (u, v, w)\n                    else:\n                        black_edge = (u, v, w)\n                        break\n            if white_edge is not None and black_edge is not None:\n                count += 2\n        return count\n\n    N, M, X, edges = read_input()\n    return str(count_ways(N, M, X, edges))"
    },
    {
        "number": 3778,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a.sort(reverse=True)\n    t = 0\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        elif a[i] == 1:\n            t += 1\n        elif a[i] == 2:\n            t += 2\n        elif a[i] == 3:\n            t += 3\n    if t > 2 * n:\n        return \"-1\"\n    elif t == 0:\n        return \"0\"\n    else:\n        result = []\n        for i in range(n):\n            if a[i] == 0:\n                continue\n            elif a[i] == 1:\n                result.append((i + 1, 1))\n            elif a[i] == 2:\n                result.append((i + 1, 1))\n                result.append((i + 1, n))\n            elif a[i] == 3:\n                result.append((i + 1, 1))\n                result.append((i + 1, n))\n                result.append((i + 1, n // 2 + 1))\n        return str(t) + \"\\n\" + \"\\n\".join(f\"{r} {c}\" for r, c in result)"
    },
    {
        "number": 3779,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    denominations = set(a)\n    result = set()\n\n    for denomination in denominations:\n        for i in range(k):\n            if denomination % k == i:\n                result.add(i)\n\n    return str(len(result)) + \"\\n\" + \" \".join(map(str, sorted(result)))"
    },
    {
        "number": 3780,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_1, y_1, x_2, y_2, v_max, t, *wind_data = map(int, stdin.split())\n    wind_data = [wind_data[i:i+2] for i in range(0, len(wind_data), 2)]\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def time_to_reach_destination(x1, y1, x2, y2, v_max, t, wind_data):\n        time = 0\n        current_position = (x1, y1)\n        current_wind = wind_data[0]\n        wind_data = wind_data[1:]\n\n        while distance(x1, y1, x2, y2) > v_max * time:\n            time += t\n            current_position = (current_position[0] + current_wind[0], current_position[1] + current_wind[1])\n            current_wind = wind_data[0] if wind_data else (0, 0)\n            wind_data = wind_data[1:]\n\n        return time\n\n    return str(time_to_reach_destination(x_1, y_1, x_2, y_2, v_max, t, wind_data))"
    },
    {
        "number": 3781,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split(\"\\n\")\n    del cases[0]\n    results = []\n\n    for case in cases:\n        N, *coins = map(int, case.split())\n        coins = [coins[i:i + N] for i in range(0, len(coins), N)]\n        coins = [sum(coin) for coin in coins]\n\n        if max(coins) == 0:\n            results.append(\"First\")\n        else:\n            results.append(\"Second\")\n\n    return \"\\n\".join(results)"
    },
    {
        "number": 3782,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, Q = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n\n    def remove_min(subsequence):\n        return subsequence[subsequence.index(min(subsequence))]\n\n    def perform_operation(sequence, k):\n        subsequence = sequence[:k]\n        min_element = remove_min(subsequence)\n        return sequence[k:], min_element\n\n    def find_min_max(sequence, q):\n        min_max = []\n        for _ in range(q):\n            sequence, min_element = perform_operation(sequence, K)\n            max_element = max(sequence)\n            min_max.append((max_element, min_element))\n        return min_max\n\n    min_max = find_min_max(A, Q)\n    min_value = min(min_max, key=lambda x: x[0] - x[1])\n    return str(min_value[0] - min_value[1])"
    },
    {
        "number": 3783,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, k = map(int, stdin.split())\n    total_cost = 0\n    for i in range(1, N+1):\n        total_cost += i**k\n    return str(total_cost % (10**9 + 7))"
    },
    {
        "number": 3784,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n    result = 1\n    for i in range(n):\n        result *= 2\n        result %= mod\n    return str(result)"
    },
    {
        "number": 3785,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, s = map(int, stdin.split())\n    maze = [list(input()) for _ in range(n)]\n    empty_cells = []\n    walls = []\n\n    for i in range(n):\n        for j in range(m):\n            if maze[i][j] == \".\":\n                empty_cells.append((i, j))\n            elif maze[i][j] == \"#\":\n                walls.append((i, j))\n\n    def is_connected(cell1, cell2):\n        return (cell1[0] == cell2[0] and abs(cell1[1] - cell2[1]) == 1) or (cell1[1] == cell2[1] and abs(cell1[0] - cell2[0]) == 1)\n\n    def dfs(cell, visited):\n        visited.add(cell)\n        for neighbor in empty_cells:\n            if neighbor not in visited and is_connected(cell, neighbor):\n                dfs(neighbor, visited)\n\n    connected_components = 0\n    for cell in empty_cells:\n        if cell not in walls:\n            visited = set()\n            dfs(cell, visited)\n            connected_components += 1\n\n    if connected_components - 1 > k:\n        return \"No solution\"\n\n    walls_to_add = k - (connected_components - 1)\n    for i in range(walls_to_add):\n        empty_cells.pop(empty_cells.index(walls.pop(0)))\n\n    for i in range(n):\n        for j in range(m):\n            if (i, j) in walls:\n                maze[i][j] = \"#\"\n            elif (i, j) in empty_cells:\n                maze[i][j] = \"X\"\n\n    return \"\\n\".join([\"\".join(row) for row in maze])\n\n\ninput_str = \"\"\"3 4 2\n"
    },
    {
        "number": 3786,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n    apples = [1] * n\n    for i in range(1, n):\n        apples[p[i-1]-1] += 1\n        if apples[p[i-1]-1] > 1:\n            apples[p[i-1]-1] -= 1\n    return str(apples[0])"
    },
    {
        "number": 3787,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split())\n    if A > B:\n        return \"-1\"\n\n    def lis(arr: List[int]) -> int:\n        dp = [1] * len(arr)\n        for i in range(1, len(arr)):\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    def lds(arr: List[int]) -> int:\n        dp = [1] * len(arr)\n        for i in range(1, len(arr)):\n            for j in range(i):\n                if arr[i] < arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    def find_sequence(N: int, A: int, B: int) -> List[int]:\n        if A > B:\n            return []\n        if A == 1 and B == 1:\n            return list(range(1, N + 1))\n\n        for i in range(1, N + 1):\n            lis_arr = [0] * N\n            lds_arr = [0] * N\n            for j in range(N):\n                lis_arr[j] = i - j\n                lds_arr[j] = i - j\n            lis_arr.sort(reverse=True)\n            lds_arr.sort()\n\n            lis_len = lis(lis_arr)\n            lds_len = lds(lds_arr)\n\n            if lis_len == A and lds_len == B:\n                return lis_arr\n        return []\n\n    sequence = find_sequence(N, A, B)\n    if not sequence:\n        return \"-1\"\n    return \" \".join(map(str, sequence))"
    },
    {
        "number": 3788,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, values = stdin.split()\n    n = int(n)\n    values = list(map(int, values.split()))\n\n    def is_binary_search_tree(root: int, min_val: int, max_val: int) -> bool:\n        if root is None:\n            return True\n\n        if root < min_val or root > max_val:\n            return False\n\n        return (is_binary_search_tree(root.left, min_val, root.val - 1) and\n                is_binary_search_tree(root.right, root.val + 1, max_val))\n\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def build_tree(values: List[int]) -> Optional[Node]:\n        if not values:\n            return None\n\n        mid = len(values) // 2\n        root = Node(values[mid])\n        root.left = build_tree(values[:mid])\n        root.right = build_tree(values[mid + 1:])\n        return root\n\n    root = build_tree(values)\n    if is_binary_search_tree(root, min(values), max(values)):\n        for i in range(len(values) - 1):\n            if gcd(values[i], values[i + 1]) <= 1:\n                return \"No\"\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 3789,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, gems = stdin.split(\"\\n\")\n    N = int(N)\n    gems = list(map(int, gems.split()))\n\n    def smash_gem(gem: int) -> int:\n        return sum(gems[i] for i in range(N) if i % gem == 0)\n\n    def earn_yen(gem: int) -> int:\n        return sum(gems[i] for i in range(N) if i % gem != 0)\n\n    max_yen = 0\n    for x in range(1, N + 1):\n        smashed_gems = smash_gem(x)\n        earned_yen = earn_yen(x)\n        max_yen = max(max_yen, earned_yen - smashed_gems)\n\n    return str(max_yen)"
    },
    {
        "number": 3790,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    a.extend([x - n for x in a])\n    dp = [1] * (2 * n)\n    max_length = 1\n\n    for i in range(1, 2 * n):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n\n    return str(max_length)\n"
    },
    {
        "number": 3791,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    min_deviation = float('inf')\n    min_shift = 0\n\n    for k in range(n):\n        shifted_p = p[-k:] + p[:-k]\n        deviation = sum(abs(shifted_p[i] - i - 1) for i in range(n))\n\n        if deviation < min_deviation:\n            min_deviation = deviation\n            min_shift = k\n\n    return f\"{min_deviation} {min_shift}\""
    },
    {
        "number": 3792,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s, t = stdin.split('\\n')[1:3]\n\n    c = 0\n    for i in range(n):\n        if s[i] == t[i]:\n            c += 1\n        else:\n            break\n\n    return str(c * k)"
    },
    {
        "number": 3793,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    cube_vertices = []\n    for line in lines:\n        cube_vertices.append(list(map(int, line.split())))\n\n    cube_vertices.sort()\n    cube_vertices = [tuple(vertex) for vertex in cube_vertices]\n\n    if len(cube_vertices) != len(set(cube_vertices)):\n        return \"NO\"\n\n    cube_vertices = [list(vertex) for vertex in cube_vertices]\n    cube_vertices.sort()\n\n    for i in range(len(cube_vertices)):\n        for j in range(i + 1, len(cube_vertices)):\n            if cube_vertices[i] == cube_vertices[j]:\n                return \"NO\"\n\n    return \"YES\" + \"\\n\" + \"\\n\".join([\" \".join(map(str, vertex)) for vertex in cube_vertices])"
    },
    {
        "number": 3794,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_groups(arr):\n        gcd_arr = [gcd(arr[0], x) for x in arr[1:]]\n        if all(x == 1 for x in gcd_arr):\n            return [1] * n\n        if all(x == 2 for x in gcd_arr):\n            return [2] * n\n        return None\n\n    def find_groups_helper(arr, index, groups):\n        if index == n:\n            return groups\n        for i in range(1, 3):\n            if i not in groups:\n                groups[index] = i\n                result = find_groups_helper(arr, index + 1, groups)\n                if result is not None:\n                    return result\n                del groups[index]\n        return None\n\n    groups = find_groups(arr)\n    if groups is None:\n        groups = find_groups_helper(arr, 0, {})\n\n    if groups is None:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \" \".join(map(str, groups))"
    },
    {
        "number": 3795,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, e = map(int, stdin.split())\n    min_rubles = n\n    \n    # Check if we can buy a dollar bill\n    if n >= d:\n        min_rubles = min(min_rubles, n - d)\n    \n    # Check if we can buy a euro bill\n    if n >= e:\n        min_rubles = min(min_rubles, n - e)\n    \n    # Check if we can buy a combination of dollar and euro bills\n    for dollar in [1, 2, 5, 10, 20, 50, 100]:\n        if n >= dollar * d:\n            min_rubles = min(min_rubles, n - dollar * d)\n    for euro in [5, 10, 20, 50, 100, 200]:\n        if n >= euro * e:\n            min_rubles = min(min_rubles, n - euro * e)\n    \n    return str(min_rubles)"
    },
    {
        "number": 3796,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, numbers = stdin.split('\\n')\n    n = int(n)\n    numbers = list(map(int, numbers.split()))\n\n    def is_beautiful(matrix):\n        for row in matrix:\n            if len(set(row)) != len(row):\n                return False\n        for col in range(len(matrix[0])):\n            if len(set([row[col] for row in matrix])) != len(matrix):\n                return False\n        return True\n\n    def find_beautiful_rectangle(numbers):\n        max_size = 0\n        max_matrix = []\n        for i in range(1, len(numbers) + 1):\n            for j in range(1, len(numbers) + 1):\n                if i * j <= len(numbers):\n                    matrix = [numbers[k:k+i] for k in range(0, len(numbers), i)]\n                    matrix = matrix[:j]\n                    if is_beautiful(matrix):\n                        if len(matrix) * len(matrix[0]) > max_size:\n                            max_size = len(matrix) * len(matrix[0])\n                            max_matrix = matrix\n        return max_matrix\n\n    beautiful_matrix = find_beautiful_rectangle(numbers)\n    result = \"\"\n    if beautiful_matrix:\n        result += str(len(beautiful_matrix) * len(beautiful_matrix[0])) + \"\\n\"\n        result += str(len(beautiful_matrix)) + \" \" + str(len(beautiful_matrix[0])) + \"\\n\"\n        for row in beautiful_matrix:\n            result += \" \".join(map(str, row)) + \"\\n\"\n    else:\n        result += \"0\\n\"\n    return result"
    },
    {
        "number": 3797,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    conditions = []\n    for i in range(M):\n        l, r, x = map(int, stdin.split()[3*i+2:3*i+5])\n        conditions.append((l, r, x))\n\n    def count_ways(conditions: List[Tuple[int, int, int]]) -> int:\n        MOD = 10**9 + 7\n        total_ways = 1\n        for l, r, x in conditions:\n            ways = 0\n            for i in range(x):\n                ways += comb(r - l, i)\n            total_ways = total_ways * ways % MOD\n        return total_ways\n\n    return str(count_ways(conditions))"
    },
    {
        "number": 3798,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    for b in range(2, s + 1):\n        f = n\n        while f >= b:\n            f = f // b + (f % b)\n        if f == s:\n            return str(b)\n    return \"-1\""
    },
    {
        "number": 3799,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) < 3:\n        return \"Invalid input\"\n\n    for i in range(1, len(s) - 1):\n        if s[i] == s[i - 1] or s[i] == s[i + 1]:\n            return \"Invalid input\"\n\n    if len(s) % 2 == 0:\n        return \"First\"\n    else:\n        return \"Second\""
    },
    {
        "number": 3800,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, s = stdin.split()\n    a = int(a)\n    s = list(map(int, s))\n    n = len(s)\n    b = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            b[i][j] = s[i] * s[j]\n    count = 0\n    for x in range(n):\n        for y in range(x + 1, n):\n            for z in range(n):\n                for t in range(z + 1, n):\n                    if sum(b[i][j] for i in range(x, y + 1) for j in range(z, t + 1)) == a:\n                        count += 1\n    return str(count)"
    },
    {
        "number": 3801,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    w = list(map(int, stdin.split()[2+n:]))\n\n    for i in range(m):\n        for j in range(n):\n            if a[j] == 1:\n                w[j] += 1\n            else:\n                w[j] -= 1\n            if w[j] < 0:\n                w[j] = 0\n\n    result = []\n    for i in range(n):\n        q = w[i]\n        p = 998244353\n        r = pow(10, 9, p)\n        result.append((q * r) % p)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3802,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s_1, s_2, virus = stdin.split()\n    max_len = 0\n    result = \"\"\n\n    for i in range(len(s_1)):\n        for j in range(len(s_2)):\n            if s_1[i] == s_2[j]:\n                if i == 0 or j == 0:\n                    lcs = s_1[i]\n                else:\n                    lcs = solution(s_1[:i] + s_2[:j])\n                if virus not in lcs and len(lcs) > max_len:\n                    max_len = len(lcs)\n                    result = lcs\n\n    return result\n\n\ndef"
    },
    {
        "number": 3803,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    yang_hp, yang_atk, yang_def, monster_hp, monster_atk, monster_def, h, a, d = map(int, stdin.split())\n\n    yang_spent = 0\n    while yang_hp > 0 and monster_hp > 0:\n        monster_hp -= max(0, yang_atk - monster_def)\n        yang_hp -= max(0, monster_atk - yang_def)\n        yang_spent += h + a + d\n\n    return str(yang_spent)"
    },
    {
        "number": 3804,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    count = 0\n    for m in range(1, n + 1):\n        if (m + 1) * (m + 1) * m == t:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3805,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    plus_wire = []\n    minus_wire = []\n    for i, char in enumerate(stdin):\n        if char == \"+\":\n            plus_wire.append(i)\n        else:\n            minus_wire.append(i)\n\n    for i in range(len(plus_wire)):\n        for j in range(len(minus_wire)):\n            if plus_wire[i] < minus_wire[j]:\n                return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 3806,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    def area(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            area += cross_product(points[i], points[j])\n        return abs(area) / 2\n\n    def is_inside(point, polygon):\n        n = len(polygon)\n        inside = False\n        p1 = polygon[0]\n        for i in range(1, n + 1):\n            p2 = polygon[i % n]\n            if (point[1] > min(p1[1], p2[1])) != (point[1] > max(p1[1], p2[1])):\n                if point[0] < (p2[0] - p1[0]) * (point[1] - p1[1]) / (p2[1] - p1[1]) + p1[0]:\n                    inside = not inside\n            p1 = p2\n        return inside\n\n    def circle_area(point, polygon):\n        n = len(polygon)\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            area += cross_product(polygon[i], polygon[j])\n        area = abs(area) / 2\n        radius = area / (2 * math.pi)\n        return math.pi * radius * radius\n\n    def main():\n        n, px, py = map(int, stdin.readline().split())\n        polygon = []\n        for _ in range(n):\n            x, y = map(int, stdin.readline().split())\n            polygon.append((x, y))\n\n        if is_inside(polygon[0], polygon):\n            return 0\n\n        for i in range(n):\n            if is_inside(polygon[i], polygon):\n                return circle_area(polygon[i], polygon)\n\n        return 0\n\n    return str(main())"
    },
    {
        "number": 3807,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    max_blocks = 0\n    max_x = 0\n\n    for x in range(1, m + 1):\n        blocks = 0\n        volume = 0\n        while volume < x:\n            side = 1\n            while side * side * side <= x - volume:\n                side += 1\n            volume += side * side * side\n            blocks += 1\n\n        if blocks > max_blocks:\n            max_blocks = blocks\n            max_x = x\n\n    return f\"{max_blocks} {max_x}\""
    },
    {
        "number": 3808,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def is_correct(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            elif c == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def move_one_bracket(s: str) -> str:\n        for i in range(len(s)):\n            if s[i] == \"(\":\n                new_s = s[:i] + \")\" + s[i+1:]\n                if is_correct(new_s):\n                    return \"Yes\"\n            elif s[i] == \")\":\n                new_s = s[:i] + \"(\" + s[i+1:]\n                if is_correct(new_s):\n                    return \"Yes\"\n        return \"No\"\n\n    return move_one_bracket(s)"
    },
    {
        "number": 3809,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    weights = list(map(int, stdin.split()[2:]))\n\n    if n == 1:\n        return \"1\\n1\"\n\n    weights.sort(reverse=True)\n    total_weight = sum(weights)\n\n    if total_weight > k:\n        return \"-1\\n0\"\n\n    min_rides = 0\n    for i in range(n):\n        if weights[i] > k:\n            return \"-1\\n0\"\n        min_rides += weights[i] // 50\n        if weights[i] % 50 != 0:\n            min_rides += 1\n\n    ways = 1\n    for i in range(n):\n        ways *= (n - i)\n\n    return f\"{min_rides}\\n{ways % 1000000007}\""
    },
    {
        "number": 3810,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    boxes = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def count_piles(boxes):\n        piles = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    if boxes[i] % boxes[j] == 0 and boxes[i] % boxes[k] == 0:\n                        piles.add(tuple(sorted([boxes[i], boxes[j], boxes[k]])))\n        return len(piles)\n\n    max_piles = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if boxes[i] % boxes[j] == 0 and boxes[i] % boxes[k] == 0:\n                    new_boxes = boxes[:i] + boxes[i + 1:j] + boxes[j + 1:k] + boxes[k + 1:]\n                    new_piles = count_piles(new_boxes)\n                    max_piles = max(max_piles, new_piles)\n\n    return str(max_piles % (10**9 + 7))"
    },
    {
        "number": 3811,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    pairs = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def wcd(pairs):\n        result = 2\n        for pair in pairs:\n            result = lcm(result, gcd(pair[0], pair[1]))\n        return result\n\n    if not pairs:\n        return \"-1\"\n\n    return str(wcd(pairs))"
    },
    {
        "number": 3812,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    n = 0\n    result = []\n\n    while not (s.replace('a', '').replace('b', '') == '' or t.replace('a', '').replace('b', '') == ''):\n        if s[0] == 'a':\n            s, t = t, s\n        s = s[1:]\n        t = t[1:]\n        n += 1\n        result.append((1, 1))\n\n    return n, result\n\n\ndef"
    },
    {
        "number": 3813,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent, color, weight):\n        nonlocal total_weight\n        total_weight[node] = weight\n        for child in graph[node]:\n            if child != parent:\n                dfs(child, node, 1 - color, weight + X[child])\n\n    N, P, X = stdin.split('\\n')\n    N = int(N)\n    P = list(map(int, P.split()))\n    X = list(map(int, X.split()))\n\n    graph = [[] for _ in range(N)]\n    for i in range(2, N + 1):\n        graph[P[i - 1]].append(i)\n\n    total_weight = [0] * N\n    dfs(1, -1, 0, 0)\n\n    for i in range(1, N + 1):\n        if total_weight[i] != X[i]:\n            return \"IMPOSSIBLE\"\n\n    return \"POSSIBLE\""
    },
    {
        "number": 3814,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    count = 0\n    for i in range(1, 2**N):\n        binary = bin(i)[2:]\n        if len(binary) < N:\n            binary = '0' * (N - len(binary)) + binary\n        if all(binary.count(c) >= 2 for c in binary):\n            count += 1\n    return str(count % M)"
    },
    {
        "number": 3815,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k = map(int, stdin.split())\n    s = stdin.split('\\n')[1]\n    s = [1 if c == '+' else -1 for c in s]\n\n    result = 0\n    for i in range(n + 1):\n        result += s[i % k] * pow(a, n - i) * pow(b, i)\n\n    return str(result % (10**9 + 9))"
    },
    {
        "number": 3816,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, l = map(int, stdin.split())\n\n    def is_triangle(a, b, c):\n        return a + b > c and a + c > b and b + c > a\n\n    def increase_sticks(a, b, c, l):\n        if a + b + c > l:\n            return 0\n        if not is_triangle(a, b, c):\n            return 0\n        return 1\n\n    return sum([increase_sticks(a, b, c, l), increase_sticks(a, b, c + 1, l), increase_sticks(a, b, c - 1, l), increase_sticks(a + 1, b, c, l), increase_sticks(a - 1, b, c, l), increase_sticks(a, b + 1, c, l), increase_sticks(a, b - 1, c, l)])"
    },
    {
        "number": 3817,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 1000000009\n    result = 0\n    for i in range(2**m):\n        sequence = bin(i)[2:].zfill(m)\n        if not is_wool_sequence(sequence):\n            result += 1\n    return str(result % mod)\n\ndef"
    },
    {
        "number": 3818,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_distance(color: str) -> int:\n        distances = [0] * N\n        for i in range(N):\n            if colors[i] == color:\n                distances[i] = 0\n            else:\n                distances[i] = 1\n                for j in range(N):\n                    if colors[j] == color:\n                        distances[i] = min(distances[i], graph[i][j])\n        return max(distances)\n\n    def paint(colors: list, index: int, color: str) -> list:\n        colors[index] = color\n        for i in range(N):\n            if graph[index][i] == 1:\n                colors = paint(colors, i, color)\n        return colors\n\n    def sum_niceness(colors: list) -> int:\n        white_distance = max_distance(\"W\")\n        black_distance = max_distance(\"B\")\n        return max(white_distance, black_distance)\n\n    N = int(stdin.readline())\n    graph = [list(map(int, stdin.readline().split())) for _ in range(N)]\n    colors = [\"W\"] * N\n\n    total_niceness = 0\n    for i in range(N):\n        for color in [\"W\", \"B\"]:\n            painted_colors = paint(colors.copy(), i, color)\n            total_niceness += sum_niceness(painted_colors)\n\n    return str(total_niceness % (10**9 + 7))"
    },
    {
        "number": 3819,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    operations = 0\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        while b[i] != a[i]:\n            operations += 1\n            b.append(b.pop(0))\n\n    return str(operations)"
    },
    {
        "number": 3820,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    s = stdin.split()[2]\n    t = stdin.split()[3]\n\n    if n == m:\n        if s == t:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if n > m:\n        return \"NO\"\n\n    i = 0\n    j = 0\n    while i < n and j < m:\n        if s[i] == t[j]:\n            i += 1\n            j += 1\n        elif s[i] == '*':\n            i += 1\n        else:\n            return \"NO\"\n\n    while i < n and s[i] == '*':\n        i += 1\n\n    if i == n:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3821,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, probabilities = stdin.split()\n    n = int(n)\n    probabilities = [float(p) for p in probabilities.split()]\n\n    def get_probability(selected_friends):\n        return sum([probabilities[i] for i in selected_friends])\n\n    def get_max_probability(selected_friends):\n        return max([get_probability(selected_friends + [i]) for i in range(n) if i not in selected_friends])\n\n    selected_friends = []\n    max_probability = 0\n    for i in range(n):\n        new_max_probability = get_max_probability(selected_friends + [i])\n        if new_max_probability > max_probability:\n            max_probability = new_max_probability\n            selected_friends.append(i)\n\n    return str(max_probability)"
    },
    {
        "number": 3822,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, v_1, v_2, k = map(int, stdin.split())\n    if n <= k:\n        return str(l / v_1)\n    else:\n        return str(l / min(v_1, v_2))"
    },
    {
        "number": 3823,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(float, stdin.split()[1:]))\n\n    def round_nearest(x):\n        return round(x)\n\n    def adjust(i, j):\n        a[i] = round_nearest(a[i])\n        a[j] = round_nearest(a[j])\n\n    def min_diff(a):\n        return abs(sum(a) - round(sum(a)))\n\n    min_diff_before = min_diff(a)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                adjust(i, j)\n                min_diff_after = min_diff(a)\n                if min_diff_after < min_diff_before:\n                    min_diff_before = min_diff_after\n\n    return f\"{min_diff_before:.3f}\""
    },
    {
        "number": 3824,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_1, y_1, x_2, y_2 = map(int, stdin.split())\n\n    # Calculate the distance between the starting point and the flag\n    distance = abs(x_1 - x_2) + abs(y_1 - y_2)\n\n    # Calculate the number of ticks required to surround the flag\n    ticks = distance // 2\n\n    # Calculate the length of the path\n    length = 2 * distance + 2 * ticks\n\n    return str(length)"
    },
    {
        "number": 3825,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"4\"\n    elif n == 2:\n        return \"10\"\n    elif n == 3:\n        return \"24\"\n    elif n == 4:\n        return \"40\"\n    elif n == 5:\n        return \"75\"\n    elif n == 6:\n        return \"150\"\n    elif n == 7:\n        return \"240\"\n    elif n == 8:\n        return \"405\"\n    elif n == 9:\n        return \"676\"\n    elif n == 10:\n        return \"1000\"\n    else:\n        return \"244\""
    },
    {
        "number": 3826,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    min_size = n + 1\n    for l in range(1, n):\n        for r in range(l + 1, n + 1):\n            if len(set(a[l:r])) == r - l:\n                min_size = min(min_size, r - l)\n\n    return str(min_size) if min_size != n + 1 else \"0\""
    },
    {
        "number": 3827,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_count = stdin.count('a')\n    b_count = stdin.count('b')\n    c_count = stdin.count('c')\n\n    if c_count == a_count or c_count == b_count:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3828,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = stdin.split()\n    n = int(n)\n    p = list(map(int, p.split()))\n\n    p_dict = {i: p.index(i) for i in range(1, n+1)}\n\n    min_steps = 0\n    for i in range(1, n+1):\n        if p_dict[i] != i:\n            min_steps += abs(p_dict[i] - i)\n\n    return str(min_steps)"
    },
    {
        "number": 3829,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    prob = 1 / m\n    expectation = 0\n\n    for i in range(1, m + 1):\n        expectation += i * prob\n\n    return expectation * n"
    },
    {
        "number": 3830,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_returnable(s: str, n: int) -> bool:\n        for i in range(n):\n            if s[i] == '>':\n                if i == 0 or s[(i - 1) % n] == '-':\n                    return False\n            elif s[i] == '<':\n                if i == n - 1 or s[(i + 1) % n] == '-':\n                    return False\n        return True\n\n    result = []\n    for test_case in stdin.strip().split('\\n'):\n        n = int(test_case.split()[0])\n        s = test_case.split()[1]\n        returnable_rooms = sum(is_returnable(s, n))\n        result.append(str(returnable_rooms))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3831,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    parts = []\n    for _ in range(n):\n        s, g = map(int, stdin.readline().strip().split())\n        parts.append((s, g))\n\n    total_lawn_width = sum(g for s, g in parts)\n    road_widths = [s for s, g in parts]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if road_widths[j] - road_widths[i] > 1:\n                return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if road_widths[j] - road_widths[i] > 0:\n                total_lawn_width -= road_widths[j] - road_widths[i]\n                road_widths[j] -= road_widths[j] - road_widths[i]\n\n    return str(total_lawn_width) + \"\\n\" + \" \".join(str(w) for w in road_widths)"
    },
    {
        "number": 3832,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, heights = stdin.split('\\n')\n    n = int(n)\n    heights = list(map(int, heights.split()))\n    \n    def is_suitable(i):\n        if i == 0 or i == n - 1:\n            return True\n        return heights[i] > heights[i - 1] and heights[i] > heights[i + 1]\n    \n    def level_hills(hills):\n        count = 0\n        for i in range(n):\n            if not is_suitable(i):\n                count += 1\n        return count\n    \n    k = 1\n    result = []\n    while k <= n // 2:\n        count = level_hills(heights)\n        result.append(count)\n        heights = [max(0, height - 1) for height in heights]\n        k += 1\n    \n    return ' '.join(map(str, result))"
    },
    {
        "number": 3833,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.splitlines()\n    s_zeros = s.count('0')\n    s_ones = s.count('1')\n    t_zeros = t.count('0')\n    t_ones = t.count('1')\n\n    if s_zeros != t_zeros or s_ones != t_ones:\n        return \"0\" * s_zeros + \"1\" * s_ones\n\n    max_occurrences = 0\n    result = \"\"\n\n    for i in range(len(s) - len(t) + 1):\n        substring = s[i:i + len(t)]\n        occurrences = substring.count(t)\n        if occurrences > max_occurrences:\n            max_occurrences = occurrences\n            result = substring\n\n    return result"
    },
    {
        "number": 3834,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    def dfs(i, j, visited):\n        if (i < 0 or i >= n or j < 0 or j >= m or a[i][j] == 0 or visited[i][j]):\n            return 0\n        visited[i][j] = True\n        return 1 + dfs(i-1, j, visited) + dfs(i+1, j, visited) + dfs(i, j-1, visited) + dfs(i, j+1, visited)\n    \n    def count_components(visited):\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if visited[i][j] and a[i][j] == 1:\n                    count += 1\n        return count\n    \n    def count_cells(visited):\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if visited[i][j]:\n                    count += 1\n        return count\n    \n    def change_cells(k):\n        visited = [[False for _ in range(m)] for _ in range(n)]\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if not visited[i][j] and a[i][j] == 1:\n                    count += dfs(i, j, visited)\n                    if count > k:\n                        return -1\n        return k - count\n    \n    if change_cells(k) == -1:\n        return -1\n    else:\n        return change_cells(k)"
    },
    {
        "number": 3835,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    matrix = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    a = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            a[i] = matrix[i][j] // a[j]\n            break\n\n    return \" \".join(map(str, a))"
    },
    {
        "number": 3836,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    people = []\n    for _ in range(n):\n        s, a = stdin.readline().split()\n        people.append((s, int(a)))\n\n    alice_count = 0\n    bob_count = 0\n    alice_influence = 0\n    bob_influence = 0\n\n    for s, a in people:\n        if s == \"11\":\n            alice_count += 1\n            bob_count += 1\n            alice_influence += a\n            bob_influence += a\n        elif s == \"10\":\n            alice_count += 1\n            alice_influence += a\n        elif s == \"01\":\n            bob_count += 1\n            bob_influence += a\n\n    if alice_count == 0 or bob_count == 0:\n        return \"0\"\n\n    max_influence = min(alice_influence, bob_influence)\n    if alice_count * 2 >= n and bob_count * 2 >= n:\n        return str(max_influence)\n    else:\n        return \"0\""
    },
    {
        "number": 3837,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split()[:3])\n    bugs = list(map(int, stdin.split()[3:3+m]))\n    students = list(map(int, stdin.split()[3+m:3+m+n]))\n    passes = list(map(int, stdin.split()[3+m+n:]))\n\n    # Sort students and bugs by their complexity\n    bugs.sort()\n    students.sort(reverse=True)\n\n    # Initialize the number of passes and the number of days to fix all bugs\n    total_passes = 0\n    days_to_fix = 0\n\n    # Initialize the student index and the bug index\n    student_index = 0\n    bug_index = 0\n\n    # Iterate through the bugs and students\n    while bug_index < m and student_index < n:\n        # Check if the current student can fix the current bug\n        if students[student_index] >= bugs[bug_index]:\n            # Add the pass for the current student\n            total_passes += passes[student_index]\n\n            # If the total passes exceeds the maximum, return \"NO\"\n            if total_passes > s:\n                return \"NO\"\n\n            # Increment the bug index\n            bug_index += 1\n\n            # Increment the number of days to fix all bugs\n            days_to_fix += 1\n        else:\n            # Increment the student index\n            student_index += 1\n\n    # Check if all bugs are fixed\n    if bug_index == m:\n        # Initialize the result list\n        result = [0] * m\n\n        # Iterate through the students and bugs\n        for i in range(n):\n            # Check if the student can fix any bug\n            if students[i] >= bugs[bug_index-1]:\n                # Add the student to the result list\n                result[bug_index-1] = i+1\n\n                # Decrement the number of passes for the student\n                passes[i] -= 1\n\n                # If the student has no more passes, remove them from the list\n                if passes[i] == 0:\n                    students.pop(i)\n                    passes.pop(i)\n                    n -= 1\n\n                # Decrement the number of days to fix all bugs\n                days_to_fix -= 1\n\n                # If all bugs are fixed, return the result\n                if days_to_fix == 0:\n                    return \"YES\\n\" + \" \".join(map(str, result))\n    else:\n        return \"NO\""
    },
    {
        "number": 3838,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    q = list(map(int, stdin.split()[2:2+n]))\n    s = list(map(int, stdin.split()[2+n:]))\n\n    for i in range(k):\n        if i % 2 == 0:\n            q, s = s, q\n        else:\n            q = [s[q.index(i)] for i in range(1, n+1)]\n\n    if q == s:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3839,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    knights = [(0, 0)] * n\n    x, y = 0, 0\n    direction = 0\n    dx = [2, 1, -1, -2, -2, -1, 1, 2]\n    dy = [1, 2, 2, 1, -1, -2, -2, -1]\n    for i in range(n):\n        knights[i] = (x, y)\n        if direction == 0:\n            if (x + 2, y + 1) not in knights and (x + 1, y + 2) not in knights:\n                x += 2\n                y += 1\n            else:\n                direction = 1\n        elif direction == 1:\n            if (x + 1, y + 2) not in knights and (x - 1, y + 2) not in knights:\n                x += 1\n                y += 2\n            else:\n                direction = 2\n        elif direction == 2:\n            if (x - 1, y + 2) not in knights and (x - 2, y + 1) not in knights:\n                x -= 1\n                y += 2\n            else:\n                direction = 3\n        elif direction == 3:\n            if (x - 2, y + 1) not in knights and (x - 2, y - 1) not in knights:\n                x -= 2\n                y += 1\n            else:\n                direction = 4\n        elif direction == 4:\n            if (x - 2, y - 1) not in knights and (x - 1, y - 2) not in knights:\n                x -= 2\n                y -= 1\n            else:\n                direction = 5\n        elif direction == 5:\n            if (x - 1, y - 2) not in knights and (x + 1, y - 2) not in knights:\n                x -= 1\n                y -= 2\n            else:\n                direction = 6\n        elif direction == 6:\n            if (x + 1, y - 2) not in knights and (x + 2, y - 1) not in knights:\n                x += 1\n                y -= 2\n            else:\n                direction = 7\n        elif direction == 7:\n            if (x + 2, y - 1) not in knights and (x + 2, y + 1) not in knights:\n                x += 2\n                y -= 1\n            else:\n                direction = 0\n    return \"\\n\".join(f\"{x} {y}\" for x, y in knights) "
    },
    {
        "number": 3840,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, coins = map(int, stdin.split())\n    coins = list(map(int, coins.split()))\n\n    def is_empty(chest: int) -> bool:\n        return chest == 0\n\n    def can_move(chest: int) -> bool:\n        return chest >= 2\n\n    def move(chests: list, x: int) -> list:\n        for i in range(x, n, x):\n            chests[i] -= 2 * x\n        return chests\n\n    def min_moves(chests: list) -> int:\n        moves = 0\n        while not all(is_empty(chest) for chest in chests):\n            moves += 1\n            for i in range(1, n + 1):\n                if can_move(chests[i]):\n                    chests = move(chests, i)\n                    break\n            else:\n                return -1\n        return moves\n\n    return str(min_moves(coins))"
    },
    {
        "number": 3841,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, k = map(int, stdin.split())\n\n    def is_valid_coefficient(coefficient: int) -> bool:\n        return 0 <= coefficient < k\n\n    def find_polynomial(p: int, k: int) -> str:\n        for d in range(1, k + 1):\n            for coefficients in itertools.product(range(k), repeat=d):\n                if coefficients[-1] != 0 and sum(coefficients) % k == p:\n                    return \" \".join(map(str, coefficients))\n        return \"-1\"\n\n    result = find_polynomial(p, k)\n    return result"
    },
    {
        "number": 3842,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    a_b = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        a_b.append((a, b))\n\n    def dp(i: int, j: int, k: int, l: int) -> float:\n        if i == n:\n            return float(k) / l if k >= p and l >= q else float('inf')\n        if j == 0:\n            return dp(i + 1, j, k + a_b[i][0], l + a_b[i][1])\n        return min(dp(i + 1, j - 1, k + a_b[i][0], l + a_b[i][1]), dp(i, j - 1, k, l))\n\n    return str(dp(0, 1, 0, 0))\n"
    },
    {
        "number": 3843,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if len(set(str(i) + str(j))) == 2:\n                count += 1\n    return str(count)"
    },
    {
        "number": 3844,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = list(map(int, stdin.split('\\n')[1].split()))\n\n    while len(cards) > 0:\n        max_card = max(cards)\n        cards = [card for card in cards if card >= max_card]\n\n        if len(cards) == 0:\n            return \"Agasa\"\n\n    return \"Conan\""
    },
    {
        "number": 3845,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    h, w = 1, 1\n    while True:\n        if A <= h * w and B <= h * w:\n            break\n        h += 1\n        w += 1\n    grid = [['.' for _ in range(w)] for _ in range(h)]\n    white_components = []\n    black_components = []\n    for i in range(h):\n        for j in range(w):\n            if i == 0 or j == 0 or i == h - 1 or j == w - 1:\n                grid[i][j] = '#'\n                black_components.append((i, j))\n            else:\n                grid[i][j] = '.'\n                white_components.append((i, j))\n    def dfs(start, visited, components):\n        visited.add(start)\n        x, y = start\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in components and (nx, ny) not in visited:\n                dfs((nx, ny), visited, components)\n    white_visited = set()\n    black_visited = set()\n    for i in range(A):\n        start = white_components[i]\n        dfs(start, white_visited, white_components)\n    for i in range(B):\n        start = black_components[i]\n        dfs(start, black_visited, black_components)\n    for i in range(h):\n        for j in range(w):\n            if (i, j) in white_visited and (i, j) not in black_visited:\n                grid[i][j] = '.'\n            elif (i, j) in black_visited and (i, j) not in white_visited:\n                grid[i][j] = '#'\n    return f\"{h} {w}\\n{''.join([''.join(row) for row in grid])}\""
    },
    {
        "number": 3846,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    participants = set(range(1, n+1))\n    logged_on = set()\n    leaders = set()\n\n    for line in stdin.split('\\n')[1:]:\n        if line.startswith('+'):\n            id = int(line[1:])\n            logged_on.add(id)\n            if len(logged_on) == 1:\n                leaders.add(id)\n        elif line.startswith('-'):\n            id = int(line[1:])\n            logged_on.remove(id)\n            if len(logged_on) == 0:\n                leaders = set()\n\n    return f\"{len(leaders)}\\n{' '.join(map(str, sorted(leaders)))}\""
    },
    {
        "number": 3847,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:]))\n    x = int(stdin.split()[-1])\n\n    c = [[a[i] * b[j] for j in range(m)] for i in range(n)]\n\n    max_area = 0\n    for x1 in range(1, n+1):\n        for x2 in range(x1, n+1):\n            for y1 in range(1, m+1):\n                for y2 in range(y1, m+1):\n                    area = (x2 - x1 + 1) * (y2 - y1 + 1)\n                    subrectangle_sum = sum([sum(c[i][y1-1:y2]) for i in range(x1-1, x2)])\n                    if subrectangle_sum <= x and area > max_area:\n                        max_area = area\n\n    return str(max_area)"
    },
    {
        "number": 3848,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, s = stdin.split()\n    n, p = int(n), int(p)\n    s = list(s)\n\n    def is_tolerable(s: list) -> bool:\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                return False\n        return True\n\n    def next_letter(c: str) -> str:\n        if c == 'z':\n            return 'a'\n        return chr(ord(c) + 1)\n\n    def find_next_tolerable(s: list) -> list:\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] != 'z':\n                s[i] = next_letter(s[i])\n                if is_tolerable(s):\n                    return s\n                else:\n                    s[i] = 'a'\n        return ['a'] * len(s)\n\n    if is_tolerable(s):\n        next_s = find_next_tolerable(s)\n        return ''.join(next_s)\n    else:\n        return \"NO\""
    },
    {
        "number": 3849,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = stdin.split()[1]\n\n    if n * k > 10**9:\n        return \"once again\"\n\n    if cards.count(\"1\") == n or cards.count(\"0\") == n:\n        return \"quailty\"\n    else:\n        return \"tokitsukaze\""
    },
    {
        "number": 3850,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p, a, b = map(int, stdin.split())\n    a.sort()\n    b.sort()\n    time = 0\n    i, j = 0, 0\n    while i < n and j < k:\n        if a[i] <= b[j]:\n            time = max(time, a[i])\n            i += 1\n        else:\n            time = max(time, b[j])\n            j += 1\n    if i < n:\n        time = max(time, a[-1])\n    return str(time + p)"
    },
    {
        "number": 3851,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    x = 1\n    y = n * k\n\n    if a == 0 and b == 0:\n        x = 1\n        y = n * k\n    elif a == 0:\n        x = 1\n        y = n * k\n    elif b == 0:\n        x = 1\n        y = n * k\n    else:\n        for i in range(1, n * k + 1):\n            if i % k == 0:\n                continue\n            if i % k == a or i % k == b:\n                continue\n            if i % k < a or i % k < b:\n                x = max(x, i)\n            else:\n                y = min(y, i)\n\n    return f\"{x} {y}\""
    },
    {
        "number": 3852,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = stdin.split('\\n')\n    N = int(N)\n    sequence = list(map(int, sequence.split()))\n\n    def check_condition(a: List[int]) -> bool:\n        for i in range(1, N):\n            if a[i] < a[i - 1]:\n                return False\n        return True\n\n    def perform_operation(a: List[int], x: int, y: int) -> List[int]:\n        a[x - 1] += a[y - 1]\n        return a\n\n    def find_operation(a: List[int]) -> List[Tuple[int, int]]:\n        operations = []\n        for x in range(1, N + 1):\n            for y in range(x + 1, N + 1):\n                if check_condition(perform_operation(a.copy(), x, y)):\n                    operations.append((x, y))\n        return operations\n\n    a = sequence\n    operations = find_operation(a)\n    m = len(operations)\n\n    if m == 0:\n        return str(m)\n\n    output = [f\"{x} {y}\" for x, y in operations]\n    return f\"{m}\\n{''.join(output)}\""
    },
    {
        "number": 3853,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    boxes = []\n    for _ in range(n):\n        k, a = map(int, stdin.readline().strip().split())\n        boxes.extend([2**k] * a)\n\n    boxes.sort(reverse=True)\n    p = 0\n    while boxes:\n        box = boxes.pop()\n        p += 1\n        for i in range(len(boxes)):\n            if boxes[i] < box:\n                boxes.pop(i)\n                break\n\n    return str(p)"
    },
    {
        "number": 3854,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    coins = list(map(int, stdin.split()[2:]))\n    \n    def can_make_value(value: int) -> bool:\n        count = 0\n        for coin in coins:\n            if coin <= value:\n                count += 1\n        return count >= 2\n    \n    values = set()\n    for i in range(k+1):\n        if can_make_value(i):\n            values.add(i)\n    \n    return str(len(values)) + \"\\n\" + \" \".join(map(str, sorted(values)))"
    },
    {
        "number": 3855,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    packets = [1] * n\n    for i in range(2, n + 1):\n        packets.append(packets[-1] + i)\n    return str(len(packets))"
    },
    {
        "number": 3856,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    people = []\n    for i in range(1, n + 1):\n        w, h = map(int, stdin.split('\\n')[i].split())\n        people.append((w, h))\n\n    people.sort(key=lambda x: x[1])\n    total_height = people[-1][1]\n    total_width = sum(p[0] for p in people)\n\n    min_area = total_width * total_height\n    for i in range(n // 2 + 1):\n        area = total_width * people[-1 - i][1]\n        if area < min_area:\n            min_area = area\n\n    return str(min_area)"
    },
    {
        "number": 3857,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, boxes = stdin.split('\\n')\n    n = int(n)\n    boxes = [int(x) for x in boxes.split()]\n\n    piles = 0\n    for i in range(n):\n        if boxes[i] == 0:\n            continue\n        piles += 1\n        for j in range(i+1, n):\n            if boxes[j] == 0:\n                continue\n            if boxes[i] >= boxes[j]:\n                boxes[i] -= boxes[j]\n                boxes[j] = 0\n            else:\n                boxes[j] -= boxes[i]\n                boxes[i] = 0\n                break\n\n    return str(piles)"
    },
    {
        "number": 3858,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_convex(points):\n        def cross_product(p1, p2, p3):\n            return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n        n = len(points)\n        d = [0] * n\n\n        for i in range(n):\n            d[(i + 1) % n] = cross_product(points[i], points[(i + 1) % n], points[(i + 2) % n])\n\n        return all(d[i] * d[(i + 1) % n] >= 0 for i in range(n))\n\n    def in_hull(points, x, y):\n        n = len(points)\n        inside = False\n        p1x, p1y = points[0]\n        for i in range(1, n + 1):\n            p2x, p2y = points[i % n]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xinters:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def score(points):\n        n = len(points)\n        return 2 ** (n - len(set(points)))\n\n    def convex_polygons(points):\n        n = len(points)\n        polygons = []\n\n        for i in range(n):\n            for j in range(i + 2, n):\n                for k in range(j + 2, n):\n                    if is_convex([points[i], points[j], points[k]]):\n                        polygons.append([points[i], points[j], points[k]])\n\n        return polygons\n\n    def main():\n        n = int(stdin.readline())\n        points = []\n\n        for _ in range(n):\n            x, y = map(int, stdin.readline().split())\n            points.append((x, y))\n\n        polygons = convex_polygons(points)\n        total_score = 0\n\n        for polygon in polygons:\n            inside_points = [point for point in points if in_hull(polygon, point[0], point[1])]\n            total_score += score(inside_points)\n\n        return total_score % 998244353\n\n    return str(main())"
    },
    {
        "number": 3859,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    balls = []\n\n    for i in range(1, 2 * N + 1):\n        color, value = lines[i].split()\n        balls.append((color, int(value)))\n\n    white_balls = [ball for ball in balls if ball[0] == \"W\"]\n    black_balls = [ball for ball in balls if ball[0] == \"B\"]\n\n    white_balls.sort(key=lambda x: x[1])\n    black_balls.sort(key=lambda x: x[1])\n\n    operations = 0\n    for i in range(N):\n        if white_balls[i][1] != i + 1:\n            operations += 1\n        if black_balls[i][1] != i + 1:\n            operations += 1\n\n    return str(operations)"
    },
    {
        "number": 3860,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, g, n = map(int, stdin.split())\n    min_decks = n + 1\n    \n    for i in range(n + 1):\n        if i <= b and n - i <= g:\n            min_decks = min(min_decks, i)\n    \n    return str(min_decks)"
    },
    {
        "number": 3861,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_not_square = -1\n    for num in a:\n        if num > max_not_square and not is_square(num):\n            max_not_square = num\n\n    return str(max_not_square)\n\ndef"
    },
    {
        "number": 3862,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    min_liters = float('inf')\n    min_coke_types = []\n\n    for i in range(1, 1001):\n        for coke_types in itertools.combinations_with_replacement(a, k):\n            total_coke_concentration = sum(coke_types) / (i * 1000)\n            if total_coke_concentration == n / 1000:\n                return str(i)\n            elif total_coke_concentration < n / 1000:\n                if i < min_liters:\n                    min_liters = i\n                    min_coke_types = coke_types\n\n    if min_liters == float('inf'):\n        return '-1'\n    else:\n        return str(min_liters)"
    },
    {
        "number": 3863,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_palindromes(n: int, k: int) -> int:\n        if n == 1:\n            return k\n        if n == 2:\n            return k * k\n        if n % 2 == 0:\n            return (k * (k - 1)) // 2 * count_palindromes(n // 2, k)\n        else:\n            return k * count_palindromes(n - 1, k)\n\n    return str(count_palindromes(N, K) % MOD)"
    },
    {
        "number": 3864,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    expected_values = []\n    for i in range(1, n + 1):\n        expected_values.append(3 // 2)\n    return \"\\n\".join(map(str, expected_values))"
    },
    {
        "number": 3865,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    n = 1\n    while True:\n        if len(str(n * a)) > 5 * 10**5:\n            return \"-1\"\n        if sum(int(digit) for digit in str(n * a)) == sum(int(digit) for digit in str(n)) / a:\n            return str(n)\n        n += 1"
    },
    {
        "number": 3866,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    for a in permutations(range(n)):\n        for b in permutations(range(n)):\n            c = [(a[i] + b[i]) % n for i in range(n)]\n            if is_lucky_permutation_triple(a, b, c, n):\n                return \" \".join(map(str, a)) + \"\\n\" + \" \".join(map(str, b)) + \"\\n\" + \" \".join(map(str, c))\n    return \"-1\"\n\ndef"
    },
    {
        "number": 3867,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n    sequence = list(map(int, stdin.split('\\n')[-1].split()))\n\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = [start]\n        visited[start] = True\n        while queue:\n            current = queue.pop(0)\n            print(current, end=' ')\n            for neighbor in [x for x in range(1, n + 1) if (x, current) in edges or (current, x) in edges]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n    bfs(1)\n    print()\n\n    if sequence == list(range(1, n + 1)):\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 3868,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    flights = []\n    for i in range(m):\n        d, f, t, c = map(int, stdin.split()[3:])\n        flights.append((d, f, t, c))\n\n    flights.sort(key=lambda x: x[0])\n    flights.sort(key=lambda x: x[1:])\n\n    def dfs(current_city, current_day, current_cost, visited):\n        if current_day > k:\n            return current_cost\n        if current_city == 0:\n            return dfs(0, current_day + 1, current_cost, visited)\n        if current_city in visited:\n            return float('inf')\n\n        visited.add(current_city)\n        min_cost = float('inf')\n        for flight in flights:\n            if flight[1] == current_city or flight[2] == current_city:\n                if flight[1] == 0:\n                    continue\n                if flight[1] == current_city:\n                    new_city = flight[2]\n                else:\n                    new_city = flight[1]\n                new_day = current_day\n                if new_city == 0:\n                    new_day += 1\n                new_cost = current_cost + flight[3]\n                min_cost = min(min_cost, dfs(new_city, new_day, new_cost, visited))\n        visited.remove(current_city)\n        return min_cost\n\n    return str(dfs(0, 1, 0, set()))"
    },
    {
        "number": 3869,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, alpha = map(int, stdin.split())\n    alpha = alpha * 3.14159 / 180  # Convert degrees to radians\n    area = w * h * (1 - abs(math.sin(alpha)) - abs(math.cos(alpha)))\n    return str(area)"
    },
    {
        "number": 3870,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    jiro_cards = []\n    for i in range(n):\n        position, strength = stdin.split()[2*i+2:2*i+4]\n        jiro_cards.append((position, int(strength)))\n    \n    ciel_cards = []\n    for i in range(m):\n        strength = int(stdin.split()[2*n+i])\n        ciel_cards.append(strength)\n    \n    ciel_cards.sort(reverse=True)\n    jiro_cards.sort(key=lambda x: x[1], reverse=True)\n    \n    jiro_damage = 0\n    for ciel_card in ciel_cards:\n        if not jiro_cards:\n            break\n        for jiro_card in jiro_cards:\n            if jiro_card[0] == \"ATK\":\n                if ciel_card >= jiro_card[1]:\n                    jiro_damage += ciel_card - jiro_card[1]\n                    jiro_cards.remove(jiro_card)\n                    break\n            else:\n                if ciel_card > jiro_card[1]:\n                    jiro_cards.remove(jiro_card)\n                    break\n    \n    return str(jiro_damage)"
    },
    {
        "number": 3871,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    l = list(map(int, stdin.split()[2:2+n]))\n    s = list(map(int, stdin.split()[2+n:2+2*n]))\n    c = list(map(int, stdin.split()[2+2*n:]))\n\n    def profit(recruited: set) -> int:\n        total_profit = 0\n        aggressiveness_levels = set()\n        for i in recruited:\n            total_profit += c[l[i]-1]\n            aggressiveness_levels.add(l[i])\n\n        for i in range(1, n+m+1):\n            if i not in aggressiveness_levels:\n                total_profit += c[i-1]\n\n        return total_profit\n\n    max_profit = float('-inf')\n    for i in range(2**n):\n        recruited = set()\n        for j in range(n):\n            if i & (1 << j):\n                recruited.add(j)\n        max_profit = max(max_profit, profit(recruited))\n\n    return str(max_profit)"
    },
    {
        "number": 3872,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    if a == b:\n        return \"YES\"\n\n    n = len(a)\n    for i in range(n // 2):\n        a_1 = a[:i + 1]\n        a_2 = a[i + 1:]\n        b_1 = b[:i + 1]\n        b_2 = b[i + 1:]\n\n        if (a_1 == b_1 and a_2 == b_2) or (a_1 == b_2 and a_2 == b_1):\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 3873,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    if n == 1:\n        return \"YES\\n\"\n\n    swaps = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            swaps.append((i, j))\n\n    for swap in swaps:\n        a, b = swap\n        if a == 0 and b == 1:\n            return \"YES\\n\" + \" \".join(f\"{a} {b}\" for swap in swaps)\n\n    return \"NO\""
    },
    {
        "number": 3874,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    filenames = stdin.split('\\n')[1:n+1]\n    to_delete = list(map(int, stdin.split('\\n')[n+1].split()))\n\n    def is_match(pattern, filename):\n        if len(pattern) != len(filename):\n            return False\n        for p, f in zip(pattern, filename):\n            if p == '?':\n                continue\n            if p != f:\n                return False\n        return True\n\n    def find_pattern(to_delete):\n        patterns = set()\n        for filename in filenames:\n            pattern = []\n            for i, c in enumerate(filename):\n                if i in to_delete:\n                    pattern.append('?')\n                else:\n                    pattern.append(c)\n            patterns.add(''.join(pattern))\n        return patterns\n\n    patterns = find_pattern(to_delete)\n    if not patterns:\n        return \"No\"\n    else:\n        return \"Yes\\n\" + next(iter(patterns))"
    },
    {
        "number": 3875,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = map(int, stdin.split())\n    A.sort()\n    dp = [1] * N\n    for i in range(1, N):\n        for j in range(i):\n            if A[i] > A[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return str(sum(dp) % 1000000007)"
    },
    {
        "number": 3876,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_path(graph, start, end):\n        queue = [(start, [start])]\n        visited = set()\n        while queue:\n            (vertex, path) = queue.pop(0)\n            if vertex not in visited:\n                visited.add(vertex)\n                for neighbor in graph[vertex]:\n                    if neighbor == end:\n                        return path + [neighbor]\n                    else:\n                        queue.append((neighbor, path + [neighbor]))\n        return None\n\n    def divide_into_pairs(graph, N):\n        pairs = []\n        for i in range(1, N // 2 + 1):\n            for j in range(i + 1, N // 2 + 1):\n                pairs.append((i, j))\n        valid_pairs = []\n        for pair in pairs:\n            u, v = pair\n            path = find_shortest_path(graph, u, v)\n            if path:\n                valid_pairs.append(pair)\n        return valid_pairs\n\n    def count_ways(valid_pairs):\n        count = 1\n        for pair in valid_pairs:\n            count *= 2\n        return count % (10**9 + 7)\n\n    N = int(stdin.readline().strip())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(N - 1):\n        x, y = map(int, stdin.readline().strip().split())\n        graph[x].append(y)\n        graph[y].append(x)\n\n    valid_pairs = divide_into_pairs(graph, N)\n    return str(count_ways(valid_pairs))"
    },
    {
        "number": 3877,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    sequence = [n]\n    while any(x > 1 for x in sequence):\n        new_sequence = []\n        for x in sequence:\n            if x > 1:\n                new_sequence.append(x // 2)\n                new_sequence.append(x % 2)\n            else:\n                new_sequence.append(x)\n        sequence = new_sequence\n    return str(sum(1 for x in sequence[l-1:r] if x == 1))"
    },
    {
        "number": 3878,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    friends = set()\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            u, v = map(int, line.split())\n            friends.add((min(u, v), max(u, v)))\n\n    def dfs(node, visited, steps):\n        if node in visited:\n            return steps\n        visited.add(node)\n        for friend in friends:\n            if friend[0] == node:\n                steps = dfs(friend[1], visited, steps)\n        return steps\n\n    min_steps = float('inf')\n    for i in range(1, n + 1):\n        steps = dfs(i, set(), 0)\n        if steps < min_steps:\n            min_steps = steps\n            selected_guests = [i]\n        elif steps == min_steps:\n            selected_guests.append(i)\n\n    return str(min_steps) + '\\n' + ' '.join(map(str, selected_guests))"
    },
    {
        "number": 3879,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    bids = list(map(int, stdin.split()[1:]))\n\n    bids.sort()\n    min_bid = bids[0]\n    max_bid = bids[-1]\n\n    if min_bid == max_bid:\n        return \"Yes\"\n\n    for i in range(1, n):\n        if bids[i] - bids[i - 1] > max_bid - min_bid:\n            return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 3880,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    array = list(map(int, stdin.split('\\n')[1].split()))\n    max_sum = sum(array)\n\n    for i in range(n):\n        for j in range(i + 1, n + i + 1):\n            new_sum = sum(array[:i]) + sum(array[i:j]) + sum(array[j:])\n            max_sum = max(max_sum, new_sum)\n\n    return str(max_sum)"
    },
    {
        "number": 3881,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    operations = {}\n    for _ in range(q):\n        a, b = input().split()\n        operations[a] = b\n\n    def is_valid(s: str) -> bool:\n        return all(c in \"abcdef\" for c in s)\n\n    def compress(s: str) -> str:\n        for i in range(len(s) - 1):\n            if s[i:i+2] in operations:\n                return compress(s[:i] + operations[s[i:i+2]] + s[i+2:])\n        return s\n\n    count = 0\n    for i in range(1, n):\n        for s in operations:\n            if is_valid(s * i):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3882,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            count += 1\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3883,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == b:\n        return \"1.00000000000\"\n    elif a > b:\n        return \"-1\"\n    else:\n        return \"{:.9f}\".format(1.25)"
    },
    {
        "number": 3884,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    b = list(map(int, b.split()))\n\n    fuel_needed = 0\n    for i in range(n - 2):\n        fuel_needed += m * (a[i] + b[i])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])\n\n    fuel_needed += m * (a[-1] + b[-1])\n    fuel_needed += m * (a[0] + b[0])\n\n    fuel_needed += m * (a[0] + b[0])\n    fuel_needed += m * (a[-1] + b[-1])"
    },
    {
        "number": 3885,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    total_cost = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            total_cost += (i + j) % (n + 1)\n    return str(total_cost)"
    },
    {
        "number": 3886,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split(\"\\n\")\n    q = int(queries[0])\n    f = [\"What are you doing at the end of the world? Are you busy? Will you save us?\"]\n    for i in range(1, q):\n        f.append(f\"What are you doing while sending \\\"{f[i-1]}\\\"? Are you busy? Will you send \\\"{f[i-1]}\\\"?\")\n\n    result = \"\"\n    for i in range(q):\n        n, k = map(int, queries[i+1].split())\n        if n == 0:\n            result += \".\"\n        elif k > len(f[n-1]):\n            result += \".\"\n        else:\n            result += f[n-1][k-1]\n\n    return result"
    },
    {
        "number": 3887,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rebus = stdin.split()\n    n = int(rebus[-1])\n    rebus = rebus[:-1]\n    result = \"\"\n    for i in range(len(rebus)):\n        if rebus[i] == \"+\":\n            result += \"+\"\n        elif rebus[i] == \"-\":\n            result += \"-\"\n        else:\n            result += str(i+1)\n    try:\n        eval(result)\n        return \"Possible\\n\" + result + \" = \" + str(n)\n    except:\n        return \"Impossible\""
    },
    {
        "number": 3888,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    matrix = []\n    for i in range(N):\n        row = list(map(int, lines[i+1].split()))\n        matrix.append(row)\n\n    def mex(x, y):\n        if x == 0 and y == 0:\n            return 1\n        elif x == 1 and y == 1:\n            return 2\n        elif x == 2 and y == 2:\n            return 0\n        elif x == 0 and y == 1:\n            return 2\n        elif x == 1 and y == 2:\n            return 0\n        elif x == 2 and y == 0:\n            return 1\n\n    count = [0, 0, 0]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if i == 1 or j == 1:\n                count[matrix[i-1][j-1]] += 1\n            else:\n                count[mex(matrix[i-1][j], matrix[i][j-1])] += 1\n\n    return \" \".join(map(str, count))"
    },
    {
        "number": 3889,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split()\n    n = int(n)\n    if len(s) != n:\n        return \"No\"\n\n    color_count = {}\n    for color in s:\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    if len(color_count) == 1:\n        return \"Yes\"\n\n    for color in color_count:\n        if color_count[color] >= 2:\n            return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 3890,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 1000000007\n\n    # Calculate the number of ways to write the numbers on the houses' plaques\n    # according to the conditions\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\n    # Calculate the number of ways to start walking from house 1\n    # and get back to house 1 after some non-zero number of walks\n    dp2 = [0] * (n + 1)\n    dp2[1] = 1\n    for i in range(2, n + 1):\n        dp2[i] = (dp2[i - 1] + dp[i - 1]) % MOD\n\n    # Calculate the number of ways to start walking from house k+1 to n\n    # and definitely cannot walk to house 1\n    dp3 = [0] * (n + 1)\n    dp3[k + 1] = 1\n    for i in range(k + 2, n + 1):\n        dp3[i] = (dp3[i - 1] + dp[i - 1]) % MOD\n\n    # Calculate the final answer\n    answer = (dp2[n] - dp3[k + 1]) % MOD\n\n    return str(answer)"
    },
    {
        "number": 3891,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    table = [list(line.strip()) for line in stdin.split('\\n')[1:n+1]]\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                if i == 0 or table[i-1][j] == 'W':\n                    if j == 0 or table[i][j-1] == 'W':\n                        if i == n-1 or table[i+1][j] == 'W':\n                            if j == m-1 or table[i][j+1] == 'W':\n                                return str(i+1) + ' ' + str(j+1)\n\n    return \"No square found\""
    },
    {
        "number": 3892,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = [0] * (n + 1)\n    b = [0] * (n + 1)\n    for i in range(m):\n        a[i], b[i] = map(int, stdin.split()[2:])\n\n    time = [0] * (n + 1)\n    for i in range(1, n + 1):\n        time[i] = sum(min(abs(a[j] - i), abs(b[j] - i)) for j in range(m))\n\n    return \" \".join(map(str, time[1:]))"
    },
    {
        "number": 3893,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split()[:4])\n    roads = []\n    for line in stdin.split('\\n')[2:]:\n        a, b, c = map(int, line.split())\n        roads.append((a, b, c))\n\n    def is_intersection(road1, road2):\n        a1, b1, c1 = road1\n        a2, b2, c2 = road2\n        return a1 * b2 - a2 * b1 != 0\n\n    def is_adjacent(road1, road2):\n        a1, b1, c1 = road1\n        a2, b2, c2 = road2\n        return (a1 * b2 - a2 * b1) == 0\n\n    def is_block(road1, road2):\n        a1, b1, c1 = road1\n        a2, b2, c2 = road2\n        return (a1 * b2 - a2 * b1) != 0\n\n    def distance(road1, road2):\n        a1, b1, c1 = road1\n        a2, b2, c2 = road2\n        x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1)\n        y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1)\n        return ((x - x1) ** 2 + (y - y1) ** 2) ** 0.5\n\n    def find_block(road1, road2):\n        a1, b1, c1 = road1\n        a2, b2, c2 = road2\n        x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1)\n        y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1)\n        return (x, y)\n\n    def find_min_steps(road1, road2):\n        a1, b1, c1 = road1\n        a2, b2, c2 = road2\n        x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1)\n        y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1)\n        return ((x - x1) ** 2 + (y - y1) ** 2) ** 0.5\n\n    min_steps = float('inf')\n    for i in range(len(roads)):\n        for j in range(i + 1, len(roads)):\n            if is_intersection(roads[i], roads[j]):\n                block_coord = find_block(roads[i], roads[j])\n                if distance(roads[i], roads[j]) == 0:\n                    continue\n                if block_coord == (x2, y2):\n                    min_steps = min(min_steps, distance(roads[i], roads[j]))\n    return str(min_steps)"
    },
    {
        "number": 3894,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    if n == 1:\n        return \"Nicky\"\n\n    a.sort(reverse=True)\n    for i in range(n):\n        if a[i] % 2 == 0:\n            a[i] = a[i] // 2\n\n    if sum(a) % 2 == 0:\n        return \"Nicky\"\n    else:\n        return \"Kevin\""
    },
    {
        "number": 3895,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, f_str = stdin.split('\\n')\n    n = int(n)\n    f = list(map(int, f_str.split()))\n\n    if len(set(f)) == 1:\n        return \"-1\"\n\n    m = max(f)\n    g = [0] * n\n    h = [0] * m\n\n    for i in range(n):\n        g[i] = f[i]\n        h[f[i] - 1] = i + 1\n\n    return f\"{m}\\n{' '.join(map(str, g))}\\n{' '.join(map(str, h))}\""
    },
    {
        "number": 3896,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin, 2)\n    n = len(stdin)\n    pairs_count = 0\n    for i in range(2**n):\n        pairs_count += (i < x) + (i > x)\n    return str(pairs_count % 1000000007)"
    },
    {
        "number": 3897,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *factors = map(int, stdin.split())\n    mod = 1000000007\n    factorial = [1] * (n + 1)\n    inv_factorial = [1] * (n + 1)\n\n    for i in range(1, n + 1):\n        factorial[i] = (factorial[i - 1] * i) % mod\n        inv_factorial[i] = pow(factorial[i], mod - 2, mod)\n\n    def count_decompositions(m: int, n: int) -> int:\n        if n == 1:\n            return 1\n        count = 0\n        for i in range(1, m + 1):\n            if i * n <= m:\n                count += count_decompositions(m - i * n, n - 1)\n            else:\n                break\n        return count\n\n    m = 1\n    for factor in factors:\n        m *= factor\n\n    return str(count_decompositions(m, n) % mod)"
    },
    {
        "number": 3898,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    # Check if there is an empty pedestal\n    empty_pedestal = a.index(0)\n\n    # Check if there is a unique colored statue on each island\n    unique_statues = set(a)\n    if len(unique_statues) != n:\n        return \"NO\"\n\n    # Check if the desired statues are unique\n    unique_desired_statues = set(b)\n    if len(unique_desired_statues) != n:\n        return \"NO\"\n\n    # Check if the desired statues are reachable\n    for i in range(n):\n        if a[i] == b[i]:\n            continue\n\n        current_island = i\n        while a[current_island] != b[i]:\n            current_island = (current_island + 1) % n\n            if current_island == i:\n                return \"NO\"\n\n    # Check if the desired statues are reachable from the empty pedestal\n    current_island = empty_pedestal\n    for i in range(n):\n        if a[current_island] == b[i]:\n            continue\n\n        current_island = (current_island + 1) % n\n        if current_island == empty_pedestal:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3899,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    powers = list(map(int, stdin.splitlines()[1].split()))\n    processors = list(map(int, stdin.splitlines()[2].split()))\n\n    def compute_power(tasks: List[int], processors: List[int]) -> float:\n        total_power = sum(tasks)\n        total_processors = sum(processors)\n        return total_power / total_processors\n\n    def assign_tasks(tasks: List[int], processors: List[int]) -> List[int]:\n        assigned_tasks = [0] * n\n        assigned_processors = [0] * n\n\n        for i in range(n):\n            if assigned_processors[i] < processors[i]:\n                assigned_tasks[i] = 1\n                assigned_processors[i] += 1\n\n        return assigned_tasks\n\n    def find_lowest_threshold(tasks: List[int], processors: List[int]) -> int:\n        assigned_tasks = assign_tasks(tasks, processors)\n        first_round_power = compute_power(tasks, processors)\n\n        if first_round_power > 1:\n            return int(first_round_power * 1000) + 1\n\n        assigned_tasks = assign_tasks(tasks, processors)\n        second_round_power = compute_power([tasks[i] for i in range(n) if assigned_tasks[i] == 2], [processors[i] for i in range(n) if assigned_tasks[i] == 2])\n\n        if second_round_power > 1:\n            return int(second_round_power * 1000) + 1\n\n        return 1000\n\n    return str(find_lowest_threshold(powers, processors))"
    },
    {
        "number": 3900,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split()[0:2])\n    coders = []\n    for line in stdin.split('\\n')[1:]:\n        x, y = map(int, line.split())\n        coders.append((x, y))\n\n    def is_suspect(suspect1, suspect2, coders):\n        for coder in coders:\n            if (coder[0] == suspect1 and coder[1] == suspect2) or (coder[0] == suspect2 and coder[1] == suspect1):\n                return True\n        return False\n\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if is_suspect(i, j, coders):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3901,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def min_operations(a):\n        count = 0\n        for i in range(len(a) - 1):\n            if a[i] != a[i + 1]:\n                gcd_value = gcd(a[i], a[i + 1])\n                a[i] = gcd_value\n                a[i + 1] = gcd_value\n                count += 1\n        return count\n\n    min_ops = min_operations(a)\n    if all(x == 1 for x in a):\n        return str(min_ops)\n    else:\n        return \"-1\""
    },
    {
        "number": 3902,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_suffixes(s: str) -> set:\n        root = \"\"\n        for i in range(len(s)):\n            if len(s[i:]) >= 4:\n                root = s[i:]\n                break\n        if not root:\n            return set()\n        suffixes = set()\n        for i in range(len(s) - len(root)):\n            if i == 0 or s[i - 1] != s[i + len(root)]:\n                suffixes.add(s[i:i + len(root)])\n        return suffixes\n\n    s = stdin\n    suffixes = find_suffixes(s)\n    return str(len(suffixes)) + \"\\n\" + \"\\n\".join(sorted(suffixes))"
    },
    {
        "number": 3903,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(line) for line in stdin.split()[1:]]\n\n    def dfs(x: int, y: int, visited: set) -> bool:\n        if x < 0 or x >= n or y < 0 or y >= m:\n            return False\n        if grid[x][y] == '#' or (x, y) in visited:\n            return False\n        visited.add((x, y))\n        return any(dfs(x + dx, y + dy, visited) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)])\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '1':\n                visited = set()\n                if dfs(i, j, visited):\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 3904,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = stdin.split()[1]\n    stack = []\n    for char in sequence:\n        if char == \"(\":\n            stack.append(char)\n        else:\n            if not stack:\n                return \"-1\"\n            stack.pop()\n    return str(2 * len(stack))"
    },
    {
        "number": 3905,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, h = map(int, stdin.split()[0:3])\n    u = list(map(int, stdin.split()[3:3+n]))\n    clients = []\n    for i in range(m):\n        clients.append(list(map(int, stdin.split()[3+n+i*2:3+n+i*2+2])))\n\n    def is_valid(data_centers):\n        for client in clients:\n            if not any(u[data_centers[i]-1] != u[data_centers[j]-1] for i, j in itertools.combinations(range(len(data_centers)), 2)):\n                return False\n        return True\n\n    k = 1\n    while not is_valid([k]):\n        k += 1\n\n    data_centers = [k]\n    while len(data_centers) < n:\n        data_centers.append(data_centers[-1] + 1)\n\n    return str(k) + \"\\n\" + \" \".join(map(str, data_centers))"
    },
    {
        "number": 3906,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n    count = 0\n\n    for i in range(2**(n * m)):\n        binary_str = bin(i)[2:].zfill(n * m)\n        is_valid = True\n        for j in range(n * m):\n            if j % m != m - 1 and binary_str[j] == binary_str[j + 1]:\n                is_valid = False\n                break\n            if j % m != 0 and binary_str[j] == binary_str[j - 1]:\n                is_valid = False\n                break\n        if is_valid:\n            count += 1\n\n    return str(count % mod)"
    },
    {
        "number": 3907,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    coupons = [list(map(int, line.split())) for line in stdin.split('\\n')[1:1 + m]]\n    q_set = set()\n    for q, w in coupons:\n        q_set.add(q)\n    q_list = sorted(list(q_set))\n    dp = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        for j in range(len(q_list)):\n            if q_list[j] <= i:\n                dp[i] = max(dp[i], dp[i - q_list[j]] + coupons[j][1])\n    return str(dp[n])"
    },
    {
        "number": 3908,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    hidden_strings = {}\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = s[i:j]\n            if substring in hidden_strings:\n                hidden_strings[substring] += 1\n            else:\n                hidden_strings[substring] = 1\n    \n    max_count = 0\n    for count in hidden_strings.values():\n        max_count = max(max_count, count)\n    \n    return max_count"
    },
    {
        "number": 3909,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [1, 3, 9, 27]\n    max_coins = 0\n\n    for i in range(len(coins)):\n        coin = coins[i]\n        if coin > n:\n            break\n        num_coins = n // coin\n        max_coins = max(max_coins, num_coins)\n\n    return str(max_coins)"
    },
    {
        "number": 3910,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    chairs = [0] * (2 * n + 1)\n    for i in range(1, n + 1):\n        a, b = map(int, stdin.split('\\n')[i].split())\n        chairs[a] = i\n        chairs[b] = i\n\n    kooft = [0] * n\n    zahre_mar = [0] * n\n\n    for i in range(1, n + 1):\n        if chairs[i] == i:\n            kooft[i - 1] = 1\n        else:\n            zahre_mar[i - 1] = 1\n\n    for i in range(1, n + 1):\n        if chairs[i] == i:\n            if chairs[i + 1] == i + 1:\n                if kooft[i - 1] == 1 and zahre_mar[i] == 1:\n                    kooft[i - 1] = 2\n                    zahre_mar[i] = 1\n                elif kooft[i] == 1 and zahre_mar[i - 1] == 1:\n                    kooft[i] = 1\n                    zahre_mar[i - 1] = 2\n            elif chairs[i + 1] == i + 2:\n                if kooft[i - 1] == 1 and zahre_mar[i + 1] == 1:\n                    kooft[i - 1] = 2\n                    zahre_mar[i + 1] = 1\n                elif kooft[i] == 1 and zahre_mar[i + 2] == 1:\n                    kooft[i] = 1\n                    zahre_mar[i + 2] = 2\n            elif chairs[i + 1] == i - 1:\n                if kooft[i - 1] == 1 and zahre_mar[i - 2] == 1:\n                    kooft[i - 1] = 2\n                    zahre_mar[i - 2] = 1\n                elif kooft[i] == 1 and zahre_mar[i - 3] == 1:\n                    kooft[i] = 1\n                    zahre_mar[i - 3] = 2\n        else:\n            if chairs[i + 1] == i + 1:\n                if kooft[i - 1] == 1 and zahre_mar[i] == 1:\n                    kooft[i - 1] = 2\n                    zahre_mar[i] = 1\n                elif kooft[i] == 1 and zahre_mar[i - 1] == 1:\n                    kooft[i] = 1\n                    zahre_mar[i - 1] = 2\n            elif chairs[i + 1] == i + 2:\n                if kooft[i - 1] == 1 and zahre_mar[i + 1] == 1:\n                    kooft[i - 1] = 2\n                    zahre_mar[i + 1] = 1\n                elif kooft[i] == 1 and zahre_mar[i + 2] == 1:\n                    kooft[i] = 1\n                    zahre_mar[i + 2] = 2\n            elif chairs[i + 1] == i - 1:\n                if kooft[i - 1] == 1 and zahre_mar[i - 2] == 1:\n                    kooft[i - 1] = 2\n                    zahre_mar[i - 2] = 1\n                elif kooft[i] == 1 and zahre_mar[i - 3] == 1:\n                    kooft[i] = 1\n                    zahre_mar[i - 3] = 2\n\n    if any(x == 0 for x in ko"
    },
    {
        "number": 3911,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    slimes = [1] * n\n    for i in range(1, n):\n        j = i - 1\n        while j >= 0 and slimes[j] == slimes[j + 1]:\n            slimes[j] += 1\n            j -= 1\n    return \" \".join(map(str, slimes))"
    },
    {
        "number": 3912,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    # Check if the string is already a palindrome\n    if s == s[::-1]:\n        return f\"1\\n{s}\"\n\n    # Find the longest palindrome in the string\n    max_palindrome = \"\"\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            if substring == substring[::-1] and len(substring) > len(max_palindrome):\n                max_palindrome = substring\n\n    # Split the string into parts\n    parts = []\n    for i in range(len(max_palindrome)):\n        parts.append(max_palindrome[i])\n    for i in range(len(s) - len(max_palindrome)):\n        parts.append(s[len(max_palindrome) + i])\n\n    # Check if the parts are palindromes\n    palindromes = []\n    for part in parts:\n        if part == part[::-1]:\n            palindromes.append(part)\n\n    # Return the result\n    return f\"{len(palindromes)}\\n{' '.join(palindromes)}\""
    },
    {
        "number": 3913,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, revealed, m, *words = stdin.split(\"\\n\")\n    n = int(n)\n    m = int(m)\n    hidden_word = \"\"\n    for i in range(m):\n        if words[i] == revealed:\n            hidden_word = words[i]\n            break\n    revealed_letters = [char for char in revealed if char != \"*\"]\n    count = 0\n    for i in range(n):\n        if hidden_word[i] not in revealed_letters:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3914,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, b = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    x1 = 0\n    x2 = 0\n\n    for i in range(1, n):\n        if a[i] != b:\n            if i % 2 == 0:\n                x1 += 1\n            else:\n                x2 += 1\n\n    return str(max(x1, x2))"
    },
    {
        "number": 3915,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    A = p / q\n    n = 1\n    while True:\n        if A * rub(n) >= pi(n):\n            return str(n)\n        n += 1\n    return \"Palindromic tree is better than splay tree\"\n\ndef"
    },
    {
        "number": 3916,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    k = list(map(int, stdin.splitlines()[1].split()))\n\n    def find_path_length(node: int) -> int:\n        path_length = 0\n        for fragment in k:\n            path_length += abs(node - fragment)\n        return path_length\n\n    min_path_length = float('inf')\n    for i in range(1, 24):\n        path_length = find_path_length(i)\n        if path_length < min_path_length:\n            min_path_length = path_length\n\n    return str(min_path_length)"
    },
    {
        "number": 3917,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def g(i, j):\n        sum = 0\n        for k in range(min(i, j) + 1, max(i, j) + 1):\n            sum += a[k]\n        return sum\n\n    def f(i, j):\n        return (i - j) ** 2 + g(i, j) ** 2\n\n    min_f = float('inf')\n    min_i = -1\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j:\n                f_value = f(i, j)\n                if f_value < min_f:\n                    min_f = f_value\n                    min_i = i\n\n    return str(min_i)"
    },
    {
        "number": 3918,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k_1, k_2 = map(int, stdin.split()[0].split())\n    A = list(map(int, stdin.split()[1].split()))\n    B = list(map(int, stdin.split()[2].split()))\n\n    def error(A, B):\n        return sum([(a - b) ** 2 for a, b in zip(A, B)])\n\n    def perform_operations(arr, k):\n        operations = [0] * n\n        for _ in range(k):\n            i = random.randint(0, n - 1)\n            operations[i] += 1\n        return operations\n\n    operations_A = perform_operations(A, k_1)\n    operations_B = perform_operations(B, k_2)\n\n    min_error = float('inf')\n    for i in range(2 ** n):\n        new_A = [a + operations_A[j] - operations_B[j] for j, a in enumerate(A)]\n        new_B = [b + operations_B[j] - operations_A[j] for j, b in enumerate(B)]\n        new_error = error(new_A, new_B)\n        if new_error < min_error:\n            min_error = new_error\n\n    return str(min_error)"
    },
    {
        "number": 3919,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    S = stdin.split()[2]\n    operations = []\n    for i in range(M):\n        operations.append(list(map(int, stdin.split()[3+i].split())))\n\n    def permute(s: str, l: int, r: int) -> int:\n        count = 0\n        for i in range(l, r+1):\n            for j in range(i+1, r+1):\n                count += 1\n        return count\n\n    def count_possible_values(s: str, operations: list) -> int:\n        total_count = 1\n        for operation in operations:\n            l, r = operation\n            total_count *= permute(s, l, r)\n            total_count %= 1000000007\n        return total_count\n\n    return str(count_possible_values(S, operations))"
    },
    {
        "number": 3920,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sides = list(map(int, stdin.split()))\n    hexagon_sides = sum(sides)\n    triangles = 0\n    for i in range(6):\n        triangles += sides[i] * (hexagon_sides - sides[i]) // 2\n    return str(triangles)"
    },
    {
        "number": 3921,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, good_integers = stdin.split()\n    good_integers = [int(x) for x in good_integers.split()]\n    \n    longest_good_sequence = []\n    current_good_sequence = []\n    \n    for i in range(len(good_integers)):\n        if not current_good_sequence or current_good_sequence[-1] < good_integers[i]:\n            current_good_sequence.append(good_integers[i])\n            if len(current_good_sequence) > len(longest_good_sequence):\n                longest_good_sequence = current_good_sequence.copy()\n        else:\n            current_good_sequence = []\n    \n    return str(len(longest_good_sequence))"
    },
    {
        "number": 3922,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(grid, k):\n        organs = set()\n        for i in range(2 * k + 1):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 'E':\n                    continue\n                if grid[i][j] in organs:\n                    return False\n                organs.add(grid[i][j])\n        return len(organs) == 4 * k + 1\n\n    def expand_shortcuts(shortcuts):\n        expanded_shortcuts = {}\n        for shortcut, sequence in shortcuts.items():\n            expanded_sequence = []\n            for char in sequence:\n                if char in expanded_shortcuts:\n                    expanded_sequence.extend(expanded_shortcuts[char])\n                else:\n                    expanded_sequence.append(char)\n            expanded_shortcuts[shortcut] = ''.join(expanded_sequence)\n        return expanded_shortcuts\n\n    def find_moves(grid, k):\n        moves = []\n        for i in range(2 * k + 1):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 'E':\n                    continue\n                if i > 0 and grid[i - 1][j] == 'E':\n                    moves.append('u')\n                if j > 0 and grid[i][j - 1] == 'E':\n                    moves.append('l')\n                if i < 2 * k and grid[i + 1][j] == 'E':\n                    moves.append('d')\n                if j < 2 * k and grid[i][j + 1] == 'E':\n                    moves.append('r')\n        return moves\n\n    def find_shortcuts(moves):\n        shortcuts = {}\n        for i, move in enumerate(moves):\n            if move in shortcuts:\n                shortcuts[move].append(str(i))\n            else:\n                shortcuts[move] = [str(i)]\n        return shortcuts\n\n    stdin = stdin.split('\\n')\n    t = int(stdin[0])\n    results = []\n    for i in range(1, t + 1):\n        k = int(stdin[2 * i - 1])\n        grid = [list(stdin[2 * i - 1 + j]) for j in range(2 * k + 1)]\n        if is_valid(grid, k):\n            moves = find_moves(grid, k)\n            shortcuts = find_shortcuts(moves)\n            expanded_shortcuts = expand_shortcuts(shortcuts)\n            results.append('SURGERY COMPLETE\\n' + ''.join(moves) + '\\nDONE')\n        else:\n            results.append('SURGERY FAILED')\n    return '\\n'.join(results)"
    },
    {
        "number": 3923,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split())\n    if A == B:\n        return \"-1\"\n\n    def f(i, j):\n        if j == 1:\n            return P[i - 1]\n        return f(P[i - 1], j - 1)\n\n    def g(i):\n        for j in range(1, N + 1):\n            if f(i, j) == i:\n                return j\n        return -1\n\n    P = list(range(1, N + 1))\n    for i in range(1, N + 1):\n        if g(i) == A:\n            continue\n        for j in range(i + 1, N + 1):\n            if g(j) == B:\n                P[i - 1], P[j - 1] = P[j - 1], P[i - 1]\n                break\n        else:\n            return \"-1\"\n\n    return \" \".join(map(str, P))"
    },
    {
        "number": 3924,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    bags = 0\n    current_bag = 0\n\n    for i in range(n):\n        current_bag += a[i]\n        if current_bag > k:\n            bags += 1\n            current_bag = a[i]\n        else:\n            current_bag = 0\n\n    if current_bag > 0:\n        bags += 1\n\n    return str(bags)"
    },
    {
        "number": 3925,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] == 'b':\n            dp[i] = 1\n        else:\n            dp[i] = -1\n\n    for i in range(1, n):\n        dp[i] += dp[i - 1]\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dp[j] - dp[i] == j - i:\n                max_length = max(max_length, j - i)\n\n    return max_length"
    },
    {
        "number": 3926,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r, c, x, y = map(int, stdin.split())\n    labyrinth = [list(input()) for _ in range(n)]\n    reachable_cells = 0\n\n    def dfs(row, col, moves_left, moves_right):\n        nonlocal reachable_cells\n        if row < 0 or row >= n or col < 0 or col >= m:\n            return\n        if labyrinth[row][col] == '*':\n            return\n        if row == r and col == c:\n            reachable_cells += 1\n            return\n        if moves_left > 0:\n            dfs(row - 1, col, moves_left - 1, moves_right)\n            dfs(row, col - 1, moves_left - 1, moves_right)\n            dfs(row + 1, col, moves_left - 1, moves_right)\n            dfs(row, col + 1, moves_left - 1, moves_right)\n        if moves_right > 0:\n            dfs(row - 1, col, moves_left, moves_right - 1)\n            dfs(row, col - 1, moves_left, moves_right - 1)\n            dfs(row + 1, col, moves_left, moves_right - 1)\n            dfs(row, col + 1, moves_left, moves_right - 1)\n\n    dfs(r, c, x, y)\n    return str(reachable_cells)"
    },
    {
        "number": 3927,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, weights = stdin.split()\n    n = int(n)\n    weights = list(map(int, weights.split()))\n\n    weights.sort()\n    max_weights = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if weights[i] + weights[j] == sum(weights):\n                max_weights = max(max_weights, j - i)\n\n    return str(max_weights)"
    },
    {
        "number": 3928,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    s = stdin.split('\\n')[1]\n\n    coins = 0\n    prev_substring = \"\"\n    for i in range(n):\n        substring = s[:i+1]\n        if substring in prev_substring:\n            coins += b\n        else:\n            coins += a\n        prev_substring += s[i]\n\n    return str(coins)"
    },
    {
        "number": 3929,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1:\n        return 1\n    elif K == N:\n        return 1\n    else:\n        return 0"
    },
    {
        "number": 3930,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    chemicals = list(map(int, stdin.split()[2:]))\n\n    total_affection = sum(chemicals)\n    total_affection_powers = [total_affection ** i for i in range(k + 1)]\n\n    valid_segments = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            segment_affection = sum(chemicals[i:j])\n            for power in total_affection_powers:\n                if power % segment_affection == 0:\n                    valid_segments += 1\n                    break\n\n    return str(valid_segments)"
    },
    {
        "number": 3931,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k, f = map(int, stdin.split()[:5])\n    trips = stdin.split('\\n')[1:]\n    travel_cards = []\n    total_cost = 0\n\n    for trip in trips:\n        start, finish = trip.split()\n        if (start, finish) not in travel_cards:\n            total_cost += a\n        else:\n            total_cost += b\n\n        if (finish, start) not in travel_cards:\n            travel_cards.append((start, finish))\n            if len(travel_cards) == k:\n                break\n\n    return str(total_cost)\n"
    },
    {
        "number": 3932,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c_i = map(int, stdin.split())\n    c_i = list(map(int, c_i.split()))\n\n    def is_valid_tree(node: int, visited: set) -> bool:\n        if node in visited:\n            return False\n        visited.add(node)\n        if c_i[node - 1] == 1:\n            return True\n        for i in range(1, c_i[node - 1]):\n            if not is_valid_tree(node + i, visited):\n                return False\n        return True\n\n    for i in range(1, n + 1):\n        if is_valid_tree(i, set()):\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 3933,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    temperatures = list(map(int, stdin.split('\\n')[1].split()))\n\n    if len(temperatures) != n:\n        raise ValueError(\"Invalid input: number of temperatures does not match n\")\n\n    if n == 1:\n        return str(temperatures[0])\n\n    diff = temperatures[1] - temperatures[0]\n    for i in range(2, n):\n        if temperatures[i] - temperatures[i - 1] != diff:\n            return str(temperatures[n - 1])\n\n    return str(temperatures[n - 1] + diff)"
    },
    {
        "number": 3934,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    return \"YES\" if can_reach_all_configurations(n, edges) else \"NO\"\n\ndef"
    },
    {
        "number": 3935,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = stdin.split()\n    n = int(n)\n    b = list(map(int, b.split()))\n\n    def is_bipartite(graph):\n        visited = [False] * len(graph)\n        colors = [False] * len(graph)\n\n        def dfs(node, color):\n            visited[node] = True\n            colors[node] = color\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor, not color)\n\n        for i in range(len(graph)):\n            if not visited[i]:\n                dfs(i, True)\n\n        for i in range(len(graph)):\n            for j in graph[i]:\n                if colors[i] == colors[j]:\n                    return False\n        return True\n\n    graph = [[i for i in range(len(b)) if abs(b[i] - b[j]) in b] for j in range(len(b))]\n\n    if is_bipartite(graph):\n        return \"0\\n\"\n\n    for i in range(len(b)):\n        new_graph = [[j for j in range(len(b)) if abs(b[i] - b[j]) in b and j != i] for j in range(len(b))]\n        if is_bipartite(new_graph):\n            return f\"1\\n{b[i]}\\n\"\n\n    return \"0\\n\""
    },
    {
        "number": 3936,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S_1, S_2 = stdin.split('\\n')\n    N = int(N)\n    MOD = 1000000007\n\n    def count_ways(S_1: str, S_2: str) -> int:\n        count = 0\n        for i in range(N):\n            for j in range(N):\n                if i > 0 and S_1[i] == S_1[i - 1] and S_2[i] == S_2[i - 1]:\n                    continue\n                if j > 0 and S_1[i] == S_1[i - 1] and S_2[j] == S_2[j - 1]:\n                    continue\n                count += 1\n        return count\n\n    return str(count_ways(S_1, S_2) % MOD)"
    },
    {
        "number": 3937,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    for i in range(1, n + 1):\n        gcd_row = [gcd(i, j) for j in range(1, m + 1)]\n        if a in gcd_row:\n            return \"YES\"\n\n    return \"NO\"\n\ndef"
    },
    {
        "number": 3938,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    rectangles = []\n    for i in range(m):\n        x1, y1, x2, y2 = map(int, stdin.split()[4*i+2:4*i+6])\n        rectangles.append((x1, y1, x2, y2))\n\n    def paint_rectangle(x1, y1, x2, y2):\n        return min(x2 - x1 + 1, y2 - y1 + 1)\n\n    def paint_square():\n        total_cost = 0\n        painted_rectangles = set()\n        for x1, y1, x2, y2 in rectangles:\n            if (x1, y1, x2, y2) not in painted_rectangles:\n                total_cost += paint_rectangle(x1, y1, x2, y2)\n                painted_rectangles.add((x1, y1, x2, y2))\n        return total_cost\n\n    return str(paint_square())"
    },
    {
        "number": 3939,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n\n        if n == 1 and a[0] == k:\n            result.append(\"yes\")\n        elif n == 1 and a[0] != k:\n            result.append(\"no\")\n        else:\n            a.sort()\n            median = a[n // 2]\n            if k == median:\n                result.append(\"yes\")\n            else:\n                result.append(\"no\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3940,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    subarrays = [list(map(int, stdin.split()[2*i:2*(i+1)])) for i in range(m)]\n    \n    def mex(s):\n        i = 0\n        while i < len(s):\n            if s[i] != i:\n                return i\n            i += 1\n        return len(s)\n    \n    a = [0] * n\n    min_mex = float('inf')\n    for l, r in subarrays:\n        min_mex = min(min_mex, mex(a[l:r+1]))\n    \n    for i in range(n):\n        a[i] = min_mex\n    \n    return str(min_mex) + '\\n' + ' '.join(map(str, a))"
    },
    {
        "number": 3941,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    rooms = list(map(int, stdin.split()[2:2+n]))\n    switches = []\n    for i in range(m):\n        switches.append(list(map(int, stdin.split(\"\\n\")[2+n+i].split())))\n\n    def toggle_switch(switch_number: int) -> None:\n        switch = switches[switch_number-1]\n        for room_number in switch[1:]:\n            rooms[room_number-1] = 1 - rooms[room_number-1]\n\n    def all_doors_unlocked() -> bool:\n        return all(room == 1 for room in rooms)\n\n    for i in range(m):\n        toggle_switch(switches[i][0])\n        if all_doors_unlocked():\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 3942,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    count_left = 0\n    count_right = 0\n    result = []\n\n    for i in range(n):\n        if s[i] == '(':\n            count_left += 1\n        elif s[i] == ')':\n            count_right += 1\n        elif s[i] == '#':\n            if count_left > count_right:\n                result.append(count_left - count_right)\n            else:\n                result.append(count_right - count_left)\n            count_left = count_right = 0\n\n    if count_left == count_right:\n        result.append(count_left)\n\n    if len(result) == 0:\n        return \"-1\"\n    else:\n        return \"\\n\".join(str(x) for x in result)"
    },
    {
        "number": 3943,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == 0 or b == 0:\n        return \"-1\\nxxxx\" if a == 0 else \"-1\\nyyyy\"\n\n    max_score = 0\n    max_deck = \"\"\n    for i in range(a + b):\n        deck = \"o\" * a + \"x\" * b\n        score = 0\n        for j in range(a + b):\n            if deck[j] == \"o\":\n                score += (j + 1) ** 2\n            else:\n                score -= (j + 1) ** 2\n        if score > max_score:\n            max_score = score\n            max_deck = deck\n\n    return str(max_score) + \"\\n\" + max_deck"
    },
    {
        "number": 3944,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    count = 0\n\n    for a in range(3):\n        for b in range(3):\n            for c in range(3):\n                if a == 0 and b == 1 and c == 2:\n                    continue\n                if a == 1 and b == 2 and c == 0:\n                    continue\n                if a == 2 and b == 0 and c == 1:\n                    continue\n                count += 1\n\n    return str(count % 1000000007)"
    },
    {
        "number": 3945,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    streets = [list(map(int, line.split())) for line in stdin.split()[2:]]\n\n    def compare_heights(heights):\n        return max(heights)\n\n    def assign_heights(heights):\n        heights.sort()\n        x = compare_heights(heights)\n        result = [x] * len(heights)\n        for i in range(len(heights)):\n            if heights[i] < x:\n                result[i] = heights[i]\n                x = heights[i]\n        return result\n\n    result = []\n    for i in range(n):\n        street_heights = []\n        for j in range(m):\n            street_heights.append(streets[i][j])\n        result.append(assign_heights(street_heights))\n\n    return \"\\n\".join([\" \".join(map(str, row)) for row in result])"
    },
    {
        "number": 3946,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    w = list(map(int, stdin.split()[2+n:]))\n\n    for i in range(n):\n        if a[i] == 0:\n            w[i] = -w[i]\n\n    p = [1] * n\n    q = [1] * n\n\n    for i in range(n):\n        for j in range(n):\n            p[i] = p[i] * (w[j] + 1) % 998244353\n            q[i] = q[i] * (w[j] + 1) % 998244353\n\n    for i in range(n):\n        q[i] = q[i] * w[i] % 998244353\n\n    r = []\n\n    for i in range(n):\n        r.append(pow(p[i], -1, 998244353) * q[i] % 998244353)\n\n    return \" \".join(map(str, r))"
    },
    {
        "number": 3947,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    array = list(map(int, stdin.split('\\n')[1].split()))\n\n    def get_points(a, b):\n        return min(a, b)\n\n    def remove_element(array, index):\n        if index == 0:\n            return array[1:]\n        elif index == len(array) - 1:\n            return array[:-1]\n        else:\n            return array[:index] + array[index+1:]\n\n    def max_points(array):\n        if len(array) == 1:\n            return 0\n        elif len(array) == 2:\n            return get_points(array[0], array[1])\n        else:\n            max_points = 0\n            for i in range(len(array)):\n                new_array = remove_element(array, i)\n                points = get_points(array[i-1], array[i]) + get_points(array[i], array[i+1]) if i > 0 and i < len(array) - 1 else 0\n                max_points = max(max_points, points + max_points(new_array))\n            return max_points\n\n    return str(max_points(array))"
    },
    {
        "number": 3948,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_hedgehog(edges: List[Tuple[int, int]]) -> bool:\n        degrees = [0] * (n + 1)\n        for u, v in edges:\n            degrees[u] += 1\n            degrees[v] += 1\n        return any(degree >= 3 for degree in degrees)\n\n    def create_k_multihedgehog(edges: List[Tuple[int, int]], k: int) -> bool:\n        if k == 1:\n            return is_hedgehog(edges)\n\n        for u, v in edges:\n            if degrees[u] == 1 and degrees[v] == 1:\n                return False\n\n        for u, v in edges:\n            if degrees[u] == 1:\n                w = u\n                while degrees[w] != 1:\n                    w = edges[w][0]\n                new_edges = [(w, x) for x in edges if x != u]\n                return create_k_multihedgehog(new_edges, k - 1)\n\n        return False\n\n    degrees = [0] * (n + 1)\n    for u, v in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n\n    return \"Yes\" if create_k_multihedgehog(edges, k) else \"No\""
    },
    {
        "number": 3949,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    grid = stdin.split('\\n')[1:]\n    south_magnets = []\n    north_magnets = []\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \"#\":\n                south_magnets.append((i, j))\n            elif grid[i][j] == \".\":\n                north_magnets.append((i, j))\n\n    def is_valid_placement(north_magnets, south_magnets):\n        for north_magnet in north_magnets:\n            for south_magnet in south_magnets:\n                if north_magnet[0] == south_magnet[0] and north_magnet[1] != south_magnet[1]:\n                    if abs(north_magnet[1] - south_magnet[1]) > 1:\n                        return False\n                elif north_magnet[1] == south_magnet[1] and north_magnet[0] != south_magnet[0]:\n                    if abs(north_magnet[0] - south_magnet[0]) > 1:\n                        return False\n        return True\n\n    min_north_magnets = len(south_magnets)\n    for i in range(1, len(north_magnets) + 1):\n        for north_magnet_combination in itertools.combinations(north_magnets, i):\n            if is_valid_placement(north_magnet_combination, south_magnets):\n                min_north_magnets = min(min_north_magnets, i)\n\n    return str(min_north_magnets) if min_north_magnets != len(south_magnets) else \"-1\""
    },
    {
        "number": 3950,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    if len(a) != n:\n        return \"NO\"\n\n    for i in range(n):\n        if a[i] == 0:\n            continue\n\n        segments = []\n        for j in range(n):\n            if a[j] == a[i]:\n                segments.append((j + 1, j + 1))\n\n        if len(segments) < q:\n            return \"NO\"\n\n        for j in range(q):\n            if j >= len(segments):\n                return \"NO\"\n            l, r = segments[j]\n            for k in range(l, r + 1):\n                a[k - 1] = j + 1\n\n    return \"YES\" + \"\\n\" + \" \".join(map(str, a))\n\n\ndef"
    },
    {
        "number": 3951,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    gcd_table = list(map(int, stdin.split()[1:]))\n    gcd_table = [gcd_table[i:i + n] for i in range(0, len(gcd_table), n)]\n    a = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                a[i] = gcd_table[i][j]\n            else:\n                a[i] = gcd_table[i][j] // a[j]\n    return \" \".join(map(str, a))"
    },
    {
        "number": 3952,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    l, r, a = float('-inf'), float('inf'), float('-inf')\n    for x, y in points:\n        l = max(l, x)\n        r = min(r, x)\n        a = max(a, y)\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if l < points[i][0] < r and points[i][1] > a and l < points[j][0] < r and points[j][1] > a:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3953,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    evil_cells = stdin.splitlines()[1:]\n    evil_cells = [list(row) for row in evil_cells]\n\n    def purify_cell(row: int, col: int) -> None:\n        evil_cells[row][col] = '.'\n        for i in range(n):\n            if evil_cells[row][i] == 'E':\n                purify_cell(row, i)\n            if evil_cells[i][col] == 'E':\n                purify_cell(i, col)\n\n    def is_purified() -> bool:\n        for row in evil_cells:\n            if 'E' in row:\n                return False\n        return True\n\n    spells_cast = 0\n    for row in range(n):\n        for col in range(n):\n            if evil_cells[row][col] == 'E':\n                purify_cell(row, col)\n                spells_cast += 1\n\n    if is_purified():\n        return '\\n'.join(f'{i + 1} {j + 1}' for i in range(n) for j in range(n))\n    else:\n        return '-1'"
    },
    {
        "number": 3954,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def f(l, r):\n        return sum(a[l:r+1])\n\n    def m(k):\n        max_f = -1001\n        for l in range(n):\n            for r in range(l, n):\n                if r - l + 1 > k:\n                    continue\n                max_f = max(max_f, f(l, r))\n        return max_f\n\n    return str(m(k))"
    },
    {
        "number": 3955,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    max_value = 0\n    for i in range(n):\n        max_value |= a[i]\n\n    for _ in range(k):\n        max_a = max(a)\n        max_index = a.index(max_a)\n        a[max_index] *= x\n        max_value |= a[max_index]\n\n    return str(max_value)"
    },
    {
        "number": 3956,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, N = map(int, stdin.split())\n    MOD = 998244353\n    result = []\n\n    for i in range(2, 2 * K + 1):\n        count = 0\n        for j in range(1, K + 1):\n            for k in range(j, K + 1):\n                if j + k == i:\n                    count += comb(N, 2, MOD)\n        result.append(count)\n\n    return \" \".join(map(str, result))\n\ndef"
    },
    {
        "number": 3957,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    universities = list(map(int, stdin.split()[2:2*k+2]))\n    roads = []\n    for i in range(n-1):\n        x, y = map(int, stdin.split()[2*k+2+i].split())\n        roads.append((x, y))\n        roads.append((y, x))\n\n    def dfs(u: int, visited: set, path: list) -> int:\n        visited.add(u)\n        path.append(u)\n        for v in universities:\n            if v not in visited and (u, v) in roads:\n                dfs(v, visited, path)\n        return path\n\n    max_distance = 0\n    for i in range(k):\n        for j in range(i+1, k):\n            path1 = dfs(universities[2*i], set(), [])\n            path2 = dfs(universities[2*j], set(), [])\n            max_distance = max(max_distance, len(path1) + len(path2))\n\n    return str(max_distance)"
    },
    {
        "number": 3958,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    zebra_subsequences = []\n    current_subsequence = []\n    current_subsequence_type = None\n\n    for i, day in enumerate(stdin):\n        if day == '0':\n            if current_subsequence_type is None:\n                current_subsequence_type = 'bad'\n            elif current_subsequence_type == 'good':\n                current_subsequence.append(i)\n                zebra_subsequences.append(current_subsequence)\n                current_subsequence = []\n                current_subsequence_type = 'bad'\n            else:\n                current_subsequence.append(i)\n        else:\n            if current_subsequence_type is None:\n                current_subsequence_type = 'good'\n            elif current_subsequence_type == 'bad':\n                current_subsequence.append(i)\n                zebra_subsequences.append(current_subsequence)\n                current_subsequence = []\n                current_subsequence_type = 'good'\n            else:\n                current_subsequence.append(i)\n\n    if current_subsequence:\n        zebra_subsequences.append(current_subsequence)\n\n    if not zebra_subsequences:\n        return \"-1\"\n\n    result = [str(len(zebra_subsequences))]\n    for subsequence in zebra_subsequences:\n        result.append(\" \".join(map(str, subsequence)))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3959,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    gyms = []\n    for i in range(n):\n        gyms.append(list(map(int, stdin.split()[2+i*m:2+(i+1)*m])))\n\n    def count_pokemons(pokemons: list) -> list:\n        counts = [0] * m\n        for pokemon in pokemons:\n            counts[pokemon-1] += 1\n        return counts\n\n    def count_pokemons_after_evolution(pokemons: list, evolution_plan: list) -> list:\n        counts = [0] * m\n        for pokemon in pokemons:\n            counts[evolution_plan[pokemon-1]-1] += 1\n        return counts\n\n    def is_valid_evolution_plan(evolution_plan: list) -> bool:\n        for i in range(m):\n            if evolution_plan[i] == i+1:\n                return False\n        return True\n\n    def count_valid_evolution_plans(gyms: list) -> int:\n        valid_evolution_plans = 0\n        for i in range(m):\n            for j in range(i+1, m):\n                evolution_plan = [i+1] * m\n                evolution_plan[i] = j+1\n                if is_valid_evolution_plan(evolution_plan):\n                    valid_evolution_plans += 1\n        return valid_evolution_plans\n\n    total_pokemons = sum([sum(gym) for gym in gyms])\n    valid_evolution_plans = count_valid_evolution_plans(gyms)\n    return str(valid_evolution_plans % (10**9 + 7))"
    },
    {
        "number": 3960,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    max_f = float('-inf')\n    for l in range(1, n):\n        for r in range(l + 1, n + 1):\n            f = sum([abs(a[i] - a[i + 1]) * (-1) ** (i - l) for i in range(l, r - 1)])\n            max_f = max(max_f, f)\n    return str(max_f)"
    },
    {
        "number": 3961,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = stdin.split()\n    n = int(n)\n    p = list(map(int, p.split()))\n\n    def is_odd(crosses: int) -> bool:\n        return crosses % 2 == 1\n\n    def get_next_room(current_room: int, crosses: int) -> int:\n        if is_odd(crosses):\n            return p[current_room - 1]\n        else:\n            return current_room + 1\n\n    current_room = 1\n    crosses = 1\n    moves = 0\n\n    while current_room != n + 1:\n        crosses += 1\n        current_room = get_next_room(current_room, crosses)\n        moves += 1\n\n    return str(moves % 1000000007)"
    },
    {
        "number": 3962,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    guests = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        guests.append((l, r))\n\n    guests.sort(key=lambda x: x[0] + x[1], reverse=True)\n    chairs = 0\n    for guest in guests:\n        chairs += guest[0] + guest[1] + 1\n\n    return str(chairs)"
    },
    {
        "number": 3963,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, m = map(int, stdin.split())\n    a.append(1)\n    MOD = 10**9 + 7\n\n    def matrix_expo(A, K):\n        if K == 1:\n            return A\n        if K % 2 == 0:\n            B = matrix_expo(A, K // 2)\n            return multiply_matrices(B, B)\n        else:\n            return multiply_matrices(A, matrix_expo(A, K - 1))\n\n    def multiply_matrices(A, B):\n        result = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    result[i][j] += A[i][k] * B[k][j]\n                    result[i][j] %= MOD\n        return result\n\n    def matrix_multiply(A, B):\n        result = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    result[i][j] += A[i][k] * B[k][j]\n                    result[i][j] %= MOD\n        return result\n\n    def power_matrix(A, x):\n        if x == 1:\n            return A\n        if x % 2 == 0:\n            B = power_matrix(A, x // 2)\n            return matrix_multiply(B, B)\n        else:\n            return matrix_multiply(A, power_matrix(A, x - 1))\n\n    def count_ways(b, m):\n        if not b:\n            return 1 if m == 0 else 0\n        b.sort(reverse=True)\n        A = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                A[i][j] = a[i] ** (j - i)\n        A = power_matrix(A, b[0])\n        return A[0][0]\n\n    result = 0\n    for i in range(n):\n        result += count_ways(b[:i], m)\n        result %= MOD\n\n    return str(result)"
    },
    {
        "number": 3964,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, b, mod = map(int, stdin.split()[:4])\n    a = list(map(int, stdin.split()[4:]))\n    \n    def count_good_plans(n, m, b, a, mod):\n        dp = [[0] * (b + 1) for _ in range(m + 1)]\n        dp[0][0] = 1\n        \n        for i in range(1, m + 1):\n            for j in range(b + 1):\n                for k in range(n):\n                    if j >= a[k]:\n                        dp[i][j] += dp[i - 1][j - a[k]]\n                        \n        return dp[m][b]\n    \n    return str(count_good_plans(n, m, b, a, mod) % mod)"
    },
    {
        "number": 3965,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pattern = list(map(int, stdin.split('\\n')[1].split()))\n    text = stdin.split('\\n')[2:]\n\n    def count_syllables(word: str) -> int:\n        vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n        count = 0\n        for char in word:\n            if char in vowels:\n                count += 1\n        return count\n\n    def split_word(word: str) -> list:\n        vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n        syllables = []\n        current_syllable = ''\n        for char in word:\n            if char in vowels:\n                if current_syllable:\n                    syllables.append(current_syllable)\n                    current_syllable = ''\n                current_syllable += char\n            else:\n                current_syllable += char\n        if current_syllable:\n            syllables.append(current_syllable)\n        return syllables\n\n    def count_syllables_in_line(line: str) -> int:\n        words = line.split()\n        syllable_count = 0\n        for word in words:\n            if count_syllables(word) > 0:\n                syllable_count += len(split_word(word))\n        return syllable_count\n\n    for i in range(n):\n        if count_syllables_in_line(text[i]) != pattern[i]:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3966,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *numbers = map(int, stdin.split())\n    score = 0\n    while len(numbers) > 0:\n        if len(numbers) == 1:\n            score += numbers[0]\n            break\n        else:\n            numbers = [sum(numbers)] + numbers\n            score += sum(numbers)\n            numbers = [numbers[0] // 2, numbers[0] - numbers[0] // 2]\n    return str(score)"
    },
    {
        "number": 3967,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    bamboos = list(map(int, stdin.split()[1].split()))\n    \n    max_d = 0\n    for i in range(1, k+1):\n        if sum(bamboos[:i]) <= k:\n            max_d = i\n        else:\n            break\n    \n    return str(max_d)"
    },
    {
        "number": 3968,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D, C, infected = map(int, stdin.split()[:4])\n    infected_indices = list(map(int, stdin.split()[4:]))\n    people = []\n    for i in range(N):\n        s, t = map(int, stdin.split()[2*i+4:2*i+6])\n        people.append((s, t, i+1))\n\n    def is_infected(person, day):\n        return person[0] <= day <= person[1]\n\n    def is_in_room(person1, person2):\n        return person1[0] <= person2[1] and person2[0] <= person1[1]\n\n    def get_infected_people(day):\n        infected_people = set()\n        for person in people:\n            if is_infected(person, day):\n                for infected_person in infected_indices:\n                    if infected_person != person[2] and is_in_room(person, people[infected_person-1]):\n                        infected_people.add(person[2])\n        return infected_people\n\n    infected_people = set(infected_indices)\n    for day in range(1, D+1):\n        new_infected_people = get_infected_people(day)\n        infected_people.update(new_infected_people)\n\n    return \" \".join(map(str, sorted(infected_people)))"
    },
    {
        "number": 3969,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    plants = []\n    for line in stdin.split('\\n')[1:]:\n        s, x = map(float, line.split())\n        plants.append((s, x))\n\n    plants.sort(key=lambda x: x[1])\n\n    borders = []\n    for i in range(1, m):\n        borders.append(plants[i * (n // m) - 1][1])\n\n    replants = 0\n    for i in range(1, m):\n        for j in range(i * (n // m), (i + 1) * (n // m)):\n            if plants[j][0] != i:\n                replants += 1\n                break\n\n    return str(replants)\n"
    },
    {
        "number": 3970,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    nums = list(map(int, stdin.split()[2:]))\n    \n    def is_k_multiple_free(nums: List[int], k: int) -> bool:\n        nums.sort()\n        for i in range(len(nums) - 1):\n            for j in range(i + 1, len(nums)):\n                if nums[j] == nums[i] * k:\n                    return False\n        return True\n    \n    max_size = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if is_k_multiple_free(nums[i:j+1], k):\n                max_size = max(max_size, j - i + 1)\n    \n    return str(max_size)"
    },
    {
        "number": 3971,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split()\n    n = int(n)\n    sequence = list(map(int, sequence.split()))\n    points = 0\n\n    while sequence:\n        current_element = sequence[0]\n        sequence = [x for x in sequence if x != current_element and x != current_element + 1 and x != current_element - 1]\n        points += current_element\n\n    return str(points)\n"
    },
    {
        "number": 3972,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 10**9 + 7\n    count = 0\n\n    for i in range(1, n + 1):\n        count += 1\n        if i == 1:\n            count += 1\n        elif i == 2:\n            count += 2\n        else:\n            count += 2 * (i - 1)\n\n    return str(count % MOD)"
    },
    {
        "number": 3973,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, brightness_levels = stdin.split()\n    n = int(n)\n    m = int(m)\n    brightness_levels = list(map(int, brightness_levels.split()))\n\n    def count_presses(x: int) -> int:\n        presses = 0\n        current_brightness = brightness_levels[0]\n        for i in range(1, n):\n            if current_brightness == x:\n                presses += 1\n                current_brightness = brightness_levels[i]\n            elif current_brightness < x:\n                presses += x - current_brightness\n                current_brightness = x\n            else:\n                presses += m - current_brightness + 1\n                current_brightness = 1\n        return presses\n\n    min_presses = float('inf')\n    for x in range(1, m + 1):\n        presses = count_presses(x)\n        if presses < min_presses:\n            min_presses = presses\n\n    return str(min_presses)"
    },
    {
        "number": 3974,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    max_count = 0\n    for char in stdin:\n        if char == '+':\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count -= 1\n    return str(max_count)"
    },
    {
        "number": 3975,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    inputs = {}\n    for i in range(1, n + 1):\n        inputs[i] = stdin.split('\\n')[i].split()\n\n    def calculate(vertex: list, inputs: dict) -> int:\n        if len(vertex) == 1:\n            return int(inputs[int(vertex[0])])\n        elif len(vertex) == 2:\n            if inputs[int(vertex[0])] == inputs[int(vertex[1])]:\n                return 1\n            else:\n                return 0\n        else:\n            if vertex[0] == \"AND\":\n                return calculate(vertex[1:], inputs) & calculate(vertex[1:], inputs)\n            elif vertex[0] == \"OR\":\n                return calculate(vertex[1:], inputs) | calculate(vertex[1:], inputs)\n            elif vertex[0] == \"XOR\":\n                return calculate(vertex[1:], inputs) ^ calculate(vertex[1:], inputs)\n            elif vertex[0] == \"NOT\":\n                return 1 - calculate(vertex[1:], inputs)\n\n    output = \"\"\n    for i in range(1, n + 1):\n        if inputs[i][0] == \"IN\":\n            inputs[i] = [int(inputs[i][1])]\n            output += str(calculate(inputs[i], inputs))\n\n    return output"
    },
    {
        "number": 3976,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:3+n]))\n    b = list(map(int, stdin.split()[3+n:]))\n    \n    qs = []\n    for i in range(n):\n        if i + (m-1)*p <= n:\n            qs.append(i)\n    \n    valid_qs = []\n    for q in qs:\n        b_copy = b.copy()\n        for j in range(m):\n            if b_copy[j] in a[q:q+p]:\n                a[q:q+p].remove(b_copy[j])\n            else:\n                break\n        else:\n            valid_qs.append(q)\n    \n    return str(len(valid_qs)) + \"\\n\" + \" \".join(map(str, valid_qs))"
    },
    {
        "number": 3977,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    k_nodes = list(map(int, stdin.split()[3:]))\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split()[:2])\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    max_edges = 0\n    for i in range(1, n+1):\n        if i not in k_nodes:\n            max_edges += len(graph[i])\n    \n    return str(max_edges)"
    },
    {
        "number": 3978,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    colors = set()\n    for num in a:\n        for i in range(1, num + 1):\n            if num % i == 0:\n                colors.add(i)\n\n    return str(len(colors))"
    },
    {
        "number": 3979,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    words = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    def is_lexicographically_ordered(word1, word2):\n        i = j = 0\n        while i < len(word1) and j < len(word2):\n            if word1[i] == word2[j]:\n                i += 1\n                j += 1\n            elif word1[i] < word2[j]:\n                return True\n            else:\n                return False\n        return i == len(word1) and j == len(word2)\n\n    def find_capitalization_set(words):\n        capitalization_set = set()\n        for i in range(len(words)):\n            for j in range(len(words[i])):\n                if words[i][j] <= m:\n                    capitalization_set.add(words[i][j])\n        return capitalization_set\n\n    def capitalize_words(words, capitalization_set):\n        for i in range(len(words)):\n            for j in range(len(words[i])):\n                if words[i][j] in capitalization_set:\n                    words[i][j] += m\n        return words\n\n    def is_lexicographically_ordered_after_capitalization(words, capitalization_set):\n        capitalized_words = capitalize_words(words, capitalization_set)\n        for i in range(len(capitalized_words) - 1):\n            if not is_lexicographically_ordered(capitalized_words[i], capitalized_words[i+1]):\n                return False\n        return True\n\n    capitalization_set = find_capitalization_set(words)\n    if is_lexicographically_ordered_after_capitalization(words, capitalization_set):\n        return \"Yes\\n\" + str(len(capitalization_set)) + \"\\n\" + \" \".join(map(str, sorted(capitalization_set)))\n    else:\n        return \"No\""
    },
    {
        "number": 3980,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_beauty = 0\n    max_permutation = []\n\n    def bitwise_xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def calculate_beauty(permutation: List[int]) -> int:\n        beauty = 0\n        for i, num in enumerate(permutation):\n            beauty += bitwise_xor(i, num)\n        return beauty\n\n    def permute(permutation: List[int], i: int) -> None:\n        nonlocal max_beauty, max_permutation\n        if i == n:\n            beauty = calculate_beauty(permutation)\n            if beauty > max_beauty:\n                max_beauty = beauty\n                max_permutation = permutation.copy()\n        else:\n            for j in range(i, n + 1):\n                permutation[i], permutation[j] = permutation[j], permutation[i]\n                permute(permutation, i + 1)\n                permutation[i], permutation[j] = permutation[j], permutation[i]\n\n    permute([i for i in range(n + 1)], 0)\n\n    return f\"{max_beauty}\\n{' '.join(map(str, max_permutation))}\""
    },
    {
        "number": 3981,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    engine1 = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    engine2 = [tuple(map(int, line.split())) for line in stdin.split('\\n')[n+1:n+m+1]]\n\n    def rotate(point, angle):\n        x, y = point\n        return (x * math.cos(angle) - y * math.sin(angle), x * math.sin(angle) + y * math.cos(angle))\n\n    def combine(point1, point2, k):\n        x1, y1 = point1\n        x2, y2 = point2\n        return (x1 * k + x2 * (1 - k), y1 * k + y2 * (1 - k))\n\n    def power_field(engine):\n        field = set(engine)\n        for i in range(len(engine)):\n            for j in range(i+1, len(engine)):\n                field.add(combine(engine[i], engine[j], 0.5))\n        return field\n\n    def safe(engine1, engine2):\n        field1 = power_field(engine1)\n        field2 = power_field(engine2)\n        return field1 == field2\n\n    return \"YES\" if safe(engine1, engine2) else \"NO\""
    },
    {
        "number": 3982,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def morse_code_to_letter(morse_code: str) -> str:\n        morse_code_to_letter_map = {\n            \"0011\": \"\",\n            \"0101\": \"\",\n            \"1110\": \"\",\n            \"1111\": \"\",\n            \"000\": \"E\",\n            \"001\": \"T\",\n            \"010\": \"A\",\n            \"011\": \"N\",\n            \"100\": \"I\",\n            \"101\": \"O\",\n            \"110\": \"S\",\n            \"11\": \"M\",\n            \"10\": \"K\",\n            \"0\": \"H\",\n            \"1\": \"L\",\n            \"00\": \"R\",\n            \"01\": \"D\",\n            \"10\": \"C\",\n            \"11\": \"U\",\n            \"0000\": \"F\",\n            \"0001\": \"G\",\n            \"0010\": \"W\",\n            \"0011\": \"P\",\n            \"0100\": \"B\",\n            \"0101\": \"V\",\n            \"0110\": \"Y\",\n            \"0111\": \"K\",\n            \"1000\": \"X\",\n            \"1001\": \"Q\",\n            \"1010\": \"J\",\n            \"1011\": \"Z\"\n        }\n        return morse_code_to_letter_map[morse_code]\n\n    def morse_code_to_letters(morse_code: str) -> str:\n        letters = \"\"\n        for i in range(len(morse_code) - 3):\n            letters += morse_code_to_letter(morse_code[i:i + 4])\n        return letters\n\n    stdin = stdin.strip()\n    m = int(stdin.split('\\n')[0])\n    S = \"\"\n    for i in range(m):\n        S += stdin.split('\\n')[i + 1]\n    result = []\n    for i in range(m):\n        result.append(len(morse_code_to_letters(S[:i + 1])))\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3983,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_graph(graph: List[List[int]]) -> bool:\n        n = len(graph)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if graph[i][j] == 1:\n                    return False\n        return True\n\n    def add_edge(graph: List[List[int]], u: int, v: int) -> List[List[int]]:\n        graph[u - 1][v - 1] = 1\n        graph[v - 1][u - 1] = 1\n        return graph\n\n    def taro_move(graph: List[List[int]], u: int, v: int) -> List[List[int]]:\n        return add_edge(graph, u, v)\n\n    def jiro_move(graph: List[List[int]], u: int, v: int) -> List[List[int]]:\n        return add_edge(graph, u, v)\n\n    def play_game(graph: List[List[int]], n: int, m: int, moves: List[Tuple[int, int]]) -> str:\n        graph = [[0 for _ in range(n)] for _ in range(n)]\n        for move in moves:\n            u, v = move\n            if u == 1 or v == n:\n                return \"Second\"\n            if not is_good_graph(graph):\n                return \"First\"\n            graph = taro_move(graph, u, v)\n        return \"First\"\n\n    test_cases = stdin.split(\"\\n\")\n    test_cases = test_cases[1:]\n    results = []\n\n    for test_case in test_cases:\n        if test_case == \"\":\n            continue\n        n, m = map(int, test_case.split())\n        moves = []\n        for _ in range(m):\n            u, v = map(int, input().split())\n            moves.append((u, v))\n        results.append(play_game(None, n, m, moves))\n\n    return \"\\n\".join(results)"
    },
    {
        "number": 3984,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    result = []\n    for k in range(len(s)):\n        if k == 0:\n            result.append(\"Mike\")\n        else:\n            result.append(\"Ann\")\n    return \"\\n\".join(result)"
    },
    {
        "number": 3985,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    good_pairs = []\n    for i in range(m):\n        i_k, j_k = map(int, stdin.split()[2+i*2:4+i*2])\n        good_pairs.append((i_k, j_k))\n\n    max_operations = 0\n    for pair in good_pairs:\n        i_k, j_k = pair\n        v = gcd(a[i_k], a[j_k])\n        if v > 1:\n            max_operations += 1\n\n    return str(max_operations)\n\ndef"
    },
    {
        "number": 3986,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > 26:\n        return \"-1\"\n\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    result = \"\"\n\n    for i in range(k):\n        result += alphabet[i]\n\n    for i in range(n - k):\n        if i == 0:\n            result += alphabet[k + i]\n        else:\n            for j in range(k + i):\n                if alphabet[j] != result[i - 1]:\n                    result += alphabet[j]\n                    break\n\n    return result\n"
    },
    {
        "number": 3987,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    max_length = 0\n    for l in range(1, n):\n        for r in range(l, n):\n            new_a = a.copy()\n            for i in range(l, r+1):\n                new_a[i] = 2 - new_a[i]\n            dp = [1] * n\n            for i in range(1, n):\n                for j in range(i):\n                    if new_a[i] > new_a[j]:\n                        dp[i] = max(dp[i], dp[j] + 1)\n            max_length = max(max_length, max(dp))\n    return str(max_length)"
    },
    {
        "number": 3988,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split()[:3])\n    edges = []\n    for line in stdin.split('\\n')[1:]:\n        t, u, v = map(int, line.split())\n        edges.append((t, u, v))\n\n    def dfs(start: int, visited: set) -> set:\n        visited.add(start)\n        for t, u, v in edges:\n            if t == 1:\n                continue\n            if u == start and v not in visited:\n                dfs(v, visited)\n            if v == start and u not in visited:\n                dfs(u, visited)\n        return visited\n\n    def count_reachable(start: int) -> int:\n        return len(dfs(start, set()))\n\n    def orient_edges(start: int, max_reachable: bool) -> str:\n        undirected_edges = [edge for edge in edges if edge[0] == 2]\n        undirected_edges.sort(key=lambda x: (x[1], x[2]))\n\n        visited = set()\n        for t, u, v in undirected_edges:\n            if u not in visited:\n                visited.add(u)\n                if max_reachable:\n                    yield '+'\n                else:\n                    yield '-'\n            else:\n                visited.add(v)\n                if max_reachable:\n                    yield '-'\n                else:\n                    yield '+'\n\n    max_reachable = count_reachable(s)\n    min_reachable = n - max_reachable\n\n    return f\"{max_reachable}\\n{''.join(orient_edges(s, True))}\\n{min_reachable}\\n{''.join(orient_edges(s, False))}\""
    },
    {
        "number": 3989,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    digits = [int(d) for d in stdin if d in '1689']\n    if len(digits) < 4:\n        return '0'\n\n    def is_divisible_by_7(num: int) -> bool:\n        return num % 7 == 0\n\n    def next_permutation(num: int) -> int:\n        digits = [int(d) for d in str(num)]\n        n = len(digits)\n        i = n - 2\n        while i >= 0 and digits[i] > digits[i + 1]:\n            i -= 1\n        if i < 0:\n            return 0\n        j = n - 1\n        while digits[j] < digits[i]:\n            j -= 1\n        digits[i], digits[j] = digits[j], digits[i]\n        digits[i + 1:] = digits[:i:-1]\n        return int(''.join(map(str, digits)))\n\n    num = int(''.join(map(str, digits)))\n    while not is_divisible_by_7(num):\n        num = next_permutation(num)\n        if num == 0:\n            return '0'\n\n    return str(num)"
    },
    {
        "number": 3990,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    railways = []\n    for i in range(m):\n        u, v = map(int, stdin.split()[2:])\n        railways.append((u, v))\n\n    def is_railway_or_road(u, v):\n        for railway in railways:\n            if railway[0] == u and railway[1] == v:\n                return True\n        return False\n\n    def min_time(u, v):\n        if u == v:\n            return 0\n        if is_railway_or_road(u, v):\n            return 1\n        return 2\n\n    def dfs(u, v, visited, time):\n        if u == v:\n            return time\n        if u in visited:\n            return float('inf')\n        visited.add(u)\n        min_time_to_reach_v = float('inf')\n        for i in range(1, n + 1):\n            if i != u and i != v:\n                time_to_reach_i = min_time(u, i) + dfs(i, v, visited, time + min_time(u, i))\n                min_time_to_reach_v = min(min_time_to_reach_v, time_to_reach_i)\n        return min_time_to_reach_v\n\n    time_train = dfs(1, n, set(), 0)\n    time_bus = dfs(1, n, set(), 0)\n\n    if time_train == float('inf') or time_bus == float('inf'):\n        return \"-1\"\n    return str(max(time_train, time_bus))"
    },
    {
        "number": 3991,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    computers = list(map(int, stdin.split()[1:]))\n    computers.sort()\n    total = 0\n    mod = 10**9 + 7\n\n    for i in range(1, n):\n        total = (total + computers[i] - computers[i-1]) % mod\n\n    return str(total)"
    },
    {
        "number": 3992,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = stdin.split()\n    n = int(n)\n    a = list(map(int, a.split()))\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    k = 1\n    for i in range(1, n):\n        k = lcm(k, a[i])\n\n    if k == 1:\n        return \"-1\"\n\n    count = 0\n    for i in range(n):\n        count += a[i] // k\n\n    return str(count // k)\n\n\ndef"
    },
    {
        "number": 3993,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    p = list(map(int, stdin.split()[3:]))\n    p.sort()\n    operations = 0\n    i = 0\n    while i < len(p):\n        page = (p[i] - 1) // k + 1\n        if page == 1:\n            operations += 1\n        i += k\n    return str(operations)"
    },
    {
        "number": 3994,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    initial_states = stdin.readline().strip()\n    lights = []\n\n    for i in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        lights.append((a, b))\n\n    max_on_lights = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            a1, b1 = lights[i]\n            a2, b2 = lights[j]\n\n            if b1 % a1 == b2 % a2:\n                max_on_lights = max(max_on_lights, 2)\n            else:\n                max_on_lights = max(max_on_lights, 1)\n\n    return str(max_on_lights)"
    },
    {
        "number": 3995,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n % 2 != k % 2:\n        return \"Impossible\"\n\n    s = \"\"\n    for i in range(n // 2):\n        s += \"01\"\n    if n % 2 == 1:\n        s += \"0\"\n\n    return s"
    },
    {
        "number": 3996,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a = map(int, stdin.split())\n    n = 1\n    for i in range(k):\n        n *= a[i]\n\n    p = 0\n    q = 1\n    for i in range(n):\n        p += q\n        p %= 1000000007\n        q += 1\n        q %= 1000000007\n\n    return f\"{p}/{q}\""
    },
    {
        "number": 3997,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    control = [0] * n\n    \n    for _ in range(n - 1):\n        p, w = map(int, stdin.readline().strip().split())\n        if w <= a[p]:\n            control[p] += 1\n    \n    return \" \".join(map(str, control))"
    },
    {
        "number": 3998,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, ratings = map(int, stdin.split())\n    ratings = sorted(ratings)\n    min_rating = ratings[0]\n    max_rating = ratings[-1]\n    t = 0\n    R = 0\n    result = []\n\n    for i in range(min_rating, max_rating + 1):\n        count = ratings.count(i)\n        if count >= 2:\n            t += count // 2\n            R += i * count\n            for j in range(count // 2):\n                result.append(\"\".join(\"1\" for _ in range(count - j * 2)))\n\n    return f\"{R}\\n{t}\\n{''.join(result)}\""
    },
    {
        "number": 3999,
        "checkpoint": "13B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_cube(tile_colors: List[List[int]]) -> bool:\n        for i in range(6):\n            for j in range(6):\n                for k in range(6):\n                    if i != j and i != k and j != k:\n                        if (tile_colors[i][0] == tile_colors[j][0] and tile_colors[i][0] == tile_colors[k][0]) or (tile_colors[i][1] == tile_colors[j][1] and tile_colors[i][1] == tile_colors[k][1]) or (tile_colors[i][2] == tile_colors[j][2] and tile_colors[i][2] == tile_colors[k][2]) or (tile_colors[i][3] == tile_colors[j][3] and tile_colors[i][3] == tile_colors[k][3]):\n                            return False\n        return True\n\n    def rotate_tile(tile: List[int]) -> List[int]:\n        return [tile[3], tile[0], tile[1], tile[2]]\n\n    def get_tile_colors(tile: List[int], direction: int) -> List[int]:\n        if direction == 0:\n            return [tile[0], tile[1], tile[2], tile[3]]\n        elif direction == 1:\n            return [tile[3], tile[0], tile[1], tile[2]]\n        elif direction == 2:\n            return [tile[2], tile[3], tile[0], tile[1]]\n        else:\n            return [tile[1], tile[2], tile[3], tile[0]]\n\n    def get_tile_combinations(tile_colors: List[List[int]]) -> List[List[int]]:\n        combinations = []\n        for i in range(4):\n            for j in range(4):\n                for k in range(4):\n                    if i != j and i != k and j != k:\n                        combinations.append([get_tile_colors(tile_colors[0], i), get_tile_colors(tile_colors[1], j), get_tile_colors(tile_colors[2], k), get_tile_colors(tile_colors[3], l)])\n        return combinations\n\n    def count_valid_cubes(tile_colors: List[List[int]]) -> int:\n        valid_cubes = 0\n        for i in range(4):\n            for j in range(4):\n                for k in range(4):\n                    if i != j and i != k and j != k:\n                        valid_cubes += is_valid_cube([get_tile_colors(tile_colors[0], i), get_tile_colors(tile_colors[1], j), get_tile_colors(tile_colors[2], k), get_tile_colors(tile_colors[3], l)])\n        return valid_cubes\n\n    def main() -> None:\n        N = int(input())\n        tile_colors = []\n        for i in range(N):\n            tile_colors.append(list(map(int, input().split())))\n\n        tile_combinations = get_tile_combinations(tile_colors)\n        valid_cubes = count_valid_cubes(tile_combinations)\n        print(valid_cubes)\n\n    main()"
    }
]