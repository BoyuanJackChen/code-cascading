[
    {
        "number": 3000,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    modulo = 10**9 + 7\n    n = int(stdin.split()[0])\n    tokens = stdin.split()[1:]\n    stack = []\n    i = 0\n\n    while i < n:\n        if tokens[i] == \"(\":\n            stack.append(\"(\")\n        elif tokens[i] == \")\":\n            sub_sequence = []\n            while stack[-1] != \"(\":\n                sub_sequence.append(stack.pop())\n            stack.pop()  # Remove the opening parenthesis\n\n            # Evaluate the sub-sequence\n            result = 1\n            operator = \"*\"\n            for item in sub_sequence[::-1]:\n                if item == \"*\" or item == \"+\":\n                    operator = item\n                else:\n                    if operator == \"*\":\n                        result *= int(item)\n                    else:\n                        result += int(item)\n            stack.append(str(result % modulo))\n        else:\n            stack.append(tokens[i])\n        i += 1\n\n    # Evaluate the final sequence\n    result = 0\n    operator = \"+\"\n    for item in stack[::-1]:\n        if item == \"+\" or item == \"*\":\n            operator = item\n        else:\n            if operator == \"*\":\n                result *= int(item)\n            else:\n                result += int(item)\n\n    return str(result % modulo)\n"
    },
    {
        "number": 3000,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    modulo = 10**9 + 7\n    n = int(stdin.split('\\n')[0])\n    tokens = stdin.split('\\n')[1].split()\n\n    def evaluate(tokens):\n        stack = []\n        for token in tokens:\n            if token == '(':\n                stack.append('(')\n            elif token == ')':\n                sub_sequence = []\n                while stack and stack[-1] != '(':\n                    sub_sequence.append(stack.pop())\n                stack.pop()  # Remove the opening parenthesis\n                sub_sequence.reverse()\n                stack.append(evaluate(sub_sequence))\n            else:\n                stack.append(int(token))\n        return stack[0]\n\n    return str(evaluate(tokens) % modulo)\n"
    },
    {
        "number": 3000,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    mod = 10**9 + 7\n    tokens = stdin.split()\n    stack = []\n    value_stack = []\n    for token in tokens:\n        if token.isdigit():\n            value_stack.append(int(token))\n        elif token == '(':\n            stack.append(token)\n        else:\n            while stack[-1] != '(':\n                if stack[-1] == '*':\n                    value_stack.append(value_stack.pop() * value_stack.pop())\n                else:\n                    value_stack.append(value_stack.pop() + value_stack.pop())\n                stack.pop()\n            stack.pop()\n    while stack:\n        if stack[-1] == '*':\n            value_stack.append(value_stack.pop() * value_stack.pop())\n        else:\n            value_stack.append(value_stack.pop() + value_stack.pop())\n        stack.pop()\n    return str(value_stack[0] % mod)"
    },
    {
        "number": 3000,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    tokens = stdin.split()\n    n = int(tokens[0])\n    tokens = tokens[1:]\n    modulo = 10**9 + 7\n\n    def evaluate(tokens):\n        stack = []\n        for token in tokens:\n            if token == '(':\n                stack.append('(')\n            elif token == ')':\n                sub_sequence = []\n                while stack[-1] != '(':\n                    sub_sequence.append(stack.pop())\n                stack.pop()  # Remove the opening parenthesis\n                stack.append(evaluate(sub_sequence[::-1]))\n            else:\n                stack.append(int(token))\n\n        result = 0\n        current_operator = '+'\n        while stack:\n            token = stack.pop()\n            if isinstance(token, int):\n                if current_operator == '+':\n                    result += token\n                else:\n                    result *= token\n            else:\n                current_operator = token\n        return result\n\n    return str(evaluate(tokens) % modulo)\n"
    },
    {
        "number": 3000,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    modulo = 10**9 + 7\n    input_list = list(stdin.split())\n    stack = []\n    i = 0\n    while i < len(input_list):\n        if input_list[i] == '(':\n            stack.append('(')\n        elif input_list[i] == ')':\n            temp_stack = []\n            while stack[-1] != '(':\n                temp_stack.append(stack.pop())\n            stack.pop()\n            temp_stack.reverse()\n            if not temp_stack:\n                stack.append(1)\n            else:\n                prev = temp_stack[0]\n                for num in temp_stack[1:]:\n                    if num == '*':\n                        prev = (prev * temp_stack.pop(1)) % modulo\n                    else:\n                        prev = (prev + temp_stack.pop(1)) % modulo\n                stack.append(prev)\n        else:\n            stack.append(int(input_list[i]))\n        i += 1\n    return str(stack[0])"
    },
    {
        "number": 3000,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    modulo = 10**9 + 7\n    n = int(stdin.readline())\n    sequence = stdin.readline().split()\n    stack = []\n    for token in sequence:\n        if token == '(':\n            stack.append('(')\n        elif token == ')':\n            result = 1\n            while stack[-1] != '(':\n                op = stack.pop()\n                num = stack.pop()\n                if op == '+':\n                    result += num\n                else:\n                    result *= num\n            stack.pop()\n            stack.append(result)\n        else:\n            stack.append(int(token))\n            stack.append('+')\n    result = 0\n    while stack:\n        op = stack.pop()\n        num = stack.pop()\n        if op == '+':\n            result += num\n        else:\n            result *= num\n    return str(result % modulo)"
    },
    {
        "number": 3000,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    tokens = stdin.split('\\n')[1].split()\n\n    def evaluate(tokens: list) -> int:\n        stack = []\n        for token in tokens:\n            if token == '(':\n                stack.append('(')\n            elif token == ')':\n                sub_expression = []\n                while stack and stack[-1] != '(':\n                    sub_expression.append(stack.pop())\n                stack.pop()  # Remove the opening parenthesis\n                sub_expression.reverse()\n                stack.append(calculate(sub_expression))\n            else:\n                stack.append(int(token))\n        return calculate(stack)\n\n    def calculate(stack: list) -> int:\n        result = 0\n        operand = 0\n        operator = '+'\n        for token in stack:\n            if isinstance(token, int):\n                if operator == '+':\n                    result += token\n                else:\n                    result *= token\n                operand = token\n            else:\n                operator = token\n        return result\n\n    result = evaluate(tokens)\n    return result % (10**9 + 7)"
    },
    {
        "number": 3000,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def evaluate(tokens):\n        stack = []\n        for token in tokens:\n            if token == '(':\n                stack.append('(')\n            elif token == ')':\n                sub_sequence = []\n                while stack[-1] != '(':\n                    sub_sequence.append(stack.pop())\n                stack.pop()\n                value = evaluate(sub_sequence)\n                if stack and stack[-1] == '*':\n                    stack.pop()\n                    stack[-1] *= value\n                else:\n                    stack.append(value)\n            else:\n                if stack and stack[-1] == '+':\n                    stack.pop()\n                    stack[-1] += int(token)\n                else:\n                    stack.append(int(token))\n        return stack[0]\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    tokens = input_data[1].split()\n    result = evaluate(tokens) % (10**9 + 7)\n    return str(result)"
    },
    {
        "number": 3000,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    tokens = stdin.readline().strip().split()\n\n    def evaluate(tokens):\n        stack = []\n        i = 0\n        while i < len(tokens):\n            if tokens[i] == '(':\n                stack.append(tokens[i])\n            elif tokens[i] == ')':\n                sub_expression = []\n                while stack[-1] != '(':\n                    sub_expression.append(stack.pop())\n                stack.pop()  # Remove the opening parenthesis\n                stack.append(evaluate(sub_expression[::-1]))\n            else:\n                stack.append(int(tokens[i]))\n            i += 1\n        return sum(stack) % (10**9 + 7)\n\n    return str(evaluate(tokens))"
    },
    {
        "number": 3000,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    sequence = stdin.readline().strip().split()\n\n    def evaluate(start, end):\n        result = []\n        operators = []\n\n        i = start\n        while i < end:\n            if sequence[i] == '(':\n                par_start = i\n                par_level = 1\n                while par_level > 0:\n                    i += 1\n                    if sequence[i] == '(':\n                        par_level += 1\n                    elif sequence[i] == ')':\n                        par_level -= 1\n                result.append(evaluate(par_start + 1, i))\n            elif sequence[i] == '+':\n                operators.append('+')\n            elif sequence[i] == '*':\n                operators.append('*')\n            else:\n                result.append(int(sequence[i]))\n            i += 1\n\n        while len(operators) > 1:\n            if operators[0] == '+':\n                result[0] += result[1]\n                result.pop(1)\n            else:\n                result[0] *= result[1]\n                result.pop(1)\n            operators.pop(0)\n\n        return result[0]\n\n    return evaluate(0, n) % (10**9 + 7)"
    },
    {
        "number": 3001,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = list(stdin.lstrip('0'))\n    n = len(num)\n    steps = 0\n\n    for i in range(n // 2):\n        left = num[i]\n        right = num[n - i - 1]\n\n        if left != right:\n            diff = abs(int(left) - int(right))\n            steps += diff\n\n            if int(left) < int(right):\n                num[n - i - 1] = left\n            else:\n                num[i] = right\n\n    return str(steps)\n\ndef"
    },
    {
        "number": 3001,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(number: str) -> bool:\n        return number == number[::-1]\n\n    def advance_counter(counter: str) -> str:\n        new_counter = \"\"\n        for i, digit in enumerate(counter):\n            if digit == \"9\":\n                new_counter += \"0\"\n                if i > 0:\n                    counter = counter[:i-1] + chr(ord(counter[i-1])+1) + counter[i:]\n            else:\n                new_counter += chr(ord(digit)+1)\n        return new_counter\n\n    def palindrome_steps(counter: str) -> int:\n        steps = 0\n        while not is_palindrome(counter):\n            counter = advance_counter(counter)\n            steps += 1\n        return steps\n\n    return str(palindrome_steps(stdin))"
    },
    {
        "number": 3001,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    digits = [int(d) for d in stdin]\n    num_steps = 0\n\n    for i in range(len(digits) // 2):\n        if digits[i] != digits[-(i + 1)]:\n            diff = abs(digits[i] - digits[-(i + 1)])\n            if diff > 5:\n                diff = 10 - diff\n            digits[i] += diff\n            digits[-(i + 1)] -= diff\n            num_steps += 1\n\n    return str(num_steps)"
    },
    {
        "number": 3001,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(number: str) -> bool:\n        return number == number[::-1]\n\n    def increment(wheels: List[int]) -> List[int]:\n        carry = 1\n        for i in range(len(wheels)):\n            wheels[i] += carry\n            carry = 0\n            if wheels[i] == 10:\n                wheels[i] = 0\n                carry = 1\n            else:\n                break\n        if carry == 1:\n            wheels.insert(0, 1)\n        return wheels\n\n    wheels = [int(d) for d in stdin]\n    steps = 0\n    while not is_palindrome(stdin):\n        wheels = increment(wheels)\n        stdin = ''.join([str(d) for d in wheels])\n        steps += 1\n\n    return str(steps)"
    },
    {
        "number": 3001,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num = stdin.lstrip('0')  # Remove leading zeros\n    n = len(num)\n    if n == 0 or n == 1:  # Base cases\n        return \"0\"\n    mid = n // 2  # Find midpoint of the number\n    palindrome = num[:mid] + num[mid-1::-1] if n % 2 == 1 else num[:mid] + num[:mid-1:-1]\n    # If the number is odd, we add the middle element to both halves of the palindrome.\n    # If the number is even, we don't include the middle element in the first half.\n    steps = 0\n    for i in range(mid):\n        # Count the number of steps needed to advance the wheels\n        steps += abs(int(palindrome[i]) - int(num[i]))\n    return str(steps)"
    },
    {
        "number": 3001,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(num: str) -> bool:\n        return num == num[::-1]\n\n    def rotate_wheel(wheel: str) -> str:\n        if wheel == '9':\n            return '0'\n        return str(int(wheel) + 1)\n\n    num_str = stdin.lstrip('0')\n    num_len = len(num_str)\n    num_wheels = num_len // 2\n\n    if num_len % 2 == 0:\n        left_half = num_str[:num_wheels]\n        right_half = num_str[num_wheels:]\n    else:\n        left_half = num_str[:num_wheels + 1]\n        right_half = num_str[num_wheels + 1:]\n\n    if left_half == right_half:\n        return '0'\n\n    for i in range(1, num_len):\n        rotated_num = int(num_str[-i:])\n        rotated_num_str = str(rotate_wheel(str(rotated_num))) + num_str[-i+1:]\n\n        if is_palindrome(rotated_num_str):\n            return str(i)\n\n    return str(num_len)"
    },
    {
        "number": 3001,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    def increment(wheels, index):\n        wheels[index] += 1\n        if wheels[index] == 10:\n            wheels[index] = 0\n            if index > 0:\n                increment(wheels, index - 1)\n\n    wheels = [int(d) for d in stdin]\n    steps = 0\n    while not is_palindrome(wheels):\n        increment(wheels, -1)\n        steps += 1\n\n    return str(steps)"
    },
    {
        "number": 3001,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(num_str: str) -> bool:\n        return num_str == num_str[::-1]\n\n    def next_palindrome(num_str: str) -> str:\n        for i in range(len(num_str) // 2):\n            if num_str[i] != num_str[-i - 1]:\n                carry = 1\n                for j in range(i, len(num_str) - i - 1):\n                    temp_sum = int(num_str[j]) + carry\n                    carry = temp_sum // 10\n                    num_str = num_str[:j] + str(temp_sum % 10) + num_str[j + 1:]\n                if carry:\n                    num_str = num_str[:i] + '0' + num_str[i + 1:]\n                break\n        return num_str\n\n    stdin = stdin.lstrip('0')\n    if is_palindrome(stdin):\n        return 0\n    num_str = stdin\n    step = 0\n    while not is_palindrome(num_str):\n        num_str = next_palindrome(num_str)\n        step += 1\n    return step"
    },
    {
        "number": 3001,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(num: str) -> bool:\n        return num == num[::-1]\n\n    def next_palindrome(num: str) -> int:\n        if is_palindrome(num):\n            return 0\n\n        n = len(num)\n        mid = n // 2\n        left, right = num[:mid], num[mid:]\n\n        if left == left[::-1]:\n            for i in range(mid, n):\n                if num[i] < '9':\n                    num = num[:i] + '9' + num[i + 1:]\n                    break\n            else:\n                num = num[:mid - 1] + '9' * (n - mid + 1)\n        else:\n            for i in range(mid - 1, -1, -1):\n                if num[i] < '9':\n                    num = num[:i] + str(int(num[i]) + 1) + num[i + 1:]\n                    break\n            else:\n                num = '1' + '0' * (n - 1) + '1'\n\n        return n - len(left) + 1\n\n    num = stdin.lstrip('0')\n    if not num:\n        return '0'\n\n    result = next_palindrome(num)\n    return str(result) "
    },
    {
        "number": 3001,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(n: str) -> bool:\n        return n == n[::-1]\n\n    def next_palindrome(n: str) -> str:\n        if int(n) == 0:\n            return \"1\"\n        n = list(n)\n        left = len(n) // 2 - 1\n        mid = len(n) // 2\n        while left >= 0 and n[left] == n[mid]:\n            left -= 1\n            mid += 1\n        if left < 0:\n            n = [str(int(d) + 1) for d in n]\n        else:\n            n[left] = str(int(n[left]) + 1)\n            for i in range(left + 1, mid):\n                n[i] = \"0\"\n            for i in range(mid, len(n)):\n                n[i] = str(int(n[left]) - 1)\n        return \"\".join(n)\n\n    n = stdin.lstrip(\"0\")\n    if is_palindrome(n):\n        return \"0\"\n\n    steps = 0\n    while not is_palindrome(n):\n        n = next_palindrome(n)\n        steps += 1\n\n    return str(steps)"
    },
    {
        "number": 3002,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered_odometer(entries) -> bool:\n        for i in range(len(entries) - 1):\n            prev_entry, curr_entry = entries[i], entries[i + 1]\n            if curr_entry[2] < prev_entry[2]:\n                return True\n        return False\n\n    def is_sufficiently_serviced(entries) -> bool:\n        distance_traveled = 0\n        last_service = entries[0]\n        for i in range(1, len(entries)):\n            curr_entry = entries[i]\n            distance_traveled += curr_entry[2] - last_service[2]\n            if distance_traveled >= 30000:\n                return True\n            last_service = curr_entry\n        return False\n\n    lines = stdin.split(\"\\n\")\n    num_entries = int(lines[0])\n    entries = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    if is_tampered_odometer(entries):\n        return \"tampered odometer\"\n    elif is_sufficiently_serviced(entries):\n        return \"seems legit\"\n    else:\n        return \"insufficient service\""
    },
    {
        "number": 3002,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def has_tampered_odometer(entries):\n        for i in range(1, len(entries)):\n            y1, m1, o1 = entries[i - 1]\n            y2, m2, o2 = entries[i]\n            if y2 == y1 and m2 == m1:\n                continue\n            if o2 < o1 or o2 - o1 > 20000:\n                return True\n        return False\n\n    def is_serviced_often_enough(entries):\n        last_service_index = 0\n        for i in range(1, len(entries)):\n            y1, m1, o1 = entries[i - 1]\n            y2, m2, o2 = entries[i]\n            distance = o2 - o1\n            if y2 == y1 and m2 == m1:\n                continue\n            if distance >= 20000:\n                last_service_index = i\n            elif (y2 - y1) * 12 + (m2 - m1) > 12 or (y2 - y1) * 12 + (m2 - m1) == 12 and distance > 0:\n                if i - last_service_index >= 3:\n                    return True\n                last_service_index = i\n        return False\n\n    lines = stdin.split('\\n')\n    e = int(lines[0])\n    entries = []\n    for i in range(1, e + 1):\n        year, month, odometer = map(int, lines[i].split())\n        entries.append((year, month, odometer))\n\n    if has_tampered_odometer(entries):\n        return \"tampered odometer\"\n    elif is_serviced_often_enough(entries):\n        return \"insufficient service\"\n    else:\n        return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered(odometer_readings):\n        for i in range(1, len(odometer_readings)):\n            if odometer_readings[i] < odometer_readings[i - 1]:\n                return True\n        return False\n\n    def is_serviced(service_history):\n        km_per_month = 20000\n        distance_limit = 30000\n        months_limit = 12\n\n        for i in range(len(service_history)):\n            if i == 0:\n                continue\n\n            distance_traveled = service_history[i][2] - service_history[i - 1][2]\n            time_passed = (service_history[i][1] - service_history[i - 1][1]) * 12 + (service_history[i][0] - service_history[i - 1][0])\n\n            if distance_traveled > km_per_month * time_passed:\n                return False\n\n        service_interval = distance_limit / km_per_month\n        for i in range(len(service_history)):\n            if (i + 1) % service_interval == 0:\n                continue\n\n            if service_history[i][0] != service_history[i + service_interval - 1][0]:\n                return False\n\n        return True\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    service_history = []\n\n    for i in range(1, n + 1):\n        year, month, odometer_reading = map(int, lines[i].split())\n        service_history.append((year, month, odometer_reading))\n\n    if is_tampered([service_history[i][2] for i in range(len(service_history))]):\n        return \"tampered odometer\"\n\n    if not is_serviced(service_history):\n        return \"insufficient service\"\n\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered(entries):\n        for i in range(1, len(entries)):\n            if entries[i][2] < entries[i - 1][2]:\n                return True\n        return False\n\n    def is_serviced(entries):\n        for i in range(len(entries)):\n            if i == len(entries) - 1:\n                break\n            if entries[i][0] == entries[i + 1][0]:\n                if (entries[i][1] + 12) % 12 != entries[i + 1][1]:\n                    continue\n            elif entries[i][0] == entries[i + 1][0] - 1:\n                if entries[i][1] != 12 or entries[i + 1][1] != 1:\n                    continue\n            else:\n                continue\n\n            if (entries[i][2] + entries[i + 1][2]) >= 30000:\n                return False\n        return True\n\n    e, entries = int(stdin.split('\\n')[0]), []\n    for i in range(1, e + 1):\n        year, month, odometer = map(int, stdin.split('\\n')[i].split())\n        entries.append((year, month, odometer))\n\n    entries.sort()\n\n    if is_tampered(entries):\n        return \"tampered odometer\"\n\n    if is_serviced(entries):\n        return \"seems legit\"\n    else:\n        return \"insufficient service\" "
    },
    {
        "number": 3002,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    e = int(stdin.readline())\n    service_history = []\n    for _ in range(e):\n        year, month, odometer = map(int, stdin.readline().split())\n        service_history.append((year, month, odometer))\n\n    # Check for tampered odometer\n    for i in range(1, len(service_history)):\n        year, month, odometer = service_history[i]\n        prev_year, prev_month, prev_odometer = service_history[i - 1]\n\n        if prev_odometer > odometer:\n            return \"tampered odometer\"\n\n    # Check service history\n    for i in range(len(service_history) - 1):\n        year, month, odometer = service_history[i]\n        next_year, next_month, next_odometer = service_history[i + 1]\n\n        if next_month < month:\n            next_year -= 1\n        if next_odometer - odometer > 20000:\n            return \"insufficient service\"\n\n        time_diff = (next_year - year) * 12 + (next_month - month)\n        distance_diff = next_odometer - odometer\n        if distance_diff > 2000 and distance_diff < 20000:\n            if time_diff > 12:\n                return \"insufficient service\"\n        elif distance_diff >= 20000:\n            if time_diff > 30:\n                return \"insufficient service\"\n\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered_odometer(entries):\n        for i in range(1, len(entries)):\n            _, _, o1 = entries[i - 1]\n            y2, m2, o2 = entries[i]\n            if o2 < o1:\n                return True\n            elif o2 > o1 and o2 - o1 > 10000:\n                return True\n        return False\n\n    def sufficient_service(entries):\n        last_service = (0, 0)\n        for y, m, _ in entries:\n            if (y, m) - last_service >= (12, 0) or (y - 1, m + 12) - last_service >= (12, 0):\n                last_service = (y, m)\n            else:\n                return False\n        return True\n\n    lines = stdin.splitlines()\n    e = int(lines[0])\n    entries = []\n    for i in range(1, e + 1):\n        y, m, o = map(int, lines[i].split())\n        entries.append((y, m, o))\n\n    if is_tampered_odometer(entries):\n        return \"tampered odometer\"\n    elif not sufficient_service(entries):\n        return \"insufficient service\"\n    else:\n        return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered(entries):\n        prev_odometer = 0\n        prev_month = entries[0][1]\n        prev_year = entries[0][0]\n        for year, month, odometer in entries[1:]:\n            if year == prev_year:\n                if month <= prev_month:\n                    return True\n            if (odometer - prev_odometer) > 20000:\n                return True\n            prev_odometer = odometer\n            prev_month = month\n            prev_year = year\n        return False\n\n    def is_serviced(entries):\n        last_service = 0\n        for year, month, odometer in entries:\n            if year == 2017 and month < 4:\n                continue\n            if (odometer - last_service) >= 30000:\n                return True\n            if year > last_year and (year - last_year) * 12 + month - last_month >= 12:\n                return True\n            last_service = odometer\n            last_year = year\n            last_month = month\n        return False\n\n    e, *entries = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    entries = [(year, month, odometer) for year, month, odometer in entries if year >= 2017 or (year == 2017 and month >= 4)]\n    entries.sort(key=lambda x: (x[0], x[1]))\n\n    if is_tampered(entries):\n        return \"tampered odometer\"\n    elif is_serviced(entries):\n        return \"seems legit\"\n    else:\n        return \"insufficient service\""
    },
    {
        "number": 3002,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered(entries: List[List[int]]) -> bool:\n        for i in range(len(entries) - 1):\n            if entries[i][2] > entries[i + 1][2]:\n                return True\n        return False\n\n    def is_serviced(entries: List[List[int]]) -> bool:\n        for i in range(len(entries) - 1):\n            if i % 12 == 0 and entries[i + 1][1] != 1:\n                return False\n            if i % 12 != 0 and (entries[i + 1][2] - entries[i][2]) > 30000:\n                return False\n        return True\n\n    input_data = list(map(lambda x: list(map(int, x.strip().split())), stdin.strip().split('\\n')[1:]))\n\n    if is_tampered(input_data):\n        return \"tampered odometer\"\n    elif is_serviced(input_data):\n        return \"seems legit\"\n    else:\n        return \"insufficient service\""
    },
    {
        "number": 3002,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def parse_entry(entry):\n        year, month, odometer = map(int, entry.split())\n        return year, month, odometer\n\n    def get_months_between(start, end):\n        years = end[0] - start[0]\n        months = end[1] - start[1]\n        return years * 12 + months\n\n    def check_odometer_tampering(entries):\n        for i in range(1, len(entries)):\n            year, month, odometer = entries[i]\n            prev_year, prev_month, prev_odometer = entries[i - 1]\n            if prev_odometer > odometer:\n                return True\n        return False\n\n    def check_service_frequency(entries, min_distance, min_time):\n        for i in range(len(entries) - 1, 0, -1):\n            year, month, odometer = entries[i]\n            prev_year, prev_month, prev_odometer = entries[i - 1]\n            distance = odometer - prev_odometer\n            time_passed = get_months_between((prev_year, prev_month), (year, month))\n            if distance >= min_distance and time_passed >= min_time:\n                return True\n        return False\n\n    lines = stdin.split('\\n')\n    num_entries = int(lines[0])\n    entries = [parse_entry(entry) for entry in lines[1:num_entries + 1]]\n\n    if check_odometer_tampering(entries):\n        return 'tampered odometer'\n\n    min_distance = 2000\n    min_time = 30000 // min_distance\n\n    if not check_service_frequency(entries, min_distance, min_time):\n        return 'insufficient service'\n\n    return 'seems legit' "
    },
    {
        "number": 3002,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered(entries):\n        for i in range(1, len(entries)):\n            _, _, o1 = entries[i - 1]\n            y2, m2, o2 = entries[i]\n            if o2 < o1:\n                return True\n            elif o2 == o1:\n                continue\n            else:\n                distance = o2 - o1\n                if distance > 20000:\n                    return True\n                elif distance < 2000:\n                    return True\n        return False\n\n    def is_serviced(entries):\n        last_service_index = -1\n        for i in range(len(entries)):\n            y, m, o = entries[i]\n            if o % 30000 == 0:\n                last_service_index = i\n            elif y * 12 + m - 1 > last_service_index * 12 + 30:\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    num_entries = int(lines[0])\n    entries = [tuple(map(int, line.split())) for line in lines[1:num_entries + 1]]\n\n    if is_tampered(entries):\n        return 'tampered odometer'\n    elif is_serviced(entries):\n        return 'seems legit'\n    else:\n        return 'insufficient service'"
    },
    {
        "number": 3003,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    graph = [[] for _ in range(N)]\n    \n    for i in range(N):\n        for v in lines[i + 1].split():\n            graph[i].append(int(v))\n    \n    colors = [-1] * N\n    visited = [False] * N\n    \n    def dfs(u, col):\n        visited[u] = True\n        colors[u] = col\n        for v in graph[u]:\n            if not visited[v]:\n                if not dfs(v, 1 - col):\n                    return False\n        return True\n    \n    def is_bipartite():\n        for u in range(N):\n            if not visited[u]:\n                if not dfs(u, 0):\n                    return False\n        return True\n    \n    if is_bipartite():\n        return str(sum(colors[i] == 0 for i in range(N)))\n    else:\n        return str(2)"
    },
    {
        "number": 3003,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    num_vertices = int(lines[0])\n\n    adjacency_list = [[] for _ in range(num_vertices)]\n    for i in range(1, num_vertices + 1):\n        adjacency_list[i - 1] = list(map(int, lines[i].split()))\n\n    def bfs(start_vertex):\n        visited = [False] * num_vertices\n        colors = [-1] * num_vertices\n        colors[start_vertex] = 0\n        queue = [start_vertex]\n\n        while queue:\n            vertex = queue.pop(0)\n            for neighbor in adjacency_list[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    if colors[vertex] == colors[neighbor]:\n                        colors[neighbor] = (colors[neighbor] + 1) % 2\n                    else:\n                        colors[neighbor] = (colors[vertex] + 1) % 2\n                    queue.append(neighbor)\n\n        return max(colors) + 1\n\n    min_colors = num_vertices\n    for i in range(num_vertices):\n        min_colors = min(min_colors, bfs(i))\n\n    return str(min_colors)"
    },
    {
        "number": 3003,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(graph, start_node):\n        visited, queue = set(), [start_node]\n        while queue:\n            node = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)\n        return visited\n\n    def color_graph(graph):\n        color_map = {}\n        for node in range(len(graph)):\n            if node not in color_map:\n                adjacent_colors = set(color_map.get(adjacent) for adjacent in graph[node])\n                for color in range(len(graph)):\n                    if color not in adjacent_colors:\n                        color_map[node] = color\n                        break\n        return len(set(color_map.values()))\n\n    lines = stdin.split('\\n')\n    num_vertices = int(lines[0])\n    graph = {node: set() for node in range(num_vertices)}\n\n    for i in range(1, num_vertices + 1):\n        edges = list(map(int, lines[i].split()))\n        for edge in edges:\n            graph[i - 1].add(edge)\n            graph[edge].add(i - 1)\n\n    return str(color_graph(graph))"
    },
    {
        "number": 3003,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    adj_list = [[] for _ in range(N)]\n    for i in range(1, N):\n        adj_list[i] = list(map(int, lines[i].split()))\n\n    def dfs(u, color):\n        colors[u] = color\n        for v in adj_list[u]:\n            if colors[v] == -1:\n                dfs(v, 1 - color)\n            elif colors[v] == color:\n                return False\n        return True\n\n    def bipartite():\n        for u in range(N):\n            if colors[u] == -1:\n                if not dfs(u, 0):\n                    return False\n        return True\n\n    colors = [-1] * N\n    for u in range(N):\n        if colors[u] == -1:\n            dfs(u, 0)\n\n    if bipartite():\n        return 2\n    else:\n        return 3"
    },
    {
        "number": 3003,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    graph = [set() for _ in range(n)]\n    for i in range(n):\n        for j in map(int, lines[i+1].split()):\n            graph[i].add(j)\n            graph[j].add(i)\n    visited = [False] * n\n    colors = [0] * n\n    max_color = 1\n    for i in range(n):\n        if not visited[i]:\n            visited[i] = True\n            colors[i] = 1\n            stack = [(i, 1)]\n            while stack:\n                j, color = stack.pop()\n                for k in graph[j]:\n                    if not visited[k]:\n                        visited[k] = True\n                        if color == max_color:\n                            max_color += 1\n                        colors[k] = max_color\n                        stack.append((k, max_color))\n    return str(max_color)"
    },
    {
        "number": 3003,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    adj_list = [[] for _ in range(n)]\n    for i in range(1, n + 1):\n        adj_list[i - 1] = list(map(int, lines[i].split()))\n\n    def dfs(u, color):\n        if u == -1:\n            return 0\n        used_colors = set()\n        for v in adj_list[u]:\n            used_colors.add(color[v])\n        for c in range(n):\n            if c not in used_colors:\n                break\n        color[u] = c\n        for v in adj_list[u]:\n            dfs(v, color)\n\n    color = [-1] * n\n    dfs(0, color)\n    return str(max(color) + 1)"
    },
    {
        "number": 3003,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    input_lines = stdin.split('\\n')\n    num_vertices = int(input_lines[0])\n    graph = [[] for _ in range(num_vertices)]\n\n    for i, line in enumerate(input_lines[1:], start=1):\n        for neighbor in map(int, line.split()):\n            graph[i].append(neighbor)\n            graph[neighbor].append(i)\n\n    # Find the minimum number of colors needed\n    color_map = {}\n    available_colors = set(range(num_vertices))\n\n    def dfs(vertex, color):\n        color_map[vertex] = color\n        available_colors.remove(color)\n\n        for neighbor in graph[vertex]:\n            if neighbor not in color_map:\n                dfs(neighbor, next(iter(available_colors.difference({color_map.get(n, None) for n in graph[neighbor]}))))\n\n    dfs(0, 0)\n\n    return str(len(set(color_map.values())))"
    },
    {
        "number": 3003,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    edges = [set() for _ in range(N)]\n\n    for i in range(N):\n        for j in range(len(lines[i + 1].split()) // 2):\n            v = int(lines[i + 1].split()[j * 2])\n            w = int(lines[i + 1].split()[j * 2 + 1])\n            edges[v].add(w)\n            edges[w].add(v)\n\n    color = [-1] * N\n    count = 0\n\n    def dfs(u: int, c: int) -> None:\n        nonlocal count\n        color[u] = c\n        count += 1\n        for v in edges[u]:\n            if color[v] == -1:\n                if c == 0:\n                    dfs(v, 1)\n                else:\n                    dfs(v, 0)\n\n    for i in range(N):\n        if color[i] == -1:\n            dfs(i, 0)\n\n    return str(count)"
    },
    {
        "number": 3003,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    edges = [set() for _ in range(n)]\n\n    for i in range(n):\n        line = lines[i + 1].split()\n        for j in range(len(line)):\n            edges[i].add(int(line[j]))\n\n    def dfs(u: int, visited: set, colors: list) -> int:\n        if u in visited:\n            return colors[u]\n        visited.add(u)\n        color_set = set(range(len(edges)))\n        for v in edges[u]:\n            color_set.remove(dfs(v, visited, colors))\n        color = min(color_set)\n        colors[u] = color\n        return color\n\n    colors = [-1] * n\n    count = len(set(dfs(0, set(), colors)))\n\n    for i in range(1, n):\n        if dfs(i, set(), colors) != -1:\n            count = max(count, len(set(colors)))\n\n    return str(count)"
    },
    {
        "number": 3003,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    graph = {i: [] for i in range(n)}\n    for i in range(1, n + 1):\n        for v in map(int, lines[i].split()):\n            graph[i - 1].append(v)\n\n    visited = [False] * n\n    colors = [0] * n\n    max_color = 0\n\n    def dfs(u):\n        nonlocal max_color\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v)\n                colors[u] = max(colors[u], colors[v] + 1)\n        max_color = max(max_color, colors[u])\n\n    for u in range(n):\n        if not visited[u]:\n            dfs(u)\n\n    return str(max_color)"
    },
    {
        "number": 3004,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_common_range(offer1, offer2):\n        start1, end1 = offer1[1], offer1[2]\n        start2, end2 = offer2[1], offer2[2]\n        common_start = max(start1, start2)\n        common_end = min(end1, end2)\n        if common_start <= common_end:\n            return common_start, common_end\n        return None\n\n    offers = []\n    for i in range(int(stdin.readline())):\n        color, start, end = stdin.readline().strip().split()\n        offers.append((color, int(start), int(end)))\n\n    offers.sort(key=lambda x: (x[1], x[2]))\n\n    selected_offers = []\n    for offer in offers:\n        if not selected_offers or find_common_range(selected_offers[-1], offer) is None:\n            selected_offers.append(offer)\n            if len(selected_offers) > 3:\n                return \"IMPOSSIBLE\"\n\n    if len(selected_offers) == 1:\n        return len(selected_offers)\n\n    last_color = selected_offers[0][0]\n    for offer in selected_offers[1:]:\n        if offer[0] == last_color:\n            return \"IMPOSSIBLE\"\n        last_color = offer[0]\n\n    return len(selected_offers) "
    },
    {
        "number": 3004,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(colors):\n        if len(colors) > 3:\n            return False\n        for c in colors:\n            if colors.count(c) > 1:\n                return False\n        return True\n\n    def dfs(offers, section, color):\n        if section > 10000:\n            return 0\n        if (section, color) in memo:\n            return memo[(section, color)]\n\n        memo[(section, color)] = float('inf')\n        for i, offer in enumerate(offers):\n            if section in offer[1:]:\n                continue\n            if offer[0] != color:\n                new_color = offer[0]\n            else:\n                new_color = color\n            memo[(section, color)] = min(memo[(section, color)], 1 + dfs(offers[:i] + offers[i+1:], section + 1, new_color))\n\n        return memo[(section, color)]\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    offers = []\n    for i in range(1, N+1):\n        offers.append(lines[i].split())\n\n    colors = list(set([offer[0] for offer in offers]))\n    if not is_valid(colors):\n        return \"IMPOSSIBLE\"\n\n    memo = {}\n    ans = dfs(offers, 1, colors[0])\n    if ans == float('inf'):\n        return \"IMPOSSIBLE\"\n    return str(ans)"
    },
    {
        "number": 3004,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n', 1)[0])\n    offers = []\n    for offer in stdin.split('\\n')[1:]:\n        offers.append(offer.split())\n\n    offers.sort(key=lambda x: int(x[1]))\n\n    color_count = {}\n    last_color = ''\n    accepted_offers = 0\n\n    for offer in offers:\n        if offer[0] not in color_count:\n            color_count[offer[0]] = 1\n        else:\n            color_count[offer[0]] += 1\n\n        if offer[0] != last_color and len(color_count) <= 3 and int(offer[2]) - int(offer[1]) + 1 == 10000 - int(offer[1]) + 1:\n            accepted_offers += 1\n            last_color = offer[0]\n        elif offer[0] == last_color and int(offer[2]) - int(offer[1]) + 1 == 10000 - int(offer[1]) + 1:\n            accepted_offers += 1\n            last_color = offer[0]\n\n    return str(accepted_offers) if accepted_offers == 1 else \"IMPOSSIBLE\""
    },
    {
        "number": 3004,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def merge(intervals):\n        if not intervals:\n            return 0\n\n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n\n        for interval in intervals[1:]:\n            if merged[-1][1] >= interval[0]:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n            else:\n                merged.append(interval)\n\n        return len(merged)\n\n    lines = stdin.split('\\n')\n    offers = []\n    for line in lines[1:]:\n        if line:\n            offers.append(line.split())\n\n    colors = set()\n    sections = []\n    for offer in offers:\n        colors.add(offer[0])\n        sections.append([int(offer[1]), int(offer[2])])\n\n    if len(colors) > 3:\n        return \"IMPOSSIBLE\"\n\n    merged_sections = merge(sections)\n    if merged_sections != 1:\n        return \"IMPOSSIBLE\"\n\n    return str(len(offers))"
    },
    {
        "number": 3004,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def paint_fence(offers):\n        offers.sort(key=lambda x: x[1])\n        sections = [False] * (10001)\n        colors = []\n\n        for offer in offers:\n            color, start, end = offer\n            if not any(sections[start:end + 1]):\n                sections[start:end + 1] = [True] * (end - start + 1)\n                if color not in colors:\n                    colors.append(color)\n\n        return len(colors) <= 3 and all(sections)\n\n    def backtrack(offers, index, colors_used, current_offer):\n        if colors_used > 3:\n            return False\n\n        if index == len(offers):\n            if colors_used <= 3 and all(current_offer[i] or current_offer[i + 1] for i in range(1, 10000)):\n                return True\n            else:\n                return False\n\n        for i in range(index, len(offers)):\n            color, start, end = offers[i]\n            if not any(current_offer[start:end + 1]):\n                current_offer[start:end + 1] = [True] * (end - start + 1)\n                if color not in colors_used:\n                    colors_used.add(color)\n                result = backtrack(offers, i + 1, colors_used, current_offer)\n                if result:\n                    return True\n                colors_used.discard(color)\n                current_offer[start:end + 1] = [False] * (end - start + 1)\n\n        return False\n\n    lines = stdin.split('\\n')\n    offers = []\n    for i in range(1, len(lines), 1):\n        offers.append(tuple(lines[i].split()))\n\n    if paint_fence(offers):\n        return str(len(offers))\n    else:\n        if backtrack(offers, 0, set(), [False] * 10001):\n            return \"IMPOSSIBLE\"\n        else:\n            return str(len(offers)) "
    },
    {
        "number": 3004,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(colors: list, offers: list) -> bool:\n        if len(colors) > 3:\n            return False\n\n        sections = set(range(1, 10001))\n        for color, start, end in offers:\n            if color in colors:\n                if start not in sections or end not in sections:\n                    return False\n                for i in range(start, end + 1):\n                    sections.remove(i)\n            else:\n                return False\n\n        return len(sections) == 0\n\n    def min_offers(offers: list, colors: list, current_offer: int, current_colors: set, count: int) -> int:\n        if current_offer == len(offers):\n            if is_valid(list(current_colors), offers):\n                return count\n            else:\n                return float('inf')\n\n        next_offer = current_offer + 1\n        min_count = float('inf')\n\n        if len(current_colors) < 3:\n            for color in set(offers[current_offer][0]):\n                if color not in current_colors:\n                    current_colors.add(color)\n                    min_count = min(min_count, min_offers(offers, colors, next_offer, current_colors, count + 1))\n                    current_colors.remove(color)\n\n        min_count = min(min_count, min_offers(offers, colors, next_offer, current_colors, count))\n\n        return min_count\n\n    lines = stdin.split('\\n')\n    offers_count = int(lines[0])\n    offers = [line.split() for line in lines[1:offers_count + 1]]\n\n    colors = set()\n    for offer in offers:\n        colors.add(offer[0])\n\n    if len(colors) > 3:\n        return 'IMPOSSIBLE'\n\n    min_count = min_offers(offers, colors, 0, set(), 0)\n\n    if min_count == float('inf'):\n        return 'IMPOSSIBLE'\n\n    return str(min_count)"
    },
    {
        "number": 3004,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def paint_fence(offers, colors_used):\n        if not offers or colors_used == 3:\n            return 0\n        offer = offers[0]\n        remaining_offers = offers[1:]\n        color, start, end = offer\n        if color not in colors:\n            colors_used += 1\n        if start == 1 and end == 10000:\n            return 1 + paint_fence(remaining_offers, colors_used)\n        else:\n            if start > 1:\n                new_offer = (color, 1, start - 1)\n                remaining_offers.append(new_offer)\n            if end < 10000:\n                new_offer = (color, end + 1, 10000)\n                remaining_offers.append(new_offer)\n            return 1 + paint_fence(remaining_offers, colors_used)\n\n    N = int(stdin.readline().strip())\n    offers = []\n    for _ in range(N):\n        color, start, end = stdin.readline().strip().split()\n        offers.append((color, int(start), int(end)))\n\n    colors = set()\n    for offer in offers:\n        color, _, _ = offer\n        colors.add(color)\n\n    if len(colors) > 3:\n        return \"IMPOSSIBLE\"\n\n    offers.sort(key=lambda x: (x[1], x[2]))\n    result = paint_fence(offers, 0)\n    return str(result) if result != 0 else \"IMPOSSIBLE\""
    },
    {
        "number": 3004,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def merge(intervals):\n        if not intervals:\n            return 0\n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n        for interval in intervals[1:]:\n            if merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        return merged\n\n    def is_valid(intervals):\n        colors = set()\n        for interval in intervals:\n            colors.add(interval[2])\n        return len(colors) <= 3\n\n    def min_offers(intervals, sections, i, j, memo):\n        if i > j:\n            return 0\n        if (i, j) in memo:\n            return memo[(i, j)]\n        min_count = float(\"inf\")\n        for k in range(i, j):\n            if sections[i:k + 1] + sections[k + 1:j + 1] == sorted(sections):\n                count = 1 + min_offers(intervals, sections, i, k, memo) + min_offers(intervals, sections, k + 1, j, memo)\n                min_count = min(min_count, count)\n        memo[(i, j)] = min_count\n        return min_count\n\n    lines = stdin.split(\"\\n\")\n    offers = []\n    sections = set()\n\n    for i in range(1, int(lines[0]) + 1):\n        color, start, end = lines[i].split(\" \")\n        start = int(start)\n        end = int(end)\n        offers.append((start, end, color))\n        for j in range(start, end + 1):\n            sections.add(j)\n\n    sections = sorted(list(sections))\n    merged_offers = merge(offers)\n\n    if not is_valid(merged_offers):\n        return \"IMPOSSIBLE\"\n\n    return str(min_offers(merged_offers, sections, 0, len(sections) - 1, {}))"
    },
    {
        "number": 3004,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_subset(painters, color_count):\n        for i in range(len(painters)):\n            for j in range(i + 1, len(painters)):\n                if painters[i][1] > painters[j][0] or painters[i][0] > painters[j][1]:\n                    continue\n                if painters[i][2] == painters[j][2]:\n                    return True\n                if color_count < 3:\n                    color_count += 1\n                    return is_valid_subset(painters[:i] + painters[i + 1:j] + painters[j + 1:], color_count)\n        return False\n\n    def dfs(painters, offers_accepted, color_count):\n        if not painters:\n            return offers_accepted\n        for i in range(len(painters)):\n            if is_valid_subset(painters[:i] + painters[i + 1:], color_count):\n                if dfs(painters[:i] + painters[i + 1:], offers_accepted + [painters[i]], color_count + 1):\n                    return True\n        return False\n\n    N = int(stdin.readline().strip())\n    painters = []\n    for _ in range(N):\n        color, start, end = stdin.readline().strip().split()\n        painters.append((int(start), int(end), color))\n\n    painters.sort()\n    if dfs(painters, [], 0):\n        return str(len(painters))\n    else:\n        return \"IMPOSSIBLE\" "
    },
    {
        "number": 3004,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def overlap(offer1, offer2):\n        return not (offer1[1] < offer2[0] or offer1[0] > offer2[1])\n\n    def merge_offer(offer1, offer2):\n        return (offer1[0], min(offer1[2], offer2[2]), offer1[1], offer1[3], offer1[4] + offer2[4])\n\n    def paint_fence(offers):\n        offers.sort(key=lambda x: x[0])\n        merged_offers = [offers[0]]\n\n        for i in range(1, len(offers)):\n            if overlap(merged_offers[-1], offers[i]):\n                merged_offers[-1] = merge_offer(merged_offers[-1], offers[i])\n            else:\n                merged_offers.append(offers[i])\n\n        return merged_offers\n\n    def find_min_offers(offers):\n        colors = {}\n        for offer in offers:\n            if offer[1] not in colors:\n                colors[offer[1]] = set()\n            colors[offer[1]].add(offer[0])\n\n        min_offers = len(offers)\n        for color in colors.values():\n            if len(color) > 3:\n                return \"IMPOSSIBLE\"\n            min_offers = min(min_offers, len(color))\n\n        return min_offers\n\n    offers = []\n    for line in stdin.split('\\n')[1:]:\n        color, first, last = line.split()\n        offers.append((color, int(first), int(last)))\n\n    merged_offers = paint_fence(offers)\n    min_offers = find_min_offers(merged_offers)\n\n    return str(min_offers) "
    },
    {
        "number": 3005,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_factoring_weight(s: str) -> int:\n        if not s:\n            return 0\n        for i in range(1, len(s) // 2 + 1):\n            if s[:i] * (len(s) // i) == s:\n                return i + get_factoring_weight(s[i:])\n        return len(s)\n\n    def get_maximal_factoring_weight(s: str) -> int:\n        min_weight = float('inf')\n        for i in range(1, len(s) // 2 + 1):\n            if s[:i] * (len(s) // i) == s:\n                weight = get_factoring_weight(s[i:])\n                if weight < min_weight:\n                    min_weight = weight\n        return min_weight + len(s)\n\n    return str(get_maximal_factoring_weight(stdin))"
    },
    {
        "number": 3005,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def max_weight(s):\n        n = len(s)\n        memo = [0] * n\n        for i in range(n):\n            for j in range(i, n):\n                if s[i:j + 1] == s[j + 1:i:-1]:\n                    memo[j] = max(memo[j], j - i + 1)\n        return max(memo)\n\n    def factor(s):\n        n = len(s)\n        memo = [0] * n\n        for i in range(n):\n            for j in range(i, n):\n                if s[i:j + 1] == s[j + 1:i:-1]:\n                    memo[j] = max(memo[j], memo[i - 1] + j - i + 1)\n        return memo[-1]\n\n    def find_max_weight(s):\n        weight = 0\n        for i in range(len(s)):\n            weight = max(weight, max_weight(s[:i + 1]) + max_weight(s[i + 1:]))\n        return weight\n\n    def find_max_factor(s):\n        n = len(s)\n        memo = [0] * n\n        for i in range(n):\n            for j in range(i, n):\n                if s[i:j + 1] == s[j + 1:i:-1]:\n                    memo[j] = max(memo[j], memo[i - 1] + j - i + 1)\n        return memo[-1]\n\n    max_weight_value = find_max_weight(stdin)\n    max_factor_value = find_max_factor(stdin)\n\n    return min(max_weight_value, max_factor_value)"
    },
    {
        "number": 3005,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def maximal_factoring_weight(s):\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i:j] == s[j:2 * j - i] and j - i <= 2 * j - i:\n                    dp[i][j] = dp[j][2 * j - i] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[j][j])\n        return dp[0][n - 1]\n\n    return str(maximal_factoring_weight(stdin))"
    },
    {
        "number": 3005,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_repeating_substring(s):\n        for length in range(len(s) // 2, 0, -1):\n            for i in range(len(s) - 2 * length + 1):\n                substring = s[i:i + length]\n                if s.count(substring) >= 2:\n                    return substring\n        return \"\"\n\n    def factor_string(s, factor):\n        factorings = []\n        i = 0\n        while i < len(s):\n            if s[i:i + len(factor)] == factor:\n                count = 1\n                i += len(factor)\n                while i < len(s) and s[i:i + len(factor)] == factor:\n                    count += 1\n                    i += len(factor)\n                factorings.append((factor, count))\n            else:\n                i += 1\n        return factorings\n\n    def weight(factoring):\n        weight = 0\n        for factor, count in factoring:\n            weight += len(factor) * count\n        return weight\n\n    def find_minimal_factoring(s):\n        for length in range(1, len(s) // 2 + 1):\n            for i in range(len(s) - 2 * length + 1):\n                substring = s[i:i + length]\n                factorings = factor_string(s, substring)\n                for factoring in factorings:\n                    if weight(factoring) <= weight(find_minimal_factoring(substring)):\n                        return factoring\n        return []\n\n    longest_substring = find_longest_repeating_substring(stdin)\n    minimal_factoring = find_minimal_factoring(longest_substring)\n    return str(weight(minimal_factoring))"
    },
    {
        "number": 3005,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_weight(s):\n        if len(s) < 2:\n            return 1\n        for i in range(1, len(s) // 2 + 1):\n            if s[:i] == s[i:2 * i] and find_max_weight(s[i:]) == 1:\n                return i\n        return 1\n\n    return str(find_max_weight(stdin))"
    },
    {
        "number": 3005,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def factor_string(s, start=0, factoring=None):\n        if factoring is None:\n            factoring = []\n\n        for i in range(start, len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if s[start:j] == s[i:j]:\n                    continue\n\n                if len(factoring) == 0:\n                    factoring.append(s[start:j])\n                elif s[start:j] == factoring[-1]:\n                    factoring.append(s[start:j])\n                else:\n                    new_factoring = factor_string(s, j, factoring)\n                    if len(new_factoring) < len(factoring):\n                        factoring = new_factoring\n\n        return factoring\n\n    def count_irreducible_factorings(s):\n        factorings = []\n        for i in range(len(s) // 2, 0, -1):\n            if len(s) % i == 0:\n                substring = s[:i]\n                if substring * (len(s) // len(substring)) == s:\n                    factorings.append((substring, len(s) // len(substring)))\n\n        return factorings\n\n    def count_weight(factoring):\n        weight = 0\n        for factor in factoring:\n            weight += len(factor[0]) * factor[1]\n\n        return weight\n\n    factorings = count_irreducible_factorings(stdin)\n    weights = [count_weight(factoring) for factoring in factorings]\n\n    return str(min(weights))"
    },
    {
        "number": 3005,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def factor(substring):\n        n = len(stdin) // len(substring)\n        if stdin == substring * n:\n            return n, substring\n        return None\n\n    def factorize(s):\n        for i in range(1, len(s) // 2 + 1):\n            if len(s) % i == 0:\n                if factor(s[:i]):\n                    return factor(s[:i]), factorize(s[i:])\n        return None, None\n\n    def weigh(factoring):\n        weight = 0\n        for n, substring in factoring:\n            weight += len(str(n)) + len(substring)\n        return weight\n\n    def find_minimal_factorization(s):\n        min_weight = float('inf')\n        min_factoring = None\n        for i in range(1, len(s) + 1):\n            for j in range(i, len(s) + 1):\n                if j - i >= 2:\n                    factoring = factorize(s[i:j])\n                    if factoring[0] is not None:\n                        weight = weigh(factoring)\n                        if weight < min_weight:\n                            min_weight = weight\n                            min_factoring = factoring\n        return min_factoring\n\n    minimal_factoring = find_minimal_factorization(stdin)\n    return str(weigh(minimal_factoring))"
    },
    {
        "number": 3005,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_factorization(s):\n        i = 2\n        while i <= len(s) // 2:\n            if len(s) % i == 0:\n                if s[:i] * (len(s) // i) == s:\n                    return s[:i], len(s) // i\n            i += 1\n        return s, 1\n\n    def get_maximal_factorization(s):\n        while True:\n            factor, count = get_factorization(s)\n            if count == 1:\n                return factor\n            s = s.replace(factor * count, f\"({factor})^({count})\")\n\n    def get_weight(factorization):\n        return len(factorization) - factorization.count(\"(\") - factorization.count(\")\")\n\n    return str(get_weight(get_maximal_factorization(stdin)))"
    },
    {
        "number": 3005,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Define a recursive function to find the maximal factoring\n    def find_max_factoring(s, start, end, max_factoring, max_weight):\n        # If we have reached the end of the string, return the current max_factoring and weight\n        if start == end:\n            return max_factoring, max_weight\n\n        # Check if the current substring can be factored\n        for i in range(start + 1, end + 1):\n            if s[start:i] == s[i:2 * i - start]:\n                # If the substring can be factored, recursively find the factoring of the rest of the string\n                factoring, weight = find_max_factoring(s, 2 * i - start, end, max_factoring, max_weight)\n\n                # If the factoring is valid and has a smaller weight than the current max_weight, update max_factoring and max_weight\n                if weight < max_weight and i != start + 1:\n                    max_factoring = s[start:i] + \"(\" + factoring + \")\" + s[2 * i - start:end]\n                    max_weight = weight + i - start\n\n        # If the substring cannot be factored, return the current max_factoring and weight\n        return max_factoring, max_weight\n\n    # Call the recursive function to find the maximal factoring\n    max_factoring, max_weight = find_max_factoring(stdin, 0, len(stdin), \"\", float(\"inf\"))\n\n    # Return the weight of the maximal factoring\n    return max_weight "
    },
    {
        "number": 3005,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def factor(s):\n        for i in range(1, len(s) // 2 + 1):\n            if len(s) % i == 0 and s[:i] * (len(s) // i) == s:\n                return i\n        return 0\n\n    def weigh(f):\n        return sum(len(f[i]) + len(str(f[i + 1])) for i in range(0, len(f), 2)) - 1\n\n    def find_max_factoring(s):\n        max_weight = len(s)\n        for i in range(1, factor(s) + 1):\n            if len(s) % i == 0:\n                f = s[:i] * (len(s) // i)\n                if weigh([f]) < max_weight:\n                    max_weight = weigh([f])\n        return max_weight\n\n    return str(find_max_factoring(stdin))\n"
    },
    {
        "number": 3006,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def process_program(program):\n        stack = []\n        for line in program:\n            if line[0] == \"D\":\n                p = int(line.split()[1])\n                stack.append((\"D\", p))\n            elif line[0] == \"I\":\n                p, c = map(str.strip, line.split()[1:])\n                stack.append((\"I\", int(p), c))\n        return stack\n\n    def compare_programs(program1, program2):\n        if len(program1) != len(program2):\n            return False\n        for op1, op2 in zip(program1, program2):\n            if op1[0] != op2[0] or op1[1:] != op2[1:]:\n                return False\n        return True\n\n    program1, program2 = stdin.split(\"\\nE\\n\")\n    program1 = process_program(program1.split(\"\\n\"))\n    program2 = process_program(program2.split(\"\\n\"))\n\n    return \"0\" if compare_programs(program1, program2) else \"1\""
    },
    {
        "number": 3006,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def parse_operation(line: str) -> tuple:\n        op, *args = line.split()\n        if op == 'I':\n            return (op, int(args[0]), args[1])\n        elif op == 'D':\n            return (op, int(args[0]))\n        else:\n            return (op,)\n\n    def compare_programs(prog1: list, prog2: list) -> bool:\n        i = j = 0\n        while i < len(prog1) and j < len(prog2):\n            if prog1[i] != prog2[j]:\n                return False\n            i += 1\n            j += 1\n        return i == len(prog1) and j == len(prog2)\n\n    programs = stdin.split('\\n\\n')\n    prog1 = list(map(parse_operation, programs[0].split('\\n')))\n    prog2 = list(map(parse_operation, programs[1].split('\\n')))\n\n    return str(int(not compare_programs(prog1, prog2)))"
    },
    {
        "number": 3006,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def process_ins(operation, index, char, operations):\n        if index > len(operations):\n            operations.extend([None] * (index - len(operations) + 1))\n        operations[index - 1] = (operation, char)\n\n    def process_del(operation, index, operations):\n        if index > len(operations):\n            operations.extend([None] * (index - len(operations) + 1))\n        for i in range(index - 1, len(operations)):\n            if operations[i] is not None:\n                operations[i][0] = 'I'\n                operations[i][1] = chr(ord(operations[i][1]) - 1)\n                operations[i] = ('I', operations[i][1])\n            else:\n                break\n        del operations[index - 1]\n\n    def apply_operations(program1, program2):\n        for i in range(len(program1)):\n            if program1[i] != program2[i]:\n                return False\n        return True\n\n    def process_program(program):\n        operations = []\n        for line in program:\n            if line[0] == 'I':\n                index, char = int(line.split()[1]), line.split()[2]\n                process_ins('I', index, char, operations)\n            elif line[0] == 'D':\n                index = int(line.split()[1])\n                process_del('D', index, operations)\n        return operations\n\n    programs = stdin.strip().split('\\n\\n')\n    program1 = programs[0].split('\\n')[:-1]\n    program2 = programs[1].split('\\n')[:-1]\n\n    operations1 = process_program(program1)\n    operations2 = process_program(program2)\n\n    return '0' if apply_operations(operations1, operations2) else '1'"
    },
    {
        "number": 3006,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> list:\n        operations = []\n        for line in input_str.split('\\n'):\n            if line.startswith('E'):\n                break\n            operation, *args = line.split()\n            if operation == 'D':\n                operations.append(('D', int(args[0])))\n            elif operation == 'I':\n                operations.append(('I', int(args[0]), args[1]))\n        return operations\n\n    def compare_programs(program1: list, program2: list) -> bool:\n        if len(program1) != len(program2):\n            return False\n        for operation1, operation2 in zip(program1, program2):\n            if operation1 != operation2:\n                return False\n        return True\n\n    program1, program2 = stdin.split('\\n\\n')\n    program1 = parse_input(program1)\n    program2 = parse_input(program2)\n\n    if compare_programs(program1, program2):\n        return '0'\n    else:\n        return '1'"
    },
    {
        "number": 3006,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def apply_operation(program1, program2):\n        for op1, op2 in zip(program1, program2):\n            if op1 != op2:\n                return False\n        return True\n\n    program1 = []\n    program2 = []\n\n    for line in stdin.split('\\n'):\n        if line[0] == 'E':\n            break\n        if line[0] == 'I':\n            pos, char = line.split()[1:]\n            program1.append(('I', int(pos), char))\n            program2.append(('I', int(pos), char))\n        elif line[0] == 'D':\n            pos = line.split()[1]\n            program1.append(('D', int(pos)))\n            program2.append(('D', int(pos)))\n\n    return '0' if apply_operation(program1, program2) else '1'"
    },
    {
        "number": 3006,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def parse_operation(line: str) -> tuple:\n        operation, *args = line.split()\n        if operation == 'D':\n            return ('D', int(args[0]))\n        elif operation == 'I':\n            return ('I', int(args[0]), args[1])\n        else:\n            return ('E',)\n\n    def compare_programs(ops1: list, ops2: list) -> bool:\n        if len(ops1) != len(ops2):\n            return False\n        \n        for op1, op2 in zip(ops1, ops2):\n            if op1 != op2:\n                return False\n        \n        return True\n\n    def apply_operation(op: tuple, dna: list) -> list:\n        if op[0] == 'D':\n            del dna[op[1] - 1]\n        elif op[0] == 'I':\n            dna.insert(op[1] - 1, op[2])\n\n        return dna\n\n    def run_program(ops: list) -> list:\n        dna = []\n        for op in ops:\n            if op[0] == 'E':\n                break\n            dna = apply_operation(op, dna)\n\n        return dna\n\n    stdin_list = stdin.strip().split('\\n')\n    program1 = [parse_operation(line) for line in stdin_list[0].split('\\n')]\n    program2 = [parse_operation(line) for line in stdin_list[1].split('\\n')]\n\n    dna1 = run_program(program1)\n    dna2 = run_program(program2)\n\n    return '0' if dna1 == dna2 else '1' "
    },
    {
        "number": 3006,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def process_program(program):\n        operations = []\n        for line in program.split('\\n'):\n            if line[0] == 'D':\n                operations.append(('D', int(line.split()[1])))\n            elif line[0] == 'I':\n                operations.append(('I', int(line.split()[1]), line.split()[2]))\n        return operations\n\n    program1, program2 = stdin.split('\\n\\n')\n    ops1 = process_program(program1)\n    ops2 = process_program(program2)\n\n    if len(ops1) != len(ops2):\n        return '1'\n\n    for op1, op2 in zip(ops1, ops2):\n        if op1 != op2:\n            return '1'\n\n    return '0'"
    },
    {
        "number": 3006,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def compare_programs(p1, p2):\n        i = 0\n        j = 0\n        while i < len(p1) and j < len(p2):\n            if p1[i][0] == p2[j][0]:\n                if p1[i][0] == 'I':\n                    if p1[i][1] == p2[j][1] and p1[i][2] == p2[j][2]:\n                        i += 1\n                        j += 1\n                    else:\n                        return False\n                elif p1[i][0] == 'D':\n                    if p1[i][1] == p2[j][1]:\n                        i += 1\n                        j += 1\n                    else:\n                        return False\n            else:\n                return False\n        if i < len(p1) or j < len(p2):\n            return False\n        return True\n\n    stdin = stdin.split('\\n')\n    i = 0\n    program1 = []\n    program2 = []\n    while i < len(stdin):\n        if stdin[i] == 'E':\n            break\n        if stdin[i][0] == 'I':\n            program1.append(('I', int(stdin[i].split()[1]), stdin[i].split()[2]))\n        else:\n            program1.append(('D', int(stdin[i].split()[1])))\n        i += 1\n\n    while i < len(stdin):\n        if stdin[i] == 'E':\n            break\n        if stdin[i][0] == 'I':\n            program2.append(('I', int(stdin[i].split()[1]), stdin[i].split()[2]))\n        else:\n            program2.append(('D', int(stdin[i].split()[1])))\n        i += 1\n\n    if compare_programs(program1, program2):\n        return '0'\n    else:\n        return '1'"
    },
    {
        "number": 3006,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def apply_operation(operation: str, program: str, index: int) -> str:\n        if operation == \"D\":\n            return program[:index - 1] + program[index:]\n        elif operation == \"I\":\n            return program[:index] + program[index + 1:]\n\n    def parse_operation(line: str) -> tuple:\n        operation, value = line.split()\n        if operation == \"D\":\n            return \"D\", int(value)\n        elif operation == \"I\":\n            index, char = value.split()\n            return \"I\", int(index), char\n        else:\n            return None, None, None\n\n    program1 = \"\"\n    program2 = \"\"\n\n    lines1 = stdin.split(\"\\n\")\n    lines2 = lines1[len(lines1) // 2:]\n    lines1 = lines1[:len(lines1) // 2]\n\n    for line in lines1:\n        operation, index, char = parse_operation(line)\n        if operation == \"D\":\n            program1 = apply_operation(operation, program1, index)\n        elif operation == \"I\":\n            program1 = apply_operation(operation, program1 + char, index)\n\n    for line in lines2:\n        operation, index, char = parse_operation(line)\n        if operation == \"D\":\n            program2 = apply_operation(operation, program2, index)\n        elif operation == \"I\":\n            program2 = apply_operation(operation, program2 + char, index)\n\n    return \"0\" if program1 == program2 else \"1\" "
    },
    {
        "number": 3006,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def apply_operation(operation: str, long_string: str, index: int, char: str = \"\") -> str:\n        if operation == \"D\":\n            return long_string[:index - 1] + long_string[index:]\n        elif operation == \"I\":\n            return long_string[:index - 1] + char + long_string[index - 1:]\n        else:\n            return long_string\n\n    def compare_programs(program1: list, program2: list) -> bool:\n        long_string = \"A\" * 10**10\n        for operation in program1:\n            long_string = apply_operation(operation[0], long_string, int(operation[1:]), \"\" if operation[0] == \"D\" else operation[-1])\n        end_string1 = long_string\n\n        long_string = \"A\" * 10**10\n        for operation in program2:\n            long_string = apply_operation(operation[0], long_string, int(operation[1:]), \"\" if operation[0] == \"D\" else operation[-1])\n        end_string2 = long_string\n\n        return end_string1 == end_string2\n\n    lines = stdin.split(\"\\n\")\n    programs = []\n    current_program = []\n    for line in lines:\n        if line == \"E\":\n            programs.append(current_program)\n            current_program = []\n        else:\n            current_program.append(line)\n\n    result = \"1\"\n    for i in range(len(programs) - 1):\n        if compare_programs(programs[i], programs[i + 1]):\n            result = \"0\"\n            break\n\n    return result"
    },
    {
        "number": 3007,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # If there are no fruits or trees, there is nothing to be done\n    if f == 0 and t0 == 0 and t1 == 0 and t2 == 0:\n        return str(b)\n\n    # Calculate the maximum amount of Bling we can get by selling all fruits and planting fruit trees\n    max_bling = f * 100 + t0 * 100 + t1 * 100 + t2 * 100\n\n    # If there is no time left, we can't do anything\n    if d == 0:\n        return str(max_bling)\n\n    # If there is only one day left, we can sell all fruits and plant fruit trees\n    if d == 1:\n        return str(max_bling)\n\n    # Calculate the maximum amount of Bling we can get by selling all fruits and planting fruit trees\n    max_bling = f * 100 + t0 * 100 + t1 * 100 + t2 * 100\n\n    # Calculate the maximum amount of Bling we can get by buying an exotic fruit and planting it\n    if d > 1:\n        max_bling = max(max_bling, 400 + f * 100 + t0 * 100 + t1 * 100 + t2 * 100)\n\n    # Calculate the maximum amount of Bling we can get by buying an exotic fruit and selling it\n    if d > 3:\n        max_bling = max(max_bling, 500 + f * 100 + t0 * 100 + t1 * 100 + t2 * 100)\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Check if it is possible to buy an exotic fruit\n    if b >= 400 and d > 0:\n        b += 500\n        d -= 1\n\n    # Calculate the maximum Bling that can be achieved in the remaining days\n    max_bling = b + f * 100 + t0 * 100 + t1 * 100 + t2 * 100\n\n    # Update the fruit trees crop\n    t0 += 1\n    t1 += 1\n    t2 += 1\n\n    # Harvest the fruits from the trees\n    harvested_fruits = t0 // 3 + t1 // 3 + t2 // 3\n\n    # Sell the harvested fruits\n    max_bling += harvested_fruits * 100\n\n    # Plant the harvested fruits\n    t0 += harvested_fruits\n    t1 += harvested_fruits\n    t2 += harvested_fruits\n\n    # Repeat the process for the remaining days\n    for _ in range(d - 1):\n        # Update the fruit trees crop\n        t0 += 1\n        t1 += 1\n        t2 += 1\n\n        # Harvest the fruits from the trees\n        harvested_fruits = t0 // 3 + t1 // 3 + t2 // 3\n\n        # Sell the harvested fruits\n        max_bling += harvested_fruits * 100\n\n        # Plant the harvested fruits\n        t0 += harvested_fruits\n        t1 += harvested_fruits\n        t2 += harvested_fruits\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    total_fruit = f\n    total_bling = b\n    days_left = d\n\n    def sell_fruit(fruit_count, bling_amount):\n        return fruit_count * 100 + bling_amount\n\n    def plant_fruit(fruit_count, bling_amount, days_left):\n        if days_left >= 3:\n            new_trees = min(fruit_count // 3, (500 - bling_amount) // 100)\n            fruit_count -= new_trees * 3\n            bling_amount += new_trees * 100\n            return fruit_count, bling_amount\n        return fruit_count, bling_amount\n\n    def plant_exotic_fruit(fruit_count, bling_amount, days_left):\n        if days_left >= 3:\n            new_trees = min(fruit_count // 3, (500 - bling_amount) // 500)\n            fruit_count -= new_trees * 3\n            bling_amount += new_trees * 500\n            return fruit_count, bling_amount\n        return fruit_count, bling_amount\n\n    def buy_exotic_fruit(fruit_count, bling_amount):\n        return fruit_count, bling_amount + 400\n\n    while days_left > 0:\n        # Sell fruit\n        total_bling += sell_fruit(total_fruit, total_bling)\n\n        # Plant fruit\n        total_fruit, total_bling = plant_fruit(total_fruit, total_bling, days_left)\n\n        # Plant exotic fruit\n        total_fruit, total_bling = plant_exotic_fruit(total_fruit, total_bling, days_left)\n\n        # Buy exotic fruit\n        if days_left >= 3:\n            total_fruit, total_bling = buy_exotic_fruit(total_fruit, total_bling)\n            days_left -= 3\n        else:\n            days_left -= 1\n\n    return str(total_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Harvest fruits from existing trees\n    fruits_harvested = (t0 + t1 + t2) * 3\n    f += fruits_harvested\n\n    # Plant trees if possible\n    trees_planted = min(f // 100, (40 - d) // 3)\n    f -= trees_planted * 100\n\n    # Buy exotic fruit if possible\n    if d > 3 and b >= 400:\n        b -= 400\n        f += 500\n\n    # Calculate total Bling\n    total_bling = b + f * 100 + trees_planted * 300\n\n    return str(total_bling)\n"
    },
    {
        "number": 3007,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    # Sell fruits\n    b += f * 100\n\n    # Calculate the amount of Bling from fruit trees\n    total_trees = t0 + t1 + t2\n    days_to_next_crop = min(t0, 3) + min(t1, 3) + min(t2, 3)\n    if total_trees > 0:\n        days_until_max_crop = (d - days_to_next_crop) // 3 * 3\n    else:\n        days_until_max_crop = 0\n\n    max_crop = (t0 + t1 + t2) * (days_until_max_crop // 3)\n    remaining_days = d - days_to_next_crop - days_until_max_crop\n    remaining_crop = (t0 + t1 + t2) * (remaining_days // 3)\n\n    b += max_crop * 100 + remaining_crop * 100\n\n    # Buy exotic fruit\n    if b >= 400:\n        b -= 400\n        b += 500\n\n    return str(b)"
    },
    {
        "number": 3007,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    def crop_fruits(trees):\n        fruits = sum(trees)\n        for i in range(len(trees)):\n            if trees[i] > 0:\n                trees[i] -= 1\n                if i == 0:\n                    fruits += 1\n                elif i == 1:\n                    fruits += 3\n                else:\n                    fruits += 5\n        return fruits\n\n    max_bling = b\n    for i in range(1, d + 1):\n        if i % 3 == 0 and t0 > 0:\n            f += crop_fruits([t0, t1, t2]) * 2\n            t0 -= 1\n            t1 += 1\n        b = max(0, b - 400) + f * 100\n        max_bling = max(max_bling, b)\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    def can_buy_exotic_fruit(b):\n        return b >= 400\n\n    def plant_fruit_trees(f, t0, t1, t2):\n        for i in range(3):\n            if t0 == i:\n                f += 3\n            if t1 == i:\n                f += 3\n            if t2 == i:\n                f += 3\n        return f\n\n    def sell_fruits(f):\n        return f * 100\n\n    def plant_exotic_fruit_trees(b, t0, t1, t2):\n        for i in range(3):\n            if t0 == i:\n                b -= 400\n            if t1 == i:\n                b -= 400\n            if t2 == i:\n                b -= 400\n        return b\n\n    def sell_exotic_fruit(b, t0, t1, t2):\n        for i in range(3):\n            if t0 == i:\n                b += 500\n            if t1 == i:\n                b += 500\n            if t2 == i:\n                b += 500\n        return b\n\n    max_bling = b\n\n    for _ in range(d):\n        b = sell_fruits(f) + b\n        f = 0\n        b = plant_exotic_fruit_trees(b, t0, t1, t2)\n        b = sell_exotic_fruit(b, t0, t1, t2)\n        f = plant_fruit_trees(f, t0, t1, t2)\n        if can_buy_exotic_fruit(b):\n            b -= 400\n            f += 1\n        max_bling = max(max_bling, b)\n        t0 += 1\n        t0 %= 3\n        t1 += 1\n        t1 %= 3\n        t2 += 1\n        t2 %= 3\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    \n    # Calculate maximum amount of Bling you can earn in the remaining time\n    max_bling = b + d * f * 100\n    if t0 > 0:\n        max_bling += (d - 1) // 3 * 3 * t0 * 100\n    if t1 > 0:\n        max_bling += (d - 2) // 3 * 3 * t1 * 100\n    if t2 > 0:\n        max_bling += (d - 3) // 3 * 3 * t2 * 100\n    \n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Simulate the remaining days\n    for _ in range(d):\n        # Sell fruits\n        b += f * 100\n        f = 0\n\n        # Plant fruit trees\n        if t0 > 0:\n            t1 += 1\n        if t1 > 0:\n            t2 += 1\n        t0 = t1\n        t1 = t2\n        t2 = 0\n\n        # Buy an exotic fruit\n        b -= 400\n\n        # Plant the exotic fruit\n        t2 += 1\n\n    return str(b)"
    },
    {
        "number": 3007,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    days = 40 - d\n\n    # Sell fruits and plant trees\n    b += f * 100\n    f = 0\n    t0 += f // 3\n    f %= 3\n    t1 += f // 3\n    f %= 3\n    t2 += f // 3\n    f = 0\n\n    # Calculate total fruits and Bling after planting trees\n    total_fruits = sum([t0 * 3, t1 * 3, t2 * 3])\n    total_bling = b + total_fruits * 100\n\n    # Buy exotic fruit if possible\n    if days > 0 and b >= 400:\n        b -= 400\n        total_fruits += 3\n        total_bling += 500\n\n    # Calculate harvest for remaining days\n    for _ in range(days):\n        # Sell trees\n        total_bling += t0 * 300\n        total_bling += t1 * 300\n        total_bling += t2 * 300\n\n        # Grow trees\n        t0 += f // 3\n        f %= 3\n        t1 += f // 3\n        f %= 3\n        t2 += f // 3\n        f = 0\n\n        # Buy exotic fruit if possible\n        if b >= 400:\n            b -= 400\n            total_fruits += 3\n            total_bling += 500\n\n    return str(total_bling)"
    },
    {
        "number": 3008,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    ranks = []\n\n    for i in range(N):\n        rank = 1\n        for j in range(i):\n            if a[i] - a[j] >= K or b[i] - b[j] >= K:\n                rank += 1\n        ranks.append(rank)\n\n    return str(max(ranks))"
    },
    {
        "number": 3008,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    ranks = set()\n    for i in range(N):\n        for j in range(i + 1, N):\n            if a[i] + K < a[j] or b[i] + K < b[j]:\n                ranks.add(max(a[i], b[i]))\n                ranks.add(max(a[j], b[j]))\n\n    return str(len(ranks))"
    },
    {
        "number": 3008,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    # Determine the maximum number of distinct ranks\n    max_rank = 1\n    for i in range(N):\n        rank = 1\n        for j in range(i):\n            if a[i] - a[j] >= K or b[i] - b[j] >= K:\n                rank += 1\n        max_rank = max(max_rank, rank)\n\n    return str(max_rank)"
    },
    {
        "number": 3008,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    a_sorted = sorted(enumerate(a), key=lambda x: x[1])\n    b_sorted = sorted(enumerate(b), key=lambda x: x[1])\n\n    ranks = {}\n    rank_count = 0\n\n    for i in range(N):\n        if a[i] + K < a[i - 1] or b[i] + K < b[i - 1]:\n            rank_count += 1\n        ranks[i] = rank_count\n\n    return str(rank_count + 1)"
    },
    {
        "number": 3008,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Sort assistants by quality of jokes and self-esteem boosts\n    assistants = sorted(zip(a, b), key=lambda x: (x[0], x[1]))\n\n    # Assign ranks to assistants\n    ranks = [1] * N\n    for i in range(1, N):\n        if assistants[i][0] - assistants[i - 1][0] > K or assistants[i][1] - assistants[i - 1][1] > K:\n            ranks[i] = ranks[i - 1] + 1\n        else:\n            ranks[i] = ranks[i - 1]\n\n    # Calculate maximum number of distinct ranks\n    max_distinct_ranks = max(ranks)\n\n    return str(max_distinct_ranks)"
    },
    {
        "number": 3008,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    ranks = [0] * N\n    for i in range(N):\n        for j in range(i + 1, N):\n            if a[i] + K < a[j] or b[i] + K < b[j]:\n                ranks[j] = max(ranks[j], ranks[i] + 1)\n\n    return str(max(ranks) + 1)"
    },
    {
        "number": 3008,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def merge_sort(arr):\n        if len(arr) > 1:\n            mid = len(arr) // 2\n            left = arr[:mid]\n            right = arr[mid:]\n            merge_sort(left)\n            merge_sort(right)\n            i = j = k = 0\n            while i < len(left) and j < len(right):\n                if left[i] < right[j]:\n                    arr[k] = left[i]\n                    i += 1\n                else:\n                    arr[k] = right[j]\n                    j += 1\n                k += 1\n            while i < len(left):\n                arr[k] = left[i]\n                i += 1\n                k += 1\n            while j < len(right):\n                arr[k] = right[j]\n                j += 1\n                k += 1\n\n    def find_distinct_ranks(arr, K):\n        distinct_ranks = 1\n        for i in range(len(arr) - 1):\n            if arr[i] + K < arr[i + 1]:\n                distinct_ranks += 1\n        return distinct_ranks\n\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    merge_sort(a)\n    merge_sort(b)\n\n    distinct_ranks_a = find_distinct_ranks(a, K)\n    distinct_ranks_b = find_distinct_ranks(b, K)\n\n    return max(distinct_ranks_a, distinct_ranks_b)"
    },
    {
        "number": 3008,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N, K = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n\n    # Sort assistants by a, then by b, then by index\n    assistants = sorted(enumerate(zip(a, b)), key=lambda x: (x[1][0], x[1][1], x[0]))\n\n    # Assign ranks\n    ranks = [1] * N\n    for i in range(N - 1):\n        j = i + 1\n        if assistants[i][1][0] + K < assistants[j][1][0] or assistants[i][1][1] + K < assistants[j][1][1]:\n            ranks[assistants[j][0]] = max(ranks[assistants[j][0]], ranks[assistants[i][0]] + 1)\n\n    # Count distinct ranks\n    distinct_ranks = len(set(ranks))\n\n    return str(distinct_ranks)"
    },
    {
        "number": 3008,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def bisect_left(a, x):\n        lo, hi = 0, len(a)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if a[mid][0] < x:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo\n\n    def bisect_right(a, x):\n        lo, hi = 0, len(a)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if a[mid][0] <= x:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo\n\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    a_b = sorted([(a[i], b[i]) for i in range(N)])\n\n    a_ranks = [0] * N\n    b_ranks = [0] * N\n\n    for i in range(N):\n        a_ranks[i] = bisect_left(a_b, (a[i] + K, float('inf'))) + 1\n        b_ranks[i] = bisect_right(a_b, (float('-inf'), b[i] + K)) + 1\n\n    return max(a_ranks[i] for i in range(N)), max(b_ranks[i] for i in range(N))\n\n    # return max(a_ranks[i] for i in range(N)), max(b_ranks[i] for i in range(N))"
    },
    {
        "number": 3008,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def bubble_sort(arr, key):\n        n = len(arr)\n        for i in range(n):\n            for j in range(0, n - i - 1):\n                if arr[j][key] < arr[j + 1][key]:\n                    arr[j], arr[j + 1] = arr[j + 1], arr[j]\n        return arr\n\n    input_data = list(map(int, stdin.split()))\n    N, K = input_data[0], input_data[1]\n    a = list(map(int, input_data[2:N+2]))\n    b = list(map(int, input_data[N+2:]))\n\n    assistants = [{\"a\": a[i], \"b\": b[i]} for i in range(N)]\n    assistants = bubble_sort(assistants, \"a\")\n\n    distinct_ranks = 1\n    current_rank = assistants[0][\"a\"]\n    for i in range(1, N):\n        if assistants[i][\"a\"] > current_rank + K:\n            distinct_ranks += 1\n            current_rank = assistants[i][\"a\"]\n\n    return str(distinct_ranks)"
    },
    {
        "number": 3009,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def line_intersects(p1, p2, p3, p4):\n        def cross(a, b):\n            return a[0] * b[1] - a[1] * b[0]\n\n        def is_on_segment(p1, p2, p):\n            return min(p1[0], p2[0]) <= p[0] <= max(p1[0], p2[0]) and min(p1[1], p2[1]) <= p[1] <= max(p1[1], p2[1])\n\n        if p1[0] == p2[0] and p3[0] == p4[0]:\n            return False\n        if p1[1] == p2[1] and p3[1] == p4[1]:\n            return False\n        a1 = (p2[0] - p1[0], p2[1] - p1[1])\n        b1 = (p4[0] - p3[0], p4[1] - p3[1])\n        a2 = (-a1[1], a1[0])\n        b2 = (-b1[1], b1[0])\n        r = cross(a1, b1)\n        if r == 0:\n            return is_on_segment(p1, p2, p3) or is_on_segment(p1, p2, p4)\n        s = cross(a2, (p3[0] - p1[0], p3[1] - p1[1]))\n        t = cross(b2, (p1[0] - p3[0], p1[1] - p3[1]))\n        if r < 0:\n            return s >= 0 and t >= 0 and (s + t) <= r\n        return s <= 0 and t <= 0 and (s + t) >= r\n\n    def area(p1, p2, p3):\n        return abs((p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0]))\n\n    lines = [line.split() for line in stdin.split('\\n') if line]\n    N = int(lines[0][0])\n    lamps = [(int(x), int(y), int(e)) for x, y, e in lines[1:N + 1]]\n    points = [(x, y) for x, y, e in lamps]\n\n    def shortest_line():\n        lines = []\n        for i, (x1, y1, e1) in enumerate(lamps):\n            for j, (x2, y2, e2) in enumerate(lamps[i + 1:], i + 1):\n                if line_intersects((x1, y1), (x2, y2), (0, 0), (99, 99)):\n                    lines.append((area((x1, y1), (x2, y2), (0, 0)), (x1, y1, x2, y2, e1, e2)))\n        lines.sort(reverse=True)\n\n        for _, (x1, y1, x2, y2, e1, e2) in lines:\n            for x, y, e in lamps:\n                if (x1, y1) != (x, y) and (x2, y2) != (x, y) and (0, 0) != (x, y) and (99, 99) != (x, y):\n                    if line_intersects((x1, y1), (x2, y2), (x, y), (x + 1, y + 1)):\n                        return e1 + e2\n        return 0\n\n    result = shortest_line()\n    return round(result, 6) if result != 0 else \"IMPOSSIBLE\""
    },
    {
        "number": 3009,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from collections import namedtuple\n    from typing import List, Tuple\n\n    def point_in_square(p: Tuple[int, int], q: Tuple[int, int], r: Tuple[int, int]):\n        return q[0] <= p[0] <= r[0] and q[1] <= p[1] <= r[1]\n\n    def line_intersects_square(l: Tuple[Tuple[int, int], Tuple[int, int]],\n                                     q: Tuple[int, int], r: Tuple[int, int]):\n        p1, p2 = l\n        p3 = q\n        p4 = (r[0], q[1])\n        return (point_in_square(p1, q, r) and point_in_square(p2, q, r) or\n                point_in_square(p3, p1, p2) and point_in_square(p4, p1, p2))\n\n    def get_square_footprint(lamp: Tuple[int, int, int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n        x, y, _ = lamp\n        return ((x - 1, y - 1), (x + 1, y + 1))\n\n    def find_shortest_line_length(lamps: List[Tuple[int, int, int]], n: int) -> float:\n        lamps.sort(key=lambda x: x[2])\n        positive_lamps = [l for l in lamps if l[2] > 0]\n        negative_lamps = [l for l in lamps if l[2] < 0]\n\n        for i, lamp in enumerate(positive_lamps):\n            square = get_square_footprint(lamp)\n            if any(line_intersects_square(get_square_footprint(nl), *square) for nl in negative_lamps):\n                continue\n            else:\n                return sum(l[2] for l in negative_lamps) - lamp[2]\n\n        for i, lamp in enumerate(negative_lamps):\n            square = get_square_footprint(lamp)\n            if any(line_intersects_square(get_square_footprint(pl), *square) for pl in positive_lamps):\n                continue\n            else:\n                return sum(l[2] for l in positive_lamps) + lamp[2]\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    lamps = [list(map(int, line.split())) for line in lines[1:n + 1]]\n\n    try:\n        result = find_shortest_line_length(lamps, n)\n        return '{:.6f}'.format(result)\n    except (IndexError, ValueError):\n        return 'IMPOSSIBLE'"
    },
    {
        "number": 3009,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(x, y, x1, y1, x2, y2):\n        return x1 <= x <= x2 and y1 <= y <= y2\n\n    def get_line_length(N, lamps, x1, y1, x2, y2):\n        length = 0\n        for x, y, _ in lamps:\n            if is_inside(x, y, x1, y1, x2, y2):\n                length += (x2 - x1) + (y2 - y1)\n            else:\n                length += (x1 - x) + (y1 - y)\n        return length\n\n    def process_lamps(N, lamps):\n        positive_lamps = [lamp for lamp in lamps if lamp[2] > 0]\n        negative_lamps = [lamp for lamp in lamps if lamp[2] < 0]\n\n        if not positive_lamps or not negative_lamps:\n            return \"IMPOSSIBLE\"\n\n        min_length = float('inf')\n\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                x1, y1, _ = lamps[i]\n                x2, y2, _ = lamps[j]\n\n                if x1 == x2 or y1 == y2:\n                    continue\n\n                line_length = get_line_length(N, lamps, x1, y1, x2, y2)\n                min_length = min(min_length, line_length)\n\n        return min_length\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    lamps = [tuple(map(int, line.split())) for line in lines[1:N + 1]]\n\n    return process_lamps(N, lamps)"
    },
    {
        "number": 3009,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x1, y1, e1, x2, y2, e2):\n        return (x1 - x2)**2 + (y1 - y2)**2 >= 2\n\n    def find_shortest_line(energies):\n        energies.sort(key=lambda x: x[2])\n        n = len(energies)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_valid(*energies[i], *energies[j]):\n                    continue\n                else:\n                    return (energies[i][2] + energies[j][2]) / 2\n        return \"IMPOSSIBLE\"\n\n    n = int(stdin.readline().strip())\n    energies = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    result = find_shortest_line(energies)\n    return f\"{result:.6f}\""
    },
    {
        "number": 3009,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_line(x, y, x1, y1, x2, y2):\n        return (y2 - y1) * x + (x1 - x2) * y + (x2 * y1 - x1 * y2) <= 0\n\n    def get_energy_inside_line(x1, y1, x2, y2):\n        energy_inside = 0\n        for x, y, e in lamps:\n            if is_inside_line(x, y, x1, y1, x2, y2):\n                energy_inside += e\n        return energy_inside\n\n    def get_total_energy(x1, y1, x2, y2):\n        total_energy = sum(e for x, y, e in lamps)\n        total_energy -= get_energy_inside_line(x1, y1, x2, y2)\n        return total_energy\n\n    def can_balance():\n        for x1, y1, e1 in lamps:\n            for x2, y2, e2 in lamps:\n                if (x1, y1) != (x2, y2):\n                    energy_inside = get_energy_inside_line(x1, y1, x2, y2)\n                    total_energy = get_total_energy(x1, y1, x2, y2)\n                    if abs(energy_inside) == abs(total_energy) and energy_inside * total_energy < 0:\n                        return True\n        return False\n\n    def get_length_of_line():\n        min_length = float('inf')\n        for x1, y1, e1 in lamps:\n            for x2, y2, e2 in lamps:\n                if (x1, y1) != (x2, y2):\n                    energy_inside = get_energy_inside_line(x1, y1, x2, y2)\n                    total_energy = get_total_energy(x1, y1, x2, y2)\n                    if abs(energy_inside) == abs(total_energy) and energy_inside * total_energy < 0:\n                        length = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n                        min_length = min(min_length, length)\n        return min_length if min_length != float('inf') else 'IMPOSSIBLE'\n\n    lamps = []\n    N = int(stdin.readline().strip())\n    for _ in range(N):\n        x, y, e = map(int, stdin.readline().strip().split())\n        lamps.append((x, y, e))\n\n    if can_balance():\n        return get_length_of_line()\n    else:\n        return 'IMPOSSIBLE' "
    },
    {
        "number": 3009,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(line, x, y, e, used_points):\n        for i in range(len(line)):\n            if i == 0:\n                continue\n            prev_x, prev_y, prev_e = line[i - 1]\n            if (prev_x, prev_y) in used_points:\n                continue\n            if abs(prev_e) < abs(e):\n                return False\n        return True\n\n    def find_line(line, used_points):\n        line.sort(key=lambda x: x[2])\n        for i in range(len(line)):\n            x, y, e = line[i]\n            if (x, y) in used_points:\n                continue\n            if abs(e) < 100:\n                return None\n            used_points.add((x, y))\n            if is_valid(line, x, y, e, used_points):\n                return (x, y, e)\n        return None\n\n    def get_line_length(line, dividing_point):\n        x, y, e = dividing_point\n        positive_energy = 0\n        negative_energy = 0\n        for l in line:\n            l_x, l_y, l_e = l\n            if (l_x, l_y) == (x, y):\n                continue\n            if l_e > 0:\n                positive_energy += l_e\n            else:\n                negative_energy += l_e\n        return abs(positive_energy) + abs(negative_energy)\n\n    def main(stdin: str) -> str:\n        line = [list(map(int, i.split())) for i in stdin.split('\\n')[1:]]\n        used_points = set()\n        dividing_point = find_line(line, used_points)\n        if dividing_point is None:\n            return \"IMPOSSIBLE\"\n        x, y, e = dividing_point\n        line_length = get_line_length(line, dividing_point)\n        return \"{:.6f}\".format(line_length)\n\n    return main(stdin) "
    },
    {
        "number": 3009,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_line(line: tuple) -> bool:\n        for i in range(len(line)):\n            for j in range(i + 1, len(line)):\n                if line[i][0] == line[j][0] or line[i][1] == line[j][1]:\n                    return False\n        return True\n\n    def energy_sum(line: tuple, center: tuple) -> int:\n        total_energy = 0\n        for lamp in line:\n            if center[0] <= lamp[0][0] <= center[2] and center[1] <= lamp[0][1] <= center[3]:\n                total_energy += lamp[1]\n        return total_energy\n\n    def find_balance_line(lines: list, center: tuple) -> float:\n        min_length = float('inf')\n        min_line = None\n\n        for i in range(len(lines)):\n            for j in range(i + 1, len(lines)):\n                for k in range(j + 1, len(lines)):\n                    points = [lines[i], lines[j], lines[k]]\n                    if is_valid_line(points):\n                        x1, y1 = points[0][0]\n                        x2, y2 = points[1][0]\n                        x3, y3 = points[2][0]\n                        p1 = (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2\n                        p2 = -((x1 * x1 + y1 * y1) * (y2 - y3) + (x2 * x2 + y2 * y2) * (y3 - y1) + (x3 * x3 + y3 * y3) * (y1 - y2)) / 2\n                        a = y1 * (x2 - x3) + x1 * (y2 - y3) + y2 * (x3 - x1) + x2 * (y3 - y1)\n                        b = p1 * 2 - a * (x1 + x2 + x3) - p2 * (y1 + y2 + y3)\n                        c = p1 * (x1 + x2 + x3) + p2 * (y1 + y2 + y3) + x1 * y2 + x2 * y3 + x3 * y1 - p2 * (x1 + x2 + x3) - p1 * (y1 + y2 + y3) - x1 * y3 - x2 * y1 - x3 * y2\n                        length = abs(a * x1 + b * y1 + c) / (a ** 2 + b ** 2) ** 0.5\n                        if length < min_length:\n                            min_length = length\n                            min_line = points\n\n        if min_line:\n            center_x = sum([lamp[0][0] for lamp in min_line]) / len(min_line)\n            center_y = sum([lamp[0][1] for lamp in min_line]) / len(min_line)\n            positive_energy = energy_sum(lines, (center_x - 1, center_y - 1, center_x + 1, center_y + 1))\n            negative_energy = energy_sum(lines, (center_x - 1, center_y - 1, center_x + 1, center_y + 1))\n\n            if abs(positive_energy + negative_energy) < 1e-6:\n                return round(min_length, 6)\n\n        return \"IMPOSSIBLE\"\n\n    lines = []\n    for i in range(int(stdin.readline())):\n        x, y, e = map(int, stdin.readline().split())\n        lines.append(((x, y), e))\n\n    center_x = sum([lamp[0][0] for lamp in lines]) / len(lines)\n    center_y = sum([lamp[0][1] for lamp in lines]) / len(lines)\n    min_x = min(lamp[0][0] for lamp in lines)\n    min_y = min(lamp[0][1] for lamp in"
    },
    {
        "number": 3009,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def energy_at_point(x, y, lamps):\n        energy = 0\n        for lamp in lamps:\n            if lamp[0] - 1 <= x <= lamp[0] + 1 and lamp[1] - 1 <= y <= lamp[1] + 1:\n                energy += lamp[2]\n        return energy\n\n    def find_balance_line(lamps):\n        min_length = float('inf')\n        for i in range(len(lamps)):\n            for j in range(i + 1, len(lamps)):\n                x1, y1, _ = lamps[i]\n                x2, y2, _ = lamps[j]\n                energy1 = energy_at_point(x1, y1, lamps)\n                energy2 = energy_at_point(x2, y2, lamps)\n                if energy1 * energy2 < 0:\n                    d = distance((x1, y1), (x2, y2))\n                    if d < min_length:\n                        min_length = d\n        return min_length\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    lamps = []\n    for i in range(1, N + 1):\n        x, y, e = map(int, lines[i].split())\n        lamps.append((x, y, e))\n\n    min_length = find_balance_line(lamps)\n    return f'{min_length:.6f}' if min_length != float('inf') else 'IMPOSSIBLE'"
    },
    {
        "number": 3009,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    lamps = [(int(x), int(y), int(e)) for x, y, e in (line.split() for line in lines[1:N+1])]\n\n    # Initialize energy map\n    energy_map = [[0 for _ in range(101)] for _ in range(101)]\n    for x, y, e in lamps:\n        energy_map[x][y] = e\n\n    # Calculate energy line\n    for x in range(1, 100):\n        for y in range(1, 100):\n            energy_map[x][y] = energy_map[x-1][y] + energy_map[x][y-1] - energy_map[x-1][y-1] + energy_map[x][y]\n\n    # Find shortest energy line\n    min_line_length = float(\"inf\")\n    for x1 in range(1, 100):\n        for y1 in range(1, 100):\n            for x2 in range(1, 100):\n                for y2 in range(1, 100):\n                    if (x1, y1) != (x2, y2):\n                        area_sum = sum(energy_map[x][y] for x in range(x1, x2+1) for y in range(y1, y2+1))\n                        if area_sum == 0:\n                            line_length = ((x2-x1)**2 + (y2-y1)**2) ** 0.5\n                            min_line_length = min(min_line_length, line_length)\n\n    if min_line_length == float(\"inf\"):\n        return \"IMPOSSIBLE\"\n    else:\n        return f\"{min_line_length:.6f}\""
    },
    {
        "number": 3009,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    lamps = []\n    for i in range(1, N+1):\n        x, y, e = map(int, lines[i].split())\n        lamps.append((x, y, e))\n    \n    def point_inside(x, y, lamps):\n        for lamp in lamps:\n            if lamp[0]-1 <= x <= lamp[0]+1 and lamp[1]-1 <= y <= lamp[1]+1:\n                return True\n        return False\n\n    def line_crosses(x1, y1, x2, y2, lamps):\n        for lamp in lamps:\n            if ((x1 < lamp[0] and lamp[0] < x2) or (x2 < lamp[0] and lamp[0] < x1)) and \\\n               ((y1 < lamp[1] and lamp[1] < y2) or (y2 < lamp[1] and lamp[1] < y1)):\n                return True\n        return False\n\n    def line_length(x1, y1, x2, y2):\n        return ((x2-x1)**2 + (y2-y1)**2)**0.5\n\n    def find_min_line(lamps, start_x, start_y):\n        min_length = float('inf')\n        for i in range(len(lamps)):\n            for j in range(i+1, len(lamps)):\n                if lamps[i][2]*lamps[j][2] < 0:\n                    if not (point_inside(lamps[i][0], lamps[i][1], [lamps[j]]) or\n                            point_inside(lamps[j][0], lamps[j][1], [lamps[i]]) or\n                            line_crosses(lamps[i][0], lamps[i][1], lamps[j][0], lamps[j][1], [lamps[i], lamps[j]])):\n                        length = line_length(lamps[i][0], lamps[i][1], lamps[j][0], lamps[j][1])\n                        min_length = min(min_length, length)\n        return min_length\n\n    min_length = find_min_line(lamps, 0, 0)\n    if min_length == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return round(min_length, 6)\n"
    },
    {
        "number": 3010,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def slope(x0, y0, x1, y1):\n        if x0 == x1:\n            return float('inf')\n        return (y1 - y0) / (x1 - x0)\n\n    n = int(stdin.readline().strip())\n    lines = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    points = {}\n    for i in range(n):\n        x0, y0, x1, y1 = lines[i]\n        m = slope(x0, y0, x1, y1)\n        if m == 0:\n            for x in range(min(x0, x1), max(x0, x1) + 1):\n                points[x] = points.get(x, 0) + 1\n        elif m == float('inf'):\n            y = min(y0, y1)\n            for x in range(min(x0, x1), max(x0, x1) + 1):\n                points[x, y] = points.get((x, y), 0) + 1\n        else:\n            a = y0 - m * x0\n            for x in range(min(x0, x1), max(x0, x1) + 1):\n                y = m * x + a\n                points[x, y] = points.get((x, y), 0) + 1\n\n    count = sum(1 for c in points.values() if c > 1)\n    return str(count) if count != float('inf') else '-1'"
    },
    {
        "number": 3010,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def intersection_point(x0, y0, x1, y1, x2, y2, x3, y3):\n        A1 = y0 - y1\n        B1 = x1 - x0\n        C1 = x0 * y1 - x1 * y0\n        A2 = y2 - y3\n        B2 = x3 - x2\n        C2 = x2 * y3 - x3 * y2\n        if A1 * B2 - A2 * B1 == 0:\n            return None\n        x = (C2 * B1 - C1 * B2) / (A1 * B2 - A2 * B1)\n        y = (C1 * A2 - C2 * A1) / (A1 * B2 - A2 * B1)\n        return (x, y)\n\n    def is_on_segment(x0, y0, x1, y1, x, y):\n        if x0 <= x <= x1 or x0 >= x >= x1:\n            if y0 <= y <= y1 or y0 >= y >= y1:\n                return True\n        return False\n\n    n = int(stdin.readline().strip())\n    points = set()\n    for i in range(n):\n        x0, y0, x1, y1 = map(int, stdin.readline().strip().split())\n        for j in range(i + 1, n):\n            x2, y2, x3, y3 = map(int, stdin.readline().strip().split())\n            p = intersection_point(x0, y0, x1, y1, x2, y2, x3, y3)\n            if p and (is_on_segment(x0, y0, x1, y1, p[0], p[1]) or is_on_segment(x2, y2, x3, y3, p[0], p[1])):\n                points.add(p)\n\n    return len(points) if len(points) != float('inf') else -1"
    },
    {
        "number": 3010,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_intersecting(p1, p2, q1, q2):\n        (x1, y1), (x2, y2) = p1, p2\n        (x3, y3), (x4, y4) = q1, q2\n\n        if (x1 == x2 and x3 == x4) or (y1 == y2 and y3 == y4):\n            return False\n\n        if (x1 - x2) * (y3 - y1) == (y2 - y1) * (x3 - x1):\n            return False\n\n        if (x1 - x2) * (y4 - y1) == (y2 - y1) * (x4 - x1):\n            return False\n\n        return True\n\n    def get_intersection_point(p1, p2, q1, q2):\n        (x1, y1), (x2, y2) = p1, p2\n        (x3, y3), (x4, y4) = q1, q2\n\n        if (x1 - x2) * (y3 - y1) == (y2 - y1) * (x3 - x1):\n            return None\n\n        if (x1 - x2) * (y4 - y1) == (y2 - y1) * (x4 - x1):\n            return None\n\n        t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4))\n        u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4))\n\n        if 0 <= t <= 1 and 0 <= u <= 1:\n            return (x1 + t * (x2 - x1), y1 + t * (y2 - y1))\n\n        return None\n\n    n = int(stdin.readline().strip())\n    points = set()\n\n    for _ in range(n):\n        x0, y0, x1, y1 = map(int, stdin.readline().strip().split())\n        for j in range(i + 1, n):\n            x2, y2, x3, y3 = map(int, stdin.readline().strip().split())\n            if is_intersecting((x0, y0), (x1, y1), (x2, y2), (x3, y3)):\n                point = get_intersection_point((x0, y0), (x1, y1), (x2, y2), (x3, y3))\n                if point:\n                    points.add(point)\n\n    return len(points) if len(points) != float(\"inf\") else -1"
    },
    {
        "number": 3010,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_parallel(a, b):\n        return (a[0] - a[2], a[1] - a[3]) == (b[0] - b[2], b[1] - b[3])\n\n    def is_intersect(a, b):\n        x1, y1, x2, y2 = a\n        x3, y3, x4, y4 = b\n\n        if (x1, y1) == (x3, y3) or (x1, y1) == (x4, y4) or \\\n                (x2, y2) == (x3, y3) or (x2, y2) == (x4, y4):\n            return True\n\n        if (x1 - x2) * (y3 - y4) == (y1 - y2) * (x4 - x3):\n            return False\n\n        x = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)\n        y = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)\n\n        return (x1 - x2) * (x3 - x4) < 0 and (y1 - y2) * (y3 - y4) < 0\n\n    lines = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    for i in range(len(lines)):\n        x1, y1, x2, y2 = lines[i]\n        lines[i] = (min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2))\n\n    points = set()\n\n    for i in range(len(lines)):\n        for j in range(i + 1, len(lines)):\n            if not is_parallel(lines[i], lines[j]) and is_intersect(lines[i], lines[j]):\n                points.add(((lines[i][0], lines[i][1])) if lines[i][0] < lines[j][0] or (lines[i][0] == lines[j][0] and lines[i][1] < lines[j][1]) else (lines[i][2], lines[i][3]))\n                points.add((lines[j][0], lines[j][1]))\n                points.add((lines[j][2], lines[j][3]))\n\n    return len(points) if len(points) != float('inf') else -1"
    },
    {
        "number": 3010,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    lines = [line.split() for line in stdin.split(\"\\n\")[1:]]\n    points = {}\n\n    for line in lines:\n        x0, y0, x1, y1 = map(int, line)\n        if x0 == x1:\n            for y in range(min(y0, y1), max(y0, y1) + 1):\n                points[(x0, y)] = True\n        elif y0 == y1:\n            for x in range(min(x0, x1), max(x0, x1) + 1):\n                points[(x, y0)] = True\n        else:\n            if x0 < x1:\n                x_step = 1\n            else:\n                x_step = -1\n\n            if y0 < y1:\n                y_step = 1\n            else:\n                y_step = -1\n\n            dx = x1 - x0\n            dy = y1 - y0\n            if dx > dy:\n                err = dx\n            else:\n                err = -dy\n            e2 = err * 2\n            x = x0\n            y = y0\n            points[(x, y)] = True\n\n            for i in range(dx + dy):\n                e2 -= dy if err < 0 else dx\n                if e2 < 0:\n                    err -= dy if err < 0 else dx\n                    e2 += dy if err < 0 else dx\n                    x += x_step\n                    y += y_step\n                elif err < 0:\n                    x += x_step\n                    err += dy\n                else:\n                    y += y_step\n                    err -= dx\n                points[(x, y)] = True\n\n    return str(len(points))"
    },
    {
        "number": 3010,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def line_intersect(x1, y1, x2, y2, x3, y3, x4, y4):\n        numerator1 = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)\n        numerator2 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)\n        denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n        if denominator == 0:\n            return None\n        t = numerator1 / denominator\n        u = numerator2 / denominator\n        if 0 <= t <= 1 and 0 <= u <= 1:\n            return (x1 + t * (x2 - x1), y1 + t * (y2 - y1))\n        return None\n\n    def count_intersections(lines):\n        points = {}\n        for i in range(len(lines)):\n            for j in range(i + 1, len(lines)):\n                intersect = line_intersect(*lines[i], *lines[j])\n                if intersect is not None:\n                    points.setdefault(intersect, 0)\n                    points[intersect] += 1\n        return len(points)\n\n    lines = []\n    n = int(stdin.readline().strip())\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        lines.append((x1, y1, x2, y2))\n\n    result = count_intersections(lines)\n    return str(result) if result != float('inf') else '-1'"
    },
    {
        "number": 3010,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lines = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    def slope(x0, y0, x1, y1):\n        if x0 == x1:\n            return float('inf')\n        else:\n            return (y1 - y0) / (x1 - x0)\n    \n    points = {}\n    \n    for i in range(n):\n        x0, y0, x1, y1 = lines[i]\n        m = slope(x0, y0, x1, y1)\n        \n        for j in range(i + 1, n):\n            x2, y2, x3, y3 = lines[j]\n            if m == slope(x2, y2, x3, y3):\n                if (x0, y0) != (x2, y2) and (x0, y0) != (x3, y3) and (x1, y1) != (x2, y2) and (x1, y1) != (x3, y3):\n                    x = (y2 - y0 + m * x0 - m * x2) / (m - 1/m)\n                    y = m * x + y2 - m * x2\n                    points[(x, y)] = True\n                    \n    return str(len(points)) if len(points) != float('inf') else '-1'"
    },
    {
        "number": 3010,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def intersection(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        den_x = (x1 - x2) * (x3 - x4)\n        den_y = (y1 - y2) * (y3 - y4)\n        num_x = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)\n        num_y = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)\n        if den_x == 0 and den_y == 0:\n            if num_x == 0 and num_y == 0:\n                return \"Infinity\"\n            return None\n        if den_x == 0 or den_y == 0:\n            return None\n        return num_x / den_x, num_y / den_y\n\n    def check_intersection(line1, line2, points):\n        intersection_point = intersection(line1, line2)\n        if intersection_point == \"Infinity\":\n            return \"Infinity\"\n        if intersection_point is not None:\n            points.add(intersection_point)\n        return points\n\n    lines = [list(map(int, line.split())) for line in stdin.split('\\n') if line]\n    n = lines[0][0]\n    lines = lines[1:]\n    points = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            points = check_intersection(lines[i], lines[j], points)\n            if points == \"Infinity\":\n                return -1\n    return len(points)"
    },
    {
        "number": 3010,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_points_from_line(x0, y0, x1, y1):\n        points = []\n        if x0 != x1:\n            if y0 != y1:\n                m = (y1 - y0) / (x1 - x0)\n                b = y0 - m * x0\n                for x in range(min(x0, x1), max(x0, x1) + 1):\n                    y = round(m * x + b)\n                    points.append((x, y))\n            else:\n                for y in range(min(y0, y1), max(y0, y1) + 1):\n                    points.append((x0, y))\n        else:\n            for x in range(min(x0, x1), max(x0, x1) + 1):\n                points.append((x, y0))\n        return points\n\n    lines = []\n    for line in stdin.split('\\n')[1:]:\n        x0, y0, x1, y1 = map(int, line.split())\n        lines.append(get_points_from_line(x0, y0, x1, y1))\n\n    points = set()\n    for i in range(len(lines)):\n        for j in range(i + 1, len(lines)):\n            if lines[i] & lines[j]:\n                points |= (lines[i] & lines[j])\n\n    return len(points) if len(points) != float('inf') else -1"
    },
    {
        "number": 3010,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def slope(x0, y0, x1, y1):\n        return (y1 - y0) / (x1 - x0)\n\n    def y_intercept(x0, y0, m):\n        return y0 - m * x0\n\n    def count_intersections(lines, n):\n        intersections = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                x0, y0, x1, y1 = lines[i]\n                x2, y2, x3, y3 = lines[j]\n\n                if x0 == x1:\n                    m2 = slope(x2, y2, x3, y3)\n                    b2 = y_intercept(x2, y2, m2)\n                    y_int = m2 * x0 + b2\n                    if y_int == y0:\n                        intersections.add((x0, y0))\n                elif x2 == x3:\n                    m1 = slope(x0, y0, x1, y1)\n                    b1 = y_intercept(x0, y0, m1)\n                    y_int = m1 * x2 + b1\n                    if y_int == y2:\n                        intersections.add((x2, y2))\n                else:\n                    m1 = slope(x0, y0, x1, y1)\n                    m2 = slope(x2, y2, x3, y3)\n                    b1 = y_intercept(x0, y0, m1)\n                    b2 = y_intercept(x2, y2, m2)\n\n                    if m1 == m2:\n                        if b1 == b2:\n                            if x0 < x1 and x2 < x3:\n                                intersections.add((min(x0, x1, x2, x3), min(y0, y1, y2, y3)))\n                            elif x0 > x1 and x2 > x3:\n                                intersections.add((max(x0, x1, x2, x3), max(y0, y1, y2, y3)))\n                    else:\n                        x_int = (b2 - b1) / (m1 - m2)\n                        y_int = m1 * x_int + b1\n                        if min(x0, x1) < x_int < max(x0, x1) and min(x2, x3) < x_int < max(x2, x3):\n                            intersections.add((x_int, y_int))\n\n        return intersections\n\n    def count_distinct_points(intersections):\n        distinct_points = set()\n        for point in intersections:\n            if point not in distinct_points:\n                distinct_points.add(point)\n            else:\n                return -1\n        return len(distinct_points)\n\n    lines = []\n    n = int(stdin.readline().strip())\n    for _ in range(n):\n        x0, y0, x1, y1 = map(int, stdin.readline().strip().split())\n        lines.append((x0, y0, x1, y1))\n\n    intersections = count_intersections(lines, n)\n    distinct_points = count_distinct_points(intersections)\n    return str(distinct_points)"
    },
    {
        "number": 3011,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_hill_number(num: int) -> bool:\n        num_str = str(num)\n        hill_number = True\n        increasing = True\n        for i in range(len(num_str) - 1):\n            if num_str[i] > num_str[i + 1]:\n                increasing = False\n            elif num_str[i] < num_str[i + 1]:\n                if not increasing:\n                    hill_number = False\n                    break\n        return hill_number\n\n    def count_hill_numbers(num: int) -> int:\n        count = 0\n        for i in range(1, num + 1):\n            if is_hill_number(i):\n                count += 1\n        return count\n\n    n = int(stdin)\n    if is_hill_number(n):\n        return str(count_hill_numbers(n))\n    else:\n        return str(-1)\n"
    },
    {
        "number": 3011,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n\n    for i in range(1, n + 1):\n        is_hill_number = True\n        last_digit = -1\n\n        for digit in str(i):\n            digit = int(digit)\n            if last_digit > digit:\n                is_hill_number = False\n                break\n            last_digit = digit\n\n        if is_hill_number:\n            count += 1\n\n    return str(count) if n == 1 or count > 0 else \"-1\""
    },
    {
        "number": 3011,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 1 or n > 10**18:\n        return \"-1\"\n\n    def is_hill_number(num: int) -> bool:\n        num_str = str(num)\n        length = len(num_str)\n        for i in range(length // 2):\n            if int(num_str[i]) > int(num_str[length - 1 - i]):\n                return False\n        return True\n\n    def count_hill_numbers(n: int) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if is_hill_number(i):\n                count += 1\n        return count\n\n    if is_hill_number(n):\n        return str(count_hill_numbers(n))\n    else:\n        return \"-1\""
    },
    {
        "number": 3011,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n + 1):\n        prev_digit = -1\n        is_hill_number = True\n        for digit in str(i):\n            if prev_digit == -1:\n                prev_digit = int(digit)\n            else:\n                if prev_digit < int(digit):\n                    prev_digit = int(digit)\n                elif prev_digit > int(digit):\n                    is_hill_number = False\n                    break\n        if is_hill_number:\n            count += 1\n    if count == n:\n        return \"-1\"\n    else:\n        return str(count)"
    },
    {
        "number": 3011,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        hill_number = str(i)\n        increasing = True\n        decreasing = False\n        for j in range(len(hill_number) - 1):\n            if hill_number[j] < hill_number[j + 1]:\n                if decreasing:\n                    break\n            elif hill_number[j] > hill_number[j + 1]:\n                if increasing:\n                    break\n                decreasing = True\n                increasing = False\n            else:\n                continue\n        else:\n            count += 1\n    return str(count) if count == n else '-1'"
    },
    {
        "number": 3011,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_numbers = []\n\n    def is_hill_number(num: int) -> bool:\n        num_str = str(num)\n        prev_digit = num_str[0]\n        increasing = True\n        for i in range(1, len(num_str)):\n            if num_str[i] == prev_digit:\n                continue\n            elif num_str[i] > prev_digit:\n                if not increasing:\n                    return False\n            else:\n                increasing = False\n            prev_digit = num_str[i]\n        return True\n\n    for i in range(1, n + 1):\n        if is_hill_number(i):\n            hill_numbers.append(i)\n\n    if not hill_numbers or not is_hill_number(n):\n        return \"-1\"\n    else:\n        return str(len(hill_numbers))"
    },
    {
        "number": 3011,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 1 or n > 10**18:\n        return \"-1\"\n\n    def is_hill_number(num: int) -> bool:\n        num_str = str(num)\n        for i in range(len(num_str) - 1):\n            if num_str[i] > num_str[i + 1]:\n                return False\n            elif num_str[i] < num_str[i + 1]:\n                break\n        return True\n\n    if not is_hill_number(n):\n        return \"-1\"\n\n    count = 0\n    for i in range(1, n + 1):\n        if is_hill_number(i):\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3011,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n+1):\n        s = str(i)\n        if s == s[::-1]:\n            continue\n        if s == \"\".join(sorted(s)) or s == \"\".join(sorted(s, reverse=True)):\n            count += 1\n    if count == 0:\n        return \"-1\"\n    else:\n        return str(count)"
    },
    {
        "number": 3011,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    hill_numbers = [1]\n    for i in range(len(str(n))):\n        hill_numbers.extend([10 ** i + j for j in range(10)])\n\n    return str(sum(1 for i in hill_numbers if i <= n)) if n in hill_numbers else '-1'"
    },
    {
        "number": 3011,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return 1\n    if not is_hill_number(n):\n        return -1\n    return count_hill_numbers(n)\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    mod = 1000000007\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    if a11 + a12 + a21 + a22 == 0:\n        return 0\n\n    def count_sequences(N, a11, a12, a21, a22):\n        sequences = []\n        for i in range(N):\n            if i % 3 == 0:\n                sequences.append(\"A\")\n            elif i % 3 == 1:\n                sequences.append(\"B\")\n            else:\n                sequences.append(\"C\")\n        return sequences\n\n    def count_rest_sequences(N, a11, a12, a21, a22):\n        sequences = []\n        for i in range(N):\n            if i % 3 == 0:\n                sequences.append(\"A\")\n            elif i % 3 == 1:\n                sequences.append(\"B\")\n            else:\n                sequences.append(\"C\")\n        return sequences\n\n    def count_moves(sequences, a11, a12, a21, a22):\n        count = 0\n        for i in range(len(sequences) - 1):\n            attacker = sequences[i]\n            defender = sequences[i + 1]\n            if attacker == \"A\" and defender == \"B\":\n                count += a11 * a22\n            elif attacker == \"A\" and defender == \"C\":\n                count += a11 * a21\n            elif attacker == \"B\" and defender == \"A\":\n                count += a12 * a21\n            elif attacker == \"B\" and defender == \"C\":\n                count += a12 * a22\n        return count\n\n    sequences = count_sequences(N, a11, a12, a21, a22)\n    rest_sequences = count_rest_sequences(N, a11, a12, a21, a22)\n    moves = count_moves(sequences, a11, a12, a21, a22)\n    rest_moves = count_moves(rest_sequences, a11, a12, a21, a22)\n\n    return (moves + rest_moves) % mod"
    },
    {
        "number": 3012,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    mod = 10**9 + 7\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    total_players = a11 + a12 + a21 + a22\n\n    if N < total_players or N % 2 != 0:\n        return \"0\"\n\n    if a11 == 0 or a21 == 0:\n        return \"0\"\n\n    def combinations(n, k):\n        if k == 0 or k == n:\n            return 1\n        if k == 1 or k == n - 1:\n            return n\n        return (combinations(n - 1, k - 1) * n // k) % mod\n\n    return str(combinations(a11 + a21, a11))"
    },
    {
        "number": 3012,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    mod = 1000000007\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    def count_sequences(attackers: int, defenders: int, rest: int) -> int:\n        if N == 0:\n            return 1\n        if rest > 0:\n            rest -= 1\n            return count_sequences(attackers, defenders, rest)\n        if attackers == 0 or defenders == 0:\n            return 0\n        count = 0\n        if attackers >= defenders:\n            for i in range(defenders):\n                count += count_sequences(attackers - 1, defenders - i - 1, 0)\n                count += count_sequences(attackers, defenders - i - 1, 2)\n                count %= mod\n        else:\n            for i in range(attackers):\n                count += count_sequences(attackers - i - 1, defenders - 1, 0)\n                count %= mod\n        return count\n\n    total = 0\n    for i in range(1, a11 + 1):\n        for j in range(1, a12 + 1):\n            total += count_sequences(i, j, 0)\n            total %= mod\n\n    for i in range(1, a21 + 1):\n        for j in range(1, a22 + 1):\n            total -= count_sequences(i, j, 0)\n            total %= mod\n\n    return str(total)"
    },
    {
        "number": 3012,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    mod = 1000000007\n\n    def count_sequences(N: int, a11: int, a12: int, a21: int, a22: int) -> int:\n        def count_sequences_helper(N: int, a11: int, a12: int, a21: int, a22: int, memo: dict) -> int:\n            if N == 0:\n                return 1\n            if N < 0:\n                return 0\n            if (N, a11, a12, a21, a22) in memo:\n                return memo[(N, a11, a12, a21, a22)]\n\n            total_players = a11 + a12 + a21 + a22\n            total_sequences = 0\n\n            # Case 1: Use skill 1, successful attack\n            if a11 > 0:\n                total_sequences += a11 * count_sequences_helper(N - 1, a11 - 1, a12, a21, a22, memo)\n                total_sequences += a11 * count_sequences_helper(N - 3, a11 - 1, a12, a21, a22, memo)\n\n            # Case 2: Use skill 2, successful attack\n            if a21 > 0:\n                total_sequences += a21 * count_sequences_helper(N - 1, a11, a12, a21 - 1, a22, memo)\n                total_sequences += a21 * count_sequences_helper(N - 3, a11, a12, a21 - 1, a22, memo)\n\n            # Case 3: Use skill 1, failed attack\n            if a11 > 0:\n                total_sequences += a11 * count_sequences_helper(N - 1, a11, a12 + 1, a21, a22, memo)\n\n            # Case 4: Use skill 2, failed attack\n            if a21 > 0:\n                total_sequences += a21 * count_sequences_helper(N - 1, a11, a12, a21, a22 + 1, memo)\n\n            total_sequences %= mod\n            memo[(N, a11, a12, a21, a22)] = total_sequences\n\n            return total_sequences\n\n        memo = {}\n        return count_sequences_helper(N, a11, a12, a21, a22, memo)\n\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    return str(count_sequences(N, a11, a12, a21, a22))"
    },
    {
        "number": 3012,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    total_players = a11 + a12 + a21 + a22\n\n    if N < 1 or N > 10**18 or total_players > 5000:\n        return \"0\"\n\n    dp = [[0] * (N + 1) for _ in range(4)]\n    dp[0][1] = a11 + a12\n    dp[1][1] = a21 + a22\n    dp[2][1] = a11 + a12\n    dp[3][1] = a21 + a22\n\n    for i in range(3):\n        for j in range(2, N + 1):\n            dp[i][j] = (dp[i][j - 1] + dp[i][j - 2]) % MOD\n\n    for i in range(4):\n        for j in range(N + 1):\n            if i == 0:\n                dp[i][j] = (dp[i][j] * a11) % MOD\n            elif i == 1:\n                dp[i][j] = (dp[i][j] * a12) % MOD\n            elif i == 2:\n                dp[i][j] = (dp[i][j] * a21) % MOD\n            else:\n                dp[i][j] = (dp[i][j] * a22) % MOD\n\n    return str(sum(dp[0][1:]) + sum(dp[1][1:]) + sum(dp[2][1:]) + sum(dp[3][1:])) % MOD)"
    },
    {
        "number": 3012,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def count_sequences(N: int) -> int:\n        if N == 1:\n            return a11 + a12 + a21 + a22\n        elif N == 2:\n            return ((a11 * (a11 - 1) // 2) % mod + (a11 * a12) % mod + (a11 * a21) % mod + (a12 * a22) % mod) * 2\n        else:\n            return ((a11 * (a11 - 1) // 2) % mod + (a11 * a12) % mod + (a11 * a21) % mod + (a12 * a22) % mod) * (count_sequences(N - 1) % mod)\n\n    return str(count_sequences(N))"
    },
    {
        "number": 3012,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    mod = 1000000007\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    if a11 + a12 + a21 + a22 <= 0 or N <= 0:\n        return str(0)\n\n    dp = [[0] * (a11 + a12 + a21 + a22 + 1) for _ in range(N + 1)]\n    dp[0][a11 + a21] = 1\n\n    for i in range(1, N + 1):\n        for j in range(1, a11 + a12 + a21 + a22 + 1):\n            dp[i][j] += dp[i - 1][j] * (j - 1) % mod\n            if j >= a11 + a21:\n                dp[i][j] += dp[i - 3][j] * (j - a11 - a21) % mod\n\n    return str(dp[N][a11 + a21] % mod)"
    },
    {
        "number": 3012,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    mod = 1000000007\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    if a11 + a12 + a21 + a22 < 1:\n        return \"0\"\n\n    dp = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n    dp[1][1] = a11\n    dp[1][2] = a12\n    dp[2][1] = a21\n    dp[2][2] = a22\n\n    for i in range(N):\n        new_dp = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n        for j in range(3):\n            for k in range(3):\n                if j == k:\n                    continue\n                for l in range(3):\n                    if l == k:\n                        continue\n                    if j == 1 and k == 1:\n                        new_dp[j][k] += dp[j][l] * dp[k][l]\n                        new_dp[j][k] %= mod\n                    elif j == 1:\n                        new_dp[j][k] += dp[j][l] * dp[k][l]\n                        new_dp[j][k] %= mod\n                    elif k == 1:\n                        new_dp[j][k] += dp[j][l] * dp[k][l]\n                        new_dp[j][k] %= mod\n        dp = new_dp\n\n    return str(sum(dp[1][1:]) % mod)"
    },
    {
        "number": 3012,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    # Calculate the number of sequences of moves\n    total_players = a11 + a12 + a21 + a22\n    sequences = pow(total_players, N, 1000000007)\n\n    # Subtract the sequences with rest periods\n    rest_periods = 0\n    for i in range(N - 1):\n        rest_periods += pow(a11 + a21, i + 1, 1000000007)\n    sequences -= rest_periods\n\n    # Subtract the sequences with consecutive successful attacks\n    consecutive_success = pow(a11, 3, 1000000007) * pow(a11 + a12 + a21, N - 3, 1000000007)\n    sequences -= consecutive_success\n\n    # Return the result\n    return str(sequences % 1000000007)"
    },
    {
        "number": 3012,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    \n    def count_sequences(N, atk_count, def_count):\n        if N == 0:\n            return 1\n        if atk_count == 0 or def_count == 0:\n            return 0\n        result = 0\n        for i in range(max(atk_count, def_count) + 1):\n            result += count_sequences(N - 1, atk_count - i, def_count)\n            result %= MOD\n        return result\n    \n    total_atk = a11 + a21\n    total_def = a12 + a22\n    result = count_sequences(N, total_atk, total_def)\n    return str(result)"
    },
    {
        "number": 3013,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n\n    def get_spiral_point(phi):\n        r = b * phi\n        x = r * math.cos(phi)\n        y = r * math.sin(phi)\n        return x, y\n\n    def is_intersect(px, py, cx, cy):\n        p2_x, p2_y = get_spiral_point(phi + 0.1)\n        return ((p2_y - py) * (cx - px) - (p2_x - px) * (cy - py)) < 0\n\n    def find_release_point(px, py):\n        start_phi = math.atan2(py, px)\n        end_phi = start_phi + 2 * math.pi\n        phi_step = 0.001\n        while True:\n            phi = start_phi + phi_step\n            cx, cy = get_spiral_point(phi)\n            if is_intersect(px, py, cx, cy):\n                phi_step /= 2\n            else:\n                if phi_step < 0.0001:\n                    return cx, cy\n                start_phi = phi\n\n    px, py = 0, 0\n    cx, cy = find_release_point(px, py)\n\n    dx = t_x - cx\n    dy = t_y - cy\n    distance = math.sqrt(dx * dx + dy * dy)\n    direction_x = dx / distance\n    direction_y = dy / distance\n\n    release_x = cx + direction_x * 1.001\n    release_y = cy + direction_y * 1.001\n\n    return \"{:.8f} {:.8f}\".format(release_x, release_y)"
    },
    {
        "number": 3013,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = list(map(float, stdin.split()))\n\n    def get_spiral_coord(angle):\n        return b * angle * cos(angle), b * angle * sin(angle)\n\n    def distance_to_spiral(x, y):\n        angle = atan2(y, x)\n        return sqrt((x - get_spiral_coord(angle)[0])**2 + (y - get_spiral_coord(angle)[1])**2)\n\n    def find_intersection_point(p1, p2, angle):\n        x1, y1 = p1\n        x2, y2 = p2\n        cx1, cy1 = get_spiral_coord(angle)\n        cx2, cy2 = get_spiral_coord(angle + 0.01)\n        k = (y2 - y1) / (x2 - x1)\n        m = y1 - k * x1\n        A = k**2 + 1\n        B = 2 * (k * m - k * cy1 - cy2)\n        C = cy2**2 + (m - k * cx1)**2 - 2 * cy2 * m - b**2\n        x_intersection = (-B + sqrt(B**2 - 4 * A * C)) / (2 * A)\n        y_intersection = k * x_intersection + m\n        return x_intersection, y_intersection\n\n    angle_step = 0.01\n    angle = angle_step\n    while distance_to_spiral(t_x, t_y) >= 10**-3:\n        p1 = get_spiral_coord(angle - angle_step)\n        p2 = get_spiral_coord(angle)\n        intersection_point = find_intersection_point(p1, p2, angle)\n        if distance(intersection_point, (t_x, t_y)) < distance_to_spiral(t_x, t_y):\n            t_x, t_y = intersection_point\n            angle += angle_step\n        else:\n            angle -= angle_step\n\n    return f\"{t_x:.8f} {t_y:.8f}\""
    },
    {
        "number": 3013,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n\n    def phi(x):\n        return x * (1 + b ** 2) ** 0.5\n\n    def spiral(x):\n        return phi(x) * (1 if x >= 0 else -1)\n\n    def find_intersection_point(target, r):\n        dx, dy = target\n        x = r / b\n        y = spiral(x)\n        while (x - r) ** 2 + (y - dy) ** 2 > 1e-6:\n            x -= (x - r) / 1000\n            y = spiral(x)\n        return x, y\n\n    target = (t_x, t_y)\n    r = (t_x ** 2 + t_y ** 2) ** 0.5\n    intersection_point = find_intersection_point(target, r)\n\n    return f\"{intersection_point[0]:.9f} {intersection_point[1]:.9f}\""
    },
    {
        "number": 3013,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n\n    def get_spiral_point(phi):\n        r = b * phi\n        x = r * math.cos(phi)\n        y = r * math.sin(phi)\n        return x, y\n\n    def get_distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def get_closest_spiral_point(point):\n        phi = 0\n        spiral_point = get_spiral_point(phi)\n        min_distance = get_distance(point, spiral_point)\n\n        while True:\n            phi += 0.1\n            spiral_point = get_spiral_point(phi)\n            distance = get_distance(point, spiral_point)\n\n            if distance < min_distance:\n                min_distance = distance\n            else:\n                return phi - 0.1, spiral_point\n\n    def get_intersection_point(p1, p2, p3, p4):\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        x4, y4 = p4\n\n        d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if d == 0:\n            return None\n\n        x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d\n        y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d\n\n        return x, y\n\n    target = (tx, ty)\n    closest_spiral_phi, closest_spiral_point = get_closest_spiral_point(target)\n    spiral_direction = get_spiral_point(closest_spiral_phi + 0.01)\n    release_point = (closest_spiral_point[0] + tx, closest_spiral_point[1] + ty)\n\n    intersection_point = get_intersection_point(closest_spiral_point, spiral_direction, target, release_point)\n\n    if intersection_point:\n        return \"{} {}\".format(*intersection_point)\n    else:\n        return \"{} {}\".format(*release_point)"
    },
    {
        "number": 3013,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n\n    def get_spiral_point(phi):\n        r = b * phi\n        return r * cos(phi), r * sin(phi)\n\n    def distance_to_spiral(x, y):\n        r = hypot(x, y)\n        phi = acos(x / r)\n        spiral_x, spiral_y = get_spiral_point(phi)\n        return hypot(x - spiral_x, y - spiral_y)\n\n    def distance_to_target(x, y):\n        return hypot(x - t_x, y - t_y)\n\n    def binary_search(left, right):\n        while abs(right - left) > 1e-5:\n            mid = (left + right) / 2\n            if distance_to_spiral(0, mid) > 1e-3:\n                right = mid\n            else:\n                left = mid\n        return (left + right) / 2\n\n    # Find the point on the spiral where the avatar should leave the spiral\n    y_detach = binary_search(-2 * pi * b, 2 * pi * b)\n    x_detach = y_detach / tan(acos(t_x / hypot(t_x, t_y)))\n\n    # Check if the avatar will hit the target without intersecting the spiral\n    if distance_to_target(x_detach, y_detach) > distance_to_spiral(x_detach, y_detach):\n        return f\"{x_detach:.8f} {y_detach:.8f}\"\n    else:\n        raise ValueError(\"The avatar will intersect the spiral if it leaves at the given point.\")"
    },
    {
        "number": 3013,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n\n    def spiral_point(phi):\n        return b * phi * cos(phi), b * phi * sin(phi)\n\n    def distance_to_spiral(x, y):\n        return abs(atan2(y, x) - 2 * pi * b)\n\n    def distance_to_target(x, y):\n        return sqrt((x - t_x) ** 2 + (y - t_y) ** 2)\n\n    def point_on_spiral_tangent(phi):\n        x, y = spiral_point(phi)\n        tangent_slope = -1 / tan(phi)\n        target_slope = (t_y - y) / (t_x - x)\n        intersection_angle = atan((tangent_slope - target_slope) / (1 + tangent_slope * target_slope))\n        intersection_x, intersection_y = x + b * phi * cos(intersection_angle), y + b * phi * sin(intersection_angle)\n        return intersection_x, intersection_y\n\n    phi = atan2(t_y, t_x)\n    while distance_to_target(*spiral_point(phi)) > distance_to_target(*point_on_spiral_tangent(phi)):\n        phi -= pi / 2\n\n    x, y = point_on_spiral_tangent(phi)\n    return f\"{x:.8f} {y:.8f}\""
    },
    {
        "number": 3013,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n\n    def point_on_spiral(phi):\n        return b * phi * cos(phi), b * phi * sin(phi)\n\n    def distance_to_spiral(x, y):\n        phi = acos(x / (b * phi))\n        p = point_on_spiral(phi)\n        return sqrt((x - p[0]) ** 2 + (y - p[1]) ** 2)\n\n    def distance_to_target(x, y):\n        return sqrt((x - t_x) ** 2 + (y - t_y) ** 2)\n\n    def find_solution():\n        lo, hi = 0, 2 * pi\n        while hi - lo > 1e-5:\n            mid = (lo + hi) / 2\n            if distance_to_spiral(mid * cos(mid), mid * sin(mid)) > distance_to_target(mid * cos(mid), mid * sin(mid)):\n                lo = mid\n            else:\n                hi = mid\n        return point_on_spiral(lo)\n\n    return \"{:.8f} {:.8f}\".format(*find_solution())"
    },
    {
        "number": 3013,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def spiral_points(b, r):\n        theta = b * r\n        x = r * np.cos(theta)\n        y = r * np.sin(theta)\n        return x, y\n\n    def distance_to_spiral(b, x, y):\n        r = np.sqrt(x ** 2 + y ** 2)\n        theta = b * r\n        spiral_x, spiral_y = spiral_points(b, r)\n        return np.sqrt((x - spiral_x) ** 2 + (y - spiral_y) ** 2)\n\n    def target_hit_time(b, t_x, t_y):\n        r_target = np.sqrt(t_x ** 2 + t_y ** 2)\n        theta_target = b * r_target\n        theta_x = np.arccos(t_x / r_target)\n        theta_y = np.arcsin(t_y / r_target)\n        return theta_target - theta_x - theta_y\n\n    def find_release_point(b, t_x, t_y):\n        r_target = np.sqrt(t_x ** 2 + t_y ** 2)\n        theta_release = target_hit_time(b, t_x, t_y)\n        release_x, release_y = spiral_points(b, theta_release)\n        return release_x, release_y\n\n    b, t_x, t_y = map(float, stdin.split())\n    release_x, release_y = find_release_point(b, t_x, t_y)\n    return f\"{release_x:.8f} {release_y:.8f}\""
    },
    {
        "number": 3013,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n\n    def get_point_on_spiral(phi):\n        r = b * phi\n        x = r * math.cos(phi)\n        y = r * math.sin(phi)\n        return x, y\n\n    def get_phi_from_point(x, y):\n        r = math.sqrt(x ** 2 + y ** 2)\n        phi = r / b\n        return phi\n\n    def is_point_on_spiral(x, y):\n        r = math.sqrt(x ** 2 + y ** 2)\n        phi = r / b\n        new_x, new_y = get_point_on_spiral(phi)\n        return math.isclose(x, new_x, rel_tol=1e-5) and math.isclose(y, new_y, rel_tol=1e-5)\n\n    def get_distance_from_point_to_spiral(x, y):\n        r = math.sqrt(x ** 2 + y ** 2)\n        phi = r / b\n        new_x, new_y = get_point_on_spiral(phi)\n        return math.sqrt((x - new_x) ** 2 + (y - new_y) ** 2)\n\n    def get_distance_from_point_to_target(x, y):\n        return math.sqrt((x - t_x) ** 2 + (y - t_y) ** 2)\n\n    phi = 2 * math.pi\n    while True:\n        x, y = get_point_on_spiral(phi)\n        if not is_point_on_spiral(t_x, t_y) and not is_point_on_spiral(x + t_x, y + t_y):\n            break\n        phi += 0.01\n\n    closest_distance = get_distance_from_point_to_spiral(t_x, t_y)\n    closest_point = (t_x, t_y)\n\n    for angle in range(0, int(phi), 10):\n        x, y = get_point_on_spiral(angle)\n        distance = get_distance_from_point_to_spiral(x, y)\n        if distance < closest_distance:\n            closest_distance = distance\n            closest_point = (x, y)\n\n    return \"{:.8f} {:.8f}\".format(*closest_point)"
    },
    {
        "number": 3013,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n    \n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n    \n    def get_spiral_point(phi):\n        return (b * phi * np.cos(phi), b * phi * np.sin(phi))\n    \n    def find_intersection_point(p1, p2, p3, p4):\n        s1_x = p2[0] - p1[0]\n        s1_y = p2[1] - p1[1]\n        s2_x = p4[0] - p3[0]\n        s2_y = p4[1] - p3[1]\n\n        s = (-s1_y * (p1[0] - p3[0]) + s1_x * (p1[1] - p3[1])) / (-s2_x * s1_y + s1_x * s2_y)\n        t = (s2_x * (p1[1] - p3[1]) - s2_y * (p1[0] - p3[0])) / (-s2_x * s1_y + s1_x * s2_y)\n\n        return (p1[0] + (t * s1_x), p1[1] + (t * s1_y))\n\n    def find_best_point(p1, p2, p3):\n        min_distance = float('inf')\n        best_point = None\n        for phi in np.arange(0, 2 * np.pi, 0.001):\n            spiral_point = get_spiral_point(phi)\n            intersection_point = find_intersection_point(p1, p2, spiral_point, p3)\n            dist = distance(intersection_point, p3)\n            if dist < min_distance:\n                min_distance = dist\n                best_point = spiral_point\n        return best_point\n\n    p1 = (0, 0)\n    p2 = get_spiral_point(2 * np.pi)\n    p3 = (t_x, t_y)\n\n    best_point = find_best_point(p1, p2, p3)\n\n    return f\"{best_point[0]:.8f} {best_point[1]:.8f}\" "
    },
    {
        "number": 3014,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        graph[u - 1].append(v - 1)\n\n    def dfs(node, visited, parent):\n        if visited[node]:\n            return False\n        visited[node] = True\n        for neighbor in graph[node]:\n            if neighbor == parent or dfs(neighbor, visited, node):\n                return True\n        visited[node] = False\n        return False\n\n    removed = []\n    for i in range(n):\n        visited = [False] * n\n        if dfs(i, visited, -1):\n            removed.append(i)\n            for j in range(n):\n                if j in graph[i] and j not in removed:\n                    removed.append(j)\n            break\n\n    return f\"{len(removed)}\\n{' '.join(map(str, removed))}\""
    },
    {
        "number": 3014,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected(graph, visited, current, target, path):\n        if current == target:\n            return True\n        visited.add(current)\n        for neighbor in graph[current]:\n            if neighbor not in visited and is_connected(graph, visited, neighbor, target, path):\n                path.append(neighbor)\n                return True\n        return False\n\n    def find_cycles(graph, visited, current, path):\n        visited.add(current)\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                if is_connected(graph, set(), neighbor, current, path):\n                    return True\n        return False\n\n    input_list = list(map(int, stdin.split()))\n    n, m = input_list[0], input_list[1]\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v = input_list[2 + i * 2], input_list[2 + i * 2 + 1]\n        graph[u].append(v)\n\n    removed_corridors = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j and j not in graph[i]:\n                graph[i].append(j)\n                if find_cycles(graph, set(), i, []):\n                    removed_corridors.append((i, j))\n                graph[i].remove(j)\n\n    r = len(removed_corridors) // 2\n    output = [str(r)]\n    for i in range(r):\n        output.append(str(removed_corridors[i][0]) + \" \" + str(removed_corridors[i][1]))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3014,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    corridors = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    graph = {i: [] for i in range(1, n + 1)}\n    for u, v in corridors:\n        graph[u].append(v)\n\n    def dfs(node, visited):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if dfs(neighbor, visited):\n                return True\n        visited.remove(node)\n        return False\n\n    def has_cycle():\n        visited = set()\n        for node in graph:\n            if dfs(node, visited):\n                return True\n        return False\n\n    def remove_corridors(corridors_to_remove):\n        for corridor in corridors_to_remove:\n            u, v = corridor\n            graph[u].remove(v)\n\n    def find_max_corridors_to_remove():\n        for i in range(m // 2, -1, -1):\n            corridors_to_remove = corridors[:i]\n            remove_corridors(corridors_to_remove)\n            if not has_cycle():\n                return corridors_to_remove\n        return []\n\n    max_corridors_to_remove = find_max_corridors_to_remove()\n    return f\"{len(max_corridors_to_remove)}\\n\" + '\\n'.join(map(str, max_corridors_to_remove)) "
    },
    {
        "number": 3014,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_connected_components(graph):\n        visited = [False] * len(graph)\n        components = []\n        def dfs(vertex, component):\n            visited[vertex] = True\n            component.append(vertex)\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    dfs(neighbor, component)\n\n        for vertex in range(len(graph)):\n            if not visited[vertex]:\n                component = []\n                dfs(vertex, component)\n                components.append(component)\n\n        return components\n\n    def has_cycle(graph, start, visited, rec_stack):\n        visited[start] = True\n        rec_stack[start] = True\n\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if has_cycle(graph, neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[start] = False\n        return False\n\n    def has_cycles(graph):\n        visited = [False] * len(graph)\n        rec_stack = [False] * len(graph)\n        for vertex in range(len(graph)):\n            if not visited[vertex]:\n                if has_cycle(graph, vertex, visited, rec_stack):\n                    return True\n        return False\n\n    def build_graph(n, edges):\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u-1].append(v-1)\n        return graph\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    edges = [list(map(int, line.split())) for line in lines[1:m+1]]\n    graph = build_graph(n, edges)\n\n    connected_components = get_connected_components(graph)\n    corridors_to_remove = []\n\n    for component in connected_components:\n        component_graph = [[] for _ in range(len(component))]\n        for i in range(len(component)):\n            for j in range(len(graph[component[i]])):\n                if graph[component[i]][j] in component:\n                    component_graph[i].append(component.index(graph[component[i]][j]))\n\n        if has_cycles(component_graph):\n            for i in range(len(component)):\n                for j in range(len(graph[component[i]])):\n                    if graph[component[i]][j] in component:\n                        corridors_to_remove.append(edges.index((component[i]+1, graph[component[i]][j]+1)))\n\n    corridors_to_remove = sorted(set(corridors_to_remove))\n    result = [str(corridor) for corridor in corridors_to_remove]\n    return str(len(result)) + '\\n' + '\\n'.join(result) + '\\n'"
    },
    {
        "number": 3014,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def remove_corridors(graph, removed):\n        def dfs(node, visited):\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        dfs(neighbor, visited)\n\n        for corridor in removed:\n            u, v = corridor\n            graph[u].remove(v)\n            graph[v].remove(u)\n\n        visited = set()\n        for node in graph:\n            if node not in visited:\n                dfs(node, visited)\n\n        return not any(len(component) > 1 for component in visited)\n\n    def bfs(graph, removed):\n        def remove_corridors_helper(graph, removed):\n            for corridor in removed:\n                u, v = corridor\n                if u in graph and v in graph[u]:\n                    graph[u].remove(v)\n                if v in graph and u in graph[v]:\n                    graph[v].remove(u)\n\n        def bfs_helper(graph, start):\n            visited = set()\n            queue = [(start, None)]\n            while queue:\n                node, parent = queue.pop(0)\n                if node not in visited:\n                    visited.add(node)\n                    for neighbor in graph[node]:\n                        if neighbor != parent:\n                            queue.append((neighbor, node))\n            return visited\n\n        removed_count = 0\n        while removed_count < len(removed) // 2:\n            remove_corridors_helper(graph, removed)\n            for corridor in removed:\n                u, v = corridor\n                if not graph[u] or not graph[v]:\n                    removed.remove(corridor)\n                    removed_count += 1\n                    break\n            else:\n                for room in graph:\n                    if len(graph[room]) == 1:\n                        neighbor = graph[room][0]\n                        if len(graph[neighbor]) == 1:\n                            removed.append((room, neighbor))\n                            graph[room].remove(neighbor)\n                            graph[neighbor].remove(room)\n                            removed_count += 1\n                            break\n                else:\n                    for room in graph:\n                        if len(graph[room]) == 0:\n                            continue\n                        visited = bfs_helper(graph, room)\n                        if not all(len(component) == 1 for component in visited):\n                            for neighbor in graph[room]:\n                                if (room, neighbor) in removed:\n                                    removed.remove((room, neighbor))\n                                    graph[room].append(neighbor)\n                                    graph[neighbor].append(room)\n                                    removed_count -= 1\n                            break\n\n        return removed\n\n    def parse_input(stdin):\n        lines = stdin.split(\"\\n\")\n        n, m = map(int, lines[0].split())\n        graph = {i: set() for i in range(1, n + 1)}\n        for i in range(1, m + 1):\n            u, v = map(int, lines[i].split())\n            graph[u].add(v)\n            graph[v].add(u)\n        return graph, m\n\n    graph, m = parse_input(stdin)\n    removed = bfs(graph, [])\n    return f\"{len(removed)}\\n\" + \"\\n\".join(map(lambda x: f\"{x[0]} {x[1]}\", removed)) "
    },
    {
        "number": 3014,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_there_cycle(graph, visited, current, start):\n        if visited[current] == 0:\n            visited[current] = 1\n            for neighbor in graph[current]:\n                if is_there_cycle(graph, visited, neighbor, start):\n                    return True\n            visited[current] = 2\n        elif visited[current] == 1:\n            if current != start:\n                return True\n        return False\n\n    n, m = map(int, stdin.readline().strip().split())\n    corridors = []\n    for _ in range(m):\n        corridors.append(list(map(int, stdin.readline().strip().split()))[1:])\n\n    graph = [[] for _ in range(n)]\n    for u, v in corridors:\n        graph[u - 1].append(v - 1)\n\n    visited = [0] * n\n    to_remove = []\n    for i in range(n):\n        if not is_there_cycle(graph, visited, i, i):\n            for j in range(i + 1, n):\n                if i in graph[j] and j not in to_remove:\n                    to_remove.append((i + 1, j + 1))\n\n    return f\"{len(to_remove)}\\n\" + \"\\n\".join([\" \".join(map(str, edge)) for edge in to_remove])"
    },
    {
        "number": 3014,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, visited, rec_stack, start, node):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, rec_stack, start, neighbor):\n                    return True\n            elif rec_stack[neighbor] and node != neighbor:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    def remove_corridors(graph, num_corridors):\n        removed_corridors = []\n\n        for i in range(num_corridors):\n            u, v = corridors[i]\n            graph[u].remove(v)\n            removed_corridors.append(i + 1)\n\n            if not find_cycle(graph, [False] * len(rooms), [False] * len(rooms), u, u):\n                return removed_corridors\n\n            graph[u].append(v)\n            removed_corridors.pop()\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    rooms = [[] for _ in range(n)]\n    corridors = []\n\n    for i in range(m):\n        u, v = map(int, lines[i + 1].split())\n        rooms[u - 1].append(v - 1)\n        corridors.append((u - 1, v - 1))\n\n    max_corridors_to_remove = m // 2\n    corridors_to_remove = remove_corridors(rooms, max_corridors_to_remove)\n\n    if not corridors_to_remove:\n        return f'{max_corridors_to_remove}\\n' + '\\n'.join(map(str, range(1, m + 1)))\n    else:\n        return f'{len(corridors_to_remove)}\\n' + '\\n'.join(map(str, corridors_to_remove))"
    },
    {
        "number": 3014,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u, visited, graph, stack):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v, visited, graph, stack)\n        stack.append(u)\n\n    def create_graph(corridors):\n        graph = [[] for _ in range(n + 1)]\n        for u, v in corridors:\n            graph[u].append(v)\n        return graph\n\n    def find_cycles(graph, n):\n        visited = [False] * (n + 1)\n        stack = []\n        for i in range(1, n + 1):\n            if not visited[i]:\n                dfs(i, visited, graph, stack)\n\n        while stack:\n            u = stack.pop()\n            visited[u] = False\n            for v in graph[u]:\n                if not visited[v]:\n                    dfs(v, visited, graph[u], stack)\n                    graph[u].remove(v)\n\n    def count_cycles(graph, n):\n        cycle_count = 0\n        visited = [False] * (n + 1)\n        for i in range(1, n + 1):\n            if not visited[i]:\n                cycle_count += 1\n                dfs(i, visited, graph, [])\n        return cycle_count\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    corridors = [list(map(int, line.split())) for line in lines[1:m + 1]]\n\n    graph = create_graph(corridors)\n    find_cycles(graph, n)\n    cycle_count = count_cycles(graph, n)\n\n    if cycle_count == 0:\n        return '0\\n'\n\n    corridors_to_remove = [i for i in range(1, m + 1) if not graph[corridors[i - 1][0]][corridors[i - 1][1] - 1]]\n    corridors_to_remove = sorted(corridors_to_remove, reverse=True)\n\n    r = min(len(corridors_to_remove), cycle_count)\n    result = [str(corridors_to_remove.pop()) for _ in range(r)]\n\n    return f'{r}\\n' + '\\n'.join(result) + '\\n'"
    },
    {
        "number": 3014,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(start, visited, backtrack, graph):\n        visited[start] = True\n        backtrack[start] = True\n\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if find_cycle(neighbor, visited, backtrack, graph):\n                    return True\n            elif backtrack[neighbor]:\n                return True\n\n        backtrack[start] = False\n        return False\n\n    def find_cycles(n, m, corridors):\n        graph = [[] for _ in range(n)]\n        for i in range(m):\n            u, v = corridors[i]\n            graph[u - 1].append(v - 1)\n\n        visited = [False] * n\n        backtrack = [False] * n\n        result = []\n\n        for i in range(n):\n            if not visited[i]:\n                if find_cycle(i, visited, backtrack, graph):\n                    for j in range(m):\n                        u, v = corridors[j]\n                        if u == i + 1 or v == i + 1:\n                            result.append(j + 1)\n        return result\n\n    input_data = list(map(int, stdin.split()))\n    n, m = input_data[0], input_data[1]\n    corridors = [tuple(map(int, input_data[i + 2].split())) for i in range(m)]\n\n    result = find_cycles(n, m, corridors)\n    return f\"{len(result)}\\n{' '.join(map(str, result))}\""
    },
    {
        "number": 3014,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, visited, current, start):\n        visited[current] = True\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, neighbor, start):\n                    return True\n            elif neighbor != start:\n                return True\n        return False\n\n    def remove_cycle(graph, corridors, index):\n        start, end = corridors[index - 1]\n        if start in graph[end]:\n            graph[end].remove(start)\n        else:\n            graph[start].remove(end)\n\n    def find_max_corridors_to_remove(graph, corridors):\n        for i in range(len(corridors), 0, -1):\n            graph_copy = [set(adj) for adj in graph]\n            for j in range(i):\n                remove_cycle(graph_copy, corridors, j)\n            visited = [False] * len(graph_copy)\n            if not find_cycle(graph_copy, visited, 0, 0):\n                return i\n        return 0\n\n    num_rooms, num_corridors = map(int, stdin.readline().strip().split())\n    corridors = [tuple(map(int, stdin.readline().strip().split())) for _ in range(num_corridors)]\n\n    graph = [set() for _ in range(num_rooms)]\n    for room1, room2 in corridors:\n        graph[room1 - 1].add(room2 - 1)\n        graph[room2 - 1].add(room1 - 1)\n\n    max_corridors_to_remove = find_max_corridors_to_remove(graph, corridors)\n    output = [str(max_corridors_to_remove)]\n\n    if max_corridors_to_remove > 0:\n        for i in range(max_corridors_to_remove):\n            remove_cycle(graph, corridors, i)\n            output.append(str(i + 1))\n\n    return \"\\n\".join(output) + \"\\n\""
    },
    {
        "number": 3015,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    visited = [False] * n\n    for _ in range(m):\n        a, b, w = map(int, input().split())\n        graph[a].append((b, w))\n\n    def dfs(node, step):\n        visited[node] = True\n        for next_node, weight in graph[node]:\n            if not visited[next_node]:\n                if dfs(next_node, step + weight):\n                    return True\n        visited[node] = False\n        return node == t\n\n    left_time = 0\n    while not dfs(s, 0):\n        left_time += 1\n        for i in range(n):\n            if visited[i]:\n                visited[i] = False\n\n    return \"infinity\" if left_time >= 10**4 else left_time * 2\n\nn, m, s, t = map(int, input().split())\nprint(solution(input())) "
    },
    {
        "number": 3015,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    visited = set()\n    left_tubes = []\n    current_ball = s\n    left_time = 0\n    right_time = 0\n    total_time = 0\n\n    while True:\n        if current_ball == t:\n            total_time += min(left_time, right_time)\n            break\n\n        if current_ball in visited:\n            total_time = float('infinity')\n            break\n\n        visited.add(current_ball)\n\n        left_tube, right_tube = None, None\n        for a, b, w in tubes:\n            if a == current_ball:\n                if left_time == 0:\n                    left_tube = (a, b, w)\n                else:\n                    right_tube = (a, b, w)\n            elif b == current_ball:\n                if left_time == 0:\n                    left_tube = (b, a, w)\n                else:\n                    right_tube = (b, a, w)\n\n        if left_tube:\n            left_tubes.append(left_tube)\n            current_ball = left_tube[1]\n            left_time = left_tube[2]\n            right_time = 0\n        elif right_tube:\n            current_ball = right_tube[1]\n            right_time = right_tube[2]\n\n        total_time += min(left_time, right_time)\n        left_time = max(0, left_time - right_time)\n        right_time = max(0, right_time - left_time)\n\n        if not left_tubes:\n            total_time = float('infinity')\n            break\n\n        left_tube = left_tubes.pop()\n        left_time = left_tube[2]\n\n    return str(total_time) if total_time != float('infinity') else \"infinity\""
    },
    {
        "number": 3015,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[0:4])\n    tubes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    visited = [False] * n\n    rest_time = [0] * n\n\n    def find_path(current_ball, ball_to_reach, current_time, left):\n        if current_ball == ball_to_reach:\n            return current_time + rest_time[current_ball]\n        else:\n            visited[current_ball] = True\n            for tube in tubes:\n                if tube[0] == current_ball and not visited[tube[1]]:\n                    time = tube[2]\n                    if left:\n                        rest_time[current_ball] += time\n                    else:\n                        rest_time[tube[1]] += time\n\n                    new_time = find_path(tube[1], ball_to_reach, current_time + time, not left)\n                    if new_time != float('inf'):\n                        return new_time\n            return float('inf')\n\n    result = find_path(s, t, 0, True)\n    if result == float('inf'):\n        return \"infinity\"\n    else:\n        return str(result)"
    },
    {
        "number": 3015,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [list(map(int, stdin.split()[4:])) for _ in range(m)]\n\n    visited = [False] * n\n    time = 0\n\n    def dfs(current, direction):\n        nonlocal time\n        visited[current] = True\n        for tube in tubes:\n            if tube[0] == current and not visited[tube[1]]:\n                if tube[1] == t:\n                    return True\n                if dfs(tube[1], 1 - direction):\n                    time += tube[2] * (1 - direction)\n                    return True\n        time += 1\n        return False\n\n    if dfs(s, 0):\n        return str(time)\n    else:\n        return \"infinity\""
    },
    {
        "number": 3015,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    visited = set()\n    left_tubes = []\n    right_tubes = []\n\n    def traverse(ball, time, hemisphere):\n        nonlocal visited, left_tubes, right_tubes\n\n        if ball == t:\n            return time\n\n        if (ball, hemisphere) in visited:\n            return None\n        visited.add((ball, hemisphere))\n\n        available_tubes = [tube for tube in tubes if tube[0] == ball and (tube[1], tube[2]) not in left_tubes and (tube[1], tube[2]) not in right_tubes]\n\n        if not available_tubes:\n            return None\n\n        for next_tube in available_tubes:\n            if hemisphere == \"left\":\n                left_tubes.append((next_tube[1], next_tube[2]))\n                new_time = traverse(next_tube[1], time + next_tube[2], \"right\")\n                if new_time is not None:\n                    return new_time\n                left_tubes.pop()\n            elif hemisphere == \"right\":\n                right_tubes.append((next_tube[1], next_tube[2]))\n                new_time = traverse(next_tube[1], time + next_tube[2], \"left\")\n                if new_time is not None:\n                    return new_time\n                right_tubes.pop()\n\n        return None\n\n    left_tubes.append((s, 0))\n    result = traverse(s, 0, \"left\")\n\n    return \"infinity\" if result is None else str(result)"
    },
    {
        "number": 3015,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, source, destination):\n        distances = {vertex: float('inf') for vertex in graph}\n        distances[source] = 0\n        vertices_count = len(graph)\n        visited = set()\n\n        while len(visited) < vertices_count:\n            current_vertex = None\n            current_distance = float('inf')\n\n            for vertex in distances:\n                if vertex not in visited and distances[vertex] < current_distance:\n                    current_vertex = vertex\n                    current_distance = distances[vertex]\n\n            if not current_vertex:\n                break\n\n            visited.add(current_vertex)\n\n            for neighbor, edge_weight in graph[current_vertex].items():\n                new_distance = current_distance + edge_weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n        return distances[destination] if destination in distances else None\n\n    stdin = stdin.split('\\n')\n    n, m, s, t = map(int, stdin[0].split())\n    graph = {i: {} for i in range(n)}\n\n    for i in range(1, m + 1):\n        a, b, w = map(int, stdin[i].split())\n        graph[a][b] = w\n\n    time_to_reach_bed = dijkstra(graph, s, t)\n\n    if time_to_reach_bed is not None:\n        return str(time_to_reach_bed)\n    else:\n        return 'infinity'"
    },
    {
        "number": 3015,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    tubes = [tuple(map(int, input().split())) for _ in range(m)]\n\n    visited = set()\n    steps = 0\n\n    def dfs(ball, direction):\n        nonlocal steps\n        if ball == t:\n            return True\n        if (ball, direction) in visited:\n            return False\n        visited.add((ball, direction))\n        for start, end, time in tubes:\n            if ball == start and (end not in visited or direction == 0):\n                if dfs(end, 1 - direction):\n                    steps += time if direction == 0 else 0\n                    return True\n        return False\n\n    if dfs(s, 0):\n        return str(steps)\n    else:\n        return \"infinity\""
    },
    {
        "number": 3015,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [tuple(map(int, stdin.split()[4:])) for i in range(m)]\n\n    # Initialize visited and distances\n    visited = [False] * n\n    distances = [float('inf')] * n\n    distances[s] = 0\n\n    # Dijkstra's algorithm with two phases\n    for i in range(n - 1):\n        # Find the next closest ball\n        dist = float('inf')\n        ball = -1\n        for j in range(n):\n            if not visited[j] and distances[j] < dist:\n                dist = distances[j]\n                ball = j\n        visited[ball] = True\n\n        # Update distances from this ball to adjacent balls\n        for tube in tubes:\n            if tube[0] == ball and not visited[tube[1]]:\n                distances[tube[1]] = min(distances[tube[1]], distances[ball] + tube[2])\n\n    # Check if Harry reached the bed\n    if distances[t] == float('inf'):\n        return 'infinity'\n    else:\n        return str(distances[t])"
    },
    {
        "number": 3015,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    visited = {s}\n    ball, time = s, 0\n    while ball != t:\n        next_tubes = []\n        for a, b, w in tubes:\n            if a == ball and b not in visited:\n                next_tubes.append((b, w))\n        if not next_tubes:\n            return \"infinity\"\n        ball, time = min(next_tubes, key=lambda x: x[1])\n        visited.add(ball)\n        time += 2\n    return time - 2"
    },
    {
        "number": 3015,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n, m, s, t = map(int, stdin.split()[:4])\n    balls = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, w = map(int, stdin.split()[4:])\n        balls[a].append((b, w))\n\n    # Initialize variables\n    visited = [False] * n\n    current_tube = [0] * n\n    current_time = [0] * n\n\n    # Breadth-first search\n    queue = [(s, 0)]\n    visited[s] = True\n    while queue:\n        ball, time = queue.pop(0)\n        current_tube[ball], current_time[ball] = 0, time\n        for i, (next_ball, tube_time) in enumerate(balls[ball]):\n            if not visited[next_ball]:\n                queue.append((next_ball, time + tube_time))\n                visited[next_ball] = True\n            elif next_ball == ball and i == len(balls[ball]) - 1:\n                current_tube[ball], current_time[ball] = 0, time\n                return \"infinity\"\n\n    # Check if Harry can reach his bed\n    if not visited[t]:\n        return \"infinity\"\n\n    # Calculate time to reach bed\n    time = current_time[t]\n    ball = t\n    while ball != s:\n        prev_ball, prev_time = None, float('inf')\n        for next_ball, tube_time in balls[ball]:\n            if current_time[next_ball] < prev_time and current_time[next_ball] + tube_time <= time:\n                prev_ball, prev_time = next_ball, current_time[next_ball] + tube_time\n        time = prev_time\n        ball = prev_ball\n\n    return time"
    },
    {
        "number": 3016,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *freqs = [int(x) for x in stdin.split('\\n')[0].split()]\n    k, *colors_not_next_to_each_other = [int(x) for x in stdin.split('\\n')[1].split()]\n    l, *fav_seq = [int(x) for x in stdin.split('\\n')[2].split()]\n\n    mod = 1000000007\n\n    def count_permutations(arr: list, k: int, l: int) -> int:\n        n = len(arr)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = 1\n\n        for gap in range(1, n):\n            for i in range(n - gap):\n                j = i + gap\n                if arr[i] != arr[j]:\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n        return dp[0][n - 1]\n\n    def count_permutations_with_fav_seq(arr: list, k: int, l: int) -> int:\n        n = len(arr)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = 1\n\n        for gap in range(1, n):\n            for i in range(n - gap):\n                j = i + gap\n                if arr[i] != arr[j]:\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n                else:\n                    dp[i][j] = dp[i + 1][j - 1]\n\n        total_count = dp[0][n - 1]\n\n        for i in range(n - l + 1):\n            j = i + l - 1\n            count = dp[i][j]\n            for x in range(i, j - l + 1):\n                y = x + l - 1\n                count -= dp[x + 1][y]\n                count -= dp[x][y - 1]\n                count += dp[x + 1][y - 1]\n            total_count -= count * (fav_seq[0] ** (l - 1))\n\n        return total_count\n\n    total_count = count_permutations(freqs, k, l)\n    total_count_with_fav_seq = count_permutations_with_fav_seq(freqs, k, l)\n\n    return str((total_count_with_fav_seq) % mod)"
    },
    {
        "number": 3016,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(colors, not_next, seq):\n        n = len(colors)\n        MOD = 1000000007\n\n        @lru_cache(maxsize=None)\n        def dp(i, j, k):\n            if i == n and k == 0:\n                return 1\n            if i == n or k == 0:\n                return 0\n\n            ways = dp(i + 1, j, k)\n\n            if not_next[j]:\n                ways += dp(i + 1, j, k - 1)\n\n            for l in range(n):\n                if l not in not_next[j] and l != colors[i]:\n                    ways += dp(i + 1, l, k)\n\n            return ways % MOD\n\n        total_ways = dp(0, seq[0], len(seq))\n\n        for i in range(1, n):\n            total_ways += dp(0, seq[0], len(seq)) * colors[i]\n            total_ways %= MOD\n\n        return total_ways\n\n    n, *colors = map(int, stdin.split())\n    not_next = [[] for _ in range(n)]\n    k, *not_next_colors = map(int, input().split())\n    for i in range(k):\n        not_next[not_next_colors[i] - 1].append(i)\n\n    l, *seq = map(int, input().split())\n\n    result = count_ways(colors, not_next, seq)\n    return str(result)"
    },
    {
        "number": 3016,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(sequence, invalid_colors):\n        for i in range(len(sequence) - 1):\n            if sequence[i] in invalid_colors and sequence[i + 1] in invalid_colors:\n                return False\n        return True\n\n    def count_arrangements(balls, sequence, modulo=1000000007):\n        n = len(balls)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(n):\n            if balls[i] == sequence[0]:\n                if i + len(sequence) <= n:\n                    for j in range(len(sequence)):\n                        if balls[i + j] != sequence[j]:\n                            break\n                    else:\n                        dp[i + len(sequence)] += dp[i]\n            for j in range(i + 1, n):\n                if balls[i] != balls[j] and balls[i] != sequence[0]:\n                    dp[j] += dp[i]\n\n        return dp[n] % modulo\n\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    balls = input_data[1:n + 1]\n    invalid_colors_count = input_data[n + 1]\n    invalid_colors = set(input_data[n + 2:n + 2 + invalid_colors_count])\n    sequence_length = input_data[n + 2 + invalid_colors_count]\n    sequence = input_data[n + 3 + invalid_colors_count:n + 3 + invalid_colors_count + sequence_length]\n\n    if not is_valid(sequence, invalid_colors):\n        return 0\n\n    return count_arrangements(balls, sequence)"
    },
    {
        "number": 3016,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_arrangements(freq, bad_colors, favorite_sequence):\n        total_balls = sum(freq)\n        mod = 1000000007\n\n        # Create a DP table to store the number of ways to arrange the balls\n        dp = [[0] * total_balls for _ in range(total_balls + 1)]\n\n        # Base case: When there are no balls, there is only one way to arrange them\n        for i in range(len(dp)):\n            dp[i][i] = 1\n\n        # Fill the DP table using the given conditions\n        for i in range(total_balls - 1, -1, -1):\n            for j in range(i + 1, total_balls):\n                # If the current color is not in the bad_colors list\n                if i not in bad_colors and j not in bad_colors:\n                    # Add the number of ways to arrange the balls excluding the current color\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n                else:\n                    # If the current color is in the bad_colors list, subtract the number of ways\n                    # to arrange the balls excluding the current color\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1] + dp[i + 1][j - 1]\n                dp[i][j] %= mod\n\n        # Calculate the total number of arrangements with the favorite sequence included as many times as possible\n        total_arrangements = 0\n        for i in range(len(favorite_sequence) - 1, -1, -1):\n            for j in range(i - 1, -1, -1):\n                total_arrangements += dp[sum(freq[:j + 1])][sum(freq[:i + 1])] - dp[sum(freq[:j])][sum(freq[:i + 1])]\n                total_arrangements %= mod\n\n        return total_arrangements\n\n    n, *freq = map(int, stdin.split())\n    bad_colors = list(map(int, stdin.split()))\n    favorite_sequence = list(map(int, stdin.split()))\n\n    return str(count_arrangements(freq, bad_colors, favorite_sequence))"
    },
    {
        "number": 3016,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_arrangements(colors, forbidden_pairs, favorite_sequence):\n        mod = 1000000007\n        n = len(colors)\n        total_balls = sum(colors)\n        dp = [[0] * n for _ in range(total_balls + 1)]\n        dp[0][0] = 1\n\n        for i in range(total_balls):\n            for j in range(n):\n                if dp[i][j]:\n                    for k in range(n):\n                        if j != k and (j, k) not in forbidden_pairs and (k, j) not in forbidden_pairs:\n                            dp[i + 1][k] += dp[i][j]\n\n        def helper(balls_left, sequence_left, prev_color):\n            if balls_left == 0 and sequence_left == 0:\n                return 1\n            if balls_left == 0 or sequence_left == 0:\n                return 0\n\n            total = 0\n            for i in range(n):\n                if i != prev_color and colors[i] >= balls_left and (i, prev_color) not in forbidden_pairs and (prev_color, i) not in forbidden_pairs:\n                    if i == favorite_sequence[len(favorite_sequence) - sequence_left]:\n                        total += helper(balls_left - colors[i], sequence_left - 1, i)\n                    else:\n                        total += helper(balls_left - colors[i], sequence_left, i)\n\n            return total % mod\n\n        return helper(total_balls, len(favorite_sequence), -1)\n\n    n, *colors = list(map(int, stdin.split()))\n    colors = colors[:n]\n    forbidden_pairs = set()\n    k = int(stdin.readline().strip())\n    for _ in range(k):\n        forbidden_pairs.add(tuple(map(int, stdin.readline().strip().split())))\n    l = int(stdin.readline().strip())\n    favorite_sequence = list(map(int, stdin.readline().strip().split()))[:l]\n\n    return str(count_arrangements(colors, forbidden_pairs, favorite_sequence))"
    },
    {
        "number": 3016,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    modulo = 1000000007\n    n, colors, forbidden, sequence = map(int, stdin.split())\n    colors = list(map(int, colors.split()))\n    forbidden = list(map(int, forbidden.split()))\n    sequence = list(map(int, sequence.split()))\n\n    def count_arrangements(colors, forbidden, sequence, modulo=modulo):\n        if not colors:\n            return 1\n        if not sequence:\n            return factorial(sum(colors))\n\n        color, *rest = colors\n        if color < sequence[0]:\n            return count_arrangements(rest, forbidden, sequence, modulo) * factorial(color) % modulo\n\n        next_color = sequence[0]\n        if next_color in forbidden:\n            return 0\n\n        index = colors.index(next_color)\n        colors[index], colors[0] = colors[0], colors[index]\n\n        count = count_arrangements(colors[1:], forbidden, sequence[1:], modulo) * (color - (next_color - 1)) % modulo\n        count += count_arrangements(colors[1:], forbidden, sequence, modulo) * (color - next_color) % modulo\n\n        colors[index], colors[0] = colors[0], colors[index]\n        return count\n\n    def factorial(n, modulo=modulo):\n        fact = 1\n        for i in range(1, n + 1):\n            fact = (fact * i) % modulo\n        return fact\n\n    return str(count_arrangements(colors, forbidden, sequence))"
    },
    {
        "number": 3016,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, *freq = map(int, stdin.split())\n    k, *dislike_colors = map(int, input().split())\n    l, *favorite_sequence = map(int, input().split())\n\n    MOD = 1000000007\n\n    def count_arrangements(freq, dislike_colors, favorite_sequence):\n        total_balls = sum(freq)\n        dp = [0] * (total_balls + 1)\n        dp[0] = 1\n\n        for color, count in enumerate(freq, 1):\n            for i in range(count, total_balls - (l - 1) * max(count, 1) + 1):\n                dp[i + count] += dp[i]\n                dp[i + count] %= MOD\n\n            if color in dislike_colors:\n                for i in range(count, total_balls - (l - 1) * max(count, 1) + 1):\n                    dp[i + count] -= dp[i]\n                    dp[i + count] %= MOD\n\n        return dp[total_balls]\n\n    return str(count_arrangements(freq, dislike_colors, favorite_sequence))"
    },
    {
        "number": 3016,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_permutations(colors, not_next, seq):\n        mod = 1000000007\n        n = len(colors)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(n):\n            if i > 0:\n                dp[i] = (dp[i - 1] + dp[i]) % mod\n            if i + 1 < n and not_next[colors[i]] != colors[i + 1]:\n                dp[i + 1] = (dp[i + 1] + dp[i]) % mod\n        return dp[n - 1]\n\n    stdin = stdin.split('\\n')\n    n = int(stdin[0].split()[0])\n    colors = [int(x) for x in stdin[0].split()[1:]]\n    not_next = {int(x): True for x in stdin[1].split()}\n    seq = [int(x) for x in stdin[2].split()[1:]]\n\n    if seq:\n        if seq[0] not in colors or seq[-1] not in colors:\n            return '0'\n        if seq[0] in not_next or seq[-1] in not_next:\n            return '0'\n\n    return str(count_permutations(colors, not_next, seq))"
    },
    {
        "number": 3016,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, *freq, *dislike_colors, k, *dislike_colors, l, *preferred_sequence = map(int, stdin.split())\n    mod = 1000000007\n\n    # Create a list of tuples to represent the available balls\n    balls = [(i, j) for i, j in enumerate(freq, 1) if j > 0]\n\n    # Initialize the count variable\n    count = 0\n\n    # Recursive function to arrange the balls\n    def arrange(current_balls, used_colors):\n        nonlocal count\n\n        # If there are no more balls left, increment the count\n        if not current_balls:\n            count += 1\n            return\n\n        # Find the next ball to place\n        for i, (color, remaining) in enumerate(current_balls):\n            if color in used_colors or (i > 0 and current_balls[i - 1][0] in dislike_colors and color in dislike_colors):\n                continue\n\n            # Place the ball and update the used colors\n            new_used_colors = used_colors | {color}\n            if l > 0 and color == preferred_sequence[0] and tuple(preferred_sequence) in str(current_balls[i:]):\n                new_used_colors = new_used_colors | set(preferred_sequence)\n            arrange(current_balls[:i] + current_balls[i + 1:], new_used_colors)\n\n    # Call the recursive function\n    arrange(balls, set())\n\n    # Return the result\n    return str(count % mod)"
    },
    {
        "number": 3016,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, *freq, k, *rest = map(int, stdin.split())\n    forbidden = set(rest[:k])\n    favorite = rest[k:]\n    mod = 1000000007\n\n    @lru_cache(maxsize=None)\n    def count_ways(start: int, remaining: tuple, must_use: int) -> int:\n        if must_use > 0:\n            for i, f in enumerate(favorite, start):\n                if freq[f - 1] >= must_use and (i == start or f not in forbidden):\n                    new_remaining = tuple(x - (f == x) for x in remaining)\n                    new_must_use = must_use - (f == start)\n                    result = count_ways(i, new_remaining, new_must_use)\n                    if result > 0:\n                        return result\n            return 0\n        elif not remaining:\n            return 1\n        else:\n            total = 0\n            for i, f in enumerate(range(1, n + 1), start):\n                if freq[f - 1] > 0 and (i == start or f not in forbidden):\n                    new_remaining = tuple(x - (f == x) for x in remaining)\n                    result = count_ways(i, new_remaining, 0)\n                    if result > 0:\n                        total += result\n            return total % mod\n\n    return str(count_ways(0, (freq[i - 1] for i in favorite), len(favorite)))"
    },
    {
        "number": 3017,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    max_power = 10 ** e\n    count = 0\n    for i in range(n // max_power + 1):\n        for j in range(max_power, 10 * max_power):\n            if \"2\" * e in str(i * j):\n                count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n\n    def count_powers(n: int, e: int) -> int:\n        power_str = str(2 ** e)\n        length = len(power_str)\n        count = 0\n\n        for i in range(len(str(n)) - length + 1):\n            if str(n)[i:i + length] == power_str:\n                count += 1\n\n        return count\n\n    result = count_powers(n, e)\n    return str(result)"
    },
    {
        "number": 3017,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    max_power = 10 ** e\n    for i in range(1, n + 1):\n        if i % max_power == 0:\n            count += 1\n            continue\n        if max_power % i == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    limit = 10 ** (e + 1)\n    for i in range(1, n + 1):\n        if int(str(2 ** e)[1:-1]) <= i % limit:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for k in range(n + 1):\n        if str(2**e) in str(k):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n\n    # Find the number of digits in 2^e\n    digits = e\n    power_of_two = 2**e\n    while power_of_two > 0:\n        power_of_two //= 10\n        digits += 1\n\n    # Create a set to store the distinct numbers that contain the digits of 2^e as a substring\n    numbers = set()\n\n    # Iterate through all numbers from 0 to n\n    for i in range(n+1):\n        # Convert the number to a string\n        num_str = str(i)\n\n        # Check if the digits of 2^e are a substring of the number\n        if all(num_str[j:j+digits] == str(power_of_two) for j in range(len(num_str)-digits+1)):\n            numbers.add(i)\n\n    return str(len(numbers))"
    },
    {
        "number": 3017,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n + 1):\n        if str(2**e) in str(i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        if str(2**e) in str(i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    max_num = n + 1\n    \n    count = 0\n    for k in range(max_num):\n        if str(2**e) in str(k):\n            count += 1\n    \n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for k in range(n + 1):\n        if str(2 ** e) in str(k):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3018,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    K, T = map(int, lines[0].split())\n    first_roll = list(map(int, lines[1].split()))\n\n    probabilities = {}\n    max_prob = 0\n\n    for i in range(K, 0, -1):\n        total = sum(first_roll[:i])\n        remaining = K - i\n\n        if total + remaining * 6 >= T:\n            prob = 1 / 6 ** remaining\n            if prob > max_prob:\n                max_prob = prob\n                probabilities[i] = prob\n            elif prob == max_prob:\n                probabilities[i] = prob\n\n    if not probabilities:\n        return 0\n\n    max_prob_key = min(probabilities.keys())\n    return max_prob_key"
    },
    {
        "number": 3018,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[0:2])\n    dice_numbers = list(map(int, stdin.split()[2:]))\n    possible_numbers = set()\n    for i in range(K):\n        for j in range(i, K):\n            possible_numbers.add(dice_numbers[i] + dice_numbers[j])\n    \n    max_probability = 0\n    max_pick_up = 0\n    for i in range(1, K + 1):\n        current_probability = 0\n        for number in possible_numbers:\n            if number <= T and (T - number) % (6 * i) == 0:\n                current_probability = 1 / (6 * i)\n                break\n        if current_probability > max_probability:\n            max_probability = current_probability\n            max_pick_up = i\n    \n    return str(max_pick_up)"
    },
    {
        "number": 3018,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split('\\n')[0].split())\n    dice_values = list(map(int, stdin.split('\\n')[1].split()))\n\n    counts = [0] * (K + 1)\n    for value in dice_values:\n        counts[value] += 1\n\n    dp = [0] * (T + 1)\n    for i in range(1, 7):\n        dp[i] = 1\n\n    for i in range(2, T + 1):\n        for j in range(1, 7):\n            for k in range(1, K + 1):\n                if i - j * k > 0 and i - j * k <= T:\n                    dp[i] = max(dp[i], dp[i - j * k] + j * counts[k])\n\n    max_prob = 0\n    min_dice = K + 1\n    for i in range(1, K + 1):\n        if dp[T] - i * counts[i] > 0 and i < min_dice:\n            min_dice = i\n\n    return str(min_dice)"
    },
    {
        "number": 3018,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[0:2])\n    first_roll = list(map(int, stdin.split()[2:]))\n    max_prob = 0\n    max_pickup = 0\n\n    for pickup in range(K + 1):\n        prob = 0\n        for i in range(6 * pickup + 1):\n            if i + sum(first_roll) - pickup * 1 >= T:\n                prob += comb(K, pickup) * (1 / 6)**pickup * (1 / 6)**(K - pickup)\n        if prob > max_prob:\n            max_prob = prob\n            max_pickup = pickup\n\n    return str(max_pickup)"
    },
    {
        "number": 3018,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[:2])\n    dice_numbers = list(map(int, stdin.split()[2:]))\n\n    # Create a dictionary to store the sum and its frequency for each possible outcome\n    outcome_freq = {}\n    for i in range(1, 7):\n        for j in range(1, 7):\n            outcome_freq[i + j] = outcome_freq.get(i + j, 0) + 1\n\n    # Calculate the probability of each possible outcome\n    outcome_prob = {}\n    for key, value in outcome_freq.items():\n        outcome_prob[key] = value / 36\n\n    # Calculate the probability of getting the target number on the second roll\n    max_prob = 0\n    max_pickup = 0\n    for pickup in range(K + 1):\n        prob = 0\n        for i in range(1, 7):\n            for j in range(1, 7):\n                for k in range(pickup + 1):\n                    if i + j == T - (pickup - k):\n                        prob += outcome_prob[i] * outcome_prob[j]\n        if prob > max_prob:\n            max_prob = prob\n            max_pickup = pickup\n\n    return str(max_pickup)"
    },
    {
        "number": 3018,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    dice_numbers = list(map(int, input().split()))\n    \n    total_dice = sum(dice_numbers)\n    max_prob = 0\n    max_pickup = 0\n    \n    for i in range(K):\n        for j in range(i+1, K+1):\n            pickup_numbers = dice_numbers[:i] + dice_numbers[j:]\n            total_pickup = sum(pickup_numbers)\n            if total_pickup + total_dice - i - j == T:\n                prob = 1\n                for k in range(i):\n                    prob *= 1 - (1/6)\n                for k in range(j):\n                    prob *= (1/6)\n                if prob > max_prob:\n                    max_prob = prob\n                    max_pickup = i\n    \n    return str(max_pickup)"
    },
    {
        "number": 3018,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    dice_values = list(map(int, input().split()))\n    dice_counts = [0] * 7\n    for value in dice_values:\n        dice_counts[value] += 1\n    \n    probabilities = [0] * (T + 1)\n    for i in range(1, 7):\n        for j in range(i, 7):\n            for k in range(j, 7):\n                for l in range(k, 7):\n                    for m in range(l, 7):\n                        for n in range(m, 7):\n                            for o in range(n, 7):\n                                probabilities[i+j+k+l+m+n+o] += (1/216)\n    \n    max_probability = 0\n    max_dice_count = 0\n    for i in range(K):\n        for j in range(i, K):\n            for k in range(j, K):\n                for l in range(k, K):\n                    for m in range(l, K):\n                        for n in range(m, K):\n                            for o in range(n, K):\n                                new_probability = probabilities[T] * (1 - (sum(probabilities[:T]) * (len(dice_values) - i - j - k - l - m - n - o)))\n                                if new_probability > max_probability:\n                                    max_probability = new_probability\n                                    max_dice_count = i + j + k + l + m + n + o\n    \n    return str(max_dice_count)"
    },
    {
        "number": 3018,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_probability(dice_count, target_sum, current_sum, index, memo):\n        if (current_sum, index) in memo:\n            return memo[(current_sum, index)]\n\n        if current_sum == target_sum:\n            return 1.0\n\n        if index == 0 or current_sum > target_sum:\n            return 0.0\n\n        prob = 0.0\n        for i in range(1, dice_count + 1):\n            new_sum = current_sum + i\n            prob += (1.0 / 6) * calculate_probability(dice_count, target_sum, new_sum, index - 1, memo)\n\n        memo[(current_sum, index)] = prob\n        return prob\n\n    lines = stdin.splitlines()\n    K, T = map(int, lines[0].split())\n    first_roll = list(map(int, lines[1].split()))\n\n    memo = {}\n    max_prob = 0.0\n    max_dice_count = 0\n\n    for dice_count in range(1, K + 1):\n        prob = calculate_probability(K, T, dice_count, K, memo)\n        if prob > max_prob:\n            max_prob = prob\n            max_dice_count = dice_count\n\n    return str(max_dice_count)"
    },
    {
        "number": 3018,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split('\\n')[0].split())\n    dice_values = list(map(int, stdin.split('\\n')[1].split()))\n    total_dice_count = len(dice_values)\n\n    def count_combinations(target_sum, current_sum, index, combinations, memo):\n        if (index, current_sum) in memo:\n            return memo[(index, current_sum)]\n\n        if current_sum == target_sum:\n            return 1\n\n        if current_sum > target_sum or index == total_dice_count:\n            return 0\n\n        with_current = count_combinations(target_sum, current_sum + dice_values[index], index + 1, combinations, memo)\n        without_current = count_combinations(target_sum, current_sum, index + 1, combinations, memo)\n\n        memo[(index, current_sum)] = with_current + without_current\n        combinations[(index, current_sum)] = with_current\n\n        return with_current + without_current\n\n    memo = {}\n    combinations = {}\n    total_combinations = count_combinations(T, 0, 0, combinations, memo)\n\n    max_probability = 0\n    max_pickup_count = 0\n\n    for i in range(total_dice_count):\n        for j in range(i + 1, total_dice_count + 1):\n            pickup_count = j - i\n            current_sum = sum(dice_values[i:j])\n            remaining_combinations = total_combinations - combinations[(i, current_sum)]\n\n            if remaining_combinations > max_probability:\n                max_probability = remaining_combinations\n                max_pickup_count = pickup_count\n\n    return str(max_pickup_count)"
    },
    {
        "number": 3018,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_probability(num_dice, target_sum, roll):\n        if num_dice == 0:\n            return 1 if sum(roll) == target_sum else 0\n        elif sum(roll) > target_sum:\n            return 0\n        else:\n            prob = 0\n            for i in range(1, 7):\n                new_roll = roll + [i]\n                prob += get_probability(num_dice - 1, target_sum, new_roll)\n            return prob / 6\n\n    lines = stdin.split('\\n')\n    K, T = map(int, lines[0].split())\n    roll = list(map(int, lines[1].split()))\n\n    max_prob = 0\n    max_num_dice = 0\n    for i in range(K + 1):\n        prob = get_probability(i, T, roll[:K - i])\n        if prob > max_prob:\n            max_prob = prob\n            max_num_dice = i\n\n    return str(max_num_dice)"
    },
    {
        "number": 3019,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    S = list(map(int, stdin.readline().strip().split()))\n\n    def count_prime_factors(num):\n        factors = set()\n        for i in range(2, num + 1):\n            if num % i == 0:\n                factors.add(i)\n                while num % i == 0:\n                    num //= i\n        return len(factors)\n\n    total_revenue = 0\n    for i in range(1, N + 1):\n        revenue = 0\n        for j in range(i, N + 1, i):\n            revenue += count_prime_factors(S[j - 1])\n        total_revenue += revenue\n\n    return str(total_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    data = list(map(int, input().split()))\n    prime_factors = [set() for _ in range(N)]\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if gcd(data[i], data[j]) != 1:\n                prime_factors[i].add(data[i])\n                prime_factors[j].add(data[j])\n\n    revenues = [0] * N\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                revenues[i] += len(prime_factors[i] | prime_factors[j])\n\n    return str(max(revenues))\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_distinct_prime_factors(n):\n        prime_factors = set()\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                prime_factors.add(i)\n        if n > 1:\n            prime_factors.add(n)\n        return len(prime_factors)\n\n    N, *S = list(map(int, stdin.split()))\n    max_revenue = sum(count_distinct_prime_factors(sum(S)) for _ in range(N))\n\n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    S = [int(x) for x in stdin.split('\\n')[1].split()]\n    total = 0\n    \n    for i in range(1, N+1):\n        sum_S = sum(S[:i])\n        factors = set()\n        for j in range(2, int(sum_S**0.5)+1):\n            if sum_S % j == 0:\n                factors.add(j)\n                if sum_S // j != j:\n                    factors.add(sum_S // j)\n        total += len(factors)\n    \n    return str(total)"
    },
    {
        "number": 3019,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_prime_factors(n: int) -> int:\n        factors = 0\n        while n % 2 == 0:\n            factors += 1\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                factors += 1\n                n //= i\n        if n > 2:\n            factors += 1\n        return factors\n\n    def find_max_revenue(N: int, S: List[int]) -> int:\n        S_sum = [0] * N\n        for i in range(N):\n            for j in range(i, N):\n                S_sum[i] += S[j]\n        revenue = [0] * (N + 1)\n        for i in range(N - 1, -1, -1):\n            for j in range(i + 1, N + 1):\n                revenue[i] = max(revenue[i], revenue[j] + count_prime_factors(S_sum[i]))\n        return revenue[0]\n\n    N = int(stdin.split('\\n')[0])\n    S = list(map(int, stdin.split('\\n')[1].split()))\n    return str(find_max_revenue(N, S))"
    },
    {
        "number": 3019,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, *S = list(map(int, stdin.split()))\n    max_revenue = 0\n\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            revenue = len(set(prime_factors(S[i - 1] + S[j - 1])))\n            max_revenue = max(max_revenue, revenue)\n\n    return str(max_revenue)\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, S = list(map(int, stdin.split()))\n    def prime_factors(n):\n        factors = []\n        while n % 2 == 0:\n            factors.append(2)\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                factors.append(i)\n                n //= i\n        if n > 2:\n            factors.append(n)\n        return factors\n\n    def distinct_prime_factors(arr):\n        total = 0\n        for num in arr:\n            total += len(set(prime_factors(num)))\n        return total\n\n    max_revenue = 0\n    for i in range(1, N + 1):\n        for combo in itertools.combinations(S, i):\n            revenue = distinct_prime_factors(combo)\n            max_revenue = max(max_revenue, revenue)\n\n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    S = list(map(int, stdin.readline().strip().split()))\n\n    def count_distinct_prime_factors(num: int) -> int:\n        i = 2\n        factors = set()\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                num //= i\n                factors.add(i)\n        if num > 1:\n            factors.add(num)\n        return len(factors)\n\n    total_revenue = 0\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            data_sum = sum(S[i - 1:j])\n            revenue = count_distinct_prime_factors(data_sum)\n            total_revenue = max(total_revenue, revenue)\n\n    return str(total_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    input_list = list(map(int, stdin.split()))\n    N = input_list[0]\n    S = input_list[1:]\n\n    # find the sum of S_i for each customer\n    sum_S = [0] * N\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                sum_S[i] += S[j]\n\n    # count the number of distinct prime factors for each customer\n    def count_prime_factors(num):\n        count = 0\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                count += 1\n        return count\n\n    num_prime_factors = [0] * N\n    for i in range(N):\n        num_prime_factors[i] = count_prime_factors(sum_S[i])\n\n    # find the maximum revenue\n    max_revenue = sum(num_prime_factors)\n\n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    S = list(map(int, stdin.readline().strip().split()))\n    def count_distinct_prime_factors(num):\n        i = 2\n        factors = set()\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                num //= i\n                factors.add(i)\n        if num > 1:\n            factors.add(num)\n        return len(factors)\n    \n    revenue = [0] * N\n    for i in range(N):\n        for j in range(i+1, N):\n            if i != j:\n                revenue[i] += count_distinct_prime_factors(S[i]+S[j])\n    return str(max(revenue))"
    },
    {
        "number": 3020,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = 1\n\n    while True:\n        if pow(a, 2, 10) == n:\n            return str(a)\n        elif pow(a, 2, 10) > n:\n            return \"-1\"\n        a += 1\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def carryless_multiply(a: int, b: int) -> int:\n        if a == 0 or b == 0:\n            return 0\n        if a == 1:\n            return b\n        if b == 1:\n            return a\n        carryless_sum = 0\n        for i in range(1, len(str(a)) + 1):\n            for j in range(1, len(str(b)) + 1):\n                product = (int(str(a)[-i]) * int(str(b)[-j])) % 10\n                if i == 1 and j == 1:\n                    carryless_sum = product\n                else:\n                    carryless_sum = (carryless_sum + product) % 10\n        return carryless_sum\n\n    def find_smallest_a(N: int) -> int:\n        if N == 0 or N == 1:\n            return N\n        for a in range(2, int(N / 2) + 1):\n            if carryless_multiply(a, a) == N:\n                return a\n        return -1\n\n    N = int(stdin)\n    return str(find_smallest_a(N))"
    },
    {
        "number": 3020,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for i in range(1, n + 1):\n        if i ** 2 == n:\n            return str(i)\n    return \"-1\""
    },
    {
        "number": 3020,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    n = len(str(N))\n\n    if n % 2 == 1:\n        a = int(\"9\" * (n // 2 + 1))\n        while True:\n            if a * a == N:\n                return str(a)\n            elif a * a > N:\n                break\n            a += 1\n    else:\n        a = int(\"9\" * (n // 2))\n        while True:\n            if a * a == N:\n                return str(a)\n            a += 1\n\n    return \"-1\""
    },
    {
        "number": 3020,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return \"-1\"\n    for i in range(1, n + 1):\n        if i ** 2 == n:\n            return str(i)\n    return \"-1\"\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 10:\n        return str(n)\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            a = i\n            b = n // i\n            if a * b == n:\n                return str(a)\n            elif b < a:\n                break\n    return \"-1\""
    },
    {
        "number": 3020,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    def carryless_multiplication(a, b):\n        def carryless_addition(x, y):\n            return (x + y) % 10\n\n        a = str(a)\n        b = str(b)\n        result = 0\n        for i, digit_a in enumerate(reversed(a)):\n            temp = 0\n            for j, digit_b in enumerate(reversed(b)):\n                temp += int(digit_a) * int(digit_b) * (10 ** (i + j))\n            result = carryless_addition(result, temp)\n        return result\n\n    def is_square(n):\n        return int(n ** 0.5) ** 2 == n\n\n    for i in range(1, n + 1):\n        if is_square(carryless_multiplication(i, i)):\n            return str(i)\n    return \"-1\""
    },
    {
        "number": 3020,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    a = 1\n    while True:\n        if pow(a, 2, 10) == N:\n            return str(a)\n        elif pow(a, 2, 10) > N:\n            return \"-1\"\n        a += 1 "
    },
    {
        "number": 3020,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    i = 0\n    while True:\n        i += 1\n        square = int(str(i) * 2)\n        for j in range(1, i):\n            square += i * j * j\n        if square % 10 == n % 10:\n            if square == n:\n                return str(i)\n            for j in range(1, i):\n                if (square + i * j * j) % 10 != n % 10:\n                    break\n            else:\n                return str(i)\n    return \"-1\""
    },
    {
        "number": 3020,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def carryless_multiplication(a: str, b: str) -> str:\n        result = [0] * (len(a) + len(b))\n        for i in range(len(a) - 1, -1, -1):\n            for j in range(len(b) - 1, -1, -1):\n                result[i + j + 1] += int(a[i]) * int(b[j])\n                result[i + j] += result[i + j + 1] // 10\n                result[i + j + 1] %= 10\n        return \"\".join(map(str, result)).lstrip(\"0\") or \"0\"\n\n    def find_smallest_positive_integer(N: str) -> str:\n        for i in range(2, int(N) + 1):\n            if carryless_multiplication(str(i), str(i)) == N:\n                return str(i)\n        return \"-1\"\n\n    return find_smallest_positive_integer(stdin)"
    },
    {
        "number": 3021,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_letter(word1, word2):\n        for i in range(min(len(word1), len(word2))):\n            if word1[i] != word2[i]:\n                return word1[i], word2[i]\n        return None, None\n    \n    def check_alphabet(alphabet, words):\n        for i in range(len(words) - 1):\n            for j in range(i + 1, len(words)):\n                if words[i] > words[j]:\n                    return False\n        return True\n    \n    def generate_alphabets(alphabet):\n        alphabets = []\n        for i in range(len(alphabet)):\n            for j in range(i + 1, len(alphabet) + 1):\n                alphabets.append(\"\".join(sorted(alphabet[:i] + alphabet[i:j] + alphabet[j:])))\n        return alphabets\n\n    lines = stdin.split(\"\\n\")\n    L, N = lines[0].split()\n    L = ord(L) - ord('a')\n    N = int(N)\n    words = lines[1:]\n\n    alphabet = [chr(i) for i in range(ord('a'), ord('a') + L + 1)]\n    for i in range(len(words) - 1):\n        for j in range(i + 1, len(words)):\n            letter1, letter2 = find_letter(words[i], words[j])\n            if letter1 and letter2:\n                if letter1 in alphabet and letter2 in alphabet:\n                    index1 = alphabet.index(letter1)\n                    index2 = alphabet.index(letter2)\n                    if index1 > index2:\n                        alphabet.pop(index1)\n                        alphabet.insert(index2, letter1)\n                    elif index1 < index2:\n                        alphabet.pop(index2)\n                        alphabet.insert(index1, letter2)\n                elif letter1 in alphabet:\n                    alphabet.remove(letter1)\n                    alphabet.insert(0, letter2)\n                elif letter2 in alphabet:\n                    alphabet.remove(letter2)\n                    alphabet.insert(0, letter1)\n                else:\n                    alphabet.insert(0, letter1)\n                    alphabet.insert(0, letter2)\n\n    alphabets = generate_alphabets(alphabet)\n    for alpha in alphabets:\n        if check_alphabet(alpha, words):\n            return alpha\n    if any(len(set(word)) != len(word) for word in words):\n        return \"AMBIGUOUS\"\n    return \"IMPOSSIBLE\" "
    },
    {
        "number": 3021,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split())\n    words = []\n    for _ in range(N):\n        word = input()\n        if len(word) > 1000:\n            raise ValueError(\"Length of word is greater than 1000\")\n        words.append(word)\n\n    def find_first_diff_char(word1: str, word2: str) -> str:\n        for i in range(min(len(word1), len(word2))):\n            if word1[i] != word2[i]:\n                return word1[i]\n        return ''\n\n    def is_valid(word1: str, word2: str) -> bool:\n        if len(word1) < len(word2):\n            return False\n        for i in range(len(word2)):\n            if word1[i] != word2[i]:\n                return True\n        return len(word1) > len(word2)\n\n    def check_alphabet(words: List[str]) -> bool:\n        for i in range(len(words) - 1):\n            if not is_valid(words[i], words[i + 1]):\n                return False\n        return True\n\n    def build_alphabet(words: List[str]) -> str:\n        alphabet = []\n        for word in words:\n            for char in word:\n                if char not in alphabet:\n                    alphabet.append(char)\n        return ''.join(sorted(alphabet))\n\n    if not check_alphabet(words):\n        return \"IMPOSSIBLE\"\n\n    first_diff_chars = set()\n    for i in range(len(words) - 1):\n        first_diff_char = find_first_diff_char(words[i], words[i + 1])\n        if first_diff_char:\n            first_diff_chars.add(first_diff_char)\n\n    if len(first_diff_chars) < L - 1:\n        return \"AMBIGUOUS\"\n\n    return build_alphabet(words)"
    },
    {
        "number": 3021,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_alphabet(words, n):\n        alphabet = list(set(words))\n        alphabet.sort()\n        order = {}\n        for i in range(len(alphabet)):\n            order[alphabet[i]] = i\n\n        for i in range(n - 1):\n            for j in range(min(len(words[i]), len(words[i + 1]))):\n                if words[i][j] != words[i + 1][j]:\n                    if order[words[i][j]] > order[words[i + 1][j]]:\n                        return False\n                    break\n            else:\n                if len(words[i]) > len(words[i + 1]):\n                    return False\n\n        return order\n\n    input_data = stdin.split(\"\\n\")\n    L = input_data[0].split(\" \")[0]\n    N = int(input_data[0].split(\" \")[1])\n    words = input_data[1:]\n\n    if N == 1:\n        return L\n    else:\n        alphabet_order = find_alphabet(words, N)\n        if not alphabet_order:\n            return \"IMPOSSIBLE\"\n        elif len(set(alphabet_order.values())) != len(alphabet_order.values()):\n            return \"AMBIGUOUS\"\n        else:\n            return \"\".join(sorted(alphabet_order.keys(), key=lambda x: alphabet_order[x]))"
    },
    {
        "number": 3021,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    L, N = map(int, lines[0].split())\n    words = lines[1:]\n\n    # Create a dictionary to store the first differing letter for each pair of words\n    first_diff = {}\n    for i in range(N):\n        for j in range(i + 1, N):\n            w1, w2 = words[i], words[j]\n            for k in range(min(len(w1), len(w2))):\n                if w1[k] != w2[k]:\n                    first_diff[(i, j)] = (w1[k], w2[k])\n                    break\n            else:\n                if len(w1) != len(w2):\n                    first_diff[(i, j)] = (w1[-1], w2[-1])\n\n    # Create a directed graph to represent the constraints\n    graph = {c: [] for c in 'abcdefghijklmnopqrstuvwxyz' if c <= L}\n    for (i, j), (c1, c2) in first_diff.items():\n        if c1 != c2:\n            if c1 in graph and c2 in graph[c1]:\n                return 'IMPOSSIBLE'\n            if c2 in graph and c1 in graph[c2]:\n                return 'IMPOSSIBLE'\n            graph[c1].append(c2)\n\n    # Perform a topological sort to find the lexicographic order of the alphabet\n    order = []\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)\n        order.append(node)\n\n    for c in graph:\n        dfs(c)\n\n    if len(order) == len(graph):\n        return ''.join(order)\n    else:\n        return 'AMBIGUOUS'"
    },
    {
        "number": 3021,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_alphabet(words, alphabet):\n        for word in words:\n            if not all(letter in alphabet for letter in word):\n                return False\n        return True\n\n    def find_letter_order(words, alphabet):\n        letter_order = {}\n        for i in range(len(alphabet)):\n            for j in range(i + 1, len(alphabet)):\n                if any(word.startswith(alphabet[i] + letter) for word in words for letter in alphabet if letter != alphabet[j]):\n                    letter_order[alphabet[i]] = alphabet[j]\n                    break\n        return letter_order\n\n    def find_ambiguous_orders(words, alphabet):\n        orders = set()\n        for letter_order in find_letter_order(words, alphabet):\n            orders.add(frozenset(letter_order.items()))\n        return orders\n\n    def is_consistent(words, alphabet):\n        for i in range(len(words) - 1):\n            for j in range(i + 1, len(words)):\n                if not (words[i] < words[j]) and not (words[j] < words[i]):\n                    return False\n        return True\n\n    L, N = map(int, stdin.split())\n    words = [input() for _ in range(N)]\n    alphabet = [chr(i) for i in range(ord('a'), ord('b') + 1 + L)]\n\n    if is_valid_alphabet(words, alphabet):\n        if is_consistent(words, alphabet):\n            letter_order = find_letter_order(words, alphabet)\n            return ''.join(sorted(alphabet, key=lambda x: letter_order.get(x, x)))\n        else:\n            return 'IMPOSSIBLE'\n    else:\n        return 'AMBIGUOUS'"
    },
    {
        "number": 3021,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_consistent(order: str, words: List[str]) -> bool:\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            for j in range(min(len(w1), len(w2))):\n                if order.index(w1[j]) > order.index(w2[j]):\n                    break\n                elif order.index(w1[j]) < order.index(w2[j]):\n                    return False\n            else:\n                if len(w1) > len(w2):\n                    return False\n        return True\n\n    def find_order(words: List[str]) -> str:\n        alphabet = set(\"\".join(words))\n        for order in itertools.permutations(alphabet):\n            if is_consistent(\"\".join(order), words):\n                return \"\".join(order)\n        return \"IMPOSSIBLE\"\n\n    def is_ambiguous(words: List[str]) -> bool:\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            for j in range(min(len(w1), len(w2))):\n                if w1[j] != w2[j]:\n                    break\n            else:\n                if len(w1) < len(w2):\n                    return True\n        return False\n\n    L, N = map(int, stdin.split())\n    words = [input() for _ in range(N)]\n\n    if is_ambiguous(words):\n        return \"AMBIGUOUS\"\n    else:\n        return find_order(words)"
    },
    {
        "number": 3021,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_consistent(alphabet, words):\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            for j in range(min(len(w1), len(w2))):\n                if w1[j] != w2[j]:\n                    a, b = w1[j], w2[j]\n                    if alphabet.index(a) > alphabet.index(b):\n                        return False\n                    break\n            else:\n                if len(w1) > len(w2):\n                    return False\n        return True\n\n    def find_order(words):\n        alphabet = [chr(i) for i in range(ord('a'), ord('a') + L)]\n        for i in range(len(alphabet)):\n            for j in range(i + 1, len(alphabet)):\n                for w in words:\n                    if alphabet[i] in w and alphabet[j] in w:\n                        if w.index(alphabet[i]) > w.index(alphabet[j]):\n                            alphabet[i], alphabet[j] = alphabet[j], alphabet[i]\n                        break\n        return ''.join(alphabet)\n\n    L, N = map(int, stdin.split())\n    words = [input() for _ in range(N)]\n\n    if is_consistent(find_order(words), words):\n        return find_order(words)\n    elif any(is_consistent(find_order(words), words) for _ in range(1000)):\n        return \"AMBIGUOUS\"\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3021,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def compare_words(word1, word2):\n        for i in range(min(len(word1), len(word2))):\n            if word1[i] != word2[i]:\n                return word1[i], word2[i]\n        return None, None\n\n    def find_first_difference(words):\n        for i in range(len(words) - 1):\n            first, second = compare_words(words[i], words[i + 1])\n            if first is not None and second is not None:\n                return first, second\n        return None, None\n\n    def is_valid_alphabet(alphabet, words):\n        for word in words:\n            for char in word:\n                if char not in alphabet:\n                    return False\n        return True\n\n    def generate_alphabets(alphabet_size):\n        alphabets = []\n        for alphabet in itertools.permutations(string.ascii_lowercase[:alphabet_size + 1]):\n            alphabets.append(''.join(alphabet))\n        return alphabets\n\n    def find_ordered_alphabet(words):\n        first, second = find_first_difference(words)\n        if first is None and second is None:\n            return \"AMBIGUOUS\"\n        elif first is None or second is None:\n            return \"IMPOSSIBLE\"\n        else:\n            alphabet = \"\"\n            for char in string.ascii_lowercase:\n                if char < first:\n                    alphabet += char\n                elif char < second:\n                    alphabet += first\n                    first = second\n                    second = char\n                else:\n                    alphabet += second\n                    second = char\n            return alphabet\n\n    lines = stdin.split(\"\\n\")\n    alphabet_size, num_words = map(int, lines[0].split())\n    words = lines[1:num_words + 1]\n\n    if is_valid_alphabet(string.ascii_lowercase[:alphabet_size + 1], words):\n        return find_ordered_alphabet(words)\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3021,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_consistent(candidate_alphabet, word1, word2):\n        for c1, c2 in zip(word1, word2):\n            if candidate_alphabet[c1] != candidate_alphabet[c2]:\n                return candidate_alphabet[c1] < candidate_alphabet[c2]\n        return None\n\n    def find_alphabet(candidate_alphabet, words):\n        for i in range(len(words) - 1):\n            if not is_consistent(candidate_alphabet, words[i], words[i + 1]):\n                return False\n        return True\n\n    def find_lexicographic_order(words):\n        letters = sorted(set(\"\".join(words)))\n        if len(letters) > 26:\n            return \"AMBIGUOUS\"\n\n        candidate_alphabet = {c: i for i, c in enumerate(letters)}\n\n        if find_alphabet(candidate_alphabet, words):\n            return \"\".join(letters)\n        else:\n            return \"IMPOSSIBLE\"\n\n    lines = stdin.strip().split(\"\\n\")\n    L, N = map(int, lines[0].split())\n    words = lines[1:]\n\n    return find_lexicographic_order(words)"
    },
    {
        "number": 3021,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_order(words):\n        order = []\n        for word in words:\n            for char in word:\n                if char not in order:\n                    order.append(char)\n        return order\n\n    def compare(a, b):\n        for i in range(min(len(a), len(b))):\n            if a[i] != b[i]:\n                return order.index(a[i]), order.index(b[i]), i\n        return len(a), len(b), None\n\n    def is_ordered(words):\n        for i in range(len(words) - 1):\n            a, b, pos = compare(words[i], words[i + 1])\n            if (a > b) or (a == b and pos is not None and words[i][pos + 1:] > words[i + 1][pos + 1:]):\n                return False\n        return True\n\n    L, N = map(int, stdin.split())\n    words = [input() for _ in range(N)]\n\n    if any(len(set(word)) != len(word) for word in words):\n        return \"IMPOSSIBLE\"\n\n    order = find_order(words)\n\n    if is_ordered(words):\n        return \"\".join(order)\n    else:\n        return \"AMBIGUOUS\""
    },
    {
        "number": 3022,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    min_cookies_per_person = total_cookies // N\n\n    almond_biscuits_remaining = A\n    butter_cookies_remaining = B\n    chocolate_macarons_remaining = C\n\n    def distribute_cookies(person: int, min_cookies_per_person: int) -> int:\n        if person % 3 == 0:\n            if almond_biscuits_remaining >= min_cookies_per_person:\n                almond_biscuits_remaining -= min_cookies_per_person\n                return min_cookies_per_person\n            else:\n                return almond_biscuits_remaining\n        elif person % 3 == 1:\n            if butter_cookies_remaining >= min_cookies_per_person:\n                butter_cookies_remaining -= min_cookies_per_person\n                return min_cookies_per_person\n            else:\n                return butter_cookies_remaining\n        else:\n            if chocolate_macarons_remaining >= min_cookies_per_person:\n                chocolate_macarons_remaining -= min_cookies_per_person\n                return min_cookies_per_person\n            else:\n                return chocolate_macarons_remaining\n\n    total_distributed_cookies = 0\n    for person in range(N):\n        total_distributed_cookies += distribute_cookies(person, min_cookies_per_person)\n\n    return str(total_distributed_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    min_cookies_per_person = total_cookies // N\n\n    almond_biscuits_per_person = min_cookies_per_person\n    butter_cookies_per_person = min_cookies_per_person\n    chocolate_macarons_per_person = min_cookies_per_person\n\n    remaining_cookies = total_cookies % N\n    for i in range(remaining_cookies):\n        if i % 3 == 0:\n            almond_biscuits_per_person += 1\n        elif i % 3 == 1:\n            butter_cookies_per_person += 1\n        else:\n            chocolate_macarons_per_person += 1\n\n    total_distributed_cookies = min_cookies_per_person * N + remaining_cookies\n    return str(total_distributed_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n\n    # Calculate the maximum number of cookies that can be distributed\n    total_cookies = A + B + C\n    max_cookies = total_cookies // N\n\n    # Calculate the remaining cookies\n    remaining_cookies = total_cookies % N\n\n    # Distribute the remaining cookies\n    almond_biscuit_count = min(A, remaining_cookies)\n    butter_cookie_count = min(B, remaining_cookies - almond_biscuit_count)\n    chocolate_macaron_count = remaining_cookies - almond_biscuit_count - butter_cookie_count\n\n    # Calculate the total number of cookies distributed\n    total_distributed = max_cookies * N + almond_biscuit_count + butter_cookie_count + chocolate_macaron_count\n\n    return str(total_distributed)"
    },
    {
        "number": 3022,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    min_cookies_per_person = total_cookies // N\n\n    almond_biscuits_left = A\n    butter_cookies_left = B\n    chocolate_macarons_left = C\n\n    total_distributed_cookies = 0\n\n    for _ in range(N):\n        cookies_to_distribute = min_cookies_per_person\n        if almond_biscuits_left > 0:\n            cookies_to_distribute = min(cookies_to_distribute, almond_biscuits_left)\n        if butter_cookies_left > 0:\n            cookies_to_distribute = min(cookies_to_distribute, butter_cookies_left)\n        if chocolate_macarons_left > 0:\n            cookies_to_distribute = min(cookies_to_distribute, chocolate_macarons_left)\n\n        total_distributed_cookies += cookies_to_distribute\n\n        if almond_biscuits_left > 0:\n            almond_biscuits_left -= cookies_to_distribute\n        if butter_cookies_left > 0:\n            butter_cookies_left -= cookies_to_distribute\n        if chocolate_macarons_left > 0:\n            chocolate_macarons_left -= cookies_to_distribute\n\n    return str(total_distributed_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = list(map(int, stdin.split()))\n    total_cookies = A + B + C\n    min_cookies = min(A, B, C)\n    max_cookies = total_cookies // N\n    max_cookies = max(max_cookies, min_cookies)\n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    min_cookies = min(A, B, C)\n    remaining_friends = N - 1\n    total_cookies = 0\n\n    while remaining_friends > 0:\n        if A >= min_cookies and B >= min_cookies and C >= min_cookies:\n            total_cookies += min_cookies\n            A -= min_cookies\n            B -= min_cookies\n            C -= min_cookies\n            remaining_friends -= 1\n        else:\n            break\n\n    if A == 0 and B == 0 and C == 0:\n        total_cookies += remaining_friends * min_cookies\n    elif A == 0 and B == 0:\n        total_cookies += min(remaining_friends, C) * min_cookies\n    elif B == 0 and C == 0:\n        total_cookies += min(remaining_friends, A) * min_cookies\n    elif A == 0 and C == 0:\n        total_cookies += min(remaining_friends, B) * min_cookies\n    elif A == 0:\n        total_cookies += min(remaining_friends // 2, B) + min(remaining_friends - remaining_friends // 2, C)\n    elif B == 0:\n        total_cookies += min(remaining_friends // 2, A) + min(remaining_friends - remaining_friends // 2, C)\n    elif C == 0:\n        total_cookies += min(remaining_friends // 2, A) + min(remaining_friends - remaining_friends // 2, B)\n    else:\n        total_cookies += min(remaining_friends // 3, A) + min(remaining_friends // 3, B) + min(remaining_friends - 2 * remaining_friends // 3, C)\n\n    return str(total_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    num_types = 3\n    max_cookies = float(\"inf\")\n\n    for i in range(1, N + 1):\n        cookies_per_person = total_cookies // N * i\n        remaining_cookies = total_cookies % N\n        if cookies_per_person > max_cookies:\n            break\n        num_leftover = N - i\n        if num_leftover > 0:\n            cookies_per_person += remaining_cookies // num_leftover\n            remaining_cookies = remaining_cookies % num_leftover\n        if remaining_cookies > 0:\n            cookies_per_person += 1\n        max_cookies = min(max_cookies, cookies_per_person)\n\n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    min_cookies_per_person = total_cookies // N\n    remaining_cookies = total_cookies % N\n\n    almond_biscuits = A // min_cookies_per_person\n    butter_cookies = B // min_cookies_per_person\n    chocolate_macarons = C // min_cookies_per_person\n\n    max_cookies = min(almond_biscuits + butter_cookies + chocolate_macarons, total_cookies)\n\n    for i in range(1, remaining_cookies + 1):\n        almond_biscuits += 1\n        butter_cookies += 1\n        chocolate_macarons += 1\n        max_cookies = max(max_cookies, almond_biscuits + butter_cookies + chocolate_macarons)\n\n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = list(map(int, stdin.split()))\n    total_cookies = A + B + C\n    min_cookies = min(A, B, C)\n    max_cookies = total_cookies - min_cookies\n    \n    if N > 3:\n        max_cookies -= (N - 3) * min_cookies\n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = list(map(int, stdin.split()))\n    total_cookies = A + B + C\n    min_cookies_per_person = total_cookies // N\n\n    remaining_cookies = total_cookies % N\n    remaining_almond_cookies = remaining_cookies // 2\n    remaining_butter_cookies = remaining_cookies - remaining_almond_cookies\n    remaining_chocolate_cookies = remaining_cookies - remaining_almond_cookies - remaining_butter_cookies\n\n    min_cookies_per_person += remaining_almond_cookies + remaining_butter_cookies + remaining_chocolate_cookies\n\n    return str(min_cookies_per_person)"
    },
    {
        "number": 3023,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.readline().split())\n    candles = []\n    for _ in range(n):\n        candles.append(list(map(int, stdin.readline().split())))\n    lines = []\n    for _ in range(m):\n        lines.append(list(map(int, stdin.readline().split())))\n    \n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n    \n    def point_in_piece(x, y, piece_index):\n        for i in range(n):\n            if i == piece_index:\n                continue\n            if distance(x, y, candles[i][0], candles[i][1]) <= r:\n                return False\n        return True\n    \n    for line in lines:\n        a, b, c = line\n        for i in range(n):\n            x, y = candles[i]\n            if abs(a * x + b * y + c) <= 1e-4:\n                return \"no\"\n    \n    for i in range(n):\n        x, y = candles[i]\n        if not point_in_piece(x, y, i):\n            return \"no\"\n    \n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = list(map(int, stdin.readline().strip().split()))\n    candles = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    cuts = [tuple(map(int, stdin.readline().strip().split())) for _ in range(m)]\n\n    def is_inside(point, radius):\n        return point[0] ** 2 + point[1] ** 2 <= radius ** 2\n\n    def crosses(line, candle, radius):\n        x, y = candle\n        a, b, c = line\n        if a == 0:\n            return abs(c / b) <= radius and (x, y - c / b) == candle\n        if b == 0:\n            return abs(c / a) <= radius and (x - c / a, y) == candle\n        x0, y0 = c / a, c / b\n        return is_inside((x - x0, y - y0), radius)\n\n    for cut in cuts:\n        for candle in candles:\n            if crosses(cut, candle, r):\n                break\n        else:\n            continue\n        break\n    else:\n        return \"yes\"\n    return \"no\""
    },
    {
        "number": 3023,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def on_line(x, y, a, b, c):\n        return abs(a * x + b * y + c) < 1e-4\n\n    def has_valid_cut(candles, line):\n        for candle in candles:\n            if on_line(candle[0], candle[1], line[0], line[1], line[2]):\n                return True\n        return False\n\n    def cut_candles(candles, line):\n        new_candles = []\n        for i in range(len(candles)):\n            if on_line(candles[i][0], candles[i][1], line[0], line[1], line[2]):\n                continue\n            new_candles.append(candles[i])\n        return new_candles\n\n    n, m, r = map(int, stdin.readline().split())\n    candles = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        if distance(x, y, 0, 0) <= r:\n            candles.append((x, y))\n\n    lines = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        lines.append((a, b, c))\n\n    for line in lines:\n        if has_valid_cut(candles, line):\n            candles = cut_candles(candles, line)\n\n    if len(candles) == n:\n        return \"yes\"\n    return \"no\""
    },
    {
        "number": 3023,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_cake(x, y, r):\n        return x ** 2 + y ** 2 <= r ** 2\n\n    def check_line(a, b, c, n, r):\n        if a == 0 and b == 0:\n            return False\n        x, y = -c / a, 0\n        if b != 0:\n            y = (-c - a * x) / b\n        return is_inside_cake(x, y, r)\n\n    def check_cut(n, m, r, candles, cuts):\n        for candle in candles:\n            if not any(is_inside_cake(x, y, r) for x, y in cuts if (candle[0] - x) ** 2 + (candle[1] - y) ** 2 <= r ** 2):\n                return False\n        return True\n\n    data = stdin.split('\\n')\n    n, m, r = map(int, data[0].split())\n    candles = [tuple(map(int, line.split())) for line in data[1:n + 1]]\n    cuts = [tuple(map(int, line.split())) for line in data[n + 1:n + m + 1]]\n\n    for a, b, c in cuts:\n        if not check_line(a, b, c, n, r):\n            return \"no\"\n\n    return \"yes\" if check_cut(n, m, r, candles, cuts) else \"no\""
    },
    {
        "number": 3023,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def line_intersection(a1, b1, c1, a2, b2, c2):\n        d = a1 * b2 - a2 * b1\n        dx = c1 * b2 - c2 * b1\n        dy = a1 * c2 - a2 * c1\n        if d != 0:\n            x = dx / d\n            y = dy / d\n            if -1e-4 <= x <= 1 + 1e-4 and -1e-4 <= y <= 1 + 1e-4:\n                return x, y\n        return None\n\n    def on_line(x, y, a, b, c):\n        return abs(a * x + b * y + c) <= 1e-4\n\n    def inside_circle(x, y, r):\n        return x * x + y * y <= r * r\n\n    n, m, r = map(int, stdin.readline().split())\n    candles = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    lines = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if distance(*candles[i], *candles[j]) > 2 * r:\n                return \"no\"\n\n    for a, b, c in lines:\n        if a == 0 and b == 0:\n            return \"no\"\n        for i in range(n):\n            if not inside_circle(*candles[i], r):\n                return \"no\"\n            if not on_line(*candles[i], a, b, c - 1e-4):\n                intersection = line_intersection(a, b, c, candles[i][0], candles[i][1], 0)\n                if intersection is None:\n                    return \"no\"\n                if not inside_circle(*intersection, r):\n                    return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(x, y, r):\n        return x ** 2 + y ** 2 <= r ** 2\n\n    def intersect(line1, line2):\n        a1, b1, c1 = line1\n        a2, b2, c2 = line2\n        det = a1 * b2 - a2 * b1\n        if det == 0:\n            return None, None\n        x = (c1 * b2 - c2 * b1) / det\n        y = (a1 * c2 - a2 * c1) / det\n        return x, y\n\n    def has_intersection(line1, line2, r):\n        x, y = intersect(line1, line2)\n        if x is None or y is None:\n            return False\n        return is_inside(x, y, r)\n\n    def has_valid_intersection(line1, line2, r):\n        x, y = intersect(line1, line2)\n        if x is None or y is None:\n            return False\n        return is_inside(x, y, r) and not (abs(x) <= 10e-4 and abs(y) <= 10e-4)\n\n    def has_at_least_one_valid_intersection(line1, lines, r):\n        for line2 in lines:\n            if has_valid_intersection(line1, line2, r):\n                return True\n        return False\n\n    n, m, r = map(int, stdin.readline().split())\n    candles = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    lines = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    for i, line1 in enumerate(lines):\n        if not has_at_least_one_valid_intersection(line1, lines[:i] + lines[i + 1:], r):\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def point_in_segment(x1, y1, x2, y2, x3, y3):\n        return min(x1, x2) <= x3 <= max(x1, x2) and min(y1, y2) <= y3 <= max(y1, y2)\n\n    def line_intersection(a1, b1, c1, a2, b2, c2):\n        d = a1 * b2 - a2 * b1\n        dx = c1 * b2 - c2 * b1\n        dy = a1 * c2 - a2 * c1\n        if d != 0:\n            x = dx / d\n            y = dy / d\n            return x, y\n        else:\n            return None\n\n    def is_valid(n, m, r, candles, lines):\n        for i in range(m):\n            valid = False\n            for j in range(n):\n                x1, y1 = candles[j]\n                x2, y2 = candles[(j + 1) % n]\n                a, b, c = lines[i]\n                intersection = line_intersection(a, b, c, x2 - x1, y2 - y1, -x1 * (x2 - x1) - y1 * (y2 - y1))\n                if intersection:\n                    x, y = intersection\n                    if point_in_segment(x1, y1, x2, y2, x, y):\n                        valid = True\n                        break\n            if not valid:\n                return False\n        return True\n\n    data = list(map(str, stdin.split()))\n    n, m, r = map(int, data[0:3])\n    data = data[3:]\n    candles = []\n    for i in range(n):\n        x, y = map(int, data[i].split())\n        candles.append((x, y))\n    lines = []\n    for i in range(n, n + m):\n        a, b, c = map(int, data[i].split())\n        lines.append((a, b, c))\n\n    if is_valid(n, m, r, candles, lines):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3023,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_circle(x, y, r):\n        return x ** 2 + y ** 2 <= r ** 2\n\n    def check_line_inside_circle(a, b, c, r):\n        if abs(a) > r or abs(b) > r:\n            return False\n        return abs(a * r + b * r + c) <= r * (abs(a) + abs(b))\n\n    def line_cross_quadrant(a, b, c, quadrant):\n        if quadrant == 1:\n            return a > 0 and b > 0 and c > 0\n        elif quadrant == 2:\n            return a < 0 and b > 0 and c > 0\n        elif quadrant == 3:\n            return a < 0 and b < 0 and c > 0\n        elif quadrant == 4:\n            return a > 0 and b < 0 and c > 0\n\n    n, m, r = map(int, stdin.readline().strip().split())\n    candles = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        if is_inside_circle(x, y, r):\n            candles.append((x, y))\n\n    cuts = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().strip().split())\n        if check_line_inside_circle(a, b, c, r) and all(line_cross_quadrant(a, b, c, i + 1) for i in range(4)):\n            cuts.append((a, b, c))\n\n    for x, y in candles:\n        for a, b, c in cuts:\n            if a * x + b * y + c <= r:\n                break\n        else:\n            return \"no\"\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_cake(x, y, r):\n        return x ** 2 + y ** 2 <= r ** 2\n\n    def distance_to_line(x, y, a, b, c):\n        return abs(a * x + b * y + c) / (a ** 2 + b ** 2) ** 0.5\n\n    def has_valid_cuts(n, m, r, candles, lines):\n        for candle in candles:\n            valid_cuts = 0\n            for line in lines:\n                if distance_to_line(*candle, *line) <= 10 ** -4:\n                    valid_cuts += 1\n            if valid_cuts != 1:\n                return False\n        return True\n\n    def has_valid_pieces(n, m, r, candles, lines):\n        pieces = []\n        for line in lines:\n            piece = []\n            for candle in candles:\n                if distance_to_line(*candle, *line) <= 10 ** -4:\n                    piece.append(candle)\n            pieces.append(piece)\n\n        for piece in pieces:\n            if len(piece) != 1:\n                return False\n        return True\n\n    lines = []\n    candles = []\n\n    n, m, r = map(int, stdin.split('\\n', 1)[0].split())\n\n    for _ in range(n):\n        x, y = map(int, stdin.split('\\n', 1)[0].split())\n        candles.append((x, y))\n\n    for _ in range(m):\n        a, b, c = map(int, stdin.split('\\n', 1)[0].split())\n        lines.append((a, b, c))\n\n    if has_valid_cuts(n, m, r, candles, lines) and has_valid_pieces(n, m, r, candles, lines):\n        return 'yes'\n    return 'no'"
    },
    {
        "number": 3023,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_circle(x, y, r):\n        return x ** 2 + y ** 2 <= r ** 2\n\n    def check_line_cut(a, b, c, candles):\n        count = 0\n        for x, y in candles:\n            if a * x + b * y + c == 0:\n                count += 1\n        return count == len(candles)\n\n    def has_valid_cut(cuts, candles):\n        for a, b, c in cuts:\n            if check_line_cut(a, b, c, candles):\n                return True\n        return False\n\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    n, m, r = tuple(map(int, input_data[0].split()))\n\n    candles = []\n    for i in range(1, n + 1):\n        x, y = tuple(map(int, input_data[i].split()))\n        if is_inside_circle(x, y, r):\n            candles.append((x, y))\n\n    cuts = []\n    for i in range(n + 1, n + m + 1):\n        a, b, c = tuple(map(int, input_data[i].split()))\n        cuts.append((a, b, c))\n\n    if has_valid_cut(cuts, candles):\n        return 'yes'\n    else:\n        return 'no'"
    },
    {
        "number": 3024,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    max_palindrome = \"\"\n    for i in range(n // 2, -1, -1):\n        for j in range(n // 2, -1, -1):\n            substring = stdin[i:n - j]\n            if substring == substring[::-1] and len(substring) > len(max_palindrome):\n                max_palindrome = substring\n\n    return str(len(max_palindrome))\n"
    },
    {
        "number": 3024,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    for k in range(n, 0, -1):\n        for i in range(n - k + 1):\n            if is_palindrome(stdin[i:i + k]):\n                for j in range(i + k, n, k):\n                    if not is_palindrome(stdin[j:j + k]):\n                        break\n                else:\n                    return str(k)\n    return \"1\"\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n\n    # Initialize variables\n    is_palindrome = [[False for _ in range(n)] for _ in range(n)]\n    max_length = 0\n\n    # Check for single character strings\n    if n == 1:\n        return 1\n\n    # Check for double character strings\n    if n == 2:\n        if s[0] == s[1]:\n            return 2\n        else:\n            return 1\n\n    # Fill in the is_palindrome matrix\n    for i in range(n):\n        is_palindrome[i][i] = True\n        if i < n - 1 and s[i] == s[i + 1]:\n            is_palindrome[i][i + 1] = True\n            max_length = 2\n\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j] and is_palindrome[i + 1][j - 1]:\n                is_palindrome[i][j] = True\n                max_length = length\n\n    return max_length\n"
    },
    {
        "number": 3024,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    max_k = 1\n    \n    for k in range(2, n + 1):\n        parts = [stdin[i:i + k] for i in range(0, n - k + 1, k)]\n        if len(parts) == 1:\n            break\n        if all(p == parts[k - 1][::-1] for p in parts[:k - 1]) and parts[k - 1] == parts[k - 1][::-1]:\n            max_k = k\n    \n    return str(max_k)"
    },
    {
        "number": 3024,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    ans = 1\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                if j - i == 1 or dp[i + 1][j - 1] == 1:\n                    dp[i][j] = 1\n                    ans = max(ans, j - i + 1)\n    return str(ans)"
    },
    {
        "number": 3024,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = len(stdin)\n    k = 1\n    while k <= n // 2:\n        for i in range(n - 2 * k + 1):\n            if is_palindrome(stdin[i:i + k]):\n                return str(k)\n        k += 1\n    return \"1\""
    },
    {
        "number": 3024,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    if n == 1:\n        return 1\n    for k in range(n, 0, -1):\n        for i in range(n - k + 1):\n            substring = s[i:i + k]\n            if substring == substring[::-1]:\n                if i + k <= n // 2:\n                    return k\n                elif i - k >= n // 2:\n                    return k\n    return 1"
    },
    {
        "number": 3024,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    max_palindrome = \"\"\n    for i in range(n // 2, -1, -1):\n        for j in range(i, n - i):\n            substring = stdin[j:j + 2 * i + 1]\n            if substring == substring[::-1]:\n                if len(substring) > len(max_palindrome):\n                    max_palindrome = substring\n                break\n    return str(len(max_palindrome))"
    },
    {
        "number": 3024,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = len(stdin)\n    max_k = 1\n\n    for k in range(2, n // 2 + 1):\n        if n % k != 0:\n            continue\n\n        if is_palindrome(stdin[:n // k]):\n            max_k = k\n\n    return str(max_k)"
    },
    {
        "number": 3024,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if stdin[i - 1] == stdin[n - j]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    ans = n\n    for i in range(1, n // 2 + 1):\n        j = n - i + 1\n        if dp[i][j] == i:\n            ans = min(ans, n - 2 * i + 1)\n\n    return str(ans)\n"
    },
    {
        "number": 3025,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    gold = list(map(int, stdin.split()[1].split()))\n    adj_list = [[] for _ in range(n)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.split()[_ + 2].split())\n        adj_list[a - 1].append(b - 1)\n        adj_list[b - 1].append(a - 1)\n\n    visited = [False] * n\n    max_gold = 0\n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node)\n        if node != 0 and parent != 0:\n            nonlocal max_gold\n            max_gold = max(max_gold, gold[node - 1])\n\n    dfs(0, -1)\n    return str(max_gold)"
    },
    {
        "number": 3025,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    gold_list = list(map(int, stdin.readline().split()))\n    adj_list = [[] for _ in range(n)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        adj_list[a - 1].append(b - 1)\n        adj_list[b - 1].append(a - 1)\n\n    bandit_home = 0\n    king_castle = 1\n    visited = [False] * n\n    dfs = []\n\n    def dfs_util(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs_util(neighbor)\n        dfs.append(node)\n\n    dfs_util(king_castle)\n    total_gold = sum(gold_list)\n\n    for node in reversed(dfs):\n        if node != bandit_home:\n            total_gold -= gold_list[node - 1]\n\n        if node == bandit_home:\n            return str(total_gold)\n\n        visited[node] = False\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs_util(neighbor)\n        dfs.append(node)\n"
    },
    {
        "number": 3025,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, end):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(neighbor, end)\n\n    def max_gold(start, end):\n        visited = [False] * n\n        dfs(start, end)\n        return sum(gold[i] for i in range(1, n) if visited[i])\n\n    n, m = map(int, stdin.readline().split())\n    gold = [0] + list(map(int, stdin.readline().split()))\n    graph = [[] for _ in range(n)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    return str(max_gold(1, 2))"
    },
    {
        "number": 3025,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    gold = list(map(int, stdin.split()[2:n - 1]))\n    roads = [list(map(int, stdin.split()))[1:3] for _ in range(m)]\n    graph = [[] for _ in range(n)]\n\n    for road in roads:\n        a, b = road\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    bandit_home = 0\n    king_castle = 1\n\n    visited = [False] * n\n    visited[bandit_home] = True\n    max_gold = 0\n    gold_stolen = [0] * n\n\n    def dfs(node, prev):\n        nonlocal max_gold\n        if node == king_castle:\n            for i in range(n):\n                if i != bandit_home and i != king_castle and not visited[i]:\n                    max_gold += gold_stolen[i]\n            return\n\n        for neighbor in graph[node]:\n            if neighbor != prev and not visited[neighbor]:\n                visited[neighbor] = True\n                gold_stolen[node] += gold[neighbor]\n                dfs(neighbor, node)\n                visited[neighbor] = False\n                gold_stolen[node] -= gold[neighbor]\n\n    dfs(bandit_home, None)\n    return str(max_gold)"
    },
    {
        "number": 3025,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    gold = list(map(int, input_list[1].split()))\n    roads = [list(map(int, input_list[i+2].split())) for i in range(m)]\n\n    # Create graph\n    graph = {i:[] for i in range(1, n+1)}\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # DFS to find shortest path to king's castle\n    visited = {i:False for i in range(1, n+1)}\n    shortest_path = []\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        shortest_path.append(node)\n    dfs(1)\n\n    # Initialize variables\n    total_gold = sum(gold)\n    max_gold = 0\n    current_gold = 0\n\n    # Iterate through shortest path\n    for i in range(1, len(shortest_path)):\n        node = shortest_path[i]\n        if node > 2:\n            current_gold += gold[node-3]\n        if node == 2:\n            max_gold = max(max_gold, current_gold)\n        if node > 2 and node == shortest_path[i-1] - 1:\n            current_gold -= gold[node-3]\n\n    return str(max_gold)"
    },
    {
        "number": 3025,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, end):\n        stack = [(start, 0)]\n        visited = [False] * n\n        while stack:\n            node, gold = stack.pop()\n            if node == end:\n                return gold\n            if not visited[node]:\n                visited[node] = True\n                for neighbor in roads[node]:\n                    if not visited[neighbor]:\n                        stack.append((neighbor, gold + gold_in_villages[neighbor]))\n        return None\n\n    n, m = map(int, stdin.readline().strip().split())\n    gold_in_villages = list(map(int, stdin.readline().strip().split()))\n    roads = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().strip().split())\n        roads[a - 1].append(b - 1)\n        roads[b - 1].append(a - 1)\n\n    max_gold = dfs(0, 1)\n    return str(max_gold)"
    },
    {
        "number": 3025,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    gold = list(map(int, stdin.readline().split()))\n    roads = [set() for _ in range(n)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        roads[a - 1].add(b - 1)\n        roads[b - 1].add(a - 1)\n\n    visited = [False] * n\n    max_gold = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in roads[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    dfs(0)\n\n    for i in range(1, n - 1):\n        if not visited[i]:\n            max_gold = gold[i]\n            break\n\n    return str(max_gold)"
    },
    {
        "number": 3025,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    gold = list(map(int, stdin.readline().split()))\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    graph = [[] for _ in range(n)]\n    for a, b in roads:\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    visited[0] = True\n    max_gold = 0\n    stack = [(0, 0)]\n\n    while stack:\n        node, gold_stolen = stack.pop()\n        visited[node] = True\n        max_gold = max(max_gold, gold_stolen)\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if neighbor == 1:\n                    stack.append((neighbor, gold_stolen))\n                else:\n                    stack.append((neighbor, gold_stolen + gold[neighbor - 1]))\n\n    return str(max_gold)"
    },
    {
        "number": 3025,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    gold = list(map(int, stdin.readline().split()))\n    adj_list = [[] for _ in range(n)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        adj_list[a - 1].append(b - 1)\n        adj_list[b - 1].append(a - 1)\n\n    def dfs(v, visited, amount):\n        visited[v] = True\n        for u in adj_list[v]:\n            if not visited[u]:\n                dfs(u, visited, amount)\n        if v != 0 and v != 1:\n            amount += gold[v - 1]\n        return amount\n\n    max_gold = 0\n    for i in range(n):\n        visited = [False] * n\n        max_gold = max(max_gold, dfs(i, visited, 0))\n\n    return str(max_gold)"
    },
    {
        "number": 3025,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, end, visited, graph):\n        if start == end:\n            return True\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if dfs(neighbor, end, visited, graph):\n                    return True\n        return False\n\n    def is_reachable(start, end, graph):\n        return dfs(start, end, [False] * len(graph), graph)\n\n    def find_max_gold(gold, roads, n):\n        graph = [[] for _ in range(n)]\n        for a, b in roads:\n            graph[a - 1].append(b - 1)\n            graph[b - 1].append(a - 1)\n\n        max_gold = 0\n        for i in range(n):\n            for j in range(n):\n                if i != j and not is_reachable(i, j, graph):\n                    max_gold = max(max_gold, gold[i] + gold[j])\n\n        return max_gold\n\n    params = [line.split() for line in stdin.split('\\n') if line]\n    n, m = map(int, params[0])\n    gold = list(map(int, params[1]))\n    roads = [tuple(map(int, road)) for road in params[2:]]\n\n    max_gold = find_max_gold(gold, roads, n)\n    return str(max_gold) "
    },
    {
        "number": 3026,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = [int(x) for x in stdin.split('\\n')[1].split()]\n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[j] < sequence[i] and lis[j] + 1 > lis[i]:\n                lis[i] = lis[j] + 1\n    critical_elements = []\n    for i in range(n):\n        if sequence[i] > 1:\n            if lis[i - 1] >= lis[sequence[i] - 1]:\n                critical_elements.append(sequence[i])\n        elif lis[i] > 1:\n            critical_elements.append(sequence[i])\n    if not critical_elements:\n        return \"-1\"\n    return \" \".join(str(x) for x in sorted(critical_elements))"
    },
    {
        "number": 3026,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = sorted(list(map(int, stdin.split('\\n')[1].split())))\n    lis_length = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[j] < sequence[i] and lis_length[j] + 1 > lis_length[i]:\n                lis_length[i] = lis_length[j] + 1\n    critical_elements = [x for x in sequence if lis_length[sequence.index(x)] == n - 1]\n    if critical_elements:\n        return ' '.join(map(str, sorted(critical_elements)))\n    else:\n        return \"-1\""
    },
    {
        "number": 3026,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = list(map(int, stdin.split('\\n')[1].split()))\n\n    def find_lis(arr):\n        n = len(arr)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return dp\n\n    lis = find_lis(sequence)\n    critical_elements = [i for i in range(n) if lis[i] == 1]\n\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical_elements)))"
    },
    {
        "number": 3026,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    sequence = list(map(int, stdin.split(\"\\n\")[1].split()))\n    lis = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[j] < sequence[i] and lis[j] + 1 > lis[i]:\n                lis[i] = lis[j] + 1\n\n    max_lis = max(lis)\n    critical_elements = []\n\n    for i in range(n):\n        temp = lis[i]\n        lis[i] = 1\n        if max(lis) == temp - 1:\n            critical_elements.append(sequence[i])\n        lis[i] = temp\n\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical_elements)))"
    },
    {
        "number": 3026,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    \n    lis = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                lis[i] = max(lis[i], lis[j] + 1)\n    \n    critical = []\n    for i in range(n):\n        if arr[i] > lis[i]:\n            critical.append(arr[i])\n    \n    return ' '.join(map(str, critical)) if critical else '-1'"
    },
    {
        "number": 3026,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    sequence = list(map(int, stdin.split(\"\\n\")[1].split()))\n    lis = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if sequence[j] < sequence[i] and lis[j] + 1 > lis[i]:\n                lis[i] = lis[j] + 1\n\n    max_lis = max(lis)\n\n    critical_elements = [i + 1 for i in range(n) if lis[i] == max_lis]\n\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, critical_elements))"
    },
    {
        "number": 3026,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    lis = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i] and lis[j] + 1 > lis[i]:\n                lis[i] = lis[j] + 1\n\n    max_lis = max(lis)\n    critical_elements = []\n\n    for i in range(n):\n        temp_lis = lis.copy()\n        temp_lis[i] = 1\n        temp_max_lis = max(temp_lis)\n\n        if temp_max_lis < max_lis:\n            critical_elements.append(arr[i])\n\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical_elements)))"
    },
    {
        "number": 3026,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = [int(x) for x in stdin.split('\\n')[1].split()]\n    \n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if sequence[j] < sequence[i] and lis[j] + 1 > lis[i]:\n                lis[i] = lis[j] + 1\n                \n    critical_elements = []\n    for i in range(n):\n        if sequence[i] == lis[i]:\n            critical_elements.append(sequence[i])\n    \n    if critical_elements:\n        return ' '.join(map(str, sorted(critical_elements)))\n    else:\n        return \"-1\""
    },
    {
        "number": 3026,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    seq = list(map(int, stdin.split(\"\\n\")[1].split()))\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if seq[j] < seq[i] and lis[j] + 1 > lis[i]:\n                lis[i] = lis[j] + 1\n    critical_elements = []\n    for i in range(n):\n        if lis[i] == 1 and seq[i] != 1:\n            critical_elements.append(seq[i])\n        elif lis[i] == n and seq[i] != n:\n            critical_elements.append(seq[i])\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical_elements)))"
    },
    {
        "number": 3026,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = sorted(list(map(int, stdin.split('\\n')[1].split())))\n    lis_length = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[j] < sequence[i] and lis_length[j] + 1 > lis_length[i]:\n                lis_length[i] = lis_length[j] + 1\n\n    max_length = max(lis_length)\n    critical_elements = [x for x in sequence if lis_length[sequence.index(x)] == max_length - 1]\n\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical_elements)))"
    },
    {
        "number": 3027,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().strip().split())\n    first_stamp = []\n    second_stamp = []\n    for _ in range(n):\n        line = stdin.readline().strip()\n        first_stamp.append(line)\n        second_stamp.append(line)\n\n    for i in range(n):\n        for j in range(m):\n            if first_stamp[i][j] == '#':\n                second_stamp[i][j] = '.'\n            elif second_stamp[i][j] == '#':\n                first_stamp[i][j] = '.'\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if first_stamp[i][j] == '#' and second_stamp[i][j] == '#':\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3027,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    paper = [list(stdin.readline().strip()) for _ in range(n)]\n    # Find the stamp\n    stamp = []\n    stamp_x = stamp_y = None\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] == \"#\":\n                stamp.append((i, j))\n                if stamp_x is None:\n                    stamp_x = i\n                    stamp_y = j\n                else:\n                    stamp_x = min(stamp_x, i)\n                    stamp_y = min(stamp_y, j)\n    # Mark the stamp on the paper\n    for x, y in stamp:\n        paper[x][y] = \"@\"\n    # Count the number of nubs\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] == \"#\":\n                count += 1\n    return str(count)"
    },
    {
        "number": 3027,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    paper = [list(stdin.readline().strip()) for _ in range(n)]\n    total_nubs = sum(row.count('#') for row in paper)\n\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] == '#':\n                nubs_in_stamp = 0\n                for di in range(-2, 3):\n                    for dj in range(-2, 3):\n                        if 0 <= i + di < n and 0 <= j + dj < m:\n                            nubs_in_stamp += paper[i + di][j + dj] == '#'\n                if nubs_in_stamp == 8:\n                    total_nubs -= 4\n\n    return str(total_nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    stamp1 = [list(stdin.readline().strip()) for _ in range(n)]\n    stamp2 = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def count_nubs(stamp1: List[List[str]], stamp2: List[List[str]]) -> int:\n        nubs = 0\n        for i in range(n):\n            for j in range(m):\n                if stamp1[i][j] == '#' and stamp2[i][j] == '#':\n                    nubs += 1\n        return nubs\n\n    return str(count_nubs(stamp1, stamp2))"
    },
    {
        "number": 3027,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().strip().split())\n    paper = [list(stdin.readline().strip()) for _ in range(n)]\n\n    # Find all cells with at least one '#' in the first stamp\n    first_stamp = []\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] == '#':\n                first_stamp.append((i, j))\n\n    # For each cell in the second stamp, count the number of possible cells in the first stamp that could have made it\n    min_nubs = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] == '#':\n                count = sum(1 for x, y in first_stamp if i - n <= x <= i and j - m <= y <= j)\n                min_nubs = min(min_nubs, count)\n\n    return str(min_nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().strip().split())\n    paper = [list(stdin.readline().strip()) for _ in range(n)]\n    \n    def is_stamp(x, y, stamp_size):\n        for i in range(stamp_size):\n            for j in range(stamp_size):\n                if x + i >= n or y + j >= m:\n                    return False\n                if paper[x + i][y + j] == '#' and stamp[i][j] == '.':\n                    return False\n        return True\n    \n    def find_stamp_size(x, y):\n        stamp_size = 1\n        while is_stamp(x, y, stamp_size):\n            stamp_size += 1\n        return stamp_size - 1\n    \n    nubs = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] == '#':\n                stamp_size = find_stamp_size(i, j)\n                nubs += stamp_size * stamp_size\n    \n    return str(nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    mark = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def count_nubs(stamp):\n        return sum(row.count('#') for row in stamp)\n\n    min_nubs = float('inf')\n\n    for i in range(n):\n        for j in range(m):\n            if mark[i][j] == '#':\n                for di in range(n):\n                    for dj in range(m):\n                        if i + di < n and j + dj < m and mark[i + di][j + dj] != '.':\n                            stamp = [\n                                [mark[k][l] for l in range(j, j + m)]\n                                for k in range(i, i + n)\n                            ]\n                            min_nubs = min(min_nubs, count_nubs(stamp))\n\n    return str(min_nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    mark = [list(lines[i]) for i in range(1, n + 1)]\n    total_nubs = 0\n\n    for i in range(n):\n        for j in range(m):\n            if mark[i][j] == '#':\n                total_nubs += 1\n\n    min_nubs = total_nubs\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if mark[i][j] == '#' and mark[i + 1][j] == '#' and mark[i][j + 1] == '#' and mark[i + 1][j + 1] == '#':\n                min_nubs = min(min_nubs, total_nubs - 4)\n\n    for i in range(n - 2):\n        for j in range(m - 2):\n            if all(mark[i + k][j + l] == '#' for k in range(3) for l in range(3)):\n                min_nubs = min(min_nubs, total_nubs - 9)\n\n    return str(min_nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().strip().split())\n    paper = [list(stdin.readline().strip()) for _ in range(n)]\n    \n    def count_nubs(stamp):\n        nubs = 0\n        for row in stamp:\n            nubs += row.count('#')\n        return nubs\n    \n    max_nubs = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] == '#':\n                stamp_height = 2\n                stamp_width = 2\n                stamp = [paper[x][y] for x in range(i, i + stamp_height) for y in range(j, j + stamp_width)]\n                nubs = count_nubs(stamp)\n                max_nubs = max(max_nubs, nubs)\n                \n                stamp_height = 1\n                stamp_width = 4\n                stamp = [paper[x][y] for x in range(i, i + stamp_height) for y in range(j, j + stamp_width)]\n                nubs = count_nubs(stamp)\n                max_nubs = max(max_nubs, nubs)\n                \n                stamp_height = 4\n                stamp_width = 1\n                stamp = [paper[x][y] for x in range(i, i + stamp_height) for y in range(j, j + stamp_width)]\n                nubs = count_nubs(stamp)\n                max_nubs = max(max_nubs, nubs)\n                \n                stamp_height = 3\n                stamp_width = 3\n                stamp = [paper[x][y] for x in range(i, i + stamp_height) for y in range(j, j + stamp_width)]\n                nubs = count_nubs(stamp)\n                max_nubs = max(max_nubs, nubs)\n                \n    return str(max_nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    paper = [list(stdin.readline().strip()) for _ in range(n)]\n    \n    def count_nubs(stamp):\n        nubs = 0\n        for row in stamp:\n            nubs += row.count('#')\n        return nubs\n    \n    possible_stamps = []\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] == '#':\n                stamp_top = i\n                stamp_left = j\n                break\n        else:\n            continue\n        break\n    \n    for length in range(1, n // 2 + 1):\n        width = m // 2 - stamp_left\n        if width < length:\n            break\n        stamp = [['.' for _ in range(width)] for _ in range(length)]\n        for i in range(length):\n            for j in range(width):\n                stamp[i][j] = paper[stamp_top + i][stamp_left + j]\n        stamp_bottom = stamp_top + length - 1\n        stamp_right = stamp_left + width - 1\n        if all(all(stamp[i][j] == paper[i][j] for j in range(m)) for i in range(n)) and all(all(stamp[i][j] == paper[i][j] for i in range(n)) for j in range(m)):\n            possible_stamps.append(stamp)\n    \n    min_nubs = float('inf')\n    for stamp in possible_stamps:\n        min_nubs = min(min_nubs, count_nubs(stamp))\n    \n    return str(min_nubs)"
    },
    {
        "number": 3028,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split('\\n')[0].split())\n    board = [[int(x) for x in line.split()] for line in stdin.split('\\n')[1:]]\n\n    def is_winner(board):\n        for row in board:\n            if all(x == p for x in row):\n                return True\n        for col in range(m):\n            if all(board[row][col] == p for row in range(n)):\n                return True\n        return False\n\n    def helper(board, moves=0, seen=set()):\n        if tuple(tuple(row) for row in board) in seen:\n            return None\n        seen.add(tuple(tuple(row) for row in board))\n\n        if is_winner(board):\n            return moves\n\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    board[i][j] += 1\n                else:\n                    board[i][j] = 1\n                result = helper(board, moves + 1, seen)\n                if result is not None:\n                    return result\n                if board[i][j] > 1:\n                    board[i][j] -= 1\n                else:\n                    board[i][j] = p\n\n        return None\n\n    result = helper(board)\n    if result is not None:\n        return str(result) + '\\n' + ' '.join(map(str, [i * m + j + 1 for i in range(n) for j in range(m) if board[i][j] == p]))\n    else:\n        return '-1\\n'"
    },
    {
        "number": 3028,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[0:3])\n    board = [[int(x) for x in line.split()] for line in stdin.splitlines()[1:]]\n\n    def find_winner():\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    return False\n        return True\n\n    def move(x, y):\n        for i in range(n):\n            if i != x:\n                board[i][y] = (board[i][y] + 1) % (p + 1)\n        for j in range(m):\n            if j != y:\n                board[x][j] = (board[x][j] + 1) % (p + 1)\n\n    def bfs():\n        visited = set()\n        queue = deque([(tuple(tuple(row) for row in board), ())])\n\n        while queue:\n            curr_board, curr_moves = queue.popleft()\n            if find_winner():\n                return curr_moves\n\n            for i in range(n):\n                for j in range(m):\n                    if curr_board[i][j] != p:\n                        new_board = [list(row) for row in curr_board]\n                        new_board[i][j] = (new_board[i][j] + 1) % (p + 1)\n                        move(i, j)\n                        new_moves = curr_moves + ((i * m) + j + 1,)\n                        queue.append((tuple(tuple(row) for row in new_board), new_moves))\n                        move(i, j)\n\n        return None\n\n    result = bfs()\n    if result is None:\n        return \"-1\\n\"\n    else:\n        return f\"{len(result)}\\n{' '.join(map(str, result))}\\n\""
    },
    {
        "number": 3028,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_valid_moves(board, n, m, p, moves):\n        valid_moves = []\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == p:\n                    continue\n                new_board = [[board[x][y] for y in range(m)] for x in range(n)]\n                new_board[i][j] += 1\n                if new_board[i][j] > p:\n                    new_board[i][j] = 1\n                if not any(1 in row for row in new_board):\n                    return moves + [(i * m) + j + 1]\n                valid_moves.extend(find_valid_moves(new_board, n, m, p, moves + [(i * m) + j + 1]))\n        return valid_moves\n\n    input_data = list(map(int, stdin.split()))\n    n, m, p = input_data[0], input_data[1], input_data[2]\n    board = [input_data[i + 3] for i in range(n * m) if i % m + 1 != 0]\n    board = [board[i:i + m] for i in range(0, n * m, m)]\n\n    if any(1 in row for row in board):\n        return -1\n\n    valid_moves = find_valid_moves(board, n, m, p, [])\n\n    if not valid_moves:\n        return -1\n\n    min_moves = min(len(moves) for moves in valid_moves)\n    shortest_moves = [moves for moves in valid_moves if len(moves) == min_moves]\n\n    output = [str(len(shortest_moves[0]))] + [str(move) for moves in shortest_moves for move in moves]\n\n    return \" \".join(output)"
    },
    {
        "number": 3028,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def primonimo(board: List[List[int]], n: int, m: int, p: int) -> int:\n        def is_winner(board: List[List[int]]) -> bool:\n            for row in board:\n                if not all(x == p for x in row):\n                    return False\n            return True\n\n        def get_moves(board: List[List[int]], row: int, col: int) -> List[int]:\n            moves = []\n            for i in range(m):\n                if i != col:\n                    moves.append((row, i))\n            for i in range(n):\n                if i != row:\n                    moves.append((i, col))\n            return moves\n\n        visited = set()\n        queue = deque([(tuple(tuple(row) for row in board), [])])\n\n        while queue:\n            curr_board, curr_moves = queue.popleft()\n            if is_winner(curr_board):\n                return curr_moves\n            for row, col in get_moves(curr_board, curr_moves[-2][0], curr_moves[-1][1]):\n                new_board = deepcopy(curr_board)\n                new_board[row][col] = 1 if new_board[row][col] == p else new_board[row][col] + 1\n                new_moves = curr_moves + [(row, col)]\n                if (tuple(tuple(row) for row in new_board), new_moves) not in visited:\n                    visited.add((tuple(tuple(row) for row in new_board), new_moves))\n                    queue.append((new_board, new_moves))\n\n        return None\n\n    stdin_list = stdin.strip().split('\\n')\n    n, m, p = map(int, stdin_list[0].split())\n    board = [list(map(int, line.split())) for line in stdin_list[1:]]\n\n    if not (1 <= n <= 20 and 1 <= m <= 20 and is_prime(p) and p <= 97):\n        return '-1'\n\n    moves = primonimo(board, n, m, p)\n\n    if moves is None:\n        return '-1'\n    else:\n        return str(len(moves)) + '\\n' + ' '.join(str(board[row][col]) for row, col in moves)\n"
    },
    {
        "number": 3028,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def check_win(board: List[List[int]]) -> bool:\n        for row in board:\n            if 1 in row:\n                return False\n        return True\n\n    def is_valid(board: List[List[int]], row: int, col: int) -> bool:\n        if 0 <= row < len(board) and 0 <= col < len(board[0]):\n            return True\n        return False\n\n    def get_neighbors(board: List[List[int]], row: int, col: int) -> List[Tuple[int, int]]:\n        neighbors = []\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if (i, j) != (0, 0) and is_valid(board, row + i, col + j):\n                    neighbors.append((row + i, col + j))\n        return neighbors\n\n    def update_board(board: List[List[int]], row: int, col: int) -> None:\n        board[row][col] = 1 if board[row][col] == p else board[row][col] + 1\n\n    def bfs(board: List[List[int]]) -> List[int]:\n        queue = deque()\n        visited = set()\n\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 1:\n                    queue.append((i, j, 0))\n                    visited.add((i, j))\n\n        while queue:\n            row, col, depth = queue.popleft()\n\n            if check_win(board):\n                return depth\n\n            for neighbor_row, neighbor_col in get_neighbors(board, row, col):\n                if (neighbor_row, neighbor_col) not in visited:\n                    update_board(board, neighbor_row, neighbor_col)\n                    visited.add((neighbor_row, neighbor_col))\n                    queue.append((neighbor_row, neighbor_col, depth + 1))\n\n        return -1\n\n    def find_sequence(board: List[List[int]], p: int) -> List[int]:\n        sequence = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 1:\n                    sequence.append(i * len(board[0]) + j + 1)\n                    update_board(board, i, j)\n                    if check_win(board):\n                        break\n            if check_win(board):\n                break\n        return sequence\n\n    def main(stdin: str) -> str:\n        n, m, p = map(int, stdin.split()[:3])\n        board = [list(map(int, stdin.split()[3 + i * m:3 + i * m + m])) for i in range(n)]\n        result = bfs(board)\n        if result == -1:\n            return \"-1\"\n        sequence = find_sequence(board, p)\n        return f\"{len(sequence)}\\n{' '.join(map(str, sequence))}\"\n\n    return main(stdin) "
    },
    {
        "number": 3028,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_move(board, n, m, p, target, start):\n        def is_valid(x, y):\n            return 0 <= x < n and 0 <= y < m\n\n        def is_target(x, y):\n            return board[x][y] == target\n\n        def is_start(x, y):\n            return board[x][y] == start\n\n        def add_one(x, y):\n            board[x][y] = (board[x][y] + 1) % (p + 1)\n\n        moves = 0\n        for i in range(n):\n            for j in range(m):\n                if is_start(i, j):\n                    if is_valid(i - 1, j) and not is_target(i - 1, j):\n                        add_one(i - 1, j)\n                        moves += 1\n                    if is_valid(i + 1, j) and not is_target(i + 1, j):\n                        add_one(i + 1, j)\n                        moves += 1\n                    if is_valid(i, j - 1) and not is_target(i, j - 1):\n                        add_one(i, j - 1)\n                        moves += 1\n                    if is_valid(i, j + 1) and not is_target(i, j + 1):\n                        add_one(i, j + 1)\n                        moves += 1\n\n        return moves\n\n    def is_win(board, n, m, p):\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    return False\n        return True\n\n    def solve(board, n, m, p):\n        moves = 0\n        for start in range(1, p + 1):\n            while True:\n                move = find_move(board, n, m, p, start, p)\n                if move == 0:\n                    break\n                moves += move\n                if is_win(board, n, m, p):\n                    return moves\n        return -1\n\n    input_data = list(map(int, stdin.split()))\n    n, m, p = input_data[0], input_data[1], input_data[2]\n    board = [input_data[(i * m + 3):(i * m + 3 + m)] for i in range(n)]\n    result = solve(board, n, m, p)\n    return str(result)"
    },
    {
        "number": 3028,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split('\\n')[0].split())\n    board = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_winner(board):\n        for row in board:\n            if not all(square == p for square in row):\n                return False\n        for col in range(m):\n            if not all(board[row][col] == p for row in range(n)):\n                return False\n        return True\n\n    def add_move(move, moves):\n        row, col = move\n        for i in range(n):\n            if board[i][col] < p:\n                board[i][col] += 1\n            else:\n                board[i][col] = 1\n        for j in range(m):\n            if board[row][j] < p:\n                board[row][j] += 1\n            else:\n                board[row][j] = 1\n        moves.append((row, col))\n\n    def solve(board, k):\n        if k > p * m * n:\n            return -1\n        if is_winner(board):\n            return k\n        moves_list = []\n        for i in range(n):\n            for j in range(m):\n                add_move((i, j), moves_list)\n                result = solve(board, k + 1)\n                if result != -1:\n                    return result\n                moves_list.pop()\n        return -1\n\n    result = solve(board, 0)\n    if result == -1:\n        return \"-1\"\n    else:\n        output = str(result) + \"\\n\"\n        for move in moves_list:\n            output += str(move[0] * m + move[1] + 1) + \" \"\n        return output[:-1] + \"\\n\" "
    },
    {
        "number": 3028,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_winning_moves(board, p):\n        def move(board, row, col, p):\n            new_board = [[val for val in row] for row in board]\n            if new_board[row][col] == p:\n                new_board[row][col] = 1\n            else:\n                new_board[row][col] += 1\n            return new_board\n\n        def is_winner(board, p):\n            for row in board:\n                if p not in row:\n                    return False\n            return True\n\n        moves = []\n        for row in range(len(board)):\n            for col in range(len(board[0])):\n                if board[row][col] == p:\n                    continue\n                new_board = move(board, row, col, p)\n                if is_winner(new_board, p):\n                    moves.append((row, col))\n        return moves\n\n    def print_moves(moves):\n        result = []\n        for move in moves:\n            result.append(move[0] * m + move[1] + 1)\n        return \" \".join(map(str, result))\n\n    input_data = list(map(int, stdin.split()))\n    n, m, p = input_data[0], input_data[1], input_data[2]\n    board = [list(map(int, input_data[i + 1])) for i in range(3, 3 + n)]\n\n    if not is_prime(p) or n > 20 or m > 20 or p < 2:\n        return \"-1\"\n\n    winning_moves = find_winning_moves(board, p)\n    if not winning_moves:\n        return \"-1\"\n\n    output = [len(winning_moves)] + list(map(lambda x: x[0] * m + x[1] + 1, winning_moves))\n    return \" \".join(map(str, output))"
    },
    {
        "number": 3028,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.readline().split())\n    board = [[int(x) for x in stdin.readline().split()] for _ in range(n)]\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < m\n\n    def get_neighbors(x: int, y: int) -> list:\n        return [(x + dx, y + dy) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)] if is_valid(x + dx, y + dy)]\n\n    def get_wrapped_value(value: int) -> int:\n        return value if value != p else 1\n\n    def is_winning_board(board: list) -> bool:\n        for row in board:\n            if 1 in row:\n                return False\n        return True\n\n    def find_winning_moves(board: list) -> tuple:\n        winning_moves = []\n        visited = set()\n\n        def dfs(x: int, y: int, moves: int) -> bool:\n            if moves > p * n * m:\n                return False\n\n            if (x, y) in visited:\n                return False\n\n            if board[x][y] == p:\n                board[x][y] = 1\n\n            for nx, ny in get_neighbors(x, y):\n                if dfs(nx, ny, moves + 1):\n                    return True\n\n            if is_winning_board(board):\n                winning_moves.append((x, y))\n                return True\n\n            board[x][y] = get_wrapped_value(board[x][y] + 1)\n            visited.add((x, y))\n\n            return False\n\n        for x in range(n):\n            for y in range(m):\n                if dfs(x, y, 0):\n                    return len(winning_moves), winning_moves\n\n        return -1, winning_moves\n\n    result, winning_moves = find_winning_moves(board)\n\n    if result == -1:\n        return \"-1\"\n\n    row_major_order = [(x * m + y + 1) for x, y in winning_moves]\n    return f\"{result}\\n{' '.join(map(str, row_major_order))}\""
    },
    {
        "number": 3028,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_win(board):\n        return all(cell == p for row in board for cell in row)\n\n    def update_board(board, row, col):\n        for i in range(m):\n            board[row][i] = 1 if board[row][i] == p else board[row][i] + 1\n        for i in range(n):\n            board[i][col] = 1 if board[i][col] == p else board[i][col] + 1\n\n    def find_win(board, k=0, moves=[]):\n        if is_win(board):\n            return k, moves\n        for i in range(n):\n            for j in range(m):\n                new_board = [row.copy() for row in board]\n                update_board(new_board, i, j)\n                if (i * m + j) not in moves:\n                    result = find_win(new_board, k + 1, moves + [i * m + j])\n                    if result:\n                        return result\n        return None\n\n    result = find_win(board)\n\n    if result:\n        k, moves = result\n        return f\"{k}\\n\" + \" \".join(map(str, moves))\n    else:\n        return \"-1\\n\""
    },
    {
        "number": 3029,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, parent):\n        depth[v] = depth[parent] + 1\n        for child in tree[v]:\n            if child != parent:\n                dfs(child, v)\n\n    def non_decreasing_paths(v, parent):\n        if len(tree[v]) == 0:\n            return [1]\n\n        path_lengths = []\n        for child in tree[v]:\n            if child != parent:\n                child_paths = non_decreasing_paths(child, v)\n                for path_length in child_paths:\n                    path_lengths.append(path_length + 1)\n\n        return path_lengths\n\n    def longest_non_decreasing_path(v, parent):\n        non_dec_paths = non_decreasing_paths(v, parent)\n        return max(non_dec_paths)\n\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    labels = list(map(int, lines[1:N + 1]))\n    tree = [[] for _ in range(N)]\n    for i in range(N - 1):\n        parent, child = map(int, lines[N + 1 + i].split())\n        tree[parent - 1].append(child - 1)\n        tree[child - 1].append(parent - 1)\n\n    depth = [0] * N\n    dfs(0, -1)\n\n    max_length = 0\n    total_paths = 0\n    for i in range(N):\n        length = longest_non_decreasing_path(i, -1)\n        if length > max_length:\n            max_length = length\n            total_paths = 1\n        elif length == max_length:\n            total_paths += 1\n\n    prime = 11092019\n    return f\"{max_length} {total_paths % prime}\" "
    },
    {
        "number": 3029,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    u = [int(x) for x in lines[1:N+1]]\n    parents = [int(x) for x in lines[N+1:]]\n    \n    def build_tree(parents):\n        tree = [[] for _ in range(N)]\n        for i, p in enumerate(parents):\n            if i != p:\n                tree[p].append(i)\n        return tree\n    \n    def longest_jumping_path(u, tree):\n        def dfs(v, parent):\n            ret = 0\n            for w in tree[v]:\n                if w != parent and u[w] >= u[v]:\n                    ret = max(ret, dfs(w, v) + 1)\n            return ret\n        \n        return dfs(0, -1)\n    \n    def count_jumping_paths(u, tree, L):\n        def dfs(v, parent):\n            ret = 0\n            for w in tree[v]:\n                if w != parent and u[w] >= u[v]:\n                    ret += dfs(w, v)\n            return ret + (1 if len(tree[v]) == 0 and u[v] == L else 0)\n        \n        return dfs(0, -1)\n\n    tree = build_tree(parents)\n    L = longest_jumping_path(u, tree)\n    M = count_jumping_paths(u, tree, L)\n    \n    return f\"{L} {M % 11092019}\""
    },
    {
        "number": 3029,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def construct_tree(n, parents):\n        tree = [[] for _ in range(n)]\n        for i in range(1, n):\n            tree[parents[i - 1]].append(i)\n        return tree\n\n    def nondecreasing_paths(tree, labels):\n        n = len(labels)\n        dp = [[0, 0] for _ in range(n)]\n\n        for i in range(n - 1, -1, -1):\n            for j, child in enumerate(tree[i]):\n                dp[i][0] = max(dp[i][0], dp[child][0])\n                dp[i][1] = max(dp[i][1], dp[child][1])\n\n            if i == 0:\n                dp[i][0] = 1\n                dp[i][1] = 1\n            else:\n                if labels[i] >= labels[tree[i][-1]]:\n                    dp[i][0] = dp[tree[i][-1]][0] + 1\n                    dp[i][1] = dp[tree[i][-1]][1] + 1\n                else:\n                    dp[i][1] = max(dp[i][1], dp[tree[i][-1]][0])\n\n        return dp\n\n    def count_nondecreasing_paths(tree, dp):\n        n = len(tree)\n        count = [0] * n\n        total = 0\n\n        for i in range(n - 1, -1, -1):\n            count[i] = dp[i][1]\n            if i == 0:\n                total = dp[i][1]\n            else:\n                total = (total + count[i]) % 11092019\n                for child in tree[i]:\n                    count[i] = max(count[i], count[child])\n\n        return total\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    labels = [int(line) for line in lines[1:n + 1]]\n    parents = [int(line) for line in lines[n + 1:]]\n\n    tree = construct_tree(n, parents)\n    dp = nondecreasing_paths(tree, labels)\n    length = dp[0][0]\n    total = count_nondecreasing_paths(tree, dp)\n\n    return f\"{length} {total}\""
    },
    {
        "number": 3029,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, parent):\n        depth[v] = depth[parent] + 1\n        for child in tree[v]:\n            if child != parent:\n                dfs(child, v)\n\n    def lcp(s1, s2):\n        n1, n2 = len(s1), len(s2)\n        i, ans = 0, 0\n        while i < n1 and i < n2 and s1[i] == s2[i]:\n            ans += 1\n            i += 1\n        return ans\n\n    def non_decreasing_jumping_paths(node, parent, prev_label):\n        if node != root:\n            label = labels[node]\n            if label < prev_label:\n                return 0\n        paths = 1 if node == root else 0\n        for child in tree[node]:\n            if child != parent:\n                paths += non_decreasing_jumping_paths(child, node, label)\n        return paths\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    labels = [int(lines[i]) for i in range(1, N + 1)]\n    tree = [[] for _ in range(N)]\n    for i in range(2, N):\n        parent = int(lines[i])\n        tree[parent].append(i)\n\n    depth = [0] * N\n    dfs(0, -1)\n\n    longest_jumping_path = max(depth[i] for i in range(N) if labels[i] == 0)\n    non_decreasing_paths = non_decreasing_jumping_paths(0, -1, -1)\n    non_decreasing_paths %= 11092019\n\n    return f\"{longest_jumping_path} {non_decreasing_paths}\""
    },
    {
        "number": 3029,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def read_input(stdin: str):\n        lines = stdin.splitlines()\n        N = int(lines[0])\n        labels = [int(line) for line in lines[1:N+1]]\n        tree = [int(line) for line in lines[N+1:]]\n        return N, labels, tree\n\n    def lcp_array(s: str):\n        n = len(s)\n        temp = [0] * n\n        res = [0] * n\n        for i in range(n):\n            temp[i] = res[i] = i\n        for i in range(n):\n            if temp[i] == n:\n                continue\n            j = s[temp[i]]\n            while i + j < n and s[i+j] == s[j]:\n                j += 1\n            temp[i+j] = j\n            if j == i:\n                continue\n            k = temp[i]\n            while k < i+j:\n                res[k] = i+j-k\n                k += 1\n        return res\n\n    def longest_nondecreasing_jumping_path(labels: List[int], tree: List[int]) -> int:\n        L = 0\n        parent = [0] * len(tree)\n        for i, p in enumerate(tree, start=1):\n            parent[i] = p\n\n        for i in range(len(labels)):\n            stack = []\n            j = i\n            while j > 0:\n                stack.append(j)\n                j = parent[j]\n            stack.append(0)\n            stack.pop()\n            for j in range(1, len(stack)):\n                if labels[stack[j]] < labels[stack[j-1]]:\n                    L = max(L, j)\n                else:\n                    break\n        return L\n\n    def count_nondecreasing_jumping_paths(labels: List[int], tree: List[int]) -> int:\n        L = longest_nondecreasing_jumping_path(labels, tree)\n        M = 0\n        for i in range(len(labels)):\n            stack = []\n            j = i\n            while j > 0:\n                stack.append(j)\n                j = tree[j]\n            stack.append(0)\n            stack.pop()\n            for j in range(1, len(stack)):\n                if labels[stack[j]] < labels[stack[j-1]]:\n                    if j == L:\n                        M += 1\n                else:\n                    break\n        return M % 11092019\n\n    N, labels, tree = read_input(stdin)\n    L = longest_nondecreasing_jumping_path(labels, tree)\n    M = count_nondecreasing_jumping_paths(labels, tree)\n    return f\"{L} {M}\" "
    },
    {
        "number": 3029,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_jumping_path(u, v):\n        max_length = 0\n        count = 0\n        visited = [False] * n\n        stack = [(u, 0)]\n\n        while stack:\n            v, length = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                if length == max_length:\n                    count += 1\n                elif length > max_length:\n                    max_length = length\n                    count = 1\n\n                for child in graph[v]:\n                    if not visited[child] and labels[child] >= labels[v]:\n                        stack.append((child, length + 1))\n\n        return max_length, count\n\n    n = int(stdin.readline())\n    labels = [int(stdin.readline()) for _ in range(n)]\n    graph = [[] for _ in range(n)]\n\n    for i in range(2, n):\n        parent = int(stdin.readline())\n        graph[parent].append(i)\n\n    max_length, count = find_max_jumping_path(0, 0)\n    return f\"{max_length} {count % 11092019}\""
    },
    {
        "number": 3029,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def build_tree(parent):\n        tree = [[] for _ in range(n + 1)]\n        for i, p in enumerate(parent, 1):\n            if i != 1:\n                tree[p].append(i)\n        return tree\n\n    def dfs(tree, vertex, depth, labels):\n        nonlocal max_depth, paths\n        if tree[vertex]:\n            for child in tree[vertex]:\n                dfs(tree, child, depth + 1, labels)\n        else:\n            if depth > max_depth:\n                max_depth = depth\n                paths = 1\n            elif depth == max_depth:\n                paths += 1\n\n        if labels[vertex] >= labels[parent[vertex]]:\n            if depth > max_depth:\n                max_depth = depth\n                paths = 1\n            elif depth == max_depth:\n                paths += 1\n\n        return max_depth, paths % 11092019\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    labels = [int(line) for line in lines[1:n + 1]]\n    parent = [int(line) for line in lines[n + 1:]]\n\n    tree = build_tree(parent)\n    max_depth, paths = dfs(tree, 1, 0, labels)\n\n    return f'{max_depth} {paths}'"
    },
    {
        "number": 3029,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    u = [int(x) for x in lines[1:N+1]]\n    parent = [-1] * N\n    for i in range(N-1):\n        parent[int(lines[N+1+i])] = int(lines[N+1+i]) - 1\n\n    def lcp(s1, s2):\n        n1, n2 = len(s1), len(s2)\n        if n1 < n2:\n            s1, s2 = s2, s1\n            n1, n2 = n2, n1\n        aux = [0] * (n1 + 1)\n        for i in range(n2):\n            aux[i] = max(0, aux[i-1] - 1)\n            while i + aux[i] < n2 and s1[aux[i]] == s2[i+aux[i]]:\n                aux[i] += 1\n        return aux[n2-1]\n\n    def dp(v):\n        if v not in memo:\n            if parent[v] == -1:\n                memo[v] = (1, 1)\n            else:\n                L, M = dp(parent[v])\n                idx = bisect_left(orders[v], u[parent[v]])\n                new_L = L + idx\n                new_M = M * (idx+1) % 11092019\n                memo[v] = (new_L, new_M)\n        return memo[v]\n\n    memo = {}\n    orders = [[] for _ in range(N)]\n    for v in range(1, N):\n        p = parent[v]\n        orders[p].append(u[v])\n        orders[p].sort()\n\n    for v in range(N):\n        if v not in memo:\n            dp(v)\n\n    L, M = max(memo.values(), key=lambda x: x[0])\n    return f\"{L} {M}\""
    },
    {
        "number": 3029,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def build_tree(n, tree):\n        for i in range(2, n + 1):\n            tree[i] = [tree[i]]\n            while True:\n                parent = tree[i][-1]\n                if parent == 1:\n                    break\n                tree[i].append(parent)\n                if u[parent] >= u[i]:\n                    break\n\n    def longest_jumping_path(n, tree, u):\n        longest_path = [0] * (n + 1)\n        for i in range(n, 1, -1):\n            for j in tree[i]:\n                if u[j] >= u[i]:\n                    longest_path[i] = max(longest_path[i], longest_path[j] + 1)\n        return longest_path\n\n    def count_jumping_paths(n, tree, u, longest_path):\n        count = [0] * (n + 1)\n        count[1] = 1\n        for i in range(2, n + 1):\n            for j in tree[i]:\n                if u[j] >= u[i] and longest_path[i] == longest_path[j] + 1:\n                    count[i] += count[j]\n        return count\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    u = [int(line) for line in lines[1:n + 1]]\n    tree = {1: []}\n    for i, parent in enumerate(map(int, lines[n + 1:])):\n        tree[parent] = [i + 2]\n\n    build_tree(n, tree)\n    longest_path = longest_jumping_path(n, tree, u)\n    count = count_jumping_paths(n, tree, u, longest_path)\n    longest_jumping_path_length = max(longest_path)\n    count_jumping_paths_mod = count[n] % 11092019\n    return f\"{longest_jumping_path_length} {count_jumping_paths_mod}\" "
    },
    {
        "number": 3029,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def preprocess(n):\n        tree = [[] for _ in range(n + 1)]\n        depth = [0] * (n + 1)\n        for i in range(2, n + 1):\n            parent = int(input())\n            tree[parent].append(i)\n            depth[i] = depth[parent] + 1\n        return tree, depth\n\n    def longest_nondecreasing_path(tree, depth, labels):\n        def dfs(node):\n            if not tree[node]:\n                return 1, [labels[node]]\n            children_paths = [dfs(child) for child in tree[node]]\n            max_length = 0\n            max_path = []\n            for length, path in children_paths:\n                if len(path) > max_length and path[-1] > labels[node]:\n                    max_length = length\n                    max_path = path\n            if max_length == 0:\n                return 1, [labels[node]]\n            return max_length + 1, max_path + [labels[node]]\n\n        return dfs(1)\n\n    def count_nondecreasing_paths(tree, depth, labels, max_length):\n        count = 0\n\n        def dfs(node):\n            nonlocal count\n            if depth[node] == max_length:\n                count += 1\n                return\n            for child in tree[node]:\n                dfs(child)\n\n        dfs(1)\n        return count % 11092019\n\n    n = int(input())\n    labels = [int(input()) for _ in range(n)]\n    tree, depth = preprocess(n)\n    max_length, max_path = longest_nondecreasing_path(tree, depth, labels)\n    count = count_nondecreasing_paths(tree, depth, labels, max_length)\n    return f\"{max_length} {count}\""
    },
    {
        "number": 3030,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def build_tree(values, parents):\n        tree = [[] for _ in range(len(values))]\n        for i, parent in enumerate(parents):\n            if parent != 0:\n                tree[parent - 1].append(i)\n        return tree\n\n    def is_valid_heap(values, tree, node=0, parent_value=None):\n        if parent_value is None or values[node] > values[parent_value]:\n            for child in tree[node]:\n                if not is_valid_heap(values, tree, child, node):\n                    return False\n            return True\n        return False\n\n    def find_largest_heap(values, tree):\n        max_size = 0\n        for i in range(len(values)):\n            if is_valid_heap(values, tree, i):\n                size = sum(1 for node in tree if is_valid_heap(values, tree, node, i)) + 1\n                max_size = max(max_size, size)\n        return max_size\n\n    n = int(stdin.readline())\n    values = []\n    parents = []\n    for i in range(n):\n        value, parent = map(int, stdin.readline().split())\n        values.append(value)\n        parents.append(parent)\n\n    tree = build_tree(values, parents)\n    max_size = find_largest_heap(values, tree)\n    return str(max_size)"
    },
    {
        "number": 3030,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def build_tree(values, parents):\n        tree = {i: [] for i in range(1, len(values) + 1)}\n        for i, parent in enumerate(parents, start=1):\n            if parent:\n                tree[parent].append(i)\n        return tree\n\n    def is_heap(tree, node, values):\n        for child in tree[node]:\n            if values[node - 1] <= values[child - 1]:\n                return False\n            if not is_heap(tree, child, values):\n                return False\n        return True\n\n    def find_max_heap(tree, values, node=1):\n        max_size = 0\n        for child in tree[node]:\n            max_size = max(max_size, find_max_heap(tree, values, child))\n        if is_heap(tree, node, values):\n            return max_size + 1\n        return max_size\n\n    n = int(stdin.readline().strip())\n    values = []\n    parents = []\n    for i in range(n):\n        v, p = map(int, stdin.readline().strip().split())\n        values.append(v)\n        parents.append(p)\n\n    tree = build_tree(values, parents)\n    max_size = find_max_heap(tree, values)\n    return str(max_size)"
    },
    {
        "number": 3030,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\", 1)[0])\n    nodes = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    parent_values = [0] * n\n\n    for i in range(1, n):\n        value, parent_index = nodes[i]\n        parent_values[i] = value + parent_values[parent_index]\n\n    max_size = 0\n    for i in range(1, n):\n        value, parent_index = nodes[i]\n        size = 1\n        while parent_index > 0:\n            if nodes[parent_index][0] > value:\n                size += 1\n            elif nodes[parent_index][0] + parent_values[parent_index] <= value:\n                size += 1\n                parent_values[parent_index] += value - nodes[parent_index][0]\n            else:\n                break\n            parent_index = nodes[parent_index][1]\n        max_size = max(max_size, size)\n\n    return str(max_size)"
    },
    {
        "number": 3030,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_subset(node, parent, values, max_subset):\n        if values[node] > values[parent]:\n            max_subset[node] = max(max_subset[node], max_subset[parent] + 1)\n        for child in children[node]:\n            find_max_subset(child, node, values, max_subset)\n\n    n = int(stdin.readline())\n    values = [0] * (n + 1)\n    children = [[] for _ in range(n + 1)]\n    max_subset = [1] * (n + 1)\n\n    for i in range(1, n + 1):\n        v, p = map(int, stdin.readline().split())\n        values[i] = v\n        children[p].append(i)\n\n    find_max_subset(1, 0, values, max_subset)\n    return str(max(max_subset[1:]))"
    },
    {
        "number": 3030,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    nodes = []\n    for i in range(1, n+1):\n        v, p = map(int, lines[i].split())\n        nodes.append((v, p))\n\n    def find_max_subset(root: int, nodes: list) -> tuple:\n        if not nodes:\n            return 0, float('-inf')\n        if root not in nodes:\n            return 0, float('-inf')\n        children = [(v, i) for i, (v, p) in enumerate(nodes) if p == root]\n        children.sort(reverse=True)\n        include_root = 1\n        exclude_root = 0\n        for v, i in children:\n            new_nodes = [node for node in nodes if node[1] != root]\n            included, _ = find_max_subset(i, new_nodes)\n            exclude_root = max(exclude_root, include_root + included)\n        return exclude_root, children[0][0] if children else float('-inf')\n\n    max_subset_size, _ = find_max_subset(0, nodes)\n    return str(max_subset_size)"
    },
    {
        "number": 3030,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    nodes = []\n    for i in range(n):\n        v, p = map(int, stdin.readline().split())\n        nodes.append({\"index\": i + 1, \"value\": v, \"parent\": p})\n\n    def is_ancestor(node1, node2):\n        current = node2[\"parent\"]\n        while current != 0:\n            if current == node1[\"index\"]:\n                return True\n            current = nodes[current - 1][\"parent\"]\n        return False\n\n    def find_max_subset(node, current_subset):\n        if node is None:\n            return 0\n\n        include_node = 0\n        for child in node[\"children\"]:\n            include_node += find_max_subset(child, current_subset)\n\n        exclude_node = 1\n        for child in node[\"children\"]:\n            exclude_node += find_max_subset(child, [node] + current_subset)\n\n        if include_node > exclude_node:\n            return include_node\n        else:\n            for child in node[\"children\"]:\n                if child in current_subset:\n                    current_subset.remove(child)\n            return exclude_node\n\n    def build_tree(root):\n        for node in nodes:\n            if node[\"parent\"] != 0:\n                if nodes[node[\"parent\"] - 1][\"children\"] is None:\n                    nodes[node[\"parent\"] - 1][\"children\"] = [node]\n                else:\n                    nodes[node[\"parent\"] - 1][\"children\"].append(node)\n\n    root = nodes[0]\n    build_tree(root)\n    max_subset = find_max_subset(root, [])\n\n    return str(max_subset)"
    },
    {
        "number": 3030,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    nodes = []\n    for i in range(n):\n        v, p = map(int, stdin.readline().split())\n        nodes.append((v, p))\n\n    def find_children(parent_idx):\n        return [i for i, (_, p) in enumerate(nodes) if p == parent_idx]\n\n    def is_valid(idx, subset):\n        if idx not in subset:\n            return False\n        for child in find_children(idx):\n            if child not in subset:\n                return True\n            if nodes[child][0] >= nodes[idx][0]:\n                return False\n        return all(is_valid(child, subset) for child in find_children(idx))\n\n    def find_largest_subset():\n        max_size = 0\n        for i in range(n):\n            subset = {i}\n            for child in find_children(i):\n                subset.add(child)\n            while True:\n                found = False\n                for child in find_children(i):\n                    if child not in subset and is_valid(child, subset):\n                        subset.add(child)\n                        found = True\n                if not found:\n                    break\n            max_size = max(max_size, len(subset))\n        return max_size\n\n    return str(find_largest_subset())"
    },
    {
        "number": 3030,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_subset_size(n, values, parents):\n        size = [1] * n\n        max_size = 1\n\n        for i in range(1, n):\n            parent = parents[i]\n            if values[i] > values[parent]:\n                size[i] = size[parent] + 1\n                max_size = max(max_size, size[i])\n\n        return max_size\n\n    n = int(stdin.readline().strip())\n    values = []\n    parents = []\n\n    for i in range(n):\n        value, parent = map(int, stdin.readline().strip().split())\n        values.append(value)\n        parents.append(parent)\n\n    max_subset_size = find_max_subset_size(n, values, parents)\n    return str(max_subset_size)"
    },
    {
        "number": 3030,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    nodes = [list(map(int, i.split())) for i in stdin.split('\\n')[1:]]\n    nodes = sorted(nodes, key=lambda x: x[0])\n    nodes.reverse()\n    heap = [0] * n\n    heap[0] = nodes[0][0]\n    i = 1\n    while i < n:\n        if nodes[i][1] == 0 or nodes[i][0] > heap[nodes[i][1]]:\n            heap[i] = nodes[i][0]\n            i += 1\n        else:\n            nodes[i][1] = nodes[nodes[i][1]][1]\n    return str(sum(heap != [0] * n))"
    },
    {
        "number": 3030,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_ancestor(node1: int, node2: int) -> bool:\n        while node2 != 0:\n            if node1 == node2:\n                return True\n            node2 = parent[node2]\n        return False\n\n    n = int(stdin.readline().strip())\n    parent = [0] * n\n    values = [0] * n\n\n    for i in range(n):\n        v, p = map(int, stdin.readline().strip().split())\n        values[i] = v\n        parent[i] = p\n\n    dp = [1] * n\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if is_ancestor(i, j):\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return str(max(dp))"
    },
    {
        "number": 3031,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    adj_list = [[] for _ in range(n+1)]\n    for line in lines[1:]:\n        a, b, c = map(int, line.split())\n        adj_list[a].append((b, c))\n        adj_list[b].append((a, c))\n\n    def is_rainbow(node, color):\n        if len(adj_list[node]) == 0:\n            return True\n        for next_node, next_color in adj_list[node]:\n            if next_color == color or not is_rainbow(next_node, next_color):\n                return False\n        return True\n\n    good_nodes = []\n    for i in range(1, n+1):\n        colors = set()\n        for j, color in adj_list[i]:\n            colors.add(color)\n        if len(colors) == len(adj_list[i]) and all(is_rainbow(j, color) for j, color in adj_list[i]):\n            good_nodes.append(i)\n\n    output = [str(len(good_nodes))] + [str(node) for node in good_nodes]\n    return '\\n'.join(output)"
    },
    {
        "number": 3031,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, color, visited, adj_colors, good_nodes):\n        if node not in visited:\n            visited.add(node)\n            if all(adj_colors[color] != adj_colors[c] for c in adj_colors if c != color):\n                good_nodes.add(node)\n            for neighbor in adj[node]:\n                dfs(neighbor, adj_colors[node, neighbor], visited, adj_colors, good_nodes)\n\n    n = int(stdin.readline().strip())\n    adj = {i: set() for i in range(1, n + 1)}\n    adj_colors = {}\n\n    for _ in range(n - 1):\n        a, b, c = map(int, stdin.readline().strip().split())\n        adj[a].add(b)\n        adj[b].add(a)\n        adj_colors[a, b] = c\n        adj_colors[b, a] = c\n\n    good_nodes = set()\n    dfs(1, 0, set(), adj_colors, good_nodes)\n\n    return f\"{len(good_nodes)}\\n\" + \"\\n\".join(map(str, sorted(good_nodes)))"
    },
    {
        "number": 3031,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_rainbow(edge_colors):\n        for i in range(1, len(edge_colors)):\n            if edge_colors[i] == edge_colors[i - 1]:\n                return False\n        return True\n\n    def find_good_nodes(node, parent, colors, visited):\n        good_nodes = []\n        if all(is_rainbow(visited[i][node]) for i in range(n)):\n            good_nodes.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and (colors[node][neighbor] not in visited[node][neighbor]):\n                visited[node][neighbor].append(colors[node][neighbor])\n                visited[neighbor][node].append(colors[node][neighbor])\n                good_nodes += find_good_nodes(neighbor, node, colors, visited)\n        return good_nodes\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    graph = [[] for _ in range(n)]\n    colors = [[0] * n for _ in range(n)]\n    for line in lines[1:]:\n        a, b, c = map(int, line.split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n        colors[a - 1][b - 1] = c\n        colors[b - 1][a - 1] = c\n\n    visited = [[[] for _ in range(n)] for _ in range(n)]\n    good_nodes = find_good_nodes(0, -1, colors, visited)\n    k = len(good_nodes)\n\n    return f\"{k}\\n\" + \"\\n\".join(map(str, sorted(good_nodes))) + \"\\n\" "
    },
    {
        "number": 3031,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, edges = int(stdin.split(\"\\n\", 1)[0]), [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    adj_colors, adj_list = [[-1] * n for _ in range(n)], [[] for _ in range(n)]\n    for u, v, c in edges:\n        adj_colors[u - 1][v - 1], adj_colors[v - 1][u - 1] = c, c\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n\n    def dfs(u, visited, parent):\n        if all(adj_colors[u][v] != adj_colors[u][parent] for v in adj_list[u] if v != parent):\n            return True\n        visited.add(u)\n        for v in adj_list[u]:\n            if v not in visited and dfs(v, visited, u):\n                return True\n        return False\n\n    good_nodes = [u for u in range(n) if dfs(u, set(), -1)]\n    output = [str(len(good_nodes))] + [str(u + 1) for u in good_nodes]\n    return \"\\n\".join(output)"
    },
    {
        "number": 3031,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_rainbow(edge_colors, nodes, start, end):\n        if start == end:\n            return True\n        visited = [False] * len(nodes)\n        stack = [(start, -1)]\n        while stack:\n            node, parent = stack.pop()\n            if visited[node]:\n                continue\n            visited[node] = True\n            if parent != -1:\n                edge_color = edge_colors[parent][node]\n                if edge_color == parent_edge_color:\n                    return False\n            parent_edge_color = edge_colors[node][end] if end in edge_colors[node] else -1\n            for child in nodes[node]:\n                if not visited[child]:\n                    stack.append((child, node))\n        return True\n\n    def find_good_nodes(edge_colors, nodes):\n        good_nodes = []\n        for node in range(len(nodes)):\n            if all(is_rainbow(edge_colors, nodes, node, end) for end in nodes[node]):\n                good_nodes.append(node)\n        return good_nodes\n\n    def read_input(stdin):\n        n = int(stdin.readline().strip())\n        edge_colors = [{} for _ in range(n)]\n        nodes = [[] for _ in range(n)]\n        for _ in range(n - 1):\n            a, b, c = map(int, stdin.readline().strip().split())\n            edge_colors[a - 1][b - 1] = c\n            edge_colors[b - 1][a - 1] = c\n            nodes[a - 1].append(b - 1)\n            nodes[b - 1].append(a - 1)\n        return edge_colors, nodes\n\n    edge_colors, nodes = read_input(stdin)\n    good_nodes = find_good_nodes(edge_colors, nodes)\n    return str(len(good_nodes)) + '\\n' + '\\n'.join(map(str, good_nodes)) + '\\n'"
    },
    {
        "number": 3031,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_good_nodes(n, edges):\n        adj_list = [[] for _ in range(n)]\n        for u, v, color in edges:\n            adj_list[u-1].append((v-1, color))\n            adj_list[v-1].append((u-1, color))\n\n        def is_rainbow_path(node, visited, prev_color):\n            visited[node] = True\n            for neighbor, color in adj_list[node]:\n                if not visited[neighbor]:\n                    if color != prev_color and is_rainbow_path(neighbor, visited, color):\n                        return True\n            return False\n\n        good_nodes = []\n        for node in range(n):\n            if all(is_rainbow_path(node, [False] * n, -1) for neighbor, color in adj_list[node]):\n                good_nodes.append(node)\n        return good_nodes\n\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    edges = [input_data[i:i+3] for i in range(1, len(input_data), 3)]\n\n    good_nodes = find_good_nodes(n, edges)\n    output_data = [str(len(good_nodes))] + [str(node+1) for node in good_nodes]\n    return '\\n'.join(output_data)"
    },
    {
        "number": 3031,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_rainbow(path):\n        colors = set()\n        for c in path:\n            if c in colors:\n                return False\n            colors.add(c)\n        return True\n\n    def dfs(node, visited, parent, color):\n        if node not in visited:\n            visited[node] = color\n            for neighbor, neighbor_color in tree[node]:\n                if neighbor != parent:\n                    if not is_rainbow([color, neighbor_color] + path):\n                        continue\n                    dfs(neighbor, visited, node, neighbor_color)\n        else:\n            if visited[node] != color:\n                return\n\n        path.append(color)\n        good_nodes[node] = True\n        dfs(node, visited, None, None)\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    tree = [[] for _ in range(n)]\n    for line in lines[1:]:\n        a, b, c = map(int, line.split())\n        tree[a-1].append((b-1, c))\n        tree[b-1].append((a-1, c))\n\n    good_nodes = [False] * n\n    for node in range(n):\n        if not good_nodes[node]:\n            visited = {}\n            path = []\n            dfs(node, visited, None, None)\n\n    result = [str(i+1) for i in range(n) if good_nodes[i]]\n    return str(len(result)) + '\\n' + '\\n'.join(result)"
    },
    {
        "number": 3031,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_rainbow(path):\n        colors = set()\n        for edge in path:\n            if edge[2] in colors:\n                return False\n            colors.add(edge[2])\n        return True\n\n    def find_paths(node):\n        paths = []\n        for edge in edges:\n            if edge[0] == node:\n                new_path = [edge]\n                paths.append(new_path)\n                if edge[1] not in visited:\n                    find_paths(edge[1])\n                    for path in paths_from[edge[1]]:\n                        paths.append([edge] + path)\n            elif edge[1] == node:\n                new_path = [edge]\n                paths.append(new_path)\n                if edge[0] not in visited:\n                    find_paths(edge[0])\n                    for path in paths_from[edge[0]]:\n                        paths.append([edge] + path)\n        paths_from[node] = paths\n\n    n, edges = int(stdin.readline()), []\n    for _ in range(n - 1):\n        a, b, c = map(int, stdin.readline().split())\n        edges.append((a, b, c))\n\n    paths_from, visited = {}, set()\n    find_paths(1)\n\n    good_nodes = []\n    for i in range(1, n + 1):\n        if all(is_rainbow(path) for path in paths_from[i]):\n            good_nodes.append(i)\n\n    output = [str(len(good_nodes))] + [str(node) for node in good_nodes]\n    return '\\n'.join(output) + '\\n'"
    },
    {
        "number": 3031,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_rainbow(path):\n        colors = set()\n        for edge in path:\n            if edge[2] in colors:\n                return False\n            colors.add(edge[2])\n        return True\n\n    def is_good(node):\n        paths = []\n        for path in dfs(node):\n            if is_rainbow(path):\n                paths.append(path)\n        for i in range(len(paths)):\n            for j in range(i + 1, len(paths)):\n                if not is_rainbow(paths[i] + paths[j]):\n                    return False\n        return True\n\n    def dfs(node, path=[]):\n        path.append((node, node_edges[node][0][0], node_edges[node][0][2]))\n        if len(node_edges[node]) == 1:\n            yield path\n        else:\n            for neighbor, edge in node_edges[node][1:]:\n                node_edges[node].remove((neighbor, edge))\n                node_edges[neighbor].remove((node, edge))\n                yield from dfs(neighbor, path)\n                node_edges[node].append((neighbor, edge))\n                node_edges[neighbor].append((node, edge))\n        path.pop()\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    edges = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    node_edges = [[] for _ in range(n + 1)]\n    for edge in edges:\n        node_edges[edge[0]].append((edge[1], edge[2]))\n        node_edges[edge[1]].append((edge[0], edge[2]))\n\n    good_nodes = [i for i in range(1, n + 1) if is_good(i)]\n    return f\"{len(good_nodes)}\\n\" + \"\\n\".join(map(str, good_nodes))"
    },
    {
        "number": 3031,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def read_tree():\n        n = int(stdin.readline().strip())\n        edges = []\n        for _ in range(n - 1):\n            a, b, c = map(int, stdin.readline().strip().split())\n            edges.append((a, b, c))\n        return n, edges\n\n    def build_tree(n, edges):\n        tree = [[] for _ in range(n)]\n        for a, b, c in edges:\n            tree[a - 1].append((b - 1, c))\n            tree[b - 1].append((a - 1, c))\n        return tree\n\n    def is_rainbow(tree, u, v, visited, colors):\n        if u == v:\n            return True\n        if u in visited:\n            return False\n        visited.add(u)\n        for next_node, color in tree[u]:\n            if color not in colors:\n                colors.add(color)\n                if is_rainbow(tree, next_node, v, visited, colors):\n                    return True\n                colors.remove(color)\n        visited.remove(u)\n        return False\n\n    def find_good_nodes(tree, n):\n        good_nodes = set()\n        for i in range(n):\n            if all(is_rainbow(tree, i, j, set(), set()) for j in range(n) if i != j):\n                good_nodes.add(i)\n        return good_nodes\n\n    n, edges = read_tree()\n    tree = build_tree(n, edges)\n    good_nodes = find_good_nodes(tree, n)\n\n    output = [str(len(good_nodes))] + [str(node) for node in good_nodes]\n    return \"\\n\".join(output) + \"\\n\""
    },
    {
        "number": 3032,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.readline().split())\n    program = stdin.readline().split()\n    \n    def parse_program(program, variables_per_bank):\n        def get_bank_and_offset(var_index):\n            bank = (var_index - 1) // variables_per_bank\n            offset = (var_index - 1) % variables_per_bank\n            return bank, offset\n\n        def parse_recursive(program, variables_per_bank, bank_bsr):\n            instructions = 0\n            for token in program:\n                if token.startswith('V'):\n                    var_index = int(token[1:])\n                    bank, offset = get_bank_and_offset(var_index)\n                    if bank != bank_bsr:\n                        instructions += 1\n                    instructions += 1\n                elif token.startswith('R'):\n                    n = int(token[1:])\n                    body, _ = parse_recursive(program, variables_per_bank, bank_bsr)\n                    instructions += n * body\n                elif token == 'E':\n                    break\n            return instructions, bank_bsr\n\n        return parse_recursive(program, variables_per_bank, None)\n\n    return str(parse_program(program, s)[0])"
    },
    {
        "number": 3032,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.readline().split())\n    program = stdin.readline().split()\n\n    min_time = float('inf')\n\n    for i in range(1, b * s + 1):\n        time = 0\n        mapping = {}\n        bsr = 0\n\n        for instruction in program:\n            if instruction.startswith('V'):\n                variable = int(instruction[1:])\n                bank = mapping.get(variable, 0)\n                if bank == 0:\n                    time += 1\n                elif bank == bsr:\n                    time += 1\n                else:\n                    time += 2\n                    bsr = bank\n            elif instruction.startswith('R'):\n                repetitions = int(instruction[1:instruction.index('<')])\n                loop_program = instruction[instruction.index('<') + 1:instruction.index('>')].split()\n                loop_time = solution(loop_program)\n                time += repetitions * loop_time\n            elif instruction == 'E':\n                continue\n\n        min_time = min(min_time, time)\n\n    return str(min_time)\n"
    },
    {
        "number": 3032,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.readline().split())\n    program = stdin.readline().split()\n\n    bank_size = b * s\n\n    def get_location(variable: str) -> int:\n        variable_index = int(variable[1:])\n        return (variable_index - 1) % bank_size\n\n    def get_bank(variable: str) -> int:\n        variable_index = int(variable[1:])\n        return (variable_index - 1) // bank_size\n\n    def count_instructions(program: list, current_bank: int) -> int:\n        instructions = 0\n        for instruction in program:\n            if instruction[0] == \"R\":\n                n, subprogram = int(instruction[1]), instruction[3:-1]\n                instructions += count_instructions(subprogram, current_bank) * n\n            elif instruction[0] == \"V\":\n                location = get_location(instruction)\n                bank = get_bank(instruction)\n                if bank == current_bank:\n                    instructions += 1\n                else:\n                    instructions += 2\n                    if bank > current_bank:\n                        instructions += 1\n        return instructions\n\n    min_instructions = float(\"inf\")\n    for i in range(b):\n        min_instructions = min(min_instructions, count_instructions(program, i))\n\n    return str(min_instructions)"
    },
    {
        "number": 3032,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def execute_program(program, bank_size, bank_count, variables):\n        def set_bsr(value):\n            nonlocal bsr\n            bsr = value\n\n        def get_memory_index(var_index):\n            bank_index = (var_index - 1) // bank_size\n            return (bank_index, (var_index - 1) % bank_size)\n\n        def execute_instruction(instruction):\n            nonlocal instructions_count\n            if instruction.startswith('V'):\n                var_index = int(instruction[1:])\n                if var_index in variables:\n                    bank_index, memory_index = get_memory_index(var_index)\n                    if bank_index == bsr or bsr is None:\n                        instructions_count += 1\n                    else:\n                        set_bsr(bank_index)\n                        instructions_count += 2\n                else:\n                    raise ValueError(\"Undefined variable reference\")\n            elif instruction.startswith('R'):\n                repetitions = int(instruction[1:instruction.index('<')])\n                inner_program = instruction[instruction.index('<') + 1:instruction.rindex('>')].split()\n                for _ in range(repetitions):\n                    execute_program(inner_program, bank_size, bank_count, variables)\n            elif instruction.startswith('E'):\n                return\n            else:\n                raise ValueError(\"Invalid instruction\")\n\n        instructions_count = 0\n        bsr = None\n        for instruction in program:\n            execute_instruction(instruction)\n        return instructions_count\n\n    bank_count, bank_size = map(int, stdin.readline().split())\n    variables = set(map(int, stdin.readline().split()))\n    program = stdin.readline().split()\n\n    return str(execute_program(program, bank_size, bank_count, variables))"
    },
    {
        "number": 3032,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.split()[0].split())\n    program = stdin.split('\\n')[1].split()\n    total_variables = b * s\n    \n    def get_min_instructions(program, variables_per_bank):\n        min_instructions = float('inf')\n        for i in range(variables_per_bank):\n            curr_min_instructions = 0\n            for element in program:\n                if element.startswith('V'):\n                    variable = int(element[1:])\n                    if variable > i * s and variable <= (i + 1) * s:\n                        curr_min_instructions += 1\n                    else:\n                        curr_min_instructions += 2\n                elif element.startswith('R'):\n                    loop_program = program[program.index(element) + 1:program.index('E')]\n                    loop_body = get_min_instructions(loop_program, variables_per_bank)\n                    curr_min_instructions += loop_body * int(element[1:])\n                    program = program[program.index('E') + 1:]\n                else:\n                    raise ValueError(\"Invalid element in program\")\n            min_instructions = min(min_instructions, curr_min_instructions)\n        return min_instructions\n\n    return str(get_min_instructions(program, total_variables))"
    },
    {
        "number": 3032,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.readline().split())\n    program = stdin.readline().split()\n\n    def execute_program(program, memory_mapping):\n        instructions = 0\n        for i, instruction in enumerate(program):\n            if instruction[0] == 'V':\n                memory_bank, memory_index = memory_mapping[int(instruction[1:])]\n                if memory_bank == -1:\n                    instructions += 1\n                else:\n                    instructions += 2\n            elif instruction[0] == 'R':\n                n = int(instruction[1:instruction.index('<')])\n                sub_program = program[i+1:i+1+n]\n                sub_memory_mapping = memory_mapping.copy()\n                execute_program(sub_program, sub_memory_mapping)\n        return instructions\n\n    memory_mapping = {i: (-1, -1) for i in range(1, min(b * s, 13) + 1)}\n    for i in range(1, b + 1):\n        for j in range(1, s + 1):\n            memory_mapping[i * j] = (i - 1, 0)\n\n    return str(execute_program(program, memory_mapping))"
    },
    {
        "number": 3032,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.readline().split())\n    program = stdin.readline().strip().split()\n\n    def get_min_time(banks, variables, program):\n        min_time = 0\n        bank_mapping = {}\n        for var in range(1, variables + 1):\n            bank = var % banks\n            if bank not in bank_mapping:\n                bank_mapping[bank] = [var]\n            else:\n                bank_mapping[bank].append(var)\n\n        for instruction in program:\n            if instruction.startswith(\"V\"):\n                var = int(instruction[1:])\n                for bank, vars_list in bank_mapping.items():\n                    if var in vars_list:\n                        min_time += 1\n                        break\n            elif instruction.startswith(\"R\"):\n                n = int(instruction[1:instruction.index(\" \")-1])\n                sub_program = instruction[instruction.index(\" \")+1:-1].split()\n                min_time += get_min_time(banks, variables, sub_program) * n\n            else:\n                min_time += 1\n\n        return min_time\n\n    return str(get_min_time(b, s, program))"
    },
    {
        "number": 3032,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    b, s, *program = stdin.split()\n    b, s = int(b), int(s)\n\n    def get_bank_and_offset(var_index: int) -> tuple:\n        return (var_index - 1) // s, (var_index - 1) % s\n\n    def process_program(program: list, bank_assignments: dict) -> int:\n        total_instructions = 0\n        for elem in program:\n            if elem.startswith(\"R\"):\n                n = int(elem[1:])\n                sub_program = program.pop(0).split()\n                total_instructions += process_program(sub_program, bank_assignments) * n\n            elif elem.startswith(\"V\"):\n                var_index = int(elem[1:])\n                bank, offset = get_bank_and_offset(var_index)\n                if bank not in bank_assignments:\n                    bank_assignments[bank] = set()\n                if offset not in bank_assignments[bank]:\n                    bank_assignments[bank].add(offset)\n                    total_instructions += 1\n            else:\n                raise ValueError(\"Invalid program element\")\n        return total_instructions\n\n    initial_bank_assignments = {i: {0} for i in range(b)}\n    return str(process_program(program, initial_bank_assignments))"
    },
    {
        "number": 3032,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.readline().split())\n    program = stdin.readline().split()\n\n    def parse_program(program: List[str], variables: Dict[str, int]) -> int:\n        instructions = 0\n\n        for i, op in enumerate(program):\n            if op.startswith(\"R\"):\n                n = int(op[1:])\n                instructions += parse_program(program[i + 1 : i + n + 1], variables)\n            elif op.startswith(\"V\"):\n                v = int(op[1:])\n                bank = variables.get(v)\n\n                if bank is None:\n                    if not variables:\n                        bank = 0\n                    else:\n                        bank = max(variables.values()) + 1\n\n                    if bank >= b:\n                        bank = 0\n\n                    variables[v] = bank\n\n                if bank == 0:\n                    instructions += 1\n                else:\n                    instructions += 2\n            elif op == \"E\":\n                break\n\n        return instructions\n\n    variables = {}\n    result = parse_program(program, variables)\n\n    return str(result)"
    },
    {
        "number": 3032,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b, s, program = list(map(int, stdin.split()))\n    return str(execute_program(b, s, program))\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    X = 0\n\n    while True:\n        digits = [int(d) for d in str(X)]\n        digits_sum = sum(digits)\n        if f(digits_sum, B) == N:\n            break\n        X += 1\n\n    if X < 2**63:\n        return str(X)\n    else:\n        return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    X = 0\n\n    while True:\n        digits_sum = 0\n        X += 1\n\n        for digit in str(X):\n            digits_sum += int(digit)\n\n        if f(B, digits_sum) == N:\n            return X\n\n    return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    digits = [int(d) for d in str(N)]\n    max_digit = max(digits)\n    if max_digit >= B or N == 0:\n        return \"impossible\"\n    \n    X = N\n    for i in range(1, N):\n        X += sum(int(d) ** B for d in str(i))\n        if X >= 2**63:\n            return \"impossible\"\n        if X == N:\n            return i + 1\n    \n    return \"impossible\""
    },
    {
        "number": 3033,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    X = 0\n    for i in range(2, int(N**(1/B*2)) + 1):\n        num = i\n        digits = []\n        while num > 0:\n            digits.append(num % B)\n            num //= B\n        if int(\"\".join(map(str, digits))) == N:\n            X = i\n            break\n    return str(X) if X else \"impossible\""
    },
    {
        "number": 3033,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    if N == 0:\n        return \"impossible\"\n    X = 0\n    for i in range(1, int(N * (B - 1) ** (1 / B)) + 1):\n        if sum(map(int, str(i))) * (B - 1) >= N:\n            X = i\n            break\n    for i in range(X, int(N * (B - 1) ** (1 / B)) + 1):\n        if f(i, B) == N:\n            return str(i)\n    return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n\n    def digits_product(x: int, base: int) -> int:\n        product = 1\n        while x > 0:\n            digit = x % 10\n            product *= digit\n            x //= 10\n        return product\n\n    def find_smallest_X(N: int, base: int) -> int:\n        for x in range(2, 2**63):\n            if digits_product(x, base) == N:\n                return x\n        return -1\n\n    smallest_X = find_smallest_X(N, B)\n    if smallest_X == -1:\n        return \"impossible\"\n    else:\n        return str(smallest_X)"
    },
    {
        "number": 3033,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    if N == 0:\n        return \"impossible\"\n    X = \"\"\n    while N > 0:\n        N, digit = divmod(N, B)\n        X = str(digit) + X\n    X = int(X)\n    return X if X > 0 else \"impossible\""
    },
    {
        "number": 3033,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    for X in range(2**63):\n        if f_B(X, B) == N:\n            return str(X)\n    return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    if N == 0:\n        return \"impossible\"\n    X = \"\"\n    while N > 0:\n        N, r = divmod(N, B)\n        X = str(r) + X\n    X = int(X)\n    if X > 0 and f(X, B) == N:\n        return X\n    else:\n        return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    \n    def get_digits_sum(x, base):\n        return sum(int(d) for d in str(x))\n\n    def binary_search(base, target):\n        left, right = 1, 2**63 - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if get_digits_sum(mid, base) == target:\n                return mid\n            elif get_digits_sum(mid, base) < target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return \"impossible\"\n\n    result = binary_search(B, N)\n    return str(result)"
    },
    {
        "number": 3034,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_roof_coordinates(roof_segments):\n        roof_coordinates = []\n        for segment in roof_segments:\n            x, y = map(int, segment.split())\n            roof_coordinates.append((x, y))\n        return sorted(roof_coordinates, key=lambda x: x[0])\n\n    def get_cloud_probabilities(clouds):\n        cloud_probabilities = []\n        for cloud in clouds:\n            start, end, probability, amount = map(float, cloud.split())\n            cloud_probabilities.append((start, end, probability, amount))\n        return sorted(cloud_probabilities, key=lambda x: x[0])\n\n    def get_expected_rain(cloud_probabilities, roof_coordinates, d, t):\n        expected_rain = 0\n        current_position = 0\n        current_roof = 0\n\n        for cloud in cloud_probabilities:\n            start, end, probability, amount = cloud\n            while current_roof < len(roof_coordinates) and roof_coordinates[current_roof][0] <= current_position:\n                current_roof += 1\n\n            if current_roof > 0:\n                current_roof -= 1\n                if roof_coordinates[current_roof][1] <= current_position:\n                    current_roof += 1\n\n            if current_roof > 0 and roof_coordinates[current_roof][1] > current_position:\n                expected_rain += (end - max(start, current_position)) * probability * amount\n            else:\n                expected_rain += (end - start) * probability * amount\n\n            current_position = end\n\n        return expected_rain\n\n    def main():\n        d, t, c, r = map(int, stdin.readline().split())\n        clouds = [stdin.readline().strip() for _ in range(c)]\n        roof_segments = [stdin.readline().strip() for _ in range(r)]\n\n        roof_coordinates = get_roof_coordinates(roof_segments)\n        cloud_probabilities = get_cloud_probabilities(clouds)\n\n        expected_rain = get_expected_rain(cloud_probabilities, roof_coordinates, d, t)\n        return f\"{expected_rain:.5f}\"\n\n    return main() "
    },
    {
        "number": 3034,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_list = stdin.split('\\n')\n    input_list = [line.split() for line in input_list]\n    d, t, c, r = map(int, input_list[0])\n    clouds = input_list[1:c+1]\n    roofs = input_list[c+1:]\n\n    # Initialize variables\n    expected_rain = 0\n    cumulative_roof_length = [0] * (d + 1)\n\n    # Calculate expected rain\n    for cloud in clouds:\n        s, e, p, a = map(float, cloud)\n        for i in range(int(s), int(e) + 1):\n            expected_rain += a * p * (1 - cumulative_roof_length[i] / d)\n\n    # Calculate cumulative roof length\n    for roof in roofs:\n        x, y = map(int, roof)\n        for i in range(x, y):\n            cumulative_roof_length[i] = 1\n\n    # Return output\n    return str(expected_rain)"
    },
    {
        "number": 3034,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_roof_segments(roof_data: list) -> list:\n        segments = []\n        for x, y in roof_data:\n            segments.append((x, y))\n        return segments\n\n    def get_clouds(cloud_data: list) -> list:\n        clouds = []\n        for s, e, p, a in cloud_data:\n            clouds.append((s, e, p, a))\n        return clouds\n\n    def calculate_min_rain(roof_segments: list, clouds: list, d: int, t: int) -> float:\n        roof_segments.sort()\n        cloud_rains = [0] * t\n\n        for s, e, p, a in clouds:\n            for i in range(s, e):\n                cloud_rains[i] += p * a\n\n        min_rain = float('inf')\n        current_rain = 0\n        prev_roof = 0\n\n        for i in range(d + 1):\n            current_rain += sum(cloud_rains[i:i + len(roof_segments)])\n\n            for j in range(prev_roof, len(roof_segments)):\n                if roof_segments[j][0] <= i < roof_segments[j][1]:\n                    break\n                current_rain -= roof_segments[j][2] * a\n\n            min_rain = min(min_rain, current_rain)\n            prev_roof = j\n\n        return min_rain\n\n    lines = stdin.split('\\n')\n    d, t, c, r = map(int, lines[0].split())\n    roof_data = [list(map(int, lines[i + 1].split())) for i in range(r)]\n    roof_segments = get_roof_segments(roof_data)\n    cloud_data = [list(map(float, lines[i + r + 1].split())) for i in range(c)]\n    clouds = get_clouds(cloud_data)\n\n    min_rain = calculate_min_rain(roof_segments, clouds, d, t)\n    return f\"{min_rain:.5f}\""
    },
    {
        "number": 3034,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_roof_segments(roof_data):\n        roof_segments = []\n        for roof in roof_data:\n            x, y = map(int, roof.split())\n            roof_segments.append((x, y))\n        return roof_segments\n\n    def get_cloud_data(cloud_data):\n        clouds = []\n        for cloud in cloud_data:\n            s, e, p, a = map(float, cloud.split())\n            clouds.append((s, e, p, a))\n        return clouds\n\n    def get_expected_rain_fall(clouds, roof_segments, d, t):\n        expected_rain_fall = 0\n        for s, e, p, a in clouds:\n            if s >= t:\n                continue\n            e = min(e, t)\n            for x, y in roof_segments:\n                if x <= d and d < y:\n                    expected_rain_fall += (e - s) * p * a * (y - d) / (y - x)\n                elif x <= d < y:\n                    expected_rain_fall += (e - s) * p * a * (y - x)\n        return expected_rain_fall\n\n    lines = stdin.splitlines()\n    d, t, c, r = map(int, lines[0].split())\n    roof_data = lines[1:r + 1]\n    roof_segments = get_roof_segments(roof_data)\n    cloud_data = lines[r + 1:r + c + 1]\n    clouds = get_cloud_data(cloud_data)\n\n    expected_rain_fall = get_expected_rain_fall(clouds, roof_segments, d, t)\n    return f\"{expected_rain_fall:.5f}\""
    },
    {
        "number": 3034,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin):\n        lines = stdin.split(\"\\n\")\n        d, t, c, r = map(int, lines[0].split())\n        clouds = [list(map(float, line.split())) for line in lines[1:c+1]]\n        roofs = [list(map(int, line.split())) for line in lines[c+1:]]\n        return d, t, clouds, roofs\n\n    def min_rain(d, t, clouds, roofs):\n        def rain_at_position(position, clouds):\n            total_rain = 0\n            for cloud in clouds:\n                s, e, p, a = cloud\n                if s <= position <= e:\n                    total_rain += p * a\n            return total_rain\n\n        def min_rain_on_route(d, t, clouds, roofs):\n            min_rain = float('inf')\n            for i in range(d+1):\n                if any(x <= i <= y for x, y in roofs):\n                    continue\n                min_rain = min(min_rain, rain_at_position(i, clouds))\n            return min_rain\n\n        return min_rain_on_route(d, t, clouds, roofs)\n\n    d, t, clouds, roofs = parse_input(stdin)\n    return f\"{min_rain(d, t, clouds, roofs):.5f}\""
    },
    {
        "number": 3034,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def min_rain(clouds, roofs):\n        def rain_between(start, end):\n            total_rain = 0\n            for cloud in clouds:\n                if cloud[0] < end and cloud[1] > start:\n                    prob = cloud[2]\n                    amount = cloud[3]\n                    total_rain += prob * (min(end, cloud[1]) - max(start, cloud[0])) * amount\n            return total_rain\n\n        min_rain = float('inf')\n        for i in range(len(roofs)):\n            for j in range(i, len(roofs)):\n                rain = rain_between(roofs[i][0], roofs[j][1])\n                min_rain = min(min_rain, rain)\n        return min_rain\n\n    lines = stdin.split('\\n')\n    input_values = list(map(int, lines[0].split()))\n    clouds = []\n    roofs = []\n\n    for i in range(1, input_values[2] + 1):\n        cloud = list(map(float, lines[i].split()))\n        clouds.append(cloud)\n\n    for i in range(input_values[2] + 1, input_values[2] + input_values[3] + 1):\n        roof = list(map(int, lines[i].split()))\n        roofs.append(roof)\n\n    min_rain_amount = min_rain(clouds, roofs)\n    return f\"{min_rain_amount:.5f}\""
    },
    {
        "number": 3034,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_data = list(map(str, stdin.split('\\n')))\n    d, t, c, r = map(int, input_data[0].split())\n    clouds = []\n    for i in range(1, c + 1):\n        s, e, p, a = map(float, input_data[i].split())\n        clouds.append([s, e, p, a])\n    roofs = []\n    for j in range(c + 1, c + 1 + r):\n        x, y = map(int, input_data[j].split())\n        roofs.append([x, y])\n\n    # Sort clouds by starting time\n    clouds.sort(key=lambda x: x[0])\n\n    # Initialize variables\n    expected_rain = 0\n    current_rain = 0\n    current_position = 0\n    current_roof = 0\n    rain_under_roof = 0\n\n    # Iterate through time\n    for time in range(t):\n        # Update current position\n        current_position += 1\n\n        # Update current roof\n        if current_roof < len(roofs) and current_position == roofs[current_roof][1]:\n            current_roof += 1\n\n        # Update current rain\n        for cloud in clouds:\n            s, e, p, a = cloud\n            if s <= time < e:\n                current_rain += a * p\n\n        # Check if under roof\n        if current_roof < len(roofs) and roofs[current_roof][0] <= current_position < roofs[current_roof][1]:\n            rain_under_roof += current_rain\n        else:\n            expected_rain += current_rain\n            current_rain = 0\n\n    # Add final rain under roof\n    expected_rain += rain_under_roof\n\n    return str(expected_rain)"
    },
    {
        "number": 3034,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin):\n        lines = stdin.split(\"\\n\")\n        d, t, c, r = map(int, lines[0].split())\n        clouds = []\n        for i in range(1, c + 1):\n            s, e, p, a = map(int, lines[i].split())\n            clouds.append((s, e, p, a))\n        roofs = []\n        for i in range(c + 1, c + r + 1):\n            x, y = map(int, lines[i].split())\n            roofs.append((x, y))\n        return d, t, clouds, roofs\n\n    def expected_rain(clouds, roofs, d, t):\n        expected_rain_amount = 0\n        for cloud in clouds:\n            s, e, p, a = cloud\n            if s <= t <= e:\n                expected_rain_amount += p * a * (min(e, t) - max(s, 0))\n        return expected_rain_amount\n\n    def under_roof(roofs, d):\n        under_roof_distance = [0] * (d + 1)\n        for roof in roofs:\n            for i in range(roof[0], roof[1]):\n                under_roof_distance[i] = 1\n        return under_roof_distance\n\n    def min_expected_rain(d, t, clouds, roofs):\n        expected_rain_amount = expected_rain(clouds, roofs, d, t)\n        under_roof_distance = under_roof(roofs, d)\n        min_rain_amount = float(\"inf\")\n\n        for i in range(d + 1):\n            if under_roof_distance[i] == 1:\n                continue\n            rain_amount = expected_rain_amount + under_roof_distance[i] * i * 0.33333\n            min_rain_amount = min(min_rain_amount, rain_amount)\n\n        return min_rain_amount\n\n    d, t, clouds, roofs = parse_input(stdin)\n    min_expected_rain_amount = min_expected_rain(d, t, clouds, roofs)\n\n    return f\"{min_expected_rain_amount:.5f}\""
    },
    {
        "number": 3034,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split(\"\\n\")\n        d, t, c, r = map(int, lines[0].split())\n        clouds = []\n        for i in range(1, c + 1):\n            s, e, p, a = map(float, lines[i].split())\n            clouds.append((s, e, p, a))\n        roofs = []\n        for i in range(c + 1, c + r + 1):\n            x, y = map(int, lines[i].split())\n            roofs.append((x, y))\n        return d, t, clouds, roofs\n\n    def get_expected_rain(clouds: list, roofs: list, d: int, t: int) -> float:\n        expected_rain = 0\n        for s, e, p, a in clouds:\n            if s + d / 1000 <= t:\n                expected_rain += p * a * min(e - (s + d / 1000), t - (s + d / 1000))\n        for x, y in roofs:\n            if x <= d <= y:\n                expected_rain /= 1 + (y - x) / (d + 1)\n        return expected_rain\n\n    d, t, clouds, roofs = parse_input(stdin)\n    expected_rain = get_expected_rain(clouds, roofs, d, t)\n    return f\"{expected_rain:.5f}\""
    },
    {
        "number": 3034,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        d, t, c, r = map(int, lines[0].split())\n        clouds = []\n        for i in range(1, c + 1):\n            s, e, p, a = map(float, lines[i].split())\n            clouds.append((s, e, p, a))\n        roofs = []\n        for i in range(c + 1, c + r + 1):\n            x, y = map(int, lines[i].split())\n            roofs.append((x, y))\n        return d, t, clouds, roofs\n\n    def expected_rain(d: int, t: int, clouds: list, roofs: list) -> float:\n        min_rain = float('inf')\n        for roof in roofs:\n            x, y = roof\n            for cloud in clouds:\n                s, e, p, a = cloud\n                expected_rain = a * p * (y - x)\n                min_rain = min(min_rain, expected_rain)\n        return min_rain\n\n    d, t, clouds, roofs = parse_input(stdin)\n    min_rain = expected_rain(d, t, clouds, roofs)\n    return f\"{min_rain:.5f}\""
    },
    {
        "number": 3035,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_trade(offers, wanted):\n        for offer in offers:\n            if offer[1] == wanted:\n                return True\n        return False\n\n    def get_trade_amount(offers, wanted, pink_amount):\n        offers = [offer for offer in offers if offer[1] == wanted]\n        total_amount = 0\n        for offer in offers:\n            amount = min(pink_amount / offer[2], offer[0])\n            pink_amount -= amount * offer[2]\n            total_amount += amount\n        return total_amount\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    children_offers = []\n    for i in range(1, N + 1):\n        offer, wanted, rate = lines[i].split()\n        children_offers.append((float(rate), offer, wanted))\n\n    pink_amount = 1\n    blue_amount = 0\n    for i in range(N):\n        if can_trade(children_offers[i:], \"pink\"):\n            traded_amount = get_trade_amount(children_offers[i:], \"pink\", pink_amount)\n            pink_amount -= traded_amount\n            blue_amount += traded_amount\n\n        if blue_amount >= 10:\n            break\n\n    return f\"{min(blue_amount, 10):.10f}\""
    },
    {
        "number": 3035,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_litres(wanted: str, exchange_rates: dict, litres: float) -> float:\n        if wanted not in exchange_rates:\n            return 0.0\n        rate, other_wanted = exchange_rates[wanted]\n        return litres * rate + get_litres(other_wanted, exchange_rates, litres * rate)\n\n    N = int(stdin.readline().strip())\n    exchange_rates = {}\n    for _ in range(N):\n        offer, wanted, rate = stdin.readline().strip().split()\n        exchange_rates[offer] = (float(rate), wanted)\n\n    blue_lemonade = 10.0\n    for offer, (rate, wanted) in exchange_rates.items():\n        if wanted == \"blue\":\n            continue\n        litres = blue_lemonade / (rate + 1e-6)\n        blue_lemonade -= litres\n        blue_lemonade += get_litres(wanted, exchange_rates, litres)\n\n    return f\"{min(10.0, blue_lemonade):.10f}\""
    },
    {
        "number": 3035,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def max_lemonade(N: int, exchange_rates: list) -> float:\n        max_blue = 0\n        for exchange_rate in exchange_rates:\n            if exchange_rate[1] == \"blue\":\n                max_blue += 1 / exchange_rate[2]\n            else:\n                max_blue += exchange_rate[2]\n        return min(max_blue, 10)\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    exchange_rates = [line.split() + [float(line.split()[-1])] for line in lines[1:N+1]]\n\n    return f\"{max_lemonade(N, exchange_rates):.10f}\""
    },
    {
        "number": 3035,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(target_lemonade, lemonade_list, exchange_rate, pink_lemonade):\n        if target_lemonade == \"pink\":\n            return pink_lemonade\n        for lemonade, rate in lemonade_list:\n            if lemonade == target_lemonade:\n                return rate * pink_lemonade / (rate - 1)\n        return 0.0\n\n    def maximize_blue_lemonade(N, lemonade_list, pink_lemonade):\n        max_blue_lemonade = 0.0\n        for lemonade, _ in lemonade_list:\n            blue_lemonade = is_possible(lemonade, lemonade_list, 1.0, pink_lemonade)\n            if blue_lemonade > max_blue_lemonade:\n                max_blue_lemonade = blue_lemonade\n        return max_blue_lemonade\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    lemonade_list = []\n    for i in range(1, N + 1):\n        lemonade, wanted_lemonade, exchange_rate = lines[i].split()\n        lemonade_list.append((lemonade, float(exchange_rate)))\n\n    max_blue_lemonade = maximize_blue_lemonade(N, lemonade_list, 1.0)\n    if max_blue_lemonade > 10:\n        max_blue_lemonade = 10\n    return \"{:.10f}\".format(max_blue_lemonade)"
    },
    {
        "number": 3035,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    exchange_rates = []\n    for i in range(1, N + 1):\n        line = input_data[i].split()\n        exchange_rates.append((line[0], line[1], float(line[2])))\n\n    # Initialize the variables\n    pink_lemonade = 1.0\n    blue_lemonade = 0.0\n    max_blue_lemonade = 10.0\n\n    # Calculate the maximum amount of blue lemonade\n    for O, W, R in exchange_rates:\n        if W == \"pink\":\n            pink_lemonade -= 1 / R\n        elif W == \"blue\":\n            blue_lemonade += 1 / R\n\n        if blue_lemonade > max_blue_lemonade:\n            max_blue_lemonade = blue_lemonade\n            pink_lemonade = 0.0\n\n    return format(max_blue_lemonade, \".10f\")"
    },
    {
        "number": 3035,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, curr_blue, curr_pink):\n        if start == n:\n            if curr_blue > 10:\n                return 10\n            return curr_blue\n        if curr_pink >= 1:\n            return max(dfs(start + 1, curr_blue, curr_pink), dfs(start + 1, curr_blue + curr_pink / rate[start][1], curr_pink - 1 / rate[start][1]))\n        else:\n            return dfs(start + 1, curr_blue, curr_pink)\n\n    n, *rate = stdin.split('\\n')\n    n = int(n)\n    rate = [(s.split(), float(r)) for s, r in [r.split(' ') for r in rate]]\n\n    return \"{:.10f}\".format(dfs(0, 1, 0))"
    },
    {
        "number": 3035,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def get_max_blue_lemonade(exchange_rates):\n        max_blue_lemonade = 0\n        for rate in exchange_rates:\n            if rate[1] == \"blue\":\n                max_blue_lemonade += 1\n            else:\n                max_blue_lemonade += 1 / rate[2]\n        return max_blue_lemonade\n\n    def get_exchange_rates(stdin):\n        exchange_rates = []\n        for i in range(int(stdin.readline().strip())):\n            offer, want, rate = stdin.readline().strip().split()\n            rate = float(rate)\n            exchange_rates.append((offer, want, rate))\n        return exchange_rates\n\n    def get_max_pink_lemonade(exchange_rates):\n        max_pink_lemonade = 1  # 1 litre of pink lemonade\n        for rate in exchange_rates:\n            if rate[0] == \"pink\":\n                max_pink_lemonade = min(max_pink_lemonade, 1 / rate[2])\n            else:\n                max_pink_lemonade = min(max_pink_lemonade, rate[2])\n        return max_pink_lemonade\n\n    exchange_rates = get_exchange_rates(stdin)\n    max_blue_lemonade = get_max_blue_lemonade(exchange_rates)\n    max_pink_lemonade = get_max_pink_lemonade(exchange_rates)\n\n    # Calculate the greatest common divisor\n    gcd_value = gcd(max_blue_lemonade, max_pink_lemonade)\n\n    # Calculate the amount of blue lemonade obtained\n    blue_lemonade = max_blue_lemonade / gcd_value\n\n    # Throw away excess blue lemonade if necessary\n    if blue_lemonade > 10:\n        blue_lemonade = 10\n\n    return format(blue_lemonade, \".10f\")"
    },
    {
        "number": 3035,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    exchange_rates = []\n    for i in range(1, N + 1):\n        offer, want, rate = lines[i].split()\n        exchange_rates.append((want, offer, float(rate)))\n\n    # Sort exchange rates by decreasing rate\n    exchange_rates.sort(key=lambda x: x[2], reverse=True)\n\n    # Calculate maximum amount of blue lemonade\n    pink_lemonade = 1\n    blue_lemonade = 0\n    for want, offer, rate in exchange_rates:\n        if want == 'blue':\n            blue_lemonade += pink_lemonade / rate\n        else:\n            pink_lemonade += blue_lemonade * rate\n\n    # Cap at 10 litres\n    blue_lemonade = min(blue_lemonade, 10)\n\n    # Format output\n    return f'{blue_lemonade:.10f}'"
    },
    {
        "number": 3035,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    exchange_rates = []\n    for i in range(1, N+1):\n        O, W, R = lines[i].split()\n        exchange_rates.append((O, W, float(R)))\n\n    # Initialize trading variables\n    lemonades = {\"pink\": 1}\n    max_blue = 0\n\n    # Trade with each child\n    for O, W, R in exchange_rates:\n        if W not in lemonades:\n            lemonades[W] = 0\n        if O in lemonades:\n            lemonades[W] += lemonades[O] * (1/R)\n            lemonades[O] = 0\n\n    # Calculate maximum blue lemonade\n    if \"blue\" in lemonades:\n        max_blue = lemonades[\"blue\"]\n        if max_blue > 10:\n            max_blue = 10\n\n    return format(max_blue, \".10f\")"
    },
    {
        "number": 3035,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def trade_lemonade(child_1: tuple, child_2: tuple) -> tuple:\n        amount_1, rate_1, lemonade_1, lemonade_2 = child_1\n        amount_2, rate_2, lemonade_3, lemonade_4 = child_2\n\n        if lemonade_1 == \"blue\" and lemonade_2 == \"pink\":\n            return child_1\n        elif lemonade_1 == \"pink\" and lemonade_2 == \"blue\":\n            return child_2\n        elif lemonade_3 == \"blue\" and lemonade_4 == \"pink\":\n            return child_2\n        elif lemonade_3 == \"pink\" and lemonade_4 == \"blue\":\n            return child_1\n        else:\n            return child_1, child_2\n\n    N = int(stdin.readline().strip())\n    children = []\n\n    for _ in range(N):\n        O, W, R = stdin.readline().strip().split()\n        children.append((1 / float(R), float(R), W, O))\n\n    children.sort(key=lambda x: x[0], reverse=True)\n\n    result = 0\n    for child in children:\n        amount, rate, lemonade_1, lemonade_2 = child\n        if lemonade_1 == \"blue\":\n            result += amount\n        elif lemonade_2 == \"blue\":\n            result += amount * rate\n\n        if result >= 10:\n            break\n\n    return \"{:.10f}\".format(result)"
    },
    {
        "number": 3036,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_data = [line.strip() for line in stdin.split('\\n')]\n    r, s, m, d, n = map(int, input_data[0].split())\n    brands = list(map(int, input_data[1].split()))\n    dishes = input_data[2:s+m+d]\n    incompatible_dishes = [list(map(int, line.split())) for line in input_data[s+m+d:s+m+d+n]]\n\n    # Count the number of incompatible dishes per type\n    incompatible_dishes_count = [0] * (s+m+d)\n    for dish1, dish2 in incompatible_dishes:\n        incompatible_dishes_count[dish1-1] += 1\n        incompatible_dishes_count[dish2-1] += 1\n\n    # Calculate the number of different dinner experiences\n    total_experiences = 1\n    for dish_index, dish in enumerate(dishes):\n        ingredients_count, *ingredients = map(int, dish.split())\n        compatible_brands = 1\n        for ingredient in ingredients:\n            compatible_brands *= brands[ingredient-1] - incompatible_dishes_count[dish_index]\n        total_experiences *= compatible_brands\n\n    # Check if the number of experiences is too large\n    if total_experiences > 10**18:\n        return \"too many\"\n    else:\n        return str(total_experiences) "
    },
    {
        "number": 3036,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_dish_ingredients(dish_index):\n        dish_type = (dish_index <= s) + (dish_index <= s + m) + (dish_index <= s + m + d)\n        dish_index -= dish_type\n        return dishes[dish_type][dish_index][1:]\n\n    def check_compatibility(dish1, dish2):\n        for incompatible_pair in incompatible_pairs:\n            if (dish1 in incompatible_pair and dish2 in incompatible_pair) or (dish2 in incompatible_pair and dish1 in incompatible_pair):\n                return False\n        return True\n\n    def get_dish_brands(ingredients):\n        brands = []\n        for ingredient in ingredients:\n            brands.append(ingredient_brands[ingredient - 1])\n        return brands\n\n    def get_dish_brand_combinations(brands):\n        brand_combinations = []\n        for i in range(1, len(brands) + 1):\n            for combination in itertools.combinations(brands, i):\n                brand_combinations.append(combination)\n        return brand_combinations\n\n    def get_dish_experiences(dish_index):\n        ingredients = get_dish_ingredients(dish_index)\n        brands = get_dish_brands(ingredients)\n        brand_combinations = get_dish_brand_combinations(brands)\n        return len(brand_combinations)\n\n    def get_dish_type(dish_index):\n        if dish_index <= s:\n            return 0\n        elif dish_index <= s + m:\n            return 1\n        else:\n            return 2\n\n    def get_all_dish_experiences():\n        all_dish_experiences = [0] * (s + m + d)\n        for i in range(1, s + m + d + 1):\n            all_dish_experiences[i - 1] = get_dish_experiences(i)\n        return all_dish_experiences\n\n    def find_valid_dish_combinations(all_dish_experiences):\n        valid_dish_combinations = []\n        for i in range(1, s + m + d + 1):\n            for j in range(i, s + m + d + 1):\n                if check_compatibility(i, j):\n                    valid_dish_combinations.append((i, j))\n        return valid_dish_combinations\n\n    def get_dinner_experiences(valid_dish_combinations, all_dish_experiences):\n        dinner_experiences = 1\n        for combination in valid_dish_combinations:\n            dinner_experiences *= all_dish_experiences[combination[0] - 1] * all_dish_experiences[combination[1] - 1]\n            if dinner_experiences > 10**18:\n                return \"too many\"\n        return dinner_experiences\n\n    stdin_list = stdin.split('\\n')\n    r, s, m, d, n = list(map(int, stdin_list[0].split()))\n    ingredient_brands = list(map(int, stdin_list[1].split()))\n    dishes = [[], [], []]\n    for i in range(s):\n        dish = list(map(int, stdin_list[i + 2].split()))\n        dishes[0].append(dish)\n    for i in range(s, s + m):\n        dish = list(map(int, stdin_list[i + 2].split()))\n        dishes[1].append(dish)\n    for i in range(s + m, s + m + d):\n        dish = list(map(int, stdin_list[i + 2].split()))\n        dishes["
    },
    {
        "number": 3036,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def read_line() -> str:\n        return stdin.readline().strip()\n\n    def read_int() -> int:\n        return int(read_line())\n\n    def read_ints() -> List[int]:\n        return list(map(int, read_line().split()))\n\n    r, s, m, d, n = read_ints()\n    b = read_ints()\n    starter_dishes = []\n    main_dishes = []\n    dessert_dishes = []\n    incompatible_dishes = []\n\n    for _ in range(s):\n        k, *i = read_ints()\n        starter_dishes.append((k, i))\n\n    for _ in range(m):\n        k, *i = read_ints()\n        main_dishes.append((k, i))\n\n    for _ in range(d):\n        k, *i = read_ints()\n        dessert_dishes.append((k, i))\n\n    for _ in range(n):\n        j, k = read_ints()\n        incompatible_dishes.append((j, k))\n\n    def count_dinners(starter_dishes, main_dishes, dessert_dishes, incompatible_dishes):\n        total_dinners = 1\n        for dishes in [starter_dishes, main_dishes, dessert_dishes]:\n            total_dinners *= sum(\n                reduce(\n                    lambda x, y: x * y,\n                    (\n                        len(set(bands))\n                        for i, bands in dishes\n                        if i in dish[1]\n                    ),\n                )\n                for dish in dishes\n            )\n\n        for incompatible_pair in incompatible_dishes:\n            starter1, main1, dessert1 = [dish[1] for dish in starter_dishes], [dish[1] for dish in main_dishes], [dish[1] for dish in dessert_dishes]\n            starter2, main2, dessert2 = [], [], []\n            if 1 <= incompatible_pair[0] <= s:\n                starter2 = starter_dishes[incompatible_pair[0] - 1][1]\n            elif s < incompatible_pair[0] <= s + m:\n                main2 = main_dishes[incompatible_pair[0] - s - 1][1]\n            else:\n                dessert2 = dessert_dishes[incompatible_pair[0] - s - m - 1][1]\n\n            if 1 <= incompatible_pair[1] <= s:\n                starter1 = starter_dishes[incompatible_pair[1] - 1][1]\n            elif s < incompatible_pair[1] <= s + m:\n                main1 = main_dishes[incompatible_pair[1] - s - 1][1]\n            else:\n                dessert1 = dessert_dishes[incompatible_pair[1] - s - m - 1][1]\n\n            common_ingredients = set(starter1) & set(starter2) | set(main1) & set(main2) | set(dessert1) & set(dessert2)\n            total_dinners *= reduce(lambda x, y: x * y, (len(set(bands)) for i in common_ingredients for bands in dishes if i in dish[1]))\n\n        return total_dinners\n\n    result = count_dinners(starter_dishes, main_dishes, dessert_dishes, incompatible_dishes)\n    return \"too many\" if result > 10**18 else str(result)"
    },
    {
        "number": 3036,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.readline().split())\n    brands = list(map(int, stdin.readline().split()))\n    stdin.readline()  # Skip brands\n\n    def read_dishes(count: int) -> list:\n        dishes = []\n        for _ in range(count):\n            line = stdin.readline().split()\n            dishes.append((int(line[0]), set(map(int, line[1:]))))\n        return dishes\n\n    starter_dishes = read_dishes(s)\n    main_dishes = read_dishes(m)\n    dessert_dishes = read_dishes(d)\n\n    incompatible_dishes = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().split())\n        incompatible_dishes.append((a, b))\n\n    # Calculate the number of different dinner experiences\n    total_experiences = 1\n    for brand in brands:\n        total_experiences *= brand\n\n    # Check for incompatible dishes\n    for a, b in incompatible_dishes:\n        if a <= s and b <= s:  # Both dishes are starter dishes\n            if not set(starter_dishes[a - 1][1]).isdisjoint(starter_dishes[b - 1][1]):\n                total_experiences = 0\n                break\n        elif a <= s + m and b <= s + m:  # One dish is a starter dish and the other is a main dish\n            if not set(starter_dishes[a - 1][1]).isdisjoint(main_dishes[b - s - 1][1]) or not set(main_dishes[a - s - 1][1]).isdisjoint(starter_dishes[b - 1][1]):\n                total_experiences = 0\n                break\n        elif a <= s + m + d and b <= s + m + d:  # Both dishes are desserts\n            if not set(dessert_dishes[a - s - m - 1][1]).isdisjoint(dessert_dishes[b - s - m - 1][1]):\n                total_experiences = 0\n                break\n        elif a <= s + m + d and b > s + m + d:  # One dish is a dessert and the other is a starter or main dish\n            if not set(dessert_dishes[a - s - m - 1][1]).isdisjoint(starter_dishes[b - 1][1]) or not set(dessert_dishes[a - s - m - 1][1]).isdisjoint(main_dishes[b - s - 1][1]):\n                total_experiences = 0\n                break\n        elif a > s + m + d and b <= s + m + d:  # One dish is a dessert and the other is a starter or main dish\n            if not set(dessert_dishes[b - s - m - 1][1]).isdisjoint(starter_dishes[a - 1][1]) or not set(dessert_dishes[b - s - m - 1][1]).isdisjoint(main_dishes[a - s - 1][1]):\n                total_experiences = 0\n                break\n\n    if total_experiences > 10**18:\n        return \"too many\"\n    else:\n        return str(total_experiences)"
    },
    {
        "number": 3036,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.readline().split())\n    brand_counts = list(map(int, stdin.readline().split()))\n    starter_dishes = [list(map(int, stdin.readline().split()))[1:] for _ in range(s)]\n    main_dishes = [list(map(int, stdin.readline().split()))[1:] for _ in range(m)]\n    dessert_dishes = [list(map(int, stdin.readline().split()))[1:] for _ in range(d)]\n    incompatible_dishes = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    # Calculate the total number of ingredients\n    total_ingredients = sum(brand_counts)\n\n    # Calculate the total number of dinner experiences\n    total_experiences = 1\n    for i in range(total_ingredients):\n        total_experiences *= brand_counts[i]\n\n    # If the number of experiences exceeds 10^18, return \"too many\"\n    if total_experiences > 10**18:\n        return \"too many\"\n\n    # Return the total number of experiences\n    return total_experiences"
    },
    {
        "number": 3036,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    def count_dinner_experiences(r, s, m, d, n, b, starter_dishes, main_dishes, desserts, incompatible_dishes):\n        total_experiences = 1\n\n        for brands in b:\n            total_experiences *= brands\n\n        for dish in starter_dishes + main_dishes + desserts:\n            total_experiences *= factorial(len(dish))\n\n        for incompatible in incompatible_dishes:\n            total_experiences //= factorial(len(incompatible))\n\n        if total_experiences > 10**18:\n            return \"too many\"\n        else:\n            return str(total_experiences)\n\n    lines = stdin.split(\"\\n\")\n    r, s, m, d, n = list(map(int, lines[0].split()))\n    b = list(map(int, lines[1].split()))\n    starter_dishes = [list(map(int, lines[i + 2].split()))[1:] for i in range(s)]\n    main_dishes = [list(map(int, lines[i + 2 + s].split()))[1:] for i in range(m)]\n    desserts = [list(map(int, lines[i + 2 + s + m].split()))[1:] for i in range(d)]\n    incompatible_dishes = [list(map(int, lines[i + 2 + s + m + d].split())) for i in range(n)]\n\n    return count_dinner_experiences(r, s, m, d, n, b, starter_dishes, main_dishes, desserts, incompatible_dishes)"
    },
    {
        "number": 3036,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_compatible(dish1, dish2):\n        return len(set(dish1) & set(dish2)) == 0\n\n    def count_dinners(starter, main, dessert):\n        return len(starter) * len(main) * len(dessert)\n\n    def get_dish_type(dish_index, starter, main, dessert):\n        if dish_index <= len(starter):\n            return starter[dish_index - 1]\n        elif dish_index <= len(starter) + len(main):\n            return main[dish_index - len(starter) - 1]\n        else:\n            return dessert[dish_index - len(starter) - len(main) - 1]\n\n    def dfs(dish_index, starter, main, dessert, incompatible_pairs, visited, result):\n        if dish_index > len(starter) + len(main) + len(dessert):\n            result[0] += 1\n            return\n\n        if visited[dish_index]:\n            return\n\n        visited[dish_index] = True\n\n        for i in range(dish_index + 1, len(starter) + len(main) + len(dessert) + 1):\n            if i in incompatible_pairs[dish_index]:\n                continue\n\n            if not is_compatible(get_dish_type(dish_index, starter, main, dessert), get_dish_type(i, starter, main, dessert)):\n                continue\n\n            dfs(i, starter, main, dessert, incompatible_pairs, visited, result)\n\n        visited[dish_index] = False\n\n    lines = stdin.split('\\n')\n    r, s, m, d, n = map(int, lines[0].split())\n    brands = list(map(int, lines[1].split()))\n    starter = []\n    main = []\n    dessert = []\n    for i in range(s + m + d):\n        dish = list(map(int, lines[2 + i].split()))[1:]\n        if i < s:\n            starter.append(dish)\n        elif i < s + m:\n            main.append(dish)\n        else:\n            dessert.append(dish)\n\n    incompatible_pairs = [set() for _ in range(s + m + d + 1)]\n    for i in range(n):\n        dish1, dish2 = map(int, lines[s + m + d + 1 + i].split())\n        incompatible_pairs[dish1].add(dish2)\n        incompatible_pairs[dish2].add(dish1)\n\n    starter = [sorted(s) for s in starter]\n    main = [sorted(m) for m in main]\n    dessert = [sorted(d) for d in dessert]\n    incompatible_pairs = [sorted(p) for p in incompatible_pairs]\n\n    result = [0]\n    visited = [False] * (s + m + d + 1)\n    dfs(1, starter, main, dessert, incompatible_pairs, visited, result)\n\n    return \"too many\" if result[0] > 10**18 else str(result[0])"
    },
    {
        "number": 3036,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_dish_count(dish_type):\n        if dish_type == \"s\":\n            return s\n        elif dish_type == \"m\":\n            return m\n        else:\n            return d\n\n    def get_incompatible_dishes(dish_type):\n        if dish_type == \"s\":\n            return incompatible_starter_dishes\n        elif dish_type == \"m\":\n            return incompatible_main_dishes\n        else:\n            return incompatible_dessert_dishes\n\n    def calculate_permutations(dishes, incompatible_dishes):\n        permutations = 1\n        for dish in dishes:\n            permutations *= len(dish)\n\n        for incompatible_dish in incompatible_dishes:\n            if incompatible_dish in dishes:\n                permutations -= 1\n\n        return permutations\n\n    lines = stdin.split(\"\\n\")\n    r, s, m, d, n = map(int, lines[0].split())\n    b = list(map(int, lines[1].split()))\n\n    starter_dishes = []\n    main_dishes = []\n    dessert_dishes = []\n    incompatible_starter_dishes = set()\n    incompatible_main_dishes = set()\n    incompatible_dessert_dishes = set()\n\n    for i in range(2, 2 + s):\n        starter_dishes.append(list(map(int, lines[i].split()[1:])))\n    for i in range(2 + s, 2 + s + m):\n        main_dishes.append(list(map(int, lines[i].split()[1:])))\n    for i in range(2 + s + m, 2 + s + m + d):\n        dessert_dishes.append(list(map(int, lines[i].split()[1:])))\n\n    for i in range(2 + s + m + d, 2 + s + m + d + n):\n        dish1, dish2 = map(int, lines[i].split())\n        if dish1 <= s:\n            incompatible_starter_dishes.add((dish1, dish2))\n        elif dish1 <= s + m:\n            incompatible_main_dishes.add((dish1 - s, dish2 - s))\n        else:\n            incompatible_dessert_dishes.add((dish1 - s - m, dish2 - s - m))\n\n    starter_permutations = calculate_permutations(starter_dishes, incompatible_starter_dishes)\n    main_permutations = calculate_permutations(main_dishes, incompatible_main_dishes)\n    dessert_permutations = calculate_permutations(dessert_dishes, incompatible_dessert_dishes)\n\n    total_permutations = starter_permutations * main_permutations * dessert_permutations\n\n    return str(total_permutations) if total_permutations <= 10**18 else \"too many\""
    },
    {
        "number": 3036,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def parse_line(line, b):\n        line = line.split()\n        num_ingredients = int(line[0])\n        ingredients = [int(x) for x in line[1:]]\n        brands = [b[i - 1] for i in ingredients]\n        return num_ingredients, brands\n\n    def check_compatibility(dish1, dish2, incompatible_dishes):\n        for dish in incompatible_dishes:\n            if (dish1, dish2) in dish or (dish2, dish1) in dish:\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    r, s, m, d, n = [int(x) for x in lines[0].split()]\n    b = [int(x) for x in lines[1].split()]\n    starter_dishes = []\n    main_dishes = []\n    desserts = []\n\n    for i in range(2, 2 + s):\n        num_ingredients, brands = parse_line(lines[i], b)\n        starter_dishes.append((num_ingredients, brands))\n\n    for i in range(2 + s, 2 + s + m):\n        num_ingredients, brands = parse_line(lines[i], b)\n        main_dishes.append((num_ingredients, brands))\n\n    for i in range(2 + s + m, 2 + s + m + d):\n        num_ingredients, brands = parse_line(lines[i], b)\n        desserts.append((num_ingredients, brands))\n\n    incompatible_dishes = []\n    for i in range(2 + s + m + d, 2 + s + m + d + n):\n        dish1, dish2 = [int(x) for x in lines[i].split()]\n        incompatible_dishes.append((dish1, dish2))\n\n    total_experiences = 1\n    for i in range(r):\n        total_experiences *= b[i]\n        total_experiences %= 10**18\n\n    for starter in starter_dishes:\n        num_ingredients, brands = starter\n        for i in range(num_ingredients):\n            total_experiences //= lcm(*brands)\n            total_experiences *= brands[i]\n            total_experiences %= 10**18\n\n    for main in main_dishes:\n        num_ingredients, brands = main\n        for i in range(num_ingredients):\n            total_experiences //= lcm(*brands)\n            total_experiences *= brands[i]\n            total_experiences %= 10**18\n\n    for dessert in desserts:\n        num_ingredients, brands = dessert\n        for i in range(num_ingredients):\n            total_experiences //= lcm(*brands)\n            total_experiences *= brands[i]\n            total_experiences %= 10**18\n\n    for i in range(1, s + 1):\n        for j in range(1 + s, s + m + 1):\n            if not check_compatibility(i, j, incompatible_dishes):\n                continue\n            for k in range(1 + s + m, s + m + d + 1):\n                if not check_compatibility(i, k, incompatible_dishes):\n                    continue\n                if not check_compatibility(j, k, incompatible_dishes):\n                    continue\n                total_experiences //= lcm(*starter_dishes[i - 1][1], *main_dishes[j - s - 1][1], *desserts[k - s - m"
    },
    {
        "number": 3036,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.readline().split())\n    brands = list(map(int, stdin.readline().split()))\n    all_dishes = [list(map(int, stdin.readline().split()))[1:] for _ in range(s + m + d)]\n    incompatible_dishes = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    # Check if the number of experiences is too large\n    total_brands = 1\n    for b in brands:\n        total_brands *= b\n    if total_brands ** (s + m + d) > 10**18:\n        return \"too many\"\n\n    # Remove incompatible dishes\n    for d1, d2 in incompatible_dishes:\n        if d1 <= s:\n            i1, i2 = 0, 1\n        elif d1 <= s + m:\n            i1, i2 = 1, 2\n        else:\n            i1, i2 = 2, 3\n\n        if d2 <= s:\n            j1, j2 = 0, 1\n        elif d2 <= s + m:\n            j1, j2 = 1, 2\n        else:\n            j1, j2 = 2, 3\n\n        for k in range(len(all_dishes[d1 - 1])):\n            if all_dishes[d1 - 1][k] in all_dishes[d2 - 1]:\n                brands[all_dishes[d1 - 1][k] - 1] -= 1\n                brands[all_dishes[d2 - 1][k] - 1] -= 1\n                all_dishes[d1 - 1][k] = all_dishes[d2 - 1][k] = 0\n\n        all_dishes[d1 - 1], all_dishes[d2 - 1] = all_dishes[d1 - 1][i1:i2] + all_dishes[d2 - 1][j1:j2], all_dishes[d1 - 1][j1:j2] + all_dishes[d2 - 1][i1:i2]\n\n    # Count experiences\n    total_experiences = 1\n    for b in brands:\n        total_experiences *= b\n\n    return str(total_experiences)"
    },
    {
        "number": 3037,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def execute_commands(commands, board_size):\n        row, col = 0, 0\n        for command in commands:\n            direction, distance = command.split()\n            distance = int(distance)\n            if direction == \"up\":\n                for _ in range(distance):\n                    row -= 1\n                    if row < 0:\n                        return -1\n            elif direction == \"down\":\n                for _ in range(distance):\n                    row += 1\n                    if row >= board_size[0]:\n                        return -1\n            elif direction == \"left\":\n                for _ in range(distance):\n                    col -= 1\n                    if col < 0:\n                        return -1\n            elif direction == \"right\":\n                for _ in range(distance):\n                    col += 1\n                    if col >= board_size[1]:\n                        return -1\n        return row, col\n\n    def find_min_max(board, commands, board_size):\n        min_time, max_time = float(\"inf\"), 0\n        for i in range(len(commands)):\n            new_commands = commands[:i] + commands[i + 1:]\n            result = execute_commands(new_commands, board_size)\n            if result == -1:\n                continue\n            row, col = result\n            if board[row][col] == \"#\":\n                min_time = min(min_time, i)\n                max_time = max(max_time, i)\n        return min_time, max_time\n\n    stdin_list = stdin.split(\"\\n\")\n    h, w, n = map(int, stdin_list[0].split())\n    board = [list(stdin_list[i + 1]) for i in range(h)]\n    commands = stdin_list[h + 1:h + 1 + n]\n    min_time, max_time = find_min_max(board, commands, (h, w))\n    return f\"{min_time} {max_time}\" if min_time != float(\"inf\") else \"-1 -1\""
    },
    {
        "number": 3037,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n, pattern, commands = parse_input(stdin)\n    marker_positions = simulate_turtle(h, w, pattern, commands)\n    min_dry_time, max_dry_time = find_dry_timesteps(marker_positions)\n    return f\"{min_dry_time} {max_dry_time}\"\n\ndef"
    },
    {
        "number": 3037,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_lines = stdin.split('\\n')\n    h, w, n = map(int, input_lines[0].split())\n    pattern = [list(input_lines[i + 1]) for i in range(h)]\n    commands = [(command.split()[0], int(command.split()[1])) for command in input_lines[h + 1:h + 1 + n]]\n\n    # Initialize variables\n    board = [[0] * w for _ in range(h)]\n    x, y = 0, 0\n    min_timestep = float('inf')\n    max_timestep = -1\n\n    # Execute commands\n    for command in commands:\n        dx, dy = 0, 0\n        if command[0] == 'up':\n            dy = -1\n        elif command[0] == 'down':\n            dy = 1\n        elif command[0] == 'left':\n            dx = -1\n        elif command[0] == 'right':\n            dx = 1\n\n        for i in range(command[1]):\n            x += dx\n            y += dy\n            if 0 <= x < w and 0 <= y < h and board[y][x] == 0:\n                board[y][x] = 1\n                min_timestep = min(min_timestep, i + 1)\n                max_timestep = max(max_timestep, i + 1)\n            elif i < command[1] - 1:\n                return \"-1 -1\"\n\n    return f\"{min_timestep} {max_timestep}\""
    },
    {
        "number": 3037,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.readline().split())\n    board = [list(stdin.readline().strip()) for _ in range(h)]\n    commands = [stdin.readline().strip().split() for _ in range(n)]\n\n    def move(x, y, direction, distance):\n        if direction == 'up':\n            return x - distance, y\n        elif direction == 'down':\n            return x + distance, y\n        elif direction == 'left':\n            return x, y - distance\n        elif direction == 'right':\n            return x, y + distance\n\n    def draw(board, marker_x, marker_y, timestep):\n        if 0 <= marker_x < h and 0 <= marker_y < w:\n            if board[marker_x][marker_y] == '.':\n                board[marker_x][marker_y] = str(timestep)\n            else:\n                board[marker_x][marker_y] = '-'\n        return board\n\n    marker_x, marker_y = 0, 0\n    timestep = 1\n    min_timestep, max_timestep = float('inf'), -1\n    for command in commands:\n        direction, distance = command\n        distance = int(distance)\n        marker_x, marker_y = move(marker_x, marker_y, direction, distance)\n        if not (0 <= marker_x < h and 0 <= marker_y < w):\n            break\n        board = draw(board, marker_x, marker_y, timestep)\n        timestep += 1\n        min_timestep = min(min_timestep, timestep)\n        max_timestep = max(max_timestep, timestep)\n\n    if min_timestep == float('inf') and max_timestep == -1:\n        return \"-1 -1\\n\"\n    else:\n        return f\"{min_timestep} {max_timestep}\\n\""
    },
    {
        "number": 3037,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.readline().split())\n    target = [list(stdin.readline().strip()) for _ in range(h)]\n\n    def is_valid(x, y, commands):\n        dx, dy = [0, 0, -1, 1][commands[0]], [0, 1, 0, -1][commands[0]]\n        for i in range(1, len(commands)):\n            if commands[i] == 'up':\n                dx, dy = 0, -1\n            elif commands[i] == 'down':\n                dx, dy = 0, 1\n            elif commands[i] == 'left':\n                dx, dy = -1, 0\n            elif commands[i] == 'right':\n                dx, dy = 1, 0\n            x += dx * commands[i]\n            y += dy * commands[i]\n            if not (0 <= x < h and 0 <= y < w and target[x][y] == '.'):\n                return False\n        return True\n\n    def find_limits(x, y, commands, current_timestep, min_timestep, max_timestep):\n        if current_timestep > max_timestep:\n            max_timestep = current_timestep\n        if current_timestep < min_timestep:\n            min_timestep = current_timestep\n        if current_timestep == n:\n            return min_timestep, max_timestep\n\n        dx, dy = [0, 0, -1, 1][commands[0]], [0, 1, 0, -1][commands[0]]\n        for i in range(1, len(commands)):\n            if commands[i] == 'up':\n                dx, dy = 0, -1\n            elif commands[i] == 'down':\n                dx, dy = 0, 1\n            elif commands[i] == 'left':\n                dx, dy = -1, 0\n            elif commands[i] == 'right':\n                dx, dy = 1, 0\n            x += dx * commands[i]\n            y += dy * commands[i]\n            current_timestep += 1\n            if not (0 <= x < h and 0 <= y < w and target[x][y] == '.'):\n                return min_timestep, max_timestep\n\n        min_timestep, max_timestep = find_limits(x, y, commands, current_timestep, min_timestep, max_timestep)\n        return min_timestep, max_timestep\n\n    commands = [stdin.readline().strip().split() for _ in range(n)]\n    min_timestep, max_timestep = find_limits(0, 0, commands, 0, float('inf'), float('-inf'))\n    if min_timestep == float('inf'):\n        return \"-1 -1\\n\"\n    else:\n        return f\"{min_timestep} {max_timestep}\\n\""
    },
    {
        "number": 3037,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[0:3])\n    target_board = [list(stdin.split()[3 + i]) for i in range(h)]\n    commands = stdin.split(\"\\n\")[3 + h:3 + h + n]\n\n    current_board = [['.' for _ in range(w)] for _ in range(h)]\n    x, y = 0, 0\n    dry_time = -1\n\n    for command in commands:\n        direction, distance = command.split()\n        distance = int(distance)\n\n        if direction == \"up\":\n            for i in range(distance):\n                if y - i - 1 < 0:\n                    break\n                if current_board[y - i - 1][x] == '#':\n                    dry_time = max(dry_time, i)\n                    break\n                current_board[y - i - 1][x] = '#'\n            y = max(0, y - i)\n\n        elif direction == \"down\":\n            for i in range(distance):\n                if y + i + 1 >= h:\n                    break\n                if current_board[y + i + 1][x] == '#':\n                    dry_time = max(dry_time, i)\n                    break\n                current_board[y + i + 1][x] = '#'\n            y = min(h - 1, y + i)\n\n        elif direction == \"left\":\n            for i in range(distance):\n                if x - i - 1 < 0:\n                    break\n                if current_board[y][x - i - 1] == '#':\n                    dry_time = max(dry_time, i)\n                    break\n                current_board[y][x - i - 1] = '#'\n            x = max(0, x - i)\n\n        elif direction == \"right\":\n            for i in range(distance):\n                if x + i + 1 >= w:\n                    break\n                if current_board[y][x + i + 1] == '#':\n                    dry_time = max(dry_time, i)\n                    break\n                current_board[y][x + i + 1] = '#'\n            x = min(w - 1, x + i)\n\n    if dry_time == -1:\n        return \"-1 -1\\n\"\n\n    return f\"{dry_time} {dry_time}\\n\""
    },
    {
        "number": 3037,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = list(map(int, stdin.split()[:3]))\n    pattern = stdin.split(\"\\n\")[3:h+3]\n    commands = stdin.split(\"\\n\")[h+3:]\n\n    # Convert pattern into initial marker position\n    marker_position = [(i, j) for i in range(h) for j in range(w) if pattern[i][j] == '#']\n\n    min_time = max_time = 0\n\n    # Execute commands\n    for command in commands:\n        direction, distance = command.split()\n        distance = int(distance)\n\n        if direction == \"up\":\n            marker_position = [(i-distance, j) for i, j in marker_position if i-distance >= 0]\n        elif direction == \"down\":\n            marker_position = [(i+distance, j) for i, j in marker_position if i+distance < h]\n        elif direction == \"left\":\n            marker_position = [(i, j-distance) for i, j in marker_position if j-distance >= 0]\n        else:\n            marker_position = [(i, j+distance) for i, j in marker_position if j+distance < w]\n\n        # If there is no marker, it means it has dried out\n        if not marker_position:\n            return \"-1 -1\"\n\n        # Update min and max time\n        min_time = max(min_time, distance)\n        max_time = max(max_time, distance + len(marker_position) - 1)\n\n    return f\"{min_time} {max_time}\" "
    },
    {
        "number": 3037,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.readline().split())\n    turtle_board = []\n    for i in range(h):\n        turtle_board.append(list(stdin.readline().strip()))\n\n    commands = []\n    for i in range(n):\n        commands.append(stdin.readline().strip().split())\n\n    up_moves = []\n    down_moves = []\n    left_moves = []\n    right_moves = []\n\n    for command in commands:\n        if command[0] == \"up\":\n            up_moves.append(int(command[1]))\n        elif command[0] == \"down\":\n            down_moves.append(int(command[1]))\n        elif command[0] == \"left\":\n            left_moves.append(int(command[1]))\n        elif command[0] == \"right\":\n            right_moves.append(int(command[1]))\n\n    min_time = float(\"inf\")\n    max_time = float(\"-inf\")\n\n    for i in range(h):\n        for j in range(w):\n            if turtle_board[i][j] == \"#\":\n                time = 0\n                for up_move in up_moves:\n                    if i - up_move >= 0:\n                        time += up_move\n                    else:\n                        time += i\n                for down_move in down_moves:\n                    if i + down_move < h:\n                        time += down_move\n                    else:\n                        time += h - i - 1\n                for left_move in left_moves:\n                    if j - left_move >= 0:\n                        time += left_move\n                    else:\n                        time += j\n                for right_move in right_moves:\n                    if j + right_move < w:\n                        time += right_move\n                    else:\n                        time += w - j - 1\n                min_time = min(min_time, time)\n                max_time = max(max_time, time)\n\n    if min_time == float(\"inf\") and max_time == float(\"-inf\"):\n        return \"-1 -1\\n\"\n    else:\n        return f\"{min_time} {max_time}\\n\""
    },
    {
        "number": 3037,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = list(map(int, stdin.readline().split()))\n    turtle_plan = []\n    for _ in range(n):\n        turtle_plan.append(stdin.readline().strip().split())\n\n    drawing_plan = []\n    for _ in range(h):\n        drawing_plan.append(list(stdin.readline().strip()))\n\n    def move(position, direction, distance):\n        x, y = position\n        if direction == \"up\":\n            return (x, y - distance)\n        elif direction == \"down\":\n            return (x, y + distance)\n        elif direction == \"left\":\n            return (x - distance, y)\n        elif direction == \"right\":\n            return (x + distance, y)\n\n    def draw(drawing_plan, turtle_plan):\n        timestep = 0\n        position = (0, 0)\n        marker_dry_timestep = -1\n        for command in turtle_plan:\n            direction, distance = command\n            distance = int(distance)\n            if direction == \"up\" and position[1] - distance < 0:\n                distance = position[1]\n            elif direction == \"down\" and position[1] + distance >= h:\n                distance = h - position[1] - 1\n            elif direction == \"left\" and position[0] - distance < 0:\n                distance = position[0]\n            elif direction == \"right\" and position[0] + distance >= w:\n                distance = w - position[0] - 1\n\n            if distance == 0:\n                return -1, -1\n\n            new_position = move(position, direction, distance)\n            for i in range(position[1] + 1, new_position[1]):\n                if drawing_plan[i][position[0]] == \"#\":\n                    marker_dry_timestep = timestep + distance - 1\n                    break\n            position = new_position\n            timestep += distance\n\n        if position != (w - 1, h - 1):\n            return -1, -1\n\n        return 0, marker_dry_timestep\n\n    min_timestep, max_timestep = draw(drawing_plan, turtle_plan)\n    return f\"{min_timestep} {max_timestep}\\n\" "
    },
    {
        "number": 3037,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.readline().split())\n    board = [list(stdin.readline().strip()) for _ in range(h)]\n    commands = [stdin.readline().strip().split() for _ in range(n)]\n\n    dry_out_min = -1\n    dry_out_max = -1\n\n    marker_x = 0\n    marker_y = h - 1\n    for i, (direction, distance) in enumerate(commands):\n        distance = int(distance)\n        if direction == \"up\":\n            for _ in range(distance):\n                if marker_y > 0:\n                    marker_y -= 1\n                else:\n                    break\n        elif direction == \"down\":\n            for _ in range(distance):\n                if marker_y < h - 1:\n                    marker_y += 1\n                else:\n                    break\n        elif direction == \"left\":\n            for _ in range(distance):\n                if marker_x > 0:\n                    marker_x -= 1\n                else:\n                    break\n        elif direction == \"right\":\n            for _ in range(distance):\n                if marker_x < w - 1:\n                    marker_x += 1\n                else:\n                    break\n\n        if i == 0 or i == n - 1 or board[marker_y][marker_x] == \"#\":\n            continue\n\n        board[marker_y][marker_x] = \"#\"\n\n        if dry_out_min == -1:\n            dry_out_min = i\n\n        if dry_out_max == -1:\n            dry_out_max = i\n        else:\n            dry_out_max = i\n\n    return f\"{dry_out_min} {dry_out_max}\""
    },
    {
        "number": 3038,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_pack(B, companies, companies_dict, index):\n        min_pack = float('inf')\n        for i in range(1, len(companies[index]) // 2 + 1):\n            if companies[index][2 * i - 1] >= B and companies[index][2 * i - 1] < min_pack:\n                min_pack = companies[index][2 * i - 1]\n            elif companies[index][2 * i - 1] < B and companies[index][2 * i - 1] * (i + 1) >= B:\n                for j in range(1, i + 1):\n                    for key, value in companies_dict.items():\n                        if value == companies[index][2 * j - 1]:\n                            for m in range(1, len(companies[key]) // 2 + 1):\n                                if companies[key][2 * m - 1] >= B and companies[key][2 * m - 1] < min_pack:\n                                    min_pack = companies[key][2 * m - 1]\n                                elif companies[key][2 * m - 1] < B and companies[key][2 * m - 1] * (m + 1) >= B:\n                                    if companies[key][2 * m - 1] * (i + 1) >= B:\n                                        return False\n                                    elif companies[key][2 * m - 1] * (i + 1) < B:\n                                        for n in range(1, m + 1):\n                                            for p in range(1, len(companies[key]) // 2 + 1):\n                                                if companies[key][2 * p - 1] >= B and companies[key][2 * p - 1] < min_pack:\n                                                    min_pack = companies[key][2 * p - 1]\n                                                elif companies[key][2 * p - 1] < B and companies[key][2 * p - 1] * (p + 1) >= B:\n                                                    if companies[key][2 * p - 1] * (i + 1) >= B:\n                                                        return False\n                                                    elif companies[key][2 * p - 1] * (i + 1) < B:\n                                                        for o in range(1, p + 1):\n                                                            if companies[key][2 * o - 1] * (i + 1) >= B:\n                                                                return False\n                                                            elif companies[key][2 * o - 1] * (i + 1) < B:\n                                                                for q in range(1, len(companies[key]) // 2 + 1):\n                                                                    if companies[key][2 * q - 1] >= B and companies[key][2 * q - 1] < min_pack:\n                                                        min_pack = companies[key][2 * q - 1]\n                                                    elif companies[key][2 * q - 1] < B and companies[key][2 * q - 1] * (q + 1) >= B:\n                                                        if companies[key][2 * q - 1] * (i + 1) >= B:\n                                                            return False\n                                                        elif companies[key][2 * q - 1] * (i + 1) < B:\n                                                            for r in range(1, q + 1):\n                                                                if companies[key][2 * r - 1] * (i + 1) >= B:\n                                                                    return False\n                                                                elif companies[key][2 * r - 1] * (i + 1) < B:\n                                                                    for s in range(1, len(companies[key]) // 2 + 1):\n                                                                        if companies[key][2 * s - 1] >= B and companies[key][2 * s - 1] < min_pack:\n                                                            min_pack = companies[key][2 * s - 1]\n                                                        elif companies[key][2 * s - 1] < B and companies[key][2 * s - 1] * (s + 1"
    },
    {
        "number": 3038,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_pack(bolts_needed, packs):\n        min_pack = None\n        for pack_size, real_size in packs:\n            if bolts_needed <= real_size:\n                if min_pack is None or pack_size < min_pack:\n                    min_pack = pack_size\n        return min_pack\n\n    def process_company(bolts_needed, company_data):\n        num_types, *sizes = map(int, company_data.split())\n        real_sizes = [size * i for i, size in enumerate(sizes, start=1)]\n        packs = list(zip(sizes, real_sizes))\n        return get_pack(bolts_needed, packs)\n\n    def process_packet(bolts_needed, num_companies, company_data):\n        min_pack = None\n        for i in range(num_companies):\n            pack_size = process_company(bolts_needed, company_data[i])\n            if pack_size is not None and (min_pack is None or pack_size < min_pack):\n                min_pack = pack_size\n        return min_pack\n\n    stdin_list = stdin.strip().split('\\n')\n    bolts_needed = int(stdin_list[0])\n    num_companies = int(stdin_list[1])\n    company_data = stdin_list[2:]\n\n    min_pack = process_packet(bolts_needed, num_companies, company_data)\n\n    if min_pack is None:\n        return 'impossible'\n    else:\n        return str(min_pack)"
    },
    {
        "number": 3038,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_packet_size(B, k, companies):\n        packets = [sorted(packet_sizes) for packet_sizes in companies]\n        dp = [float('inf')] * (B + 1)\n        dp[0] = 0\n\n        for i in range(1, B + 1):\n            for j in range(k):\n                for packet_size in packets[j]:\n                    if i >= packet_size and dp[i - packet_size] != float('inf'):\n                        dp[i] = min(dp[i], packet_size + dp[i - packet_size])\n\n        return dp[-1] if dp[-1] != float('inf') else 'impossible'\n\n    input_data = [line.strip().split(' ') for line in stdin.split('\\n')]\n    B = int(input_data[0][0])\n    k = int(input_data[1][0])\n    companies = [list(map(int, line))[1:] for line in input_data[2:]]\n\n    return find_min_packet_size(B, k, companies)"
    },
    {
        "number": 3038,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_packet(B, companies):\n        def can_create_packet(B, company):\n            total = 0\n            for size in company[1:]:\n                if total + size >= B:\n                    return True\n                total += size\n            return False\n\n        def min_packet(B, company):\n            total = 0\n            min_amount = float('inf')\n            for size in company[1:]:\n                if total + size >= B:\n                    min_amount = min(min_amount, size)\n                total += size\n            return min_amount\n\n        for i in range(len(companies)):\n            if can_create_packet(B, companies[i]):\n                return min_packet(B, companies[i])\n        return \"impossible\"\n\n    lines = stdin.strip().split('\\n')\n    B = int(lines[0])\n    k = int(lines[1])\n    companies = []\n    for i in range(2, 2 + k):\n        companies.append(list(map(int, lines[i].strip().split())))\n\n    return str(find_packet(B, companies))"
    },
    {
        "number": 3038,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_data = list(map(str, stdin.split('\\n')))\n    b = int(input_data[0])\n    k = int(input_data[1])\n    companies = []\n    for i in range(2, 2 + k):\n        line = input_data[i].split()\n        l_i = int(line[0])\n        packages = []\n        for j in range(1, 1 + l_i):\n            packages.append(int(line[j]))\n        companies.append(packages)\n\n    # Calculate the smallest package size\n    min_size = float('inf')\n    for i in range(len(companies)):\n        for j in range(len(companies[i])):\n            if companies[i][j] >= b:\n                min_size = min(min_size, companies[i][j])\n                break\n            else:\n                continue\n        if min_size == float('inf'):\n            continue\n        else:\n            break\n\n    return str(min_size) if min_size != float('inf') else \"impossible\""
    },
    {
        "number": 3038,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(bolts_needed, packages):\n        for i in range(len(packages)):\n            if bolts_needed <= packages[i]:\n                return i + 1\n        return -1\n\n    def find_min_packet_size(bolts_needed, companies):\n        min_packet_size = float('inf')\n        for i in range(len(companies)):\n            packages = companies[i]\n            pos = is_possible(bolts_needed, packages)\n            if pos != -1:\n                min_packet_size = min(min_packet_size, packages[pos - 1])\n        return min_packet_size if min_packet_size != float('inf') else 'impossible'\n\n    lines = stdin.split('\\n')\n    bolts_needed = int(lines[0])\n    num_companies = int(lines[1])\n    companies = []\n    for i in range(2, 2 + num_companies):\n        company = list(map(int, lines[i].split()))\n        packages = [0] * (company[0])\n        for j in range(1, len(company), 2):\n            packages[company[j] - 1] = company[j + 1]\n        companies.append(packages)\n\n    return find_min_packet_size(bolts_needed, companies)"
    },
    {
        "number": 3038,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_packet_size(target_size, sizes, current_index, packet_sizes, current_size):\n        if current_index == len(sizes):\n            if current_size >= target_size:\n                return packet_sizes[-1]\n            else:\n                return \"impossible\"\n\n        if current_size >= target_size:\n            return packet_sizes[-1]\n\n        for i in range(len(sizes[current_index])):\n            new_packet_size = sizes[current_index][i]\n            if new_packet_size not in packet_sizes:\n                packet_sizes.append(new_packet_size)\n            new_size = current_size + new_packet_size\n            result = find_packet_size(target_size, sizes, current_index + 1, packet_sizes, new_size)\n            if result != \"impossible\":\n                return result\n\n        return \"impossible\"\n\n    input_data = list(map(int, stdin.split()))\n    bolts_needed = input_data[0]\n    num_companies = input_data[1]\n    input_data = input_data[2:]\n    packet_sizes = []\n\n    for i in range(num_companies):\n        company_data = input_data[:input_data[0] + 1]\n        input_data = input_data[input_data[0] + 1:]\n        packet_sizes.append(company_data[1:])\n\n    result = find_packet_size(bolts_needed, packet_sizes, 0, [], 0)\n\n    return str(result)"
    },
    {
        "number": 3038,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def can_buy(b, k, sizes):\n        for i in range(1, b + 1):\n            for c in sizes:\n                if i in c:\n                    return True\n        return False\n\n    def min_packet(b, k, sizes):\n        min_packet_size = float('inf')\n        for i in range(1, b + 1):\n            for c in sizes:\n                if i in c:\n                    min_packet_size = min(min_packet_size, min(c))\n        return min_packet_size if min_packet_size != float('inf') else 'impossible'\n\n    lines = stdin.split('\\n')\n    b = int(lines[0])\n    k = int(lines[1])\n    sizes = []\n    for i in range(2, 2 + k):\n        line = lines[i].split()\n        l_i = int(line[0])\n        sizes_i = [int(x) for x in line[1:]]\n        sizes.append(sizes_i)\n\n    if can_buy(b, k, sizes):\n        return str(min_packet(b, k, sizes))\n    else:\n        return 'impossible'"
    },
    {
        "number": 3038,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    input_lines = stdin.split(\"\\n\")\n    B = int(input_lines[0])\n    num_companies = int(input_lines[1])\n    companies = []\n    for i in range(2, 2 + num_companies):\n        line = input_lines[i].split()\n        l_i = int(line[0])\n        package_sizes = [int(size) for size in line[1:]]\n        companies.append((l_i, package_sizes))\n\n    # Calculate the minimum number of bolts required\n    min_bolts = B\n    for i in range(1, len(companies) + 1):\n        if i == len(companies):\n            break\n\n        # Calculate the number of bolts required for the next company\n        num_bolts = min_bolts + 1\n        for j in range(num_bolts):\n            if j not in companies[i - 1][1]:\n                continue\n            break\n        else:\n            num_bolts = min_bolts + 1\n            for j in range(num_bolts):\n                if j not in companies[i - 1][1]:\n                    continue\n                break\n            else:\n                return \"impossible\"\n\n        min_bolts = num_bolts\n\n    return min_bolts"
    },
    {
        "number": 3038,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_combinations(bolts_needed, sizes, target):\n        min_packs = float('inf')\n        for size in sizes:\n            if size >= bolts_needed:\n                return 1\n            if size < target:\n                continue\n            packs = get_combinations(bolts_needed - size, sizes, size) + 1\n            if packs < min_packs:\n                min_packs = packs\n        return min_packs\n\n    def get_min_packet_size(bolts_needed, companies):\n        min_packet_size = float('inf')\n        for company in companies:\n            l_i, *sizes = company\n            combinations = get_combinations(bolts_needed, sizes, 0)\n            if combinations == float('inf'):\n                continue\n            packet_size = sizes[combinations - 1]\n            if packet_size < min_packet_size:\n                min_packet_size = packet_size\n        return min_packet_size if min_packet_size != float('inf') else 'impossible'\n\n    lines = stdin.split('\\n')\n    bolts_needed = int(lines[0])\n    num_companies = int(lines[1])\n    companies = [list(map(int, line.split()))[1:] for line in lines[2:2 + num_companies]]\n\n    return str(get_min_packet_size(bolts_needed, companies))"
    },
    {
        "number": 3039,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(matrix: list) -> bool:\n        for row in matrix:\n            if '#' not in row:\n                return False\n        for col in range(6):\n            if '#' not in [matrix[i][col] for i in range(6)]:\n                return False\n        return True\n\n    def is_connected(matrix: list) -> bool:\n        visited = set()\n        queue = [(0, 0)]\n        while queue:\n            row, col = queue.pop(0)\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n            if matrix[row][col] == '#':\n                if row > 0 and (row - 1, col) not in visited:\n                    queue.append((row - 1, col))\n                if row < 5 and (row + 1, col) not in visited:\n                    queue.append((row + 1, col))\n                if col > 0 and (row, col - 1) not in visited:\n                    queue.append((row, col - 1))\n                if col < 5 and (row, col + 1) not in visited:\n                    queue.append((row, col + 1))\n        return len(visited) == 36\n\n    matrix = [list(input()) for _ in range(6)]\n    if is_valid(matrix) and is_connected(matrix):\n        return \"can fold\"\n    else:\n        return \"cannot fold\" "
    },
    {
        "number": 3039,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [list(line.strip()) for line in stdin.split('\\n')]\n    if not is_connected(matrix) or has_2x2_square(matrix):\n        return \"cannot fold\"\n    else:\n        return \"can fold\"\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_matrix = [list(line.rstrip()) for line in stdin.split('\\n')]\n    can_fold = True\n\n    for i in range(6):\n        for j in range(6):\n            if input_matrix[i][j] == '#':\n                if i < 2:\n                    if input_matrix[i + 2][j] != '#' or input_matrix[i + 4][j] != '#':\n                        can_fold = False\n                        break\n                elif i >= 4:\n                    if input_matrix[i - 2][j] != '#' or input_matrix[i - 4][j] != '#':\n                        can_fold = False\n                        break\n                else:\n                    if input_matrix[i - 2][j] != '#' or input_matrix[i + 2][j] != '#':\n                        can_fold = False\n                        break\n\n            if input_matrix[i][j] == '#':\n                if j < 2:\n                    if input_matrix[i][j + 2] != '#' or input_matrix[i][j + 4] != '#':\n                        can_fold = False\n                        break\n                elif j >= 4:\n                    if input_matrix[i][j - 2] != '#' or input_matrix[i][j - 4] != '#':\n                        can_fold = False\n                        break\n                else:\n                    if input_matrix[i][j - 2] != '#' or input_matrix[i][j + 2] != '#':\n                        can_fold = False\n                        break\n\n    if can_fold:\n        return 'can fold'\n    else:\n        return 'cannot fold'"
    },
    {
        "number": 3039,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    unit_squares = []\n    for i in range(6):\n        for j in range(6):\n            if lines[i][j] == \"#\":\n                unit_squares.append((i, j))\n    \n    for i in range(6):\n        for j in range(6):\n            if lines[i][j] == \"#\":\n                if (i, j) not in unit_squares:\n                    return \"cannot fold\"\n    \n    for i in range(6):\n        for j in range(6):\n            if lines[i][j] == \"#\":\n                if (i, 5 - j) not in unit_squares:\n                    return \"cannot fold\"\n    \n    return \"can fold\""
    },
    {
        "number": 3039,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def check_connected(arr):\n        stack = [(0, 0)]\n        visited = [[False] * 6 for _ in range(6)]\n        while stack:\n            i, j = stack.pop()\n            if not visited[i][j]:\n                visited[i][j] = True\n                if arr[i][j] == \"#\" and not (1 < i < 4 and 1 < j < 4):\n                    return False\n                if i > 0 and not visited[i - 1][j]:\n                    stack.append((i - 1, j))\n                if i < 5 and not visited[i + 1][j]:\n                    stack.append((i + 1, j))\n                if j > 0 and not visited[i][j - 1]:\n                    stack.append((i, j - 1))\n                if j < 5 and not visited[i][j + 1]:\n                    stack.append((i, j + 1))\n        return True\n\n    def check_2x2(arr):\n        for i in range(4):\n            for j in range(4):\n                if arr[i][j] == \"#\" and arr[i + 1][j] == \"#\" and arr[i][j + 1] == \"#\" and arr[i + 1][j + 1] == \"#\":\n                    return False\n        return True\n\n    arr = [list(line) for line in stdin.splitlines()]\n    if check_connected(arr) and check_2x2(arr):\n        return \"can fold\"\n    else:\n        return \"cannot fold\""
    },
    {
        "number": 3039,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    unit_squares = []\n    for line in stdin.split('\\n'):\n        for i, char in enumerate(line):\n            if char == '#':\n                unit_squares.append((i // 2, i % 2, -len(unit_squares)))\n\n    def is_valid(x, y, z, dx, dy, dz):\n        for i in range(6):\n            if (x + dx * i, y + dy * i, z + dz * i) not in unit_squares:\n                return False\n        return True\n\n    for dx, dy, dz in [(1, 0, 0), (0, 1, 0), (0, 0, 1), (-1, 0, 0), (0, -1, 0), (0, 0, -1)]:\n        if is_valid(*unit_squares[0], dx, dy, dz):\n            return 'can fold'\n    return 'cannot fold'"
    },
    {
        "number": 3039,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    grid = [list(line) for line in stdin.splitlines()]\n    \n    def dfs(x, y):\n        if 0 <= x < 6 and 0 <= y < 6 and grid[x][y] == '#':\n            grid[x][y] = '.'\n            dfs(x - 1, y)\n            dfs(x + 1, y)\n            dfs(x, y - 1)\n            dfs(x, y + 1)\n    \n    for i in range(6):\n        for j in range(6):\n            if grid[i][j] == '#':\n                dfs(i, j)\n                break\n        else:\n            continue\n        break\n    \n    for row in grid:\n        if '#' in row:\n            return \"cannot fold\"\n    return \"can fold\""
    },
    {
        "number": 3039,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_arr = stdin.split('\\n')\n    cross_count = 0\n    for i in range(6):\n        for j in range(6):\n            if input_arr[i][j] == '#':\n                if (i in [0, 5] or j in [0, 5]) and input_arr[i][j+1] == '#' and input_arr[i][j-1] == '#':\n                    cross_count += 1\n                elif (i in [1, 4] or j in [1, 4]) and input_arr[i+1][j] == '#' and input_arr[i-1][j] == '#':\n                    cross_count += 1\n                else:\n                    return 'cannot fold'\n    return 'can fold' if cross_count == 6 else 'cannot fold'"
    },
    {
        "number": 3039,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split(\"\\n\")\n    if len(lines) != 6:\n        raise ValueError(\"Input must consist of exactly 6 lines.\")\n    \n    unit_squares = set()\n    for y, line in enumerate(lines):\n        if len(line) != 6:\n            raise ValueError(\"Each line must consist of exactly 6 characters.\")\n        for x, char in enumerate(line):\n            if char == \"#\":\n                unit_squares.add((x, y))\n    \n    if len(unit_squares) != 6:\n        return \"cannot fold\"\n    \n    def is_valid_cube(squares: set) -> bool:\n        if not squares:\n            return False\n        \n        def is_valid_cube_helper(squares: set, x: int, y: int, z: int) -> bool:\n            if not squares:\n                return True\n            \n            new_squares = set()\n            for square in squares:\n                dx, dy, dz = square\n                if (x + dx, y + dy, z + dz) not in squares:\n                    new_squares.add((dx, dy, dz))\n            \n            if not new_squares:\n                return True\n            \n            for dx in (-1, 0, 1):\n                for dy in (-1, 0, 1):\n                    for dz in (-1, 0, 1):\n                        if (dx, dy, dz) == (0, 0, 0):\n                            continue\n                        if is_valid_cube_helper(new_squares, x + dx, y + dy, z + dz):\n                            return True\n            \n            return False\n        \n        for x in (-1, 0, 1):\n            for y in (-1, 0, 1):\n                for z in (-1, 0, 1):\n                    if is_valid_cube_helper(squares, x, y, z):\n                        return True\n        \n        return False\n    \n    return \"can fold\" if is_valid_cube(unit_squares) else \"cannot fold\" "
    },
    {
        "number": 3039,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    input_matrix = []\n    for line in stdin.split('\\n'):\n        input_matrix.append(list(line))\n    \n    # Check for the presence of a 2x2 square\n    for i in range(len(input_matrix) - 1):\n        for j in range(len(input_matrix[i]) - 1):\n            if input_matrix[i][j] == '#' and input_matrix[i+1][j] == '#' and input_matrix[i][j+1] == '#' and input_matrix[i+1][j+1] == '#':\n                return 'cannot fold'\n    \n    # Check if the initial shape is connected\n    visited = [[False for _ in range(len(input_matrix[0]))] for _ in range(len(input_matrix))]\n    stack = []\n    for i in range(len(input_matrix)):\n        for j in range(len(input_matrix[i])):\n            if input_matrix[i][j] == '#' and not visited[i][j]:\n                stack.append((i, j))\n                while stack:\n                    x, y = stack.pop()\n                    if not visited[x][y]:\n                        visited[x][y] = True\n                        if x > 0 and input_matrix[x-1][y] == '#' and not visited[x-1][y]:\n                            stack.append((x-1, y))\n                        if y > 0 and input_matrix[x][y-1] == '#' and not visited[x][y-1]:\n                            stack.append((x, y-1))\n                        if x < len(input_matrix) - 1 and input_matrix[x+1][y] == '#' and not visited[x+1][y]:\n                            stack.append((x+1, y))\n                        if y < len(input_matrix[0]) - 1 and input_matrix[x][y+1] == '#' and not visited[x][y+1]:\n                            stack.append((x, y+1))\n                break\n    if not all(visited[i].count(True) == 6 for i in range(len(visited))):\n        return 'cannot fold'\n    \n    # Check if the shape can be folded into a cube\n    return 'can fold'"
    },
    {
        "number": 3040,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    suffix_array = sorted(range(n), key=lambda i: stdin[i:])\n    lcp_array = [0] * n\n    rank_array = [0] * n\n\n    for i in range(n):\n        rank_array[suffix_array[i]] = i\n\n    lcp_array[0] = 0\n    for i in range(1, n):\n        index1 = suffix_array[rank_array[i] - 1]\n        index2 = suffix_array[rank_array[i]]\n        j = 0\n        while index1 + j < n and index2 + j < n:\n            if stdin[index1 + j] != stdin[index2 + j]:\n                break\n            j += 1\n        lcp_array[rank_array[i]] = j\n\n    max_len = max(lcp_array)\n    max_index = lcp_array.index(max_len)\n\n    return stdin[suffix_array[max_index]:suffix_array[max_index] + max_len]\n"
    },
    {
        "number": 3040,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    max_substring = ''\n    max_length = 0\n\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin)):\n            substring = stdin[i:j+1]\n            if len(substring) > max_length and stdin.count(substring) > 1:\n                max_length = len(substring)\n                max_substring = substring\n\n    return max_substring"
    },
    {
        "number": 3040,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    max_len = 0\n    max_substring = \"\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            substring = stdin[i:j + 1]\n            if len(substring) > max_len and stdin.count(substring) > 1:\n                max_len = len(substring)\n                max_substring = substring\n    return max_substring"
    },
    {
        "number": 3040,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    max_length = 0\n    max_substring = \"\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = stdin[i:j]\n            if len(substring) > max_length and stdin.count(substring) > 1:\n                max_length = len(substring)\n                max_substring = substring\n\n    return max_substring\n"
    },
    {
        "number": 3040,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    max_substring = \"\"\n    max_length = 0\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = stdin[i:j]\n            if len(substring) > max_length and stdin.count(substring) > 1:\n                max_length = len(substring)\n                max_substring = substring\n    return max_substring"
    },
    {
        "number": 3040,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    for length in range(n, 0, -1):\n        for i in range(n - length + 1):\n            substring = stdin[i:i + length]\n            if stdin.count(substring) > 1:\n                return substring\n    return \"\""
    },
    {
        "number": 3040,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    longest = \"\"\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = stdin[i:j]\n            if len(substring) > len(longest) and stdin.count(substring) > 1:\n                longest = substring\n                \n    return longest"
    },
    {
        "number": 3040,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    suffixes = sorted(stdin[i:] for i in range(n))\n    lcp = [0] * n\n    for i in range(1, n):\n        j = lcp[i - 1]\n        while i + j < n and suffixes[i - 1][j] == suffixes[i][j]:\n            j += 1\n        lcp[i] = j\n    max_lcp = max(lcp)\n    max_lcp_index = lcp.index(max_lcp)\n    return suffixes[max_lcp_index][:max_lcp]\n\ninput_string = input()\nresult = solution(input_string)\nprint(result) "
    },
    {
        "number": 3040,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    suffix = [0] * n\n    prefix = [0] * n\n\n    for i in range(n):\n        suffix[i] = stdin[i:] + stdin[:i]\n        prefix[i] = stdin[-i:] + stdin[:-i]\n\n    suffix.sort()\n    prefix.sort()\n\n    longest_substring = \"\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            if suffix[i] == suffix[j]:\n                current_substring = suffix[i]\n                if len(current_substring) > len(longest_substring):\n                    longest_substring = current_substring\n            if prefix[i] == prefix[j]:\n                current_substring = prefix[i]\n                if len(current_substring) > len(longest_substring):\n                    longest_substring = current_substring\n\n    return longest_substring\n"
    },
    {
        "number": 3040,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    longest_substring = \"\"\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = stdin[i:j]\n            if len(substring) > len(longest_substring) and stdin.count(substring) > 1:\n                longest_substring = substring\n    return longest_substring"
    },
    {
        "number": 3041,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_travel(zones, a, b):\n        for start, end in zones:\n            if start <= a <= end and start <= b <= end:\n                return True\n        return False\n\n    def cheapest_ticket(zone):\n        tickets = [2 + abs(a - b) for a, b in possible_tickets]\n        return min(tickets)\n\n    def min_coupons(trips):\n        coupons = 0\n        zones = []\n        for trip in trips:\n            zone, time = trip\n            if not can_travel(zones, 0, zone):\n                coupons += cheapest_ticket(zone)\n            zones = [(min(a, zone), max(b, zone)) for a, b in zones]\n        return coupons\n\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    trips = [list(map(int, line.split())) for line in lines[1:]]\n    possible_tickets = [(i, j) for i in range(11) for j in range(i, 11)]\n\n    return str(min_coupons(trips))"
    },
    {
        "number": 3041,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    coupons = set()\n    N = int(stdin.readline())\n    current_zone = 0\n    for _ in range(N):\n        zone, time = map(int, stdin.readline().split())\n        while current_zone not in coupons and current_zone < zone:\n            current_zone += 1\n            coupons.add(current_zone)\n        coupons.add(zone)\n        current_zone = zone\n    return str(len(coupons))"
    },
    {
        "number": 3041,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    coupons = 0\n    trips = []\n    for _ in range(N):\n        zone, time = map(int, stdin.readline().strip().split())\n        trips.append((zone, time))\n    trips.sort(key=lambda x: x[1])\n    current_ticket = [0, 0]\n    for trip in trips:\n        if trip[0] > current_ticket[1]:\n            coupons += 2 + abs(current_ticket[0] - current_ticket[1])\n            current_ticket = [trip[0], trip[0]]\n        elif trip[0] < current_ticket[0]:\n            coupons += 2 + abs(current_ticket[0] - current_ticket[1])\n            current_ticket = [trip[0], trip[0]]\n        current_ticket[1] = max(current_ticket[1], trip[0])\n    return str(coupons) "
    },
    {
        "number": 3041,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    coupons = set()\n    total_coupons = 0\n    for i in range(1, N + 1):\n        zone, time = map(int, lines[i].split())\n        while coupons and next(iter(coupons))[1] < time:\n            coupons.pop()\n        found = False\n        for c in coupons:\n            if c[0] <= zone <= c[1]:\n                found = True\n                break\n        if not found:\n            total_coupons += 2 + abs(zone - 0)\n            coupons.add((zone, time + 10000))\n    return str(total_coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    coupons = 0\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    zones = []\n    for i in range(1, N+1):\n        zones.append(list(map(int, lines[i].split())))\n    \n    trips = sorted(zones, key=lambda x: x[1])\n    current_ticket = [0, 0]\n    \n    for trip in trips:\n        if trip[0] > current_ticket[1]:\n            coupons += 2 + abs(current_ticket[0] - current_ticket[1])\n            current_ticket = trip\n        else:\n            current_ticket[1] = max(current_ticket[1], trip[0])\n    \n    return coupons + 2 + abs(current_ticket[0] - current_ticket[1]) "
    },
    {
        "number": 3041,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    trips = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:N+1]]\n\n    coupons = 0\n    valid_tickets = []\n\n    for trip in trips:\n        zone, time = trip\n        valid_tickets = [ticket for ticket in valid_tickets if time - ticket[1] <= 10000]\n        valid_tickets = sorted(valid_tickets + [[zone, time]], key=lambda x: x[0])\n\n        if len(valid_tickets) > 1:\n            coupons += 2 + abs(valid_tickets[-2][0] - valid_tickets[-1][0])\n        elif len(valid_tickets) == 1:\n            coupons += 2 + abs(valid_tickets[0][0] - zone)\n        else:\n            coupons += 2 + abs(0 - zone)\n\n        valid_tickets[-1][1] = time\n\n    return coupons"
    },
    {
        "number": 3041,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def coupons(a, b):\n        return 2 + abs(a - b)\n\n    trips = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    trips.sort(key=lambda x: x[1])\n\n    coupons_count = 0\n    current_zone = 0\n    current_ticket = None\n\n    for trip in trips:\n        new_zone, start_time = trip\n\n        if current_ticket is None or current_ticket[1] < start_time:\n            coupons_count += coupons(current_zone, new_zone)\n            current_ticket = (current_zone, start_time + 10000)\n\n        current_zone = new_zone\n\n    return str(coupons_count)"
    },
    {
        "number": 3041,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_coupons(trips):\n        coupons = 0\n        valid_ticket = (0, 0)\n\n        for trip in trips:\n            if trip[0] <= valid_ticket[1]:\n                coupons += 2 + abs(valid_ticket[0] - valid_ticket[1])\n                valid_ticket = (trip[0], trip[0])\n\n            valid_ticket = (min(valid_ticket[0], trip[0]), max(valid_ticket[1], trip[1]))\n\n        coupons += 2 + abs(valid_ticket[0] - valid_ticket[1])\n        return coupons\n\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    trips = [(int(line.split()[0]), int(line.split()[1])) for line in lines[1:]]\n\n    return str(get_min_coupons(trips))"
    },
    {
        "number": 3041,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    N = int(stdin.split(\"\\n\")[0])\n    trips = []\n    for i in range(1, N+1):\n        Z, T = map(int, stdin.split(\"\\n\")[i].split())\n        trips.append((Z, T))\n\n    # Initialize the variables\n    coupons = 0\n    valid_ticket = None\n\n    # Process the trips\n    for trip in trips:\n        Z, T = trip\n\n        # Check if the current ticket is still valid\n        if valid_ticket is not None and T < valid_ticket[1]:\n            # Check if the trip is within the valid zones of the current ticket\n            if valid_ticket[0][0] <= Z <= valid_ticket[0][1]:\n                continue\n\n        # Buy a new ticket\n        valid_ticket = (Z, T+10000)\n        coupons += 2 + abs(Z - valid_ticket[0])\n\n    return str(coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def zones_to_buy(trips):\n        bought = []\n        coupons = 0\n\n        for trip in trips:\n            zone, time = trip\n            found = False\n            for i in range(len(bought)):\n                if zone in range(bought[i][0], bought[i][1] + 1):\n                    found = True\n                    if time >= bought[i][2]:\n                        bought[i] = (zone, zone, time + 10000)\n            if not found:\n                coupons += 2 + abs(zone - 0)\n                bought.append((zone, zone, time + 10000))\n\n        return coupons\n\n    input_data = [line.strip().split() for line in stdin.split('\\n') if line.strip()]\n    num_trips = int(input_data[0][0])\n    trips = [(int(zone), int(time)) for zone, time in input_data[1:]]\n\n    return str(zones_to_buy(trips))"
    },
    {
        "number": 3042,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from math import gcd\n    from functools import reduce\n\n    n = int(stdin.readline())\n    values = list(map(int, stdin.readline().split()))\n\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    total_lcm = reduce(lcm, values)\n    return str(sum(total_lcm // value for value in values) % (10**9 + 7))\n\n    # Read input\n    n = int(input())\n    values = list(map(int, input().split()))\n\n    # Define LCM function\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    # Calculate total LCM\n    total_lcm = reduce(lcm, values)\n\n    # Calculate number of ways to arrange the nodes\n    result = sum(total_lcm // value for value in values) % (10**9 + 7)\n\n    # Output result\n    print(result) "
    },
    {
        "number": 3042,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    values = list(map(int, stdin.split('\\n')[1].split()))\n    MOD = 10**9 + 7\n\n    def lcm(x: int, y: int) -> int:\n        return (x * y) // gcd(x, y)\n\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    def count_ways(idx: int, parent_value: int) -> int:\n        if idx >= n:\n            return 1\n\n        left_value = values[idx]\n        right_value = parent_value // left_value\n        count = 0\n\n        for i in range(idx + 1, n):\n            if values[i] == right_value:\n                count += count_ways(i + 1, lcm(left_value, right_value))\n                count %= MOD\n                break\n\n        return count\n\n    return str(count_ways(0, values[0]))"
    },
    {
        "number": 3042,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    nodes = list(map(int, stdin.split(\"\\n\")[1].split()))\n    mod = 10**9 + 7\n\n    def count_ways(node_values):\n        if len(node_values) == 0:\n            return 1\n        if len(node_values) == 1:\n            return 1\n        if len(node_values) == 2:\n            return 1 if node_values[0] * node_values[1] % 2 == 0 else 0\n\n        node_values.sort()\n        count = 0\n        i = 0\n        while i < len(node_values) - 1:\n            lcm = (node_values[i] * node_values[i + 1]) // gcd(node_values[i], node_values[i + 1])\n\n            j = i + 2\n            while j < len(node_values) and node_values[j] % lcm == 0:\n                count += 1\n                j += 1\n\n            i += 1\n\n        return count % mod\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    return str(count_ways(nodes))"
    },
    {
        "number": 3042,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    if n % 2 == 0:\n        return \"0\"\n    nodes = sorted(list(map(int, stdin.split(\"\\n\")[1].split())), reverse=True)\n\n    def lcm(x: int, y: int) -> int:\n        return (x * y) // gcd(x, y)\n\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(i - 1, 0, -1):\n            if lcm(nodes[i - 1], nodes[j]) == nodes[i - 1]:\n                dp[i] += dp[j]\n                dp[i] %= mod\n\n    return str(dp[n])"
    },
    {
        "number": 3042,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(x: int, y: int) -> int:\n        return (x * y) // gcd(x, y)\n\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    n = int(stdin.split(\"\\n\")[0])\n    values = list(map(int, stdin.split(\"\\n\")[1].split()))\n    ways = 1\n\n    for i in range(n):\n        lcm_val = lcm(values[i], values[(i + 1) % n])\n        if lcm_val == values[0]:\n            ways *= 2\n\n    return str(ways % (10**9 + 7))"
    },
    {
        "number": 3042,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    n = int(stdin.split('\\n')[0])\n    values = list(map(int, stdin.split('\\n')[1].split()))\n    MOD = 10**9 + 7\n\n    dp = [0] * (2 * 10**9 + 1)\n    for i in range(n):\n        dp[values[i]] = 1\n\n    for i in range(2, 2 * 10**9 + 1):\n        for j in range(1, i // 2 + 1):\n            if i % j != 0:\n                continue\n            if lcm(j, i // j) == i:\n                dp[i] += dp[j] * dp[i // j]\n                dp[i] %= MOD\n\n    return str(dp[lcm(*values)])"
    },
    {
        "number": 3042,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    nodes = [int(x) for x in stdin.split(\"\\n\")[1].split()]\n    modulo = 10**9 + 7\n\n    def count_ways(index: int, value: int) -> int:\n        if index == n - 1:\n            return 1\n        left_value = value // nodes[index + 1]\n        right_value = value // nodes[index + 2]\n        left_ways = count_ways(index + 2, right_value)\n        right_ways = count_ways(index + 2, left_value)\n        return (left_ways + right_ways) % modulo\n\n    return str(count_ways(0, nodes[0]))"
    },
    {
        "number": 3042,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    values = list(map(int, stdin.split('\\n')[1].split()))\n    mod = 10**9 + 7\n    dp = [0] * 25\n    dp[0] = 1\n\n    for i in range(n):\n        for j in range(i, n):\n            if gcd(values[i], values[j]) == values[n]:\n                dp[j+1] += dp[i]\n                dp[j+1] %= mod\n\n    return str(dp[n])\n\ndef"
    },
    {
        "number": 3042,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    nodes = list(map(int, stdin.readline().split()))\n    mod = 10**9 + 7\n\n    def count_ways(lcm_tree: List[int]) -> int:\n        if len(lcm_tree) == 0:\n            return 1\n        if len(lcm_tree) == 1:\n            return 0\n        if len(lcm_tree) == 2:\n            return 1\n\n        lcm_tree.sort()\n        ways = 0\n        for i in range(1, len(lcm_tree)):\n            if lcm_tree[i] % lcm_tree[i - 1] == 0:\n                ways += count_ways(lcm_tree[:i - 1]) * count_ways(lcm_tree[i:])\n                ways %= mod\n\n        return ways\n\n    nodes.sort()\n    return str(count_ways(nodes))"
    },
    {
        "number": 3042,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    values = list(map(int, stdin.split('\\n')[1].split()))\n    mod = 10**9 + 7\n\n    def lcm(x, y):\n        return x * y // gcd(x, y)\n\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def count_ways(start, end):\n        if start == end:\n            return 1\n\n        count = 0\n        for i in range(start, end):\n            if lcm(values[i], values[end]) == values[end]:\n                count += count_ways(start, i) * count_ways(i + 1, end)\n                count %= mod\n\n        return count\n\n    return str(count_ways(0, n - 1))\n"
    },
    {
        "number": 3043,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.readline().split())\n    grid = []\n    start_pos = None\n    treasure_pos = None\n\n    for i in range(N):\n        row = list(stdin.readline().strip())\n        if 'S' in row:\n            start_pos = (i, row.index('S'))\n        if 'G' in row:\n            treasure_pos = (i, row.index('G'))\n        grid.append(row)\n\n    def is_valid_move(row, col, stamina):\n        if 0 <= row < N and 0 <= col < M:\n            cell = grid[row][col]\n            if cell in ('.', 'S', 'G'):\n                stamina -= 1\n            elif cell == 'F':\n                stamina -= 2\n            elif cell == 'M':\n                stamina -= 3\n            elif cell == '#':\n                return False\n            return stamina >= 0\n        return False\n\n    def bfs(start_pos, treasure_pos, stamina):\n        queue = [(start_pos, stamina)]\n        visited = set()\n\n        while queue:\n            pos, stamina = queue.pop(0)\n            if pos == treasure_pos:\n                return True\n\n            if (pos, stamina) in visited:\n                continue\n\n            visited.add((pos, stamina))\n\n            row, col = pos\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_pos = (row + dr, col + dc)\n                if is_valid_move(*new_pos, stamina):\n                    queue.append((new_pos, stamina))\n\n        return False\n\n    days = 0\n    while not bfs(start_pos, treasure_pos, K):\n        days += 1\n        K += 1\n\n    return str(days) if days <= 10**9 else \"-1\" "
    },
    {
        "number": 3043,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[0:3])\n    grid = list(stdin.split()[3:])\n    S_loc = next((i, j) for i in range(N) for j in range(M) if grid[i][j] == 'S')\n    G_loc = next((i, j) for i in range(N) for j in range(M) if grid[i][j] == 'G')\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < N and 0 <= y < M and grid[x][y] != '#'\n\n    def bfs() -> int:\n        days = 0\n        visited = set()\n        queue = [(S_loc, K)]\n\n        while queue:\n            new_queue = []\n\n            for (x, y), stamina in queue:\n                if (x, y) == G_loc:\n                    return days\n\n                if (x, y) in visited:\n                    continue\n\n                visited.add((x, y))\n\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    new_x, new_y = x + dx, y + dy\n                    if is_valid(new_x, new_y):\n                        if grid[new_x][new_y] == 'M' or grid[new_x][new_y] == 'F':\n                            if stamina >= 1:\n                                new_stamina = stamina - 1\n                                new_queue.append(((new_x, new_y), new_stamina))\n                        elif grid[new_x][new_y] == '.':\n                            if stamina >= 1:\n                                new_stamina = stamina - 1\n                                new_queue.append(((new_x, new_y), new_stamina))\n\n            days += 1\n            queue = new_queue\n\n        return -1\n\n    return bfs()"
    },
    {
        "number": 3043,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(board: List[List[str]], source: Tuple[int, int], target: Tuple[int, int]) -> int:\n        days = 0\n        visited = set()\n        queue = deque([(source, 0)])\n        while queue:\n            current, stamina = queue.popleft()\n            if current == target:\n                return days\n            if current in visited:\n                continue\n            visited.add(current)\n            row, col = current\n            if stamina < K and days > 0:\n                days += 1\n                stamina = K\n            for neighbor in get_neighbors(board, current):\n                if neighbor not in visited:\n                    queue.append((neighbor, stamina - get_cost(board, neighbor)))\n            days += 1\n        return -1\n\n    def get_neighbors(board: List[List[str]], cell: Tuple[int, int]) -> List[Tuple[int, int]]:\n        row, col = cell\n        neighbors = []\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < N and 0 <= new_col < M:\n                neighbors.append((new_row, new_col))\n        return neighbors\n\n    def get_cost(board: List[List[str]], cell: Tuple[int, int]) -> int:\n        row, col = cell\n        if board[row][col] == '.':\n            return 1\n        elif board[row][col] == 'F':\n            return 2\n        elif board[row][col] == 'M':\n            return 3\n        else:\n            return float('inf')\n\n    N, M, K = map(int, stdin.split()[0].split())\n    board = [list(stdin.split()[i + 1]) for i in range(N)]\n    source, target = None, None\n    for i in range(N):\n        for j in range(M):\n            if board[i][j] == 'S':\n                source = (i, j)\n            elif board[i][j] == 'G':\n                target = (i, j)\n    return bfs(board, source, target)"
    },
    {
        "number": 3043,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x, y, terrain):\n        return 0 <= x < N and 0 <= y < M and terrain[x][y] != '#'\n\n    def bfs(start_x, start_y, terrain, target_x, target_y, stamina):\n        queue = [(start_x, start_y, stamina)]\n        visited = set()\n        while queue:\n            x, y, current_stamina = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            if x == target_x and y == target_y:\n                return current_stamina\n            if current_stamina < 1:\n                continue\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n                if is_valid_move(new_x, new_y, terrain) and (terrain[new_x][new_y] != 'F' or current_stamina >= 2):\n                    if terrain[new_x][new_y] == 'M' or terrain[new_x][new_y] == 'F':\n                        queue.append((new_x, new_y, current_stamina - 1))\n                    elif terrain[new_x][new_y] == '.':\n                        queue.append((new_x, new_y, current_stamina - 1))\n                    else:\n                        queue.append((new_x, new_y, current_stamina))\n        return -1\n\n    stdin_list = stdin.split('\\n')\n    N, M, K = map(int, stdin_list[0].split())\n    terrain = [list(stdin_list[i + 1]) for i in range(N)]\n    start_x, start_y = 0, 0\n    target_x, target_y = 0, 0\n    for i in range(N):\n        for j in range(M):\n            if terrain[i][j] == 'S':\n                start_x, start_y = i, j\n            elif terrain[i][j] == 'G':\n                target_x, target_y = i, j\n\n    result = bfs(start_x, start_y, terrain, target_x, target_y, K)\n    if result == -1:\n        return -1\n    else:\n        return (result + K - 1) // K + 1 "
    },
    {
        "number": 3043,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(N)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M and grid[x][y] != '#'\n\n    def bfs(start_x, start_y):\n        queue = [(start_x, start_y, K)]\n        visited = set()\n\n        while queue:\n            x, y, stamina = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n\n            if grid[x][y] == 'G':\n                return True\n\n            if stamina < 1:\n                continue\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n                if is_valid(new_x, new_y):\n                    cost = 1 if grid[new_x][new_y] == '.' else 2 if grid[new_x][new_y] == 'F' else 3\n                    queue.append((new_x, new_y, stamina - cost))\n\n        return False\n\n    start_x, start_y = None, None\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_x, start_y = i, j\n                break\n\n    if start_x is None or start_y is None:\n        return -1\n\n    if bfs(start_x, start_y):\n        return 1\n    else:\n        return -1\n\n\ndef"
    },
    {
        "number": 3043,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(N)]\n\n    def is_valid(x, y):\n        if 0 <= x < N and 0 <= y < M and grid[x][y] != '#':\n            return True\n        return False\n\n    def bfs(start_x, start_y):\n        queue = [(start_x, start_y, K)]\n        visited = set()\n\n        while queue:\n            x, y, stamina = queue.pop(0)\n            if (x, y, stamina) in visited:\n                continue\n            visited.add((x, y, stamina))\n\n            if grid[x][y] == 'G':\n                return True\n\n            if stamina < 1:\n                continue\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n                if is_valid(new_x, new_y):\n                    cost = 1 if grid[new_x][new_y] == '.' else 2 if grid[new_x][new_y] == 'F' else 3\n                    queue.append((new_x, new_y, stamina - cost))\n\n        return False\n\n    start_x, start_y = -1, -1\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_x, start_y = i, j\n\n    if bfs(start_x, start_y):\n        return 1\n    elif bfs(start_x, start_y, K * 2):\n        return 2\n    else:\n        return -1"
    },
    {
        "number": 3043,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x, y):\n        return 0 <= x < N and 0 <= y < M and grid[x][y] != '#'\n\n    def find_treasure():\n        while not reached_treasure and days < max_days:\n            days += 1\n            x, y = current_position\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n\n                if is_valid_move(new_x, new_y):\n                    new_stamina = stamina - (1 if grid[new_x][new_y] == '.' else 2 if grid[new_x][new_y] == 'F' else 3)\n\n                    if new_stamina >= 0:\n                        next_positions.append((new_x, new_y, new_stamina))\n\n            if not next_positions:\n                return False\n\n            current_position = min(next_positions, key=lambda x: x[2])\n            next_positions.clear()\n\n            stamina = current_position[2]\n            if grid[current_position[0]][current_position[1]] == 'G':\n                reached_treasure = True\n\n        return days\n\n    N, M, K = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(N)]\n\n    S_position = next((x, y) for x in range(N) for y in range(M) if grid[x][y] == 'S')\n    G_position = next((x, y) for x in range(N) for y in range(M) if grid[x][y] == 'G')\n\n    max_days = (N + M) * 4\n    days = 0\n    stamina = K\n    current_position = S_position\n    next_positions = []\n    reached_treasure = False\n\n    result = find_treasure()\n\n    return str(result) if result <= max_days else \"-1\""
    },
    {
        "number": 3043,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start_row, start_col, target):\n        visited = [[False for _ in range(M)] for _ in range(N)]\n        visited[start_row][start_col] = True\n        queue = [(start_row, start_col, K)]\n        days = 0\n\n        while queue:\n            row, col, stamina = queue.pop(0)\n            if grid[row][col] == target:\n                return days\n\n            for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                next_row, next_col = row + direction[0], col + direction[1]\n                if 0 <= next_row < N and 0 <= next_col < M and not visited[next_row][next_col]:\n                    if grid[next_row][next_col] != '#':\n                        cost = 1 if grid[next_row][next_col] == '.' else 2 if grid[next_row][next_col] == 'F' else 3\n                        if stamina >= cost:\n                            visited[next_row][next_col] = True\n                            queue.append((next_row, next_col, stamina - cost))\n\n            days += 1\n            if days % 2 == 0 and stamina < K:\n                queue.append((start_row, start_col, K))\n\n        return -1\n\n    N, M, K = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(N)]\n\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                start_row, start_col = row, col\n            elif grid[row][col] == 'G':\n                target = 'G'\n\n    return str(bfs(start_row, start_col, target))"
    },
    {
        "number": 3043,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[0:3])\n    grid = [list(input()) for _ in range(N)]\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < N and 0 <= y < M and grid[x][y] != '#'\n\n    def bfs(start_x: int, start_y: int) -> int:\n        queue = deque([(start_x, start_y, K)])\n        visited = set()\n        days = 0\n\n        while queue:\n            x, y, stamina = queue.popleft()\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n\n            if grid[x][y] == 'G':\n                return days\n\n            if stamina < 1:\n                days += 1\n                stamina = K\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n                if is_valid(new_x, new_y):\n                    cost = {'S': 0, 'F': 1, 'M': 2, '.': 1}[grid[new_x][new_y]]\n                    if stamina >= cost:\n                        queue.append((new_x, new_y, stamina - cost))\n\n        return -1\n\n    start_x, start_y = None, None\n    for x in range(N):\n        for y in range(M):\n            if grid[x][y] == 'S':\n                start_x, start_y = x, y\n\n    return str(bfs(start_x, start_y))"
    },
    {
        "number": 3043,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.readline().split())\n    grid = []\n    for i in range(N):\n        row = stdin.readline().strip()\n        if 'S' in row and 'G' in row:\n            grid.append(row)\n\n    days = 0\n    stamina = K\n    treasure_found = False\n\n    while not treasure_found:\n        for i in range(N):\n            for j in range(M):\n                if grid[i][j] == 'G':\n                    treasure_found = True\n                    break\n                if grid[i][j] == 'S':\n                    if i > 0 and grid[i - 1][j] != '#':\n                        stamina -= 1\n                    if i < N - 1 and grid[i + 1][j] != '#':\n                        stamina -= 1\n                    if j > 0 and grid[i][j - 1] != '#':\n                        stamina -= 1\n                    if j < M - 1 and grid[i][j + 1] != '#':\n                        stamina -= 1\n\n                    if stamina < 0:\n                        days += 1\n                        stamina = K\n\n                if grid[i][j] == '.':\n                    stamina -= 1\n                elif grid[i][j] == 'F':\n                    stamina -= 2\n                elif grid[i][j] == 'M':\n                    stamina -= 3\n\n            if treasure_found:\n                break\n\n        if days == 0 and not treasure_found:\n            return -1\n\n        days += 1\n        stamina = K\n\n    return days"
    },
    {
        "number": 3044,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(grid, x, y, command):\n        if command == 'L':\n            if x > 0 and grid[y][x - 1] != '#':\n                return True\n        elif command == 'R':\n            if x < W - 1 and grid[y][x + 1] != '#':\n                return True\n        elif command == 'U':\n            if y > 0 and grid[y - 1][x] != '#':\n                return True\n        elif command == 'D':\n            if y < H - 1 and grid[y + 1][x] != '#':\n                return True\n        return False\n\n    def robot_path(grid, start_x, start_y, commands):\n        x, y = start_x, start_y\n        for command in commands:\n            if is_valid_move(grid, x, y, command):\n                if command == 'L':\n                    x -= 1\n                elif command == 'R':\n                    x += 1\n                elif command == 'U':\n                    y -= 1\n                elif command == 'D':\n                    y += 1\n            if grid[y][x] == 'G':\n                return True\n        return False\n\n    def find_min_changes(grid, start_x, start_y, commands):\n        if robot_path(grid, start_x, start_y, commands):\n            return 0\n\n        min_changes = float('inf')\n        for i in range(len(commands)):\n            new_commands = commands[:i] + commands[i + 1:]\n            for new_command in 'LRUD':\n                if is_valid_move(grid, start_x, start_y, new_command):\n                    if new_command == 'L':\n                        new_x = start_x - 1\n                    elif new_command == 'R':\n                        new_x = start_x + 1\n                    elif new_command == 'U':\n                        new_y = start_y - 1\n                    elif new_command == 'D':\n                        new_y = start_y + 1\n                    changes = find_min_changes(grid, new_x, new_y, new_commands)\n                    if changes != float('inf'):\n                        min_changes = min(min_changes, changes + 1)\n\n        return min_changes\n\n    lines = stdin.split('\\n')\n    H, W = map(int, lines[0].split())\n    grid = [list(line) for line in lines[1:H+1]]\n    start_x, start_y = next((x, y) for y in range(H) for x in range(W) if grid[y][x] == 'S')\n    commands = lines[-1]\n\n    return find_min_changes(grid, start_x, start_y, commands)"
    },
    {
        "number": 3044,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(robot_pos, command, grid):\n        x, y = robot_pos\n        if command == \"L\":\n            new_pos = (x - 1, y)\n        elif command == \"R\":\n            new_pos = (x + 1, y)\n        elif command == \"U\":\n            new_pos = (x, y - 1)\n        elif command == \"D\":\n            new_pos = (x, y + 1)\n        return 0 <= new_pos[0] < len(grid) and 0 <= new_pos[1] < len(grid[0]) and grid[new_pos[0]][new_pos[1]] != \"#\"\n\n    def get_robot_path(start_pos, commands, grid):\n        x, y = start_pos\n        path = [(x, y)]\n        for command in commands:\n            if is_valid_move((x, y), command, grid):\n                if command == \"L\":\n                    x -= 1\n                elif command == \"R\":\n                    x += 1\n                elif command == \"U\":\n                    y -= 1\n                elif command == \"D\":\n                    y += 1\n            path.append((x, y))\n            if grid[x][y] == \"G\":\n                break\n        return path\n\n    H, W = map(int, input().split())\n    grid = [list(input()) for _ in range(H)]\n    start_pos = next((i, j) for i in range(H) for j in range(W) if grid[i][j] == \"S\")\n    goal_pos = next((i, j) for i in range(H) for j in range(W) if grid[i][j] == \"G\")\n    original_commands = input()\n\n    robot_path = get_robot_path(start_pos, original_commands, grid)\n\n    if robot_path[-1] == goal_pos:\n        return 0\n    else:\n        min_changes = float(\"inf\")\n        for i in range(len(original_commands)):\n            for command in \"LRUD\":\n                new_commands = original_commands[:i] + command + original_commands[i + 1 :]\n                robot_path = get_robot_path(start_pos, new_commands, grid)\n                if robot_path[-1] == goal_pos:\n                    min_changes = min(min_changes, 1 + len(original_commands) - len(new_commands))\n        for i in range(len(original_commands)):\n            for j in range(i + 1, len(original_commands) + 1):\n                for command in \"LRUD\":\n                    new_commands = original_commands[:i] + command + original_commands[i:]\n                    robot_path = get_robot_path(start_pos, new_commands, grid)\n                    if robot_path[-1] == goal_pos:\n                        min_changes = min(min_changes, 1 + len(original_commands) - len(new_commands))\n        return min_changes"
    },
    {
        "number": 3044,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Process input\n    def grid_input():\n        H, W = map(int, input().split())\n        grid = [input() for _ in range(H)]\n        return H, W, grid\n\n    def robot_input():\n        return input()\n\n    H, W, grid = grid_input()\n    start_position = next((x, y) for y, row in enumerate(grid) for x, char in enumerate(row) if char == 'S')\n    goal_position = next((x, y) for y, row in enumerate(grid) for x, char in enumerate(row) if char == 'G')\n    robot_program = robot_input()\n\n    # Create a function to simulate the robot's movements\n    def simulate_robot(program):\n        x, y = start_position\n        for command in program:\n            dx, dy = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1)}[command]\n            if 0 <= x + dx < W and 0 <= y + dy < H and grid[y + dy][x + dx] != '#':\n                x, y = x + dx, y + dy\n                if (x, y) == goal_position:\n                    return True\n        return False\n\n    # Main function to find the minimum number of changes needed\n    def min_changes():\n        # Check if the program works as is\n        if simulate_robot(robot_program):\n            return 0\n\n        # Generate all possible changes\n        changes = []\n        for i in range(len(robot_program) + 1):\n            for command in 'LRUD':\n                new_program = robot_program[:i] + command + robot_program[i:]\n                if simulate_robot(new_program):\n                    changes.append(new_program)\n\n        # Return the minimum number of changes needed\n        if not changes:\n            return -1\n        else:\n            return min(len(program) - len(robot_program) for program in changes)\n\n    # Return output\n    result = min_changes()\n    if result == -1:\n        return \"It is not possible to reach the goal.\"\n    elif result == 0:\n        return \"The program works correctly.\"\n    else:\n        return str(result)"
    },
    {
        "number": 3044,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W and grid[x][y] != '#'\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = [[False] * W for _ in range(H)]\n        visited[start[0]][start[1]] = True\n\n        while queue:\n            x, y, step = queue.pop(0)\n            if (x, y) == end:\n                return step\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append(((nx, ny, step + 1))\n\n        return -1\n\n    lines = stdin.split('\\n')\n    H, W = map(int, lines[0].split())\n    grid = [list(lines[i + 1]) for i in range(H)]\n    start_x, start_y = next((i, j) for i in range(H) for j in range(W) if grid[i][j] == 'S')\n    goal_x, goal_y = next((i, j) for i in range(H) for j in range(W) if grid[i][j] == 'G')\n    start, end = (start_x, start_y), (goal_x, goal_y)\n\n    initial_commands = lines[-1]\n    min_changes = float('inf')\n\n    for commands in generate_permutations(initial_commands):\n        commands_stack = list(commands)\n        current_x, current_y = start\n        step = 0\n\n        while commands_stack:\n            command = commands_stack.pop(0)\n            dx, dy = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1)}[command]\n            nx, ny = current_x + dx, current_y + dy\n\n            if is_valid(nx, ny):\n                step += 1\n                current_x, current_y = nx, ny\n\n            if (current_x, current_y) == end:\n                min_changes = min(min_changes, len(commands) - step + 1)\n                break\n\n        if min_changes == 1:\n            break\n\n    return str(min_changes)\n\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    H, W = map(int, stdin.readline().split())\n    grid = []\n    start_pos = (0, 0)\n    goal_pos = (0, 0)\n    for i in range(H):\n        row = stdin.readline().strip()\n        grid.append(row)\n        for j, char in enumerate(row):\n            if char == 'S':\n                start_pos = (i, j)\n            elif char == 'G':\n                goal_pos = (i, j)\n\n    original_command = stdin.readline().strip()\n\n    # Define a function to check if the robot can reach the goal with a given command string\n    def can_reach_goal(command: str) -> bool:\n        x, y = start_pos\n        for char in command:\n            if char == 'L':\n                y -= 1\n            elif char == 'R':\n                y += 1\n            elif char == 'U':\n                x -= 1\n            elif char == 'D':\n                x += 1\n\n            if 0 <= x < H and 0 <= y < W and grid[x][y] != '#':\n                if (x, y) == goal_pos:\n                    return True\n            else:\n                break\n        return False\n\n    # Check if the robot can reach the goal with the original command\n    if can_reach_goal(original_command):\n        return 0\n\n    # Try deleting each character and check if the robot can reach the goal\n    for i in range(len(original_command)):\n        new_command = original_command[:i] + original_command[i+1:]\n        if can_reach_goal(new_command):\n            return 1\n\n    # Try inserting each command at each position and check if the robot can reach the goal\n    for i in range(len(original_command) + 1):\n        for char in ['L', 'R', 'U', 'D']:\n            new_command = original_command[:i] + char + original_command[i:]\n            if can_reach_goal(new_command):\n                return 1\n\n    # If no changes can fix the program, return -1\n    return -1"
    },
    {
        "number": 3044,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(H)]\n    start_position = None\n    goal_position = None\n\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start_position = (i, j)\n            elif grid[i][j] == 'G':\n                goal_position = (i, j)\n\n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W and grid[x][y] != '#'\n\n    def bfs(start_position, goal_position):\n        queue = deque([start_position])\n        visited = set()\n        visited.add(start_position)\n\n        while queue:\n            x, y = queue.popleft()\n            if (x, y) == goal_position:\n                return True\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and (nx, ny) not in visited:\n                    queue.append((nx, ny))\n                    visited.add((nx, ny))\n\n        return False\n\n    original_commands = stdin.readline().strip()\n    min_changes = float('inf')\n\n    for i in range(len(original_commands)):\n        modified_commands = original_commands[:i] + original_commands[i + 1:]\n        if bfs(start_position, goal_position):\n            min_changes = min(min_changes, len(modified_commands))\n\n    for i in range(len(original_commands)):\n        for command in ['L', 'R', 'U', 'D']:\n            modified_commands = original_commands[:i] + command + original_commands[i:]\n            if bfs(start_position, goal_position):\n                min_changes = min(min_changes, len(modified_commands) - len(original_commands))\n\n    return min_changes "
    },
    {
        "number": 3044,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    input_lines = stdin.split(\"\\n\")\n    H, W = map(int, input_lines[0].split())\n    grid = [list(line) for line in input_lines[1:1 + H]]\n    command_string = input_lines[-1]\n\n    # Define the robot's initial position and goal position\n    for row in range(H):\n        for col in range(W):\n            if grid[row][col] == 'S':\n                start_pos = (row, col)\n            elif grid[row][col] == 'G':\n                goal_pos = (row, col)\n\n    # Define the directions the robot can move\n    directions = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1)}\n\n    # Define a function to check if a move is valid\n    def is_valid_move(pos, direction):\n        new_pos = (pos[0] + direction[0], pos[1] + direction[1])\n        return 0 <= new_pos[0] < H and 0 <= new_pos[1] < W and grid[new_pos[0]][new_pos[1]] != '#'\n\n    # Simulate the robot's movement with the given command string\n    current_pos = start_pos\n    for command in command_string:\n        if is_valid_move(current_pos, directions[command]):\n            current_pos = (current_pos[0] + directions[command][0], current_pos[1] + directions[command][1])\n\n    # Check if the robot reached the goal position\n    if current_pos == goal_pos:\n        return 0\n\n    # Try all possible changes and find the minimum number of changes needed\n    min_changes = float('inf')\n    for i in range(len(command_string) + 1):\n        for command in directions:\n            new_command_string = command_string[:i] + command + command_string[i:]\n            if solution(stdin.replace(command_string, new_command_string)) + 1 < min_changes:\n                min_changes = solution(stdin.replace(command_string, new_command_string)) + 1\n\n    return min_changes"
    },
    {
        "number": 3044,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    H, W = map(int, stdin.readline().split())\n    grid = []\n    for i in range(H):\n        grid.append(list(stdin.readline().strip()))\n    start_position = None\n    goal_position = None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start_position = (i, j)\n            elif grid[i][j] == 'G':\n                goal_position = (i, j)\n    program = stdin.readline().strip()\n\n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W and grid[x][y] != '#'\n\n    def simulate(program, start_position):\n        x, y = start_position\n        for command in program:\n            if command == 'L':\n                if is_valid(x, y - 1):\n                    y -= 1\n            elif command == 'R':\n                if is_valid(x, y + 1):\n                    y += 1\n            elif command == 'U':\n                if is_valid(x - 1, y):\n                    x -= 1\n            elif command == 'D':\n                if is_valid(x + 1, y):\n                    x += 1\n            if (x, y) == goal_position:\n                return True\n        return False\n\n    def find_diff(program, start_position):\n        if simulate(program, start_position):\n            return 0\n        for i in range(len(program)):\n            if simulate(program[:i] + program[i + 1:], start_position):\n                return 1\n        for command in 'LRUD':\n            if simulate(program + command, start_position):\n                return 1\n        return -1\n\n    return find_diff(program, start_position)"
    },
    {
        "number": 3044,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W and grid[x][y] != '#'\n\n    def find_path(x, y, command):\n        if command == 'L':\n            return (x, y - 1)\n        if command == 'R':\n            return (x, y + 1)\n        if command == 'U':\n            return (x - 1, y)\n        if command == 'D':\n            return (x + 1, y)\n\n    def dfs(x, y, command_idx):\n        if command_idx == len(commands):\n            return (x, y) == (goal[0], goal[1])\n\n        if not is_valid(x, y):\n            return False\n\n        if (x, y) == (goal[0], goal[1]):\n            return True\n\n        next_command = commands[command_idx]\n        next_x, next_y = find_path(x, y, next_command)\n\n        if dfs(next_x, next_y, command_idx + 1):\n            return True\n\n        if is_valid(next_x, next_y):\n            grid[next_x][next_y] = '#'\n            if dfs(x, y, command_idx + 1):\n                return True\n            grid[next_x][next_y] = '.'\n\n        return False\n\n    stdin_list = stdin.split('\\n')\n    H, W = map(int, stdin_list[0].split())\n    grid = [list(stdin_list[i + 1]) for i in range(H)]\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n\n    commands = stdin_list[-1]\n    result = dfs(start[0], start[1], 0)\n\n    return str(len(commands) - result)"
    },
    {
        "number": 3044,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(grid, x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != '#'\n\n    def dfs(grid, x, y, dx, dy, command, visited):\n        if not is_valid(grid, x + dx, y + dy):\n            return False\n        if (x, y) in visited:\n            return False\n        if grid[x + dx][y + dy] == 'G':\n            return True\n\n        visited.add((x, y))\n        for d in [dx, dy, -dx, -dy]:\n            if dfs(grid, x + dx, y + dy, d, d, command + ('U' if d == -dx else 'D' if d == dx else 'L' if d == -dy else 'R'), visited):\n                return True\n        return False\n\n    def find_path(grid, x, y):\n        visited = set()\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                if dfs(grid, x, y, dx, dy, '', visited):\n                    return True\n        return False\n\n    lines = stdin.split('\\n')\n    H, W = map(int, lines[0].split())\n    grid = [list(lines[i + 1]) for i in range(H)]\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start_x, start_y = i, j\n            elif grid[i][j] == 'G':\n                goal_x, goal_y = i, j\n\n    command = lines[-1]\n    original_command = command\n    min_changes = float('inf')\n\n    for i in range(len(command) + 1):\n        for delete in [True, False]:\n            new_command = original_command[:i] + (original_command[i + 1:] if delete else '') + ('U' if not delete else '')\n            if find_path(grid, start_x, start_y):\n                min_changes = min(min_changes, len(original_command) - len(new_command))\n\n    return min_changes "
    },
    {
        "number": 3045,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input and store it in the appropriate data structures\n    input_data = []\n    for line in stdin.split('\\n'):\n        if line.isnumeric():\n            continue\n        x, y, d = map(int, line.split())\n        input_data.append((x, y, d))\n    \n    # Define a function to calculate the Manhattan distance between two points\n    def manhattan_distance(point1, point2):\n        return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n    \n    # Define a function to check if a given position is consistent with the input\n    def is_consistent(position):\n        for beacon in input_data:\n            if manhattan_distance(position, beacon[:2]) != beacon[2]:\n                return False\n        return True\n    \n    # Find all the possible receiver positions and check if they are consistent with the input\n    possible_positions = []\n    for x in range(-10**6, 10**6+1):\n        for y in range(-10**6, 10**6+1):\n            if is_consistent((x, y)):\n                possible_positions.append((x, y))\n    \n    # Check the number of possible positions and return the appropriate output\n    if len(possible_positions) == 1:\n        return f\"{possible_positions[0][0]} {possible_positions[0][1]}\"\n    elif len(possible_positions) > 1:\n        return \"uncertain\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(x, y):\n        for d_i, x_i, y_i in distances:\n            if abs(x - x_i) + abs(y - y_i) != d_i:\n                return False\n        return True\n\n    N = int(stdin.readline().strip())\n    beacons = []\n    distances = []\n    for _ in range(N):\n        x_i, y_i, d_i = map(int, stdin.readline().strip().split())\n        beacons.append((x_i, y_i))\n        distances.append((d_i, x_i, y_i))\n\n    for x in range(1000000):\n        for y in range(1000000):\n            if is_possible(x, y):\n                return f\"{x} {y}\\n\"\n\n    return \"impossible\\n\" if N > 0 else \"uncertain\\n\""
    },
    {
        "number": 3045,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_position(x, y, distances):\n        for x_b, y_b, d in distances:\n            if abs(x - x_b) + abs(y - y_b) != d:\n                return False\n        return True\n\n    N = int(stdin.readline().strip())\n    beacons = [tuple(map(int, stdin.readline().strip().split())) for _ in range(N)]\n\n    min_x, max_x = min(x for x, y, d in beacons), max(x for x, y, d in beacons)\n    min_y, max_y = min(y for x, y, d in beacons), max(y for x, y, d in beacons)\n\n    possible_positions = [(x, y) for x in range(min_x, max_x + 1) for y in range(min_y, max_y + 1)]\n    valid_positions = [pos for pos in possible_positions if is_valid_position(*pos, beacons)]\n\n    if len(valid_positions) == 1:\n        return \"{} {}\\n\".format(*valid_positions[0])\n    elif len(valid_positions) > 1:\n        return \"uncertain\\n\"\n    else:\n        return \"impossible\\n\""
    },
    {
        "number": 3045,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def find_receiver_position(beacons):\n        candidates = set()\n        for i in range(len(beacons)):\n            for j in range(i + 1, len(beacons)):\n                dx = beacons[i][0] - beacons[j][0]\n                dy = beacons[i][1] - beacons[j][1]\n                candidates.add((beacons[i][0] + beacons[j][0] - distance(beacons[i][0], beacons[i][1], beacons[j][0], beacons[j][1]), dx))\n                candidates.add((beacons[i][0] + beacons[j][0] - distance(beacons[i][0], beacons[i][1], beacons[j][0], beacons[j][1]), -dx))\n                candidates.add((beacons[i][1] + beacons[j][1] - distance(beacons[i][0], beacons[i][1], beacons[j][0], beacons[j][1]), dy))\n                candidates.add((beacons[i][1] + beacons[j][1] - distance(beacons[i][0], beacons[i][1], beacons[j][0], beacons[j][1]), -dy))\n        return candidates\n\n    def check_receiver_position(candidates, beacons):\n        for candidate in candidates:\n            valid = True\n            for beacon in beacons:\n                if distance(candidate[0], candidate[1], beacon[0], beacon[1]) != beacon[2]:\n                    valid = False\n                    break\n            if valid:\n                return candidate\n        return None\n\n    input_data = [line.strip() for line in stdin.split(\"\\n\")]\n    num_beacons = int(input_data[0])\n    beacons = []\n    for i in range(1, num_beacons + 1):\n        x, y, d = map(int, input_data[i].split())\n        beacons.append((x, y, d))\n\n    candidates = find_receiver_position(beacons)\n    position = check_receiver_position(candidates, beacons)\n\n    if len(candidates) == 1:\n        return \"{} {}\\n\".format(position[0], position[1])\n    elif len(candidates) > 1:\n        return \"uncertain\\n\"\n    else:\n        return \"impossible\\n\""
    },
    {
        "number": 3045,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_consistent(x, y, beacons):\n        for b in beacons:\n            if abs(x - b[0]) + abs(y - b[1]) != b[2]:\n                return False\n        return True\n\n    def find_position(beacons):\n        for x in range(beacons[0][0] - beacons[0][2], beacons[0][0] + beacons[0][2] + 1):\n            for y in range(beacons[0][1] - beacons[0][2], beacons[0][1] + beacons[0][2] + 1):\n                if is_consistent(x, y, beacons):\n                    return (x, y)\n        return None\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    beacons = []\n    for i in range(1, N + 1):\n        x, y, d = map(int, lines[i].split())\n        beacons.append((x, y, d))\n\n    position = find_position(beacons)\n    if position:\n        return f\"{position[0]} {position[1]}\\n\"\n    elif find_position(beacons[1:]):\n        return \"uncertain\\n\"\n    else:\n        return \"impossible\\n\""
    },
    {
        "number": 3045,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        for i in range(N):\n            if abs(x - X[i]) + abs(y - Y[i]) != D[i]:\n                return False\n        return True\n\n    N = int(stdin.readline())\n    X = []\n    Y = []\n    D = []\n    for i in range(N):\n        x, y, d = map(int, stdin.readline().split())\n        X.append(x)\n        Y.append(y)\n        D.append(d)\n\n    for x in range(min(X), max(X) + 1):\n        for y in range(min(Y), max(Y) + 1):\n            if is_valid(x, y):\n                return f\"{x} {y}\"\n\n    return \"impossible\" if N > 0 else \"uncertain\""
    },
    {
        "number": 3045,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def manhattan_distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def check_position(x, y, beacons, distances):\n        for i in range(len(beacons)):\n            if manhattan_distance((x, y), beacons[i]) != distances[i]:\n                return False\n        return True\n\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n\n    beacons = []\n    distances = []\n    for i in range(1, N + 1):\n        x, y, d = map(int, input_data[i].split())\n        beacons.append((x, y))\n        distances.append(d)\n\n    possible_positions = []\n    for x in range(100000):\n        for y in range(100000):\n            if check_position(x, y, beacons, distances):\n                possible_positions.append((x, y))\n\n    if len(possible_positions) == 1:\n        return f\"{possible_positions[0][0]} {possible_positions[0][1]}\"\n    elif len(possible_positions) > 1:\n        return \"uncertain\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def check_consistency(x, y):\n        for d, (bx, by) in beacons:\n            if abs(x - bx) + abs(y - by) != d:\n                return False\n        return True\n\n    beacons = []\n    N = int(stdin.readline().strip())\n    for _ in range(N):\n        x, y, d = map(int, stdin.readline().strip().split())\n        beacons.append((d, (x, y)))\n\n    for x in range(1000000):\n        for y in range(1000000):\n            if check_consistency(x, y):\n                return f\"{x} {y}\"\n\n    return \"uncertain\" if N == 1 else \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_data = list(map(int, stdin.split()))\n    N = input_data[0]\n    beacons = []\n    for i in range(1, len(input_data), 3):\n        beacons.append((input_data[i], input_data[i+1], input_data[i+2]))\n\n    # Find all possible receiver positions\n    possible_positions = []\n    for x in range(-1000000, 1000001):\n        for y in range(-1000000, 1000001):\n            valid_position = True\n            for beacon in beacons:\n                if abs(x - beacon[0]) + abs(y - beacon[1]) != beacon[2]:\n                    valid_position = False\n                    break\n            if valid_position:\n                possible_positions.append((x, y))\n\n    # Check if there is exactly one receiver position\n    if len(possible_positions) == 1:\n        return f\"{possible_positions[0][0]} {possible_positions[0][1]}\"\n    elif len(possible_positions) == 0:\n        return \"impossible\"\n    else:\n        return \"uncertain\""
    },
    {
        "number": 3045,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(x, y, beacons):\n        for b in beacons:\n            if abs(x - b[0]) + abs(y - b[1]) != b[2]:\n                return False\n        return True\n\n    def search_positions(beacons):\n        for x in range(beacons[0][0] - beacons[0][2], beacons[0][0] + beacons[0][2] + 1):\n            for y in range(beacons[0][1] - beacons[0][2], beacons[0][1] + beacons[0][2] + 1):\n                if is_possible(x, y, beacons):\n                    return (x, y)\n        return None\n\n    N = int(stdin.readline())\n    beacons = [tuple(map(int, line.split())) for line in stdin]\n\n    position = search_positions(beacons)\n\n    if position is not None:\n        return f\"{position[0]} {position[1]}\\n\"\n    elif any(is_possible(x, y, beacons) for x in range(min(x[0] for x in beacons), max(x[0] for x in beacons) + 1) for y in range(min(x[1] for x in beacons), max(x[1] for x in beacons) + 1)):\n        return \"uncertain\\n\"\n    else:\n        return \"impossible\\n\""
    },
    {
        "number": 3046,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    input_data = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[1:2*n+1]]\n    output_data = []\n\n    def is_valid(top_left, bottom_right):\n        return top_left[0] <= bottom_right[0] and top_left[1] <= bottom_right[1]\n\n    def find_match(top_left_candidates, bottom_right_candidates):\n        for i, top_left in enumerate(top_left_candidates):\n            for j, bottom_right in enumerate(bottom_right_candidates):\n                if is_valid(top_left, bottom_right):\n                    return i, j\n        return None, None\n\n    while input_data:\n        top_left_candidates = [input_data.pop(0)]\n        bottom_right_candidates = [input_data.pop(0)]\n\n        while True:\n            i, j = find_match(top_left_candidates, bottom_right_candidates)\n            if i == j == None:\n                break\n            output_data.append(i+1)\n            top_left_candidates.pop(i)\n            bottom_right_candidates.pop(j)\n\n        if top_left_candidates or bottom_right_candidates:\n            return \"syntax error\"\n\n    return \"\\n\".join(map(str, output_data)) + \"\\n\""
    },
    {
        "number": 3046,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, top_left, bottom_right = 0, [], []\n    for line in stdin.split('\\n'):\n        if not n:\n            n = int(line)\n        elif len(top_left) < n:\n            top_left.append(tuple(map(int, line.split())))\n        else:\n            bottom_right.append(tuple(map(int, line.split())))\n\n    def is_valid(tl, br):\n        return tl[0] <= br[0] and tl[1] <= br[1]\n\n    def find_matching(tl, br, used_tl, used_br):\n        if not tl and not br:\n            return True\n        if not tl or not br:\n            return False\n\n        for i, t in enumerate(tl):\n            for j, b in enumerate(br):\n                if is_valid(t, b) and not (i in used_tl or j in used_br):\n                    used_tl.append(i)\n                    used_br.append(j)\n                    if find_matching(tl[:i] + tl[i + 1:], br[:j] + br[j + 1:], used_tl, used_br):\n                        return True\n                    used_tl.pop()\n                    used_br.pop()\n        return False\n\n    permutation = []\n    for i in range(n):\n        tl_candidates = [j for j in range(n) if j not in permutation and is_valid(top_left[j], bottom_right[i])]\n        if not tl_candidates:\n            return \"syntax error\"\n        tl_index = tl_candidates[0]\n        permutation.append(tl_index + 1)\n        top_left.pop(tl_index)\n\n    return '\\n'.join(map(str, permutation))"
    },
    {
        "number": 3046,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    top_left = []\n    bottom_right = []\n\n    for i in range(n):\n        top_left.append(list(map(int, stdin.readline().strip().split())))\n    for i in range(n):\n        bottom_right.append(list(map(int, stdin.readline().strip().split())))\n\n    def is_valid(top_left, bottom_right):\n        return (top_left[0] < bottom_right[0] and top_left[1] < bottom_right[1])\n\n    def check_overlap(top_left1, bottom_right1, top_left2, bottom_right2):\n        return not (top_left1[0] > bottom_right2[0] or top_left1[1] > bottom_right2[1] or\n                    bottom_right1[0] < top_left2[0] or bottom_right1[1] < top_left2[1])\n\n    def find_match(top_left, bottom_right, idx, result):\n        if idx == n:\n            return True\n\n        for i in range(n):\n            if i in result or not is_valid(top_left[i], bottom_right[i]):\n                continue\n\n            for j in range(n):\n                if j in result or i == j or not check_overlap(top_left[i], bottom_right[i], top_left[j], bottom_right[j]):\n                    continue\n\n                result[idx] = i + 1\n                if find_match(top_left, bottom_right, idx + 1, result):\n                    return True\n                result.pop(idx)\n\n        return False\n\n    result = {}\n    if find_match(top_left, bottom_right, 0, result):\n        return '\\n'.join(str(result[i]) for i in range(n))\n    else:\n        return 'syntax error'"
    },
    {
        "number": 3046,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(top_left, bottom_right):\n        return all(c1 <= c2 for c1, c2 in zip(top_left, bottom_right))\n\n    def intersects(r1, r2):\n        return any(t <= r1 <= b or t <= r2 <= b for t, b in intersections)\n\n    def find_matching(top_left):\n        for j, bottom_right in enumerate(bottom_rights):\n            if is_valid(top_left, bottom_right) and not intersects(top_left[0], bottom_right[0]) and not intersects(top_left[1], bottom_right[1]):\n                return j\n        return -1\n\n    n = int(stdin.readline())\n    top_lefts = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    bottom_rights = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    intersections = [(t, b) for t, b in zip(top_lefts, bottom_rights)]\n\n    result = [find_matching(top_left) for top_left in top_lefts]\n\n    if all(r != -1 for r in result):\n        return \"\\n\".join(map(str, result))\n    else:\n        return \"syntax error\""
    },
    {
        "number": 3046,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    top_left = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    bottom_right = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    def is_valid(i, j):\n        return all(top_left[i][d] <= bottom_right[j][d] for d in range(2))\n\n    def find_valid_pairs():\n        valid_pairs = []\n        for i in range(n):\n            for j in range(n):\n                if is_valid(i, j):\n                    valid_pairs.append((i, j))\n        return valid_pairs\n\n    def find_valid_permutation(valid_pairs):\n        used = [False] * len(valid_pairs)\n        permutation = []\n        for i in range(n):\n            for j, pair in enumerate(valid_pairs):\n                if pair[0] == i and not used[j]:\n                    permutation.append(pair[1] + 1)\n                    used[j] = True\n                    break\n            else:\n                return None\n        return permutation\n\n    valid_pairs = find_valid_pairs()\n    permutation = find_valid_permutation(valid_pairs)\n\n    if permutation is None:\n        return \"syntax error\"\n    else:\n        return \"\\n\".join(map(str, permutation))"
    },
    {
        "number": 3046,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    topleft = []\n    bottomright = []\n    for _ in range(n):\n        topleft.append(list(map(int, stdin.readline().split())))\n    for _ in range(n):\n        bottomright.append(list(map(int, stdin.readline().split())))\n\n    def is_valid(topleft_index, bottomright_index):\n        if topleft_index < 0 or bottomright_index < 0:\n            return False\n        if topleft[topleft_index][0] > bottomright[bottomright_index][0] or \\\n                topleft[topleft_index][1] > bottomright[bottomright_index][1]:\n            return False\n        for i in range(topleft_index):\n            if topleft[i][0] <= topleft[topleft_index][0] <= topleft[i][1] and \\\n                    topleft[i][1] <= bottomright[bottomright_index][1] <= topleft[i][2]:\n                return False\n            if bottomright[i][0] <= topleft[topleft_index][0] <= bottomright[i][1] and \\\n                    bottomright[i][1] <= bottomright[bottomright_index][1] <= bottomright[i][2]:\n                return False\n        return True\n\n    def backtrack(topleft_index, bottomright_index, result):\n        if topleft_index == n:\n            return result\n        if bottomright_index == n:\n            return backtrack(topleft_index + 1, 0, result)\n        if is_valid(topleft_index, bottomright_index):\n            result.append(bottomright_index + 1)\n            if backtrack(topleft_index, bottomright_index + 1, result):\n                return True\n            result.pop()\n        return backtrack(topleft_index, bottomright_index + 1, result)\n\n    result = []\n    if backtrack(0, 0, result):\n        return '\\n'.join(map(str, result)) + '\\n'\n    else:\n        return 'syntax error\\n'"
    },
    {
        "number": 3046,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    input_lines = stdin.split('\\n')[1:]\n    input_top_left = [tuple(map(int, input_lines[i].split())) for i in range(n)]\n    input_bottom_right = [tuple(map(int, input_lines[i].split())) for i in range(n, 2*n)]\n\n    def check_valid_rectangle(rect1, rect2):\n        r1, c1, r2, c2 = rect1\n        R1, C1, R2, C2 = rect2\n        if r1 <= R1 <= r2 and c1 <= C1 <= c2 and r1 <= R2 <= r2 and c1 <= C2 <= c2:\n            return True\n        return False\n\n    def dfs(rectangles, sorted_rectangles, visited):\n        if len(sorted_rectangles) == n:\n            return sorted_rectangles\n        for i in range(n):\n            if not visited[i]:\n                for j in range(n):\n                    if not visited[j] and check_valid_rectangle(input_top_left[i], input_bottom_right[j]):\n                        visited[i] = True\n                        visited[j] = True\n                        if dfs(rectangles, sorted_rectangles + [j+1], visited):\n                            return sorted_rectangles + [j+1]\n                        visited[i] = False\n                        visited[j] = False\n        return None\n\n    sorted_rectangles = dfs(input_top_left, [], [False] * n)\n    if sorted_rectangles:\n        return '\\n'.join(map(str, sorted_rectangles))\n    else:\n        return \"syntax error\""
    },
    {
        "number": 3046,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    top_left = []\n    bottom_right = []\n    for i in range(n):\n        top_left.append(list(map(int, stdin.readline().strip().split())) + [i])\n        bottom_right.append(list(map(int, stdin.readline().strip().split())) + [i])\n\n    def check_rectangles(top_left, bottom_right):\n        n = len(top_left)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if top_left[i][0] == bottom_right[j][0] or top_left[i][1] == bottom_right[j][1]:\n                    return False\n        return True\n\n    def find_rectangles(top_left, bottom_right):\n        n = len(top_left)\n        result = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if top_left[i][0] > bottom_right[j][0] and top_left[i][1] > bottom_right[j][1]:\n                    result[i] = j + 1\n        return result\n\n    if check_rectangles(top_left, bottom_right):\n        return '\\n'.join(map(str, find_rectangles(top_left, bottom_right)))\n    else:\n        return \"syntax error\""
    },
    {
        "number": 3046,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    top_left = []\n    bottom_right = []\n    for i in range(n):\n        top_left.append(list(map(int, stdin.readline().strip().split())))\n        bottom_right.append(list(map(int, stdin.readline().strip().split())))\n\n    def is_valid(tl_row, tl_col, br_row, br_col):\n        return tl_row <= br_row and tl_col <= br_col\n\n    def is_nested(rect1, rect2):\n        tl_row1, tl_col1, br_row1, br_col1 = rect1\n        tl_row2, tl_col2, br_row2, br_col2 = rect2\n        if is_valid(tl_row1, tl_col1, tl_row2, tl_col2) and is_valid(br_row1, br_col1, br_row2, br_col2):\n            return True\n        return False\n\n    def find_nested_rectangles(top_left, bottom_right):\n        nested_rectangles = []\n        for i in range(n):\n            for j in range(n):\n                if i != j and is_nested(top_left[i], bottom_right[j]):\n                    nested_rectangles.append((i, j))\n        return nested_rectangles\n\n    def has_cycle(nested_rectangles, node, visited, recursion_stack):\n        if node not in visited:\n            visited.add(node)\n            recursion_stack.add(node)\n            for neighbor in nested_rectangles[node]:\n                if neighbor not in visited or (neighbor in recursion_stack and has_cycle(nested_rectangles, neighbor, visited, recursion_stack)):\n                    return True\n            recursion_stack.remove(node)\n        return False\n\n    nested_rectangles = find_nested_rectangles(top_left, bottom_right)\n\n    if not nested_rectangles:\n        return \"syntax error\"\n\n    if has_cycle(nested_rectangles, 0, set(), set()):\n        return \"syntax error\"\n\n    result = []\n    visited = set()\n    for i in range(n):\n        if i not in visited:\n            cycle = set()\n            node = i\n            while node not in cycle:\n                cycle.add(node)\n                node = next((neighbor for neighbor in nested_rectangles[node] if neighbor not in cycle), None)\n            order = list(cycle)\n            while order[-1] != i:\n                order.append(order.pop(0))\n            result.extend(order)\n            visited |= set(order)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3046,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    top_left = []\n    bottom_right = []\n\n    for i in range(n):\n        top_left.append(list(map(int, stdin.readline().split())))\n        bottom_right.append(list(map(int, stdin.readline().split())))\n\n    def is_valid(tl, br):\n        return tl[0] < br[0] and tl[1] < br[1]\n\n    def can_nest(tl1, br1, tl2, br2):\n        return (\n            is_valid(tl1, br1)\n            and is_valid(tl2, br2)\n            and (\n                (tl1[0] < tl2[0] and br1[0] > tl2[0] and br1[1] > tl2[1] and tl1[1] < br2[1])\n                or (tl1[1] < tl2[1] and br1[1] > tl2[1] and br1[0] > tl2[0] and tl1[0] < br2[0])\n            )\n        )\n\n    def is_nested(top_left, bottom_right):\n        for i in range(n):\n            if i != top_left and can_nest(\n                top_left, bottom_right, top_left[i], bottom_right[i]\n            ):\n                return True\n        return False\n\n    result = []\n    for i in range(n):\n        for j in range(n):\n            if i != j and is_valid(top_left[i], bottom_right[j]) and not is_nested(top_left[i], bottom_right[j]):\n                result.append((i, j))\n\n    if len(result) == n:\n        for i in range(n):\n            for r in result:\n                if r[0] == i:\n                    print(r[1])\n                    break\n    else:\n        print(\"syntax error\")\n\n    return \"\""
    },
    {
        "number": 3047,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def compute_proportion(a, b, c, d):\n        if a == 0 or b == 0 or c == 0 or d == 0:\n            return 0\n        if a * d == b * c:\n            return 1\n        gcd_ab = gcd(a, b)\n        gcd_cd = gcd(c, d)\n        return (a // gcd_ab) * (c // gcd_cd)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def find_distinct_solutions(top_row, bottom_row):\n        distinct_solutions = set()\n        for sal_b in range(201):\n            for yet_s in range(201):\n                for golem_d in range(201):\n                    for imp_d in range(201):\n                        for kraken_s in range(201):\n                            proportions = [\n                                compute_proportion(sal_b, top_row[0], bottom_row[0], top_row[1]),\n                                compute_proportion(yet_s, top_row[2], bottom_row[2], top_row[3]),\n                                compute_proportion(golem_d, top_row[4], bottom_row[4], top_row[5]),\n                                compute_proportion(imp_d, top_row[6], bottom_row[6], top_row[7]),\n                                compute_proportion(kraken_s, top_row[8], bottom_row[8], top_row[9])\n                            ]\n                            if all(p > 0 for p in proportions):\n                                distinct_solutions.add(tuple(proportions))\n        return len(distinct_solutions)\n\n    input_data = stdin.split('\\n')\n    top_row = [int(x) if x != '_' else None for x in input_data[0].split()]\n    bottom_row = [int(x) if x != '_' else None for x in input_data[1].split()]\n\n    result = find_distinct_solutions(top_row, bottom_row)\n    return str(result)"
    },
    {
        "number": 3047,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def check_solution(solution, burger, slop, sushi, drumstick):\n        for i in range(len(burger)):\n            if burger[i] * drumstick[i] != slop[i] * sushi[i]:\n                return False\n        return True\n\n    def find_solutions(burger, slop, sushi, drumstick):\n        solutions = []\n        for b in range(201):\n            for s in range(201):\n                for d in range(201):\n                    if b * d == slop[0] * sushi[0] and b * d != burger[0] * drumstick[0]:\n                        burger[1] = b\n                        slop[1] = slop[0] * sushi[0] // b\n                        sushi[1] = slop[0] * sushi[0] // b\n                        drumstick[1] = d\n                        if check_solution([b, slop[0], s, d], burger, slop, sushi, drumstick):\n                            solutions.append([b, slop[0], s, d])\n        return solutions\n\n    lines = stdin.split('\\n')\n    top_row = list(map(int, lines[0].split(' ')))\n    bottom_row = list(map(int, lines[1].split(' ')))\n\n    burger = [top_row[0], top_row[2]]\n    slop = [top_row[1], top_row[3]]\n    sushi = [bottom_row[0], bottom_row[2]]\n    drumstick = [bottom_row[1], bottom_row[3]]\n\n    solutions = find_solutions(burger, slop, sushi, drumstick)\n    if len(solutions) == 0:\n        return \"many\"\n    elif len(solutions) == 1:\n        return \"1\"\n    else:\n        return str(len(solutions))"
    },
    {
        "number": 3047,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def compute_solution(top_row, bot_row):\n        n_solutions = 1\n        for i in range(1, 4):\n            n_solutions = lcm(n_solutions, top_row[i])\n        for i in range(1, 4):\n            n_solutions = lcm(n_solutions, bot_row[i])\n        return n_solutions\n\n    input_data = stdin.split(\"\\n\")\n    top_row = list(map(int, input_data[0].split()))\n    bot_row = list(map(int, input_data[1].split()))\n\n    if any(x == 0 for x in top_row) or any(x == 0 for x in bot_row):\n        return \"many\"\n\n    top_row = [x if x != _ else None for x in top_row]\n    bot_row = [x if x != _ else None for x in bot_row]\n\n    if top_row[0] is None:\n        top_row[0] = bot_row[0] * top_row[2] // bot_row[2]\n    if top_row[1] is None:\n        top_row[1] = bot_row[1] * top_row[2] // bot_row[2]\n    if top_row[3] is None:\n        top_row[3] = bot_row[3] * top_row[2] // bot_row[2]\n    if top_row[4] is None:\n        top_row[4] = bot_row[4] * top_row[2] // bot_row[2]\n\n    if bot_row[0] is None:\n        bot_row[0] = top_row[0] * bot_row[2] // top_row[2]\n    if bot_row[1] is None:\n        bot_row[1] = top_row[1] * bot_row[2] // top_row[2]\n    if bot_row[3] is None:\n        bot_row[3] = top_row[3] * bot_row[2] // top_row[2]\n    if bot_row[4] is None:\n        bot_row[4] = top_row[4] * bot_row[2] // top_row[2]\n\n    return str(compute_solution(top_row, bot_row))"
    },
    {
        "number": 3047,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split(\"\\n\")\n    top_row = input_values[0].split()\n    bottom_row = input_values[1].split()\n\n    def find_solutions(row_1, row_2):\n        solutions = []\n        for burger in range(1, 201):\n            for slop in range(1, 201):\n                for sushi in range(1, 201):\n                    for drumstick in range(1, 201):\n                        if row_1[0] == \"_\":\n                            sal_burger = burger\n                        else:\n                            sal_burger = int(row_1[0])\n\n                        if row_1[1] == \"_\":\n                            sal_slop = slop\n                        else:\n                            sal_slop = int(row_1[1])\n\n                        if row_2[0] == \"_\":\n                            sal_sushi = sushi\n                        else:\n                            sal_sushi = int(row_2[0])\n\n                        if row_2[1] == \"_\":\n                            sal_drumstick = drumstick\n                        else:\n                            sal_drumstick = int(row_2[1])\n\n                        if row_1[2] == \"_\":\n                            yeti_burger = sal_burger * 2\n                        else:\n                            yeti_burger = int(row_1[2])\n\n                        if row_1[3] == \"_\":\n                            yeti_slop = sal_slop * 2\n                        else:\n                            yeti_slop = int(row_1[3])\n\n                        if row_2[2] == \"_\":\n                            yeti_sushi = sal_sushi * 2\n                        else:\n                            yeti_sushi = int(row_2[2])\n\n                        if row_2[3] == \"_\":\n                            yeti_drumstick = sal_drumstick * 2\n                        else:\n                            yeti_drumstick = int(row_2[3])\n\n                        if row_1[4] == \"_\":\n                            golem_burger = sal_burger * 3\n                        else:\n                            golem_burger = int(row_1[4])\n\n                        if row_1[5] == \"_\":\n                            golem_slop = sal_slop * 3\n                        else:\n                            golem_slop = int(row_1[5])\n\n                        if row_2[4] == \"_\":\n                            golem_sushi = sal_sushi * 3\n                        else:\n                            golem_sushi = int(row_2[4])\n\n                        if row_2[5] == \"_\":\n                            golem_drumstick = sal_drumstick * 3\n                        else:\n                            golem_drumstick = int(row_2[5])\n\n                        if row_1[6] == \"_\":\n                            imp_burger = sal_burger * 4\n                        else:\n                            imp_burger = int(row_1[6])\n\n                        if row_1[7] == \"_\":\n                            imp_slop = sal_slop * 4\n                        else:\n                            imp_slop = int(row_1[7])\n\n                        if row_2[6] == \"_\":\n                            imp_sushi = sal_sushi * 4\n                        else:\n                            imp_sushi = int(row_2[6])\n\n                        if row_2[7] == \"_\":\n                            imp_drumstick = sal_drumstick * 4\n                        else:\n                            imp_drumstick = int(row_2[7])\n\n                        if row_1[8] == \"_\":\n                            kraken_burger = sal_burger * 5\n                        else:\n                            kraken_burger = int(row_1[8])\n\n                        if row_1[9] == \"_\":\n                            kraken_slop = sal_slop * 5"
    },
    {
        "number": 3047,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    top_row = [int(x) if x != '_' else x for x in input_lines[0].split(' ')]\n    bottom_row = [int(x) if x != '_' else x for x in input_lines[1].split(' ')]\n\n    def find_proportions(row, indices):\n        proportions = []\n        for i in range(len(indices) - 1):\n            if row[indices[i]] != '_' and row[indices[i + 1]] != '_':\n                proportions.append(row[indices[i]] / row[indices[i + 1]])\n        return proportions\n\n    def find_unknowns(row, indices):\n        unknowns = []\n        for i in range(len(indices) - 1):\n            if row[indices[i]] == '_' and row[indices[i + 1]] != '_':\n                unknowns.append(i)\n        return unknowns\n\n    def find_solutions(top_row, bottom_row):\n        solutions = set()\n        top_proportions = find_proportions(top_row, [0, 2, 4, 6, 8])\n        bottom_proportions = find_proportions(bottom_row, [0, 2, 4, 6, 8])\n        top_unknowns = find_unknowns(top_row, [0, 2, 4, 6, 8])\n        bottom_unknowns = find_unknowns(bottom_row, [0, 2, 4, 6, 8])\n\n        def fill_unknowns(top_row, bottom_row, top_unknowns, bottom_unknowns, index, value):\n            if index < len(top_unknowns):\n                top_row[top_unknowns[index]] = value * top_proportions[index]\n                bottom_row[bottom_unknowns[index]] = value\n                fill_unknowns(top_row, bottom_row, top_unknowns, bottom_unknowns, index + 1, value)\n            else:\n                solutions.add(tuple(top_row + bottom_row))\n\n        for i in range(len(top_unknowns)):\n            fill_unknowns(top_row, bottom_row, top_unknowns, bottom_unknowns, i, top_proportions[i])\n\n        return solutions\n\n    solutions = find_solutions(top_row, bottom_row)\n\n    if len(solutions) == 1:\n        return '1'\n    elif len(solutions) > 1:\n        return 'many'\n    else:\n        return '0'"
    },
    {
        "number": 3047,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    top_row = lines[0].split()\n    bottom_row = lines[1].split()\n\n    # Extract known values from the input\n    known_values = []\n    for i in range(10):\n        if top_row[i] != '_' and bottom_row[i] != '_':\n            known_values.append((int(top_row[i]), int(bottom_row[i])))\n\n    # Calculate the ratios\n    ratios = []\n    for i in range(4):\n        if known_values[i][0] != 0 and known_values[i][1] != 0:\n            ratio = known_values[i][0] / known_values[i][1]\n            ratios.append(ratio)\n\n    # Check if there is a unique solution\n    if len(set(ratios)) != 1:\n        return \"many\"\n\n    # Calculate the number of distinct solutions\n    distinct_solutions = 1\n    for i in range(4, 8):\n        if known_values[i][0] != 0:\n            distinct_solutions *= int(known_values[i][0] / ratios[0])\n        elif known_values[i][1] != 0:\n            distinct_solutions *= int(known_values[i][1] * ratios[0])\n\n    return str(distinct_solutions)"
    },
    {
        "number": 3047,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_solutions(top_row, bottom_row):\n        solutions = set()\n        for slop in range(1, 201):\n            for sushi in range(1, 201):\n                for drumstick in range(1, 201):\n                    for burger in range(1, 201):\n                        if slop == sushi == burger == drumstick:\n                            continue\n                        if (slop, sushi) == (top_row[0], bottom_row[0]):\n                            if (burger, drumstick) == (top_row[1], bottom_row[1]):\n                                solutions.add((slop, sushi, burger, drumstick))\n                        elif (slop, sushi) == (top_row[1], bottom_row[1]):\n                            if (burger, drumstick) == (top_row[0], bottom_row[0]):\n                                solutions.add((slop, sushi, burger, drumstick))\n        return solutions\n\n    def is_consistent(solutions, top_row, bottom_row):\n        for solution in solutions:\n            if solution[0] != top_row[0] and solution[1] != top_row[1]:\n                return False\n            if solution[2] != bottom_row[0] and solution[3] != bottom_row[1]:\n                return False\n        return True\n\n    input_rows = stdin.strip().split('\\n')\n    top_row = [int(x) if x != '_' else None for x in input_rows[0].split(' ')]\n    bottom_row = [int(x) if x != '_' else None for x in input_rows[1].split(' ')]\n\n    solutions = find_solutions(top_row, bottom_row)\n    if not is_consistent(solutions, top_row, bottom_row):\n        return \"many\"\n\n    return str(len(solutions))"
    },
    {
        "number": 3047,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_data = stdin.split(\"\\n\")\n    top_row = input_data[0].split()\n    bottom_row = input_data[1].split()\n\n    # Initialize variables\n    salamander = [top_row[0], top_row[1], bottom_row[0], bottom_row[1]]\n    yeti = [top_row[2], top_row[3], bottom_row[2], bottom_row[3]]\n    golem = [top_row[4], top_row[5], bottom_row[4], bottom_row[5]]\n    imp = [top_row[6], top_row[7], bottom_row[6], bottom_row[7]]\n    kraken = [top_row[8], top_row[9], bottom_row[8], bottom_row[9]]\n\n    # Calculate the number of distinct solutions\n    def count_solutions(monster, other_monsters):\n        count = 0\n        for i in range(4):\n            if monster[i] == \"_\":\n                for j in range(4):\n                    if other_monsters[j] != \"_\":\n                        monster[i] = str(int(other_monsters[j]) * int(monster[j]) // int(other_monsters[j]))\n                        count += count_solutions(monster, other_monsters)\n                        monster[i] = \"_\"\n                return count\n        return 1\n\n    total_solutions = count_solutions(salamander, yeti) + count_solutions(yeti, golem) + count_solutions(golem, imp) + count_solutions(imp, kraken) + count_solutions(kraken, salamander)\n\n    if total_solutions == 1:\n        return \"1\"\n    elif total_solutions > 1000000:\n        return \"many\"\n    else:\n        return str(total_solutions) "
    },
    {
        "number": 3047,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    top = list(map(int, stdin.split()[0:10]))\n    bottom = list(map(int, stdin.split()[10:]))\n\n    def get_proportions(plate):\n        if plate[0] == 0 or plate[1] == 0 or plate[2] == 0 or plate[3] == 0:\n            return None\n        return [plate[i] / plate[0] for i in range(1, 4)]\n\n    def fill_plate(top_plate, bottom_plate, proportions):\n        if proportions is None:\n            return None\n        new_plate = [top_plate[0]]\n        for i in range(1, 4):\n            new_plate.append(int(top_plate[0] * proportions[i - 1]))\n        new_plate.extend(bottom_plate[4:])\n        return new_plate\n\n    def count_solutions(plate1, plate2, proportions):\n        if proportions is None:\n            return \"many\"\n        solution1 = fill_plate(top[0:4], bottom[0:4], proportions)\n        solution2 = fill_plate(top[4:], bottom[4:], proportions)\n        if solution1 is None or solution2 is None:\n            return \"many\"\n        if solution1 == solution2:\n            return 1\n        return \"many\"\n\n    top_proportions = get_proportions(top)\n    bottom_proportions = get_proportions(bottom)\n    top_solutions = count_solutions(top[0:4], bottom[0:4], top_proportions)\n    bottom_solutions = count_solutions(top[4:], bottom[4:], bottom_proportions)\n\n    if top_solutions == bottom_solutions:\n        return str(top_solutions)\n    return \"many\""
    },
    {
        "number": 3047,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    top_row = input_list[0].split()\n    bottom_row = input_list[1].split()\n\n    # Fill the known values in the plate\n    plate = [[None] * 4 for _ in range(5)]\n    plate[0][0] = top_row[0] if top_row[0] != '_' else None\n    plate[0][1] = top_row[1] if top_row[1] != '_' else None\n    plate[0][2] = bottom_row[0] if bottom_row[0] != '_' else None\n    plate[0][3] = bottom_row[1] if bottom_row[1] != '_' else None\n    plate[1][0] = top_row[2] if top_row[2] != '_' else None\n    plate[1][1] = top_row[3] if top_row[3] != '_' else None\n    plate[1][2] = bottom_row[2] if bottom_row[2] != '_' else None\n    plate[1][3] = bottom_row[3] if bottom_row[3] != '_' else None\n    plate[2][0] = top_row[4] if top_row[4] != '_' else None\n    plate[2][1] = top_row[5] if top_row[5] != '_' else None\n    plate[2][2] = bottom_row[4] if bottom_row[4] != '_' else None\n    plate[2][3] = bottom_row[5] if bottom_row[5] != '_' else None\n    plate[3][0] = top_row[6] if top_row[6] != '_' else None\n    plate[3][1] = top_row[7] if top_row[7] != '_' else None\n    plate[3][2] = bottom_row[6] if bottom_row[6] != '_' else None\n    plate[3][3] = bottom_row[7] if bottom_row[7] != '_' else None\n    plate[4][0] = top_row[8] if top_row[8] != '_' else None\n    plate[4][1] = top_row[9] if top_row[9] != '_' else None\n    plate[4][2] = bottom_row[8] if bottom_row[8] != '_' else None\n    plate[4][3] = bottom_row[9] if bottom_row[9] != '_' else None\n\n    def solve(i, j, value):\n        if i == 5 and j == 4:\n            return 1\n        if i < 0 or i > 4 or j < 0 or j > 3:\n            return 0\n        if plate[i][j] is not None:\n            if plate[i][j] != value:\n                return 0\n            else:\n                return solve(i + 1, j, value) + solve(i - 1, j, value) + solve(i, j + 1, value) + solve(i, j - 1, value)\n        else:\n            count = 0\n            for k in range(1, 201):\n                plate[i][j] = k\n                count += solve(i + 1, j, value * k) + solve(i - 1, j, value * k) + solve(i, j + 1, value * k) + solve(i, j - 1, value * k)\n                plate[i][j] = None\n            return count\n\n    result = solve(0, 0, 1)\n    if result > 10**5:\n        return \"many\"\n    else:\n        return str(result)"
    },
    {
        "number": 3048,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, edges = int(stdin.splitlines()[0]), [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    \n    adjacency = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adjacency[u].append(v)\n        adjacency[v].append(u)\n    \n    paths = 0\n    for u in range(1, N + 1):\n        for v in adjacency[u]:\n            for w in adjacency[u]:\n                if v != w and v in adjacency[w]:\n                    paths += 1\n    \n    return str(paths // 2)"
    },
    {
        "number": 3048,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_optimal_paths(n, roads):\n        adj_list = [[] for _ in range(n)]\n        for u, v in roads:\n            adj_list[u - 1].append(v - 1)\n            adj_list[v - 1].append(u - 1)\n\n        def dfs(start, visited, path):\n            if len(path) == 2:\n                if start == path[0] and path[1] in adj_list[start] and path[0] in adj_list[path[1]]:\n                    return [path]\n                return []\n\n            paths = []\n            for neighbor in adj_list[start]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    paths.extend(dfs(neighbor, visited, path + [neighbor]))\n                    visited.remove(neighbor)\n            return paths\n\n        optimal_paths = []\n        for junction in range(n):\n            visited = {junction}\n            optimal_paths.extend(dfs(junction, visited, [junction]))\n\n        return optimal_paths\n\n    def count_optimal_paths(optimal_paths):\n        count = 0\n        for path in optimal_paths:\n            if path[0] == path[1]:\n                continue\n            count += 1\n        return count\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    roads = [list(map(int, line.split())) for line in lines[1:]]\n\n    optimal_paths = find_optimal_paths(n, roads)\n    count = count_optimal_paths(optimal_paths)\n\n    return str(count)"
    },
    {
        "number": 3048,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, *roads = list(map(int, stdin.strip().split()))\n    paths = []\n    adj_list = {i: [] for i in range(1, N + 1)}\n\n    for u, v in zip(roads[::2], roads[1::2]):\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def dfs(src, dst, visited, path, length):\n        if src == dst and length == 2:\n            paths.append(path)\n            return\n\n        visited.add(src)\n        for neighbor in adj_list[src]:\n            if neighbor not in visited:\n                dfs(neighbor, dst, visited, path + [neighbor], length + 1)\n        visited.remove(src)\n\n    for u in range(1, N + 1):\n        for v in range(1, N + 1):\n            if u != v:\n                dfs(u, v, set(), [u], 0)\n\n    return str(len(paths))"
    },
    {
        "number": 3048,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_optimal_paths(graph, start, end, visited, path_length, current_path, optimal_paths):\n        if start == end and path_length == 2:\n            optimal_paths.append(current_path[:])\n            return\n\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                current_path.append(neighbor)\n                find_optimal_paths(graph, neighbor, end, visited, path_length + 1, current_path, optimal_paths)\n                current_path.pop()\n                visited.remove(neighbor)\n\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    edges = input_data[1:]\n\n    graph = {i: [] for i in range(1, n + 1)}\n    for edge in edges:\n        u, v = edge\n        graph[u].append(v)\n        graph[v].append(u)\n\n    optimal_paths = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j:\n                visited = set()\n                current_path = [i]\n                find_optimal_paths(graph, i, j, visited, 1, current_path, optimal_paths)\n\n    return str(len(optimal_paths))"
    },
    {
        "number": 3048,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(map(int, stdin.split()))\n    N = stdin[0]\n    adj = {i: [] for i in range(1, N + 1)}\n\n    for i in range(N - 1):\n        u, v = stdin[i * 2 + 1], stdin[i * 2 + 2]\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def is_optimal(u: int, v: int, visited: set) -> bool:\n        if u == v:\n            return False\n        visited.add(u)\n        for neighbor in adj[u]:\n            if neighbor not in visited:\n                if is_optimal(neighbor, v, visited):\n                    return True\n        return False\n\n    def count_paths(u: int, v: int, visited: set) -> int:\n        if u == v:\n            return 1\n        visited.add(u)\n        count = 0\n        for neighbor in adj[u]:\n            if neighbor not in visited:\n                count += count_paths(neighbor, v, visited)\n        return count\n\n    optimal_paths = 0\n    for u in range(1, N + 1):\n        for v in range(1, N + 1):\n            if u == v:\n                continue\n            if is_optimal(u, v, set()):\n                optimal_paths += count_paths(u, v, set())\n\n    return str(optimal_paths)"
    },
    {
        "number": 3048,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    adj_list = [[] for _ in range(N + 1)]\n    for i in range(1, N):\n        u, v = map(int, lines[i].split())\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    count = 0\n    for i in range(1, N + 1):\n        for j in adj_list[i]:\n            for k in adj_list[j]:\n                if k != i and k in adj_list[i]:\n                    count += 1\n\n    return str(count // 2)"
    },
    {
        "number": 3048,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    adj_list = [[] for _ in range(N + 1)]\n\n    for line in lines[1:]:\n        u, v = map(int, line.split())\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    paths = 0\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i != j:\n                for k in adj_list[i]:\n                    if k != j and j in adj_list[k]:\n                        paths += 1\n\n    return str(paths // 2)"
    },
    {
        "number": 3048,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_optimal_paths(adj_list):\n        optimal_paths = []\n        for u in range(1, N + 1):\n            for v in range(1, N + 1):\n                if u != v and (u, v) in adj_list[u] and (v, u) in adj_list[v]:\n                    for path in adj_list[u][(v, 1)]:\n                        if len(path) == 2:\n                            optimal_paths.append(path)\n        return optimal_paths\n\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        N = int(lines[0])\n        adj_list = {i: {} for i in range(1, N + 1)}\n        for line in lines[1:]:\n            u, v = map(int, line.split())\n            adj_list[u][(v, 1)] = [[u, v]]\n            adj_list[v][(u, 1)] = [[v, u]]\n        return N, adj_list\n\n    N, adj_list = parse_input(stdin)\n    optimal_paths = find_optimal_paths(adj_list)\n    return str(len(optimal_paths))"
    },
    {
        "number": 3048,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, roads = int(stdin.split(\"\\n\")[0]), [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    paths = 0\n\n    for u, v in roads:\n        for w in range(1, N + 1):\n            if (u, w) in roads and (w, v) in roads:\n                paths += 1\n\n    return str(paths)"
    },
    {
        "number": 3048,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    N = input_data[0]\n    graph = [[] for _ in range(N + 1)]\n    for i in range(1, N):\n        u, v = input_data[i * 2 - 1], input_data[i * 2]\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, visited, distance):\n        if distance == 2:\n            return 1\n        if node > N or distance > 2:\n            return 0\n        if visited[node]:\n            return 0\n        visited[node] = True\n        result = 0\n        for neighbor in graph[node]:\n            result += dfs(neighbor, visited, distance + 1)\n        visited[node] = False\n        return result\n\n    count = 0\n    visited = [False] * (N + 1)\n    for i in range(1, N + 1):\n        count += dfs(i, visited, 0)\n    return str(count)"
    },
    {
        "number": 3049,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    encrypted_fragment = ''.join([chr(ord(c) - 97) for c in decrypted_fragment])\n\n    count = encrypted_message.count(encrypted_fragment)\n    if count == 1:\n        start = encrypted_message.find(encrypted_fragment)\n        return encrypted_message[start:start + len(encrypted_fragment)]\n    else:\n        return str(count)"
    },
    {
        "number": 3049,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    encrypted_len = len(encrypted_message)\n    fragment_len = len(decrypted_fragment)\n\n    # Check if the decrypted fragment is part of the encrypted message\n    count = 0\n    for i in range(encrypted_len - fragment_len + 1):\n        if encrypted_message[i:i + fragment_len] == decrypted_fragment:\n            count += 1\n            start_position = i\n\n    if count == 1:\n        return encrypted_message[start_position:start_position + fragment_len]\n    else:\n        return str(count)"
    },
    {
        "number": 3049,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n\n    # Find the positions where the decrypted fragment could occur in the encrypted message\n    positions = []\n    for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n        match = True\n        for j in range(len(decrypted_fragment)):\n            if encrypted_message[i + j] != decrypted_fragment[j]:\n                match = False\n                break\n        if match:\n            positions.append(i)\n\n    # If there is a unique position, return the corresponding substring\n    if len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0] + len(decrypted_fragment)]\n    else:\n        return str(len(positions))"
    },
    {
        "number": 3049,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split(\"\\n\")\n    decrypted_fragment = decrypted_fragment.strip()\n\n    if decrypted_fragment in encrypted_message:\n        return decrypted_fragment\n    else:\n        count = 0\n        for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n            if encrypted_message[i:i + len(decrypted_fragment)] == decrypted_fragment:\n                count += 1\n        return str(count)"
    },
    {
        "number": 3049,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    possible_positions = []\n\n    for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n        substring = encrypted_message[i:i + len(decrypted_fragment)]\n        if decrypted_fragment in substring:\n            possible_positions.append(i)\n\n    if len(possible_positions) == 1:\n        return encrypted_message[possible_positions[0]:possible_positions[0] + len(decrypted_fragment)]\n    else:\n        return str(len(possible_positions))"
    },
    {
        "number": 3049,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    encrypted, fragment = stdin.split('\\n')\n    positions = []\n    for i in range(len(encrypted) - len(fragment) + 1):\n        if encrypted[i:i + len(fragment)] == fragment:\n            positions.append(i)\n    if not positions:\n        return '0'\n    if len(positions) == 1:\n        return encrypted[positions[0]:positions[0] + len(fragment)]\n    return str(len(positions))"
    },
    {
        "number": 3049,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    fragment_length = len(decrypted_fragment)\n\n    def count_fragment_occurrences(message: str) -> int:\n        count = 0\n        for i in range(len(message) - fragment_length + 1):\n            if message[i:i + fragment_length] == decrypted_fragment:\n                count += 1\n        return count\n\n    occurrences = count_fragment_occurrences(encrypted_message)\n\n    if occurrences == 1:\n        for i in range(len(encrypted_message) - fragment_length + 1):\n            if encrypted_message[i:i + fragment_length] == decrypted_fragment:\n                return encrypted_message[i:i + fragment_length]\n    else:\n        return str(occurrences)"
    },
    {
        "number": 3049,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    encrypted_fragment = ''.join([chr(ord('a') + (ord(c) - ord('a') - i) % 26) for i, c in enumerate(decrypted_fragment)])\n    positions = [i for i in range(len(encrypted_message) - len(decrypted_fragment) + 1) if encrypted_message[i:i + len(decrypted_fragment)] == encrypted_fragment]\n\n    if len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0] + len(decrypted_fragment)]\n    else:\n        return str(len(positions))"
    },
    {
        "number": 3049,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    encrypted_length = len(encrypted_message)\n    fragment_length = len(decrypted_fragment)\n\n    if fragment_length > encrypted_length:\n        return '0'\n\n    possible_positions = []\n    for i in range(encrypted_length - fragment_length + 1):\n        if encrypted_message[i:i + fragment_length] == decrypted_fragment:\n            possible_positions.append(i)\n\n    if len(possible_positions) == 1:\n        return encrypted_message[possible_positions[0]:possible_positions[0] + fragment_length]\n    else:\n        return str(len(possible_positions))"
    },
    {
        "number": 3049,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    decrypted_fragment_len = len(decrypted_fragment)\n    encrypted_message_len = len(encrypted_message)\n    total_possibilities = encrypted_message_len - decrypted_fragment_len + 1\n\n    if total_possibilities < 1 or decrypted_fragment_len > encrypted_message_len:\n        return \"0\"\n\n    for i in range(total_possibilities):\n        encrypted_substring = encrypted_message[i:i + decrypted_fragment_len]\n        if encrypted_substring == decrypted_fragment:\n            return encrypted_substring\n\n    return str(total_possibilities)"
    },
    {
        "number": 3050,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(grid, current_position, move):\n        new_position = list(current_position)\n        if move == \"<\":\n            new_position[1] -= 1\n        elif move == \">\":\n            new_position[1] += 1\n        elif move == \"^\":\n            new_position[0] -= 1\n        elif move == \"v\":\n            new_position[0] += 1\n\n        return (\n            new_position[0] >= 0\n            and new_position[0] < len(grid)\n            and new_position[1] >= 0\n            and new_position[1] < len(grid[0])\n            and grid[new_position[0]][new_position[1]] != \"#\"\n        )\n\n    def find_trail_length(grid, initial_position, program):\n        current_position = initial_position\n        visited = {tuple(current_position)}\n        trail = [current_position[:]]\n\n        for move in program:\n            if is_valid_move(grid, current_position, move):\n                if move == \"<\":\n                    current_position[1] -= 1\n                elif move == \">\":\n                    current_position[1] += 1\n                elif move == \"^\":\n                    current_position[0] -= 1\n                elif move == \"v\":\n                    current_position[0] += 1\n\n                if tuple(current_position) not in visited:\n                    visited.add(tuple(current_position))\n                    trail.append(current_position[:])\n\n        return len(trail)\n\n    def find_x(trail):\n        for i in range(1, len(trail) // 2 + 1):\n            if trail[-i:] == trail[-i * 2 : -i]:\n                return i\n        return 1\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    program = lines[1]\n    grid = []\n    initial_position = None\n\n    for i in range(N):\n        row = lines[i + 2]\n        grid.append(row)\n        for j in range(N):\n            if row[j] == \"R\":\n                initial_position = [i, j]\n\n    trail_length = find_trail_length(grid, initial_position, program)\n    if trail_length == len(program):\n        return \"1\"\n    else:\n        return str(find_x(trail))"
    },
    {
        "number": 3050,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, program, grid = read_input(stdin)\n    initial_position = find_initial_position(grid)\n    trail = generate_trail(N, program, grid, initial_position)\n    X = find_repeating_subsequence_length(trail)\n    return \"1\" if X == 1 else str(X)\n\ndef"
    },
    {
        "number": 3050,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(robot_position, move):\n        if move == '^':\n            return robot_position[0] > 1\n        elif move == 'v':\n            return robot_position[0] < N - 1\n        elif move == '<':\n            return robot_position[1] > 1\n        else:\n            return robot_position[1] < N - 1\n\n    def find_suffix_repeat_length(trail):\n        X = len(trail) // 2\n        while X < len(trail):\n            suffix = trail[-X:]\n            if any(suffix == trail[i:i + len(suffix)] for i in range(len(trail) - len(suffix))):\n                return X\n            X += 1\n        return X\n\n    N, program, grid = stdin.split('\\n')\n    N = int(N)\n    robot_position = [(i, j) for i in range(N) for j in range(N) if grid[i][j] == 'R'][0]\n    grid[robot_position[0]][robot_position[1]] = '.'\n    trail = [robot_position]\n    program_length = len(program)\n    program_index = 0\n\n    while True:\n        move = program[program_index]\n        program_index = (program_index + 1) % program_length\n\n        if is_valid_move(robot_position, move):\n            if move == '^':\n                new_position = (robot_position[0] - 1, robot_position[1])\n            elif move == 'v':\n                new_position = (robot_position[0] + 1, robot_position[1])\n            elif move == '<':\n                new_position = (robot_position[0], robot_position[1] - 1)\n            else:\n                new_position = (robot_position[0], robot_position[1] + 1)\n\n            grid[robot_position[0]][robot_position[1]] = '.'\n            robot_position = new_position\n            grid[robot_position[0]][robot_position[1]] = 'R'\n            trail.append(robot_position)\n\n        if len(trail) > N * N:\n            break\n\n    return str(find_suffix_repeat_length(trail))"
    },
    {
        "number": 3050,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_position(current_position, direction):\n        if direction == '<':\n            return (current_position[0] - 1, current_position[1])\n        elif direction == '>':\n            return (current_position[0] + 1, current_position[1])\n        elif direction == '^':\n            return (current_position[0], current_position[1] - 1)\n        elif direction == 'v':\n            return (current_position[0], current_position[1] + 1)\n\n    def is_valid_position(position):\n        return 0 <= position[0] < N and 0 <= position[1] < N and grid[position[0]][position[1]] != '#'\n\n    def get_trail():\n        current_position = next(((i, j) for i in range(N) for j in range(N) if grid[i][j] == 'R'), None)\n        trail = [current_position]\n        program_index = 0\n\n        while True:\n            direction = program[program_index % len(program)]\n            next_position = get_next_position(current_position, direction)\n\n            if is_valid_position(next_position):\n                current_position = next_position\n                trail.append(current_position)\n                program_index += 1\n            else:\n                break\n\n        return trail\n\n    N, program, *grid = stdin.split('\\n')\n    N = int(N)\n\n    trail = get_trail()\n    trail_set = set(trail)\n    trail_str = ''.join([str(x) for x in trail])\n    suffixes = sorted([trail_str[i:] for i in range(len(trail))], key=lambda x: len(x))\n\n    for suffix in suffixes:\n        if suffix in trail_str:\n            X = len(suffix)\n            break\n    else:\n        X = 1\n\n    return str(X)"
    },
    {
        "number": 3050,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(grid, row, col, direction):\n        if direction == '>':\n            return grid[row][col + 1] != '#'\n        elif direction == '<':\n            return grid[row][col - 1] != '#'\n        elif direction == 'v':\n            return grid[row + 1][col] != '#'\n        elif direction == '^':\n            return grid[row - 1][col] != '#'\n        else:\n            raise ValueError(\"Invalid direction\")\n\n    def find_trail_length(grid, row, col, direction, trail, visited, program):\n        if not is_valid_move(grid, row, col, direction):\n            return trail, visited, False\n\n        new_row, new_col = row, col\n        if direction == '>':\n            new_col += 1\n        elif direction == '<':\n            new_col -= 1\n        elif direction == 'v':\n            new_row += 1\n        elif direction == '^':\n            new_row -= 1\n\n        if (new_row, new_col) not in visited:\n            trail.append((new_row, new_col))\n            visited.add((new_row, new_col))\n\n        program.pop(0)\n        if not program:\n            return trail, visited, True\n\n        next_direction = program[0]\n        return find_trail_length(grid, new_row, new_col, next_direction, trail, visited, program)\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    program = lines[1]\n    grid = [list(line) for line in lines[2:]]\n\n    initial_row, initial_col = -1, -1\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'R':\n                initial_row, initial_col = i, j\n                break\n\n    trail, visited, is_trail_finite = find_trail_length(grid, initial_row, initial_col, program[0], [(initial_row, initial_col)], set([(initial_row, initial_col)]), list(program))\n\n    if is_trail_finite:\n        return \"1\"\n\n    suffix_length = len(trail)\n    trail_str = ''.join([str(x) for x in trail])\n\n    for i in range(1, suffix_length):\n        if trail_str.endswith(trail_str[:i]):\n            return str(i)\n\n    return \"1\""
    },
    {
        "number": 3050,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def move(x, y, direction):\n        if direction == '<':\n            return x - 1, y\n        elif direction == '>':\n            return x + 1, y\n        elif direction == '^':\n            return x, y - 1\n        elif direction == 'v':\n            return x, y + 1\n\n    def check_valid(x, y):\n        return 0 <= x < N and 0 <= y < N and grid[y][x] != '#'\n\n    def find_cycle(start):\n        cycle_length = 0\n        while True:\n            if trail[start + cycle_length] != trail[start + cycle_length + X]:\n                cycle_length += 1\n            else:\n                return cycle_length\n\n    N, program, grid = stdin.split('\\n')\n    N = int(N)\n    X = 0\n    robot_x, robot_y = 0, 0\n    direction_index = 0\n    trail = []\n    cycle_found = False\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'R':\n                robot_x, robot_y = j, i\n\n    while not cycle_found:\n        current_direction = program[direction_index]\n        new_x, new_y = move(robot_x, robot_y, current_direction)\n        if check_valid(new_x, new_y):\n            trail.append((new_x, new_y))\n            robot_x, robot_y = new_x, new_y\n            direction_index = (direction_index + 1) % len(program)\n        else:\n            direction_index = (direction_index + 1) % len(program)\n\n        if len(trail) > 1 and trail[-1] == trail[0]:\n            cycle_found = True\n            X = find_cycle(0)\n\n    if X == 1:\n        return '1'\n    else:\n        return str(X)"
    },
    {
        "number": 3050,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.splitlines()\n        N = int(lines[0])\n        program = lines[1]\n        grid = [list(line) for line in lines[2:]]\n        return N, program, grid\n\n    def is_valid_move(i: int, j: int, grid: list) -> bool:\n        return 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] != \"#\"\n\n    def execute_program(program: str, grid: list, initial_position: tuple) -> list:\n        i, j = initial_position\n        direction = 0\n        visited = [initial_position]\n        while True:\n            move = program[direction % len(program)]\n            if move == \"<\":\n                new_i, new_j = i, j - 1\n            elif move == \">\":\n                new_i, new_j = i, j + 1\n            elif move == \"^\":\n                new_i, new_j = i - 1, j\n            elif move == \"v\":\n                new_i, new_j = i + 1, j\n            else:\n                raise ValueError(\"Invalid move\")\n\n            if is_valid_move(new_i, new_j, grid):\n                i, j = new_i, new_j\n                visited.append((i, j))\n\n            direction += 1\n            if (i, j) == initial_position and len(visited) > 1:\n                if visited[-1] == visited[-2]:\n                    break\n\n        return visited\n\n    def find_repeating_subsequence(trail: list) -> int:\n        for i in range(1, len(trail) // 2 + 1):\n            if trail[-i:] == trail[-2 * i : -i]:\n                return i\n        return 1\n\n    N, program, grid = parse_input(stdin)\n    initial_position = [(i, j) for i in range(N) for j in range(N) if grid[i][j] == \"R\"]\n    trail = execute_program(program, grid, initial_position[0])\n    X = find_repeating_subsequence(trail)\n    return str(X)"
    },
    {
        "number": 3050,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_position(position, direction):\n        if direction == '<':\n            return (position[0] - 1, position[1])\n        elif direction == '>':\n            return (position[0] + 1, position[1])\n        elif direction == '^':\n            return (position[0], position[1] - 1)\n        else:\n            return (position[0], position[1] + 1)\n\n    def is_valid_position(position):\n        return 0 <= position[0] < N and 0 <= position[1] < N and grid[position[0]][position[1]] != '#'\n\n    def find_repeating_subsequence_length(trail):\n        for i in range(1, len(trail)):\n            if trail[-i:] == trail[-(i + len(trail) // i):-len(trail) // i]:\n                return i\n        return None\n\n    N, program, *grid = stdin.split('\\n')\n    N = int(N)\n    grid = [list(row) for row in grid]\n    R = next((i, j) for i in range(N) for j in range(N) if grid[i][j] == 'R')\n\n    trail = [R]\n    position = R\n    direction_index = 0\n\n    while True:\n        direction = program[direction_index % len(program)]\n        next_position = get_next_position(position, direction)\n\n        if is_valid_position(next_position):\n            position = next_position\n            trail.append(position)\n\n        direction_index += 1\n\n        if position == R and direction_index % len(program) == 0:\n            break\n\n    X = find_repeating_subsequence_length(trail)\n\n    return str(1 if X is None else X)"
    },
    {
        "number": 3050,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x, y, direction):\n        if direction == '<':\n            return grid[y][x - 1] != '#'\n        elif direction == '>':\n            return grid[y][x + 1] != '#'\n        elif direction == '^':\n            return grid[y - 1][x] != '#'\n        elif direction == 'v':\n            return grid[y + 1][x] != '#'\n\n    def find_continuous_subsequence(trail):\n        n = len(trail)\n        for x in range(1, n // 2 + 1):\n            if n % x != 0:\n                continue\n            is_valid = True\n            for i in range(n // x):\n                if trail[i * x: (i + 1) * x] != trail[(i + 1) * x: (i + 2) * x]:\n                    is_valid = False\n                    break\n            if is_valid:\n                return x\n        return n\n\n    stdin = stdin.split('\\n')\n    N, program = int(stdin[0]), stdin[1]\n    grid = [list(line.strip()) for line in stdin[2:]]\n    x, y = next((i, j) for i in range(N) for j in range(N) if grid[i][j] == 'R')\n    trail = [(x, y)]\n    current_position = 0\n    direction_count = {'>': 0, '<': 0, '^': 0, 'v': 0}\n\n    while True:\n        direction = program[current_position % len(program)]\n        direction_count[direction] += 1\n        if is_valid_move(x, y, direction):\n            if direction == '<':\n                x -= 1\n            elif direction == '>':\n                x += 1\n            elif direction == '^':\n                y -= 1\n            elif direction == 'v':\n                y += 1\n            if (x, y) not in trail:\n                trail.append((x, y))\n            current_position += 1\n        else:\n            break\n\n    if len(trail) == 1:\n        return '1'\n    else:\n        return str(find_continuous_subsequence(trail))"
    },
    {
        "number": 3050,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x, y, direction):\n        if direction == '<':\n            return valid_cells[y][x - 1]\n        elif direction == '>':\n            return valid_cells[y][x + 1]\n        elif direction == '^':\n            return valid_cells[y - 1][x]\n        elif direction == 'v':\n            return valid_cells[y + 1][x]\n\n    def find_repeating_sequence(sequence):\n        for length in range(1, len(sequence) // 2 + 1):\n            if len(sequence) % length != 0:\n                continue\n\n            is_repeat = True\n            for i in range(len(sequence) // length):\n                if sequence[i * length: (i + 1) * length] != sequence[(i + 1) * length: (i + 2) * length]:\n                    is_repeat = False\n                    break\n\n            if is_repeat:\n                return length\n\n        return 0\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    program = lines[1]\n    grid = [list(line) for line in lines[2:]]\n\n    valid_cells = [[cell != '#' for cell in row] for row in grid]\n\n    x, y = next((i, j) for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == 'R')\n    visited = set()\n    trail = []\n\n    for direction in program:\n        if is_valid_move(x, y, direction):\n            if direction == '<':\n                x -= 1\n            elif direction == '>':\n                x += 1\n            elif direction == '^':\n                y -= 1\n            elif direction == 'v':\n                y += 1\n\n            if (x, y) not in visited:\n                visited.add((x, y))\n                trail.append((x, y))\n\n    if len(trail) == len(set(trail)):\n        return '1'\n    else:\n        return str(find_repeating_sequence(trail))"
    },
    {
        "number": 3051,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def missed_fogs(fogs, nets):\n        missed = 0\n        for fog in fogs:\n            if not any(net.intersects(fog) for net in nets):\n                missed += 1\n        return missed\n\n    def add_patches(fogs, nets, day):\n        patches = []\n        for fog in fogs:\n            if not any(net.contains(fog) for net in nets):\n                patches.append(Rectangle(fog.left, fog.right, fog.height))\n        for patch in patches:\n            nets.add(patch)\n\n    def simulate_days(n, fogs):\n        nets = set()\n        total_missed = 0\n        for i in range(n):\n            add_patches(fogs[i], nets, i)\n            total_missed += missed_fogs(fogs[i], nets)\n        return total_missed\n\n    def parse_input(stdin):\n        n = int(stdin.readline().strip())\n        fogs = []\n        for _ in range(n):\n            params = list(map(int, stdin.readline().strip().split()))\n            m_i, d_i, l_i, r_i, h_i, delta_d_i, delta_x_i, delta_h_i = params\n            fogs.append([Fog(l_i + k * delta_x_i, r_i + k * delta_x_i, h_i + k * delta_h_i, d_i + k * delta_d_i) for k in range(m_i)])\n        return n, fogs\n\n    class Rectangle:\n        def __init__(self, left, right, height):\n            self.left = left\n            self.right = right\n            self.height = height\n\n        def intersects(self, other):\n            return not (self.left > other.right or self.right < other.left or self.height < other.height)\n\n        def contains(self, other):\n            return self.left <= other.left and self.right >= other.right and self.height >= other.height\n\n    class Fog:\n        def __init__(self, left, right, height, day):\n            self.left = left\n            self.right = right\n            self.height = height\n            self.day = day\n\n    n, fogs = parse_input(stdin)\n    total_missed = simulate_days(n, fogs)\n    return str(total_missed)"
    },
    {
        "number": 3051,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def missed_fogs(originator_fogs):\n        missed = 0\n        net_patches = []\n        for i in range(len(originator_fogs)):\n            fogs = originator_fogs[i]\n            m_i, d_i, l_i, r_i, h_i, delta_d_i, delta_x_i, delta_h_i = fogs\n            fogs_generated = [(l_i + k * delta_x_i, r_i + k * delta_x_i, h_i + k * delta_h_i) for k in range(m_i)]\n\n            for x1, x2, y in fogs_generated:\n                if any(x1 < x3 and x2 > x4 and y > y3 for x3, x4, y3 in net_patches):\n                    break\n            else:\n                continue\n\n            missed += m_i\n            net_patches.append((min(x1, x2), max(x1, x2), y))\n\n        return missed\n\n    n = int(stdin.readline())\n    originator_fogs = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    return str(missed_fogs(originator_fogs))"
    },
    {
        "number": 3051,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_missed(nets, fog):\n        for net in nets:\n            if fog[0] >= net[0] and fog[1] <= net[1] and fog[2] <= net[3]:\n                return False\n        return True\n\n    def update_nets(nets, fog, d, n, dx, dh):\n        for i in range(n):\n            x = fog[0] + i * dx\n            h = fog[2] + i * dh\n            nets.add((x, x + d, h))\n\n    def missed_fogs(n, params):\n        nets = set()\n        missed = 0\n        for i in range(n):\n            m, d, l, r, h, nd, dx, dh = params[i]\n            for j in range(m):\n                fog = (l + j * dx, r + j * dx, h + j * dh)\n                if is_missed(nets, fog):\n                    missed += 1\n            update_nets(nets, fog, nd, m, dx, dh)\n        return missed\n\n    n = int(stdin.readline())\n    params = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    return str(missed_fogs(n, params))"
    },
    {
        "number": 3051,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def missed_fogs(n, m_i, d_i, l_i, r_i, h_i, delta_d_i, delta_x_i, delta_h_i):\n        total_fogs = [0] * (n + 1)\n        total_fogs[0] = 1\n        for i in range(n):\n            for j in range(m_i):\n                total_fogs[i + 1] += 1\n\n        missed = 0\n        for i in range(n):\n            missed_today = 0\n            for j in range(m_i):\n                missed_today += total_fogs[i + 1 + j]\n            missed += missed_today\n\n        return missed\n\n    n = int(stdin.readline().strip())\n    total_missed = 0\n    for i in range(n):\n        line = stdin.readline().strip().split()\n        m_i, d_i, l_i, r_i, h_i, delta_d_i, delta_x_i, delta_h_i = map(int, line)\n        total_missed += missed_fogs(n, m_i, d_i, l_i, r_i, h_i, delta_d_i, delta_x_i, delta_h_i)\n\n    return str(total_missed)"
    },
    {
        "number": 3051,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_missed_fogs(originator_fogs: List[dict], nets: List[dict]) -> int:\n        def is_fog_missed(fog: dict, nets: List[dict]) -> bool:\n            for net in nets:\n                if net[\"left\"] <= fog[\"right\"] and fog[\"left\"] <= net[\"right\"] and net[\"top\"] <= fog[\"bottom\"]:\n                    return False\n            return True\n\n        def add_net_patches(missed_fogs: List[dict], nets: List[dict]) -> None:\n            for fog in missed_fogs:\n                fog_height = fog[\"bottom\"] - fog[\"top\"]\n                for net in nets:\n                    if net[\"top\"] < fog[\"bottom\"] and fog[\"top\"] < net[\"bottom\"]:\n                        overlap_top = max(fog[\"top\"], net[\"top\"])\n                        overlap_bottom = min(fog[\"bottom\"], net[\"bottom\"])\n                        overlap_height = overlap_bottom - overlap_top\n                        if overlap_height == fog_height:\n                            break\n                        elif overlap_height < fog_height:\n                            net[\"bottom\"] = overlap_top\n                        else:\n                            net[\"top\"] = overlap_bottom\n                else:\n                    nets.append({\n                        \"left\": fog[\"left\"],\n                        \"right\": fog[\"right\"],\n                        \"top\": fog[\"top\"],\n                        \"bottom\": fog[\"bottom\"]\n                    })\n\n        def get_missed_fogs_for_day(originator_fogs: List[dict], day: int) -> List[dict]:\n            missed_fogs = []\n            for fog in originator_fogs:\n                if day % fog[\"delta_d\"] == 0:\n                    current_fog = {\n                        \"left\": fog[\"left\"] + day // fog[\"delta_d\"] * fog[\"delta_x\"],\n                        \"right\": fog[\"right\"] + day // fog[\"delta_d\"] * fog[\"delta_x\"],\n                        \"top\": fog[\"top\"] + day // fog[\"delta_d\"] * fog[\"delta_h\"],\n                        \"bottom\": fog[\"bottom\"] + day // fog[\"delta_d\"] * fog[\"delta_h\"]\n                    }\n                    if is_fog_missed(current_fog, nets):\n                        missed_fogs.append(current_fog)\n            return missed_fogs\n\n        nets = []\n        missed_fogs = []\n        for i in range(1, max(originator_fogs, key=lambda x: x[\"delta_d\"])[\"delta_d\"]):\n            missed_fogs.extend(get_missed_fogs_for_day(originator_fogs, i))\n            add_net_patches(missed_fogs, nets)\n\n        return len(missed_fogs)\n\n    def parse_input(stdin: str) -> List[dict]:\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        originator_fogs = []\n        for i in range(1, n + 1):\n            m_i, d_i, l_i, r_i, h_i, delta_d_i, delta_x_i, delta_h_i = map(int, lines[i].split())\n            originator_fogs.append({\n                \"m\": m_i,\n                \"d\": d_i,\n                \"left\": l_i,\n                \"right\": r_i,\n                \"height\": h_i,\n                \"delta_d\": delta_d_i,\n                \"delta_x\": delta_x_i,\n                \"delta_h\": delta_h_i\n            })\n        return originator_fogs\n\n    originator_fogs = parse_input(stdin)\n    missed_fogs = get_missed_fogs(originator_fogs, [])\n    return str(missed_fogs)"
    },
    {
        "number": 3051,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_missed_fogs(n: int, fogs: list) -> int:\n        missed_fogs = 0\n        for fog in fogs:\n            m, d, ell, r, h, delta_d, delta_x, delta_h = fog\n            for k in range(m):\n                left = ell + k * delta_x\n                right = r + k * delta_x\n                height = h + k * delta_h\n                if k >= 1:\n                    day = d + k * delta_d\n                else:\n                    day = d\n\n                missed_fogs += count_missed_fogs_on_day(day, left, right, height)\n        return missed_fogs\n\n    def count_missed_fogs_on_day(day: int, left: int, right: int, height: int) -> int:\n        nets_covered_area = 0\n        for net in nets:\n            if net[0] <= left and net[1] >= right and net[2] <= height:\n                nets_covered_area += (net[1] - net[0]) * (net[2] - net[3])\n\n        fog_area = (right - left) * height\n        return fog_area - nets_covered_area\n\n    def update_nets(fogs: list):\n        for fog in fogs:\n            m, d, ell, r, h, delta_d, delta_x, delta_h = fog\n            for k in range(m):\n                left = ell + k * delta_x\n                right = r + k * delta_x\n                height = h + k * delta_h\n                if k >= 1:\n                    day = d + k * delta_d\n                else:\n                    day = d\n\n                nets.add((left, right, height, 0))\n\n    n, *fogs = [list(map(int, line.split())) for line in stdin.split('\\n') if line]\n    nets = set()\n\n    update_nets(fogs)\n    missed_fogs = count_missed_fogs(n, fogs)\n\n    return str(missed_fogs)"
    },
    {
        "number": 3051,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def missed_fogs(fogs, nets):\n        missed = 0\n        for fog in fogs:\n            caught = False\n            for net in nets:\n                if net.contains(fog):\n                    caught = True\n                    break\n            if not caught:\n                missed += 1\n        return missed\n\n    def update_nets(fogs, nets):\n        for fog in fogs:\n            if not any(net.contains(fog) for net in nets):\n                net_to_add = fog.as_net()\n                nets.append(net_to_add)\n                for k in range(1, fog.m):\n                    next_fog = fog.next_fog(k)\n                    net_to_add = next_fog.as_net()\n                    nets.append(net_to_add)\n\n    class Fog:\n        def __init__(self, m, d, ll, r, h, delta_d, delta_x, delta_h):\n            self.m = m\n            self.d = d\n            self.ll = ll\n            self.r = r\n            self.h = h\n            self.delta_d = delta_d\n            self.delta_x = delta_x\n            self.delta_h = delta_h\n\n        def next_fog(self, k):\n            return Fog(self.m, self.d + k * self.delta_d, self.ll + k * self.delta_x, self.r + k * self.delta_x, self.h + k * self.delta_h, self.delta_d, self.delta_x, self.delta_h)\n\n        def as_net(self):\n            return Net(self.ll, self.r, 0, self.h)\n\n    class Net:\n        def __init__(self, ll, r, b, t):\n            self.ll = ll\n            self.r = r\n            self.b = b\n            self.t = t\n\n        def contains(self, fog):\n            return self.ll <= fog.ll and fog.r <= self.r and self.b <= fog.b and fog.t <= self.t\n\n    n, *fog_params = map(int, stdin.split())\n    fogs = [Fog(*f) for f in [fog_params[i:i + 8] for i in range(0, len(fog_params), 8)]]\n    nets = []\n\n    missed = missed_fogs(fogs, nets)\n    if missed > 0:\n        update_nets(fogs, nets)\n        missed = missed_fogs(fogs, nets)\n\n    return str(missed)"
    },
    {
        "number": 3051,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_missed_fogs(fogs):\n        nets = []\n        missed_fogs = 0\n\n        for i in range(len(fogs)):\n            f_i = fogs[i]\n            missed_fogs += count_missed_fogs_by_fog(f_i, nets)\n            nets = update_nets_by_fog(f_i, nets)\n\n        return missed_fogs\n\n    def count_missed_fogs_by_fog(f_i, nets):\n        missed_fogs = 0\n        for k in range(f_i[\"m\"]):\n            fog_rectangle = get_fog_rectangle_by_day(f_i, k)\n            if not is_rectangle_covered_by_nets(fog_rectangle, nets):\n                missed_fogs += 1\n        return missed_fogs\n\n    def update_nets_by_fog(f_i, nets):\n        for k in range(f_i[\"m\"]):\n            fog_rectangle = get_fog_rectangle_by_day(f_i, k)\n            if not is_rectangle_covered_by_nets(fog_rectangle, nets):\n                nets.append(fog_rectangle)\n        return nets\n\n    def get_fog_rectangle_by_day(f_i, k):\n        return {\n            \"left\": f_i[\"ll\"] + k * f_i[\"dx\"],\n            \"right\": f_i[\"rl\"] + k * f_i[\"dx\"],\n            \"height\": f_i[\"h\"] + k * f_i[\"dh\"],\n        }\n\n    def is_rectangle_covered_by_nets(rectangle, nets):\n        for net in nets:\n            if (\n                rectangle[\"left\"] >= net[\"left\"]\n                and rectangle[\"right\"] <= net[\"right\"]\n                and rectangle[\"height\"] <= net[\"height\"]\n            ):\n                return True\n        return False\n\n    def parse_input(stdin):\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        fogs = []\n        for i in range(1, n + 1):\n            m_i, d_i, ll_i, rl_i, h_i, dd_i, dx_i, dh_i = map(int, lines[i].split())\n            fogs.append(\n                {\n                    \"m\": m_i,\n                    \"d\": d_i,\n                    \"ll\": ll_i,\n                    \"rl\": rl_i,\n                    \"h\": h_i,\n                    \"dx\": dx_i,\n                    \"dh\": dh_i,\n                    \"dd\": dd_i,\n                }\n            )\n        return fogs\n\n    fogs = parse_input(stdin)\n    return str(count_missed_fogs(fogs))"
    },
    {
        "number": 3051,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def missed_fogs(originator_fogs: List[List[int]]) -> int:\n        def intersects(rect1: Tuple[int, int, int], rect2: Tuple[int, int, int]) -> bool:\n            return not (rect1[0] > rect2[1] or rect1[1] < rect2[0] or rect1[2] < rect2[2])\n\n        def merge_rectangles(rectangles: List[Tuple[int, int, int]]) -> Tuple[int, int, int]:\n            left = min(rect[0] for rect in rectangles)\n            right = max(rect[1] for rect in rectangles)\n            height = max(rect[2] for rect in rectangles)\n            return (left, right, height)\n\n        def missed_fogs_per_day(fogs: List[Tuple[int, int, int, int, int]]) -> int:\n            nets = []\n            missed_count = 0\n\n            for fog in fogs:\n                fog_rect = (fog[1], fog[2], fog[3])\n                missed = True\n\n                for net in nets:\n                    if intersects(fog_rect, net):\n                        missed = False\n                        break\n\n                if missed:\n                    missed_count += 1\n                    nets.append(fog_rect)\n\n                nets.append(fog_rect)\n                nets = [merge_rectangles(nets[i:]) for i in range(0, len(nets), 2)]\n\n            return missed_count\n\n        days = max(originator_fogs[i][1] + originator_fogs[i][4] * (originator_fogs[i][0] - 1) for i in range(len(originator_fogs)))\n        total_missed_count = 0\n\n        for day in range(days + 1):\n            fogs = []\n            for i in range(len(originator_fogs)):\n                originator = originator_fogs[i]\n                m, d, l, r, h, dd, dx, dh = originator\n                fog_count = m if day >= d and (day - d) % dd == 0 else 0\n\n                for k in range(fog_count):\n                    fogs.append((l + k * dx, r + k * dx, h + k * dh))\n\n            total_missed_count += missed_fogs_per_day(fogs)\n\n        return total_missed_count\n\n    input_data = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    result = missed_fogs(input_data)\n    return str(result) "
    },
    {
        "number": 3051,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def overlap(rect1, rect2):\n        return (rect1[0] <= rect2[1] and rect1[1] >= rect2[0]) and (rect1[2] <= rect2[3] and rect1[3] >= rect2[2])\n\n    def merge_rect(rect1, rect2):\n        return [min(rect1[0], rect2[0]), max(rect1[1], rect2[1]), min(rect1[2], rect2[2]), max(rect1[3], rect2[3])]\n\n    def get_fogs(fogs, day):\n        return [fog for fog in fogs if fog['start'] <= day < fog['start'] + fog['span'] * (fog['count'] - 1)]\n\n    def get_nets(nets, fogs):\n        missed_fogs = []\n        for fog in fogs:\n            missed = True\n            for net in nets:\n                if overlap(fog, net):\n                    missed = False\n                    break\n            if missed:\n                missed_fogs.append(fog)\n        return missed_fogs\n\n    def get_new_nets(nets, missed_fogs):\n        new_nets = []\n        for fog in missed_fogs:\n            added = False\n            for i, net in enumerate(nets):\n                if overlap(fog, net):\n                    new_nets.append(merge_rect(fog, net))\n                    nets[i] = new_nets[-1]\n                    added = True\n                    break\n            if not added:\n                new_nets.append(fog)\n        return new_nets\n\n    def count_missed_fogs(fogs, nets):\n        missed_count = 0\n        for day in range(fogs[-1]['start'] + fogs[-1]['span'] * (fogs[-1]['count'] - 1) + 1):\n            fogs_today = get_fogs(fogs, day)\n            missed_fogs = get_nets(nets, fogs_today)\n            missed_count += len(missed_fogs)\n            new_nets = get_new_nets(nets, missed_fogs)\n            nets += new_nets\n        return missed_count\n\n    def parse_input(stdin):\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        fogs = []\n        for i in range(1, n + 1):\n            params = list(map(int, lines[i].split()))\n            fogs.append({\n                'count': params[0],\n                'start': params[1],\n                'left': params[2],\n                'right': params[3],\n                'height': params[4],\n                'delta_d': params[5],\n                'delta_x': params[6],\n                'delta_h': params[7]\n            })\n        return fogs\n\n    fogs = parse_input(stdin)\n    nets = []\n    return count_missed_fogs(fogs, nets)"
    },
    {
        "number": 3052,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X_A, Y_A, X_B, Y_B = map(float, stdin.readline().split())\n    N = int(stdin.readline())\n    conveyors = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(float, stdin.readline().split())\n        conveyors.append(((x1, y1), (x2, y2)))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def intersection(p, q, r, s):\n        def cross(a, b):\n            return a[0] * b[1] - a[1] * b[0]\n\n        x1, y1 = p\n        x2, y2 = q\n        x3, y3 = r\n        x4, y4 = s\n\n        d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if d == 0:\n            return None\n\n        t = cross((x1, y1), (x2, y2)) / d\n        u = cross((x1, y1), (x3, y3)) / d\n\n        if 0 <= t <= 1 and 0 <= u <= 1:\n            return ((x1 + t * (x2 - x1), y1 + t * (y2 - y1)),\n                    (x3 + u * (x4 - x3), y3 + u * (y4 - y3)))\n        else:\n            return None\n\n    def path_length(p, q, r, s):\n        i = intersection(p, q, r, s)\n        if i:\n            d1 = distance(p, i[0])\n            d2 = distance(i[0], i[1])\n            d3 = distance(i[1], q)\n            return d1 + d2 + d3\n        else:\n            return None\n\n    def best_path(p, q):\n        if p == q:\n            return 0.0\n\n        best_time = float('inf')\n        for c in conveyors:\n            d1 = path_length(p, c[0], c[0], c[1])\n            d2 = path_length(c[0], c[1], q, q)\n\n            if d1 and d2:\n                time = d1 / 2 + d2 / 2\n                if time < best_time:\n                    best_time = time\n\n        return best_time\n\n    return f\"{best_path((X_A, Y_A), (X_B, Y_B))}\""
    },
    {
        "number": 3052,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, B, conveyors = parse_input(stdin)\n    return str(min_time(A, B, conveyors))\n\ndef"
    },
    {
        "number": 3052,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def shortest_path(x, y, target, conveyors):\n        if (x, y) == target:\n            return 0\n        min_time = float('inf')\n        for conveyor in conveyors:\n            start, end = conveyor\n            start_x, start_y = start\n            end_x, end_y = end\n            if distance(x, y, start_x, start_y) <= 1 and distance(end_x, end_y, target[0], target[1]) <= 1:\n                time = abs(end_x - start_x) / 2 + abs(end_y - start_y) / 2\n                if time < min_time:\n                    min_time = time\n            elif distance(x, y, end_x, end_y) <= 1 and distance(start_x, start_y, target[0], target[1]) <= 1:\n                time = abs(start_x - end_x) / 2 + abs(start_y - end_y) / 2\n                if time < min_time:\n                    min_time = time\n            else:\n                dx1, dy1 = (start_x - x, start_y - y)\n                dx2, dy2 = (end_x - start_x, end_y - start_y)\n                cross_product = dx1 * dy2 - dx2 * dy1\n                if abs(cross_product) <= 1e-6:\n                    d = abs(dx1 * end_x - dx2 * start_x + dy1 * start_y - dy2 * end_y) / distance(start_x, start_y, end_x, end_y)\n                    if d <= 1:\n                        time = abs(end_x - start_x) / 2 + abs(end_y - start_y) / 2\n                        if time < min_time:\n                            min_time = time\n        return min_time\n\n    input_data = list(map(float, stdin.split()))\n    x_a, y_a, x_b, y_b = input_data[:4]\n    n = int(input_data[4])\n    conveyors = []\n    for i in range(n):\n        x1, y1, x2, y2 = input_data[5 + i * 4:9 + i * 4]\n        conveyors.append(((x1, y1), (x2, y2)))\n\n    target = (x_b, y_b)\n    min_time = float('inf')\n    for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n        x, y = x_a, y_a\n        while 0 <= x <= 1000 and 0 <= y <= 1000:\n            time = shortest_path(x, y, target, conveyors)\n            if time < min_time:\n                min_time = time\n            x += dx\n            y += dy\n    return f\"{min_time:.7f}\""
    },
    {
        "number": 3052,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def time_to_cross(x1, y1, x2, y2, v):\n        return distance(x1, y1, x2, y2) / v\n\n    def shortest_path(A, B, conveyors):\n        xA, yA, xB, yB = A\n        min_time = float(\"inf\")\n\n        for conveyor in conveyors:\n            x1, y1, x2, y2 = conveyor\n            if not (x1 <= xA <= x2 and y1 <= yA <= y2) or not (x1 <= xB <= x2 and y1 <= yB <= y2):\n                continue\n\n            time_on_conveyor = time_to_cross(xA, yA, xB, yB, 2)\n            time_on_floor = distance(xA, yA, x1, y1) / 1 + distance(xB, yB, x2, y2) / 1\n            total_time = time_on_conveyor + time_on_floor\n\n            min_time = min(min_time, total_time)\n\n        return min_time\n\n    lines = stdin.strip().split(\"\\n\")\n    xA, yA, xB, yB = map(float, lines[0].split())\n    conveyors = [list(map(float, line.split())) for line in lines[2:2 + int(lines[1])]]\n\n    return f\"{shortest_path((xA, yA, xB, yB), conveyors):.6f}\""
    },
    {
        "number": 3052,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A_x, A_y, B_x, B_y = map(float, stdin.split('\\n')[0].split())\n    N = int(stdin.split('\\n')[1])\n    conveyors = []\n\n    for i in range(N):\n        X1, Y1, X2, Y2 = map(float, stdin.split('\\n')[i+2].split())\n        conveyors.append([[X1, Y1], [X2, Y2]])\n\n    def distance(A, B):\n        return ((A[0] - B[0])**2 + (A[1] - B[1])**2)**0.5\n\n    def time_to_cross_conveyor(A, B, conveyor):\n        AB = distance(A, B)\n        AC = distance(A, conveyor[0])\n        CD = distance(conveyor[0], conveyor[1])\n        BD = distance(B, conveyor[1])\n\n        if AC + BD < AB:\n            return (AC + BD) / 2\n        else:\n            return AB\n\n    def time_to_travel(A, B):\n        min_time = distance(A, B)\n\n        for conveyor in conveyors:\n            if A[0] != conveyor[0][0] or B[0] != conveyor[1][0]:\n                min_time = min(min_time, time_to_cross_conveyor(A, B, conveyor) + distance([conveyor[0][0], A[1]], [conveyor[1][0], B[1]]))\n\n        return min_time\n\n    return f\"{time_to_travel([A_x, A_y], [B_x, B_y]):.7f}\""
    },
    {
        "number": 3052,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def shortest_path(x1, y1, x2, y2):\n        return min(abs(x2 - x1) + abs(y2 - y1), distance(x1, y1, x2, y2))\n\n    def shortest_path_with_conveyor(x1, y1, x2, y2, conveyors):\n        min_time = float(\"inf\")\n\n        for conveyor in conveyors:\n            p1, p2 = conveyor\n            x1_c, y1_c = p1\n            x2_c, y2_c = p2\n\n            if min(x1, x2) <= x1_c <= max(x1, x2) and min(y1, y2) <= y1_c <= max(y1, y2):\n                dist1 = shortest_path(x1, y1, x1_c, y1_c)\n                dist2 = distance(x1_c, y1_c, x2_c, y2_c)\n                dist3 = shortest_path(x2_c, y2_c, x2, y2)\n                time = dist1 / 1 + dist2 / 2 + dist3 / 1\n                min_time = min(min_time, time)\n\n            elif min(x1, x2) <= x2_c <= max(x1, x2) and min(y1, y2) <= y2_c <= max(y1, y2):\n                dist1 = shortest_path(x1, y1, x1_c, y1_c)\n                dist2 = distance(x1_c, y1_c, x2_c, y2_c)\n                dist3 = shortest_path(x2_c, y2_c, x2, y2)\n                time = dist1 / 1 + dist2 / 2 + dist3 / 1\n                min_time = min(min_time, time)\n\n        return min_time\n\n    x1, y1, x2, y2 = map(float, stdin.splitlines()[0].split())\n    conveyors = [tuple(map(float, line.split())) for line in stdin.splitlines()[1:]]\n\n    min_time = shortest_path_with_conveyor(x1, y1, x2, y2, conveyors)\n    return f\"{min_time:.6f}\""
    },
    {
        "number": 3052,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dist(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def intersect(a1, a2, b1, b2):\n        return (a1[0] - a2[0]) * (b1[1] - a1[1]) != (a1[1] - a2[1]) * (b1[0] - a1[0]) and \\\n               (b1[0] - b2[0]) * (a1[1] - b1[1]) != (b1[1] - b2[1]) * (a1[0] - b1[0])\n\n    def get_time(start, end, n, conveyors, best_time):\n        if n == 0:\n            return dist(start, end)\n\n        min_time = float('inf')\n        for i in range(n):\n            if intersect(start, end, conveyors[i][0], conveyors[i][1]):\n                continue\n\n            for j in range(i, n):\n                if intersect(conveyors[i][1], conveyors[j][0], start, end):\n                    continue\n\n                if i == j:\n                    time = max(dist(start, conveyors[i][0]), dist(conveyors[i][1], end))\n                else:\n                    time = dist(start, conveyors[i][0]) + dist(conveyors[i][1], conveyors[j][0]) + dist(conveyors[j][1], end)\n\n                if time < min_time:\n                    min_time = time\n                    best_time = min(best_time, time)\n\n            best_time = get_time(conveyors[i][0], conveyors[i][1], n - i - 1, conveyors[i + 1:], best_time)\n\n        return min_time\n\n    xa, ya, xb, yb, n, *conveyors = map(float, stdin.split())\n    conveyors = [((x1, y1), (x2, y2)) for x1, y1, x2, y2 in zip(conveyors[::4], conveyors[1::4], conveyors[2::4], conveyors[3::4])]\n\n    return f\"{get_time((xa, ya), (xb, yb), n, conveyors, float('inf')):.7f}\""
    },
    {
        "number": 3052,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def min_time(x, y, x1, y1, x2, y2):\n        dx, dy = x2 - x1, y2 - y1\n        norm = (dx ** 2 + dy ** 2) ** 0.5\n        dx, dy = dx / norm, dy / norm\n        x_proj = x1 + (x - x1) * dx + (y - y1) * dy\n        y_proj = y1 + (x - x1) * dy - (y - y1) * dx\n        if x_proj < x1 or x_proj > x2:\n            return float('inf')\n        return distance(x, y, x_proj, y_proj) / 2 + abs(y_proj - y)\n\n    x1, y1, x2, y2 = [float(x) for x in stdin.split()]\n    min_dist = float('inf')\n    for i in range(int(input())):\n        x3, y3, x4, y4 = [float(x) for x in input().split()]\n        min_dist = min(min_dist, min_time(x1, y1, x3, y3, x4, y4) + min_time(x4, y4, x2, y2, x3, y3))\n    return f\"{min_dist:.4f}\""
    },
    {
        "number": 3052,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def intersection_point(p1, p2, p3, p4):\n        x1, y1, x2, y2 = p1[0], p1[1], p2[0], p2[1]\n        x3, y3, x4, y4 = p3[0], p3[1], p4[0], p4[1]\n        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if denom == 0:\n            return None\n        ua = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denom\n        ub = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denom\n        if 0 <= ua <= 1 and 0 <= ub <= 1:\n            return x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)\n        return None\n\n    def min_time(p1, p2, p3, p4):\n        d1 = distance(p1, p2)\n        d2 = distance(p2, p3)\n        d3 = distance(p3, p4)\n        d4 = distance(p4, p1)\n        d = distance(p1, p3)\n        if d1 == 0 or d2 == 0 or d3 == 0 or d4 == 0:\n            return float(\"inf\")\n        return (d1 + d2 + d3 + d4) / 2\n\n    x_a, y_a, x_b, y_b = map(float, stdin.splitlines()[0].split())\n    p1 = (x_a, y_a)\n    p2 = (x_b, y_b)\n    conveyors = [tuple(map(float, line.split())) for line in stdin.splitlines()[1:]]\n\n    min_t = float(\"inf\")\n    for i in range(len(conveyors)):\n        for j in range(i, len(conveyors)):\n            p3, p4 = conveyors[i], conveyors[j]\n            intersection = intersection_point(p1, p2, p3, p4)\n            if intersection:\n                t1 = distance(p1, intersection) / 1 + distance(intersection, p3) / 2 + distance(p3, p4) / 2\n                t2 = distance(p1, intersection) / 1 + distance(intersection, p4) / 2 + distance(p4, p3) / 2\n                t3 = distance(p2, intersection) / 1 + distance(intersection, p3) / 2 + distance(p3, p4) / 2\n                t4 = distance(p2, intersection) / 1 + distance(intersection, p4) / 2 + distance(p4, p3) / 2\n                min_t = min(min_t, t1, t2, t3, t4)\n            else:\n                min_t = min(min_t, min_time(p1, p2, p3, p4))\n\n    return f\"{min_t:.6f}\""
    },
    {
        "number": 3052,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def nearest_point(x, y, points):\n        nearest = None\n        nearest_distance = float('inf')\n        for px, py in points:\n            d = distance(x, y, px, py)\n            if d < nearest_distance:\n                nearest = (px, py)\n                nearest_distance = d\n        return nearest\n\n    def shortest_path(x1, y1, x2, y2, conveyors):\n        dx, dy = x2 - x1, y2 - y1\n        if dx == dy == 0:\n            return 0\n\n        points = [(x1, y1)]\n        for x1, y1, x2, y2 in conveyors:\n            points.append((x1, y1))\n            points.append((x2, y2))\n\n        total_distance = float('inf')\n        while points:\n            x, y = points.pop()\n            d = distance(x, y, x2, y2)\n            if d < total_distance:\n                total_distance = d\n                nearest = nearest_point(x2, y2, conveyors)\n                if nearest:\n                    px, py = nearest\n                    dx, dy = px - x2, py - y2\n                else:\n                    dx, dy = 0, 0\n                total_distance += shortest_path(x, y, x2 + dx, y2 + dy, conveyors)\n\n        return total_distance / 2\n\n    x1, y1, x2, y2 = map(float, stdin.readline().split())\n    n = int(stdin.readline())\n    conveyors = [tuple(map(float, stdin.readline().split())) for _ in range(n)]\n\n    return f\"{shortest_path(x1, y1, x2, y2, conveyors):.7f}\""
    },
    {
        "number": 3053,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    if P > N // 2 or K > N or K > len(alphabet) or P > N or P < 1 or K < 1 or N < 1:\n        return \"IMPOSSIBLE\"\n    \n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def longest_palindromic_substring(s: str) -> int:\n        max_length = 1\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if is_palindrome(s[i:j]) and (j - i) > max_length:\n                    max_length = j - i\n        return max_length\n\n    for i in range(len(alphabet) - K + 1):\n        chars = alphabet[i:i+K]\n        for s in permutations(chars):\n            string = ''.join(s)\n            if len(string) == N and len(set(string)) == K and longest_palindromic_substring(string) == P:\n                return string\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3053,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n\n    if P > N // 2:\n        return \"IMPOSSIBLE\"\n\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    result = []\n\n    for i in range(K):\n        result.append(alphabet[i])\n\n    while len(result) < N:\n        for i in range(K):\n            if len(result) >= N:\n                break\n            result.append(alphabet[i])\n\n    result = \"\".join(result)\n\n    if len(set(result)) != K:\n        return \"IMPOSSIBLE\"\n\n    palindrome_length = 1\n    for i in range(P - 1):\n        palindrome_length += 2\n\n    for i in range(N - palindrome_length + 1):\n        if result[i:i + P] == result[i:i + P][::-1]:\n            return result[i:i + P]\n\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3053,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n\n    if n < k or k < p:\n        return \"IMPOSSIBLE\"\n\n    result = []\n    for i in range(k):\n        result.append(chr(ord('a') + i))\n\n    while len(result) < n:\n        for i in range(k):\n            if len(result) >= n:\n                break\n            result.append(chr(ord('a') + i))\n\n    return ''.join(result)\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n\n    if P > N // 2:\n        return \"IMPOSSIBLE\"\n\n    if N == 1:\n        return \"a\"\n\n    if N % 2 == 1:\n        middle_char = \"a\"\n        N -= 1\n    else:\n        middle_char = \"\"\n\n    K -= 1  # Account for middle character\n\n    result = []\n    current_char = \"a\"\n    while K > 0:\n        repetitions = min(2 * P - len(result), K) // 2\n        result.extend([current_char] * repetitions)\n        current_char = chr(ord(current_char) + 1)\n        K -= repetitions\n\n    result = result[:P] + result[::-1] + middle_char + result[:P][::-1]\n\n    return \"\".join(result)\n"
    },
    {
        "number": 3053,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    \n    if p > n // 2:\n        return \"IMPOSSIBLE\"\n    \n    if k > n:\n        return \"IMPOSSIBLE\"\n    \n    if n % 2 == 0 and p == n // 2:\n        return \"a\" * n\n    \n    if n % 2 == 1 and p == n // 2 + 1:\n        return \"a\" * n\n    \n    result = \"\"\n    while k > 0:\n        result += chr(ord(\"a\") + len(result))\n        k -= 1\n        if len(result) == p:\n            break\n    \n    if len(result) < p:\n        return \"IMPOSSIBLE\"\n    \n    return result[:n]"
    },
    {
        "number": 3053,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    \n    if P > N // 2:\n        return \"IMPOSSIBLE\"\n    \n    if N == 1:\n        return \"a\"\n    \n    if N == 2:\n        return \"aa\" if K == 1 else \"ab\"\n    \n    if P == 1:\n        return \"a\" * N\n    \n    if P == 2:\n        if K == 1:\n            return \"a\" * (N - 1) + \"b\"\n        elif K == 2:\n            return \"ab\" * (N // 2) + \"a\" * (N % 2)\n        else:\n            return \"IMPOSSIBLE\"\n    \n    if P == 3:\n        if K == 1:\n            return \"a\" * N\n        elif K == 2:\n            return \"ab\" * (N // 2) + \"a\" * (N % 2)\n        elif K == 3:\n            return \"a\" * (N - 2) + \"abc\"\n        else:\n            return \"IMPOSSIBLE\"\n    \n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3053,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if N < P:\n        return \"IMPOSSIBLE\"\n    if K * (K - 1) // 2 >= N:\n        return \"IMPOSSIBLE\"\n    if P == 1:\n        return \"a\" * N\n    result = []\n    chars = [chr(i) for i in range(97, 123)]\n    for _ in range(K):\n        result.append(chars.pop())\n    for _ in range(N - len(result)):\n        result.append(result[0])\n    return \"\".join(result)"
    },
    {
        "number": 3053,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    \n    if P > N // 2:\n        return \"IMPOSSIBLE\"\n    \n    if P == N // 2 and N % 2 == 0:\n        return \"a\" * N\n    \n    if K > P:\n        return \"IMPOSSIBLE\"\n    \n    result = []\n    current_char = ord('a')\n    remaining_chars = K\n    \n    for _ in range(N // 2):\n        result.append(chr(current_char))\n        remaining_chars -= 1\n        if remaining_chars == 0:\n            current_char += 1\n            remaining_chars = K\n    \n    if N % 2 == 1:\n        result.append(chr(current_char))\n    \n    return ''.join(result)"
    },
    {
        "number": 3053,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if K * 2 > N:\n        return \"IMPOSSIBLE\"\n\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    result = []\n    for i in range(K):\n        result.append(alphabet[i])\n        result.append(alphabet[i])\n    if P == N:\n        result.append(alphabet[K])\n    elif P < N:\n        result.append(alphabet[K - 1])\n        result.append(alphabet[K - 1])\n\n    return \"\".join(result)"
    },
    {
        "number": 3053,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n\n    # If P is odd, the palindromic substring must be in the center of the string,\n    # and the rest of the characters can be filled in with any distinct K-P characters\n    if P % 2 == 1:\n        if N - P >= K:\n            return 'a' * (N - P) + ''.join(chr(ord('a') + i) for i in range(K))\n        else:\n            return \"IMPOSSIBLE\"\n\n    # If P is even, we can divide the palindrome into two halves of length P/2,\n    # and fill the rest of the string with any distinct K-P/2 characters\n    else:\n        P = P // 2\n        if N - 2 * P >= K:\n            return 'a' * (N - 2 * P) + ''.join(chr(ord('a') + i) for i in range(K))\n        else:\n            return \"IMPOSSIBLE\""
    },
    {
        "number": 3054,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n        word = word.upper()\n        count = 0\n        i = 0\n        while i < len(word):\n            if word[i] in vowels:\n                if i == len(word) - 1 or word[i + 1] not in vowels:\n                    count += 1\n            i += 1\n        if word[-1] == 'E' and (len(word) < 3 or word[-2] != 'L' or word[-3] not in vowels):\n            count -= 1\n        if word.endswith('ES') and len(word) > 2 and word[-3] not in vowels and word[-2] in vowels:\n            count -= 1\n        return count\n\n    def is_haiku(line: str) -> bool:\n        words = line.split()\n        if len(words) != 3:\n            return False\n        first_line = [w for w in words if len(w) > 1 and w[-1] in {'.', ',', ';', ':', '!', '?'}]\n        second_line = [w for w in words if w not in first_line]\n        if len(first_line) != 2 or len(second_line) != 1:\n            return False\n        first_syllables = sum(count_syllables(w) for w in first_line)\n        second_syllables = sum(count_syllables(w) for w in second_line)\n        if first_syllables != 10 or second_syllables != 7:\n            return False\n        return True\n\n    if is_haiku(stdin):\n        words = stdin.split()\n        first_line = ' '.join(words[:2])\n        second_line = words[2]\n        third_line = ' '.join(words[3:])\n        return f'{first_line}\\n{second_line}\\n{third_line}'\n    else:\n        return stdin"
    },
    {
        "number": 3054,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUYaeiouy\"\n        consonants = \"BCDFGHJKLMNPQRSTVWXZbcdfghjklmnpqrstvwxz\"\n        word = word.strip()\n        count = 0\n        last_char = None\n        for i, char in enumerate(word):\n            if char in vowels:\n                if last_char not in vowels:\n                    count += 1\n            elif char in consonants:\n                if i == len(word) - 1:\n                    if char != 'Y' or (char == 'Y' and word[i - 1] in vowels):\n                        count += 1\n                elif char == 'Y' and word[i + 1] in vowels:\n                    count += 1\n                elif char == 'Q' and word[i + 1] == 'U':\n                    count += 1\n                elif word[i + 1] not in consonants:\n                    count += 1\n            last_char = char\n        if word[-1] == 'E' and (len(word) < 3 or (word[-2] != 'L' or word[-3] not in consonants)):\n            count -= 1\n        elif word[-2:] == 'ES' and (len(word) < 4 or word[-3] in consonants):\n            count -= 1\n        return count\n\n    words = stdin.split()\n    haiku = []\n    line1, line2, line3 = [], [], []\n    for word in words:\n        syllables = count_syllables(word)\n        if len(line1) + len(line2) + len(line3) < 5:\n            line1.append(word)\n        elif len(line2) + len(line3) < 7:\n            line2.append(word)\n        elif len(line3) < 5:\n            line3.append(word)\n        else:\n            haiku = []\n            break\n\n    if len(line1) == len(line2) == len(line3) == 5:\n        haiku.append(' '.join(line1))\n        haiku.append(' '.join(line2))\n        haiku.append(' '.join(line3))\n        return '\\n'.join(haiku)\n    else:\n        return stdin"
    },
    {
        "number": 3054,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_vowel(c):\n        return c.upper() in \"AEIOUY\"\n\n    def count_syllables(word):\n        syllables = 0\n        prev_char = \"\"\n        for c in word:\n            if is_vowel(c) and not is_vowel(prev_char):\n                syllables += 1\n            prev_char = c\n        return syllables\n\n    def split_into_words(line):\n        words = []\n        word = \"\"\n        for c in line:\n            if c.isalpha():\n                word += c\n            else:\n                if word:\n                    words.append(word)\n                    word = \"\"\n                words.append(c)\n        if word:\n            words.append(word)\n        return words\n\n    def check_haiku(words):\n        if len(words) != 12:\n            return False\n        return all(count_syllables(words[i]) == 5 for i in [0, 3, 6]) and all(\n            count_syllables(words[i]) == 7 for i in [1, 4, 7])\n\n    def format_haiku(words):\n        lines = [\"\", \"\", \"\"]\n        line_length = 0\n        word_index = 0\n        for i in range(3):\n            while line_length < 5 + i * 2 and word_index < len(words):\n                word = words[word_index]\n                if len(word) + line_length <= 5 + i * 2:\n                    lines[i] += word\n                    line_length += len(word)\n                    if word_index < len(words) - 1:\n                        lines[i] += \" \"\n                        line_length += 1\n                else:\n                    break\n                word_index += 1\n            lines[i] = lines[i].rstrip()\n            line_length = 0\n        return \"\\n\".join(lines)\n\n    words = split_into_words(stdin)\n    if check_haiku(words):\n        return format_haiku(words)\n    else:\n        return stdin"
    },
    {
        "number": 3054,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Define helper functions\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUYaeiouy\"\n        consonants = \"BCDFGHJKLMNPQRSTVWXZbcdfghjklmnpqrstvwxz\"\n        word = word.strip(\".,!?;:\")\n        count = 0\n        for i, char in enumerate(word):\n            if char in vowels:\n                if i == 0 or word[i - 1] in consonants:\n                    count += 1\n            elif char in consonants:\n                if i == len(word) - 1 or word[i + 1] in consonants:\n                    if i == 0 or word[i - 1] in consonants:\n                        count += 1\n        return count\n\n    def is_valid_haiku_line(line: str) -> bool:\n        words = line.split()\n        syllable_count = sum(count_syllables(word) for word in words)\n        return syllable_count == 5 if len(words) == 2 else syllable_count == 7\n\n    def is_valid_haiku(haiku: str) -> bool:\n        lines = haiku.split(\"\\n\")\n        return all(is_valid_haiku_line(line) for line in lines)\n\n    def create_haiku(line: str) -> str:\n        words = line.split()\n        haiku = \"\"\n        for i in range(len(words)):\n            if i % 2 == 0:\n                haiku += words[i]\n            else:\n                haiku += words[i] + \" \"\n            if i % 2 == 1 and i != len(words) - 1:\n                haiku += \"\\n\"\n        return haiku\n\n    # Main function\n    if is_valid_haiku(stdin):\n        return create_haiku(stdin)\n    else:\n        return stdin"
    },
    {
        "number": 3054,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUYaeiouy\"\n        word = word.strip()\n        syllables = 0\n        last_char = None\n        last_vowel = False\n        for char in word:\n            if char.isalpha():\n                if char in vowels:\n                    if not last_vowel:\n                        syllables += 1\n                    last_vowel = True\n                else:\n                    last_vowel = False\n            elif char == 'Q' and last_char == 'U':\n                pass\n            elif char == 'Y' and last_char in vowels:\n                pass\n            else:\n                last_vowel = False\n            last_char = char\n        return syllables\n\n    words = stdin.strip().split()\n    syllable_count = 0\n    line_breaks = [0, 0]\n    for i, word in enumerate(words):\n        syllables = count_syllables(word)\n        if syllable_count + syllables > 17:\n            return stdin\n        syllable_count += syllables\n        if syllable_count == 5 or syllable_count == 12:\n            if i == len(words) - 1:\n                return stdin\n            syllable_count += 1\n            line_breaks[len(line_breaks) - (syllable_count // 5) - 1] = i + 1\n\n    lines = [\"\", \"\", \"\"]\n    for i, line in enumerate(lines):\n        for j in range(line_breaks[i], line_breaks[i + 1]):\n            line += words[j]\n            if j < line_breaks[i + 1] - 1:\n                line += \" \"\n        lines[i] = line.strip()\n\n    return \"\\n\".join(lines)"
    },
    {
        "number": 3054,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUYaeiouy\"\n        word = word.strip(\",.!?\")\n        if word.endswith(\"es\") and len(word) > 3 and word[-3] not in vowels:\n            return count_syllables(word[:-2])\n        if word.endswith((\"al\", \"ole\", \"olea\", \"eo\", \"eoa\")):\n            return count_syllables(word[:-1])\n        if word.endswith(\"que\") or word.endswith(\"gue\"):\n            return count_syllables(word[:-1])\n        if word.endswith((\"ed\", \"ing\")):\n            return count_syllables(word[:-2])\n        if word.endswith((\"ly\", \"lessly\", \"ness\", \"cian\", \"cial\", \"tion\", \"sion\", \"ation\", \"ution\", \"tide\")):\n            return count_syllables(word[:-2])\n        if word.endswith(\"y\") and len(word) > 1 and word[-2] not in vowels:\n            return count_syllables(word[:-1] + \"i\")\n        if word.endswith((\"e\", \"a\", \"i\", \"o\", \"u\")):\n            return count_syllables(word[:-1])\n        count = 0\n        for i in range(len(word)):\n            if word[i] in vowels:\n                if i == 0 or word[i - 1] not in vowels:\n                    count += 1\n        if word.endswith(\"e\") and len(word) > 1 and word[-2] not in vowels:\n            count -= 1\n        return count\n\n    def is_haiku(line: str) -> bool:\n        words = line.split()\n        if len(words) < 3:\n            return False\n        total_syllables = 0\n        for word in words:\n            total_syllables += count_syllables(word)\n        return total_syllables == 17\n\n    def format_haiku(line: str) -> str:\n        words = line.split()\n        output = \"\"\n        for i in range(len(words)):\n            if i % 2 == 0:\n                output += words[i].strip(\",.!?\")\n            else:\n                output += \" \" + words[i].strip(\",.!?\")\n            if i == 2 or i == 4:\n                output += \"\\n\"\n        return output\n\n    line = stdin.strip()\n    if is_haiku(line):\n        return format_haiku(line)\n    else:\n        return line"
    },
    {
        "number": 3054,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUYaeiouy\"\n        word = word.strip()\n        if len(word) <= 1:\n            return 1\n        if word[-1] in vowels and len(word) > 2 and word[-2] not in vowels:\n            return 1\n        return sum(1 for i, c in enumerate(word) if c in vowels and (i == 0 or word[i - 1] not in vowels) and (i == len(word) - 1 or word[i + 1] not in vowels) and (c != 'Y' or i == len(word) - 1 or word[i + 1] in vowels))\n\n    def to_haiku(words: list) -> str:\n        haiku = []\n        line1 = []\n        line2 = []\n        line3 = []\n        for word in words:\n            if count_syllables(word) == 5:\n                line1.append(word)\n            elif count_syllables(word) == 7:\n                line2.append(word)\n            elif count_syllables(word) == 1:\n                if line1:\n                    haiku.append(line1)\n                    line1 = []\n                if line2:\n                    haiku.append(line2)\n                    line2 = []\n                line3.append(word)\n        if line1 and line2 and line3:\n            haiku.append(line1)\n            haiku.append(line2)\n            haiku.append(line3)\n            return \"\\n\".join([\" \".join(line) for line in haiku])\n        return \"\".join(words)\n\n    words = stdin.split()\n    return to_haiku(words) "
    },
    {
        "number": 3054,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUY\"\n        word = word.upper()\n        count = 0\n        last_char = ''\n        for char in word:\n            if char in vowels:\n                if last_char not in vowels and last_char != '':\n                    count += 1\n            last_char = char\n        return count\n\n    def is_valid_haiku(lines: list) -> bool:\n        return len(lines) == 3 and all(count_syllables(line.split()[0]) == 5 for line in lines) and \\\n            count_syllables(lines[1].split()[0]) == 7 and count_syllables(lines[1].split()[-1]) == 5\n\n    def process_text(text: str) -> list:\n        return [line.strip() for line in text.split(\"\\n\") if line.strip()]\n\n    lines = process_text(stdin)\n    if is_valid_haiku(lines):\n        return \"\\n\".join(lines)\n    else:\n        return stdin"
    },
    {
        "number": 3054,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUYaeiouy\"\n        word = word.strip()\n        count = 0\n        last_char = \"\"\n        for char in word:\n            if char in vowels:\n                if last_char.lower() not in vowels and last_char.lower() != \"u\":\n                    count += 1\n            last_char = char\n        return count\n\n    def can_make_haiku(words: list) -> bool:\n        total_syllables = sum(count_syllables(word) for word in words)\n        if total_syllables % 17 == 0:\n            return True\n        return False\n\n    def format_haiku(words: list) -> str:\n        lines = []\n        line_length = 0\n        for word in words:\n            if line_length + len(word) + 1 > 17:\n                lines.append(word)\n                line_length = len(word)\n            else:\n                lines[-1] += \" \" + word\n                line_length += 1 + len(word)\n        return \"\\n\".join(lines)\n\n    words = stdin.split()\n    if can_make_haiku(words):\n        return format_haiku(words)\n    else:\n        return stdin"
    },
    {
        "number": 3054,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUY\"\n        word = word.upper()\n        syllables = 0\n        prev_char = None\n        for char in word:\n            if char in vowels:\n                if prev_char not in vowels:\n                    syllables += 1\n            prev_char = char\n        if word[-1] == 'E' and (len(word) < 3 or word[-2] not in 'LE' or (word[-2] == 'L' and word[-3] not in vowels)):\n            syllables -= 1\n        if word.endswith('ES') and len(word) > 2 and word[-2] not in vowels and (word[-3] in vowels or word[-3] in 'QU'):\n            syllables -= 1\n        return max(syllables, 1)\n\n    def is_valid_haiku(line1: str, line2: str, line3: str) -> bool:\n        words1 = line1.split()\n        words2 = line2.split()\n        words3 = line3.split()\n        total_syllables = sum(count_syllables(word) for word in words1 + words2 + words3)\n        return total_syllables == 17 and len(words1) == len(words2) == len(words3) == 5\n\n    def format_haiku(line1: str, line2: str, line3: str) -> str:\n        words1 = line1.split()\n        words2 = line2.split()\n        words3 = line3.split()\n        line_length = len(line1)\n        line1 = \" \".join(words1)\n        line2 = \" \".join(words2)\n        line3 = \" \".join(words3)\n        return line1.ljust(line_length) + \"\\n\" + line2.ljust(line_length) + \"\\n\" + line3.ljust(line_length)\n\n    lines = stdin.split(\"\\n\")\n    for line in lines:\n        words = line.split()\n        if len(words) == 15 and is_valid_haiku(*words):\n            return format_haiku(*words)\n    return stdin"
    },
    {
        "number": 3055,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    names = sorted(stdin.split('\\n')[1:])\n    thore_index = names.index(\"ThoreHusfeldt\")\n    if thore_index == 0:\n        return \"Thore is awesome\"\n    for i in range(thore_index - 1, -1, -1):\n        if names[i].startswith(\"ThoreHusfeldt\"):\n            return \"Thore sucks\"\n        if names[i].startswith(\"ThoreHusfeld\"):\n            return \"ThoreH\"\n    return \"ThoreH\""
    },
    {
        "number": 3055,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    names = sorted(stdin.split('\\n')[1:])\n    \n    thore_index = names.index(\"ThoreHusfeldt\")\n    \n    if thore_index == 0:\n        return \"Thore is awesome\"\n    \n    if \"ThoreHusfeldt\" not in names:\n        return \"Thore sucks\"\n    \n    prefix = \"ThoreH\"\n    for name in names[:thore_index]:\n        if name.startswith(prefix):\n            prefix += 'u'\n    \n    return prefix"
    },
    {
        "number": 3055,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    names = sorted(stdin.split(\"\\n\")[1:])\n    \n    if names[0] == \"ThoreHusfeldt\":\n        return \"Thore is awesome\"\n    \n    thore_index = names.index(\"ThoreHusfeldt\")\n    \n    for i in range(thore_index - 1, -1, -1):\n        if names[i].startswith(\"ThoreHusfeld\"):\n            return \"Thore sucks\"\n        \n        for j in range(len(names[i]) + 1, len(\"ThoreHusfeldt\") + 1):\n            prefix = \"ThoreHusfeldt\"[:j]\n            if names[i].startswith(prefix) and prefix not in names[i:thore_index]:\n                return prefix\n\n    return \"Thore is awesome\""
    },
    {
        "number": 3055,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    names = sorted(stdin.split('\\n')[1:])\n    thore_index = names.index('ThoreHusfeldt')\n\n    if thore_index == 0:\n        return \"Thore is awesome\"\n    else:\n        for i in range(thore_index - 1, -1, -1):\n            if names[i].startswith(\"ThoreHusfeldt\"):\n                return names[i]\n        return \"Thore sucks\""
    },
    {
        "number": 3055,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    names = sorted(stdin.split('\\n')[1:], key=lambda x: len(x))\n    thore_index = names.index(\"ThoreHusfeldt\")\n\n    if thore_index == 0:\n        return \"Thore is awesome\"\n\n    for i in range(thore_index - 1, -1, -1):\n        if names[i].startswith(\"ThoreHusfeldt\"):\n            return \"Thore sucks\"\n\n    best_prefix = \"ThoreH\"\n    for i in range(thore_index - 1, -1, -1):\n        for j in range(len(best_prefix), len(names[i]) + 1):\n            prefix = names[i][:j]\n            if prefix not in names[i + 1:thore_index] + names[thore_index + 1:] + [\"ThoreHusfeldt\"]:\n                best_prefix = prefix\n                break\n        if best_prefix == names[i]:\n            break\n\n    return best_prefix "
    },
    {
        "number": 3055,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Split input into lines\n    lines = stdin.split('\\n')\n\n    # Parse input\n    n = int(lines[0])\n    names = lines[1:]\n\n    # Check if ThoreHusfeldt is first on the scoreboard\n    if names[0] == \"ThoreHusfeldt\":\n        return \"Thore is awesome\"\n\n    # Check if another Thore with prefix \"ThoreHusfeld\" is above ThoreHusfeldt\n    for name in names:\n        if name.startswith(\"ThoreHusfeld\"):\n            return \"Thore sucks\"\n\n    # Find smallest unique prefix of ThoreHusfeldt\n    prefix = \"\"\n    for i in range(1, len(\"ThoreHusfeldt\")):\n        for name in names:\n            if name.startswith(\"ThoreHusfeldt\"[:i]):\n                prefix = \"ThoreHusfeldt\"[:i]\n                break\n        if prefix:\n            break\n\n    return prefix if prefix else \"Thore is awesome\""
    },
    {
        "number": 3055,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    names = sorted(stdin.split(\"\\n\")[1:])\n\n    thore_index = names.index(\"ThoreHusfeldt\")\n    thore_prefix = \"ThoreH\"\n    thore_found = False\n\n    for i in range(thore_index - 1, -1, -1):\n        if names[i].startswith(thore_prefix):\n            thore_found = True\n            thore_prefix += names[i][len(thore_prefix)]\n        else:\n            break\n\n    if thore_found:\n        return thore_prefix\n    elif thore_index == 0:\n        return \"Thore is awesome\"\n    else:\n        return \"Thore sucks\""
    },
    {
        "number": 3055,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    names = sorted(stdin.split('\\n')[1:])\n    thore_index = names.index('ThoreHusfeldt')\n\n    if thore_index == 0:\n        return 'Thore is awesome'\n    elif 'ThoreHusfeldt' in names[:thore_index]:\n        return 'Thore sucks'\n    else:\n        min_prefix = 'ThoreHusfeldt'\n        for i in range(thore_index - 1, -1, -1):\n            if names[i].startswith('ThoreHusfeldt'):\n                min_prefix = min(min_prefix, 'ThoreHusfeldt'[:len(min_prefix)])\n            else:\n                break\n        return min_prefix"
    },
    {
        "number": 3055,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    names = stdin.split('\\n')[1:]\n\n    thore_index = names.index(\"ThoreHusfeldt\")\n\n    if thore_index == 0:\n        return \"Thore is awesome\"\n\n    for i in range(thore_index):\n        if names[i].startswith(\"ThoreHusfeldt\"):\n            return \"Thore sucks\"\n\n    prefix = \"Thore\"\n    for i in range(1, len(\"ThoreHusfeldt\")):\n        if not any(name.startswith(prefix) for name in names[:thore_index]):\n            prefix += \"H\"\n        else:\n            break\n\n    return prefix "
    },
    {
        "number": 3055,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    names = [stdin.readline().strip() for _ in range(n)]\n\n    thore_index = names.index(\"ThoreHusfeldt\")\n    thore_prefix = \"ThoreH\"\n    while True:\n        if any(name.startswith(thore_prefix) for name in names[:thore_index]):\n            thore_prefix += \"u\"\n        else:\n            break\n\n    if thore_index == 0:\n        return \"Thore is awesome\"\n    else:\n        if any(name.startswith(thore_prefix) for name in names[:thore_index]):\n            return \"Thore sucks\"\n        else:\n            return thore_prefix\n"
    },
    {
        "number": 3056,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, walk: str) -> int:\n        if not walk:\n            return node\n        if walk[0] == 'L':\n            return dfs(node * 2, walk[1:])\n        elif walk[0] == 'R':\n            return dfs(node * 2 + 1, walk[1:])\n        else:\n            return node\n\n    total_value = 0\n    for walk in stdin.split('*'):\n        total_value += dfs(1, walk)\n\n    return str(total_value)"
    },
    {
        "number": 3056,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    max_value = 2**30\n\n    def dfs(node: int, move: str) -> int:\n        if not move:\n            return node\n        if move[0] == '*':\n            return dfs(node, move[1:]) + dfs(node * 2, move[1:]) + dfs(node * 2 + 1, move[1:])\n        if move[0] == 'L':\n            return dfs(node * 2, move[1:])\n        if move[0] == 'R':\n            return dfs(node * 2 + 1, move[1:])\n        return node\n\n    value = dfs(1, stdin)\n    return str(value)"
    },
    {
        "number": 3056,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_value(walk: str) -> int:\n        value = 1\n        for step in walk:\n            if step == 'L':\n                value *= 2\n            elif step == 'R':\n                value = value * 2 + 1\n        return value\n\n    def expand_pattern(pattern: str) -> set:\n        if '*' not in pattern:\n            return set([pattern])\n        else:\n            result = set()\n            for i, char in enumerate(pattern):\n                if char == '*':\n                    result |= set([pattern[:i] + step + pattern[i + 1:] for step in 'LRP'])\n            return result\n\n    def calculate_set_value(walks: set) -> int:\n        return sum(calculate_value(walk) for walk in walks)\n\n    pattern = stdin.strip()\n    walks = expand_pattern(pattern)\n    result = calculate_set_value(walks)\n    return str(result)\n"
    },
    {
        "number": 3056,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, path: str) -> int:\n        if path == \"L\":\n            return node * 2\n        elif path == \"R\":\n            return node * 2 + 1\n        else:\n            return node\n\n    total_value = 0\n    for walk in stdin.split(\"*\"):\n        value = 1\n        for step in walk:\n            value = dfs(value, step)\n        total_value += value\n\n    return str(total_value)"
    },
    {
        "number": 3056,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_value(walk: str) -> int:\n        value = 1\n        for move in walk:\n            if move == 'L':\n                value *= 2\n            elif move == 'R':\n                value = value * 2 + 1\n        return value\n\n    def expand_pattern(pattern: str) -> set:\n        if '*' not in pattern:\n            return {pattern}\n        else:\n            expansions = set()\n            for i, char in enumerate(pattern):\n                if char == '*':\n                    for left in expand_pattern(pattern[:i]):\n                        for right in expand_pattern(pattern[i + 1:]):\n                            for move in ('L', 'R', 'P'):\n                                expansions.add(left + move + right)\n            return expansions\n\n    walks = expand_pattern(stdin)\n    total_value = sum(calculate_value(walk) for walk in walks)\n    return str(total_value)"
    },
    {
        "number": 3056,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, path: str) -> int:\n        if path == \"L\":\n            return node * 2\n        elif path == \"R\":\n            return node * 2 + 1\n        else:\n            return node\n\n    def value(path: str) -> int:\n        node = 1\n        for p in path:\n            node = dfs(node, p)\n        return node\n\n    total = 0\n    for path in stdin.split(\"*\"):\n        total += value(path)\n\n    return str(total)"
    },
    {
        "number": 3056,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(stdin)\n    combinations = ['']\n    \n    for char in stdin:\n        if char == '*':\n            new_combinations = []\n            for comb in combinations:\n                new_combinations.append(comb + 'L')\n                new_combinations.append(comb + 'R')\n                new_combinations.append(comb + 'P')\n            combinations = new_combinations\n        else:\n            for i in range(len(combinations)):\n                combinations[i] += char\n    \n    total_value = 0\n    for comb in combinations:\n        value = 1\n        for move in comb:\n            if move == 'L':\n                value *= 2\n            elif move == 'R':\n                value = value * 2 + 1\n        total_value += value\n    \n    return str(total_value)"
    },
    {
        "number": 3056,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, path: str) -> int:\n        if path == \"\":\n            return node\n        elif path[0] == 'L':\n            return dfs(node * 2, path[1:])\n        elif path[0] == 'R':\n            return dfs(node * 2 + 1, path[1:])\n        else:\n            return node\n\n    total_value = 0\n    for i in range(len(stdin)):\n        for j in range(i, len(stdin)):\n            if stdin[i:j+1].count('*') <= 10000:\n                for walk in stdin[i:j+1]:\n                    if walk == '*':\n                        for c in 'LRP':\n                            total_value += dfs(1, stdin[i:j].replace('*', c))\n                    else:\n                        total_value += dfs(1, stdin[i:j+1])\n                        break\n    return str(total_value)"
    },
    {
        "number": 3056,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    set_walks = stdin.split()[0]\n    value = 0\n    for walk in set_walks:\n        if '*' in walk:\n            for i in range(3):\n                for j in range(3):\n                    new_walk = walk.replace('*', 'LRP'[i], 1).replace('*', 'LRP'[j], 1)\n                    value += calculate_walk(new_walk)\n        else:\n            value += calculate_walk(walk)\n    return str(value)\n\ndef"
    },
    {
        "number": 3056,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, move: str) -> int:\n        if not move:\n            return node\n        if move[0] == 'L':\n            return dfs(node * 2, move[1:])\n        elif move[0] == 'R':\n            return dfs(node * 2 + 1, move[1:])\n        else:\n            return dfs(node, move[1:])\n\n    total = 0\n    for move in stdin.split('*'):\n        total += dfs(1, move)\n    return str(total)"
    },
    {
        "number": 3057,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_rhyme(word1, word2):\n        return word1[-min(3, len(word1), len(word2)):].lower() == word2[-min(3, len(word1), len(word2)):].lower()\n\n    def find_contradiction(statements, word):\n        for w1, w2 in statements:\n            if w1 == word and w2 != word:\n                return True\n        return False\n\n    def is_consistent(statements):\n        for i, (w1, w2) in enumerate(statements):\n            if w1 == w2:\n                continue\n            for j in range(i + 1, len(statements)):\n                w3, w4 = statements[j]\n                if (w1 == w3 and w2 != w4) or (w1 == w4 and w2 != w3):\n                    return False\n                if (w1 != w3 and w1 != w4) or (w2 != w3 and w2 != w4):\n                    continue\n                if (w1 == w3 and w2 == w4) or (w1 == w4 and w2 == w3):\n                    continue\n                if (w1 == w3 and is_rhyme(w2, w4)) or (w1 == w4 and is_rhyme(w2, w3)):\n                    continue\n                if (w2 == w3 and is_rhyme(w1, w4)) or (w2 == w4 and is_rhyme(w1, w3)):\n                    continue\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    statements = []\n    for i in range(1, N + 1):\n        statement = lines[i].split()\n        if statement[1] == 'not':\n            statements.append((statement[0], '~' + statement[2]))\n        else:\n            statements.append((statement[0], statement[2]))\n\n    if is_consistent(statements):\n        return 'yes'\n    else:\n        return 'wait what?' "
    },
    {
        "number": 3057,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    statements = []\n    N = int(stdin.readline())\n    for _ in range(N):\n        x, y = stdin.readline().strip().split()\n        if y not in [statement[1] for statement in statements]:\n            statements.append((x, y))\n        elif y in [statement[1] for statement in statements] and x != [statement[0] for statement in statements if statement[1] == y][0]:\n            return \"wait what?\"\n\n    for i in range(len(statements)):\n        for j in range(i + 1, len(statements)):\n            x1, y1 = statements[i]\n            x2, y2 = statements[j]\n            if (x1 == x2 and y1 != y2) or (x1 != x2 and y1 == y2):\n                return \"wait what?\"\n\n            if y1 == y2:\n                if x1 != x2:\n                    for statement in statements:\n                        if statement[0] == x1:\n                            statement[0] = x2\n                        elif statement[0] == x2:\n                            statement[0] = x1\n                        if statement[1] == y1:\n                            statement[1] = y2\n                        elif statement[1] == y2:\n                            statement[1] = y1\n\n            if x1 == x2 or y1 == y2:\n                continue\n\n            if x1[-3:] == y1[-3:] or x2[-3:] == y2[-3:]:\n                return \"wait what?\"\n\n    return \"yes\""
    },
    {
        "number": 3057,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def rhyme(word1, word2):\n        return word1[-min(3, len(word1), len(word2)):] == word2[-min(3, len(word1), len(word2)):]\n\n    def is_consistent(statement, words):\n        x, y = statement.split()\n        if statement.startswith(\"not\"):\n            if x == y or rhyme(x, y) or x + x == y:\n                return False\n        else:\n            if not rhyme(x, y) and x != y:\n                return False\n        return True\n\n    def update_words(statement, words):\n        x, y = statement.split()\n        if x not in words:\n            words[x] = set()\n        if y not in words:\n            words[y] = set()\n\n        if statement.startswith(\"not\"):\n            words[x].add(y)\n            words[y].add(x)\n        else:\n            words[x].add(x)\n            words[y].add(y)\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    statements = lines[1:N + 1]\n    words = {}\n\n    for statement in statements:\n        if not is_consistent(statement, words):\n            return \"wait what?\"\n        update_words(statement, words)\n\n    for x in words:\n        for y in words[x]:\n            if x != y and x + x != y and not rhyme(x, y) and y in words and x in words[y]:\n                return \"wait what?\"\n    return \"yes\""
    },
    {
        "number": 3057,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def rhyme(word1, word2):\n        return word1[-min(3, len(word1), len(word2)):].lower() == word2[-min(3, len(word1), len(word2)):].lower()\n\n    def contradict(x, y, d):\n        if x in d and y in d and d[x] != d[y]:\n            return True\n        d[x] = y\n        return False\n\n    def process(words, d):\n        for i in range(len(words) - 1):\n            for j in range(i + 1, len(words)):\n                if rhyme(words[i], words[j]):\n                    if contradict(words[i], words[j], d):\n                        return True\n        return False\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    words = []\n    d = {}\n\n    for i in range(1, N + 1):\n        word1, word2, is_same = lines[i].split()\n        if is_same == 'not':\n            if contradict(word1, word2, d):\n                return 'wait what?'\n        else:\n            if contradict(word1, word2, d):\n                return 'wait what?'\n            if word1 not in words:\n                words.append(word1)\n            if word2 not in words:\n                words.append(word2)\n\n    for word1 in words:\n        for word2 in words:\n            if word1 != word2 and rhyme(word1, word2) and contradict(word1, word2, d):\n                return 'wait what?'\n\n    return 'yes'"
    },
    {
        "number": 3057,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_rhyme(word1: str, word2: str) -> bool:\n        min_length = min(3, len(word1), len(word2))\n        return word1[-min_length:] == word2[-min_length:]\n\n    def is_consistent(statement1: str, statement2: str) -> bool:\n        words1 = statement1.split()\n        words2 = statement2.split()\n\n        if words1[1] == \"is\" and words2[1] == \"is\":\n            if words1[0] == words2[0]:\n                return True\n            if is_rhyme(words1[0], words2[0]):\n                return True\n        elif words1[1] == \"not\" and words2[1] == \"not\":\n            if words1[0] == words2[0]:\n                return True\n            if is_rhyme(words1[0], words2[0]):\n                return True\n        elif words1[1] == \"is\" and words2[1] == \"not\":\n            if words1[0] == words2[0]:\n                return False\n            if is_rhyme(words1[0], words2[0]):\n                return False\n        elif words1[1] == \"not\" and words2[1] == \"is\":\n            if words1[0] == words2[0]:\n                return False\n            if is_rhyme(words1[0], words2[0]):\n                return False\n\n        return True\n\n    def is_consistent_with_all(statement: str, statements: List[str]) -> bool:\n        for other_statement in statements:\n            if not is_consistent(statement, other_statement):\n                return False\n        return True\n\n    lines = stdin.split(\"\\n\")\n    num_statements = int(lines[0])\n    statements = lines[1:num_statements + 1]\n\n    for statement in statements:\n        if not is_consistent_with_all(statement, statements):\n            return \"wait what?\"\n\n    return \"yes\""
    },
    {
        "number": 3057,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_same_word(word1, word2):\n        return word1 == word2 or abs(len(word1) - len(word2)) <= 3 and word1[-3:] == word2[-3:]\n\n    def is_consistent(statements):\n        for i, (word1, word2) in enumerate(statements):\n            if word1 == word2:\n                continue\n            for j in range(i + 1, len(statements)):\n                word3, word4 = statements[j]\n                if (word1 == word3 and not is_same_word(word2, word4)) or (word1 == word4 and not is_same_word(word2, word3)):\n                    return False\n        return True\n\n    def process_input(stdin):\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        statements = []\n        for line in lines[1:n + 1]:\n            words = line.split()\n            if words[-1] == 'not':\n                word1, word2 = words[0], words[2]\n                statements.append((word1, word2))\n            else:\n                word1, word2 = words[0], words[-1]\n                statements.append((word1, word2))\n        return statements\n\n    statements = process_input(stdin)\n    if is_consistent(statements):\n        return 'yes'\n    else:\n        return 'wait what?'"
    },
    {
        "number": 3057,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n', 1)[0])\n    statements = stdin.split('\\n', 1)[1].split('\\n')\n    words = {}\n    for statement in statements:\n        x, y = statement.split()\n        x_last = x[-min(3, len(x), len(y)):]\n        y_last = y[-min(3, len(x), len(y)):]\n        if x_last == y_last:\n            words[x] = y\n            words[y] = x\n\n    for statement in statements:\n        x, y = statement.split()\n        if x in words and words[x] != y:\n            return \"wait what?\"\n\n    return \"yes\""
    },
    {
        "number": 3057,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_consistent(X: str, Y: str) -> bool:\n        if X == Y:\n            return True\n        min_rhyme_len = min(3, len(X), len(Y))\n        if X[-min_rhyme_len:] == Y[-min_rhyme_len:]:\n            return True\n        return False\n\n    def contradicts(statements: Dict[str, str]) -> bool:\n        for X, Y in statements.items():\n            if Y == \"none\":\n                continue\n            if is_consistent(X, Y) and X in statements and statements[X] != Y:\n                return True\n        return False\n\n    def rhymes_with_anything(word: str, statements: Dict[str, str]) -> bool:\n        for X, Y in statements.items():\n            if Y == \"none\":\n                continue\n            if is_consistent(word, X) or is_consistent(word, Y):\n                return True\n        return False\n\n    statements = {}\n    for i in range(int(stdin.readline())):\n        X, Y = stdin.readline().strip().split()\n        if X not in statements:\n            statements[X] = \"none\"\n        if Y not in statements:\n            statements[Y] = \"none\"\n        if X == \"not\":\n            if statements[Y] != \"none\":\n                return \"wait what?\"\n            statements[Y] = \"none\"\n        elif Y == \"not\":\n            if statements[X] != \"none\":\n                return \"wait what?\"\n            statements[X] = \"none\"\n        elif not rhymes_with_anything(X, statements):\n            statements[X] = Y\n        elif not rhymes_with_anything(Y, statements):\n            statements[Y] = X\n        else:\n            return \"wait what?\"\n\n    if contradicts(statements):\n        return \"wait what?\"\n    return \"yes\" "
    },
    {
        "number": 3057,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_consistent(x: str, y: str) -> bool:\n        if x == y:\n            return True\n        for i in range(1, min(3, len(x), len(y))):\n            if x[-i:] == y[-i:]:\n                return True\n        return False\n\n    def is_consistent_with_rules(rules: Dict[str, Set[str]]) -> bool:\n        for x, ys in rules.items():\n            for y in ys:\n                if not is_consistent(x, y):\n                    return False\n        return True\n\n    def find_contradiction(rules: Dict[str, Set[str]]) -> bool:\n        for x, ys in rules.items():\n            for y in ys:\n                if y != x and all(y not in rules[z] for z in rules if z != x):\n                    return True\n        return False\n\n    N = int(stdin.readline().strip())\n    rules = defaultdict(set)\n    for _ in range(N):\n        x, op, y = stdin.readline().strip().split()\n        if op == \"is\":\n            rules[x].add(y)\n            rules[y].add(x)\n\n    if not is_consistent_with_rules(rules) or find_contradiction(rules):\n        return \"wait what?\"\n    else:\n        return \"yes\""
    },
    {
        "number": 3057,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def rhymes(word1, word2):\n        min_length = min(3, len(word1), len(word2))\n        return word1[-min_length:] == word2[-min_length:]\n\n    def process_statement(statement):\n        if \"is\" in statement:\n            x, y = statement.split(\"is\")\n            x, y = x.strip(), y.strip()\n            if x == y:\n                return None\n            if rhymes(x, y):\n                return f\"{x} is {y}\"\n        elif \"not\" in statement:\n            x, y = statement.split(\"not\")\n            x, y = x.strip(), y.strip()\n            if rhymes(x, y):\n                return f\"{x} not {y}\"\n        return statement\n\n    def is_consistent(statements):\n        for i in range(len(statements)):\n            for j in range(i + 1, len(statements)):\n                if statements[i] is not None and statements[j] is not None:\n                    if statements[i].split()[0] != statements[j].split()[0]:\n                        return False\n        return True\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    statements = [process_statement(lines[i]) for i in range(1, N + 1)]\n\n    if is_consistent(statements):\n        return \"yes\"\n    else:\n        return \"wait what?\""
    },
    {
        "number": 3058,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_parallel_evolution(n, current_species, fossil_species):\n        s1, s2 = 0, 0\n        current_species_set = set(current_species)\n        fossil_species_set = set(fossil_species)\n\n        if len(current_species_set) != len(current_species) or len(fossil_species_set) != len(fossil_species):\n            return False\n\n        for i in range(n):\n            if i == 0:\n                if fossil_species[i] in current_species_set:\n                    s1 += 1\n                else:\n                    return False\n            else:\n                if fossil_species[i] in current_species_set or fossil_species[i] in fossil_species_set[:i]:\n                    s1 += 1\n                else:\n                    s2 += 1\n\n        if s1 + s2 == n:\n            return True\n        else:\n            return False\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    current_species = lines[1]\n    fossil_species = lines[2:]\n\n    if is_parallel_evolution(n, current_species, fossil_species):\n        s1, s2 = 0, 0\n        result = []\n\n        for i in range(n):\n            if i == 0:\n                if fossil_species[i] in current_species:\n                    s1 += 1\n                    result.append(fossil_species[i])\n                else:\n                    return \"impossible\"\n            else:\n                if fossil_species[i] in current_species or fossil_species[i] in fossil_species[:i]:\n                    s1 += 1\n                    result.append(fossil_species[i])\n                else:\n                    s2 += 1\n                    result.append(fossil_species[i])\n\n        return f\"{s1} {s2}\\n{''.join(result)}\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3058,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def common_ancestor(seq1, seq2):\n        for i in range(1, len(seq1) + 1):\n            for j in range(i, len(seq1) + 1):\n                if seq1[i:j] == seq2[i:j]:\n                    return seq1[i:j]\n        return None\n\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    current_species = input_lines[1]\n    fossil_sequences = input_lines[2:]\n\n    path1 = [current_species]\n    path2 = []\n\n    for seq in fossil_sequences:\n        common_ancestor_path1 = common_ancestor(path1[-1], seq)\n        common_ancestor_path2 = common_ancestor(seq, path1[-1])\n\n        if common_ancestor_path1:\n            path1.append(common_ancestor_path1)\n            if seq not in path2:\n                path2.append(seq)\n        elif common_ancestor_path2:\n            path1.append(common_ancestor_path2)\n            if seq not in path2:\n                path2.append(seq)\n        else:\n            return \"impossible\"\n\n    path1.reverse()\n    path2.reverse()\n\n    return f\"{len(path1)} {len(path2)}\\n\" + '\\n'.join(path1) + '\\n' + '\\n'.join(path2)"
    },
    {
        "number": 3058,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_compatible(seq1, seq2):\n        if len(seq1) != len(seq2):\n            return False\n        diff_count = 0\n        for i in range(len(seq1)):\n            if seq1[i] != seq2[i]:\n                diff_count += 1\n                if diff_count > 1:\n                    return False\n        return True\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    current_species = lines[1]\n    fossil_sequences = lines[2:]\n\n    compatible_sequences = [[] for _ in range(n + 1)]\n    compatible_sequences[0].append(current_species)\n\n    for fossil in fossil_sequences:\n        found_compatible = False\n        for i in range(n, -1, -1):\n            if any(is_compatible(fossil, seq) for seq in compatible_sequences[i]):\n                compatible_sequences[i + 1].append(fossil)\n                found_compatible = True\n                break\n        if not found_compatible:\n            compatible_sequences[0].append(fossil)\n\n    for i in range(n, -1, -1):\n        if compatible_sequences[i]:\n            path1_count = len(compatible_sequences[i])\n            path2_count = n - path1_count + 1\n            if path1_count > 1 and path2_count > 1:\n                result = f\"{path1_count} {path2_count}\\n\"\n                result += '\\n'.join(compatible_sequences[i]) + '\\n'\n                result += '\\n'.join(compatible_sequences[i + 1])\n                return result\n    return \"impossible\""
    },
    {
        "number": 3058,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_diff(s1, s2):\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                return i, s2[i]\n        return None\n\n    def path_exists(current, paths, sequences, start):\n        if not sequences:\n            return True\n        for i, sequence in enumerate(sequences):\n            diff = find_diff(current, sequence)\n            if diff and diff[0] >= start:\n                new_current = current[:diff[0]] + diff[1] + current[diff[0] + 1:]\n                if path_exists(new_current, paths, sequences[:i] + sequences[i + 1:], diff[0] + 1):\n                    paths.append(new_current)\n                    return True\n        return False\n\n    lines = stdin.split('\\n')\n    n, current = int(lines[0]), lines[1]\n    sequences = lines[2:]\n    paths1, paths2 = [], []\n\n    if path_exists(current, paths1, sequences, 0):\n        s1, s2 = len(paths1), len(paths2)\n        output = [f\"{s1} {s2}\"]\n        for path in paths1:\n            output.append(path)\n        return '\\n'.join(output)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3058,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    current_species = lines[1]\n    fossil_sequences = lines[2:]\n\n    def is_valid_path(path):\n        for i in range(len(path) - 1):\n            if not is_evolutionary_path(path[i], path[i + 1]):\n                return False\n        return True\n\n    def is_evolutionary_path(seq1, seq2):\n        diff_count = 0\n        for i in range(len(seq1)):\n            if seq1[i] != seq2[i]:\n                diff_count += 1\n                if diff_count > 1:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1 - i):\n            path1 = fossil_sequences[:i]\n            path2 = fossil_sequences[i:i + j]\n            path3 = fossil_sequences[i + j:]\n            if is_valid_path(path1) and is_valid_path(path2) and is_valid_path(path3):\n                return f\"{i} {j}\\n{''.join(path1)}\\n{''.join(path2)}\\n{''.join(path3)}\"\n\n    return \"impossible\""
    },
    {
        "number": 3058,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s1_count, s2_count, total_count):\n        return 0 <= s1_count <= total_count and 0 <= s2_count <= total_count and s1_count + s2_count == total_count\n\n    def find_paths(sequences, current_sequence):\n        if not sequences:\n            return [[current_sequence]]\n\n        paths = []\n        for i, sequence in enumerate(sequences):\n            if sequence.startswith(current_sequence):\n                remaining_sequences = sequences[:i] + sequences[i + 1:]\n                new_path = find_paths(remaining_sequences, sequence)\n                if new_path:\n                    paths.extend(new_path)\n\n        return paths\n\n    lines = stdin.split('\\n')\n    total_count = int(lines[0])\n    current_sequence = lines[1]\n    sequences = lines[2:]\n\n    paths = find_paths(sequences, current_sequence)\n\n    for path in paths:\n        s1_count = len([p for p in path if p.startswith('A')])\n        s2_count = len([p for p in path if p.startswith('M')])\n\n        if is_valid(s1_count, s2_count, total_count):\n            return f\"{s1_count} {s2_count}\\n\" + '\\n'.join(path)\n\n    return \"impossible\""
    },
    {
        "number": 3058,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def common_prefix(a, b):\n        i = 0\n        while i < len(a) and i < len(b) and a[i] == b[i]:\n            i += 1\n        return i\n\n    def find_path(sequence, current, path):\n        if sequence == current:\n            return True\n        for i in range(1, len(sequence)):\n            if sequence[:i] == current[:i]:\n                if find_path(sequence, current[i:], path + current[:i]):\n                    return True\n        return False\n\n    n = int(stdin.readline().strip())\n    current = stdin.readline().strip()\n    sequences = [stdin.readline().strip() for _ in range(n)]\n\n    for i in range(1, len(current)):\n        if current[:i] in sequences:\n            sequences.remove(current[:i])\n\n    for sequence in sequences:\n        if sequence == current:\n            continue\n        if find_path(sequence, current, \"\"):\n            continue\n        else:\n            return \"impossible\"\n\n    sequences.sort(key=lambda x: len(x))\n    s1, s2 = 0, 0\n    for sequence in sequences:\n        if sequence == current:\n            continue\n        if common_prefix(sequence, current) == 0:\n            s2 += 1\n        else:\n            s1 += 1\n\n    output = f\"{s1} {s2}\\n\"\n    for sequence in sequences:\n        if sequence == current:\n            continue\n        if common_prefix(sequence, current) == 0:\n            output += sequence + \"\\n\"\n    for sequence in sequences:\n        if sequence == current:\n            continue\n        if common_prefix(sequence, current) != 0:\n            output += sequence + \"\\n\"\n\n    return output[:-1] if output[-1] == \"\\n\" else output\n"
    },
    {
        "number": 3058,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_compatible(seq1, seq2):\n        if len(seq1) != len(seq2):\n            return False\n        for i in range(len(seq1)):\n            if seq1[i] != seq2[i] and seq1[i] != 'M' and seq2[i] != 'M':\n                return False\n        return True\n\n    n, current_species, *fossil_sequences = stdin.split('\\n')\n    n = int(n)\n\n    sequences1 = []\n    sequences2 = []\n\n    for seq in fossil_sequences:\n        if is_compatible(seq, current_species):\n            if len(sequences1) == 0 or is_compatible(seq, sequences1[-1]):\n                sequences1.append(seq)\n            else:\n                sequences2.append(seq)\n        elif len(sequences2) == 0 or is_compatible(seq, sequences2[-1]):\n            sequences2.append(seq)\n        else:\n            return 'impossible'\n\n    if len(sequences1) + len(sequences2) != n:\n        return 'impossible'\n\n    output = [str(len(sequences1)), str(len(sequences2))]\n    output += sequences1 + sequences2\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3058,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_path(seq1, seq2, path1, path2):\n        if not path1 or not path2:\n            return False\n        for s in path1:\n            if s not in seq1:\n                return False\n        for s in path2:\n            if s not in seq2:\n                return False\n        return True\n\n    def find_path(seq1, seq2, path1, path2):\n        if len(path1) == len(seq1) and len(path2) == len(seq2):\n            return path1, path2\n\n        for i in range(len(seq1)):\n            if seq1[i] not in path1:\n                new_path1 = path1 + [seq1[i]]\n                new_path2 = path2.copy()\n                if is_valid_path(seq1, seq2, new_path1, new_path2):\n                    result1, result2 = find_path(seq1, seq2, new_path1, new_path2)\n                    if result1 and result2:\n                        return result1, result2\n\n        for i in range(len(seq2)):\n            if seq2[i] not in path2:\n                new_path2 = path2 + [seq2[i]]\n                new_path1 = path1.copy()\n                if is_valid_path(seq1, seq2, new_path1, new_path2):\n                    result1, result2 = find_path(seq1, seq2, new_path1, new_path2)\n                    if result1 and result2:\n                        return result1, result2\n\n        return None, None\n\n    def print_path(seq1, seq2, path1, path2):\n        print(len(path1), len(path2))\n        for s in path1:\n            print(s)\n        for s in path2:\n            print(s)\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    current_species = lines[1]\n    fossil_species = lines[2:]\n\n    seq1 = [current_species]\n    seq2 = []\n\n    for species in fossil_species:\n        if species not in seq1 and species not in seq2:\n            seq1.append(species)\n        elif species not in seq1:\n            seq2.append(species)\n        else:\n            seq1.append(species)\n\n    path1, path2 = find_path(seq1, seq2, [], [])\n\n    if path1 and path2:\n        print_path(seq1, seq2, path1, path2)\n    else:\n        print('impossible')\n\n    return None"
    },
    {
        "number": 3058,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(path1, path2):\n        if path1[-1] != 'A':\n            return False\n        if path2[-1] != 'A':\n            return False\n        return True\n\n    def find_paths(fossils, current):\n        paths = []\n        for i in range(len(fossils)):\n            path1 = []\n            path2 = []\n            for j in range(i + 1):\n                if j == i:\n                    path1.append(fossils[j])\n                    path2.append(fossils[j])\n                elif fossils[j][-1] == current[0]:\n                    path1.append(fossils[j])\n                    if path2 and path2[-1][-1] == current[0]:\n                        path2.append(fossils[j])\n                else:\n                    path2.append(fossils[j])\n                    if path1 and path1[-1][-1] == current[0]:\n                        path1.append(fossils[j])\n            if is_valid(path1, path2):\n                paths.append((path1, path2))\n        return paths\n\n    def print_paths(paths):\n        path1, path2 = paths[0]\n        output = f\"{len(path1)} {len(path2)}\\n\"\n        for sequence in path1:\n            output += sequence + \"\\n\"\n        for sequence in path2:\n            output += sequence + \"\\n\"\n        return output\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    current = lines[1]\n    fossils = lines[2:]\n\n    if n == 1:\n        return \"impossible\"\n\n    paths = find_paths(fossils, current)\n\n    if not paths:\n        return \"impossible\"\n\n    return print_paths(paths[0])"
    },
    {
        "number": 3059,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def E(t, p, d):\n        return t + p * d\n\n    def P(p):\n        return p[1] / p[0]\n\n    n, r, m = map(int, stdin.readline().split())\n    tricks = [list(map(float, stdin.readline().split())) for _ in range(m)]\n    tricks.sort(key=lambda x: x[0])\n\n    E_total = E(n, 1, 0)\n    for t, p, d in tricks:\n        E_total = E(t, P((E_total, E_total + d)), p * E_total + (1 - p) * (E_total + d))\n\n    return str(round(E_total, 6))"
    },
    {
        "number": 3059,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = sorted(list(map(lambda x: tuple(map(int, x.split())), stdin.split('\\n')[1:])), key=lambda x: x[0])\n\n    def expected_time(reset_time, trick_index):\n        if trick_index == m:\n            return r - reset_time\n        trick_time, success_rate, recovery_time = tricks[trick_index]\n        success_expected_time = expected_time(reset_time, trick_index + 1)\n        failure_expected_time = expected_time(reset_time + recovery_time, trick_index + 1) + recovery_time\n        return success_rate * success_expected_time + (1 - success_rate) * failure_expected_time\n\n    min_time = float('inf')\n    for i in range(1, n + 1):\n        min_time = min(min_time, expected_time(i, 0) + i)\n\n    return f\"{min_time:.6f}\""
    },
    {
        "number": 3059,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_expected_time(reset_time, success_rate, failure_time, success_time):\n        return (1 - success_rate) * (reset_time + failure_time) + success_rate * success_time\n\n    def optimal_strategy(n, r, m, tricks):\n        reset_time = 0\n        expected_time = float('inf')\n\n        for t, p, d in tricks:\n            if t > n:\n                break\n            success_rate = p ** (t - reset_time)\n            failure_time = t + d\n            success_time = t + 1\n\n            expected_time_with_reset = min(expected_time_with_reset, get_expected_time(reset_time, success_rate, failure_time, success_time))\n\n            if t < n:\n                expected_time_without_reset = min(expected_time_without_reset, get_expected_time(reset_time, success_rate, failure_time, success_time + t - reset_time))\n\n            reset_time = t\n\n        return min(expected_time_with_reset, expected_time_without_reset)\n\n    stdin = stdin.split('\\n')\n    n, r, m = map(int, stdin[0].split())\n    tricks = [list(map(float, line.split())) for line in stdin[1:m + 1]]\n\n    expected_time = optimal_strategy(n, r, m, tricks)\n    return f'{expected_time:.6f}'"
    },
    {
        "number": 3059,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_expected_time(probability: float, time: int, expected_time: int) -> float:\n        return probability * (time + expected_time) + (1 - probability) * (time + 1)\n\n    n, r, m = map(int, stdin.readline().split())\n    tricks = [tuple(map(float, stdin.readline().split())) for _ in range(m)]\n\n    expected_time = n\n    for trick in reversed(tricks):\n        t, p, d = trick\n        expected_time = get_expected_time(p, int(t), expected_time)\n\n    return f\"{expected_time:.6f}\""
    },
    {
        "number": 3059,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_expected_time(t, p, d, n, r, expected_time):\n        expected_time_after_reset = 0\n        for i in range(1, 10001):\n            expected_time_after_reset += ((1 - p) ** (i - 1)) * p * (i * d + expected_time)\n        if t + expected_time_after_reset < r:\n            return t + expected_time_after_reset\n        else:\n            return r\n\n    stdin_list = stdin.strip().split('\\n')\n    n, r, m = list(map(int, stdin_list[0].split()))\n    tricks = [list(map(float, trick.split())) for trick in stdin_list[1:]]\n    tricks.sort(key=lambda x: x[0])\n\n    expected_time = n\n    for trick in tricks:\n        t, p, d = trick\n        expected_time = get_expected_time(t, p, d, n, r, expected_time)\n\n    return f\"{expected_time:.6f}\""
    },
    {
        "number": 3059,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def geometric_series(p, q):\n        return p / (1 - q)\n\n    n, r, m = map(int, stdin.readline().split())\n    tricks = []\n    for i in range(m):\n        t, p, d = map(float, stdin.readline().split())\n        tricks.append((t, p, d))\n\n    total_time = n\n    for t, p, d in tricks:\n        total_time += d\n\n    if total_time > r:\n        return str(total_time)\n\n    time_reset = 0\n    p_success = 1\n    for t, p, d in tricks:\n        p_fail = 1 - p\n        expected_time = t + geometric_series(p_fail, p_success) * d\n        if expected_time > r:\n            break\n        time_reset += expected_time\n        p_success *= p\n\n    return str(time_reset + total_time)"
    },
    {
        "number": 3059,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def E(p, d, t, n, r):\n        return (1 - p) * (t + d) + p * (t + E(p, d, n - t, n, r))\n\n    n, r, m = map(int, stdin.split()[0].split())\n    tricks = []\n    for i in range(m):\n        t, p, d = map(float, stdin.split()[i + 1].split())\n        tricks.append((t, p, d))\n\n    e_time = min(t + d if p == 0 else E(p, d, n - t, n, r) for t, p, d in tricks)\n    return f\"{e_time:.6f}\""
    },
    {
        "number": 3059,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_expected_time(current_time: float, reset_time: float, success_rate: float, failure_penalty: int) -> float:\n        success_time = current_time + failure_penalty\n        success_prob = success_rate\n        failure_time = current_time + failure_penalty + reset_time\n        failure_prob = 1 - success_rate\n\n        expected_time = success_time * success_prob + failure_time * failure_prob\n        return expected_time\n\n    n, r, m = map(int, stdin.split()[0].split())\n    tricks = [list(map(float, stdin.split()[i + 1].split())) for i in range(m)]\n\n    current_time = 0\n    reset_time = 0\n    expected_time = float('inf')\n\n    for trick in tricks:\n        t, p, d = trick\n        t, p, d = int(t), float(p), int(d)\n\n        if current_time + n < r:\n            current_time += n\n            reset_time += n\n        else:\n            expected_time = min(expected_time, get_expected_time(current_time, reset_time, p, d))\n\n    return f'{expected_time:.6f}'"
    },
    {
        "number": 3059,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def exp_time_for_trick(t, p, d):\n        return t + 1 / p * d\n\n    def optimal_strategy(n, r, tricks):\n        expected_time = r\n        for i in range(len(tricks) - 1, -1, -1):\n            t, p, d = tricks[i]\n            if exp_time_for_trick(t, p, d) < expected_time:\n                expected_time = exp_time_for_trick(t, p, d)\n            else:\n                break\n        return expected_time\n\n    params = list(map(int, stdin.split()))\n    n, r, m = params[0], params[1], params[2]\n    tricks = []\n    for _ in range(m):\n        trick = list(map(float, input().split()))\n        tricks.append(trick)\n\n    expected_time = optimal_strategy(n, r, tricks)\n    return f\"{expected_time:.6f}\""
    },
    {
        "number": 3059,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def binom_coefficient(n, k):\n        result = 1\n        for i in range(1, k + 1):\n            result *= n - i + 1\n            result //= i\n        return result\n\n    def expected_time_to_complete(t, p, d, e):\n        failure_time = e + d\n        success_time = t\n        expected_time = success_time * p + failure_time * (1 - p)\n        return expected_time\n\n    def optimal_strategy_expected_time(n, r, m, tricks):\n        e = 0\n        for i in range(m):\n            t, p, d = tricks[i]\n            e_t = expected_time_to_complete(t, p, d, e)\n            if e_t >= r:\n                break\n            e = e_t\n        return e\n\n    def optimal_strategy_expected_time_with_reset(n, r, m, tricks):\n        total_time = n + sum(tricks[i][2] * binom_coefficient(m, i) for i in range(1, m + 1))\n        expected_time_without_reset = optimal_strategy_expected_time(n, r, m, tricks)\n        return min(total_time, expected_time_without_reset)\n\n    stdin_list = stdin.strip().split('\\n')\n    n, r, m = map(int, stdin_list[0].split())\n    tricks = [list(map(float, line.split())) for line in stdin_list[1:]]\n    tricks = sorted(tricks, key=lambda x: x[0])\n\n    result = optimal_strategy_expected_time_with_reset(n, r, m, tricks)\n    return f\"{result:.6f}\""
    },
    {
        "number": 3060,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequences = []\n    \n    def is_valid(seq: list) -> bool:\n        for i in range(len(seq) - n + 1):\n            if sum(seq[i:i + n]) % n == 0:\n                return False\n        return True\n    \n    def generate_sequences(seq: list, index: int):\n        if index == n - 1:\n            for i in range(1, n):\n                seq.append(i)\n                if is_valid(seq):\n                    sequences.append(seq.copy())\n                seq.pop()\n        else:\n            for i in range(1, n):\n                seq.append(i)\n                generate_sequences(seq, index + 1)\n                seq.pop()\n    \n    generate_sequences([], 0)\n    sequences.sort()\n    \n    return ' '.join(map(str, sequences[k - 1]))"
    },
    {
        "number": 3060,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    petals = [i for i in range(1, n)]\n    sequences = []\n\n    def is_valid(seq):\n        total = sum(seq)\n        return total % n != 0\n\n    def generate_sequences(seq, index):\n        if index == n - 1:\n            if is_valid(seq):\n                sequences.append(seq[:])\n            return\n        for petal in petals:\n            seq[index] = petal\n            generate_sequences(seq, index + 1)\n\n    generate_sequences(petals[:n - 1], 0)\n    sequences.sort()\n    return \" \".join(map(str, sequences[k - 1]))"
    },
    {
        "number": 3060,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for i in range(1, n):\n        count += n - i\n    total = count * (n - 2)\n    if k > total:\n        k -= total\n        i = n - 2\n        while k > 0:\n            k -= n - i - 1\n            i -= 1\n        i += 2\n        j = n - i\n    else:\n        i = 1\n        while k > 0:\n            k -= n - i - 1\n            i += 1\n        j = k // (i - 1) + 1\n    return \" \".join(map(str, [i] * j))\n\nn, k = map(int, input().split())\nprint(solution(f\"{n} {k}\")) "
    },
    {
        "number": 3060,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = []\n    i = 1\n    while len(result) < n - 1:\n        if (i + n - 1) % n != 0:\n            result.append(i)\n        i += 1\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3060,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    def is_valid(sequence: list) -> bool:\n        for i in range(len(sequence) - n + 1):\n            if sum(sequence[i:i + n]) % n == 0:\n                return False\n        return True\n\n    valid_sequences = []\n    for i in range(1, n):\n        for j in range(1, n):\n            for x in range(1, n):\n                for y in range(1, n):\n                    sequence = [i] * (n - 1)\n                    sequence[x - 1] = j\n                    if is_valid(sequence):\n                        valid_sequences.append(sequence)\n\n    valid_sequences.sort()\n    return \" \".join(map(str, valid_sequences[k - 1]))"
    },
    {
        "number": 3060,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    valid_sequences = []\n\n    def is_valid(sequence):\n        total_petals = sum(sequence)\n        if total_petals % n != 0:\n            for i in range(1, len(sequence)):\n                if (sum(sequence[:i]) + total_petals - sum(sequence[i:])) % n == 0:\n                    return False\n            return True\n        return False\n\n    for i in range(1, n):\n        for j in range(i, n):\n            for x in range(1, n):\n                for y in range(x, n):\n                    for z in range(y, n):\n                        sequence = [i, j, x, y, z]\n                        if is_valid(sequence):\n                            valid_sequences.append(sequence)\n\n    valid_sequences.sort()\n    return \" \".join(map(str, valid_sequences[k - 1]))"
    },
    {
        "number": 3060,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    def is_valid(sequence: List[int]) -> bool:\n        for i in range(len(sequence) - 1):\n            if (sequence[i] + sequence[i + 1]) % n == 0:\n                return False\n        return True\n\n    valid_sequences = []\n    for i in range(1, n):\n        for j in range(1, n):\n            for l in range(1, n):\n                for m in range(1, n):\n                    sequence = [i, j, l, m]\n                    if len(set(sequence)) == len(sequence) and is_valid(sequence):\n                        valid_sequences.append(sequence)\n\n    valid_sequences.sort()\n    return \" \".join(map(str, valid_sequences[k - 1]))"
    },
    {
        "number": 3060,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = []\n    i = 1\n    while k > 0:\n        if len(result) == n - 1:\n            break\n        for petals in range(1, n):\n            if i % n != 0 and i % n != n // 2:\n                result.append(petals)\n                i += 1\n                if len(result) == n - 1:\n                    break\n        if len(result) < n - 1:\n            result = []\n            i = 1\n            continue\n        k -= 1\n        if k == 0:\n            break\n        result = []\n        i = 1\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3060,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = []\n    for i in range(1, n):\n        if not (i * n) % (n - 1):\n            continue\n        petals = [(i * j) % (n - 1) + 1 for j in range(1, n)]\n        if len(set(petals)) == n - 1:\n            result.append(petals)\n    result.sort()\n    return \" \".join(map(str, result[k - 1]))"
    },
    {
        "number": 3060,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    i = 1\n    count = 0\n    while count < k:\n        valid = True\n        total_petals = 0\n        for j in range(1, n):\n            total_petals += i + j\n            if total_petals % n == 0:\n                valid = False\n                break\n        if valid:\n            count += 1\n        if count == k:\n            return \" \".join(str(x) for x in range(i, i + n - 1))\n        i += 1"
    },
    {
        "number": 3061,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected(u, v, edges):\n        return u in edges and v in edges[u]\n\n    def find_max_path_length(start, visited, length, max_length):\n        if length >= max_length:\n            max_length = length\n\n        for neighbor in edges[start]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                max_length = find_max_path_length(neighbor, visited, length + 1, max_length)\n\n        return max_length\n\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    edges = {i: set() for i in range(1, n + 1)}\n\n    for i in range(m):\n        u, v = map(int, lines[i + 1].split())\n        edges[u].add(v)\n        edges[v].add(u)\n\n    max_length = float('-inf')\n    for start in edges:\n        max_length = max(max_length, find_max_path_length(start, {start}, 0, 0))\n\n    min_length = float('inf')\n    for u, v in edges:\n        edges_copy = {i: set(j) for i, j in edges.items()}\n        edges_copy[u].remove(v)\n        edges_copy[v].remove(u)\n\n        if not is_connected(1, n, edges_copy):\n            continue\n\n        length = float('-inf')\n        for start in edges_copy:\n            length = max(length, find_max_path_length(start, {start}, 0, 0))\n\n        min_length = min(min_length, length)\n\n    return str(min_length)"
    },
    {
        "number": 3061,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n\n    # Create a dictionary to store the roads\n    roads = {}\n    for i in range(1, n + 1):\n        roads[i] = []\n\n    # Parse the roads from the input\n    for i in range(1, m + 1):\n        u, v = map(int, lines[i].split())\n        roads[u].append(v)\n\n    # Create a helper function to find the maximum length path\n    def find_max_length_path(start_station):\n        visited = {start_station}\n        max_length_path = [start_station]\n        max_length = 0\n\n        while max_length_path:\n            current_station = max_length_path[-1]\n            unvisited_roads = [road for road in roads[current_station] if road not in visited]\n\n            if unvisited_roads:\n                next_station = unvisited_roads[0]\n                max_length_path.append(next_station)\n                visited.add(next_station)\n                max_length += 1\n            else:\n                max_length_path.pop()\n                if max_length > 0:\n                    max_length -= 1\n\n        return max_length\n\n    # Find the maximum length path for each starting station\n    max_length_paths = []\n    for i in range(1, n + 1):\n        max_length_paths.append(find_max_length_path(i))\n\n    # Find the minimum maximum length path\n    min_max_length = min(max_length_paths)\n\n    # If the minimum maximum length path is 0, then there is no valid path\n    if min_max_length == 0:\n        return 0\n\n    # Find the maximum length path for each blocked road\n    max_length_paths_after_blocked_road = []\n    for i in range(1, m + 1):\n        u, v = map(int, lines[i].split())\n\n        # Block the current road\n        roads[u].remove(v)\n\n        # Find the maximum length path for each starting station after the road is blocked\n        blocked_max_length_paths = []\n        for j in range(1, n + 1):\n            blocked_max_length_paths.append(find_max_length_path(j))\n\n        # Add the maximum length path after the road is blocked to the list\n        max_length_paths_after_blocked_road.append(min(blocked_max_length_paths))\n\n        # Unblock the current road\n        roads[u].append(v)\n\n    # Find the minimum maximum length path after blocking one road\n    min_max_length_after_blocked_road = min(max_length_paths_after_blocked_road)\n\n    return min_max_length_after_blocked_road"
    },
    {
        "number": 3061,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v = map(int, lines[i + 1].split())\n        graph[u].append(v)\n\n    def dfs(node, visited, path):\n        visited.add(node)\n        path.append(node)\n        if node == n:\n            return 1\n        result = 0\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                result += dfs(neighbor, visited, path)\n        path.pop()\n        visited.remove(node)\n        return result\n\n    max_path_length = 0\n    for node in range(1, n + 1):\n        if not graph[node]:\n            continue\n        path = []\n        visited = set()\n        max_path_length = max(max_path_length, dfs(node, visited, path))\n\n    return max_path_length - 1"
    },
    {
        "number": 3061,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited, adj, station):\n        if visited[start] == 2:\n            return True\n        if visited[start] == 1:\n            return False\n        visited[start] = 1\n        for next_station in adj[start]:\n            if next_station != station[start]:\n                if dfs(next_station, visited, adj, station):\n                    return True\n        visited[start] = 2\n        return False\n\n    def bfs(start, visited, adj, station):\n        q = [start]\n        visited[start] = 0\n        while q:\n            current = q.pop(0)\n            for next_station in adj[current]:\n                if next_station != station[current]:\n                    if visited[next_station] == -1:\n                        q.append(next_station)\n                        visited[next_station] = visited[current] + 1\n                    elif visited[next_station] >= visited[current]:\n                        visited[next_station] = visited[current] + 1\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    adj = [[] for _ in range(n + 1)]\n    station = [0] * (n + 1)\n    for i in range(m):\n        u, v = map(int, lines[i + 1].split())\n        adj[u].append(v)\n        adj[v].append(u)\n        station[u] = v\n        station[v] = u\n\n    visited = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if visited[i] == -1:\n            dfs(i, visited, adj, station)\n            bfs(i, visited, adj, station)\n\n    return min(visited[1:])"
    },
    {
        "number": 3061,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    adj_list = [[] for _ in range(n)]\n    for i in range(m):\n        u, v = map(int, lines[i + 1].split())\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n\n    lengths = []\n    visited = [False] * n\n    for start in range(n):\n        if visited[start]:\n            continue\n        length = 0\n        stack = [(start, 0)]\n        while stack:\n            node, depth = stack.pop()\n            if not visited[node]:\n                visited[node] = True\n                length = depth\n                for neighbor in adj_list[node]:\n                    stack.append((neighbor, depth + 1))\n        lengths.append(length)\n\n    return str(min(lengths))"
    },
    {
        "number": 3061,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_path(path):\n        for i in range(len(path) - 1):\n            if (path[i], path[i + 1]) not in roads:\n                return False\n        return True\n\n    def find_min_length_path(start, target, visited, current_length, min_length):\n        if start == target:\n            min_length = min(min_length, current_length)\n        else:\n            visited.add(start)\n            for next_station in stations[start]:\n                if next_station not in visited:\n                    min_length = find_min_length_path(next_station, target, visited, current_length + 1, min_length)\n            visited.remove(start)\n        return min_length\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    stations = [[] for _ in range(n + 1)]\n    roads = set()\n\n    for i in range(1, m + 1):\n        u, v = map(int, lines[i].split())\n        stations[u].append(v)\n        stations[v].append(u)\n        roads.add((u, v))\n\n    min_length = float('inf')\n    for u, v in roads:\n        min_length = min(min_length, find_min_length_path(1, n, set(), 0, float('inf')))\n\n    return str(min_length)"
    },
    {
        "number": 3061,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_path(n, roads):\n        max_path_length = n - 1\n        min_path_length = 0\n        for i in range(n):\n            visited = [False] * n\n            path_length = 0\n            stack = [(i, 0)]\n            while stack:\n                node, length = stack.pop()\n                if not visited[node]:\n                    visited[node] = True\n                    path_length = max(path_length, length)\n                    if path_length == n - 1:\n                        return n - 1\n                    for neighbor in roads[node]:\n                        if not visited[neighbor]:\n                            stack.append((neighbor, length + 1))\n            min_path_length = max(min_path_length, path_length)\n        return min_path_length\n\n    def main():\n        n, m = map(int, stdin.readline().split())\n        roads = [set() for _ in range(n)]\n        for _ in range(m):\n            u, v = map(int, stdin.readline().split())\n            roads[u - 1].add(v - 1)\n            roads[v - 1].add(u - 1)\n\n        return find_min_path(n, roads)\n\n    return main()"
    },
    {
        "number": 3061,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_path(u, visited, path_len):\n        visited[u] = True\n        max_path_len = path_len\n\n        for v in graph[u]:\n            if not visited[v]:\n                max_path_len = max(max_path_len, find_max_path(v, visited, path_len + 1))\n\n        return max_path_len\n\n    def get_min_length(blocked_road):\n        for road in roads:\n            if road == blocked_road:\n                continue\n            if not visited[road[1]]:\n                path_len = find_max_path(road[1], visited, 1)\n                return path_len\n        return None\n\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    graph = {i: [] for i in range(1, n + 1)}\n    roads = []\n\n    for i in range(m):\n        u, v = map(int, lines[i + 1].split())\n        graph[u].append(v)\n        roads.append((u, v))\n\n    min_length = None\n    for road in roads:\n        visited = {i: False for i in range(1, n + 1)}\n        path_len = get_min_length(road)\n        if path_len is not None:\n            min_length = min(min_length, path_len) if min_length is not None else path_len\n\n    return str(min_length)"
    },
    {
        "number": 3061,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        n, m = map(int, stdin.readline().split())\n        roads = []\n        for _ in range(m):\n            u, v = map(int, stdin.readline().split())\n            roads.append((u, v))\n        return n, m, roads\n\n    def find_longest_path(roads: list, n: int) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v in roads:\n            graph[u - 1].append(v - 1)\n            graph[v - 1].append(u - 1)\n\n        visited = [False] * n\n        def dfs(node: int, length: int) -> int:\n            if visited[node]:\n                return 0\n            visited[node] = True\n            max_length = length\n            for neighbor in graph[node]:\n                max_length = max(max_length, dfs(neighbor, length + 1))\n            return max_length\n\n        return max(dfs(i, 1) for i in range(n))\n\n    def find_min_longest_path(n: int, m: int, roads: list) -> int:\n        longest_path = find_longest_path(roads, n)\n        min_longest_path = float('inf')\n\n        for u, v in roads:\n            modified_roads = [road for road in roads if road != (u, v)]\n            min_longest_path = min(min_longest_path, find_longest_path(modified_roads, n))\n\n        return min_longest_path if min_longest_path < longest_path else longest_path\n\n    n, m, roads = read_input()\n    min_longest_path = find_min_longest_path(n, m, roads)\n    return str(min_longest_path)"
    },
    {
        "number": 3061,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited):\n        if visited[start]:\n            return 0\n        visited[start] = True\n        length = 1\n        for next_station in graph[start]:\n            length = max(length, dfs(next_station, visited))\n        return length\n\n    def find_max_length_path(station):\n        visited = [False] * n\n        return dfs(station, visited)\n\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        u, v = map(int, lines[i + 1].split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    max_length = 0\n    for i in range(n):\n        max_length = max(max_length, find_max_length_path(i))\n\n    return str(max_length - 1)\n\nsample_1 = \"\"\"4 4\n1 2\n1 3\n3 4\n2 4\"\"\"\n\nsample_2 = \"\"\"7 6\n1 2\n2 3\n2 5\n6 3\n7 2\n3 4\"\"\"\n\nsample_3 = \"\"\"7 5\n1 2\n2 3\n3 4\n5 6\n6 7\"\"\"\n\nprint(solution(sample_1))\nprint(solution(sample_2))\nprint(solution(sample_3)) "
    },
    {
        "number": 3062,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n    time = 0\n\n    # Calculate the distance between (0, 0) and (x, y)\n    distance = (x ** 2 + y ** 2) ** 0.5\n\n    # Check if the target is reachable\n    if distance > v / w:\n        return \"IMPOSSIBLE\"\n\n    # Calculate the angle between the direction of travel and the vector (x, y)\n    angle = math.atan2(y, x)\n\n    # Calculate the time to reach the target\n    time += angle / w\n    time += distance / v\n    time += (math.pi - angle) / w\n\n    return f\"{time:.10f}\""
    },
    {
        "number": 3062,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n\n    # Calculate distance and angle\n    distance = (x ** 2 + y ** 2) ** 0.5\n    angle = math.atan2(y, x)\n\n    # Calculate time to reach destination\n    time = distance / v\n\n    # Calculate time to rotate\n    if angle % (2 * math.pi) == 0:\n        time_rotate = 0\n    else:\n        time_rotate = abs(angle) / w\n\n    # Calculate total time\n    total_time = time + time_rotate\n\n    return f\"{total_time:.10f}\""
    },
    {
        "number": 3062,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n    dx, dy = x, y\n    time = 0\n\n    while dx != 0 or dy != 0:\n        angle = math.atan2(dy, dx)\n        if abs(angle) > w:\n            time += abs(angle) / w\n        else:\n            time += dx / v\n\n        dx = x - v * math.cos(angle) * time\n        dy = y - v * math.sin(angle) * time\n\n    return f\"{time:.10f}\""
    },
    {
        "number": 3062,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x, y):\n        return (x ** 2 + y ** 2) ** 0.5\n\n    def time_to_travel(x, y, v):\n        return distance(x, y) / v\n\n    def time_to_rotate(theta, w):\n        return abs(theta) / w\n\n    def angle_to_rotate(x, y):\n        return math.atan2(y, x)\n\n    xy, vw = stdin.split(\"\\n\")\n    x, y = map(int, xy.split())\n    v, w = map(float, vw.split())\n\n    dx = x\n    dy = y\n\n    theta = angle_to_rotate(dx, dy)\n    t_rotation = time_to_rotate(theta, w)\n\n    t_travel = time_to_travel(dx, dy, v)\n\n    if t_travel <= t_rotation:\n        t_total = t_travel\n    else:\n        t_total = t_rotation + t_travel\n\n    return f\"{t_total:.10f}\""
    },
    {
        "number": 3062,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    v, w = map(float, input().split())\n    distance = ((x ** 2) + (y ** 2)) ** 0.5\n    angle = math.atan2(y, x)\n    time_to_rotate = abs(angle / w)\n    time_to_travel = distance / v\n    total_time = time_to_rotate + time_to_travel\n    return round(total_time, 10)\n\nstdin = input().split('\\n')\nprint(solution(stdin)) "
    },
    {
        "number": 3062,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = list(map(float, stdin.split()))\n\n    def time_to_travel_distance(distance: float) -> float:\n        return distance / v\n\n    def time_to_rotate_angle(angle: float) -> float:\n        return angle / w\n\n    distance = ((x ** 2) + (y ** 2)) ** 0.5\n    angle = abs(x) / v\n\n    time = time_to_travel_distance(distance) + time_to_rotate_angle(angle)\n\n    return f\"{time:.10f}\""
    },
    {
        "number": 3062,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n\n    dx, dy = x, y\n    time = 0\n\n    # Travel in x-direction\n    time += dx / v\n    dx = 0\n\n    # Rotate and move in y-direction\n    angle = abs(y) / v * w\n    time += angle / w\n    dy -= 2 * abs(y) / w\n\n    return f\"{time:.10f}\""
    },
    {
        "number": 3062,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n\n    def time_to_travel(distance):\n        return distance / v\n\n    def time_to_rotate(angle):\n        return angle / w\n\n    distance = ((x ** 2) + (y ** 2)) ** 0.5\n    angle = (x / y) if y != 0 else 0\n\n    time = time_to_travel(distance) + time_to_rotate(angle)\n\n    return format(time, \".10f\")"
    },
    {
        "number": 3062,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n    distance = (x ** 2 + y ** 2) ** 0.5\n    angle = math.atan2(y, x)\n    if angle < 0:\n        angle += 2 * math.pi\n    time = distance / v\n    rotation_time = abs(angle) / w\n    return max(time, rotation_time)"
    },
    {
        "number": 3062,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(float, stdin.split()[0].split())\n    v, w = map(float, stdin.split()[1].split())\n\n    dx = x\n    dy = y\n\n    time = 0\n\n    if dx != 0 and dy != 0:\n        time += abs(dx / v)\n        time += abs(dy / v)\n        time += abs(math.atan(dy / dx) / w)\n    elif dx == 0:\n        time += abs(dy / v)\n    else:\n        time += abs(dx / v)\n\n    return str(round(time, 10))"
    },
    {
        "number": 3063,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_edges(lines):\n        edges = []\n        for line in lines:\n            edge = list(map(int, line.split()))\n            edges.append(edge)\n        return edges\n\n    def get_payback_plan(edges, N):\n        payback_plan = {}\n        for i in range(1, N + 1):\n            payback_plan[i] = 0\n\n        for edge in edges:\n            payback_plan[edge[0]] += edge[1]\n\n        return payback_plan\n\n    def get_min_money_to_give(payback_plan):\n        total_money_to_give = 0\n        for debt in payback_plan.values():\n            if debt > 0:\n                total_money_to_give += debt\n\n        return total_money_to_give\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    edges = get_edges(lines[1:N + 1])\n    payback_plan = get_payback_plan(edges, N)\n    min_money_to_give = get_min_money_to_give(payback_plan)\n\n    return str(min_money_to_give)"
    },
    {
        "number": 3063,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    debts = {i + 1: 0 for i in range(N)}\n\n    for i in range(1, N + 1):\n        l = lines[i].split(' ')\n        debts[int(l[0])] -= int(l[1])\n        debts[i] += int(l[1])\n\n    total_debt = sum(abs(i) for i in debts.values())\n    return str(total_debt)"
    },
    {
        "number": 3063,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n', 1)[0])\n    debts = [(int(x[0]), int(x[1])) for x in map(lambda x: x.split(), stdin.split('\\n')[1:])]\n\n    def pay_debt(debtor, debtee, amount, visited):\n        if debtor not in visited:\n            visited.add(debtor)\n            if debtor in debtee_to_debtor:\n                for debtor_tmp, amount_tmp in debtee_to_debtor[debtor]:\n                    pay_debt(debtee_to_debtor[debtor][0][0], debtee_to_debtor[debtor][0][1], debtee_to_debtor[debtor][0][2], visited)\n            if debtee not in debtor_to_debtee:\n                debtor_to_debtee[debtee] = []\n            debtor_to_debtee[debtee].append((debtor, amount))\n\n    debtee_to_debtor = {}\n    debtor_to_debtee = {}\n\n    for debtor, amount in debts:\n        pay_debt(debtor, debtor, amount, set())\n\n    total_amount = sum(amount for debtee in debtor_to_debtee for _, amount in debtor_to_debtee[debtee])\n\n    return str(total_amount) "
    },
    {
        "number": 3063,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, edges = int(stdin.readline()), []\n    for i in range(N):\n        a, b = map(int, stdin.readline().split())\n        edges.append((i, a, b))\n\n    visited, stack, adj_list = [False] * N, [], [[] for _ in range(N + 1)]\n\n    for i, a, b in edges:\n        adj_list[i].append((a, b))\n        adj_list[a].append((i, b))\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor, cost in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        stack.append(node)\n\n    for i in range(N):\n        if not visited[i]:\n            dfs(i)\n\n    debt = [0] * (N + 1)\n    total_debt = 0\n    while stack:\n        node = stack.pop()\n        for neighbor, cost in adj_list[node]:\n            debt[neighbor] += cost\n            total_debt += cost\n\n    return str(total_debt - max(debt))"
    },
    {
        "number": 3063,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, graph, amount):\n        visited[node] = True\n        for neighbor, weight in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, graph, amount)\n        amount[0] += weight\n\n    N = int(stdin.readline())\n    graph = [[] for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        A, B = map(int, stdin.readline().split())\n        graph[A].append((i, B))\n\n    visited = [False] * (N + 1)\n    amount = [0]\n    for i in range(1, N + 1):\n        if not visited[i]:\n            dfs(i, visited, graph, amount)\n    return str(amount[0])"
    },
    {
        "number": 3063,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(i, visited, graph):\n        visited[i] = True\n        for j in graph[i]:\n            if not visited[j]:\n                dfs(j, visited, graph)\n\n    def kruskal(edges, n):\n        parent = [i for i in range(n)]\n        rank = [0] * n\n        graph = [[] for _ in range(n)]\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            xroot = find(x)\n            yroot = find(y)\n            if xroot == yroot:\n                return False\n            if rank[xroot] > rank[yroot]:\n                parent[yroot] = xroot\n            else:\n                parent[xroot] = yroot\n                if rank[xroot] == rank[yroot]:\n                    rank[yroot] += 1\n            return True\n\n        edges.sort(key=lambda x: x[2])\n        res = 0\n        for u, v, w in edges:\n            if union(u - 1, v - 1):\n                res += w\n        return res\n\n    lines = stdin.strip().split('\\n')\n    N = int(lines[0])\n    debts = []\n    for i in range(1, N + 1):\n        debtor, creditor, amount = map(int, lines[i].split())\n        debts.append((debtor, creditor, amount))\n\n    ans = kruskal(debts, N)\n    return str(ans)"
    },
    {
        "number": 3063,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    graph = [[0] * (N + 1) for _ in range(N + 1)]\n    for i in range(N):\n        a, b = map(int, stdin.readline().split())\n        graph[a][i + 1] = b\n    total_debt = sum(sum(row[1:]) for row in graph)\n    debt = [sum(row) for row in graph]\n    visited = [False] * (N + 1)\n    visited[0] = True\n    stack = [(0, 0)]\n\n    def dfs(start, debt):\n        visited[start] = True\n        for i in range(1, N + 1):\n            if graph[start][i] > 0:\n                debt = dfs(i, debt)\n        return debt - graph[start][0]\n\n    while stack:\n        start, debt = stack.pop()\n        if not visited[start]:\n            visited[start] = True\n            for i in range(1, N + 1):\n                if graph[start][i] > 0:\n                    stack.append((i, debt))\n            debt = dfs(start, debt)\n            stack.append((start, debt))\n\n    return str(sum(max(0, debt[i] - graph[0][i]) for i in range(1, N + 1)) + min(debt[0], total_debt))\n"
    },
    {
        "number": 3063,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    debts = []\n    for i in range(1, N+1):\n        debtor, amount = map(int, lines[i].split())\n        debts.append((i, debtor, amount))\n\n    # Calculate the graph of debts\n    graph = [[] for _ in range(N+1)]\n    for i, debtor, amount in debts:\n        graph[i].append((debtor, amount))\n\n    # Calculate the indegrees of each node\n    indegrees = [0] * (N+1)\n    for _, debtor, _ in debts:\n        indegrees[debtor] += 1\n\n    # Use a queue to find the nodes with indegree 0\n    queue = [i for i in range(1, N+1) if indegrees[i] == 0]\n\n    # Calculate the minimum total amount of money\n    total_amount = 0\n    while queue:\n        node = queue.pop(0)\n        for neighbor, amount in graph[node]:\n            indegrees[neighbor] -= 1\n            total_amount += amount\n            if indegrees[neighbor] == 0:\n                queue.append(neighbor)\n\n    return str(total_amount)"
    },
    {
        "number": 3063,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    debts = []\n\n    for i in range(N):\n        line = stdin.readline().split()\n        A, B = int(line[0]), int(line[1])\n        debts.append((A, B))\n\n    debts.sort(key=lambda x: x[1], reverse=True)\n\n    def dfs(v):\n        visited[v] = True\n        for u, w in graph[v]:\n            if not visited[u]:\n                dfs(u)\n                dist[v] = max(dist[v], dist[u] + w)\n\n    def bellman_ford(start):\n        dist[start] = 0\n        for _ in range(N):\n            for v in range(1, N + 1):\n                for u, w in graph[v]:\n                    if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n\n        for v in range(1, N + 1):\n            for u, w in graph[v]:\n                if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                    return False\n        return True\n\n    graph = [[] for _ in range(N + 1)]\n    for v, w in debts:\n        graph[v].append((w, v))\n\n    visited = [False] * (N + 1)\n    dist = [float('inf')] * (N + 1)\n\n    for i in range(1, N + 1):\n        if not visited[i]:\n            dfs(i)\n\n    if not bellman_ford(1):\n        return \"NO\"\n\n    return str(max(dist[i] for i in range(1, N + 1)) - debts[0][1])"
    },
    {
        "number": 3063,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    debts = {}\n    for i in range(1, N + 1):\n        debts[i] = []\n    for _ in range(N):\n        lender, amount = map(int, stdin.readline().strip().split())\n        debts[lender].append(amount)\n    def payback(i, amount):\n        total = 0\n        for debt in debts[i]:\n            if debt > amount:\n                total += debt - amount\n                amount = 0\n            else:\n                amount -= debt\n            if amount == 0:\n                break\n        return total, amount\n\n    def dfs(i, amount):\n        if i not in debts or len(debts[i]) == 0:\n            return 0\n        total = amount\n        for debt in sorted(debts[i], reverse=True):\n            total += debt\n        return dfs(i, total)\n\n    for i in range(1, N + 1):\n        if i in debts and len(debts[i]) > 0:\n            total, amount = payback(i, dfs(i, 0))\n            return str(total)"
    },
    {
        "number": 3064,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n    \n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    visited = [False] * n\n    longest_path = [0] * n\n    visited[0] = True\n    longest_path[0] = 1\n    \n    def dfs(node):\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                longest_path[neighbor] = longest_path[node] + 1\n                dfs(neighbor)\n    \n    dfs(0)\n    return str(longest_path[0])"
    },
    {
        "number": 3064,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n + 1)]\n    visited = [False] * (n + 1)\n    longest_path = 0\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node, length):\n        visited[node] = True\n        if node == 1:\n            global longest_path\n            longest_path = max(longest_path, length)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, length + 1)\n        visited[node] = False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, 0)\n\n    return str(longest_path)"
    },
    {
        "number": 3064,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N, M = map(int, lines[0].split())\n    adj_list = [[] for _ in range(N)]\n    visited = [False] * N\n    for i in range(M):\n        u, v = map(int, lines[i + 1].split())\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    longest_path = 0\n    for i in range(N):\n        if not visited[i]:\n            dfs(i)\n            longest_path += 1\n\n    return str(longest_path - 1)"
    },
    {
        "number": 3064,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (n + 1)\n    longest_path = 0\n\n    def dfs(node: int, distance: int) -> None:\n        nonlocal longest_path\n        visited[node] = True\n        if node == 1:\n            longest_path = max(longest_path, distance)\n        else:\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor, distance + 1)\n        visited[node] = False\n\n    for i in range(1, n + 1):\n        dfs(i, 1)\n\n    return str(longest_path)"
    },
    {
        "number": 3064,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(city, visited, path_len, memo):\n        if (city, visited) in memo:\n            return memo[(city, visited)]\n\n        if city == 1 and path_len > 0:\n            return path_len\n\n        memo[(city, visited)] = 0\n        for nxt in roads[city]:\n            if nxt not in visited:\n                memo[(city, visited)] = max(\n                    memo[(city, visited)],\n                    dfs(nxt, visited | {nxt}, path_len + 1, memo),\n                )\n\n        return memo[(city, visited)]\n\n    N, M = map(int, stdin.split())\n    roads = [set() for _ in range(N + 1)]\n\n    for _ in range(M):\n        A, B = map(int, input().split())\n        roads[A].add(B)\n        roads[B].add(A)\n\n    memo = {}\n    return str(dfs(1, {1}, 0, memo))"
    },
    {
        "number": 3064,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_path(src, visited, distance):\n        visited[src] = True\n        for neighbor in graph[src]:\n            if not visited[neighbor]:\n                distance[src] = max(distance[src], find_longest_path(neighbor, visited, distance) + 1)\n        visited[src] = False\n        return distance[src]\n\n    N, M = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (N + 1)\n    distance = [0] * (N + 1)\n    for i in range(1, N + 1):\n        find_longest_path(i, visited, distance)\n\n    return str(max(distance[1:]))"
    },
    {
        "number": 3064,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    roads = []\n    for i in range(M):\n        A, B = map(int, lines[i + 1].split())\n        roads.append((A, B))\n\n    graph = [[] for _ in range(N + 1)]\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (N + 1)\n    visited[1] = True\n    longest_path = 0\n\n    def dfs(current_city, current_length):\n        nonlocal longest_path\n        longest_path = max(longest_path, current_length)\n        for neighbor in graph[current_city]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                dfs(neighbor, current_length + 1)\n                visited[neighbor] = False\n\n    for i in range(1, N + 1):\n        if not visited[i]:\n            dfs(i, 1)\n\n    return str(longest_path - 1)"
    },
    {
        "number": 3064,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (n + 1)\n    max_length = 0\n\n    def dfs(node, length):\n        nonlocal max_length\n        if node == 1:\n            max_length = max(max_length, length)\n            return\n\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, length + 1)\n        visited[node] = False\n\n    for i in range(1, n + 1):\n        dfs(i, 0)\n\n    return str(max_length)"
    },
    {
        "number": 3064,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = [[False] * n for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a - 1][b - 1] = graph[b - 1][a - 1] = True\n\n    def dfs(start, visited=None, depth=0):\n        if visited is None:\n            visited = [False] * n\n        visited[start] = True\n        if start == 0:\n            depth += 1\n        for i in range(n):\n            if graph[start][i] and not visited[i]:\n                depth = max(depth, dfs(i, visited, depth))\n        return depth\n\n    return str(dfs(1))"
    },
    {
        "number": 3064,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = [[False] * n for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a - 1][b - 1] = graph[b - 1][a - 1] = True\n\n    def dfs(start, visited):\n        if start == 0:\n            return 1\n        visited[start] = True\n        ret = 0\n        for i in range(n):\n            if not visited[i] and graph[start][i]:\n                ret = max(ret, dfs(i, visited))\n        return ret + 1\n\n    ans = 0\n    for i in range(n):\n        ans = max(ans, dfs(i, [False] * n))\n\n    return str(ans - 1)"
    },
    {
        "number": 3065,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    L = int(lines[1])\n    path = list(map(int, lines[2].split()))\n    graph = {i: [] for i in range(N)}\n    for i in range(N):\n        node, *neighbours = list(map(int, lines[3 + i].split()))\n        graph[node] = neighbours\n\n    def get_probability(node, visited, probability):\n        if node in visited:\n            return probability\n        visited.add(node)\n        for neighbour in graph[node]:\n            probability = get_probability(neighbour, visited, probability)\n        return probability\n\n    total_probability = 0\n    for i in range(N):\n        probability = 1\n        visited = set()\n        probability = get_probability(i, visited, probability)\n        total_probability += probability\n\n    return f\"{total_probability / N:.10f}\""
    },
    {
        "number": 3065,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, end, visited):\n        if start == end:\n            return 1\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if dfs(graph, neighbor, end, visited):\n                    return 1\n        visited[start] = False\n        return 0\n\n    def bfs(graph, start, end):\n        queue = [(start, 1)]\n        visited = {start: True}\n        while queue:\n            node, depth = queue.pop(0)\n            if node == end:\n                return depth\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, depth + 1))\n                    visited[neighbor] = True\n        return 0\n\n    stdin = stdin.split('\\n')\n    N, L = map(int, stdin[0].split())\n    walk = list(map(int, stdin[1].split()))\n    graph = [[] for _ in range(N)]\n    for i in range(N):\n        neighbors = list(map(int, stdin[i + 2].split()))[1:]\n        graph[i] = neighbors\n\n    visited = [False] * N\n    p = 0\n    for i in range(N):\n        if not visited[i]:\n            dfs(graph, i, walk[p], visited)\n            p += 1\n\n    total_visits = len(walk)\n    unique_visits = len(set(walk))\n    chance = 1\n    for i in range(unique_visits):\n        chance *= 1 / 6\n    chance *= (total_visits - unique_visits) + 1\n\n    for i in range(unique_visits):\n        depth = bfs(graph, walk[i], walk[(i + 1) % len(walk)])\n        chance *= 1 - (1 / 6) ** depth\n\n    return '{:.10f}'.format(chance)"
    },
    {
        "number": 3065,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    L = int(lines[1])\n    walk = list(map(int, lines[2].split()))\n    graph = [[] for _ in range(N)]\n\n    for i in range(N):\n        neighbours = list(map(int, lines[3 + i].split()))[1:]\n        for j in range(len(neighbours)):\n            graph[i].append(neighbours[j])\n            graph[neighbours[j]].append(i)\n\n    def dfs(node, visited):\n        if visited[node]:\n            return False\n        visited[node] = True\n        for neighbour in graph[node]:\n            if not dfs(neighbour, visited):\n                return False\n        visited[node] = False\n        return True\n\n    def is_safe(room):\n        visited = [False] * N\n        return dfs(room, visited)\n\n    safe_rooms = [is_safe(room) for room in range(N)]\n    safe_walk = all(safe_rooms[walk[i]] for i in range(L))\n\n    if safe_walk:\n        return f\"{1:.6f}\"\n\n    safe_pairs = [(i, j) for i in range(L - 1) for j in range(i + 1, L) if safe_rooms[walk[i]] and safe_rooms[walk[j]]]\n    chance = 1\n\n    for pair in safe_pairs:\n        i, j = pair\n        for k in range(i + 1, j):\n            chance *= 1 / 2\n\n    return f\"{chance:.6f}\""
    },
    {
        "number": 3065,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_probability(node, visited, edges, n):\n        if visited[node] == 1:\n            return 0\n        visited[node] = 1\n        probability = 1\n        for neighbor in edges[node]:\n            if visited[neighbor] == 0:\n                probability *= (1 - find_probability(neighbor, visited, edges, n))\n        return probability\n\n    stdin = stdin.split('\\n')\n    n_nodes = int(stdin[0])\n    n_rooms = int(stdin[1])\n    walk = list(map(int, stdin[2].split()))\n    edges = [[] for _ in range(n_nodes)]\n    for i in range(n_nodes):\n        neighbors = list(map(int, stdin[3 + i].split()[1:]))\n        edges[i] = neighbors\n\n    visited = [0] * n_nodes\n    probability = 1\n    for room in walk:\n        probability *= (1 - find_probability(room, visited, edges, n_nodes))\n\n    return f\"{probability:.6f}\""
    },
    {
        "number": 3065,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N, L = map(int, lines[0].split())\n    walk = list(map(int, lines[1].split()))\n    graph = {i: set(map(int, lines[i + 2].split()[1:])) for i in range(2, N + 2)}\n\n    def dfs(node, visited):\n        if node in visited:\n            return 0\n        visited.add(node)\n        res = 1\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                res *= 1 / len(graph[node])\n                res *= dfs(neighbor, visited)\n        return res\n\n    total_rooms = sum(len(neighbors) for neighbors in graph.values())\n    probability = 1\n    for room in walk:\n        probability *= dfs(room, set())\n    probability *= (1 / total_rooms) ** (len(walk) - 1)\n    return f\"{probability:.6f}\""
    },
    {
        "number": 3065,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, graph, step):\n        if step == L:\n            return 1\n        if node in visited:\n            return 0\n        visited.add(node)\n        paths = 0\n        for neighbor in graph[node]:\n            paths += dfs(neighbor, visited.copy(), graph, step + 1)\n        return paths\n\n    stdin = stdin.split('\\n')\n    N, L = map(int, stdin[0].split())\n    walk = list(map(int, stdin[1].split()))\n    graph = [[] for _ in range(N)]\n\n    for i in range(2, N):\n        line = stdin[i].split()\n        node, neighbors = int(line[0]), list(map(int, line[1:]))\n        graph[node] = neighbors\n\n    return str(dfs(0, set(), graph, 0) / (2 ** L))"
    },
    {
        "number": 3065,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(rooms, i, j):\n        return rooms[i] != rooms[j] and abs(i - j) > 1\n\n    def count_walks(rooms, i, j, visited, walk, probabilities):\n        if i == j:\n            return 1\n\n        if (i, j) in probabilities:\n            return probabilities[(i, j)]\n\n        count = 0\n        for neighbor in rooms[i]:\n            if neighbor != j and neighbor not in visited:\n                count += count_walks(rooms, neighbor, j, visited | {i}, walk, probabilities)\n\n        probabilities[(i, j)] = count\n        return count\n\n    lines = stdin.split('\\n')\n    N, L = map(int, lines[0].split())\n    rooms = list(map(int, lines[1].split()))\n    walk = list(map(int, lines[2].split()))\n    neighbors = [list(map(int, line.split()[1:])) for line in lines[3:]]\n\n    probabilities = {}\n    total_walks = 0\n    for i in range(len(walk) - 1):\n        if not is_valid(walk, i, i + 1):\n            continue\n\n        total_walks += count_walks(neighbors, walk[i], walk[i + 1], {i}, walk, probabilities)\n\n    for i in range(len(walk) - 1):\n        for j in range(i + 2, len(walk)):\n            if not is_valid(walk, i, j):\n                continue\n\n            total_walks += count_walks(neighbors, walk[i], walk[j], set(), walk, probabilities)\n\n    return '%.6f' % (1 - total_walks / (2 ** (len(walk) - 1)))"
    },
    {
        "number": 3065,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    from heapq import heappush, heappop\n    \n    lines = stdin.split(\"\\n\")\n    N, L = map(int, lines[0].split())\n    captain_walk = list(map(int, lines[1].split()))\n    adj_list = [[] for _ in range(N)]\n    \n    for i in range(N):\n        neighbors = list(map(int, lines[2 + i].split()))[1:]\n        for j in neighbors:\n            adj_list[i].append(j)\n            adj_list[j].append(i)\n    \n    def dijkstra(start, end):\n        dist = [float('inf')] * N\n        dist[start] = 0\n        visited = [False] * N\n        heap = [(0, start)]\n        \n        while heap:\n            d, node = heappop(heap)\n            \n            if node == end:\n                return d\n            \n            if not visited[node]:\n                visited[node] = True\n                for neighbor in adj_list[node]:\n                    if not visited[neighbor]:\n                        new_dist = d + 1\n                        if new_dist < dist[neighbor]:\n                            dist[neighbor] = new_dist\n                            heappush(heap, (new_dist, neighbor))\n        \n        return float('inf')\n    \n    chances = 1\n    \n    for i in range(L - 1):\n        room1, room2 = captain_walk[i], captain_walk[i + 1]\n        chances *= 1 - 1 / (dijkstra(room1, room2) + 1)\n        \n    return f\"{chances:.6f}\""
    },
    {
        "number": 3065,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    N = int(stdin[0])\n    L = int(stdin[1])\n    path = list(map(int, stdin[2].split()))\n    graph = {}\n    for i in range(N):\n        graph[i] = []\n        for j in range(int(stdin[3+i].split()[0])):\n            graph[i].append(int(stdin[3+i].split()[j+1]))\n\n    # Compute the number of possible paths from each room to the final room\n    dp = [0] * N\n    dp[path[-1]] = 1\n    for i in range(L-1, -1, -1):\n        dp = [sum([dp[neighbor] for neighbor in graph[path[i]]])] * N\n    sentry_chance = 1 - dp[path[0]]\n\n    return '{:.7f}'.format(sentry_chance)\n"
    },
    {
        "number": 3065,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    N = int(stdin[0])\n    L = int(stdin[1])\n    walk = list(map(int, stdin[2].split()))\n    graph = {i: [] for i in range(N)}\n    for i in range(N):\n        neighbours = list(map(int, stdin[3 + i].split()[1:]))\n        graph[i].extend(neighbours)\n        for neighbour in neighbours:\n            if i not in graph[neighbour]:\n                graph[neighbour].append(i)\n\n    def bfs(graph, start):\n        visited = [False] * N\n        queue = [start]\n        visited[start] = True\n        while queue:\n            node = queue.pop(0)\n            for neighbour in graph[node]:\n                if not visited[neighbour]:\n                    queue.append(neighbour)\n                    visited[neighbour] = True\n        return visited\n\n    def get_rooms_visited(graph, walk):\n        visited = bfs(graph, walk[0])\n        return [i for i in range(N) if visited[i]]\n\n    def get_probability(rooms_visited, N):\n        total_combinations = 2 ** len(rooms_visited)\n        successful_combinations = 0\n        for i in range(total_combinations):\n            binary = bin(i)[2:].zfill(len(rooms_visited))\n            if all(binary[i] != binary[j] for i, j in combinations(walk, 2)):\n                successful_combinations += 1\n        return successful_combinations / total_combinations\n\n    rooms_visited = get_rooms_visited(graph, walk)\n    probability = get_probability(rooms_visited, N)\n    return round(probability, 6)"
    },
    {
        "number": 3066,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = list(map(int, stdin.split('\\n')[1].split()))\n    tapes = []\n    colors_set = set(colors)\n    impossible = False\n\n    for color in colors_set:\n        tape = []\n        last_pos = -1\n        for i in range(n):\n            if colors[i] == color:\n                if last_pos == -1:\n                    last_pos = i\n            elif last_pos != -1:\n                tape.append((last_pos, i - 1, color))\n                last_pos = -1\n        if last_pos != -1:\n            tape.append((last_pos, n - 1, color))\n\n        if len(tape) > 1:\n            impossible = True\n            break\n        elif len(tape) == 1:\n            tapes.append(tape[0])\n\n    if impossible:\n        return \"IMPOSSIBLE\"\n    else:\n        tapes.sort(key=lambda x: x[0])\n        result = [str(len(tapes))] + [\" \".join(map(str, tape)) for tape in tapes]\n        return \"\\n\".join(result)"
    },
    {
        "number": 3066,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, colors = list(map(int, stdin.split()))\n    instructions = []\n    color_count = {}\n\n    for i in range(n):\n        if colors[i] not in color_count:\n            color_count[colors[i]] = 1\n        else:\n            color_count[colors[i]] += 1\n\n    for i in range(n):\n        if color_count[colors[i]] == 1:\n            instructions.append((i, i, colors[i]))\n\n    if len(instructions) > 0:\n        print(len(instructions))\n        for instruction in instructions:\n            print(instruction[0] + 1, instruction[1] + 1, instruction[2])\n    else:\n        print(\"IMPOSSIBLE\")"
    },
    {
        "number": 3066,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = [int(x) for x in stdin.split('\\n')[1].split()]\n    if len(set(colors)) != n:\n        return \"IMPOSSIBLE\"\n    instructions = []\n    for i in range(n):\n        if colors[i] == i + 1:\n            instructions.append(f\"{i + 1} {i + 1} {colors[i]}\")\n        else:\n            for j in range(i, -1, -1):\n                if colors[j] == i + 1:\n                    instructions.append(f\"{j + 1} {i + 1} {colors[i]}\")\n                    break\n    return f\"{len(instructions)}\\n\" + \"\\n\".join(instructions)"
    },
    {
        "number": 3066,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    tape_colors = [int(c) for c in lines[1].split()]\n    \n    if len(set(tape_colors)) != len(tape_colors):\n        return \"IMPOSSIBLE\"\n    \n    instructions = []\n    for i in range(n):\n        instructions.append((i+1, n, tape_colors[i]))\n    \n    result = [str(len(instructions))] + [' '.join(map(str, inst)) for inst in instructions]\n    \n    return '\\n'.join(result)"
    },
    {
        "number": 3066,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    colors = [int(x) for x in stdin.split(\"\\n\")[1].split()]\n\n    if len(set(colors)) != len(colors):\n        return \"IMPOSSIBLE\"\n\n    instructions = []\n    for i in range(n):\n        if colors[i] != i + 1:\n            instructions.append((i + 1, n, colors[i]))\n\n    if not instructions:\n        return \"1\\n\" + \"\\n\".join([\"1 1 1\"] * n)\n\n    return f\"{len(instructions)}\\n\" + \"\\n\".join(f\"{l} {r} {c}\" for l, r, c in instructions)"
    },
    {
        "number": 3066,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = list(map(int, stdin.readline().strip().split()))\n\n    if len(set(colors)) != len(colors):\n        return \"IMPOSSIBLE\"\n\n    instructions = []\n    for i in range(n):\n        instructions.append((colors[i], i + 1, i + 1))\n\n    instructions.sort(key=lambda x: x[0])\n    instructions.sort(key=lambda x: x[1])\n\n    result = [len(instructions)] + [\" \".join(map(str, inst)) for inst in instructions]\n    return \"\\n\".join(result)"
    },
    {
        "number": 3066,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    if len(set(colors)) != len(colors):\n        return \"IMPOSSIBLE\"\n\n    instructions = []\n    for i, c in enumerate(colors):\n        instructions.append(f\"{i + 1} {i + 1} {c}\")\n\n    return f\"{len(instructions)}\\n\" + \"\\n\".join(instructions)"
    },
    {
        "number": 3066,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = [int(x) for x in stdin.split('\\n')[1].split()]\n    if len(set(colors)) != len(colors):\n        return \"IMPOSSIBLE\"\n    else:\n        instructions = []\n        for i in range(n):\n            if i == 0:\n                instructions.append(f\"1 {n} {colors[i]}\")\n            else:\n                if colors[i] == colors[i-1]:\n                    instructions[-1] = instructions[-1].split()\n                    instructions[-1][1] = str(i)\n                    instructions[-1] = \" \".join(instructions[-1])\n                else:\n                    instructions.append(f\"{i} {i} {colors[i]}\")\n        return f\"{len(instructions)}\\n\" + \"\\n\".join(instructions)"
    },
    {
        "number": 3066,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(color_list):\n        color_set = set()\n        for color in color_list:\n            if color in color_set:\n                return False\n            color_set.add(color)\n        return True\n\n    def get_instructions(tape_art):\n        instructions = []\n        color_dict = {}\n        for i, color in enumerate(tape_art):\n            if color not in color_dict:\n                color_dict[color] = [i, i]\n            else:\n                color_dict[color][1] = i\n\n        for color, interval in color_dict.items():\n            instructions.append([interval[0] + 1, interval[1] + 1, color])\n\n        return instructions\n\n    n = int(stdin.readline().strip())\n    tape_art = list(map(int, stdin.readline().strip().split()))\n\n    if not is_valid(tape_art):\n        return \"IMPOSSIBLE\"\n\n    instructions = get_instructions(tape_art)\n    return f\"{len(instructions)}\\n\" + \"\\n\".join(\n        \" \".join(map(str, inst)) for inst in instructions\n    )"
    },
    {
        "number": 3066,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, colors = map(int, stdin.split())\n    colors = list(map(int, colors))\n\n    instructions = []\n    used_colors = set()\n\n    for i in range(n):\n        if colors[i] not in used_colors:\n            used_colors.add(colors[i])\n            instructions.append((i + 1, n, colors[i]))\n\n    if len(instructions) != len(used_colors):\n        return \"IMPOSSIBLE\"\n\n    return f\"{len(instructions)}\\n\" + \"\\n\".join(f\"{l} {r} {c}\" for l, r, c in instructions)"
    },
    {
        "number": 3067,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def merge(left, right):\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    N = int(stdin.readline().strip())\n    sequences = [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n\n    sorted_sequence = merge_sort([x for seq in sequences for x in seq])\n    return \" \".join(map(str, sorted_sequence))"
    },
    {
        "number": 3067,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    sequences = []\n    for _ in range(N):\n        L, *nums = [int(x) for x in stdin.readline().strip().split()]\n        sequences.append((L, nums))\n\n    sequences.sort(key=lambda x: x[1])\n    solution_sequence = []\n    while sequences:\n        L, nums = sequences.pop(0)\n        solution_sequence.extend(nums)\n    return ' '.join(map(str, solution_sequence))"
    },
    {
        "number": 3067,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    sequences = []\n    for i in range(n):\n        line = stdin.readline().split()\n        length = int(line[0])\n        sequence = [int(x) for x in line[1:]]\n        sequences.append(sequence)\n    \n    sorted_sequences = []\n    for sequence in sequences:\n        sorted_sequences.append(sorted(sequence))\n    \n    solution_sequence = []\n    while sorted_sequences:\n        min_value = min(sorted_sequences, key=lambda x: x[0])[0]\n        min_index = 0\n        for i in range(len(sorted_sequences)):\n            if sorted_sequences[i][0] == min_value:\n                min_index = i\n                break\n        solution_sequence.append(sorted_sequences[min_index].pop(0))\n        if not sorted_sequences[min_index]:\n            del sorted_sequences[min_index]\n    \n    return \" \".join(str(x) for x in solution_sequence)"
    },
    {
        "number": 3067,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def merge_lists(left, right):\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge_lists(left, right)\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    sequences = []\n    for i in range(1, n + 1):\n        sequence = list(map(int, lines[i].split()))\n        sequences.append(sequence)\n\n    sorted_sequence = merge_sort([x for sequence in sequences for x in sequence])\n    return ' '.join(map(str, sorted_sequence))"
    },
    {
        "number": 3067,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def merge(left, right):\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result += left[i:]\n        result += right[j:]\n        return result\n\n    N = int(stdin.readline().strip())\n    sequences = []\n    for _ in range(N):\n        line = stdin.readline().strip()\n        sequence = list(map(int, line.split()))\n        sequences.append(sequence[1:])\n\n    merged_sequence = sequences[0]\n    for i in range(1, len(sequences)):\n        merged_sequence = merge(merged_sequence, sequences[i])\n\n    return \" \".join(map(str, merged_sequence))"
    },
    {
        "number": 3067,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # read the input\n    lines = stdin.split('\\n')\n    n_sequences = int(lines[0])\n    sequences = []\n    for i in range(1, n_sequences+1):\n        sequence = list(map(int, lines[i].split()))\n        sequences.append(sequence)\n\n    # find the best solution sequence\n    solution_sequence = []\n    while any(sequences):\n        min_card = min(min(sequence) for sequence in sequences if sequence)\n        for sequence in sequences:\n            if sequence and sequence[0] == min_card:\n                solution_sequence.append(sequence.pop(0))\n\n    # format the output\n    output = ' '.join(str(card) for card in solution_sequence)\n    return output"
    },
    {
        "number": 3067,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    sequences = []\n\n    for i in range(n):\n        line = stdin.readline().strip().split()\n        L = int(line[0])\n        sequence = [int(x) for x in line[1:]]\n        sequences.append((L, sequence))\n\n    sequences.sort(key=lambda x: x[1][0])\n\n    solution_sequence = []\n    for L, sequence in sequences:\n        solution_sequence.extend(sequence)\n\n    return \" \".join(str(x) for x in solution_sequence)"
    },
    {
        "number": 3067,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    sequences = []\n    for i in range(1, N + 1):\n        sequence = list(map(int, lines[i].split()))\n        sequences.append(sequence)\n\n    # Sort sequences by the first element\n    sequences.sort(key=lambda x: x[0])\n\n    # Merge sorted sequences\n    solution_sequence = []\n    for sequence in sequences:\n        solution_sequence.extend(sequence)\n\n    # Create the output string\n    output = ' '.join(map(str, solution_sequence))\n    return output"
    },
    {
        "number": 3067,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    sequences = []\n    for i in range(1, N+1):\n        sequence = list(map(int, lines[i].split(\" \")))\n        sequences.append(sequence)\n\n    # Initialize data structures\n    n = sum(len(seq) for seq in sequences)\n    values = [0] * n\n    index = [0] * n\n    left = [0] * n\n    right = [0] * n\n\n    # Merge sequences into a single array\n    k = 0\n    for seq in sequences:\n        for val in seq:\n            values[k] = val\n            index[k] = k\n            left[k] = k - 1\n            right[k] = k + 1\n            k += 1\n\n    # Merge sort the array\n    def merge_sort(start, end):\n        if start >= end:\n            return\n        mid = (start + end) // 2\n        merge_sort(start, mid)\n        merge_sort(mid + 1, end)\n        merge(start, mid, end)\n\n    def merge(start, mid, end):\n        left_start = start\n        right_start = mid + 1\n        merged = []\n        while left_start <= mid and right_start <= end:\n            if values[left_start] < values[right_start]:\n                merged.append(values[left_start])\n                left_start += 1\n            else:\n                merged.append(values[right_start])\n                right_start += 1\n        while left_start <= mid:\n            merged.append(values[left_start])\n            left_start += 1\n        while right_start <= end:\n            merged.append(values[right_start])\n            right_start += 1\n        values[start:end+1] = merged\n\n    merge_sort(0, n - 1)\n\n    # Reverse the index array\n    for i in range(n):\n        index[i] = n - 1 - index[i]\n\n    # Compute left and right pointers\n    for i in range(n):\n        if i == 0 or values[i] != values[i-1]:\n            left[i] = -1\n        else:\n            left[i] = index[i-1]\n        if i == n - 1 or values[i] != values[i+1]:\n            right[i] = n\n        else:\n            right[i] = index[i+1]\n\n    # Find the best solution\n    best_solution = []\n    current_solution = []\n    current_index = 0\n    while current_index < n:\n        if left[current_index] == -1:\n            current_solution.append(values[current_index])\n        else:\n            best_solution.extend(current_solution)\n            current_solution = []\n        current_index = right[current_index]\n    best_solution.extend(current_solution)\n\n    # Format the output\n    output = \" \".join(str(x) for x in best_solution)\n    return output"
    },
    {
        "number": 3067,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    sequences = []\n    for i in range(n):\n        line = stdin.readline().strip().split()\n        length, sequence = int(line[0]), [int(x) for x in line[1:]]\n        sequences.append(sequence)\n\n    while len(sequences) > 1:\n        min_sequence = min(sequences, key=lambda x: x[0])\n        min_index = sequences.index(min_sequence)\n        sequences.pop(min_index)\n        for i in range(1, len(min_sequence)):\n            sequences.append([min_sequence[i]])\n\n    return \" \".join(str(x) for x in sequences[0])\n"
    },
    {
        "number": 3068,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    investigations = []\n    for i in range(1, N + 1):\n        line = lines[i]\n        suspects, player, reply = line.split(\" \")\n        investigations.append((suspects, player, int(reply)))\n\n    black_vienna_solutions = set()\n\n    for a in range(ord('A'), ord('Z') + 1):\n        for b in range(ord('A'), ord('Z') + 1):\n            for c in range(ord('A'), ord('Z') + 1):\n                if a != b and b != c and a != c:\n                    black_vienna_set = (chr(a), chr(b), chr(c))\n                    is_admissible = True\n                    for suspects, player, reply in investigations:\n                        if player == \"1\":\n                            if suspects[0] in black_vienna_set and suspects[1] in black_vienna_set:\n                                is_admissible = is_admissible and (reply == 2)\n                            elif suspects[0] in black_vienna_set or suspects[1] in black_vienna_set:\n                                is_admissible = is_admissible and (reply == 1)\n                            else:\n                                is_admissible = is_admissible and (reply == 0)\n                        elif player == \"2\":\n                            if suspects[0] in black_vienna_set and suspects[1] in black_vienna_set:\n                                is_admissible = is_admissible and (reply == 2)\n                            elif suspects[0] in black_vienna_set or suspects[1] in black_vienna_set:\n                                is_admissible = is_admissible and (reply == 1)\n                            else:\n                                is_admissible = is_admissible and (reply == 0)\n                    if is_admissible:\n                        black_vienna_solutions.add(black_vienna_set)\n\n    return len(black_vienna_solutions)"
    },
    {
        "number": 3068,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_bit_count(n: int) -> int:\n        count = 0\n        while n:\n            n &= n - 1\n            count += 1\n        return count\n\n    def is_valid(set_a: set, set_b: set) -> bool:\n        intersection = set_a.intersection(set_b)\n        return len(intersection) == 1\n\n    def update_valid_sets(set_a: set, set_b: set, valid_sets: set) -> set:\n        new_valid_sets = set()\n        for valid_set in valid_sets:\n            if set_a.issubset(valid_set) and set_b.issubset(valid_set):\n                new_valid_sets.add(valid_set)\n        return new_valid_sets\n\n    stdin_list = stdin.split('\\n')\n    num_investigations = int(stdin_list[0])\n    stdin_list = stdin_list[1:]\n\n    valid_sets = [set(range(1, 27)) for _ in range(26)]\n    for i in range(num_investigations):\n        pair, player_num, reply = stdin_list[i].split(' ')\n        pair = set([ord(c) for c in pair])\n        reply = int(reply)\n\n        if player_num == '1':\n            valid_sets_new = []\n            for valid_set in valid_sets:\n                if get_bit_count(len(valid_set.intersection(pair))) == reply:\n                    valid_sets_new.append(valid_set)\n            valid_sets = valid_sets_new\n        else:\n            valid_sets_new = []\n            for j in range(i):\n                pair_prev, player_num_prev, reply_prev = stdin_list[j].split(' ')\n                pair_prev = set([ord(c) for c in pair_prev])\n                reply_prev = int(reply_prev)\n\n                if player_num_prev == '1' and player_num == '2':\n                    valid_sets_new = update_valid_sets(pair_prev, pair, valid_sets_new)\n                elif player_num_prev == '2' and player_num == '1':\n                    valid_sets_new = update_valid_sets(pair, pair_prev, valid_sets_new)\n            valid_sets = valid_sets_new\n\n    return len(valid_sets)"
    },
    {
        "number": 3068,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_admissible(suspects: set, black_vienna: set) -> bool:\n        return not any(s in suspects for s in black_vienna)\n\n    def count_admissible_solutions(suspects: set, black_vienna: set, investigations: list) -> int:\n        if not investigations:\n            return 1 if is_admissible(suspects, black_vienna) else 0\n\n        i, player, reply = investigations[0]\n        admissible_solutions = 0\n\n        for s1 in i:\n            for s2 in i:\n                if s1 != s2:\n                    new_black_vienna = black_vienna | set(s1) | set(s2)\n                    new_suspects = suspects - set(s1) - set(s2)\n                    if len(new_suspects) >= 3 - len(new_black_vienna):\n                        if player == 1:\n                            new_reply = len(new_suspects - set(s1) - set(s2))\n                        else:\n                            new_reply = len(new_suspects - set(s1)) - len(new_suspects - set(s2))\n\n                        if new_reply == reply:\n                            admissible_solutions += count_admissible_solutions(new_suspects, new_black_vienna, investigations[1:])\n\n        return admissible_solutions\n\n    N = int(stdin.readline().strip())\n    investigations = [tuple(stdin.readline().strip().split()) for _ in range(N)]\n    investigations = [(set(i[0]), int(i[1]), int(i[2])) for i in investigations]\n\n    black_vienna = set()\n    suspects = set(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    return str(count_admissible_solutions(suspects, black_vienna, investigations)) + \"\\n\" "
    },
    {
        "number": 3068,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    investigations = stdin.split('\\n')[1:]\n\n    def is_admissible(solution: str) -> bool:\n        for investigation in investigations:\n            suspects, player, reply = investigation.split(' ')\n            count = 0\n            for suspect in solution:\n                if suspect in suspects:\n                    count += 1\n            if player == '1':\n                if count != int(reply):\n                    return False\n            else:\n                if count == int(reply):\n                    return False\n        return True\n\n    count = 0\n    for a in range(26):\n        for b in range(a + 1, 26):\n            for c in range(b + 1, 26):\n                solution = chr(a + ord('A')) + chr(b + ord('A')) + chr(c + ord('A'))\n                if is_admissible(solution):\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 3068,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_solutions(suspects, black_vienna):\n        return len(set(filter(lambda s: all(bv not in s for bv in black_vienna), permutations(suspects))))\n\n    def read_input(stdin):\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        investigations = []\n        for line in lines[1:]:\n            if line:\n                suspects, player, reply = line.split(\" \")\n                investigations.append((tuple(suspects), int(player), int(reply)))\n        return n, investigations\n\n    def check_consistency(investigations):\n        for suspects, player, reply in investigations:\n            if reply > len(suspects) - 2:\n                return False\n        return True\n\n    n, investigations = read_input(stdin)\n    if not check_consistency(investigations):\n        return \"0\"\n\n    suspects = set(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    black_vienna = set()\n    for suspects, player, reply in investigations:\n        for suspect in suspects:\n            if suspect in suspects and suspect not in black_vienna:\n                suspects.remove(suspect)\n                black_vienna.add(suspect)\n\n    return str(count_solutions(suspects, black_vienna))"
    },
    {
        "number": 3068,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    N = int(stdin[0])\n    investigation_replies = stdin[1:]\n    players_hands = [[], []]\n    possible_solutions = set()\n\n    for i in range(N):\n        investigation = investigation_replies[i].split()\n        players_hands[int(investigation[2]) - 1].append(investigation[0])\n        players_hands[int(investigation[2]) - 1].append(investigation[1])\n\n    for a in range(26):\n        for b in range(a + 1, 26):\n            for c in range(b + 1, 26):\n                if (a not in players_hands[0]) and (b not in players_hands[0]) and (c not in players_hands[0]):\n                    if (a not in players_hands[1]) and (b not in players_hands[1]) and (c not in players_hands[1]):\n                        possible_solutions.add((a, b, c))\n\n    return str(len(possible_solutions))"
    },
    {
        "number": 3068,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_admissible(s1, s2, s3, replies):\n        return replies[(s1, s2)] + replies[(s1, s3)] + replies[(s2, s3)] == replies[(s1, s2, s3)]\n\n    def count_admissible_solutions(replies):\n        count = 0\n        for s1 in range(26):\n            for s2 in range(s1 + 1, 26):\n                for s3 in range(s2 + 1, 26):\n                    if is_admissible(s1, s2, s3, replies):\n                        count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    replies = {}\n    for i in range(1, N + 1):\n        line = lines[i]\n        s1, s2, player, reply = line[0], line[1], int(line[3]), int(line[4])\n        if player == 1:\n            replies[(s1, s2)] = reply\n        elif player == 2:\n            replies[(s2, s1)] = reply\n\n    return str(count_admissible_solutions(replies))"
    },
    {
        "number": 3068,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(lambda x: x.strip().split(), stdin.split('\\n')))\n    num_investigations = int(input_data[0][0])\n    black_vienna = []\n    player1 = set()\n    player2 = set()\n\n    for i in range(1, num_investigations + 1):\n        suspects, player, reply = input_data[i]\n        if player == '1':\n            player1.update(suspects)\n        else:\n            player2.update(suspects)\n        if reply == '1':\n            black_vienna.append(suspects)\n\n    all_suspects = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    not_in_hands = all_suspects - player1.intersection(player2)\n\n    if len(black_vienna) == 0:\n        return 2600\n    elif len(black_vienna) < 3:\n        return 0\n    else:\n        admissible_solutions = 0\n        for s1 in not_in_hands:\n            for s2 in not_in_hands - {s1}:\n                for s3 in not_in_hands - {s1, s2}:\n                    if all(s in black_vienna for s in [s1, s2, s3]):\n                        admissible_solutions += 1\n        return admissible_solutions\n"
    },
    {
        "number": 3068,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_admissible_solutions(n, black_circle, player1, player2):\n        admissible_solutions = set()\n        for i in range(26):\n            for j in range(i + 1, 26):\n                for k in range(j + 1, 26):\n                    if (\n                        (i not in black_circle)\n                        and (j not in black_circle)\n                        and (k not in black_circle)\n                    ):\n                        if (\n                            (i not in player1)\n                            and (j not in player1)\n                            and (k not in player1)\n                        ):\n                            if (\n                                (i not in player2)\n                                and (j not in player2)\n                                and (k not in player2)\n                            ):\n                                admissible_solutions.add(\n                                    tuple(sorted([i, j, k]))\n                                )\n        return len(admissible_solutions)\n\n    stdin_list = stdin.split(\"\\n\")\n    n = int(stdin_list[0])\n    black_circle = set()\n    player1 = set()\n    player2 = set()\n\n    for i in range(1, n + 1):\n        investigation = stdin_list[i].split(\" \")\n        if investigation[2] == \"1\":\n            player1.add(investigation[0][0])\n            player1.add(investigation[0][1])\n        elif investigation[2] == \"2\":\n            player2.add(investigation[0][0])\n            player2.add(investigation[0][1])\n        black_circle.add(investigation[1][0])\n        black_circle.add(investigation[1][1])\n\n    return str(count_admissible_solutions(n, black_circle, player1, player2))"
    },
    {
        "number": 3068,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_admissible(circle: set, hand1: set, hand2: set) -> bool:\n        if not circle:\n            return False\n        for a, b in itertools.combinations(circle, 2):\n            if len(circle) == 3 and (a, b) not in (('A', 'B'), ('A', 'C'), ('B', 'C')):\n                return False\n            if a not in hand1 and b not in hand1 and a not in hand2 and b not in hand2:\n                return False\n        return True\n\n    def count_solutions(circle: set, hand1: set, hand2: set) -> int:\n        return sum(1 for _ in filter(lambda c: is_admissible(c, hand1, hand2), itertools.combinations(circle, 3)))\n\n    stdin = stdin.split('\\n')\n    N = int(stdin[0])\n    hand1, hand2 = set(), set()\n\n    for i in range(1, N + 1):\n        a, b, player, reply = stdin[i].split()\n        reply = int(reply)\n        if player == '1':\n            hand1.update({a, b})\n        else:\n            hand2.update({a, b})\n\n    circle = set('ABC') - hand1 - hand2\n    return str(count_solutions(circle, hand1, hand2)) "
    },
    {
        "number": 3069,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, bracket in enumerate(stdin):\n        if bracket == \"(\":\n            stack.append(i)\n        else:\n            if not stack:\n                return \"impossible\"\n            if i - stack[-1] == 1:\n                stack.pop()\n            else:\n                stack.append(i)\n    return \"possible\" if not stack else \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, bracket in enumerate(stdin):\n        if bracket == \"(\":\n            stack.append(i)\n        else:\n            if not stack or stdin[stack[-1]] == \")\":\n                return \"impossible\"\n            stack.pop()\n\n    if not stack:\n        return \"possible\"\n    elif len(stack) == 1:\n        return \"possible\" if stdin[stack[0]] == \"(\" else \"impossible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, bracket in enumerate(stdin):\n        if bracket == '(':\n            stack.append(i)\n        else:\n            if not stack or stdin[stack[-1]] == ')':\n                return \"impossible\"\n            stack.pop()\n    if not stack:\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, bracket in enumerate(stdin):\n        if bracket == \"(\":\n            stack.append(i)\n        else:\n            if not stack:\n                return \"impossible\"\n            if stdin[stack[-1]] == \")\":\n                return \"impossible\"\n            stack.pop()\n\n    if not stack:\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, bracket in enumerate(stdin):\n        if bracket == \"(\":\n            stack.append(i)\n        else:\n            if not stack:\n                return \"impossible\"\n            if i - stack[-1] == 1:\n                stack.pop()\n            else:\n                return \"impossible\"\n    return \"possible\" if not stack else \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    left_brackets = 0\n    right_brackets = 0\n    valid = False\n\n    for i, bracket in enumerate(stdin):\n        if bracket == \"(\":\n            left_brackets += 1\n            stack.append(i)\n        elif bracket == \")\":\n            right_brackets += 1\n            if stack:\n                stack.pop()\n            elif not valid:\n                valid = True\n\n    if left_brackets == right_brackets and not stack:\n        return \"possible\"\n    elif not valid and left_brackets == right_brackets + 1:\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i in range(len(stdin)):\n        if stdin[i] == '(':\n            stack.append(i)\n        else:\n            if not stack:\n                return \"impossible\"\n            if stdin[stack[-1]] == '(':\n                stack.pop()\n            else:\n                return \"impossible\"\n    return \"possible\" if not stack else \"impossible\"\n\ndef"
    },
    {
        "number": 3069,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i in range(len(stdin)):\n        if stdin[i] == '(':\n            stack.append(i)\n        else:\n            if not stack:\n                return \"impossible\"\n            stack.pop()\n    return \"possible\" if not stack else \"impossible\"\n\ninput_str = input().strip()\nprint(solution(input_str)) "
    },
    {
        "number": 3069,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, bracket in enumerate(stdin):\n        if bracket == \"(\":\n            stack.append(i)\n        else:\n            if not stack:\n                return \"impossible\"\n            if i - stack[-1] > 1:\n                if len(stack) == 1:\n                    return \"impossible\"\n                else:\n                    stack.pop()\n            else:\n                stack.pop()\n\n    return \"possible\" if not stack else \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, bracket in enumerate(stdin):\n        if bracket == \"(\":\n            stack.append(i)\n        elif bracket == \")\":\n            if not stack:\n                return \"impossible\"\n            stack.pop()\n    return \"possible\" if not stack else \"impossible\"\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 3070,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def earliest_train_journey(N, M, timetable):\n        for X, S, T, L in timetable:\n            # Update S and T by adding L to each\n            S += L\n            T += L\n\n            # If the train is delayed by more than 30 minutes\n            if T > S + 1800:\n                continue\n\n            # If the train is the earliest so far\n            if S < earliest_time:\n                earliest_time = S\n\n    N, M = map(int, stdin.split())\n    timetable = [list(map(int, input().split())) for _ in range(M)]\n\n    earliest_time = float('inf')\n\n    # Try all possible starting times\n    for start_time in range(0, 86400):\n        earliest_train_journey(N, M, timetable)\n\n        # If the earliest train journey is earlier than the current start time\n        if earliest_time < start_time:\n            return str(start_time)\n        else:\n            earliest_time = float('inf')\n\n    return 'impossible'"
    },
    {
        "number": 3070,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_time(delayed_time: int, departure_time: int, duration: int) -> int:\n        return max(departure_time, delayed_time) + duration\n\n    def get_min_time(delayed_time: int, departure_time: int, duration: int) -> int:\n        return min(departure_time, delayed_time) + duration\n\n    def binary_search(train_info: list, start_time: int, end_time: int) -> int:\n        while start_time <= end_time:\n            mid_time = (start_time + end_time) // 2\n            total_time = 0\n            for i in range(len(train_info)):\n                total_time += get_max_time(train_info[i][1], train_info[i][2], train_info[i][3])\n            if total_time <= mid_time:\n                end_time = mid_time - 1\n            else:\n                start_time = mid_time + 1\n        return start_time\n\n    stdin_list = stdin.strip().split('\\n')\n    num_stations, num_trains = map(int, stdin_list[0].split())\n    train_info = [list(map(int, stdin_list[i+1].split())) for i in range(num_trains)]\n\n    start_time = 0\n    end_time = 86399\n    earliest_start_time = binary_search(train_info, start_time, end_time)\n\n    for i in range(len(train_info)):\n        total_time = 0\n        for j in range(len(train_info)):\n            if i == j:\n                continue\n            total_time += get_min_time(train_info[j][1], train_info[j][2], train_info[j][3])\n        if total_time + train_info[i][3] > earliest_start_time:\n            return \"impossible\"\n\n    return earliest_start_time"
    },
    {
        "number": 3070,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    train_data = [list(map(int, stdin.readline().split())) for _ in range(M)]\n    train_data = sorted(train_data, key=lambda x: x[2])\n\n    def is_delayed_train_valid(train, start_time):\n        if train[1] + train[3] > start_time + 1800:\n            return False\n        return True\n\n    def binary_search(start_time):\n        left, right = 0, M - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if is_delayed_train_valid(train_data[mid], start_time):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    for train in train_data:\n        start_time = train[1] - train[3]\n        if start_time < 0:\n            start_time = 0\n        index = binary_search(start_time)\n        if index == 0:\n            if start_time < 1800:\n                return \"impossible\"\n            return str(start_time - 1800)\n        if index < M:\n            if start_time < train_data[index][1] - train_data[index][3] - 1800:\n                return str(start_time)\n    return \"impossible\""
    },
    {
        "number": 3070,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N, M = map(int, lines[0].split())\n    train_delays = []\n    for i in range(1, M + 1):\n        X, S, T, L = map(int, lines[i].split())\n        train_delays.append((X, S, T, L))\n\n    train_delays.sort(key=lambda x: x[1])\n\n    def is_valid_journey(train_delays, start_time):\n        total_delay = 0\n        current_station = 1\n        for X, S, T, L in train_delays:\n            if S < start_time:\n                return False\n\n            if current_station == X:\n                if T + L - start_time > 1800:\n                    total_delay += T + L - start_time - 1800\n                current_station += 1\n\n        return total_delay >= 1800\n\n    start_time = 0\n    end_time = 86400\n    while start_time < end_time:\n        mid_time = (start_time + end_time) // 2\n        if is_valid_journey(train_delays, mid_time):\n            end_time = mid_time\n        else:\n            start_time = mid_time + 1\n\n    if start_time == 86400:\n        return \"impossible\"\n    else:\n        return str(start_time) "
    },
    {
        "number": 3070,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    trains = []\n    for i in range(M):\n        X, S, T, L = map(int, stdin.readline().split())\n        if L >= 1800:\n            trains.append((X, S, T, L))\n\n    trains.sort(key=lambda x: x[1])\n\n    for i in range(len(trains) - 1):\n        if trains[i][2] + trains[i][3] > trains[i + 1][1]:\n            return \"impossible\"\n\n    return str(trains[0][1] - 1800)"
    },
    {
        "number": 3070,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    trains = []\n    for _ in range(M):\n        X, S, T, L = map(int, stdin.readline().split())\n        trains.append((X, S, T, L))\n\n    earliest_start_time = 86400\n    for X, S, T, L in trains:\n        if T + L >= 27000:\n            continue\n        start_time = max(0, S - L)\n        earliest_start_time = min(earliest_start_time, start_time)\n\n    return str(earliest_start_time) if earliest_start_time < 86400 else \"impossible\""
    },
    {
        "number": 3070,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    trains = []\n    for _ in range(M):\n        X, S, T, L = map(int, stdin.readline().split())\n        trains.append((X, S + L, T + L))\n\n    trains.sort(key=lambda x: x[1])\n\n    for i in range(M):\n        X, S, T = trains[i]\n        if i == 0:\n            if S >= 1800:\n                return str(S)\n        else:\n            prev_X, prev_S, prev_T = trains[i - 1]\n            if X == prev_X + 1:\n                if S - prev_T >= 1800:\n                    return str(S)\n    return \"impossible\""
    },
    {
        "number": 3070,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    scheduled_trains = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    for train in scheduled_trains:\n        X, S, T, L = train\n        train.append(S + L)\n        train.append(T - L)\n\n    scheduled_trains.sort(key=lambda x: x[1])\n\n    min_time = float('inf')\n    max_time = 0\n    prev_train = None\n\n    for train in scheduled_trains:\n        if prev_train and prev_train[2] > train[1]:\n            min_time = min(min_time, prev_train[2])\n            max_time = max(max_time, train[4])\n        prev_train = train\n\n    if max_time - min_time >= 1800:\n        return 'impossible'\n    else:\n        return str(min_time - 1800) "
    },
    {
        "number": 3070,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_time_table(N, M, schedule):\n        time_table = [[] for _ in range(N)]\n        for i in range(M):\n            time_table[schedule[i][0]].append((schedule[i][1], schedule[i][2], schedule[i][3]))\n        return time_table\n\n    def find_earliest_train(N, M, schedule):\n        time_table = get_time_table(N, M, schedule)\n        earliest_train = [float('inf')] * N\n        for i in range(N - 1, 0, -1):\n            if not time_table[i]:\n                continue\n            for train in time_table[i]:\n                earliest_train[i] = min(earliest_train[i], train[0] - train[2])\n                earliest_train[i - 1] = min(earliest_train[i - 1], train[1] + train[2])\n        return earliest_train[0]\n\n    def main():\n        N, M = map(int, input().split())\n        schedule = [list(map(int, input().split())) for _ in range(M)]\n        result = find_earliest_train(N, M, schedule)\n        if result == float('inf'):\n            return \"impossible\"\n        return result\n\n    return str(main())"
    },
    {
        "number": 3070,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_earliest_time(station: int, time: int) -> int:\n        earliest_time = float('inf')\n        for i in range(len(trains)):\n            if trains[i][0] == station:\n                earliest_time = min(earliest_time, max(time + delay, time + trains[i][1]))\n        return earliest_time\n\n    N, M = map(int, stdin.split()[:2])\n    trains = [list(map(int, stdin.split()[2:6])) for _ in range(M)]\n    trains.sort(key=lambda x: x[1:])\n    delay = [t[3] for t in trains]\n    time = 0\n    for i in range(1, N):\n        time = get_earliest_time(i, time)\n        if time > 86400:\n            return \"impossible\"\n    return str(trains[-1][1])"
    },
    {
        "number": 3071,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teams = [chr(65 + i) + str(j) for i in range(m) for j in range(1, n + 1)]\n    games = []\n\n    for i in range(n):\n        for j in range(m):\n            for k in range(m):\n                if j != k:\n                    games.append((teams[j * n + i], teams[k * n + (i + k - j) % n]))\n\n    rounds = [[] for _ in range((m - 1) * n + 1)]\n    for game in games:\n        rounds[min(game, key=lambda x: len(rounds[len(rounds[0])]))].append(game)\n\n    output = \"\"\n    for i, round in enumerate(rounds):\n        if round:\n            output += \" \".join([\"-\".join(game) for game in round]) + \"\\n\"\n        else:\n            output += \" \".join([\"BYE\"] * (m - 1) * n) + \"\\n\"\n\n    return output.strip()"
    },
    {
        "number": 3071,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teams = [chr(65 + i) for i in range(m)]\n    schedule = []\n    \n    for i in range(n):\n        round_games = []\n        for j in range(m):\n            if j == i:\n                continue\n            for k in range(n):\n                if k == i:\n                    continue\n                if j < i:\n                    home_team = teams[j]\n                    away_team = teams[i]\n                else:\n                    home_team = teams[i]\n                    away_team = teams[j]\n                home_player = home_team + str(k + 1)\n                away_player = away_team + str(k + 1)\n                round_games.append((home_player, away_player))\n        schedule.append(round_games)\n    \n    output = []\n    for round_games in schedule:\n        round_str = \" \".join([f\"{p1}-{p2}\" for p1, p2 in round_games])\n        output.append(round_str)\n    \n    return \"\\n\".join(output)"
    },
    {
        "number": 3071,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    def get_player_name(team_id, player_id):\n        return chr(team_id + ord('A')) + str(player_id + 1)\n\n    def generate_playing_schedule():\n        total_games = n * (m - 1)\n        total_rounds = total_games + m - 1\n\n        playing_schedule = [[] for _ in range(total_rounds)]\n\n        for round_id in range(total_rounds):\n            for team_id in range(m):\n                for opponent_team_id in range(m):\n                    if opponent_team_id != team_id:\n                        for opponent_player_id in range(n):\n                            home_player_id = round_id if round_id < n else round_id % n\n                            away_player_id = (round_id + opponent_player_id) % n\n\n                            home_player = get_player_name(team_id, home_player_id)\n                            away_player = get_player_name(opponent_team_id, away_player_id)\n\n                            playing_schedule[round_id].append(f\"{home_player}-{away_player}\")\n\n        return playing_schedule\n\n    playing_schedule = generate_playing_schedule()\n\n    return \"\\n\".join(\" \".join(game_list) for game_list in playing_schedule)"
    },
    {
        "number": 3071,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    players = [f'{chr(65 + i)}({j})' for i in range(m) for j in range(n)]\n    games = []\n    for i in range(m - 1):\n        for j in range(i + 1, m):\n            for k in range(n):\n                games.append(f'{players[i * n + k]}-{players[j * n + k]}')\n    \n    rounds = []\n    for i in range((m - 1) * n):\n        round_games = []\n        for j in range(m - 1):\n            round_games.append(games[(i + j) % ((m - 1) * n)])\n        rounds.append(round_games)\n    \n    output = '\\n'.join([' '.join(round) for round in rounds])\n    return output"
    },
    {
        "number": 3071,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    team_players = [f'{chr(65 + i)}{j + 1}' for i in range(m) for j in range(n)]\n    opponents = [team_players[i:] + team_players[:i] for i in range(n)]\n    games = [f'{p1}-{p2}' for p1, p2 in zip(team_players, opponents[0])]\n    games += [f'{p1}-{p2}' for p1, p2 in zip(team_players[n:], opponents[1])]\n    games += [f'{p1}-{p2}' for p1, p2 in zip(team_players[::n], opponents[2])]\n    rounds = [games[i::n] for i in range(n)]\n    return '\\n'.join([' '.join(round) for round in rounds])"
    },
    {
        "number": 3071,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    players = [chr(65 + i) + str(j) for i in range(m) for j in range(n)]\n    rounds = []\n    \n    for i in range(n):\n        round_games = []\n        for j in range(m - 1):\n            for k in range(n):\n                if k != i:\n                    round_games.append(players[i * m + j] + \"-\" + players[k * m + j + 1])\n        rounds.append(round_games)\n    \n    output = []\n    for i in range(n):\n        output.append(\" \".join(rounds[i]))\n        output.append(\"\\n\")\n    \n    return \"\".join(output)[:-1]"
    },
    {
        "number": 3071,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    players = [chr(65 + i) + str(j) for i in range(m) for j in range(1, n + 1)]\n    games = []\n\n    for i in range(m - 1):\n        for j in range(n):\n            for k in range(n):\n                if k != j:\n                    games.append((players[i * n + j], players[i * n + k]))\n\n    for i in range(n):\n        for j in range(m - 1):\n            for k in range(j + 1, m - 1):\n                games.append((players[i], players[j * n + i]))\n                games.append((players[i], players[k * n + i]))\n                games.append((players[j * n + i], players[k * n + i]))\n\n    output = []\n    for i in range(m * n):\n        round_games = []\n        for game in games:\n            if (game[0][1:] == game[1][1:] and game[0][0] != game[1][0]) or (game[0][0] == game[1][0] and game[0][1:] != game[1][1:]):\n                if game[0][1:] == game[1][1:]:\n                    if i % 2 == 0:\n                        round_games.append(game[0] + '-' + game[1])\n                    else:\n                        round_games.append(game[1] + '-' + game[0])\n                else:\n                    if i % 2 == 0:\n                        round_games.append(game[0] + '-' + game[1])\n                    else:\n                        round_games.append(game[1] + '-' + game[0])\n        output.append(' '.join(round_games))\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3071,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    # Initialize players and their opponents\n    players = {}\n    for team in range(ord('A'), ord('A') + m):\n        for num in range(1, n + 1):\n            player = chr(team) + str(num)\n            opponents = set()\n            for opp_team in range(ord('A'), ord('A') + m):\n                if team != opp_team:\n                    for opp_num in range(1, n + 1):\n                        opponents.add(chr(opp_team) + str(opp_num))\n            players[player] = opponents\n\n    # Initialize the playing schedule\n    schedule = []\n    for i in range(m - 1):\n        schedule.append(set())\n\n    # Assign games to rounds\n    for player in players:\n        for opp in players[player]:\n            assigned = False\n            for round_idx in range(m - 1):\n                if opp in schedule[round_idx]:\n                    continue\n                if player in schedule[round_idx] or len(schedule[round_idx]) >= n:\n                    continue\n                schedule[round_idx].add(player + \"-\" + opp)\n                players[player].remove(opp)\n                assigned = True\n                break\n            if assigned:\n                break\n\n    # Output the schedule\n    output = \"\"\n    for round_idx in range(m - 1):\n        output += \" \".join(schedule[round_idx]) + \"\\n\"\n    return output.strip()"
    },
    {
        "number": 3071,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    players = [f\"{chr(65 + i)}{j}\" for i in range(m) for j in range(1, n + 1)]\n    games = []\n    for i in range(m - 1):\n        for j in range(i + 1, m):\n            for k in range(n):\n                games.append(f\"{players[i * n + k]}-{players[j * n + k]}\")\n                games.append(f\"{players[j * n + k]}-{players[i * n + k]}\")\n    rounds = []\n    for i in range(n):\n        round_games = [games[j] for j in range(i, len(games), n)]\n        rounds.append(\" \".join(round_games))\n    return \"\\n\".join(rounds)"
    },
    {
        "number": 3071,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    team_players = []\n    for i in range(1, m + 1):\n        team_players.append([f\"{chr(65)}{j}\" for j in range(1, n + 1)])\n\n    rounds = []\n    for i in range(n):\n        round_games = []\n        for j in range(m):\n            for k in range(m):\n                if j != k:\n                    round_games.append(f\"{team_players[j][i]}-{team_players[k][i]}\")\n        rounds.append(round_games)\n\n    return \"\\n\".join([\" \".join(games) for games in rounds])"
    },
    {
        "number": 3072,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    apartment = []\n    for _ in range(R):\n        apartment.append(list(stdin.readline().strip()))\n\n    def is_valid_table(x, y, table_length, table_width):\n        if x + table_length > R or y + table_width > C:\n            return False\n        for i in range(x, x + table_length):\n            for j in range(y, y + table_width):\n                if apartment[i][j] == 'X':\n                    return False\n        return True\n\n    max_people = 0\n    for x in range(R):\n        for y in range(C):\n            for table_length in range(1, R - x + 1):\n                for table_width in range(1, C - y + 1):\n                    if is_valid_table(x, y, table_length, table_width):\n                        max_people = max(max_people, (table_length + table_width) * 2)\n\n    return str(max_people)"
    },
    {
        "number": 3072,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    apartment = []\n    for i in range(R):\n        row = stdin.readline().strip()\n        apartment.append(row)\n\n    max_perimeter = 0\n    for i in range(R):\n        for j in range(C):\n            if apartment[i][j] == '.':\n                perimeter = 0\n                for k in range(4):\n                    r, c = i, j\n                    if k == 0:\n                        while r >= 0 and apartment[r][c] == '.':\n                            perimeter += 1\n                            r -= 1\n                    elif k == 1:\n                        while c >= 0 and apartment[r][c] == '.':\n                            perimeter += 1\n                            c -= 1\n                    elif k == 2:\n                        while r < R and apartment[r][c] == '.':\n                            perimeter += 1\n                            r += 1\n                    else:\n                        while c < C and apartment[r][c] == '.':\n                            perimeter += 1\n                            c += 1\n                max_perimeter = max(max_perimeter, perimeter)\n\n    return str(max_perimeter)\n"
    },
    {
        "number": 3072,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    apartment = []\n    for _ in range(R):\n        row = stdin.readline().strip()\n        apartment.append(row)\n\n    def compute_perimeter(table_size: int) -> int:\n        return table_size * 4\n\n    max_people = 0\n    for i in range(1, R + 1):\n        for j in range(1, C + 1):\n            if all(apartment[x][y] != 'X' for x in range(i) for y in range(j)) and i * j <= 1000:\n                max_people = max(max_people, compute_perimeter(i + j - 1))\n\n    return str(max_people)"
    },
    {
        "number": 3072,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    apartment = [list(line) for line in stdin.split('\\n')[1:]]\n    free_squares = sum(line.count('.') for line in apartment)\n\n    max_people = 0\n    for i in range(1, R):\n        for j in range(1, C):\n            perimeter = (i + j) * 2\n            people = (apartment[0][0:j].count('.') + apartment[i][0:j].count('.')) * 2\n            people += (apartment[i][j:C].count('.') + apartment[R-1][j:C].count('.')) * 2\n            people += (apartment[0:i][R-1].count('.') + apartment[0:i][j].count('.')) * 2\n            if perimeter == people:\n                max_people = max(max_people, people)\n\n    return str(min(max_people, free_squares))"
    },
    {
        "number": 3072,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    rows, columns = map(int, stdin.readline().split())\n    apartment = []\n    for _ in range(rows):\n        apartment.append(stdin.readline().strip())\n\n    def calculate_perimeter(table: List[List[int]]) -> int:\n        perimeter = 0\n        for i in range(len(table)):\n            for j in range(len(table[0])):\n                if table[i][j] == 1:\n                    perimeter += 4\n                else:\n                    if i > 0:\n                        perimeter -= 1\n                    if i < len(table) - 1:\n                        perimeter -= 1\n                    if j > 0:\n                        perimeter -= 1\n                    if j < len(table[0]) - 1:\n                        perimeter -= 1\n        return perimeter\n\n    max_people = 0\n    for i in range(rows):\n        for j in range(columns):\n            if apartment[i][j] == '.':\n                table = [[0 for _ in range(columns)] for _ in range(rows)]\n                table[i][j] = 1\n                people = calculate_perimeter(table)\n                if people > max_people:\n                    max_people = people\n\n    return str(max_people)"
    },
    {
        "number": 3072,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    apartment = []\n    for _ in range(R):\n        apartment.append(stdin.readline().strip())\n\n    max_people = 0\n    for r in range(R):\n        for c in range(C):\n            if apartment[r][c] == '.':\n                for dr in range(1, R - r + 1):\n                    for dc in range(1, C - c + 1):\n                        if r + dr <= R and c + dc <= C:\n                            if all(apartment[i][j] == '.' for i in range(r, r + dr) for j in range(c, c + dc)):\n                                max_people = max(max_people, 2 * (dr + dc))\n\n    return str(max_people)"
    },
    {
        "number": 3072,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    layout = [list(stdin.readline().strip()) for _ in range(R)]\n    max_people = 0\n\n    for i in range(R):\n        for j in range(C):\n            if layout[i][j] == '.':\n                perimeter = 2 * (i + j) + (R - 1) + (C - 1)\n                max_people = max(max_people, perimeter)\n\n    return str(max_people)"
    },
    {
        "number": 3072,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    apartment = [list(stdin.readline().strip()) for _ in range(R)]\n    max_people = 0\n\n    for i in range(R):\n        for j in range(C):\n            if apartment[i][j] == '.':\n                perimeter = 0\n                for r in range(i, R):\n                    if apartment[r][j] == '.':\n                        perimeter += 2\n                    else:\n                        break\n\n                for c in range(j + 1, C):\n                    if apartment[i][c] == '.':\n                        perimeter += 2\n                    else:\n                        break\n\n                for r in range(i, -1, -1):\n                    if apartment[r][j] == '.':\n                        perimeter += 2\n                    else:\n                        break\n\n                for c in range(j - 1, -1, -1):\n                    if apartment[i][c] == '.':\n                        perimeter += 2\n                    else:\n                        break\n\n                max_people = max(max_people, perimeter)\n\n    return str(max_people)\n"
    },
    {
        "number": 3072,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    apartment = []\n    for i in range(R):\n        row = list(stdin.strip())\n        apartment.append(row)\n        stdin = input()\n\n    max_people = 0\n    for i in range(R):\n        for j in range(C):\n            if apartment[i][j] == '.':\n                for m in range(1, R - i + 1):\n                    for n in range(1, C - j + 1):\n                        if all(apartment[k][l] == '.' for k in range(i, i + m) for l in range(j, j + n)):\n                            perimeter = 2 * (m + n - 1)\n                            max_people = max(max_people, perimeter)\n\n    return str(max_people)"
    },
    {
        "number": 3072,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    apartment = []\n    for _ in range(R):\n        apartment.append(list(stdin.readline().strip()))\n\n    max_people = 0\n    for row in range(R):\n        for col in range(C):\n            if apartment[row][col] == \".\":\n                perimeter = 2 * (R - row - 1) + 2 * (C - col - 1)\n                people = (perimeter - 4) * 4 + 1\n                max_people = max(max_people, people)\n\n    return str(max_people)"
    },
    {
        "number": 3073,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(board, start, goal, cost):\n        queue = [(start, cost, 0)]  # (position, cost, depth)\n        visited = set()\n        while queue:\n            position, total_cost, depth = queue.pop(0)\n            if position == goal:\n                return total_cost\n            if (position, depth) not in visited:\n                visited.add((position, depth))\n                for move in board[position]:\n                    new_position = (position[0] + move[0], position[1] + move[1])\n                    new_cost = total_cost + move[2]\n                    queue.append((new_position, new_cost, depth + 1))\n        return None\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    board = {}\n    start = None\n    for i in range(1, n + 1):\n        r, c, a, b, p = map(int, lines[i].split())\n        if (r, c) not in board:\n            board[(r, c)] = []\n        board[(r, c)].append((a, b, p))\n        if i == 1:\n            start = (r, c)\n    goal = (0, 0)\n    cost = bfs(board, start, goal, 0)\n    return str(cost) if cost is not None else '-1'"
    },
    {
        "number": 3073,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(board: dict, start: tuple, goal: tuple) -> int:\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            position, cost = queue.pop(0)\n            if position == goal:\n                return cost\n            if position in visited:\n                continue\n            visited.add(position)\n            for neighbor in board[position]:\n                queue.append((neighbor, cost + board[position][neighbor]))\n        return -1\n\n    def find_path(board: dict, start: tuple, goal: tuple) -> int:\n        path = {start: None}\n        queue = [start]\n        while queue:\n            current = queue.pop(0)\n            if current == goal:\n                break\n            for neighbor in board[current]:\n                if neighbor not in path:\n                    path[neighbor] = current\n                    queue.append(neighbor)\n\n        if goal not in path:\n            return -1\n\n        cost = 0\n        while goal != start:\n            cost += board[path[goal]][goal]\n            goal = path[goal]\n        return cost\n\n    def is_valid(tarot_cards: list, n: int) -> bool:\n        positions = set()\n        for card in tarot_cards:\n            if card[0] not in positions:\n                positions.add(card[0])\n            else:\n                return False\n        return len(positions) == n\n\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        tarot_cards = []\n        for i in range(1, n + 1):\n            r, c, a, b, p = map(int, lines[i].split())\n            tarot_cards.append(((r, c), (a, b), p))\n        return tarot_cards, n\n\n    def create_board(tarot_cards: list) -> dict:\n        board = {}\n        for card in tarot_cards:\n            position, offsets, _ = card\n            if position not in board:\n                board[position] = {}\n            board[position][tuple(np.array(position) + np.array(offsets))] = abs(offsets[0]) + abs(offsets[1])\n        return board\n\n    tarot_cards, n = parse_input(stdin)\n    if not is_valid(tarot_cards, n):\n        return -1\n\n    board = create_board(tarot_cards)\n    start = tarot_cards[0][0]\n    goal = (0, 0)\n\n    cost = bfs(board, start, goal)\n    if cost == -1:\n        cost = find_path(board, start, goal)\n    return str(cost)"
    },
    {
        "number": 3073,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from heapq import heappush, heappop\n\n    def is_valid(x, y):\n        return -10**9 <= x <= 10**9 and -10**9 <= y <= 10**9\n\n    def get_jumps(x, y, a, b):\n        return [(x + j, y + k) for j, k in [(-a, -b), (a, -b), (-a, b), (a, b), (b, a), (-b, a), (b, -a), (-b, -a)] if is_valid(x + j, y + k)]\n\n    def bfs(start_x, start_y, cards):\n        heap = []\n        visited = set()\n        heappush(heap, (0, start_x, start_y, 0))\n\n        while heap:\n            cost, x, y, card_idx = heappop(heap)\n            if (x, y) == (0, 0):\n                return cost\n\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n\n            for j, k in get_jumps(x, y, cards[card_idx][0], cards[card_idx][1]):\n                if (j, k) not in visited:\n                    heappush(heap, (cost + cards[card_idx][3], j, k, card_idx))\n\n            if card_idx + 1 < len(cards) and (x, y) == cards[card_idx + 1][:2]:\n                heappush(heap, (cost + cards[card_idx + 1][3], x, y, card_idx + 1))\n\n        return -1\n\n    n = int(stdin.readline().strip())\n    cards = []\n    for _ in range(n):\n        r, c, a, b, p = map(int, stdin.readline().strip().split())\n        cards.append((r, c, a, b, p))\n\n    start_x, start_y = cards[0][:2]\n    return str(bfs(start_x, start_y, cards))"
    },
    {
        "number": 3073,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    tarot_cards = []\n    for i in range(1, n + 1):\n        r, c, a, b, p = map(int, lines[i].split())\n        tarot_cards.append(((r, c), (a, b), p))\n\n    # Dijkstra's algorithm to find minimum cost to (0, 0)\n    import heapq\n    pq = [(0, (0, 0), {})]  # cost, position, cards\n    visited = set()\n\n    while pq:\n        cost, pos, cards = heapq.heappop(pq)\n        if pos == (0, 0):\n            return str(cost)\n        if pos in visited:\n            continue\n        visited.add(pos)\n\n        # Add possible moves from this position\n        for card in tarot_cards:\n            if pos == card[0]:\n                for offset in card[1]:\n                    new_pos = (pos[0] + offset[0], pos[1] + offset[1])\n                    new_cards = dict(cards)\n                    if card[0] in new_cards:\n                        new_cards[card[0]] += 1\n                    else:\n                        new_cards[card[0]] = 1\n                    new_cost = cost + (new_cards[card[0]] - 1) * card[2]\n                    heapq.heappush(pq, (new_cost, new_pos, new_cards))\n\n    return \"-1\""
    },
    {
        "number": 3073,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return -10**9 <= x <= 10**9 and -10**9 <= y <= 10**9\n\n    def bfs(start_r, start_c, a, b, cards, visited, cost):\n        queue = [(start_r, start_c, a, b, cost)]\n        visited.add((start_r, start_c, a, b))\n\n        while queue:\n            r, c, a, b, cost = queue.pop(0)\n\n            if r == 0 and c == 0:\n                return cost\n\n            for dx, dy in [(-a, -b), (a, -b), (-a, b), (a, b), (b, a), (-b, a), (b, -a), (-b, -a)]:\n                new_r, new_c = r + dx, c + dy\n\n                if is_valid(new_r, new_c) and (new_r, new_c) in cards:\n                    for new_a, new_b, new_p in cards[(new_r, new_c)]:\n                        if (new_r, new_c, new_a, new_b) not in visited:\n                            visited.add((new_r, new_c, new_a, new_b))\n                            queue.append((new_r, new_c, new_a, new_b, cost + new_p))\n\n        return -1\n\n    n = int(stdin.readline().strip())\n    cards = {}\n\n    for _ in range(n):\n        r, c, a, b, p = map(int, stdin.readline().strip().split())\n        if (r, c) not in cards:\n            cards[(r, c)] = []\n        cards[(r, c)].append((a, b, p))\n\n    start_r, start_c, a, b, p = cards[list(cards.keys())[0]][0]\n    visited = set()\n    return str(bfs(start_r, start_c, a, b, cards, visited, p))"
    },
    {
        "number": 3073,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    lines = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    queue = [(0, 0, 0, lines[0][-1])]  # (r, c, cost, card_price)\n    visited = set()\n\n    while queue:\n        r, c, cost, card_price = queue.pop(0)\n        if (r, c, card_price) in visited:\n            continue\n        visited.add((r, c, card_price))\n\n        if r == 0 and c == 0:\n            return str(cost)\n\n        for line in lines:\n            if line[0] == r and line[1] == c:\n                a, b, p = line[2], line[3], line[4]\n                for offset in [(a, b), (a, -b), (-a, b), (-a, -b), (b, a), (-b, a), (b, -a), (-b, -a)]:\n                    if (r + offset[0], c + offset[1]) in [(x[0], x[1]) for x in lines]:\n                        queue.append((r + offset[0], c + offset[1], cost + p, card_price))\n\n    return \"-1\""
    },
    {
        "number": 3073,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            position, cost = queue.pop(0)\n            if position == end:\n                return cost\n\n            for i in range(4):\n                dx, dy = offsets[i]\n                next_x, next_y = position[0] + dx, position[1] + dy\n                if (next_x, next_y) not in visited and (next_x, next_y) in cards:\n                    queue.append(((next_x, next_y), cost + cards[(next_x, next_y)]))\n\n            visited.add(position)\n\n        return -1\n\n    def get_offsets(a, b):\n        return [(a, b), (-a, b), (a, -b), (-a, -b), (b, a), (-b, a), (b, -a), (-b, -a)]\n\n    n = int(stdin.readline())\n    cards = {}\n    offsets = []\n    start = (0, 0)\n\n    for i in range(n):\n        r, c, a, b, p = map(int, stdin.readline().split())\n        cards[(r, c)] = p\n        if i == 0:\n            start = (r, c)\n        offsets.extend(get_offsets(a, b))\n\n    return str(bfs(start, (0, 0)))"
    },
    {
        "number": 3073,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start, end, tarot_cards, prices):\n        queue = [(start, 0)]\n        visited = {start: 0}\n\n        while queue:\n            position, cost = queue.pop(0)\n\n            if position == end:\n                return cost\n\n            for a, b in tarot_cards[position]:\n                new_position = (position[0] + a, position[1] + b)\n\n                if new_position in visited:\n                    continue\n\n                if new_position in prices:\n                    visited[new_position] = cost + prices[new_position]\n                    queue.append((new_position, cost + prices[new_position]))\n\n        return -1\n\n    n = int(stdin.readline())\n    stdin.readline()  # skip first input line\n    tarot_cards = {}\n    prices = {}\n\n    for i in range(n):\n        r, c, a, b, p = map(int, stdin.readline().split())\n        tarot_cards.setdefault((r, c), []).append((a, b))\n        prices[(r, c)] = p\n\n    start = list(tarot_cards.keys())[0]\n    end = (0, 0)\n\n    result = bfs(start, end, tarot_cards, prices)\n\n    return str(result)"
    },
    {
        "number": 3073,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(board: List[List[int]], start: Tuple[int, int]) -> int:\n        queue = deque([(start, 0)])\n        visited = set()\n        while queue:\n            position, cost = queue.popleft()\n            if position == (0, 0):\n                return cost\n            if position not in visited:\n                visited.add(position)\n                for move in moves:\n                    new_position = (position[0] + move[0], position[1] + move[1])\n                    if 0 <= new_position[0] < len(board) and 0 <= new_position[1] < len(board[0]) and board[new_position[0]][new_position[1]] != -1:\n                        queue.append((new_position, cost + board[new_position[0]][new_position[1]]))\n        return -1\n\n    def create_board(n: int, tarots: List[List[int]]) -> List[List[int]]:\n        max_r = max(x[0] for x in tarots)\n        max_c = max(x[1] for x in tarots)\n        board = [[-1] * (max_c + 1) for _ in range(max_r + 1)]\n        for i, tarot in enumerate(tarots):\n            if i == 0:\n                board[tarot[0]][tarot[1]] = 0\n            else:\n                board[tarot[0]][tarot[1]] = tarot[4]\n        return board\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    tarots = [list(map(int, line.split())) for line in lines[1:n + 1]]\n    moves = [(a, b) for a in [-1, 0, 1] for b in [-1, 0, 1] if a != 0 or b != 0]\n\n    board = create_board(n, tarots)\n    result = bfs(board, (tarots[0][0], tarots[0][1]))\n    return str(result)"
    },
    {
        "number": 3073,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(board, start, end, cost):\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            pos, total_cost = queue.pop(0)\n            if pos == end:\n                return total_cost\n            if pos in visited:\n                continue\n            visited.add(pos)\n            for move in cost[pos]:\n                new_pos = (pos[0] + move[0], pos[1] + move[1])\n                new_cost = total_cost + move[2]\n                queue.append((new_pos, new_cost))\n        return -1\n\n    def parse_input(stdin):\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        tarot_cards = []\n        for i in range(1, n + 1):\n            r, c, a, b, p = map(int, lines[i].split())\n            tarot_cards.append(((r, c), (a, b, p)))\n        return tarot_cards\n\n    def build_board(tarot_cards):\n        board = {}\n        cost = {}\n        for pos, (a, b, p) in tarot_cards:\n            board[pos] = (a, b)\n            cost[pos] = [(a, b, p), (-b, a, p), (-a, -b, p), (b, -a, p), (-a, b, p), (b, a, p)]\n        return board, cost\n\n    tarot_cards = parse_input(stdin)\n    board, cost = build_board(tarot_cards)\n    start = tarot_cards[0][0]\n    end = (0, 0)\n    return str(bfs(board, start, end, cost))"
    },
    {
        "number": 3074,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    N, S = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    # Initialize the number of valid subsets\n    count = 0\n\n    # Convert S to a string\n    S = str(S)\n\n    # Helper function to check if a string is valid\n    def is_valid(s: str) -> bool:\n        if int(s) % 3 != 0:\n            return False\n        for i in range(1, len(s)):\n            if int(s[:i]) % 3 != 0 or int(s[i:]) % 3 != 0:\n                return False\n        return True\n\n    # Iterate through all possible subsets of S\n    for i in range(len(S)):\n        for j in range(i + 1, len(S) + 1):\n            if is_valid(S[i:j]):\n                count += 1\n\n    # Return the result modulo MOD\n    return str(count % MOD)"
    },
    {
        "number": 3074,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s: str) -> bool:\n        return s.lstrip('0') == s and int(s) % 3 == 0\n\n    N, S = stdin.split('\\n')\n    N = int(N)\n\n    subsets = []\n    for i in range(1, N + 1):\n        for j in range(N - i + 1):\n            subset = S[j:j + i]\n            if is_valid(subset):\n                subsets.append(subset)\n\n    return str(len(subsets) % (10**9 + 7))"
    },
    {
        "number": 3074,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = str(s)\n    dp = [0] * n\n    dp[0] = 1 if s[0] == '0' else 2\n    for i in range(1, n):\n        if s[i] == '0':\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = dp[i - 1] + dp[i]\n    ans = 0\n    for i in range(n):\n        if s[i] % 3 == 0:\n            ans += dp[i]\n            if i > 0:\n                ans -= dp[i - 1]\n    return str(ans % (10**9 + 7))"
    },
    {
        "number": 3074,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    b = stdin.readline().strip()\n    mod = 10**9 + 7\n    result = 0\n\n    def is_valid(s: str) -> bool:\n        return s != '' and int(s) % 3 == 0\n\n    for i in range(len(b)):\n        for j in range(i + 1, len(b) + 1):\n            if is_valid(b[i:j]):\n                result += 1\n\n    return str(result % mod)"
    },
    {
        "number": 3074,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s: str) -> bool:\n        return s and int(s) % 3 == 0\n\n    n, b = map(int, stdin.split('\\n'))\n    b = str(b)\n    subsets = []\n\n    for i in range(len(b)):\n        for j in range(i + 1, len(b) + 1):\n            subset = b[i:j]\n            if is_valid(subset):\n                subsets.append(subset)\n\n    return str(len(subsets) % (10**9 + 7))"
    },
    {
        "number": 3074,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split('\\n')\n    N = int(N)\n    S = [int(d) for d in S]\n    modulo = 10**9 + 7\n\n    def is_valid(subset):\n        num = 0\n        for digit in subset:\n            num = num * 10 + digit\n        return num % 3 == 0\n\n    def count_valid_subsets(idx, prefix):\n        if idx == N:\n            return 1 if is_valid(prefix) else 0\n\n        count = count_valid_subsets(idx + 1, prefix)\n\n        new_prefix = prefix + [S[idx]]\n        if is_valid(new_prefix):\n            count += count_valid_subsets(idx + 1, new_prefix)\n\n        return count % modulo\n\n    return str(count_valid_subsets(0, []))"
    },
    {
        "number": 3074,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    b = int(stdin.readline().strip())\n\n    MOD = 10**9 + 7\n\n    def is_valid(subset):\n        return not subset.startswith('0') and int(subset) % 3 == 0\n\n    def count_valid_subsets(s):\n        subsets = [0] * len(s)\n        for i in range(len(s)):\n            if s[i] == '0':\n                continue\n            for j in range(i, len(s)):\n                if s[j] == '0':\n                    continue\n                subsets[j] += subsets[i - 1]\n                if is_valid(s[i:j + 1]):\n                    subsets[j] += 1\n        return sum(subsets) % MOD\n\n    result = count_valid_subsets(str(b))\n    return result "
    },
    {
        "number": 3074,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.strip()))\n    n = input_data[0]\n    s = input_data[1:]\n    \n    def is_valid(subset):\n        return (sum(subset) % 3 == 0) and (len(subset) > 0)\n\n    def count_valid_subsets(s):\n        dp = [[0 for _ in range(len(s) + 1)] for _ in range(2)]\n        dp[0][0] = 1\n\n        for i in range(1, len(s) + 1):\n            dp[i % 2][0] = 1\n            for j in range(1, i + 1):\n                dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + dp[i % 2][j - 1]\n                if is_valid(s[i - j:i]):\n                    dp[i % 2][j] += dp[(i - 1) % 2][j]\n\n        return dp[len(s) % 2][len(s)]\n\n    result = count_valid_subsets(s) % (10**9 + 7)\n    return str(result)"
    },
    {
        "number": 3074,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n\n    def is_valid(substring):\n        return int(substring) % 3 == 0\n\n    def generate_subsets(s, valid_subsets):\n        if not s:\n            return valid_subsets\n        generate_subsets(s[1:], valid_subsets)\n        for i in range(1, len(s)):\n            if is_valid(s[:i]):\n                generate_subsets(s[i:], valid_subsets + [s[:i]])\n\n    valid_subsets = []\n    generate_subsets(s, valid_subsets)\n\n    return str(len(valid_subsets) % (10**9 + 7))"
    },
    {
        "number": 3074,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    MOD = 10**9 + 7\n\n    def is_valid(subset):\n        return int(subset) % 3 == 0\n\n    def count_valid_subsets(s, n):\n        dp = [[0] * 2 for _ in range(n + 1)]\n\n        for i in range(n + 1):\n            if i == 0:\n                dp[i][0] = 1\n            else:\n                dp[i][0] = dp[i - 1][0]\n                dp[i][1] = dp[i - 1][0] + dp[i - 1][1]\n\n            if is_valid(s[:i]):\n                dp[i][1] += 1\n\n        return dp[n][1]\n\n    result = count_valid_subsets(s, n) % MOD\n    return str(result)"
    },
    {
        "number": 3075,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_cost_to_travel(gas_stations, fuel_tank_capacity, current_position=0, fuel_amount=0, total_cost=0):\n        if current_position == len(gas_stations) - 1:\n            return total_cost if fuel_amount >= distance_to_last_station else \"cancel road trip\"\n\n        min_cost = float(\"inf\")\n        for i in range(current_position, len(gas_stations)):\n            distance, cost = gas_stations[i]\n            if distance <= fuel_amount:\n                continue\n            else:\n                fuel_needed = distance - fuel_amount\n                cost_for_fuel = cost * fuel_needed\n                fuel_after_refuel = fuel_amount + fuel_needed\n                if fuel_after_refuel > fuel_tank_capacity:\n                    return \"cancel road trip\"\n                else:\n                    total_cost += cost_for_fuel\n                    min_cost = min(min_cost, total_cost + min_cost_to_travel(gas_stations, fuel_tank_capacity, i, fuel_after_refuel, total_cost))\n        return min_cost\n\n    n, g = map(int, stdin.readline().split())\n    gas_stations = []\n    for _ in range(n):\n        distance, cost = map(int, stdin.readline().split())\n        gas_stations.append((distance, cost))\n\n    gas_stations.sort()\n    min_cost = min_cost_to_travel(gas_stations, g)\n    if min_cost == \"cancel road trip\":\n        return \"cancel road trip\"\n    else:\n        return str(min_cost) "
    },
    {
        "number": 3075,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, g = map(int, lines[0].split())\n    gas_stations = []\n\n    for i in range(1, n + 1):\n        d, c = map(int, lines[i].split())\n        gas_stations.append((d, c))\n\n    gas_stations.sort()\n\n    fuel = 0\n    cost = 0\n\n    for i in range(n):\n        d, c = gas_stations[i]\n        fuel_needed = d - (sum([x[0] for x in gas_stations[:i]]) if i > 0 else 0)\n\n        if fuel_needed > g:\n            return \"cancel road trip\"\n\n        if fuel_needed > fuel:\n            cost += (fuel_needed - fuel) * c\n\n        fuel = min(fuel + fuel_needed, g)\n\n    return cost "
    },
    {
        "number": 3075,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n, g = map(int, stdin.readline().split())\n    gas_stations = []\n    for _ in range(n):\n        distance, cost = map(int, stdin.readline().split())\n        gas_stations.append((distance, cost))\n    \n    # Sort gas stations by distance\n    gas_stations.sort(key=lambda x: x[0])\n    \n    # Initialize variables\n    min_cost = 0\n    fuel_left = g\n    last_gas_station = 0\n    \n    # Fill up at each gas station\n    for i in range(1, n):\n        distance_to_next = gas_stations[i][0] - gas_stations[last_gas_station][0]\n        fuel_needed = distance_to_next // 10\n        \n        if fuel_left >= fuel_needed:\n            fuel_left -= fuel_needed\n            last_gas_station = i\n            min_cost += fuel_needed * gas_stations[i][1]\n        else:\n            return \"cancel road trip\"\n    \n    # Calculate final cost\n    distance_to_last = gas_stations[n-1][0] - gas_stations[last_gas_station][0]\n    fuel_needed = distance_to_last // 10\n    \n    if fuel_left >= fuel_needed:\n        min_cost += fuel_needed * gas_stations[n-1][1]\n    else:\n        return \"cancel road trip\"\n    \n    return str(min_cost)"
    },
    {
        "number": 3075,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(gas_stations, fuel_tank_capacity):\n        fuel_needed = 0\n        for distance, cost in gas_stations:\n            fuel_needed += distance * cost\n            if fuel_needed > fuel_tank_capacity:\n                return False\n        return True\n\n    def calculate_cost(gas_stations):\n        total_cost = 0\n        fuel_needed = 0\n        for distance, cost in gas_stations:\n            fuel_needed += distance * cost\n            total_cost += distance * cost\n        return total_cost\n\n    input_lines = stdin.split('\\n')\n    n, fuel_tank_capacity = map(int, input_lines[0].split())\n    gas_stations = [list(map(int, line.split())) for line in input_lines[1:]]\n    gas_stations.sort(key=lambda x: x[0])\n\n    if is_possible(gas_stations, fuel_tank_capacity):\n        return calculate_cost(gas_stations)\n    else:\n        return \"cancel road trip\""
    },
    {
        "number": 3075,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    n, g = map(int, input_data[0].split())\n    gas_stations = [list(map(int, line.split())) for line in input_data[1:]]\n    gas_stations.sort(key=lambda x: x[0])\n\n    total_cost = 0\n    fuel_left = 0\n\n    for i in range(n):\n        distance, cost = gas_stations[i]\n        fuel_needed = (distance - fuel_left)\n        fuel_price = fuel_needed * cost\n        total_cost += fuel_price\n\n        if total_cost > g:\n            return \"cancel road trip\"\n\n        fuel_left = distance\n\n    return str(total_cost)"
    },
    {
        "number": 3075,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def can_travel(fuel, stations, next_station):\n        return fuel >= distance_to_next_station(stations, next_station)\n\n    def distance_to_next_station(stations, next_station):\n        return next_station - stations[-1][0]\n\n    def calculate_cost(stations, next_station):\n        distance = distance_to_next_station(stations, next_station)\n        cost_per_gallon = stations[-1][1]\n        return distance * cost_per_gallon\n\n    def fill_up_gas(fuel, stations, next_station):\n        fuel_needed = distance_to_next_station(stations, next_station)\n        cost = calculate_cost(stations, next_station)\n        if fuel_needed <= fuel:\n            return cost\n        else:\n            return cost + fill_up_gas(fuel - fuel_needed, stations + [(next_station, cost_per_gallon)], gas_stations[i + 1][0])\n\n    n, g = map(int, stdin.readline().split())\n    gas_stations = [(0, 0)]\n    for i in range(n):\n        d, c = map(int, stdin.readline().split())\n        gas_stations.append((d, c))\n\n    fuel = g\n    current_station = 0\n    total_cost = 0\n\n    for i in range(1, n + 1):\n        if can_travel(fuel, gas_stations[:i], gas_stations[i][0]):\n            fuel -= distance_to_next_station(gas_stations[:i], gas_stations[i][0])\n            total_cost += calculate_cost(gas_stations[:i], gas_stations[i][0])\n        else:\n            return \"cancel road trip\"\n\n    return str(total_cost)"
    },
    {
        "number": 3075,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split(\"\\n\")\n    n, g = map(int, lines[0].split())\n    gas_stations = []\n    for i in range(1, n + 1):\n        distance, cost = map(int, lines[i].split())\n        gas_stations.append((distance, cost))\n\n    # Sort gas stations by distance\n    gas_stations.sort(key=lambda x: x[0])\n\n    # Initialize variables\n    tank = g\n    total_cost = 0\n    last_station_distance = 0\n\n    # Iterate through gas stations\n    for distance, cost in gas_stations:\n        # Calculate cost to reach this gas station\n        cost_to_reach = (distance - last_station_distance) * cost\n\n        # If cost to reach is greater than tank capacity, cancel trip\n        if cost_to_reach > tank:\n            return \"cancel road trip\"\n\n        # Calculate cost to refuel\n        fuel_to_buy = min(tank - cost_to_reach, g)\n        cost_to_refuel = fuel_to_buy * cost\n\n        # Update tank and total cost\n        tank -= cost_to_reach\n        tank += fuel_to_buy\n        total_cost += cost_to_reach + cost_to_refuel\n\n        # Update last station distance\n        last_station_distance = distance\n\n    # Return minimum cost\n    return total_cost"
    },
    {
        "number": 3075,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_cost(gas_stations, g):\n        total_cost = 0\n        current_gallons = 0\n        for i in range(len(gas_stations)):\n            if current_gallons < g:\n                current_gallons += g - current_gallons\n                total_cost += gas_stations[i][1] * (g - current_gallons)\n                current_gallons = g\n            else:\n                return float('inf')\n        return total_cost\n\n    n, g = map(int, stdin.split()[:2])\n    gas_stations = [list(map(int, stdin.split())) for i in range(n)]\n    gas_stations.sort(key=lambda x: x[0])\n    return min(calculate_cost(gas_stations, i) for i in range(1, g + 1))"
    },
    {
        "number": 3075,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.readline().split())\n    gas_stations = []\n\n    for i in range(n):\n        d, c = map(int, stdin.readline().split())\n        gas_stations.append((d, c))\n\n    gas_stations.sort()\n\n    tank = g\n    cost = 0\n    prev_station_distance = 0\n\n    for distance, price in gas_stations:\n        tank -= (distance - prev_station_distance)\n\n        if tank <= 0:\n            return \"cancel road trip\"\n\n        cost += (distance - prev_station_distance) * price\n        tank -= (distance - prev_station_distance) * price\n\n        if tank < 0:\n            return \"cancel road trip\"\n\n        tank = min(tank + g - (distance - prev_station_distance), g)\n        prev_station_distance = distance\n\n    return str(cost)"
    },
    {
        "number": 3075,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.readline().split())\n    stations = []\n    total_distance = 0\n\n    for i in range(n):\n        d, c = map(int, stdin.readline().split())\n        stations.append((d, c))\n        total_distance = max(total_distance, d)\n\n    stations.sort()\n    current_gallons = g\n    current_cost = 0\n    last_station_distance = 0\n\n    for distance, cost in stations:\n        if current_gallons == 0:\n            break\n\n        gallons_needed = (distance - last_station_distance) * cost\n\n        if gallons_needed <= current_gallons:\n            current_cost += gallons_needed * cost\n            current_gallons -= gallons_needed\n        else:\n            current_cost += current_gallons * cost\n            current_gallons = 0\n\n        last_station_distance = distance\n\n    if current_gallons == 0 and last_station_distance == total_distance:\n        return current_cost\n    else:\n        return \"cancel road trip\"\n"
    },
    {
        "number": 3076,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    jewels = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    knapsacks = [0] * (k + 1)\n    for size, value in jewels:\n        for i in range(size, k + 1):\n            knapsacks[i] = max(knapsacks[i], knapsacks[i - size] + value)\n    return ' '.join(map(str, knapsacks[1:]))"
    },
    {
        "number": 3076,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def knapsack(capacity: int, weights: List[int], values: List[int], n: int) -> int:\n        dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n        for i in range(n + 1):\n            for w in range(capacity + 1):\n                if i == 0 or w == 0:\n                    dp[i][w] = 0\n                elif weights[i - 1] <= w:\n                    dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w])\n                else:\n                    dp[i][w] = dp[i - 1][w]\n        return dp[n][capacity]\n\n    lines = stdin.split('\\n')\n    n, k = map(int, lines[0].split())\n    jewels = [list(map(int, line.split())) for line in lines[1:]]\n    jewels.sort(key=lambda x: x[1], reverse=True)\n\n    for i in range(1, k + 1):\n        result = knapsack(i, [j[0] for j in jewels], [j[1] for j in jewels], n)\n        print(result, end=' ')\n    return '' "
    },
    {
        "number": 3076,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    jewels = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= jewels[i - 1][0]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - jewels[i - 1][0]] + jewels[i - 1][1])\n\n    return \" \".join(str(x) for x in dp[n])"
    },
    {
        "number": 3076,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def knapsack(values, weights, n, capacity):\n        dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n            for j in range(1, capacity + 1):\n                if weights[i - 1] <= j:\n                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1])\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[n][capacity]\n\n    n, k = map(int, stdin.readline().split())\n    values = []\n    weights = []\n\n    for _ in range(n):\n        s, v = map(int, stdin.readline().split())\n        values.append(v)\n        weights.append(s)\n\n    result = [0] * (k + 1)\n    result[0] = 0\n    result[1] = knapsack(values, weights, n, 1)\n\n    for i in range(2, k + 1):\n        result[i] = knapsack(values, weights, n, i)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3076,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def knapSack(n, k, val, wt):\n        K = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            for j in range(k + 1):\n                if i == 0 or j == 0:\n                    K[i][j] = 0\n                elif wt[i - 1] <= j:\n                    K[i][j] = max(val[i - 1] + K[i - 1][j - wt[i - 1]], K[i - 1][j])\n                else:\n                    K[i][j] = K[i - 1][j]\n        return K[n][k]\n\n    def main(stdin: str) -> str:\n        n, k = map(int, stdin.readline().strip().split())\n        val = []\n        wt = []\n        for _ in range(n):\n            s, v = map(int, stdin.readline().strip().split())\n            val.append(v)\n            wt.append(s)\n        result = [0] * (k + 1)\n        for i in range(1, k + 1):\n            result[i] = knapSack(n, i, val, wt)\n        return ' '.join(map(str, result))\n\n    return main(stdin)"
    },
    {
        "number": 3076,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    jewels = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    jewels.sort(key=lambda x: x[1], reverse=True)\n    dp = [0] * (k + 1)\n    for size, value in jewels:\n        for i in range(size, k + 1):\n            dp[i] = max(dp[i], dp[i - size] + value)\n    return ' '.join(map(str, dp[1:]))\n\ndef"
    },
    {
        "number": 3076,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, k = map(int, lines[0].split())\n    jewels = [list(map(int, line.split())) for line in lines[1:]]\n    jewels.sort(key=lambda x: x[1], reverse=True)\n\n    def knapsack(s: int, jewels: List[List[int]]) -> int:\n        dp = [0] * (s + 1)\n        for jewel in jewels:\n            for i in range(s, jewel[0] - 1, -1):\n                dp[i] = max(dp[i], dp[i - jewel[0]] + jewel[1])\n        return dp[s]\n\n    result = []\n    for i in range(1, k + 1):\n        result.append(knapsack(i, jewels))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3076,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def knapsack(knapsacks, items):\n        dp = [[0] * (len(items) + 1) for _ in range(knapsacks + 1)]\n        for i in range(1, knapsacks + 1):\n            for j in range(1, len(items) + 1):\n                dp[i][j] = dp[i][j - 1]\n                if items[j - 1][0] <= i:\n                    dp[i][j] = max(dp[i][j], dp[i - items[j - 1][0]][j - 1] + items[j - 1][1])\n        return dp[knapsacks]\n\n    n, k = list(map(int, stdin.split()))\n    items = [list(map(int, input().split())) for _ in range(n)]\n    items.sort(key=lambda x: x[1], reverse=True)\n\n    result = knapsack(k, items)\n    return ' '.join(map(str, result))"
    },
    {
        "number": 3076,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    jewels = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    jewels.sort(key=lambda x: x[1], reverse=True)\n\n    dp = [0] * (k + 1)\n    for s, v in jewels:\n        for i in range(s, k + 1)[::-1]:\n            dp[i] = max(dp[i], dp[i - s] + v)\n\n    return ' '.join(map(str, dp[1:]))"
    },
    {
        "number": 3076,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    jewels = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = dp[i - 1][j]\n            size, value = jewels[i - 1]\n            if size <= j:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - size] + value)\n\n    return ' '.join(map(str, dp[n])) "
    },
    {
        "number": 3077,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.readline().split())\n    villages = []\n    for _ in range(n):\n        x, y, radius = map(int, stdin.readline().split())\n        villages.append((x, y, radius))\n    minions = []\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        minions.append((x, y))\n\n    def is_village_in_aoe(village, aoe_center, aoe_radius):\n        vx, vy, vr = village\n        cx, cy = aoe_center\n        min_distance = abs(vr - (((cx - vx) ** 2 + (cy - vy) ** 2) ** 0.5))\n        return min_distance <= aoe_radius\n\n    def is_minion_in_aoe(minion, aoe_center, aoe_radius):\n        mx, my = minion\n        cx, cy = aoe_center\n        return ((cx - mx) ** 2 + (cy - my) ** 2) ** 0.5 <= aoe_radius\n\n    def count_minions_in_aoe(aoe_center, aoe_radius):\n        count = 0\n        for minion in minions:\n            if is_minion_in_aoe(minion, aoe_center, aoe_radius):\n                count += 1\n        return count\n\n    min_damage = 0\n    max_damage = 0\n    for village in villages:\n        vx, vy, vr = village\n        min_damage = max(min_damage, count_minions_in_aoe((vx, vy), vr))\n        max_damage = max(max_damage, count_minions_in_aoe((vx, vy), r))\n\n    return str(min(min_damage, max_damage))"
    },
    {
        "number": 3077,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    n, m, r = map(int, stdin.readline().split())\n    villages = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    minions = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    max_minions = 0\n    for village in villages:\n        valid_minions = [m for m in minions if distance(m[0], m[1], village[0], village[1]) - village[2] <= r]\n        max_minions = max(max_minions, len(valid_minions))\n\n    return str(max_minions)"
    },
    {
        "number": 3077,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_circle(x, y, radius, center_x, center_y):\n        return (x - center_x) ** 2 + (y - center_y) ** 2 <= radius ** 2\n\n    def is_inside_village(x, y, villages):\n        for village in villages:\n            if is_inside_circle(x, y, village[2], village[0], village[1]):\n                return True\n        return False\n\n    def count_minions_inside_aoe(x, y, radius, minions, villages):\n        count = 0\n        for minion in minions:\n            if not is_inside_village(minion[0], minion[1], villages) and is_inside_circle(minion[0], minion[1], radius, x, y):\n                count += 1\n        return count\n\n    input_data = [line.strip() for line in stdin.split('\\n')]\n    n, m, r = list(map(int, input_data[0].split()))\n    villages = [list(map(int, input_data[i + 1].split())) for i in range(n)]\n    minions = [list(map(int, input_data[i + n + 1].split())) for i in range(m)]\n\n    max_minions_destroyed = 0\n    for village in villages:\n        x, y, radius = village\n        for curr_radius in range(1, radius + 1):\n            max_minions_destroyed = max(max_minions_destroyed, count_minions_inside_aoe(x, y, curr_radius, minions, villages))\n\n    return str(max_minions_destroyed)"
    },
    {
        "number": 3077,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split()[:3])\n    villages = [tuple(map(int, stdin.split()[3:5])) + (int(stdin.split()[5]),) for _ in range(n)]\n    minions = [tuple(map(int, stdin.split()[3 + 3 * n:5 + 3 * n])) for _ in range(m)]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def attack(center, radius):\n        return sum(distance(center, minion) <= radius for minion in minions)\n\n    def is_safe(village, radius):\n        return all(distance(village, minion) > village[-1] + radius for minion in minions)\n\n    max_minions = 0\n    for village in villages:\n        left = 0\n        right = r\n        while left <= right:\n            mid = (left + right) // 2\n            if is_safe(village, mid):\n                max_minions = max(max_minions, attack(village, mid))\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return str(max_minions)"
    },
    {
        "number": 3077,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.readline().split())\n    villages = []\n    for _ in range(n):\n        x, y, radius = map(int, stdin.readline().split())\n        villages.append((x, y, radius))\n    minions = []\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        minions.append((x, y))\n    \n    def is_valid_attack(center_x, center_y):\n        for x, y, radius in villages:\n            distance = ((center_x - x) ** 2 + (center_y - y) ** 2) ** 0.5\n            if distance <= radius + r:\n                return False\n        return True\n    \n    def count_destroyed_minions(center_x, center_y):\n        count = 0\n        for x, y in minions:\n            distance = ((center_x - x) ** 2 + (center_y - y) ** 2) ** 0.5\n            if distance <= r:\n                count += 1\n        return count\n    \n    max_minions_destroyed = 0\n    for x in range(-r, r + 1):\n        for y in range(-r, r + 1):\n            if is_valid_attack(x, y):\n                max_minions_destroyed = max(max_minions_destroyed, count_destroyed_minions(x, y))\n                \n    return str(max_minions_destroyed)"
    },
    {
        "number": 3077,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_valid(vx, vy, vr, mx, my, r):\n        return distance(vx, vy, mx, my) + r <= vr\n\n    def count_valid_minions(villages, minions, r):\n        valid_minions = 0\n        for minion in minions:\n            if all(not is_valid(vx, vy, vr, minion[0], minion[1], r) for vx, vy, vr in villages):\n                valid_minions += 1\n        return valid_minions\n\n    lines = stdin.split('\\n')\n    n, m, r = map(int, lines[0].split())\n    villages = [tuple(map(int, line.split())) for line in lines[1:n + 1]]\n    minions = [tuple(map(int, line.split())) for line in lines[n + 1:]]\n\n    max_valid_minions = 0\n    for i in range(1, r + 1):\n        max_valid_minions = max(max_valid_minions, count_valid_minions(villages, minions, i))\n\n    return str(max_valid_minions)"
    },
    {
        "number": 3077,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dist(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_valid(vx, vy, vr, mx, my, r):\n        return dist(vx, vy, mx, my) + r <= vr\n\n    def count_valid_minions(vx, vy, vr, minions, r):\n        valid_minions = [minion for minion in minions if is_valid(vx, vy, vr, minion[0], minion[1], r)]\n        return len(valid_minions)\n\n    input_data = stdin.split(\"\\n\")\n    n, m, r = list(map(int, input_data[0].split()))\n    villages = []\n    minions = []\n\n    for i in range(1, n + 1):\n        vx, vy, vr = list(map(int, input_data[i].split()))\n        villages.append((vx, vy, vr))\n\n    for i in range(n + 1, n + m + 1):\n        mx, my = list(map(int, input_data[i].split()))\n        minions.append((mx, my))\n\n    max_minions = 0\n    for village in villages:\n        for radius in range(1, r + 1):\n            max_minions = max(max_minions, count_valid_minions(village[0], village[1], village[2], minions, radius))\n\n    return str(max_minions)"
    },
    {
        "number": 3077,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.readline().split())\n    villages = []\n    for _ in range(n):\n        x, y, radius = map(int, stdin.readline().split())\n        villages.append((x, y, radius))\n    enemy_minions = []\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        enemy_minions.append((x, y))\n\n    def is_in_range(center, radius, point):\n        return (point[0] - center[0]) ** 2 + (point[1] - center[1]) ** 2 <= radius ** 2\n\n    def is_village_in_range(center, radius):\n        for village in villages:\n            if is_in_range(center, radius, (village[0], village[1])):\n                return True\n        return False\n\n    max_minions = 0\n    for radius in range(1, r + 1):\n        minions = 0\n        for minion in enemy_minions:\n            if is_in_range((0, 0), radius, minion):\n                if not is_village_in_range((0, 0), radius):\n                    minions += 1\n        max_minions = max(max_minions, minions)\n\n    return str(max_minions) "
    },
    {
        "number": 3077,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = list(map(int, stdin.readline().split()))\n    villages = []\n    for _ in range(n):\n        x, y, radius = list(map(int, stdin.readline().split()))\n        villages.append((x, y, radius))\n    enemies = []\n    for _ in range(m):\n        x, y = list(map(int, stdin.readline().split()))\n        enemies.append((x, y))\n\n    max_minions = 0\n    for x, y, radius in villages:\n        minions_in_range = sum(1 for mx, my in enemies if (x - mx) ** 2 + (y - my) ** 2 <= (radius - 1) ** 2)\n        max_minions = max(max_minions, minions_in_range)\n\n    return str(max_minions)"
    },
    {
        "number": 3077,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split()[:3])\n    villages = []\n    for _ in range(n):\n        villages.append(tuple(map(int, stdin.split()[3:6])))\n        stdin = stdin[stdin.find('\\n') + 1:]\n\n    minions = [tuple(map(int, stdin.split()[i:i + 2])) for i in range(0, m * 2, 2)]\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def is_safe(center, radius, village):\n        return distance(center, village) + radius <= village[2]\n\n    def count_minions(center, radius):\n        return sum(distance(center, minion) <= radius for minion in minions)\n\n    result = 0\n    for village in villages:\n        for radius in range(r - village[2], -1, -1):\n            if any(is_safe(village[:2], radius, v) for v in villages):\n                break\n            result = max(result, count_minions(village[:2], radius))\n    return str(result)"
    },
    {
        "number": 3078,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.readline().split())\n    A = [int(x) for x in stdin.readlines()]\n\n    dp = [0] * N\n    for i in range(1, N):\n        if sum(A[:i]) <= S:\n            dp[i] = i\n        elif sum(A[i:]) <= S:\n            dp[i] = N - i\n        for j in range(i):\n            if sum(A[j:i]) <= S:\n                dp[i] = max(dp[i], i - j)\n\n    return '\\n'.join(map(str, dp))"
    },
    {
        "number": 3078,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, S = map(int, lines[0].split())\n    A = list(map(int, lines[1:]))\n    dp = [[0] * 2001 for _ in range(N)]\n    result = []\n\n    for i in range(N):\n        dp[i][A[i]] = 1\n\n    for i in range(N - 1):\n        for j in range(S):\n            if dp[i][j] > 0:\n                k = min(j + A[i + 1], S)\n                dp[i + 1][k] = max(dp[i + 1][k], dp[i][j] + 1)\n\n    for i in range(N):\n        if A[i] > S:\n            result.append(0)\n        else:\n            k = S - A[i]\n            answer = 0\n            for j in range(k, -1, -1):\n                if dp[i][j] > 0:\n                    answer = max(answer, dp[i][j])\n            result.append(answer)\n\n    return '\\n'.join(map(str, result)) + '\\n'"
    },
    {
        "number": 3078,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, S = map(int, lines[0].split())\n    A = [int(line) for line in lines[1:]]\n    \n    dp = [0] * N\n    for i in range(N):\n        if A[i] > S:\n            continue\n        for j in range(i + 1, N):\n            if A[j] > S:\n                continue\n            k = j - i\n            if A[i] + A[j] > S:\n                continue\n            if k % 2 == 0:\n                if dp[i] >= k // 2:\n                    dp[j] = k // 2 + 1\n            else:\n                if dp[i] >= k // 2 + 1:\n                    dp[j] = k // 2 + 2\n    \n    return '\\n'.join(map(str, dp))"
    },
    {
        "number": 3078,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def longest_interesting_subsequence(arr: List[int], n: int, k: int, s: int) -> int:\n        dp = [0] * (n + 1)\n        dp[n] = 1\n\n        for i in range(n - 1, -1, -1):\n            dp[i] = 1\n            for j in range(i + 1, n + 1):\n                if abs(sum(arr[i:j])) <= s and j - i <= 2 * k:\n                    dp[i] = max(dp[i], dp[j])\n\n        return dp[0]\n\n    lines = stdin.splitlines()\n    N, S = map(int, lines[0].split())\n    A = [int(line) for line in lines[1:]]\n\n    result = []\n    for i in range(N):\n        left_sum = sum(A[:i + 1])\n        right_sum = S - left_sum\n        left_k = min(i + 1, left_sum)\n        right_k = min(N - i - 1, right_sum)\n\n        if left_k + right_k <= S:\n            result.append(longest_interesting_subsequence(A, N, min(left_k, right_k), S))\n        else:\n            result.append(0)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3078,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, S = map(int, lines[0].split())\n    A = list(map(int, lines[1:]))\n    ans = []\n    \n    for i in range(N):\n        left_sum = A[i]\n        right_sum = sum(A[i+1:])\n        k = 0\n        \n        while k < i and left_sum + A[k] <= S:\n            left_sum += A[k]\n            k += 1\n            \n        j = i + 1\n        while j < N and right_sum + A[j] <= S:\n            right_sum += A[j]\n            j += 1\n        \n        if k + j - i <= N and left_sum + right_sum <= S:\n            ans.append(k + j - i)\n        else:\n            ans.append(0)\n    \n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3078,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N, S = map(int, lines[0].split())\n    A = [int(line) for line in lines[1:]]\n\n    def longest_interesting_subsequence(start: int) -> int:\n        left_sum = [0] * N\n        right_sum = [0] * N\n        left_sum[start] = A[start]\n        right_sum[start] = A[start]\n\n        for i in range(start + 1, N):\n            left_sum[i] = max(left_sum[i - 1] + A[i], A[i])\n            right_sum[N - i - 1] = max(right_sum[N - i] + A[N - i - 1], A[N - i - 1])\n\n        for i in range(start, N):\n            if left_sum[i] <= S and right_sum[i] <= S:\n                return i - start + 1\n        return 0\n\n    result = []\n    for i in range(N):\n        result.append(longest_interesting_subsequence(i))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3078,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.readline().split())\n    A = [int(x) for x in stdin.readlines()]\n    dp = [0] * N\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if sum(A[i:j]) <= S:\n                dp[i] = max(dp[i], j - i)\n\n    for i in range(N - 2, -1, -1):\n        if sum(A[i:i + dp[i]]) > S:\n            dp[i] = min(dp[i + 1], N - i - 1)\n\n    return \"\\n\".join(str(x) for x in dp)\n"
    },
    {
        "number": 3078,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def longest_interesting_subsequence(k: int, s: int) -> int:\n        a = [0] * (2 * k + 1)\n        for i in range(k, 2 * k):\n            a[i] = 1\n        for i in range(2 * k, len(s)):\n            a[i] = a[i - k] + 1\n            if s[i] > s[i - k]:\n                break\n        else:\n            return 2 * k\n        for i in range(k - 1, -1, -1):\n            if s[i] <= s[i + k] - s[i]:\n                return i + k\n        return 0\n\n    lines = stdin.splitlines()\n    N, S = map(int, lines[0].split())\n    A = [int(line) for line in lines[1:]]\n\n    result = []\n    for i in range(N):\n        s = A[i:i + 2 * S]\n        result.append(longest_interesting_subsequence(S, s))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3078,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.readline().split())\n    A = [int(x) for x in stdin.readlines()]\n    dp = [0] * N\n    for i in range(N):\n        dp[i] = A[i]\n        for j in range(i):\n            if A[i] < A[j]:\n                dp[i] = max(dp[i], dp[j] + A[i])\n    res = [0] * N\n    for i in range(N - 1, -1, -1):\n        res[i] = dp[i]\n        for j in range(i + 1, N):\n            if A[i] < A[j]:\n                res[i] = max(res[i], res[j] + A[i])\n    return \"\\n\".join(str(S - x) for x in res) "
    },
    {
        "number": 3078,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_interesting(seq: List[int], k: int, s: int) -> bool:\n        if len(seq) != 2 * k:\n            return False\n        return seq[:k].sum() <= s and seq[-k:].sum() <= s\n\n    lines = stdin.split('\\n')\n    n, s = map(int, lines[0].split())\n    a = list(map(int, lines[1:n + 1]))\n\n    result = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_interesting(a[i:j], (j - i) // 2, s):\n                result.append((j - i, i))\n\n    longest_subseq = [0] * n\n    for length, start in result:\n        if length > longest_subseq[start]:\n            longest_subseq[start] = length\n\n    for i in range(1, n):\n        longest_subseq[i] = max(longest_subseq[i], longest_subseq[i - 1])\n\n    return '\\n'.join(map(str, longest_subseq)) + '\\n'"
    },
    {
        "number": 3079,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    letter_sequence = sorted(stdin.split('\\n')[1])\n\n    if n % 2 != 0:\n        return \"NE\"\n\n    slavko_word = \"\"\n    for i in range(n // 2):\n        slavko_word += letter_sequence.pop()\n\n    return \"DA\\n\" + slavko_word "
    },
    {
        "number": 3079,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    letters = sorted(stdin.readline().strip())\n\n    if n % 2 == 0:\n        return \"DA\\n\" + ''.join(letters)\n    else:\n        return \"DA\\n\" + ''.join(letters[:-1]) + letters[-1]\n\ndef"
    },
    {
        "number": 3079,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_most_beautiful_word(seq: str) -> str:\n        sorted_seq = sorted(seq)\n        return ''.join(sorted_seq)\n\n    def can_slavko_win(seq: str) -> bool:\n        return seq != ''.join(sorted(seq))\n\n    N, seq = stdin.strip().split('\\n')\n    N = int(N)\n\n    if can_slavko_win(seq):\n        return \"DA\\n\" + find_most_beautiful_word(seq)\n    else:\n        return \"NE\\n\" + seq[0]"
    },
    {
        "number": 3079,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    letter_sequence = sorted(stdin.split('\\n')[1])\n\n    if n % 2 != 0:\n        return \"NE\\n\" + letter_sequence[0]\n\n    most_beautiful_word = \"\"\n    for i in range(n - 1, -1, -1):\n        most_beautiful_word += letter_sequence[i]\n\n    return \"DA\\n\" + most_beautiful_word[::-1]"
    },
    {
        "number": 3079,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = stdin.split(\"\\n\")\n    N = int(N)\n\n    if N % 2 == 0:\n        return \"DA\\n\" + \"\".join(sorted(sequence))\n    else:\n        return \"NE\\n\" + \"\".join(sorted(sequence))"
    },
    {
        "number": 3079,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    letters = sorted(stdin.split('\\n')[1])\n\n    if n % 2 == 0:\n        return \"NE\\n\"\n\n    word = \"\"\n    for i in range(n - 1, -1, -1):\n        word += letters[i]\n\n    return \"DA\\n\" + word"
    },
    {
        "number": 3079,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    seq = sorted(stdin.split('\\n')[1])\n    if n == 2:\n        return \"DA\\n\" + seq[1] + seq[0]\n    elif n % 2 == 0:\n        return \"DA\\n\" + ''.join(seq[n//2:]) + ''.join(seq[:n//2])\n    else:\n        return \"DA\\n\" + ''.join(seq[n//2+1:]) + seq[n//2] + ''.join(seq[:n//2])"
    },
    {
        "number": 3079,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    letters = sorted(stdin.readline().strip())\n\n    if n % 2 == 0:\n        return \"NE\\n\"\n\n    slavko_word = \"\"\n    for i in range(n - 1, -1, -1):\n        slavko_word += letters[i]\n\n    return \"DA\\n\" + slavko_word"
    },
    {
        "number": 3079,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    seq = stdin.readline().strip()\n\n    if n == 2:\n        return \"DA\" if seq[0] == seq[1] else \"NE\"\n\n    slavko_score = seq[::-1]\n    for i in range(1, n - 1):\n        if seq[i] > seq[-1]:\n            slavko_score = seq[i] + slavko_score[1:]\n        else:\n            slavko_score = slavko_score[0] + seq[-1] + slavko_score[2:]\n\n    if slavko_score == seq:\n        return \"NE\"\n    else:\n        return \"DA\" + \"\\n\" + slavko_score[::-1]"
    },
    {
        "number": 3079,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, letters = stdin.split(\"\\n\")\n    n = int(n)\n\n    if n % 2 != 0:\n        return \"NE\\n\"\n\n    letters = sorted(letters)\n    slavko_word = letters[-1] if n > 1 else \"\"\n    mirko_word = letters[-2] if n > 1 else \"\"\n\n    for i in range(n - 2, -1, -1):\n        if i % 2 == 0:\n            slavko_word += letters[i]\n        else:\n            mirko_word += letters[i]\n\n    if slavko_word == mirko_word:\n        return \"NE\\n\"\n    elif slavko_word > mirko_word:\n        return \"DA\\n\" + slavko_word\n    else:\n        return \"NE\\n\" + slavko_word\n\n\nstdin = \"4\\nkava\"\nprint(solution(stdin)) "
    },
    {
        "number": 3080,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_sequence(runs, start, end, sequence):\n        if start == end:\n            return True\n        for run in runs:\n            if run[0] == start and run[1] == end:\n                return True\n        for run in runs:\n            if run[0] == start:\n                new_sequence = sequence.copy()\n                if run[1] in new_sequence:\n                    new_sequence.remove(run[1])\n                else:\n                    continue\n                if is_valid_sequence(runs, run[1], end, new_sequence):\n                    return True\n        return False\n\n    def count_ways(runs, k, areas):\n        return sum(1 for perm in itertools.permutations(areas) if all(is_valid_sequence(runs, 1, area, set(areas)) for area in perm[:k]))\n\n    lines = stdin.strip().split('\\n')\n    n, m, q = map(int, lines[0].split())\n    runs = [tuple(map(int, line.split())) for line in lines[1:m + 1]]\n    queries = [list(map(int, line.split())) for line in lines[m + 1:]]\n\n    result = []\n    for query in queries:\n        k, a = query[0], query[1]\n        areas = query[2:]\n        result.append(count_ways(runs, k, areas))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3080,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x, visited, adj):\n        if visited[x]:\n            return False\n        visited[x] = True\n        for y in adj[x]:\n            if not dfs(y, visited, adj):\n                return False\n        return True\n\n    def is_connected(x, y, visited, adj):\n        for i in range(1, n + 1):\n            visited[i] = False\n        return dfs(x, visited, adj) and dfs(y, visited, adj)\n\n    def count_ways(k, areas):\n        count = 0\n        for i in range(2**k):\n            snack_stops = []\n            for j in range(k):\n                if i & (1 << j):\n                    snack_stops.append(j + 1)\n            valid = True\n            for area in areas:\n                found = False\n                for snack_stop in snack_stops:\n                    if is_connected(snack_stop, area, visited, adj):\n                        found = True\n                        break\n                if not found:\n                    valid = False\n                    break\n            if valid:\n                count += 1\n        return count\n\n    n, m, q = map(int, stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        adj[x].append(y)\n        adj[y].append(x)\n\n    output = []\n    for _ in range(q):\n        k, a = map(int, stdin.readline().split())\n        areas = list(map(int, stdin.readline().split()))\n        output.append(count_ways(k, areas))\n\n    return '\\n'.join(map(str, output)) + '\\n' "
    },
    {
        "number": 3080,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x, visited, graph):\n        if visited[x]:\n            return\n        visited[x] = True\n        for y in graph[x]:\n            dfs(y, visited, graph)\n\n    def count_ways(n, k, query):\n        graph = [[] for _ in range(n + 1)]\n        for x, y in runs:\n            graph[x].append(y)\n            graph[y].append(x)\n\n        snack_stands = [False] * (n + 1)\n        for stand in query:\n            snack_stands[stand] = True\n\n        total_ways = 0\n        for i in range(1, n + 1):\n            visited = [False] * (n + 1)\n            dfs(i, visited, graph)\n            count = sum(visited[1:])\n            if visited[i] and count == k:\n                total_ways += 1\n        return total_ways\n\n    lines = stdin.strip().split('\\n')\n    n, m, q = map(int, lines[0].split())\n    runs = [tuple(map(int, line.split())) for line in lines[1:m + 1]]\n    queries = [list(map(int, line.split())) for line in lines[m + 1:m + 1 + q]]\n\n    results = []\n    for query in queries:\n        k, a = query[0], query[1]\n        query_set = query[2:]\n        result = count_ways(n, k, query_set)\n        results.append(result)\n\n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 3080,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x, depth):\n        vis[x] = True\n        for y in graph[x]:\n            if not vis[y]:\n                dfs(y, depth + 1)\n        return depth\n\n    def check(query, k, q):\n        cnt = 0\n        for i in range(1, n + 1):\n            if i not in query:\n                continue\n            for j in range(1, n + 1):\n                if j not in query:\n                    continue\n                if i == j:\n                    continue\n                for p1 in graph[i]:\n                    for p2 in graph[j]:\n                        if p1 == p2:\n                            cnt += 1\n                            break\n                    else:\n                        continue\n                    break\n            else:\n                continue\n            break\n        return cnt == k * q\n\n    def backtrack(query, k, q, idx, selected):\n        if idx == k:\n            return 1\n        if idx > k:\n            return 0\n        res = 0\n        for i in query:\n            if i in selected:\n                continue\n            selected.add(i)\n            res += backtrack(query, k, q, idx + 1, selected)\n            selected.remove(i)\n        return res\n\n    n, m, q = map(int, stdin.readline().split())\n    graph = {i: set() for i in range(1, n + 1)}\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        graph[x].add(y)\n        graph[y].add(x)\n\n    for _ in range(q):\n        k, a = map(int, stdin.readline().split())\n        query = set(map(int, stdin.readline().split()))\n        if check(query, k, a):\n            print(backtrack(query, k, a, 0, set()))\n        else:\n            print(0)\n\ndef"
    },
    {
        "number": 3080,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, start, end):\n        if start == end:\n            return 1\n        visited[start] = True\n        result = 0\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                result += dfs(graph, visited, neighbor, end)\n        visited[start] = False\n        return result\n\n    def build_graph(runs):\n        graph = {i: [] for i in range(1, len(runs) + 2)}\n        for x, y in runs:\n            graph[x].append(y)\n            graph[y].append(x)\n        return graph\n\n    def count_ways(query, k, available_stations, graph, favorite_areas):\n        count = 0\n        for i, area in enumerate(query):\n            count += dfs(graph, [False] * len(graph), 1, area)\n            favorite_areas[i] = [False] * len(graph)\n            favorite_areas[i][area] = True\n\n        for i in range(k):\n            for j, area in enumerate(query):\n                if not favorite_areas[j][area]:\n                    available_stations[area] += 1\n\n        for i, area in enumerate(query):\n            if not favorite_areas[i][area]:\n                count += dfs(graph, [False] * len(graph), 1, area)\n\n        for i in range(k):\n            for j, area in enumerate(query):\n                if not favorite_areas[j][area]:\n                    available_stations[area] -= 1\n\n        return count\n\n    lines = stdin.split('\\n')\n    n, m, q = map(int, lines[0].split())\n    runs = [list(map(int, line.split())) for line in lines[1:m + 1]]\n    graph = build_graph(runs)\n    queries = [list(map(int, line.split())) for line in lines[m + 1:m + 1 + q]]\n    results = []\n\n    for query in queries:\n        k, a = query[0], query[1]\n        favorite_areas = [False] * len(query)\n        available_stations = [0] * (n + 1)\n        result = count_ways(query[2:], k, available_stations, graph, favorite_areas)\n        results.append(result)\n\n    return '\\n'.join(map(str, results)) + '\\n' "
    },
    {
        "number": 3080,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected(u, v, graph):\n        visited = [False] * (n + 1)\n        q = [u]\n        visited[u] = True\n\n        while q:\n            u = q.pop(0)\n            for neighbor in graph[u]:\n                if not visited[neighbor]:\n                    if neighbor == v:\n                        return True\n                    q.append(neighbor)\n                    visited[neighbor] = True\n\n        return False\n\n    def count_ways(k, areas):\n        count = 0\n        for bits in range(1 << len(areas)):\n            selected_areas = [areas[i] for i in range(len(areas)) if bits & (1 << i)]\n            if len(selected_areas) == k and all(is_connected(1, area, graph) for area in selected_areas):\n                count += 1\n        return count\n\n    n, m, q = map(int, stdin.readline().split())\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        graph[x].append(y)\n\n    output = []\n    for _ in range(q):\n        k, a = map(int, stdin.readline().split())\n        areas = list(map(int, stdin.readline().split()))\n        output.append(count_ways(k, areas))\n\n    return \"\\n\".join(map(str, output))"
    },
    {
        "number": 3080,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def build_graph(runs):\n        graph = {i: [] for i in range(1, n + 1)}\n        for x, y in runs:\n            graph[x].append(y)\n        return graph\n\n    def bfs(graph, k, areas):\n        visited = {area: False for area in areas}\n        queue = [(1, set())]\n        count = 0\n\n        while queue:\n            area, stands = queue.pop(0)\n            if not visited[area]:\n                visited[area] = True\n                if len(stands | {area}) == k:\n                    count += 1\n                else:\n                    for neighbor in graph[area]:\n                        if not visited[neighbor]:\n                            queue.append((neighbor, stands | {area}))\n\n        return count\n\n    n, m, q = map(int, stdin.readline().split())\n    runs = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    graph = build_graph(runs)\n\n    result = []\n    for _ in range(q):\n        k, a = map(int, stdin.readline().split())\n        areas = list(map(int, stdin.readline().split()))\n        result.append(bfs(graph, k, areas))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3080,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, target, visited, graph):\n        if start == target:\n            return 1\n        visited[start] = True\n        result = 0\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                result += dfs(neighbor, target, visited, graph)\n        return result\n\n    def count_ways(k, query, n, graph):\n        count = 0\n        for snack_stand in range(1, n + 1):\n            if snack_stand in query:\n                continue\n            visited = [False] * (n + 1)\n            count += dfs(1, snack_stand, visited, graph)\n        return count\n\n    lines = stdin.split(\"\\n\")\n    n, m, q = map(int, lines[0].split())\n    graph = {i: [] for i in range(1, n + 1)}\n    for i in range(m):\n        x, y = map(int, lines[i + 1].split())\n        graph[x].append(y)\n        graph[y].append(x)\n\n    result = []\n    for i in range(q):\n        k, a = map(int, lines[i + m + 1].split()[:2])\n        query = set(map(int, lines[i + m + 1].split()[2:]))\n        result.append(count_ways(k, query, n, graph))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3080,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def check_conditions(query_set, k, favorite_snack, snack_stands):\n        possible_ways = 0\n        for i in range(1, len(query_set) + 1):\n            for comb in itertools.combinations(query_set, i):\n                if len(comb) == k:\n                    valid = True\n                    for area in comb:\n                        if not snack_stands[area].count(favorite_snack):\n                            valid = False\n                            break\n                    if valid:\n                        possible_ways += 1\n        return possible_ways\n\n    def bfs(start, target, graph):\n        visited = [False] * (n + 1)\n        queue = collections.deque([(start, \"\")])\n        while queue:\n            node, path = queue.popleft()\n            if node == target:\n                return path\n            if not visited[node]:\n                visited[node] = True\n                for neighbor in graph[node]:\n                    queue.append((neighbor, path + f\"{node}-\"))\n        return None\n\n    def construct_graph(runs):\n        graph = collections.defaultdict(set)\n        for x, y in runs:\n            graph[x].add(y)\n            graph[y].add(x)\n        return graph\n\n    input_data = stdin.split(\"\\n\")\n    n, m, q = map(int, input_data[0].split())\n    runs = [tuple(map(int, line.split())) for line in input_data[1:m + 1]]\n    queries = [line.split() for line in input_data[m + 1:]]\n\n    graph = construct_graph(runs)\n\n    snack_stands = {area: set() for area in range(1, n + 1)}\n    for i, line in enumerate(input_data[1 + m:]):\n        k, a, *areas = map(int, line.split())\n        areas = set(areas)\n        for area in areas:\n            path = bfs(1, area, graph)\n            snack_stands[area].add(i)\n\n    for i, line in enumerate(input_data[1 + m:]):\n        k, a, *areas = map(int, line.split())\n        areas = set(areas)\n        print(check_conditions(areas, k, i, snack_stands))"
    },
    {
        "number": 3080,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_sequence(sequence):\n        return all(x + 1 in sequence for x in sequence if x + 1 <= n)\n\n    def count_valid_sequences(query_set, k):\n        valid_sequences = []\n        for sequence in itertools.combinations(query_set, k):\n            if is_valid_sequence(sequence):\n                valid_sequences.append(sequence)\n        return len(valid_sequences)\n\n    def process_query(query):\n        k, *query_set = query\n        return count_valid_sequences(query_set, k)\n\n    lines = stdin.splitlines()\n    n, m, q = map(int, lines[0].split())\n    runs = [tuple(map(int, line.split())) for line in lines[1:1 + m]]\n    queries = [list(map(int, line.split())) for line in lines[1 + m:]]\n\n    for query in queries:\n        print(process_query(query))"
    },
    {
        "number": 3081,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = [False] * len(graph)\n        weights = [float('inf')] * len(graph)\n        weights[start] = 0\n        path = []\n\n        while not visited[end]:\n            min_weight = float('inf')\n            min_index = -1\n            for i in range(len(graph)):\n                if not visited[i] and weights[i] < min_weight:\n                    min_weight = weights[i]\n                    min_index = i\n\n            if min_index == -1:\n                break\n\n            path.append(min_index)\n            visited[min_index] = True\n\n            for i in range(len(graph)):\n                weight = weights[min_index] + graph[min_index][i]\n                if not visited[i] and weight < weights[i]:\n                    weights[i] = weight\n\n        return weights[end]\n\n    lines = stdin.strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    inspection_times = list(map(int, lines[1].split()))\n    flights = [list(map(int, line.split())) for line in lines[2:n+2]]\n    requests = [list(map(int, line.split())) for line in lines[n+2:]]\n\n    graph = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                graph[i][j] = flights[i][j]\n\n    total_time = 0\n    for s, f, t in requests:\n        time = dijkstra(graph, s - 1, f - 1) + inspection_times[s - 1]\n        if time > t:\n            total_time += time - t\n\n    return total_time "
    },
    {
        "number": 3081,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def read_line() -> list:\n        return list(map(int, stdin.readline().strip().split()))\n\n    n, m = read_line()\n    inspection_times = read_line()\n    flight_times = [read_line() for _ in range(n)]\n    flights = [read_line() for _ in range(m)]\n\n    def get_flight_time(src, dst):\n        return flight_times[src][dst]\n\n    def can_fly(plane, src, dst, time):\n        if plane[src] and plane[src][-1] >= time and plane[dst] and plane[dst][0] >= time + get_flight_time(src, dst):\n            return True\n        return False\n\n    def add_flight(plane, src, dst, time):\n        plane[src].append(time + get_flight_time(src, dst))\n        plane[dst].append(time)\n\n    def find_min_planes(flights):\n        flights.sort(key=lambda x: x[2])\n        plane = {i: [0] for i in range(n)}\n        for s, f, t in flights:\n            if not can_fly(plane, s, f, t):\n                add_flight(plane, s, f, t)\n        return len(plane)\n\n    return str(find_min_planes(flights))"
    },
    {
        "number": 3081,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_planes(n, m, inspection_times, flight_times, flights):\n        # Initialize the graph and inspection times\n        graph = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    graph[i][j] = flight_times[i][j]\n        total_flight_time = sum(flight_times[i][j] for i, j, _ in flights)\n        min_planes = total_flight_time // min(inspection_times) + 1\n\n        while True:\n            # Calculate the shortest path using Floyd-Warshall algorithm\n            for k in range(n):\n                for i in range(n):\n                    for j in range(n):\n                        if i != j:\n                            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\n\n            # Check if the minimum number of planes is sufficient\n            if all(graph[s - 1][f - 1] <= t for s, f, t in flights):\n                return min_planes\n\n            # Add an unscheduled flight to reduce the number of planes\n            min_inspection_time = min(inspection_times)\n            min_inspection_airport = inspection_times.index(min_inspection_time)\n            min_flight_time = min(flight_times[min_inspection_airport][i] for i in range(n) if i != min_inspection_airport)\n            min_flight_airport1 = flight_times[min_inspection_airport].index(min_flight_time)\n            min_flight_airport2 = flight_times[min_flight_airport1][min_inspection_airport]\n\n            graph[min_inspection_airport][min_flight_airport1] = min_flight_time\n            graph[min_flight_airport1][min_inspection_airport] = min_flight_time\n\n            min_planes += 1\n\n    stdin_list = stdin.split('\\n')\n    n, m = map(int, stdin_list[0].split())\n    inspection_times = list(map(int, stdin_list[1].split()))\n    flight_times = [list(map(int, stdin_list[i + 2].split())) for i in range(n)]\n    flights = [list(map(int, stdin_list[i + 2 + n].split())) for i in range(m)]\n\n    return str(find_min_planes(n, m, inspection_times, flight_times, flights))"
    },
    {
        "number": 3081,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_planes(n, m, inspection_time, flights, scheduled_flights):\n        def min_flight_time(src, dest, time):\n            if src == dest:\n                return 0\n            return flights[src][dest]\n\n        def check_schedule(schedule):\n            current_time = 0\n            for flight in schedule:\n                if current_time + min_flight_time(flight[0], flight[1], flight[2]) > flight[3]:\n                    return False\n                current_time += min_flight_time(flight[0], flight[1], flight[2])\n                current_time += inspection_time[flight[1]]\n            return True\n\n        def schedule_flights(min_planes):\n            planes = [[] for _ in range(min_planes)]\n            for flight in scheduled_flights:\n                for plane in planes:\n                    if check_schedule(plane + [flight]):\n                        plane.append(flight)\n                        break\n                else:\n                    planes.append([flight])\n            return planes\n\n        min_planes = 1\n        while True:\n            planes = schedule_flights(min_planes)\n            if all(check_schedule(plane) for plane in planes):\n                return min_planes\n            min_planes += 1\n\n    lines = stdin.strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    inspection_time = list(map(int, lines[1].split()))\n    flights = [list(map(int, lines[i + 2].split())) for i in range(n)]\n    scheduled_flights = [list(map(int, lines[i + n + 2].split())) for i in range(m)]\n\n    return str(find_min_planes(n, m, inspection_time, flights, scheduled_flights))"
    },
    {
        "number": 3081,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = [False] * len(graph)\n        weights = [float('inf')] * len(graph)\n        weights[start - 1] = 0\n        heap = [(0, start)]\n\n        while heap:\n            current_weight, current_node = heapq.heappop(heap)\n            if current_node == end:\n                return current_weight\n            if not visited[current_node - 1]:\n                visited[current_node - 1] = True\n                for neighbor, weight in enumerate(graph[current_node - 1]):\n                    if weight != float('inf') and not visited[neighbor]:\n                        new_weight = current_weight + weight\n                        if new_weight < weights[neighbor]:\n                            weights[neighbor] = new_weight\n                            heapq.heappush(heap, (new_weight, neighbor + 1))\n        return weights[end - 1]\n\n    def find_min_planes(n, m, inspection_times, flights, requests):\n        airports = [{} for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    airports[i][j] = flights[i][j]\n                    airports[j][i] = flights[j][i]\n\n        min_planes = float('inf')\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    inspection_time = inspection_times[i]\n                    time_to_fly = dijkstra(airports, i + 1, j + 1)\n                    total_time = inspection_time + time_to_fly\n                    planes_needed = sum(1 for _, _, t in requests if t <= total_time)\n                    min_planes = min(min_planes, planes_needed)\n\n        return min_planes\n\n    input_data = list(map(lambda x: x.split(), stdin.split('\\n')))\n    n, m = map(int, input_data[0])\n    inspection_times = list(map(int, input_data[1]))\n    flights = [list(map(int, input_data[i + 2])) for i in range(n)]\n    requests = [list(map(int, input_data[i + n + 2])) for i in range(m)]\n\n    return str(find_min_planes(n, m, inspection_times, flights, requests))"
    },
    {
        "number": 3081,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = [False] * len(graph)\n        weights = [float('inf')] * len(graph)\n        weights[start] = 0\n        min_weight = float('inf')\n        min_index = -1\n        for i in range(len(graph)):\n            for j in range(len(graph)):\n                if not visited[j] and weights[j] < weights[min_index]:\n                    min_index = j\n            if min_index == end:\n                break\n            visited[min_index] = True\n            min_weight = float('inf')\n            min_index = -1\n            for k in range(len(graph)):\n                if not visited[k] and graph[min_index][k] != 0 and weights[min_index] + graph[min_index][k] < weights[k]:\n                    weights[k] = weights[min_index] + graph[min_index][k]\n        return weights[end]\n\n    def is_valid_inspection_time(graph, flights, inspection_time):\n        for flight in flights:\n            s, f, t = flight\n            time_to_fly = dijkstra(graph, s - 1, f - 1)\n            if t < inspection_time[s - 1] + time_to_fly:\n                return False\n        return True\n\n    n, m = map(int, stdin.readline().split())\n    inspection_time = list(map(int, stdin.readline().split()))\n    graph = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    flights = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    left, right = 0, n * max(flights[-1][2], max([f[2] for f in flights]))\n    while left < right:\n        mid = (left + right) // 2\n        if is_valid_inspection_time(graph, flights, [mid] * n):\n            right = mid\n        else:\n            left = mid + 1\n\n    return str(left)"
    },
    {
        "number": 3081,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        queue = []\n        visited = [False] * len(graph)\n        weights = [float('inf')] * len(graph)\n        weights[start] = 0\n        queue.append((0, start))\n\n        while queue:\n            current_weight, current_node = heapq.heappop(queue)\n            if current_node == end:\n                return current_weight\n            if not visited[current_node]:\n                visited[current_node] = True\n                for neighbor, weight in enumerate(graph[current_node]):\n                    if weight != float('inf'):\n                        new_weight = current_weight + weight\n                        if new_weight < weights[neighbor]:\n                            weights[neighbor] = new_weight\n                            heapq.heappush(queue, (new_weight, neighbor))\n        return float('inf')\n\n    def is_valid(flights, inspection_time, graph):\n        for i in range(len(flights)):\n            s, f, t = flights[i]\n            if inspection_time[s] > t:\n                return False\n            time_needed = t + inspection_time[s] + inspection_time[f]\n            if dijkstra(graph, s, f) + time_needed > flights[i][2]:\n                return False\n        return True\n\n    def binary_search(flights, inspection_time, graph):\n        left, right = 0, 10**10\n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(flights, inspection_time, graph, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    n, m = map(int, stdin.readline().split())\n    inspection_time = list(map(int, stdin.readline().split()))\n    graph = []\n    for _ in range(n):\n        graph.append(list(map(int, stdin.readline().split())))\n    flights = []\n    for _ in range(m):\n        s, f, t = map(int, stdin.readline().split())\n        flights.append((s - 1, f - 1, t))\n\n    result = binary_search(flights, inspection_time, graph)\n    return str(result)"
    },
    {
        "number": 3081,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_planes(n, m, inspection_times, flights, schedules):\n        def dijkstra(graph, start):\n            visited = [False] * n\n            weights = [float('inf')] * n\n            weights[start] = 0\n            min_heap = []\n            for i in range(n):\n                heappush(min_heap, (weights[i], i))\n            while min_heap:\n                weight, node = heappop(min_heap)\n                if not visited[node]:\n                    visited[node] = True\n                    for neighbor, distance in graph[node]:\n                        if not visited[neighbor] and weight + distance < weights[neighbor]:\n                            weights[neighbor] = weight + distance\n                            heappush(min_heap, (weights[neighbor], neighbor))\n            return weights\n\n        flights_graph = [[] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    flights_graph[i].append((j, flights[i][j]))\n\n        min_planes = float('inf')\n        for schedule in schedules:\n            s, f, t = schedule\n            time_taken = dijkstra(flights_graph, s)[f]\n            if time_taken == float('inf'):\n                continue\n            planes_needed = ceil((t + time_taken) / (inspection_times[s] + flights[s][f]))\n            min_planes = min(min_planes, planes_needed)\n\n        return min_planes\n\n    stdin_list = stdin.split('\\n')\n    n, m = map(int, stdin_list[0].split())\n    inspection_times = list(map(int, stdin_list[1].split()))\n    flights = [list(map(int, stdin_list[i + 2].split())) for i in range(n)]\n    schedules = [list(map(int, stdin_list[i + n + 2].split())) for i in range(m)]\n\n    return str(find_min_planes(n, m, inspection_times, flights, schedules))"
    },
    {
        "number": 3081,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_planes(flights, n, m):\n        for i in range(n):\n            for j in range(n):\n                if i != j and flights[i][j] == 0:\n                    return \"IMPOSSIBLE\"\n\n        required_planes = m\n        available_planes = n\n\n        while required_planes > available_planes:\n            required_planes = 0\n            for i in range(n):\n                outgoing_flights = 0\n                for j in range(n):\n                    if i != j and flights[i][j] > 0:\n                        outgoing_flights += 1\n                if outgoing_flights > 0:\n                    required_planes += 1\n            available_planes += 1\n\n        return available_planes\n\n    def process_input(stdin: str):\n        lines = stdin.split(\"\\n\")\n        n, m = map(int, lines[0].split())\n        inspection_times = list(map(int, lines[1].split()))\n        flight_times = [list(map(int, lines[i + 2].split())) for i in range(n)]\n        flights = [list(map(int, lines[i + n + 2].split())) for i in range(m)]\n\n        return n, m, inspection_times, flight_times, flights\n\n    n, m, inspection_times, flight_times, flights = process_input(stdin)\n    result = find_min_planes(flight_times, n, m)\n\n    return str(result) "
    },
    {
        "number": 3081,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_planes(n, m, inspection_times, flight_times, flights):\n        def find_shortest_path(graph, start, end, visited, current_time):\n            if start == end:\n                return 0\n            visited.add(start)\n            min_time = float('inf')\n            for i, time in enumerate(graph[start]):\n                if time != -1 and i not in visited:\n                    new_time = find_shortest_path(graph, i, end, visited, current_time + time)\n                    if new_time != -1:\n                        min_time = min(min_time, new_time)\n            return min_time if min_time != float('inf') else -1\n\n        def get_flight_time(start, end):\n            return flight_times[start][end]\n\n        def get_inspection_time(airport):\n            return inspection_times[airport]\n\n        def get_flight_end_time(flight):\n            return flight[2] + get_flight_time(flight[0] - 1, flight[1] - 1)\n\n        def is_valid_flight(flight1, flight2):\n            return flight1[0] == flight2[1] and flight1[2] <= flight2[2]\n\n        def is_valid_flight_path(flight, path):\n            return path[-1][1] == flight[0] and path[-1][2] <= flight[2] - get_flight_time(path[-1][1] - 1, path[-1][0] - 1)\n\n        def get_flight_path(flight, path):\n            return path + [(flight[0], flight[1], get_flight_end_time(flight))]\n\n        def find_min_planes_helper(flights, index, current_time, current_path, min_planes):\n            if index == len(flights):\n                min_planes[0] = min(min_planes[0], len(current_path))\n                return\n\n            start_airport = flights[index][0]\n            end_airport = flights[index][1]\n            start_time = flights[index][2]\n\n            graph = [[-1] * n for _ in range(n)]\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        graph[i][j] = get_flight_time(i, j)\n\n            inspection_time = get_inspection_time(start_airport)\n\n            new_flights = [flight for flight in flights[index + 1:] if is_valid_flight(flight, flights[index])]\n            new_path = get_flight_path(flights[index], current_path)\n\n            min_planes_with_flight = float('inf')\n            min_planes_without_flight = float('inf')\n\n            if start_time + inspection_time <= current_time:\n                min_planes_without_flight = find_min_planes_helper(flights, index + 1, current_time, current_path, min_planes)\n\n            if start_time + inspection_time + get_flight_time(start_airport, end_airport) <= current_time:\n                new_current_time = current_time + get_flight_time(start_airport, end_airport)\n                min_planes_with_flight = find_min_planes_helper(new_flights, 0, new_current_time, new_path, min_planes)\n\n            min_planes[0] = min(min_planes_with_flight, min_planes_without_flight, min_planes[0])\n\n        flights.sort(key=lambda x: x[2])\n        inspection_times = [0] + inspection_times\n        min_planes = [float('inf')]\n        find_min_planes_helper(flights, 0, 0, [], min_planes)\n        return min_planes[0]\n\n    stdin_list = std"
    },
    {
        "number": 3082,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def total_tastiness(dishes, dish_type, total_weight):\n        if dish_type == \"D\":\n            n = total_weight // dishes[1]\n            return sum(dishes[2] - (i - 1) * dishes[3] for i in range(1, n + 1))\n        else:\n            t, decay = dishes[1], dishes[2]\n            return (t - total_weight * decay) * total_weight\n\n    def max_tastiness(dishes, dish_types, total_weight):\n        max_tastiness = 0\n        for i in range(len(dishes)):\n            if dish_types[i] == \"D\":\n                n = total_weight // dishes[i][1]\n                if n > 0:\n                    t = total_tastiness(dishes[i], dish_types[i], n * dishes[i][1])\n                    max_tastiness += t\n                    total_weight -= n * dishes[i][1]\n            else:\n                t = total_tastiness(dishes[i], dish_types[i], total_weight)\n                max_tastiness += t\n                total_weight = 0\n                break\n        return max_tastiness\n\n    def main():\n        d, w = map(int, stdin.readline().split())\n        dishes = [None] * d\n        dish_types = [None] * d\n        for i in range(d):\n            dish = list(map(int, stdin.readline().split()[1:]))\n            dishes[i] = dish\n            dish_types[i] = stdin.readline()[0]\n\n        result = max_tastiness(dishes, dish_types, w)\n        if abs(result - int(result)) < 1e-6:\n            return str(int(result))\n        else:\n            return str(result)\n\n    return main()"
    },
    {
        "number": 3082,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def total_tastiness(dish_type, weight, t_i, d_t_i):\n        if dish_type == \"D\":\n            return sum(t_i - (n - 1) * d_t_i for n in range(1, weight // w_i + 1))\n        else:\n            return (t_i - weight * d_t_i) * weight\n\n    def max_tastiness(dishes, w):\n        max_tastiness_ = 0\n        for dish in dishes:\n            dish_type, weight, t_i, d_t_i = dish\n            max_tastiness_ += total_tastiness(dish_type, weight, t_i, d_t_i)\n        return max_tastiness_\n\n    def binary_search(dishes, target_weight):\n        left, right = 0, 10001\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if max_tastiness(dishes, mid) < target_weight:\n                left = mid\n            else:\n                right = mid\n        return right\n\n    d, w = map(int, stdin.readline().split())\n    dishes = [stdin.readline().split() for _ in range(d)]\n\n    if d == 0 or w == 0:\n        return \"impossible\"\n\n    result = binary_search(dishes, w)\n    return f\"{result:.10f}\""
    },
    {
        "number": 3082,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def tastiness(t, d, n, x):\n        return (t - n * d) * x\n\n    def discrete_tastiness(t, d, n):\n        return sum(tastiness(t, d, i, 1) for i in range(1, n + 1))\n\n    def continuous_tastiness(t, d, x):\n        return tastiness(t, d, 0, x)\n\n    d, w = map(int, stdin.readline().split())\n    dishes = []\n    for _ in range(d):\n        dish_type, *args = stdin.readline().split()\n        if dish_type == \"D\":\n            w_i, t_i, d_i = map(int, args)\n            dishes.append((\"D\", w_i, t_i, d_i))\n        else:\n            t_i, d_i = map(int, args)\n            dishes.append((\"C\", t_i, d_i))\n\n    max_tastiness = -1\n    for n1 in range(w // dishes[0][1] + 1):\n        for n2 in range(w // dishes[1][1] + 1):\n            if d == 2:\n                meal_tastiness = discrete_tastiness(dishes[0][2], dishes[0][3], n1) + discrete_tastiness(dishes[1][2], dishes[1][3], n2)\n                if w - n1 * dishes[0][1] - n2 * dishes[1][1] == 0:\n                    meal_weight = n1 * dishes[0][1] + n2 * dishes[1][1]\n                    max_tastiness = max(max_tastiness, meal_tastiness)\n            else:\n                for x3 in range(w - n1 * dishes[0][1] - n2 * dishes[1][1] + 1):\n                    meal_tastiness = discrete_tastiness(dishes[0][2], dishes[0][3], n1) + discrete_tastiness(dishes[1][2], dishes[1][3], n2) + continuous_tastiness(dishes[2][1], dishes[2][2], x3)\n                    if w - n1 * dishes[0][1] - n2 * dishes[1][1] - x3 == 0:\n                        meal_weight = n1 * dishes[0][1] + n2 * dishes[1][1] + x3\n                        max_tastiness = max(max_tastiness, meal_tastiness)\n\n    return \"impossible\" if max_tastiness == -1 else f\"{max_tastiness:.10f}\""
    },
    {
        "number": 3082,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, w = map(int, stdin.readline().split())\n    dishes = []\n    for _ in range(d):\n        dish_type, *params = stdin.readline().strip().split()\n        if dish_type == 'D':\n            dishes.append(DiscreteDish(*map(int, params)))\n        elif dish_type == 'C':\n            dishes.append(ContinuousDish(*map(int, params)))\n\n    def max_tastiness(weight, dishes):\n        if weight < 0:\n            return float('-inf')\n        if weight == 0:\n            return 0\n        if not dishes:\n            return float('-inf')\n\n        dish = dishes[0]\n        remaining_dishes = dishes[1:]\n\n        if isinstance(dish, DiscreteDish):\n            max_pieces = weight // dish.weight\n            tastiness = dish.tastiness * max_pieces\n            decay = dish.decay * max_pieces\n            return max(tastiness - decay, max_tastiness(weight % dish.weight, remaining_dishes))\n\n        elif isinstance(dish, ContinuousDish):\n            weight_eaten = min(weight, dish.max_weight)\n            tastiness = (dish.tastiness - dish.decay * weight_eaten) * weight_eaten\n            return max(tastiness, max_tastiness(weight - weight_eaten, remaining_dishes))\n\n    max_tastiness_value = max_tastiness(w, dishes)\n    if max_tastiness_value == 0 and w != 0:\n        return 'impossible'\n    return '{:.6f}'.format(max_tastiness_value)\n\n\nclass DiscreteDish:\n    def __init__(self, weight, tastiness, decay):\n        self.weight = weight\n        self.tastiness = tastiness\n        self.decay = decay\n\nclass ContinuousDish:\n    def __init__(self, tastiness, decay):\n        self.tastiness = tastiness\n        self.decay = decay\n        self.max_weight = 10000"
    },
    {
        "number": 3082,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d, w = map(int, stdin.readline().split())\n    dishes = []\n\n    for _ in range(d):\n        dish_type, *params = stdin.readline().split()\n        if dish_type == \"D\":\n            w_i, t_i, delta_t_i = map(int, params)\n            dishes.append((\"D\", w_i, t_i, delta_t_i))\n        elif dish_type == \"C\":\n            t_i, delta_t_i = map(int, params)\n            dishes.append((\"C\", t_i, delta_t_i))\n\n    def discrete_dish_tastiness(dish_index, pieces):\n        w_i, t_i, delta_t_i = dishes[dish_index][1:]\n        return sum(t_i - (n - 1) * delta_t_i for n in range(1, pieces + 1))\n\n    def continuous_dish_tastiness(dish_index, weight):\n        t_i, delta_t_i = dishes[dish_index][1:]\n        return (t_i - weight * delta_t_i) * weight\n\n    def max_tastiness(dish_index, weight):\n        dish_type, *params = dishes[dish_index]\n        if dish_type == \"D\":\n            w_i, t_i, delta_t_i = params\n            pieces = weight // w_i\n            return discrete_dish_tastiness(dish_index, pieces)\n        elif dish_type == \"C\":\n            t_i, delta_t_i = params\n            return continuous_dish_tastiness(dish_index, weight)\n\n    def brute_force(w):\n        max_tastiness_ = -1\n        for i in range(1, len(dishes) + 1):\n            for comb in itertools.combinations(range(len(dishes)), i):\n                weight = sum(dishes[j][1] for j in comb)\n                if weight == w:\n                    tastiness = sum(max_tastiness(j, w) for j in comb)\n                    max_tastiness_ = max(max_tastiness_, tastiness)\n        return max_tastiness_\n\n    max_tastiness_ = brute_force(w)\n\n    if max_tastiness_ == -1:\n        return \"impossible\"\n    else:\n        return format(max_tastiness_, \".10f\")"
    },
    {
        "number": 3082,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def eat_dish(dish_type, dish_weight, tastiness, decay, eaten_weight, eaten_items):\n        if dish_type == \"D\":\n            return (tastiness - (eaten_items - 1) * decay) * eaten_weight\n        else:\n            return (tastiness - eaten_weight * decay) * eaten_weight\n\n    def max_tastiness(dishes, total_weight, memo={}):\n        if total_weight == 0:\n            return 0\n        if total_weight < 0:\n            return float('-inf')\n        if (len(dishes), total_weight) in memo:\n            return memo[(len(dishes), total_weight)]\n\n        dish_type, dish_weight, tastiness, decay = dishes[-1]\n        if dish_type == \"D\":\n            max_items = total_weight // dish_weight\n        else:\n            max_items = total_weight\n\n        max_eaten = float('-inf')\n        for eaten_items in range(max_items + 1):\n            eaten_weight = eaten_items * dish_weight if dish_type == \"D\" else eaten_items\n            remaining_weight = total_weight - eaten_weight\n            remaining_dishes = dishes[:-1]\n\n            max_eaten = max(max_eaten, eat_dish(dish_type, dish_weight, tastiness, decay, eaten_weight, eaten_items) + max_tastiness(remaining_dishes, remaining_weight, memo))\n\n        memo[(len(dishes), total_weight)] = max_eaten\n        return max_eaten\n\n    d, w = map(int, stdin.readline().split())\n    dishes = []\n    for _ in range(d):\n        dish_type, *params = stdin.readline().split()\n        dishes.append([dish_type] + list(map(int, params)))\n\n    max_tastiness_value = max_tastiness(dishes, w)\n    return f\"{max_tastiness_value:.6f}\" if max_tastiness_value != float('-inf') else \"impossible\""
    },
    {
        "number": 3082,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    d, w = map(int, stdin.readline().split())\n    dishes = []\n\n    for _ in range(d):\n        line = stdin.readline().split()\n        if line[0] == \"D\":\n            dishes.append((\"discrete\", int(line[1]), int(line[2]), int(line[3])))\n        else:\n            dishes.append((\"continuous\", int(line[1]), int(line[2])))\n\n    def tastiness(dish_type, t_i, decay, weight):\n        if dish_type == \"discrete\":\n            return sum(t_i - (n - 1) * decay for n in range(1, weight // w_i + 1))\n        else:\n            return (t_i - weight * decay) * weight\n\n    def meal_tastiness(dishes, w):\n        max_tastiness = float('-inf')\n        for n in range(1, len(dishes) + 1):\n            for subset in itertools.combinations(dishes, n):\n                weight = sum(dish[1] if dish[0] == \"discrete\" else dish[2] for dish in subset)\n                if weight == w:\n                    total_tastiness = sum(tastiness(*dish, weight) for dish in subset)\n                    max_tastiness = max(max_tastiness, total_tastiness)\n        return max_tastiness\n\n    result = meal_tastiness(dishes, w)\n    if result == float('-inf'):\n        return \"impossible\"\n    else:\n        return \"{:.6f}\".format(result)"
    },
    {
        "number": 3082,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def compute_tastiness(dish_type, w_i, t_i, delta_t_i, n, x):\n        if dish_type == \"D\":\n            return sum(t_i - (i - 1) * delta_t_i for i in range(n + 1))\n        else:\n            return (t_i - x * delta_t_i) * w_i\n\n    d, w = map(int, stdin.split())\n    dishes = []\n\n    for _ in range(d):\n        dish_type, w_i, t_i, delta_t_i = stdin.split()\n        w_i = int(w_i)\n        t_i = int(t_i)\n        delta_t_i = int(delta_t_i)\n        dishes.append((dish_type, w_i, t_i, delta_t_i))\n\n    max_tastiness = float('-inf')\n    for n1 in range(w // dishes[0][1] + 1):\n        for n2 in range(w // dishes[1][1] + 1):\n            if d == 2:\n                tastiness = compute_tastiness(dishes[0][0], dishes[0][1], dishes[0][2], dishes[0][3], n1, 0) + \\\n                             compute_tastiness(dishes[1][0], dishes[1][1], dishes[1][2], dishes[1][3], n2, 0)\n                if abs(tastiness - w) < 1e-6:\n                    return f\"{tastiness:.12f}\"\n                max_tastiness = max(max_tastiness, tastiness)\n            else:\n                for x in range(w - n1 * dishes[0][1] - n2 * dishes[1][1] + 1):\n                    tastiness = compute_tastiness(dishes[0][0], dishes[0][1], dishes[0][2], dishes[0][3], n1, 0) + \\\n                                 compute_tastiness(dishes[1][0], dishes[1][1], dishes[1][2], dishes[1][3], n2, x)\n                    if abs(tastiness - w) < 1e-6:\n                        return f\"{tastiness:.12f}\"\n                    max_tastiness = max(max_tastiness, tastiness)\n\n    if max_tastiness == float('-inf'):\n        return \"impossible\"\n    else:\n        return f\"{max_tastiness:.12f}\""
    },
    {
        "number": 3082,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def eat_discrete_dish(t, dt, n, x):\n        return sum([(t - (n - 1) * dt) for n in range(1, int(x // w_i) + 1)])\n\n    def eat_continuous_dish(t, dt, x):\n        return (t - x * dt) * x\n\n    d, w = map(int, stdin.readline().split())\n    dishes = []\n    for _ in range(d):\n        dish_type, *args = stdin.readline().strip().split()\n        if dish_type == \"D\":\n            w_i, t, dt = map(int, args)\n            dishes.append((w_i, t, dt, \"D\"))\n        else:\n            t, dt = map(int, args)\n            dishes.append((1, t, dt, \"C\"))\n\n    max_tastiness = -1\n    for w_i, t, dt, dish_type in dishes:\n        if dish_type == \"D\":\n            n = w // w_i\n            x = n * w_i\n            max_tastiness += eat_discrete_dish(t, dt, n, x)\n        else:\n            x = min(w, 10000)\n            max_tastiness += eat_continuous_dish(t, dt, x)\n            w -= x\n\n    if w != 0:\n        return \"impossible\"\n    else:\n        return f\"{max_tastiness:.10f}\""
    },
    {
        "number": 3082,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, w = map(int, stdin.readline().split())\n    dishes = []\n    for _ in range(d):\n        dish_type, *params = stdin.readline().strip().split()\n        if dish_type == 'D':\n            dishes.append(('D', int(params[0]), int(params[1]), int(params[2])))\n        elif dish_type == 'C':\n            dishes.append(('C', int(params[0]), int(params[1])))\n\n    def max_tastiness(wanted_weight, dishes):\n        def discrete_tastiness(dish, n):\n            return dish[2] - (n - 1) * dish[3]\n\n        def continuous_tastiness(dish, x):\n            return (dish[2] - x * dish[3]) * x\n\n        dishes.sort(key=lambda x: x[1], reverse=True)\n        current_weight = 0\n        max_tastiness = 0\n\n        for dish in dishes:\n            if dish[0] == 'D':\n                n = (wanted_weight - current_weight) // dish[1]\n                max_tastiness += sum(discrete_tastiness(dish, i) for i in range(1, n + 1))\n                current_weight += n * dish[1]\n            elif dish[0] == 'C':\n                x = (wanted_weight - current_weight) / dish[1]\n                max_tastiness += continuous_tastiness(dish, x)\n                current_weight += x * dish[1]\n\n            if current_weight >= wanted_weight:\n                return max_tastiness\n\n        return \"impossible\"\n\n    result = max_tastiness(w, dishes)\n    return f\"{result:.12f}\" if result != \"impossible\" else result"
    },
    {
        "number": 3083,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, songs = int(stdin.split(\"\\n\", 1)[0]), stdin.split(\"\\n\", 1)[1].split(\"\\n\")\n    artists = {}\n    for i, song in enumerate(songs):\n        artist, num_songs, *song_nums = song.split()\n        artists[artist] = artists.get(artist, []) + [i + 1]\n\n    def can_be_played_after(song_num, song_order):\n        artist = songs[song_num - 1].split()[0]\n        return any(song in artists.get(artist, []) and song not in song_order for song in range(1, n + 1))\n\n    def backtrack(song_num, song_order, playlist):\n        if len(playlist) == 9:\n            return playlist\n        next_songs = [song for song in range(1, n + 1) if song not in song_order and can_be_played_after(song, song_order)]\n        for next_song in next_songs:\n            new_order = song_order + [next_song]\n            new_playlist = playlist + [next_song]\n            result = backtrack(next_song, new_order, new_playlist)\n            if result:\n                return result\n        return None\n\n    for song_num in range(1, n + 1):\n        playlist = backtrack(song_num, [song_num], [song_num])\n        if playlist:\n            return \" \".join(map(str, playlist))\n    return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(playlist: List[int]) -> bool:\n        for i in range(len(playlist) - 1):\n            current_song = songs[playlist[i] - 1]\n            next_song = songs[playlist[i + 1] - 1]\n            if next_song not in current_song[\"following\"]:\n                return False\n        return True\n\n    def backtrack(playlist: List[int], current_song: int) -> Union[List[int], None]:\n        if len(playlist) == 9:\n            return playlist\n\n        for next_song in songs[current_song - 1][\"following\"]:\n            if next_song not in playlist:\n                result = backtrack(playlist + [next_song], next_song)\n                if result:\n                    return result\n        return None\n\n    n = int(stdin.readline())\n    songs = []\n    for i in range(n):\n        artist, num_following, *following = map(int, stdin.readline().split())\n        songs.append({\"artist\": artist, \"following\": set(following)})\n\n    for i in range(n):\n        songs[i][\"following\"].discard(i + 1)\n\n    for i in range(n):\n        playlist = backtrack([i + 1], i + 1)\n        if playlist and is_valid(playlist):\n            return \" \".join(map(str, playlist))\n\n    return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def can_be_played_after(a, b):\n        for song in songs[a][1]:\n            if song == b:\n                return True\n        return False\n\n    def backtrack(playlist, last_song):\n        if len(playlist) == 9:\n            return playlist\n\n        candidates = []\n        for song in range(1, n + 1):\n            if song not in playlist and (not last_song or can_be_played_after(last_song, song)):\n                candidates.append(song)\n\n        if not candidates:\n            return None\n\n        for candidate in candidates:\n            new_playlist = playlist.copy()\n            new_playlist.append(candidate)\n            result = backtrack(new_playlist, candidate)\n            if result:\n                return result\n\n        return None\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    songs = []\n\n    for i in range(1, n + 1):\n        line = lines[i].split()\n        artist = line[0]\n        t = int(line[1])\n        song_numbers = [int(x) for x in line[2:]]\n        songs.append((artist, t, song_numbers))\n\n    playlist = backtrack([], None)\n\n    if playlist:\n        return ' '.join(map(str, playlist))\n    else:\n        return 'fail'"
    },
    {
        "number": 3083,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(playlist: List[int]) -> bool:\n        for i in range(len(playlist) - 1):\n            if not graph[playlist[i]][playlist[i + 1]]:\n                return False\n        return True\n\n    n, *songs = map(str.split, stdin.split('\\n'))\n    n = int(n)\n    graph = [[False] * n for _ in range(n)]\n\n    for i, song in enumerate(songs):\n        artist, total, *following = song\n        for j in range(len(following) // 2):\n            graph[int(following[2 * j])][int(following[2 * j + 1])] = True\n\n    for i in range(n):\n        for j in range(n):\n            graph[i][j] |= graph[j][i]\n\n    for playlist in permutations(range(1, n + 1)):\n        if is_valid(playlist):\n            return ' '.join(map(str, playlist))\n\n    return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, artists, songs = int(stdin.splitlines()[0]), [], []\n    for i in range(1, n + 1):\n        line = stdin.splitlines()[i].split()\n        artists.append(line[0])\n        songs.append([int(x) for x in line[1:]])\n\n    def dfs(i, path):\n        if len(path) == 9:\n            return path\n        for j in songs[i - 1]:\n            if j not in path and artists[j - 1] != artists[i - 1]:\n                new_path = dfs(j, path + [j])\n                if new_path:\n                    return new_path\n        return []\n\n    for i in range(1, n + 1):\n        playlist = dfs(i, [i])\n        if playlist:\n            return \" \".join(map(str, playlist))\n    return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import permutations\n\n    def is_valid(playlist: list) -> bool:\n        for i in range(1, len(playlist)):\n            if not set(graph[playlist[i - 1] - 1]) & set(graph[playlist[i] - 1]):\n                return False\n        return True\n\n    def find_playlist(graph: list) -> str:\n        for playlist in permutations(range(1, n + 1)):\n            if is_valid(list(playlist)):\n                return \" \".join(map(str, [x for x in playlist]))\n        return \"fail\"\n\n    n = int(stdin.readline())\n    graph = [[] for _ in range(n)]\n\n    for i in range(n):\n        artist, num_songs, *songs = list(map(int, stdin.readline().split()))\n        graph[i] = songs\n\n    return find_playlist(graph)"
    },
    {
        "number": 3083,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n\n    def find_playlist(graph, start, n, visited=None, path=None):\n        if visited is None:\n            visited = set()\n        if path is None:\n            path = []\n\n        if start not in visited:\n            visited.add(start)\n            path.append(start)\n            if len(path) == n:\n                return path\n\n            for neighbor in graph[start]:\n                if neighbor not in visited:\n                    result = find_playlist(graph, neighbor, n, visited.copy(), path.copy())\n                    if len(result) == n:\n                        return result\n            visited.remove(start)\n            path.pop()\n        return []\n\n    def bfs(graph, start, n, visited=None, path=None):\n        if visited is None:\n            visited = set()\n        if path is None:\n            path = []\n\n        queue = [(start, path + [start])]\n        while queue:\n            (vertex, path) = queue.pop(0)\n            if len(path) == n:\n                return path\n            for neighbor in graph[vertex]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n        return []\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    artists = [line.split()[0] for line in lines[1:]]\n    songs = [list(map(int, line.split()[1:])) for line in lines[1:]]\n\n    graph = defaultdict(set)\n    for i, (artist, song_list) in enumerate(zip(artists, songs)):\n        for song in song_list:\n            if i + 1 != song:\n                graph[i + 1].add(song)\n\n    playlist = find_playlist(graph, 1, n)\n    if not playlist:\n        playlist = bfs(graph, 1, n)\n\n    if len(playlist) == n:\n        return ' '.join(map(str, sorted(playlist)))\n    else:\n        return 'fail'"
    },
    {
        "number": 3083,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(songs, playlist):\n        for i in range(len(playlist) - 1):\n            if not set(songs[playlist[i]][2:]) & set(playlist[i + 1:]):\n                return False\n        return True\n\n    def dfs(songs, visited, playlist, songs_left):\n        if songs_left == 0:\n            return playlist if is_valid(songs, playlist) else None\n\n        for i in range(len(songs)):\n            if not visited[i] and set(playlist) & set(songs[i][2:]):\n                visited[i] = True\n                playlist.append(i + 1)\n                result = dfs(songs, visited, playlist, songs_left - 1)\n                if result:\n                    return result\n                visited[i] = False\n                playlist.pop()\n\n        return None\n\n    lines = stdin.splitlines()\n    num_songs = int(lines[0])\n    songs = []\n\n    for i in range(num_songs):\n        line = lines[i + 1].split()\n        artist = line[0]\n        t = int(line[1])\n        s = list(map(int, line[2:]))\n        songs.append([artist, t, *s])\n\n    visited = [False] * num_songs\n    playlist = []\n    result = dfs(songs, visited, playlist, 9)\n\n    if result:\n        return ' '.join(map(str, result))\n    else:\n        return 'fail'"
    },
    {
        "number": 3083,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def can_play_after(playlist: List[int], i: int) -> bool:\n        return all(song in playlist for song in graph[i])\n\n    def find_playlist(playlist: List[int], i: int) -> List[int]:\n        if len(playlist) == 9:\n            return playlist\n\n        for song in graph[i]:\n            if song not in playlist and can_play_after(playlist, song - 1):\n                new_playlist = find_playlist(playlist + [song], song)\n                if new_playlist:\n                    return new_playlist\n        return []\n\n    n = int(stdin.readline())\n    songs = []\n    for _ in range(n):\n        artist, num_songs, *songs_to_play = map(int, stdin.readline().split())\n        songs.append((artist, num_songs, songs_to_play))\n\n    graph = [[] for _ in range(n)]\n    for i, (_, _, songs_to_play) in enumerate(songs):\n        for song in songs_to_play:\n            graph[i].append(song)\n\n    for i, (_, _, _) in enumerate(songs):\n        if len(graph[i]) == 0:\n            continue\n        playlist = find_playlist([i + 1], i)\n        if playlist:\n            return \" \".join(map(str, playlist))\n    return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def can_play_after(song, next_song, graph):\n        return next_song in graph[song]\n\n    def find_playlist(start_song, graph, visited, playlist):\n        if len(playlist) == 9:\n            return playlist\n        for next_song in graph[start_song]:\n            if next_song not in visited:\n                visited.add(next_song)\n                if find_playlist(next_song, graph, visited, playlist):\n                    return playlist\n                visited.remove(next_song)\n        return None\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    graph = {}\n\n    for i in range(n):\n        artist, num_songs, *songs = lines[i + 1].split()\n        graph[i + 1] = set(map(int, songs))\n\n    for i in range(n):\n        playlist = find_playlist(i + 1, graph, set(), [i + 1])\n        if playlist:\n            return \" \".join(map(str, playlist))\n\n    return \"fail\""
    },
    {
        "number": 3084,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_time(time: str) -> bool:\n        hour, minute = map(int, time.split(':'))\n        return 0 <= hour < 24 and 0 <= minute < 60\n\n    def next_time(time: str, op: str) -> str:\n        hour, minute = map(int, time.split(':'))\n        if op == '+':\n            minute += 1\n            if minute == 60:\n                minute = 0\n                hour += 1\n            if hour == 24:\n                hour = 0\n        else:\n            minute -= 1\n            if minute == -1:\n                minute = 59\n                hour -= 1\n            if hour == -1:\n                hour = 23\n        return f\"{hour:02}:{minute:02}\"\n\n    original_time, current_time = stdin.split('\\n')\n    times = set([original_time, current_time])\n    while current_time != original_time:\n        op = '+' if current_time < original_time else '-'\n        current_time = next_time(current_time, op)\n        if is_valid_time(current_time):\n            times.add(current_time)\n\n    return f\"{len(times)}\\n\" + '\\n'.join(sorted(times))"
    },
    {
        "number": 3084,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    original_time, current_time = stdin.strip().split(\"\\n\")\n    hours_original, minutes_original = map(int, original_time.split(\":\"))\n    hours_current, minutes_current = map(int, current_time.split(\":\"))\n\n    times_seen = set()\n    times_seen.add((hours_original, minutes_original))\n    times_seen.add((hours_current, minutes_current))\n\n    def next_time(hours, minutes):\n        if minutes == 59:\n            hours = (hours + 1) % 24\n            minutes = 0\n        else:\n            minutes += 1\n        return hours, minutes\n\n    def prev_time(hours, minutes):\n        if minutes == 0:\n            hours = (hours - 1) % 24\n            minutes = 59\n        else:\n            minutes -= 1\n        return hours, minutes\n\n    def valid_time(hours, minutes):\n        return 0 <= hours < 24 and 0 <= minutes < 60\n\n    while (hours_current, minutes_current) not in times_seen:\n        if valid_time(hours_current, minutes_current):\n            times_seen.add((hours_current, minutes_current))\n        hours_current, minutes_current = prev_time(hours_current, minutes_current)\n\n    output = [f\"{original_time}\", f\"{current_time}\"]\n    for time_seen in sorted(times_seen):\n        output.append(f\"{time_seen[0]:02d}:{time_seen[1]:02d}\")\n\n    return f\"{len(times_seen)}\\n\" + \"\\n\".join(output) + \"\\n\""
    },
    {
        "number": 3084,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    original_time, current_time = stdin.strip().split('\\n')\n\n    def adjust_time(time):\n        hh, mm = time.split(':')\n        hh, mm = int(hh), int(mm)\n\n        if mm == 9:\n            mm = 0\n            hh = (hh + 1) % 24\n        else:\n            mm += 1\n\n        return f\"{hh:02d}:{mm:02d}\"\n\n    times = set()\n    times.add(current_time)\n\n    while current_time != original_time:\n        current_time = adjust_time(current_time)\n        times.add(current_time)\n\n    output = [original_time] + list(times - {original_time})\n    return f\"{len(output)}\\n\" + \"\\n\".join(output) "
    },
    {
        "number": 3084,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    original_time, current_time = stdin.split('\\n')\n    times = set()\n    times.add(original_time)\n    times.add(current_time)\n\n    def get_next_time(time: str) -> str:\n        hour, minute = time.split(':')\n        new_minute = int(minute) + 1 if int(minute) < 59 else 0\n        new_hour = int(hour) + 1 if int(minute) == 59 else int(hour)\n        return f\"{new_hour:02d}:{new_minute:02d}\"\n\n    def get_previous_time(time: str) -> str:\n        hour, minute = time.split(':')\n        new_minute = int(minute) - 1 if int(minute) > 0 else 59\n        new_hour = int(hour) - 1 if int(minute) == 0 else int(hour)\n        return f\"{new_hour:02d}:{new_minute:02d}\"\n\n    while True:\n        new_times = set()\n        for time in times:\n            new_times.add(get_next_time(time))\n            new_times.add(get_previous_time(time))\n        if not new_times.difference(times):\n            break\n        times.update(new_times)\n\n    output = [original_time, *sorted(times.difference({original_time}))]\n    return f\"{len(output)}\\n\" + '\\n'.join(output)"
    },
    {
        "number": 3084,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def increment_time(time: str) -> str:\n        hh, mm = time.split(':')\n        if int(mm) == 59:\n            hh = str((int(hh) + 1) % 24).zfill(2)\n            mm = '00'\n        else:\n            mm = str((int(mm) + 1) % 60).zfill(2)\n        return hh + ':' + mm\n\n    def valid_time(time: str) -> bool:\n        hh, mm = time.split(':')\n        return 0 <= int(hh) < 24 and 0 <= int(mm) < 60\n\n    def find_times(start: str, end: str) -> set:\n        times = set([start])\n        current = start\n        while current != end:\n            current = increment_time(current)\n            if valid_time(current):\n                times.add(current)\n        return times\n\n    original_time, current_time = stdin.strip().split('\\n')\n    times = find_times(original_time, current_time)\n    output = [original_time] + sorted(list(times)) + [current_time]\n    return str(len(output)) + '\\n' + '\\n'.join(output)"
    },
    {
        "number": 3084,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input into two lines\n    original_time, current_time = stdin.split('\\n')\n    \n    # Convert the times to lists of digits\n    original_time = [int(d) for d in original_time.split(':')]\n    current_time = [int(d) for d in current_time.split(':')]\n    \n    # Initialize the output with the original time\n    output = [original_time]\n    \n    # Keep track of the number of times seen on the clock\n    times_seen = 1\n    \n    # Loop through all the possible changes\n    for h in range(2):\n        for m in range(2):\n            # Make a copy of the current time\n            new_time = current_time.copy()\n            \n            # Apply the change\n            if h == 0:\n                new_time[0] -= 1\n                if new_time[0] < 0:\n                    new_time[0] = 9\n            else:\n                new_time[0] += 1\n                if new_time[0] > 9:\n                    new_time[0] = 0\n                    \n            if m == 0:\n                new_time[1] -= 1\n                if new_time[1] < 0:\n                    new_time[1] = 9\n            else:\n                new_time[1] += 1\n                if new_time[1] > 9:\n                    new_time[1] = 0\n                    \n            # Check if the new time is valid\n            if new_time[0] > 2 or (new_time[0] == 2 and new_time[1] > 3):\n                continue\n                \n            # Add the new time to the output\n            if new_time not in output:\n                output.append(new_time)\n                times_seen += 1\n                \n    # Convert the output times to strings and add the final time\n    output.append(current_time)\n    output = ['{}:{}'.format(d[0], d[1]) for d in output]\n    \n    # Return the output as a string\n    return '{}\\n{}'.format(times_seen, '\\n'.join(output))"
    },
    {
        "number": 3084,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_time(time: str) -> str:\n        time_list = list(map(int, time.split(\":\")))\n        for i in range(len(time_list)):\n            if time_list[i] == 9:\n                time_list[i] = 0\n            else:\n                time_list[i] += 1\n                break\n        return \":\".join(map(lambda x: f\"{x:02d}\", time_list))\n\n    def get_valid_times(original_time: str, current_time: str) -> set:\n        valid_times = set()\n        valid_times.add(original_time)\n        while current_time != original_time:\n            valid_times.add(current_time)\n            current_time = get_next_time(current_time)\n        return valid_times\n\n    original_time, current_time = stdin.strip().split(\"\\n\")\n    valid_times = get_valid_times(original_time, current_time)\n    output = [str(len(valid_times))] + sorted(valid_times)\n    return \"\\n\".join(output)"
    },
    {
        "number": 3084,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def next_time(time):\n        hour, minute = map(int, time.split(':'))\n        if minute == 59:\n            hour = (hour + 1) % 24\n            minute = 0\n        else:\n            minute += 1\n        return f\"{hour:02d}:{minute:02d}\"\n\n    def prev_time(time):\n        hour, minute = map(int, time.split(':'))\n        if minute == 0:\n            hour = (hour - 1) % 24\n            minute = 59\n        else:\n            minute -= 1\n        return f\"{hour:02d}:{minute:02d}\"\n\n    def times_between(start, end):\n        times = set()\n        time = start\n        while time != end:\n            times.add(time)\n            time = next_time(time)\n        times.add(end)\n        return times\n\n    def find_solution(start, end):\n        times = times_between(start, end)\n        return [start] + list(times) + [end]\n\n    start, end = stdin.splitlines()\n    solution = find_solution(start, end)\n    return f\"{len(solution)}\\n\" + '\\n'.join(solution)"
    },
    {
        "number": 3084,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Split input into original time and current time\n    original_time, current_time = stdin.split('\\n')\n\n    # Parse original and current time into hour and minute integers\n    orig_hour, orig_minute = map(int, original_time.split(':'))\n    curr_hour, curr_minute = map(int, current_time.split(':'))\n\n    # Determine the required changes to set the clock correctly\n    changes = []\n    for i in range(2):\n        if orig_hour % 10 != curr_hour % 10:\n            changes.append(('h', i, curr_hour % 10))\n        if orig_minute % 10 != curr_minute % 10:\n            changes.append(('m', i, curr_minute % 10))\n        orig_hour //= 10\n        orig_minute //= 10\n        curr_hour //= 10\n        curr_minute //= 10\n\n    # Apply the changes to the original time\n    for change in changes:\n        if change[0] == 'h':\n            if orig_hour % 10 == 0:\n                orig_hour += 9\n            elif orig_hour % 10 == 9:\n                orig_hour -= 9\n            else:\n                orig_hour += change[2]\n        else:\n            if orig_minute % 10 == 0:\n                orig_minute += 9\n            elif orig_minute % 10 == 9:\n                orig_minute -= 9\n            else:\n                orig_minute += change[2]\n\n    # Format the original and final times as strings\n    orig_time_str = f\"{orig_hour:02d}:{orig_minute:02d}\"\n    curr_time_str = f\"{curr_hour:02d}:{curr_minute:02d}\"\n\n    # Output the number of times seen on the clock and the times\n    return f\"{len(changes) + 1}\\n{orig_time_str}\\n{curr_time_str}\\n\""
    },
    {
        "number": 3084,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    original_time, current_time = stdin.split(\"\\n\")\n    times = []\n    times.append(original_time)\n    \n    def change_time(time):\n        hh, mm = time.split(\":\")\n        hh, mm = int(hh), int(mm)\n        \n        if mm == 0:\n            mm = 9\n            hh -= 1\n            if hh < 0:\n                hh = 23\n        else:\n            mm -= 1\n        \n        return f\"{hh:02d}:{mm:02d}\"\n    \n    new_time = change_time(current_time)\n    while new_time != original_time:\n        times.append(new_time)\n        new_time = change_time(new_time)\n    \n    times.append(current_time)\n    return f\"{len(times)}\\n\" + \"\\n\".join(times)"
    },
    {
        "number": 3085,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    alt_notation = \"\"\n    for i, bracket in enumerate(stdin):\n        if bracket == \"(\":\n            stack.append(i)\n        else:\n            start = stack.pop()\n            end = i\n            if not stack:\n                alt_notation += f\"{start},{end + 1}:\"\n            else:\n                alt_notation += f\"{start},{end + 1}:\"\n    return alt_notation"
    },
    {
        "number": 3085,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    alt_brackets = \"\"\n    prev_open = 0\n\n    for i, c in enumerate(stdin):\n        if c == \"(\":\n            stack.append(i)\n        else:\n            start = stack.pop()\n            if not stack:\n                end = i\n                if alt_brackets:\n                    alt_brackets += \",\"\n                alt_brackets += f\"{start},{end}\"\n                prev_open = start\n\n    return alt_brackets[prev_open:] + \":\""
    },
    {
        "number": 3085,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    alt_notation = []\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        else:\n            start = stack.pop()\n            end = i\n            if not stack:\n                alt_notation.append(f\"{start},{end}:\")\n            else:\n                alt_notation.append(f\"{start},{end}:{','.join(alt_notation[-1].split(',')[:-1]) + ',' + str(end)}:\")\n                alt_notation.append(f\"{start},{end}:{','.join(alt_notation.pop().split(',')[:-1]) + ',' + str(end)}:\")\n    return ''.join(alt_notation)"
    },
    {
        "number": 3085,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    alt_notation = \"\"\n\n    for i, char in enumerate(stdin):\n        if char == \"(\":\n            stack.append(i)\n        else:\n            start = stack.pop()\n            if not stack:\n                end = i\n                alt_notation += f\"{start},{end}:\"\n                stack.append(start)\n\n    return alt_notation"
    },
    {
        "number": 3085,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    result = []\n    for i, bracket in enumerate(stdin):\n        if bracket == '(':\n            stack.append(i)\n        else:\n            start = stack.pop()\n            end = i\n            result.append(f\"{start},{end + 1}:\")\n            result.append(stdin[start + 1:end])\n    while stack:\n        start = stack.pop()\n        end = start\n        result.append(f\"{start},{end + 1}:\")\n    return ''.join(result)"
    },
    {
        "number": 3085,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, char in enumerate(stdin):\n        if char == \"(\":\n            stack.append(i)\n        else:\n            start = stack.pop()\n            if not stack:\n                end = i\n                stack.append(f\"{start},{end}:\")\n            else:\n                end = stack[-1][:stack[-1].index(\":\")]\n                stack.append(f\"{start},{end}:{i}\")\n    return \"\".join(stack)"
    },
    {
        "number": 3085,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    alt_notation = []\n    open_bracket_count = 0\n\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n            open_bracket_count += 1\n        elif char == ')':\n            start = stack.pop()\n            end = i + 1\n            alt_notation.append(f\"{start},{end}\")\n\n    # Add headers for open brackets that were not matched with a closing bracket\n    while stack:\n        start = stack.pop()\n        end = start + 1\n        alt_notation.append(f\"{start},{end}\")\n\n    # Sort the headers by their start index, and then by their length\n    alt_notation.sort(key=lambda x: (int(x.split(',')[0]), len(x)))\n\n    # Combine the headers into a single string\n    combined_headers = ''.join(alt_notation)\n\n    return combined_headers"
    },
    {
        "number": 3085,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    result = []\n\n    for i, bracket in enumerate(stdin):\n        if bracket == '(':\n            stack.append(i)\n        else:\n            start = stack.pop()\n            end = i + 1\n            header = f\"{start},{end}:\".replace(\",\", \"|\")\n            result.append(header)\n\n    return \"\".join(result)\n\ndef"
    },
    {
        "number": 3085,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    result = \"\"\n    index = 0\n\n    for char in stdin:\n        if char == \"(\":\n            stack.append(index)\n        else:\n            start = stack.pop()\n            end = index + 1\n            result += f\"{start},{end}:\"\n\n        index += 1\n\n    return result"
    },
    {
        "number": 3085,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    result = []\n    start = 0\n\n    for i, char in enumerate(stdin):\n        if char == \"(\":\n            stack.append(i)\n        else:\n            if not stack:\n                return \"Invalid\"\n            start = stack.pop()\n            end = i + 1\n            result.append(f\"{start},{end}:\")\n\n    while stack:\n        start = stack.pop()\n        end = start + 1\n        result.append(f\"{start},{end}:\")\n\n    result.sort(key=lambda x: len(x))\n    return result[0]\n"
    },
    {
        "number": 3086,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    observations = []\n\n    for _ in range(N):\n        start_date, end_date = stdin.readline().split()[:2]\n        observation = [int(x) for x in stdin.readline().split()]\n        start_date = [int(start_date[:2]), int(start_date[2:])]\n        end_date = [int(end_date[:2]), int(end_date[2:])]\n        observations.append((start_date, end_date, observation))\n\n    durations = [0] * M\n\n    for observation in observations:\n        start_date, end_date, observation = observation\n        for i in range(M):\n            durations[i] += (end_date[0] - start_date[0] + 1) * observation[i]\n\n    return \" \".join(str(x) for x in durations)"
    },
    {
        "number": 3086,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().strip().split())\n    days = [0] * M\n    for _ in range(N):\n        start_date, end_date = map(lambda x: list(map(int, x.split())), stdin.readline().strip().split()[:2])\n        event_counts = list(map(int, stdin.readline().strip().split()[2:]))\n        start_date_int = start_date[0] + start_date[1] * 31 + start_date[2] * 31 * 12\n        end_date_int = end_date[0] + end_date[1] * 31 + end_date[2] * 31 * 12\n        for i in range(M):\n            days[i] += event_counts[i] * (end_date_int - start_date_int + 1)\n\n    for i in range(M):\n        days[i] //= days[i] // 365\n\n    if all(days[i] == days[0] for i in range(M)):\n        return ' '.join(map(str, days))\n    else:\n        return '-1'"
    },
    {
        "number": 3086,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def date_to_days(date):\n        return (int(date[3:5]) - 1) * 31 + int(date[0:2])\n\n    def days_to_years(days):\n        return days // 365\n\n    N, M = map(int, stdin.readline().split())\n    observations = [stdin.readline().split() for _ in range(N)]\n    start_dates = [obs[0] + obs[1] for obs in observations]\n    end_dates = [obs[2] + obs[3] for obs in observations]\n    event_counts = [list(map(int, obs[4:])) for obs in observations]\n\n    start_days = [date_to_days(date) for date in start_dates]\n    end_days = [date_to_days(date) for date in end_dates]\n    event_durations = [0] * M\n\n    for i in range(M):\n        for j in range(N):\n            event_durations[i] += event_counts[j][i] * (end_days[j] - start_days[j])\n\n    event_durations = [days_to_years(d) for d in event_durations]\n\n    if len(set(event_durations)) == 1:\n        return str(event_durations[0])\n    else:\n        return \"-1\""
    },
    {
        "number": 3086,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_leap_year(year: int) -> bool:\n        return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\n    def days_in_year(year: int) -> int:\n        return 366 if is_leap_year(year) else 365\n\n    def days_in_month(year: int, month: int) -> int:\n        if month == 2:\n            return 29 if is_leap_year(year) else 28\n        elif month in [4, 6, 9, 11]:\n            return 30\n        else:\n            return 31\n\n    def date_diff(date1: str, date2: str) -> int:\n        year1, month1, day1 = int(date1[:4]), int(date1[4:]), int(date1[6:])\n        year2, month2, day2 = int(date2[:4]), int(date2[4:]), int(date2[6:])\n\n        days1 = sum(days_in_month(year1, m) for m in range(1, month1)) + day1\n        days2 = sum(days_in_month(year2, m) for m in range(1, month2)) + day2\n\n        return days2 - days1 + (year2 - year1) * days_in_year(year2)\n\n    N, M = map(int, stdin.readline().split())\n    observations = [stdin.readline().split() for _ in range(N)]\n\n    durations = [0] * M\n    for obs in observations:\n        start_date, end_date = obs[:2], obs[2:4]\n        event_counts = list(map(int, obs[4:]))\n        duration = date_diff(start_date, end_date) + 1\n\n        for i in range(M):\n            durations[i] += event_counts[i] * duration\n\n    return \" \".join(map(str, durations))"
    },
    {
        "number": 3086,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    data = []\n    for _ in range(N):\n        line = stdin.readline().split()\n        start_day, start_month, end_day, end_month = map(int, line[:4])\n        counts = list(map(int, line[4:]))\n        data.append((start_day, start_month, end_day, end_month, counts))\n\n    durations = [0] * M\n    for start_day, start_month, end_day, end_month, counts in data:\n        start_date = start_month * 100 + start_day\n        end_date = end_month * 100 + end_day\n        for i in range(M):\n            durations[i] += (end_date - start_date + 1) * counts[i]\n\n    if all(d % 365 == 0 for d in durations):\n        return \" \".join(str(d // 365) for d in durations)\n    else:\n        return \"-1\""
    },
    {
        "number": 3086,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    events = [[] for _ in range(M)]\n    for i in range(N):\n        start_date, end_date = stdin.readline().split()[:2]\n        start_date = [int(start_date[:2]), int(start_date[2:])]\n        end_date = [int(end_date[:2]), int(end_date[2:])]\n        durations = list(map(int, stdin.readline().split()[:M]))\n        for j in range(M):\n            events[j].append((start_date, end_date, durations[j]))\n\n    def is_valid(durations):\n        total_days = 0\n        for duration in durations:\n            total_days += duration\n        return total_days == 365\n\n    def helper(idx, duration, durations):\n        if idx == M:\n            if is_valid(durations):\n                return True\n            return False\n        for i in range(1, 366):\n            if helper(idx + 1, duration + i, durations + [i]):\n                return True\n        return False\n\n    for event in events:\n        event.sort(key=lambda x: x[1])\n\n    for event in events:\n        for i in range(len(event) - 1):\n            start_date, end_date, duration = event[i]\n            next_start_date, _, next_duration = event[i + 1]\n            if next_start_date[0] > end_date[0] or (next_start_date[0] == end_date[0] and next_start_date[1] > end_date[1]):\n                if duration == next_duration:\n                    return \"1\"\n                else:\n                    return \"-1\"\n\n    def get_duration(events):\n        for event in events:\n            start_date, end_date, _ = event[0]\n            start_date = (start_date[0] - 1) * 31 + start_date[1]\n            end_date = (end_date[0] - 1) * 31 + end_date[1]\n            duration = end_date - start_date + 1\n            if duration > 365:\n                return \"-1\"\n            else:\n                return duration\n\n    durations = []\n    for event in events:\n        duration = get_duration(event)\n        if duration == \"-1\":\n            return \"-1\"\n        durations.append(duration)\n\n    return \" \".join(map(str, durations)) "
    },
    {
        "number": 3086,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def date_to_days(day, month):\n        days = (month - 1) * 31 + day\n        return days\n\n    def days_to_date(days):\n        month = days // 31 + 1\n        day = days % 31 + 1\n        return day, month\n\n    def days_difference(start_day, start_month, end_day, end_month):\n        start_days = date_to_days(start_day, start_month)\n        end_days = date_to_days(end_day, end_month)\n        return abs(end_days - start_days)\n\n    N, M = map(int, stdin.readline().split())\n    event_counts = [0] * M\n    event_duration_sums = [0] * M\n\n    for _ in range(N):\n        start_day, start_month, end_day, end_month, *event_counts = map(int, stdin.readline().split())\n        duration = days_difference(start_day, start_month, end_day, end_month) + 1\n        for i in range(M):\n            event_duration_sums[i] += event_counts[i] * duration\n\n    result = [-1] * M\n    for i in range(M):\n        if event_counts[i] > 0:\n            result[i] = event_duration_sums[i] // event_counts[i]\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3086,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def days_between_dates(d1, m1, y1, d2, m2, y2):\n        return (y2 - y1) * 365 + (m2 - m1) * 30 + (d2 - d1)\n\n    N, M = map(int, stdin.readline().split())\n    data = [list(map(int, stdin.readline().split())) for _ in range(N)]\n    total_days = [0] * M\n\n    for i in range(M):\n        for j in range(N):\n            start_date = data[j][:2]\n            end_date = data[j][2:4]\n            count = data[j][4 + i]\n            total_days[i] += days_between_dates(*start_date, *end_date) * count\n\n    if all(total_days[i] == total_days[i + 1] for i in range(M - 1)):\n        return str(total_days[0] // M)\n    else:\n        return \"-1\""
    },
    {
        "number": 3086,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    events = [0] * M\n\n    for _ in range(N):\n        start_date, end_date = stdin.readline().split()[0:4]\n        start_date = [int(start_date[0:2]), int(start_date[2:4]), int(start_date[4:6])]\n        end_date = [int(end_date[0:2]), int(end_date[2:4]), int(end_date[4:6])]\n        event_counts = list(map(int, stdin.readline().split()))\n\n        for i in range(M):\n            events[i] += (end_date[1] - start_date[1] + 1) * event_counts[i]\n\n    for i in range(M):\n        events[i] //= 365\n\n    if sum(events) != 365:\n        return \"-1\"\n\n    return \" \".join(map(str, events))\n"
    },
    {
        "number": 3086,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split('\\n')[0].split())\n    observations = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def get_date_diff(start_date, end_date):\n        y1, m1, d1, y2, m2, d2 = start_date[2], start_date[1], start_date[0], end_date[2], end_date[1], end_date[0]\n        delta_days = (y2 - y1) * 365 + (m2 - m1) * 30 + (d2 - d1)\n        return delta_days\n\n    def check_solution(durations):\n        for obs in observations:\n            start_date, end_date = (obs[0], obs[1]), (obs[2], obs[3])\n            event_counts = obs[4:]\n            duration_sum = sum([count * durations[i] for i, count in enumerate(event_counts)])\n            date_diff = get_date_diff(start_date, end_date)\n            if duration_sum != date_diff:\n                return False\n        return True\n\n    durations = [0] * M\n    for i in range(M):\n        durations[i] = 1\n        while not check_solution(durations):\n            durations[i] += 1\n            if durations[i] > 365:\n                return \"-1\"\n\n    return \" \".join(map(str, durations))"
    },
    {
        "number": 3087,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(marks):\n        visited = [False] * len(marks)\n        for i, mark in enumerate(marks):\n            if not visited[i]:\n                cycle = [i]\n                while not visited[mark]:\n                    cycle.append(mark)\n                    visited[mark] = True\n                    mark = marks[mark]\n                if cycle[-1] == mark and len(set(cycle)) == len(cycle):\n                    return cycle\n        return None\n\n    def print_arrows(marks):\n        arrows = [0] * len(marks)\n        for start, end in zip(marks, marks[1:] + marks[:1]):\n            arrows[start] = end\n        return arrows\n\n    N, K = map(int, stdin.readline().strip().split())\n    marks = list(map(int, stdin.readline().strip().split()))\n\n    if K > N:\n        return \"Impossible\"\n\n    cycle = find_cycle(marks)\n    if cycle is None:\n        return \"Impossible\"\n\n    arrows = print_arrows(cycle)\n    return \" \".join(map(str, arrows))"
    },
    {
        "number": 3087,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(arrows, N, K):\n        stack = [(1, 0)]  # (Person, step)\n        visited = set()\n\n        while stack:\n            person, step = stack.pop()\n            if step == K:\n                visited.add(person)\n                if len(visited) == N:\n                    return True\n                continue\n\n            for target in arrows[person]:\n                if target not in visited:\n                    stack.append((target, step + 1))\n\n        return False\n\n    def backtrack(arrows, N, K, current, remaining_arrows):\n        if len(remaining_arrows) == 0:\n            return arrows if is_valid(arrows, N, K) else None\n\n        next_person = remaining_arrows[0]\n        for target in arrows[current]:\n            if target != current and target != next_person:\n                arrows[current] = [target]\n                result = backtrack(arrows, N, K, next_person, remaining_arrows[1:])\n                if result:\n                    return result\n        arrows[current] = []\n\n    N, K = map(int, stdin.split())\n    people = list(range(1, N + 1))\n    arrows = {person: [] for person in people}\n\n    for i in range(N):\n        source = i + 1\n        target = people.index(source) + 1\n        arrows[source].append(target)\n\n    result = backtrack(arrows, N, K, 1, people[1:])\n\n    if result:\n        return ' '.join(map(str, [arrow[0] for arrow in result.values()]))\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3087,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(node, visited, cycle):\n        visited.add(node)\n        cycle.append(node)\n        for neighbor in arrows[node]:\n            if neighbor not in visited:\n                if find_cycle(neighbor, visited, cycle):\n                    return True\n        cycle.pop()\n        return False\n\n    def is_valid(arrows):\n        visited = set()\n        for i in range(1, N + 1):\n            if i not in visited:\n                cycle = []\n                if find_cycle(i, visited, cycle):\n                    cycle.append(cycle[0])\n                    if cycle == photo1 or cycle == photo2:\n                        return True\n        return False\n\n    N, K = map(int, stdin.readline().split())\n    photo1 = stdin.readline().split()\n    photo2 = stdin.readline().split()\n\n    arrows = [set() for _ in range(N + 1)]\n    for i in range(N):\n        arrows[int(photo1[i])].add(i + 1)\n        arrows[i + 1].add(int(photo2[i]))\n\n    if is_valid(arrows):\n        for i in range(1, N + 1):\n            for neighbor in arrows[i]:\n                if neighbor != i:\n                    print(neighbor, end=\" \")\n                    break\n    else:\n        print(\"Impossible\")\n\n    return 0"
    },
    {
        "number": 3087,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    a1 = list(map(int, stdin.readline().split()))\n\n    a2 = [0] * N\n    for i in range(N):\n        a2[a1[i] - 1] = i + 1\n\n    if K == 1:\n        return \" \".join(map(str, a2))\n\n    arrows = []\n    for i in range(N):\n        if a1[i] != i + 1:\n            arrows.append((i + 1, a1[i]))\n\n    for k in range(2, K + 1):\n        new_arrows = []\n        for arrow in arrows:\n            start, end = arrow\n            new_start = a1[end - 1]\n            new_end = a1[new_start - 1]\n            new_arrows.append((new_start, new_end))\n        arrows.extend(new_arrows)\n\n    arrow_dict = {}\n    for arrow in arrows:\n        start, end = arrow\n        arrow_dict[start] = end\n\n    result = []\n    for i in range(1, N + 1):\n        if i in arrow_dict:\n            result.append(arrow_dict[i])\n        else:\n            result.append(\"Impossible\")\n            break\n\n    if \"Impossible\" in result:\n        return \"Impossible\"\n    else:\n        return \" \".join(map(str, result))\n"
    },
    {
        "number": 3087,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, arrow, visited):\n        if node not in visited:\n            visited.add(node)\n            for neighbor in arrow[node]:\n                if neighbor not in visited:\n                    dfs(neighbor, arrow, visited)\n\n    def is_valid(arrow):\n        for i in range(1, N + 1):\n            if arrow[i] == i:\n                return False\n        return True\n\n    def can_produce_photos(arrow):\n        for i in range(1, N + 1):\n            if arrow[i] not in end_pos:\n                return False\n        return True\n\n    N, K = map(int, stdin.readline().strip().split())\n    start_pos = list(map(int, stdin.readline().strip().split()))\n    end_pos = [0] * N\n    for i in range(N):\n        end_pos[start_pos[i] - 1] = i + 1\n\n    arrow = [[] for _ in range(N + 1)]\n    for i in range(N):\n        arrow[i + 1].append(end_pos[i])\n\n    if K == 1:\n        if is_valid(arrow):\n            return \" \".join(map(str, [0] + end_pos))\n        else:\n            return \"Impossible\"\n    elif K == 2:\n        for i in range(N):\n            if arrow[i + 1] != [end_pos[i]]:\n                arrow[i + 1] = end_pos[i]\n                break\n        if is_valid(arrow) and can_produce_photos(arrow):\n            return \" \".join(map(str, [0] + end_pos))\n        else:\n            return \"Impossible\"\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3087,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    photo1 = list(map(int, stdin.readline().split()))\n\n    # Create an empty dictionary to store the arrows\n    arrows = {}\n\n    # Find the initial position of each person\n    for i in range(N):\n        arrows[i + 1] = photo1[i]\n\n    # Check if the dance is possible\n    for i in range(K):\n        photo2 = list(map(int, stdin.readline().split()))\n        for j in range(N):\n            if arrows[photo1[j]] != photo2[j]:\n                break\n        else:\n            for j in range(N):\n                photo1[j] = photo2[j]\n            continue\n        break\n    else:\n        return \"Impossible\"\n\n    result = []\n    for i in range(N):\n        result.append(arrows[i + 1])\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3087,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph):\n        visited = [False] * N\n        for i in range(N):\n            if not visited[i]:\n                cycle = set()\n                while not visited[i]:\n                    visited[i] = True\n                    cycle.add(i)\n                    i = graph[i]\n                if i in cycle:\n                    return cycle\n        return None\n\n    N, K = map(int, stdin.split()[0:2])\n    people = list(map(int, stdin.split()[2:]))\n\n    graph = {}\n    for i, person in enumerate(people, start=1):\n        graph[i] = person\n\n    cycle = find_cycle(graph)\n\n    if cycle is None:\n        return \"Impossible\"\n    else:\n        result = [0] * N\n        for person in cycle:\n            result[person - 1] = graph[person]\n        for i in range(N):\n            if i + 1 not in cycle:\n                result[i] = graph[i + 1]\n        return \" \".join(map(str, result))"
    },
    {
        "number": 3087,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(arrows, photo1, photo2):\n        if arrows[photo1[0] - 1] == photo2[0] and arrows[photo1[1] - 1] == photo2[1]:\n            return True\n        return False\n\n    N, K = map(int, stdin.split()[0:2])\n    photo1 = list(map(int, stdin.split()[2:N + 2]))\n    photo2 = list(map(int, stdin.split()[N + 2:]))\n\n    for arrow_1 in range(1, N + 1):\n        if arrow_1 not in photo1 and arrow_1 not in photo2:\n            continue\n        for arrow_2 in range(1, N + 1):\n            if arrow_2 not in photo1 and arrow_2 not in photo2:\n                continue\n            arrows = [arrow_2] * N\n            arrows[arrow_1 - 1] = arrow_1\n            if is_valid(arrows, photo1, photo2):\n                return \" \".join(map(str, arrows))\n\n    return \"Impossible\""
    },
    {
        "number": 3087,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    start_positions = list(map(int, stdin.readline().split()))\n\n    if K > N or K > (N - 1) * N // 2:\n        return \"Impossible\"\n\n    arrows = [0] * N\n    for i in range(N):\n        arrows[i] = start_positions.index(i + 1) + 1\n\n    for i in range(N):\n        if arrows[i] == i + 1:\n            return \"Impossible\"\n\n    return \" \".join(map(str, arrows))"
    },
    {
        "number": 3087,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(arrows):\n        return all(x != y for x, y in arrows)\n\n    def print_arrows(arrows):\n        return \" \".join(str(y) for x, y in arrows)\n\n    def find_arrows(start, end, arrows, person):\n        if person == N:\n            return arrows\n\n        for i in range(1, N + 1):\n            if i != start[person] and i != end[person] and (start[person], i) not in arrows and (i, start[person]) not in arrows:\n                new_arrows = arrows + [(start[person], i)]\n                if find_arrows(start, end, new_arrows, person + 1) is not None:\n                    return new_arrows\n        return None\n\n    N, K = map(int, stdin.split()[0:2])\n    start = list(map(int, stdin.split()[2:]))\n    end = [start.index(i) + 1 for i in range(1, N + 1)]\n\n    arrows = find_arrows(start, end, [], 1)\n    if arrows is None or not is_valid(arrows):\n        return \"Impossible\"\n    else:\n        return print_arrows(arrows)\n"
    },
    {
        "number": 3088,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    num = list(str(n))\n    swaps = []\n\n    for i in range(len(num) - 1):\n        if int(num[i]) < int(num[i + 1]):\n            swaps.append((i, i + 1))\n\n    for _ in range(k):\n        max_swap = max(swaps, key=lambda x: x[0])\n        i, j = max_swap\n        num[i], num[j] = num[j], num[i]\n        swaps.remove(max_swap)\n\n        for x in range(i + 2, len(num)):\n            if num[x] > num[i]:\n                swaps.append((i, x))\n            else:\n                break\n\n    return \"\".join(num)"
    },
    {
        "number": 3088,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n = list(str(n))\n    max_digits = []\n\n    def is_valid(n, i, j):\n        if i > j:\n            i, j = j, i\n        if int(n[i]) > int(n[j]):\n            i, j = j, i\n        for x in range(i):\n            if int(n[x]) >= int(n[i]):\n                return False\n        for x in range(i + 1, j):\n            if int(n[x]) < int(n[i]):\n                return False\n        for x in range(j + 1, len(n)):\n            if int(n[x]) < int(n[j]):\n                return False\n        return True\n\n    def helper(n, k, max_digits):\n        if k == 0:\n            max_digits.append(int(\"\".join(n)))\n            return\n\n        for i in range(len(n) - 1):\n            for j in range(i + 1, len(n)):\n                if is_valid(n, i, j):\n                    n[i], n[j] = n[j], n[i]\n                    helper(n, k - 1, max_digits)\n                    n[i], n[j] = n[j], n[i]\n\n    helper(n, k, max_digits)\n    return str(max(max_digits))"
    },
    {
        "number": 3088,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = [int(x) for x in str(n)]\n    for _ in range(k):\n        # Find the index of the largest digit\n        largest_digit_index = max(range(len(digits)), key=lambda x: digits[x])\n        # Find the index of the second largest digit\n        second_largest_digit_index = max([i for i in range(len(digits)) if i != largest_digit_index], key=lambda x: digits[x])\n        # Swap the two digits\n        digits[largest_digit_index], digits[second_largest_digit_index] = digits[second_largest_digit_index], digits[largest_digit_index]\n    return ''.join([str(x) for x in digits])"
    },
    {
        "number": 3088,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n_list = list(str(n))\n\n    def swap(i, j):\n        n_list[i], n_list[j] = n_list[j], n_list[i]\n\n    for _ in range(k):\n        for i in range(len(n_list) - 1):\n            if n_list[i] < n_list[i + 1]:\n                swap(i, i + 1)\n                break\n\n    return ''.join(n_list)"
    },
    {
        "number": 3088,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n_str = str(n)\n    digits = list(n_str)\n    max_digits = digits.copy()\n    max_digits.sort(reverse=True)\n    swaps_left = k\n\n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits)):\n            if digits[i] != digits[j] and digits[i] != max_digits[j] and digits[j] != max_digits[i]:\n                digits[i], digits[j] = digits[j], digits[i]\n                swaps_left -= 1\n                if swaps_left == 0:\n                    return int(\"\".join(digits))\n\n    return \"Not possible\""
    },
    {
        "number": 3088,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n_str = str(n)\n    digits = [int(d) for d in n_str]\n\n    for _ in range(k):\n        max_i = max_j = 0\n        max_diff = -float('inf')\n\n        for i in range(len(digits) - 1):\n            for j in range(i + 1, len(digits)):\n                diff = digits[i] - digits[j]\n                if diff > max_diff:\n                    max_diff = diff\n                    max_i = i\n                    max_j = j\n\n        digits[max_i], digits[max_j] = digits[max_j], digits[max_i]\n\n    return ''.join(map(str, digits))\n"
    },
    {
        "number": 3088,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n_str = str(n)\n    digits = [int(d) for d in n_str]\n    swaps_done = 0\n\n    for i in range(len(digits) - 1):\n        max_index = i\n        for j in range(i + 1, len(digits)):\n            if digits[j] > digits[max_index]:\n                max_index = j\n\n        if swaps_done >= k:\n            break\n\n        if digits[max_index] > digits[i]:\n            digits[i], digits[max_index] = digits[max_index], digits[i]\n            swaps_done += 1\n\n    return ''.join(str(d) for d in digits)"
    },
    {
        "number": 3088,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n = list(str(n))\n    \n    for _ in range(k):\n        # Get the index of the maximum digit from the right\n        max_digit_index = len(n) - 1 - n[::-1].index(max(n))\n        max_digit = n[max_digit_index]\n        \n        # Get the index of the maximum digit from the left that is smaller than the max digit\n        max_left_digit_index = max_digit_index - 1\n        while max_left_digit_index >= 0 and n[max_left_digit_index] <= max_digit:\n            max_left_digit_index -= 1\n        max_left_digit = n[max_left_digit_index] if max_left_digit_index >= 0 else None\n        \n        # If there is no digit on the left that is smaller than the max digit, we cannot make any more swaps\n        if max_left_digit is None:\n            break\n        \n        # Swap the digits\n        n[max_digit_index], n[max_left_digit_index] = n[max_left_digit_index], n[max_digit_index]\n    \n    return \"\".join(n)"
    },
    {
        "number": 3088,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n = list(str(n))\n    \n    for _ in range(k):\n        max_index = 0\n        for i in range(1, len(n)):\n            if n[i] > n[max_index]:\n                max_index = i\n                \n        max_digit = n[max_index]\n        del n[max_index]\n        \n        min_index = 0\n        for i in range(1, len(n)):\n            if n[i] < n[min_index]:\n                min_index = i\n                \n        n.insert(min_index, max_digit)\n        \n    return \"\".join(n)"
    },
    {
        "number": 3088,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    # Convert the number to a string\n    num_str = str(n)\n\n    # Count the digits of the number\n    num_digits = len(num_str)\n\n    # Create a list of the digits\n    digits = list(num_str)\n\n    # Initialize a counter for the swaps\n    swaps_count = 0\n\n    # Initialize the largest number as the original number\n    largest_num = n\n\n    # Sort the digits in descending order\n    sorted_digits = sorted(digits, reverse=True)\n\n    # Iterate through the digits from the second largest to the smallest\n    for i in range(1, num_digits):\n        # Get the index of the current digit in the sorted list\n        index = sorted_digits.index(digits[i])\n\n        # Check if the digit is not in its correct position\n        if index != i:\n            # Swap the digit with the one at the correct position\n            digits[i], digits[index] = digits[index], digits[i]\n\n            # Convert the digits list to a string\n            new_num_str = ''.join(digits)\n\n            # Check if the new number is greater than the largest number\n            if int(new_num_str) > largest_num:\n                # Update the largest number\n                largest_num = int(new_num_str)\n\n                # Increment the swap counter\n                swaps_count += 1\n\n                # Check if the maximum number of swaps has been reached\n                if swaps_count == k:\n                    # Break out of the loop\n                    break\n\n    # Return the largest number as a string\n    return str(largest_num)"
    },
    {
        "number": 3089,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def polygon_area(points):\n        area = 0\n        n = len(points)\n        for i in range(n):\n            j = (i + 1) % n\n            area += (points[j][0] - points[i][0]) * (points[j][1] + points[i][1])\n        return abs(area) // 2\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def expected_distance(points):\n        n = len(points)\n        area = polygon_area(points)\n        total_distance = 0\n\n        for i in range(n):\n            j = (i + 1) % n\n            total_distance += distance(points[i], points[j])\n\n        return total_distance / (2 * n) * area\n\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    return f\"{expected_distance(points):.15f}\""
    },
    {
        "number": 3089,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def area(points):\n        area = 0\n        n = len(points)\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area / 2)\n\n    def expected_distance(n, points):\n        center = tuple(map(lambda x: sum(x) / n, zip(*points)))\n        distance_sum = sum(distance(x, y, *center) for x, y in points)\n        return distance_sum / n\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    points = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    cbd_area = area(points)\n    expected_distance_value = expected_distance(n, points)\n    expected_distance_ratio = expected_distance_value / cbd_area\n\n    return f\"{expected_distance_ratio:.10f}\""
    },
    {
        "number": 3089,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def point_in_polygon(point, polygon):\n        x, y = point\n        n = len(polygon)\n        inside = False\n        p1_x, p1_y = polygon[0]\n        for i in range(1, n + 1):\n            p2_x, p2_y = polygon[i % n]\n            if y > min(p1_y, p2_y):\n                if y <= max(p1_y, p2_y):\n                    if x <= max(p1_x, p2_x):\n                        if p1_y != p2_y:\n                            x_intersect = (y - p1_y) * (p2_x - p1_x) / (p2_y - p1_y) + p1_x\n                            if p1_x == p2_x or x <= x_intersect:\n                                inside = not inside\n            p1_x, p1_y = p2_x, p2_y\n        return inside\n\n    def expected_distance(polygon):\n        total_distance = 0\n        n = len(polygon)\n        for i in range(n):\n            p1_x, p1_y = polygon[i]\n            p2_x, p2_y = polygon[(i + 1) % n]\n            total_distance += distance((p1_x, p1_y), (p2_x, p2_y))\n        area = abs(sum(p[0] * p[1] for p in polygon[:-1]) + polygon[-1][0] * polygon[0][1] - polygon[0][0] * polygon[-1][1])) / 2\n        return total_distance / area\n\n    def process(stdin):\n        n = int(stdin.readline())\n        polygon = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n        return expected_distance(polygon)\n\n    return \"{0:.6f}\".format(process(stdin))"
    },
    {
        "number": 3089,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    from fractions import Fraction\n\n    def polygon_area(vertices):\n        n = len(vertices)\n        area = 0\n        for i in range(n):\n            x1, y1 = vertices[i]\n            x2, y2 = vertices[(i + 1) % n]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area) // 2\n\n    def expected_distance(vertices):\n        n = len(vertices)\n        area = polygon_area(vertices)\n        perimeter = sum([distance(vertices[i], vertices[(i + 1) % n]) for i in range(n)])\n        return perimeter / area\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def parse_input(stdin):\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        vertices = [tuple(map(int, re.findall(r\"-?\\d+\", line))) for line in lines[1:]]\n        return n, vertices\n\n    n, vertices = parse_input(stdin)\n    result = expected_distance(vertices)\n    return str(float(Fraction(result)))"
    },
    {
        "number": 3089,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def polygon_area(points):\n        area = 0\n        n = len(points)\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area / 2)\n\n    def average_distance(points, n):\n        total_distance = 0\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n            total_distance += distance(x1, y1, x2, y2)\n        return total_distance / n\n\n    def expected_distance(points, n):\n        area = polygon_area(points)\n        avg_distance = average_distance(points, n)\n        return area * avg_distance\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    points = [list(map(int, line.split())) for line in lines[1:]]\n\n    return f\"{expected_distance(points, n):.12f}\""
    },
    {
        "number": 3089,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_clockwise(points):\n        total = 0\n        for i in range(len(points)):\n            p1, p2 = points[i], points[(i + 1) % len(points)]\n            total += (p2[0] - p1[0]) * (p2[1] + p1[1])\n        return total > 0\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def compute_expected_distance(points):\n        n = len(points)\n        total_distance = 0\n        for i in range(n):\n            p1, p2 = points[i], points[(i + 1) % n]\n            total_distance += distance(p1, p2)\n        return total_distance / n\n\n    def process(stdin: str) -> str:\n        n, points = int(stdin.readline()), []\n        for _ in range(n):\n            x, y = map(int, stdin.readline().split())\n            points.append((x, y))\n\n        if not is_clockwise(points):\n            points = points[::-1]\n\n        return f\"{compute_expected_distance(points):.10f}\"\n\n    return process(stdin)"
    },
    {
        "number": 3089,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def is_inside(polygon, point):\n        n = len(polygon)\n        inside = False\n        p1 = polygon[0]\n        for i in range(1, n + 1):\n            p2 = polygon[i % n]\n            if (point[1] > min(p1[1], p2[1])):\n                if (point[1] <= max(p1[1], p2[1])):\n                    if (point[0] <= max(p1[0], p2[0])):\n                        if (p1[1] != p2[1]):\n                            xints = (point[1] - p1[1]) * (p2[0] - p1[0]) / (p2[1] - p1[1]) + p1[0]\n                            if (p1[0] == p2[0] or point[0] <= xints):\n                                inside = not inside\n            p1 = p2\n        return inside\n\n    def expected_distance(polygon):\n        n = len(polygon)\n        total_distance = 0\n        for i in range(n):\n            p1 = polygon[i]\n            p2 = polygon[(i + 1) % n]\n            total_distance += distance(p1, p2)\n        return total_distance / n\n\n    def uniform_random_point(polygon):\n        n = len(polygon)\n        p1 = polygon[0]\n        p2 = polygon[1]\n        point = (random.uniform(min(p1[0], p2[0]), max(p1[0], p2[0])),\n                 random.uniform(min(p1[1], p2[1]), max(p1[1], p2[1])))\n        return point\n\n    stdin = stdin.split('\\n')\n    n = int(stdin[0])\n    polygon = []\n    for i in range(1, n + 1):\n        x, y = map(int, stdin[i].split())\n        polygon.append((x, y))\n\n    total_distance = 0\n    num_trials = 100000\n    for _ in range(num_trials):\n        point1 = uniform_random_point(polygon)\n        point2 = uniform_random_point(polygon)\n        if is_inside(polygon, point1) and is_inside(polygon, point2):\n            total_distance += distance(point1, point2)\n\n    expected_travel_distance = total_distance / num_trials\n    expected_taxicab_distance = expected_distance(polygon)\n    relative_error = abs(expected_travel_distance - expected_taxicab_distance) / expected_taxicab_distance\n    if relative_error < 1e-6:\n        return f\"{expected_travel_distance:.6f}\"\n    else:\n        return \"Inaccurate\""
    },
    {
        "number": 3089,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def polygon_area(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area) / 2\n\n    def expected_distance(points):\n        n = len(points)\n        total_distance = 0\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n            total_distance += distance(x1, y1, x2, y2)\n        return total_distance / n\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    points = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    area = polygon_area(points)\n    expected_dist = expected_distance(points)\n    return f\"{expected_dist / (2 * area):.10f}\""
    },
    {
        "number": 3089,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def polygon_area(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area) / 2\n\n    def expected_distance(points):\n        n = len(points)\n        area = polygon_area(points)\n        expected_distance = 0\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n            distance_i = distance(x1, y1, x2, y2)\n            expected_distance += distance_i * ((x1 * y2) - (x2 * y1))\n        expected_distance = abs(expected_distance) / (6 * area)\n        return expected_distance\n\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    points = [(input_data[2 * i + 1], input_data[2 * i + 2]) for i in range(1, n + 1)]\n\n    return str(expected_distance(points))\n"
    },
    {
        "number": 3089,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def polygon_area(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area) / 2\n\n    def expected_distance(points):\n        n = len(points)\n        total_area = polygon_area(points)\n        expected_distance = 0\n\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n\n            mid_x = (x1 + x2) / 2\n            mid_y = (y1 + y2) / 2\n\n            segment_length = distance(x1, y1, x2, y2)\n            segment_area = abs(mid_x * (y1 - y2) + x1 * (y2 - y1)) / 2\n\n            expected_distance += segment_length * segment_area / total_area\n\n        return expected_distance\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    points = [tuple(map(int, line.split())) for line in lines[1:n + 1]]\n\n    return str(expected_distance(points))"
    },
    {
        "number": 3090,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_cost(costs, N, M, K):\n        def is_valid(row, col):\n            if 0 <= row < N and 0 <= col < M:\n                return True\n            return False\n\n        def find_hub_cost(row, col, cost):\n            if cost == 0:\n                return K\n            return 0\n\n        def find_corridor_cost(row, col, cost):\n            cost_sum = 0\n            if is_valid(row - 1, col) and costs[row - 1][col] != 0:\n                cost_sum += costs[row - 1][col]\n            if is_valid(row, col - 1) and costs[row][col - 1] != 0:\n                cost_sum += costs[row][col - 1]\n            if is_valid(row + 1, col) and costs[row + 1][col] != 0:\n                cost_sum += costs[row + 1][col]\n            if is_valid(row, col + 1) and costs[row][col + 1] != 0:\n                cost_sum += costs[row][col + 1]\n            return cost_sum - cost\n\n        total_cost = 0\n        for i in range(N):\n            for j in range(M):\n                if costs[i][j] != 0:\n                    corridor_cost = find_corridor_cost(i, j, costs[i][j])\n                    if corridor_cost > 0:\n                        costs[i][j] = 0\n                        total_cost += K\n                    else:\n                        hub_cost = find_hub_cost(i, j, costs[i][j])\n                        total_cost += hub_cost\n        return total_cost\n\n    lines = stdin.split('\\n')\n    N, M, K = map(int, lines[0].split())\n    costs = [list(map(int, line.split())) for line in lines[1:]]\n    min_cost = find_min_cost(costs, N, M, K)\n    return str(min_cost) "
    },
    {
        "number": 3090,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[0:3])\n    cost_matrix = [list(map(int, line.split())) for line in stdin.split()[3:3 + N]]\n\n    def can_cover_corridor(i, j, visited):\n        if i < 0 or i >= N or j < 0 or j >= M:\n            return False\n        if visited[i][j]:\n            return False\n        if cost_matrix[i][j] > 0:\n            return True\n        visited[i][j] = True\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if can_cover_corridor(i + di, j + dj, visited):\n                return True\n        return False\n\n    total_cost = 0\n    for i in range(N):\n        for j in range(M):\n            if cost_matrix[i][j] > 0 and not can_cover_corridor(i, j, [[False] * M for _ in range(N)]):\n                total_cost += K\n            elif cost_matrix[i][j] > 0:\n                total_cost += cost_matrix[i][j]\n\n    return str(total_cost)"
    },
    {
        "number": 3090,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m, k = map(int, stdin.readline().strip().split())\n    costs = []\n    for _ in range(n):\n        costs.append(list(map(int, stdin.readline().strip().split())))\n\n    # Initialize variables\n    total_cost = 0\n    router_installed = [[False for _ in range(m)] for _ in range(n)]\n    hub_installed = [[False for _ in range(m)] for _ in range(n)]\n\n    # Function to check if the given cell has a router or a hub installed\n    def is_covered(i, j):\n        return router_installed[i][j] or hub_installed[i][j]\n\n    # Iterate through each cell\n    for i in range(n):\n        for j in range(m):\n            # If the cell has a router installed, check for conflicts\n            if router_installed[i][j]:\n                # Check for conflicts with the cell on the right\n                if j < m - 1 and router_installed[i][j + 1]:\n                    hub_installed[i][j] = True\n                    total_cost += k\n                # Check for conflicts with the cell on the bottom\n                if i < n - 1 and router_installed[i + 1][j]:\n                    hub_installed[i][j] = True\n                    total_cost += k\n            # If the cell does not have a router installed, check if it needs a router or a hub\n            else:\n                if (j == 0 or is_covered(i, j - 1)) and (j == m - 1 or is_covered(i, j + 1)) and (i == 0 or is_covered(i - 1, j)) and (i == n - 1 or is_covered(i + 1, j)):\n                    total_cost += costs[i][j]\n                    router_installed[i][j] = True\n                else:\n                    hub_installed[i][j] = True\n                    total_cost += k\n\n    return total_cost"
    },
    {
        "number": 3090,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    floor_plan = [list(map(int, input().split())) for _ in range(N)]\n\n    def is_valid(i: int, j: int) -> bool:\n        return 0 <= i < N and 0 <= j < M\n\n    def get_connected_cells(i: int, j: int) -> int:\n        connected_cells = 0\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_i, new_j = i + di, j + dj\n            if is_valid(new_i, new_j) and floor_plan[new_i][new_j] != 0:\n                connected_cells += 1\n        return connected_cells\n\n    total_cost = 0\n    for i in range(N):\n        for j in range(M):\n            if floor_plan[i][j] != 0:\n                connected_cells = get_connected_cells(i, j)\n                if connected_cells == 1:\n                    total_cost += floor_plan[i][j]\n                elif connected_cells == 0 or connected_cells > 2:\n                    total_cost += K\n\n    return str(total_cost)"
    },
    {
        "number": 3090,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    cost = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def check_corridor(i, j):\n        if i > 0 and cost[i - 1][j] != 0 and cost[i][j] != 0:\n            return False\n        if j > 0 and cost[i][j - 1] != 0 and cost[i][j] != 0:\n            return False\n        if i < n - 1 and cost[i + 1][j] != 0 and cost[i][j] != 0:\n            return False\n        if j < m - 1 and cost[i][j + 1] != 0 and cost[i][j] != 0:\n            return False\n        return True\n\n    total_cost = 0\n    for i in range(n):\n        for j in range(m):\n            if cost[i][j] != 0:\n                if not check_corridor(i, j):\n                    total_cost += k\n            elif cost[i][j] == 0 and not check_corridor(i, j):\n                total_cost += k\n                cost[i][j] = -1  # mark cell with cellular hub\n\n    for i in range(n):\n        for j in range(m):\n            if cost[i][j] > 0:\n                total_cost += cost[i][j]\n\n    return str(total_cost)"
    },
    {
        "number": 3090,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.readline().split())\n    cost_matrix = []\n    for i in range(N):\n        cost_matrix.append(list(map(int, stdin.readline().split())))\n\n    def is_valid(i, j, visited):\n        if 0 <= i < N and 0 <= j < M and not visited[i][j]:\n            return True\n        return False\n\n    def dfs(i, j, visited):\n        visited[i][j] = True\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = i + dx, j + dy\n            if is_valid(nx, ny, visited):\n                dfs(nx, ny, visited)\n\n    def find_islands():\n        visited = [[False for _ in range(M)] for _ in range(N)]\n        islands = []\n        for i in range(N):\n            for j in range(M):\n                if not visited[i][j]:\n                    islands.append(set())\n                    dfs(i, j, visited)\n                    for x in range(N):\n                        for y in range(M):\n                            if visited[x][y]:\n                                islands[-1].add((x, y))\n        return islands\n\n    def check_conflict(islands):\n        for i in range(len(islands)):\n            for j in range(i + 1, len(islands)):\n                if islands[i] & islands[j]:\n                    return True\n        return False\n\n    islands = find_islands()\n    total_cost = 0\n\n    for i in range(len(islands)):\n        total_cost += K * len(islands[i])\n\n    while check_conflict(islands):\n        max_cost = 0\n        max_i = 0\n        for i in range(len(islands)):\n            if len(islands[i]) > max_cost:\n                max_cost = len(islands[i])\n                max_i = i\n\n        max_set = islands[max_i]\n        islands.pop(max_i)\n\n        for i in range(len(islands)):\n            islands[i] -= max_set\n\n        total_cost += K * max_cost\n\n    for i in range(N):\n        for j in range(M):\n            if cost_matrix[i][j] != 0:\n                total_cost += cost_matrix[i][j]\n\n    return str(total_cost) "
    },
    {
        "number": 3090,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N, M, K = map(int, lines[0].split())\n    grid = [list(map(int, line.split())) for line in lines[1:]]\n\n    def is_valid(i, j):\n        return 0 <= i < N and 0 <= j < M\n\n    def get_neighbors(i, j):\n        neighbors = []\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            neighbor_i, neighbor_j = i + di, j + dj\n            if is_valid(neighbor_i, neighbor_j):\n                neighbors.append((neighbor_i, neighbor_j))\n        return neighbors\n\n    def get_connected_components():\n        visited = set()\n        components = []\n        for i in range(N):\n            for j in range(M):\n                if (i, j) not in visited:\n                    visited.add((i, j))\n                    component = [(i, j)]\n                    queue = get_neighbors(i, j)\n                    while queue:\n                        current = queue.pop(0)\n                        if current not in visited:\n                            visited.add(current)\n                            component.append(current)\n                            queue.extend(get_neighbors(*current))\n                    components.append(component)\n        return components\n\n    components = get_connected_components()\n    total_cost = 0\n\n    for component in components:\n        component_cost = [grid[i][j] for i, j in component]\n        component_cost.sort()\n        if len(component_cost) > 2:\n            total_cost += component_cost[0] + component_cost[1] + K\n        elif len(component_cost) == 2:\n            total_cost += component_cost[0] + component_cost[1]\n        else:\n            total_cost += component_cost[0] + K\n\n    return str(total_cost)"
    },
    {
        "number": 3090,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    router_costs = [list(map(int, stdin.split('\\n')[i + 1].split())) for i in range(n)]\n\n    total_cost = 0\n    for i in range(n):\n        for j in range(m):\n            if router_costs[i][j] != 0:\n                if i > 0 and router_costs[i - 1][j] != 0:\n                    total_cost += k\n                if j > 0 and router_costs[i][j - 1] != 0:\n                    total_cost += k\n                if i < n - 1 and router_costs[i + 1][j] != 0:\n                    total_cost += k\n                if j < m - 1 and router_costs[i][j + 1] != 0:\n                    total_cost += k\n\n    for i in range(n):\n        for j in range(m):\n            if router_costs[i][j] != 0:\n                total_cost += router_costs[i][j]\n\n    return str(total_cost)"
    },
    {
        "number": 3090,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_incident_routers(i, j, grid, visited):\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        incident_routers = 0\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < N and 0 <= nj < M and grid[ni][nj] and not visited[ni][nj]:\n                incident_routers += 1\n        return incident_routers\n\n    def dfs(i, j, grid, visited, cost, total_cost):\n        if not (0 <= i < N and 0 <= j < M) or visited[i][j] or not grid[i][j]:\n            return total_cost\n\n        visited[i][j] = True\n        incident_routers = find_incident_routers(i, j, grid, visited)\n        if incident_routers == 0:\n            total_cost += K\n        elif incident_routers == 1:\n            total_cost += cost[i][j]\n        else:\n            total_cost += cost[i][j]\n\n        for di in range(-1, 2):\n            for dj in range(-1, 2):\n                if (di != 0 or dj != 0) and (0 <= i + di < N and 0 <= j + dj < M):\n                    total_cost = dfs(i + di, j + dj, grid, visited, cost, total_cost)\n\n        visited[i][j] = False\n        return total_cost\n\n    stdin_list = stdin.split('\\n')\n    N, M, K = map(int, stdin_list[0].split())\n    cost = [list(map(int, stdin_list[i].split())) for i in range(1, N + 1)]\n\n    visited = [[False for _ in range(M)] for _ in range(N)]\n    total_cost = dfs(0, 0, cost, visited, cost, 0)\n    return str(total_cost) "
    },
    {
        "number": 3090,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.readline().split())\n    cost_matrix = [[int(x) for x in stdin.readline().split()] for _ in range(N)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M\n\n    def find_cost(x, y):\n        cost = cost_matrix[x][y]\n        if cost == 0:\n            return 0\n\n        if x > 0 and cost_matrix[x - 1][y] != 0:\n            return K\n        if y > 0 and cost_matrix[x][y - 1] != 0:\n            return K\n        if x < N - 1 and cost_matrix[x + 1][y] != 0:\n            return K\n        if y < M - 1 and cost_matrix[x][y + 1] != 0:\n            return K\n\n        return cost\n\n    total_cost = 0\n    for i in range(N):\n        for j in range(M):\n            total_cost += find_cost(i, j)\n\n    return total_cost"
    },
    {
        "number": 3091,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, stdin.split())\n    rows = [[] for _ in range(n)]\n    cols = [[] for _ in range(n)]\n    nums = [0] * (n + 1)\n\n    for _ in range(m):\n        r, c = map(int, input().split())\n        rows[r - 1].append(c - 1)\n        cols[c - 1].append(r - 1)\n\n    def helper(r: int, c: int, remain: int) -> int:\n        if remain == 0:\n            return 1\n        if r == n:\n            r, c = 0, c + 1\n\n        if c == n:\n            return 0\n\n        ans = 0\n        for i in range(n):\n            if i not in rows[r] and i not in cols[c]:\n                nums[i + 1] += 1\n                ans += helper(r + 1, c, remain - 1)\n                nums[i + 1] -= 1\n\n        return ans\n\n    return str(helper(0, 0, t))"
    },
    {
        "number": 3091,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, stdin.split()[0].split())\n    grid = []\n    for i in range(1, m + 1):\n        r, c = map(int, stdin.split()[i].split())\n        grid.append((r, c))\n\n    def is_valid(board, row, col, num):\n        for i in range(len(grid)):\n            r, c = grid[i]\n            if board[r][c] == num:\n                return False\n        for i in range(n):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        return True\n\n    def kenken_helper(board, index):\n        if index == len(grid):\n            return 1\n\n        r, c = grid[index]\n        count = 0\n        for num in range(1, n + 1):\n            if is_valid(board, r, c, num):\n                board[r][c] = num\n                count += kenken_helper(board, index + 1)\n                board[r][c] = 0\n\n        return count\n\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    result = kenken_helper(board, 0)\n    return str(result)"
    },
    {
        "number": 3091,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, stdin.split()[0].split())\n    grid_squares = []\n    for i in range(1, m + 1):\n        r, c = map(int, stdin.split()[i].split())\n        grid_squares.append((r, c))\n\n    def is_valid(board: List[List[int]]) -> bool:\n        for row in board:\n            if len(set(row)) != n:\n                return False\n\n        for col in range(n):\n            if len(set(board[row][col] for row in range(n))) != n:\n                return False\n\n        return True\n\n    def helper(board: List[List[int]], index: int) -> int:\n        if index == m:\n            return is_valid(board)\n\n        row, col = grid_squares[index]\n        if op == '-':\n            for i in range(1, n + 1):\n                if i != t and i not in board[row - 1]:\n                    board[row - 1][col - 1] = i\n                    if helper(board, index + 1):\n                        return True\n                    board[row - 1][col - 1] = 0\n            return False\n\n        elif op == '*':\n            for i in range(1, n + 1):\n                if i != t and i not in board[row - 1] and i not in board[:, col - 1]:\n                    board[row - 1][col - 1] = i\n                    if helper(board, index + 1):\n                        return True\n                    board[row - 1][col - 1] = 0\n            return False\n\n        elif op == '+':\n            total = sum(board[row - 1][col - 1] for row, col in grid_squares[:index])\n            for i in range(1, n + 1):\n                if i != t and i not in board[row - 1] and i + total == t:\n                    board[row - 1][col - 1] = i\n                    if helper(board, index + 1):\n                        return True\n                    board[row - 1][col - 1] = 0\n            return False\n\n        else:\n            total = sum(board[row - 1][col - 1] for row, col in grid_squares[:index])\n            for i in range(1, n + 1):\n                if i != t and i not in board[row - 1] and total / i == t:\n                    board[row - 1][col - 1] = i\n                    if helper(board, index + 1):\n                        return True\n                    board[row - 1][col - 1] = 0\n            return False\n\n    board = [[0] * n for _ in range(n)]\n    return helper(board, 0) "
    },
    {
        "number": 3091,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_list = stdin.split('\\n')\n    n, m, t, op = map(int, input_list[0].split())\n    grid_locations = []\n    for i in range(1, m + 1):\n        row, col = map(int, input_list[i].split())\n        grid_locations.append((row, col))\n    \n    # Function to check if a given assignment of digits is valid\n    def is_valid(assignment):\n        # Check if any number appears more than once in any row or column\n        rows = [set() for _ in range(n)]\n        cols = [set() for _ in range(n)]\n        for (row, col), digit in assignment.items():\n            if digit in rows[row] or digit in cols[col]:\n                return False\n            rows[row].add(digit)\n            cols[col].add(digit)\n        \n        # Check if the section's target value can be reached using the numbers and operator\n        section_values = [assignment[loc] for loc in grid_locations]\n        target = t\n        if op == '-':\n            target = section_values[0] - section_values[1]\n        elif op == '*':\n            target = 1\n            for value in section_values:\n                target *= value\n        elif op == '/':\n            target = section_values[0] / section_values[1]\n        \n        return target == int(target)\n    \n    # Function to recursively generate all valid assignments of digits to grid locations\n    def generate_assignments(assignment, remaining_locations):\n        if not remaining_locations:\n            return [assignment]\n        \n        loc = remaining_locations[0]\n        row, col = loc\n        digits = set(range(1, n + 1)) - (rows[row] | cols[col])\n        \n        assignments = []\n        for digit in digits:\n            new_assignment = assignment.copy()\n            new_assignment[loc] = digit\n            assignments += generate_assignments(new_assignment, remaining_locations[1:])\n        \n        return assignments\n    \n    # Initialize rows and columns sets\n    rows = [set() for _ in range(n)]\n    cols = [set() for _ in range(n)]\n    for loc in grid_locations:\n        row, col = loc\n        rows[row].add(0)\n        cols[col].add(0)\n    \n    # Generate all valid assignments of digits to grid locations\n    valid_assignments = generate_assignments({}, grid_locations)\n    \n    # Count the number of valid assignments that satisfy the target value and operator\n    valid_count = 0\n    for assignment in valid_assignments:\n        if is_valid(assignment):\n            valid_count += 1\n    \n    # Output the number of valid ways to fill in the section\n    return str(valid_count) "
    },
    {
        "number": 3091,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, stdin.split()[0].split())\n    grid_locations = list(map(int, stdin.split()[1:]))\n\n    def is_valid(nums):\n        if op == '+':\n            return sum(nums) == t\n        elif op == '-':\n            return nums[0] - nums[1] == t\n        elif op == '*':\n            return nums[0] * nums[1] == t\n        elif op == '/':\n            return nums[0] // nums[1] == t\n\n    def backtrack(start, nums):\n        if len(nums) == m:\n            return is_valid(nums)\n        for i in range(start, n):\n            for j in range(n):\n                if (i, j) not in grid_locations:\n                    nums.append(i + 1)\n                    if is_valid(nums):\n                        if backtrack(j + 1, nums):\n                            return True\n                        nums.pop()\n        return False\n\n    count = 0\n    for i in range(n):\n        nums = [i + 1]\n        if backtrack(0, nums):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3091,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, stdin.split())\n    arr = [list(map(int, input().split())) for _ in range(m)]\n    \n    def is_valid(row, col, num):\n        for i in range(m):\n            r, c = arr[i]\n            if r == row and c == col:\n                continue\n            if r == row or c == col:\n                if num in set(arr[i]):\n                    return False\n            if r == num or c == num:\n                return False\n        return True\n\n    def solve(idx, num):\n        if idx == m:\n            return 1 if eval(str(arr[0][0]) + op + str(arr[1][0])) == t else 0\n        total = 0\n        for num in range(1, n + 1):\n            if is_valid(arr[idx][0], arr[idx][1], num):\n                total += solve(idx + 1, num)\n        return total\n\n    return str(solve(0, 0))"
    },
    {
        "number": 3091,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = list(map(int, stdin.split()[0:4]))\n    grid_locations = []\n    for i in range(m):\n        row, col = list(map(int, stdin.split()[4 + i].split()))\n        grid_locations.append((row, col))\n\n    def is_valid(board: list, row: int, col: int, num: int) -> bool:\n        for i in range(n):\n            if board[i][col] == num:\n                return False\n            if board[row][i] == num:\n                return False\n        return True\n\n    def kenken_solver(board: list, row: int, col: int, remaining_numbers: list) -> int:\n        if row == n - 1 and col == n:\n            return 1\n        if col == n:\n            col = 0\n            row += 1\n\n        if (row, col) not in grid_locations:\n            return kenken_solver(board, row, col + 1, remaining_numbers)\n\n        if not remaining_numbers:\n            return 0\n\n        count = 0\n        for num in remaining_numbers:\n            if is_valid(board, row, col, num):\n                board[row][col] = num\n                new_remaining_numbers = remaining_numbers.copy()\n                new_remaining_numbers.remove(num)\n                count += kenken_solver(board, row, col + 1, new_remaining_numbers)\n                board[row][col] = 0\n\n        return count\n\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    if op == '-':\n        for i in range(m):\n            for j in range(i):\n                if grid_locations[i][1] == grid_locations[j][1]:\n                    board[grid_locations[i][0]][grid_locations[i][1]] = t\n                    board[grid_locations[j][0]][grid_locations[j][1]] = t - 1\n                    break\n        return kenken_solver(board, 0, 1, list(range(1, n)))\n    elif op == '+':\n        for i in range(m):\n            for j in range(i):\n                if grid_locations[i][1] == grid_locations[j][1]:\n                    board[grid_locations[i][0]][grid_locations[i][1]] = t - 1\n                    board[grid_locations[j][0]][grid_locations[j][1]] = 1\n                    return kenken_solver(board, 0, 1, list(range(2, n - 1)))\n    elif op == '*':\n        for i in range(m):\n            for j in range(i):\n                if grid_locations[i][1] == grid_locations[j][1]:\n                    board[grid_locations[i][0]][grid_locations[i][1]] = t\n                    board[grid_locations[j][0]][grid_locations[j][1]] = 1\n                    return kenken_solver(board, 0, 1, list(range(2, n - 1)))\n    elif op == '/':\n        for i in range(m):\n            for j in range(i):\n                if grid_locations[i][1] == grid_locations[j][1]:\n                    board[grid_locations[i][0]][grid_locations[i][1]] = t\n                    board[grid_locations[j][0]][grid_locations[j][1]] = t * (t - 1)\n                    return kenken_solver(board, 0, 1, list(range(2, n - 1)))\n\n    return kenken_solver(board, 0, 1, list(range(1, n)))"
    },
    {
        "number": 3091,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(str, stdin.split()))\n    n, m, t, op = int(input_data[0]), int(input_data[1]), int(input_data[2]), input_data[3]\n    grid_locations = [(int(input_data[4*i+4]), int(input_data[4*i+5])) for i in range(m)]\n    \n    def is_valid(assignment, grid_location):\n        row, col = grid_location\n        return assignment[row-1] not in [assignment[i] for i in range(n) if (i//n, i%n) != (row-1, col-1)] and \\\n            assignment[col-1] not in [assignment[i] for i in range(n*n) if (i//n, i%n) != (row-1, col-1)]\n    \n    def helper(assignment, index):\n        if index == len(assignment):\n            return 1\n        row, col = grid_locations[index]\n        count = 0\n        for i in range(1, n+1):\n            if is_valid(assignment[:index] + [i] + assignment[index+1:], (row, col)):\n                count += helper(assignment[:index] + [i] + assignment[index+1:], index+1)\n        return count\n    \n    return str(helper([0]*m, 0))"
    },
    {
        "number": 3091,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    n, m, t, op = map(str, input_data[0].split())\n    n, m, t = int(n), int(m), int(t)\n    grid_locations = []\n    for i in range(1, m + 1):\n        row, col = map(int, input_data[i].split())\n        grid_locations.append((row - 1, col - 1))\n\n    if op == '+':\n        return count_addition_solutions(n, grid_locations, t)\n    elif op == '-':\n        return count_subtraction_solutions(n, grid_locations, t)\n    elif op == '*':\n        return count_multiplication_solutions(n, grid_locations, t)\n    else:\n        return count_division_solutions(n, grid_locations, t)\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = list(map(str, stdin.split()))\n    n, m, t = int(n), int(m), int(t)\n    grid_squares = []\n    for _ in range(m):\n        row, col = list(map(int, input().split()))\n        grid_squares.append((row - 1, col - 1))\n\n    def is_valid(board: list, row: int, col: int, num: int) -> bool:\n        for i in range(n):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        return True\n\n    def kenken_helper(board: list, row: int) -> int:\n        if row == n:\n            return 1 if sum(board[0]) == t else 0\n        count = 0\n        for num in range(1, n + 1):\n            if is_valid(board, row, 0, num):\n                board[row][0] = num\n                count += kenken_helper(board, row + 1)\n        return count\n\n    board = [[0] * m for _ in range(n)]\n    result = kenken_helper(board, 0)\n    return str(result) "
    },
    {
        "number": 3092,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def modulo_sum(a, b):\n        return (a + b) % 1000000007\n\n    def dijkstra(start_city, target_city, road_lengths):\n        n = len(road_lengths)\n        visited = [False] * n\n        distances = [float('inf')] * n\n        distances[start_city - 1] = 0\n        shortest_paths = [0] * n\n        shortest_paths[start_city - 1] = 1\n\n        while not all(visited):\n            min_distance = float('inf')\n            min_index = -1\n            for i in range(n):\n                if not visited[i] and distances[i] < min_distance:\n                    min_distance = distances[i]\n                    min_index = i\n\n            if min_index == -1:\n                break\n\n            visited[min_index] = True\n            for i in range(n):\n                if not visited[i] and road_lengths[min_index][i] != -1:\n                    new_distance = distances[min_index] + road_lengths[min_index][i]\n                    if new_distance < distances[i]:\n                        distances[i] = new_distance\n                        if distances[i] == distances[target_city - 1]:\n                            shortest_paths[i] = shortest_paths[min_index]\n                        else:\n                            shortest_paths[i] = 0\n                    elif distances[i] == distances[min_index]:\n                        shortest_paths[i] = modulo_sum(shortest_paths[i], shortest_paths[min_index])\n\n        return shortest_paths[target_city - 1]\n\n    input_data = list(map(str, stdin.split('\\n')))\n    num_cities, num_roads = map(int, input_data[0].split())\n    road_lengths = [[-1] * num_cities for _ in range(num_cities)]\n\n    for i in range(num_roads):\n        origin, destination, length = map(int, input_data[i + 1].split())\n        road_lengths[origin - 1][destination - 1] = length\n\n    result = []\n    for i in range(num_roads):\n        origin, destination, length = map(int, input_data[i + 1].split())\n        num_shortest_paths = dijkstra(origin, destination, road_lengths)\n        result.append(num_shortest_paths)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3092,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_paths(n, m, edges):\n        graph = [[0] * n for _ in range(n)]\n        for edge in edges:\n            graph[edge[0] - 1][edge[1] - 1] = edge[2]\n\n        dp = [[0] * n for _ in range(1 << n)]\n        dp[0][0] = 1\n\n        for mask in range(1, 1 << n):\n            for u in range(n):\n                if mask & (1 << u) == 0:\n                    continue\n                for v in range(n):\n                    if u == v or mask & (1 << v) == 0:\n                        continue\n                    if graph[u][v] == 0:\n                        continue\n                    dp[mask | (1 << v)][v] += dp[mask][u]\n\n        return dp\n\n    def count_shortest_paths_containing_edge(n, m, edges, shortest_paths):\n        counts = [0] * m\n        for i, edge in enumerate(edges):\n            counts[i] = shortest_paths[1 << (edge[1] - 1)][edge[0] - 1]\n        return counts\n\n    def main():\n        n, m = map(int, stdin.readline().split())\n        edges = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n        shortest_paths = find_shortest_paths(n, m, edges)\n        counts = count_shortest_paths_containing_edge(n, m, edges, shortest_paths)\n\n        for count in counts:\n            print(count % 1000000007)\n\n    main()\n"
    },
    {
        "number": 3092,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_paths(graph, start, end, visited=None, path=None):\n        if visited is None:\n            visited = set()\n        if path is None:\n            path = [start]\n\n        if start == end:\n            return [path]\n\n        paths = []\n        for node in graph[start]:\n            if node not in visited:\n                new_path = path + [node]\n                visited.add(node)\n                sub_paths = find_shortest_paths(graph, node, end, visited, new_path)\n                paths.extend(sub_paths)\n                visited.remove(node)\n\n        return paths\n\n    def count_shortest_paths(graph, start, end, modulo=1000000007):\n        shortest_paths = find_shortest_paths(graph, start, end)\n        return len(shortest_paths) % modulo\n\n    lines = stdin.strip().split('\\n')\n    N, M = map(int, lines[0].split())\n\n    graph = {i: [] for i in range(1, N + 1)}\n    for i in range(M):\n        O, D, L = map(int, lines[i + 1].split())\n        graph[O].append(D)\n\n    output = []\n    for i in range(M):\n        O, D, L = map(int, lines[i + 1].split())\n        shortest_paths = count_shortest_paths(graph, O, D)\n        output.append(shortest_paths)\n\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3092,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(src, dst, dist, visited, graph):\n        if src == dst:\n            return 1\n        if src not in visited:\n            visited.add(src)\n            paths = 0\n            for neighbor in graph[src]:\n                if neighbor not in visited:\n                    paths += dfs(neighbor, dst, dist, visited, graph)\n            visited.remove(src)\n            return paths\n        return 0\n\n    def shortest_paths(src, dst, dist, graph):\n        paths = dfs(src, dst, dist, set(), graph)\n        return paths\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    roads = [list(map(int, line.split())) for line in lines[1:]]\n    graph = {i: [] for i in range(1, N + 1)}\n    for i in range(M):\n        O, D, L = roads[i]\n        graph[O].append(D)\n\n    result = []\n    for i in range(M):\n        O, D, L = roads[i]\n        paths = shortest_paths(1, N, 0, graph)\n        result.append(paths)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3092,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_continuation(e, f):\n        if e[1] == f[0]:\n            return True\n        return False\n\n    def shortest_paths(n, m, edges):\n        shortest_path = []\n        for i in range(n):\n            shortest_path.append([0] * n)\n            shortest_path[i][i] = 1\n\n        for i in range(m):\n            for j in range(n):\n                for k in range(n):\n                    if j != k and shortest_path[j][i] and shortest_path[i][k]:\n                        for e in edges:\n                            if e[0] == i and e[1] == k:\n                                edges.remove(e)\n                                shortest_path[j][k] += shortest_path[j][i] * shortest_path[i][k]\n                                edges.append(e)\n                                break\n\n        return shortest_path\n\n    def shortest_path_count(n, m, edges, shortest_path):\n        shortest_path_count = [0] * m\n        for i in range(m):\n            for j in range(n):\n                for k in range(n):\n                    if j != k and shortest_path[j][i] and shortest_path[i][k]:\n                        for e in edges:\n                            if e[0] == i and e[1] == k:\n                                edges.remove(e)\n                                shortest_path_count[i] += shortest_path[j][i] * shortest_path[i][k]\n                                edges.append(e)\n                                break\n\n        return shortest_path_count\n\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    edges = []\n    for i in range(1, m + 1):\n        o, d, l = map(int, lines[i].split())\n        edges.append((o, d, l))\n\n    shortest_path = shortest_paths(n, m, edges)\n    shortest_path_count = shortest_path_count(n, m, edges, shortest_path)\n\n    return \"\\n\".join(map(lambda x: str(x % 1000000007), shortest_path_count))"
    },
    {
        "number": 3092,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, modulo):\n        n = len(graph)\n        dist = [float(\"inf\")] * n\n        dist[start] = 0\n        queue = [(0, start)]\n\n        while queue:\n            d, node = heapq.heappop(queue)\n            if d > dist[node]:\n                continue\n            for neighbor, length in graph[node].items():\n                new_dist = dist[node] + length\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(queue, (new_dist, neighbor))\n\n        return [dist[i] % modulo for i in range(n)]\n\n    def shortest_paths(graph, start, end, modulo):\n        n = len(graph)\n        dist = dijkstra(graph, start, modulo)\n        shortest_path = dist[end]\n        paths_count = 1 if shortest_path > 0 else 0\n\n        for i in range(n):\n            for j in range(n):\n                if i != j and j in graph[i] and j in graph[j]:\n                    graph[i][j] += graph[j][i]\n                    graph[j].pop(i)\n\n        for i in range(n):\n            if i != start and i != end:\n                dist = dijkstra(graph, i, modulo)\n                if dist[start] != float(\"inf\") and dist[end] != float(\"inf\"):\n                    new_shortest_path = dist[start] + shortest_path + dist[end]\n                    if new_shortest_path % modulo == shortest_path % modulo:\n                        paths_count += 1\n\n        return paths_count\n\n    lines = stdin.split(\"\\n\")\n    params = list(map(int, lines[0].split()))\n    n, m = params[0], params[1]\n    graph = {i: {} for i in range(1, n + 1)}\n\n    for i in range(1, m + 1):\n        line = lines[i]\n        params = list(map(int, line.split()))\n        origin, destination, length = params[0], params[1], params[2]\n        graph[origin][destination] = length\n\n    result = []\n    for i in range(1, m + 1):\n        line = lines[i]\n        params = list(map(int, line.split()))\n        origin, destination, length = params[0], params[1], params[2]\n        result.append(shortest_paths(graph, origin, destination, 1000000007))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3092,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n\n    roads = [list(map(int, line.split())) for line in lines[1:]]\n    paths = [0] * M\n    modulo = 1000000007\n\n    def find_shortest_paths(origin, destination, length):\n        shortest_path = [0] * N\n        shortest_path[origin - 1] = length\n\n        for i in range(N):\n            for j in range(M):\n                if roads[j][0] == i + 1:\n                    if shortest_path[i] == 0:\n                        shortest_path[roads[j][1] - 1] = roads[j][2]\n                    else:\n                        shortest_path[roads[j][1] - 1] = min(shortest_path[roads[j][1] - 1], shortest_path[i] + roads[j][2])\n\n        return shortest_path[destination - 1]\n\n    for i in range(M):\n        origin, destination, length = roads[i]\n        shortest_length = find_shortest_paths(origin, destination, length)\n\n        for j in range(M):\n            if i != j:\n                other_origin, other_destination, other_length = roads[j]\n                if other_origin == origin and other_destination == destination:\n                    other_shortest_length = find_shortest_paths(other_origin, other_destination, other_length)\n                    if other_shortest_length == shortest_length:\n                        paths[i] += 1\n                elif other_origin == destination and other_destination == origin:\n                    other_shortest_length = find_shortest_paths(other_destination, other_origin, other_length)\n                    if other_shortest_length == shortest_length:\n                        paths[i] += 1\n\n        paths[i] = paths[i] % modulo\n\n    return '\\n'.join(str(x) for x in paths)"
    },
    {
        "number": 3092,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_modulo_sum(a: int, b: int) -> int:\n        return (a + b) % 1000000007\n\n    def get_shortest_paths(graph: dict, start: int, end: int, visited: set, shortest_paths: list) -> None:\n        if start == end:\n            shortest_paths.append(1)\n            return\n\n        visited.add(start)\n        for neighbor, length in graph[start]:\n            if neighbor not in visited:\n                get_shortest_paths(graph, neighbor, end, visited, shortest_paths)\n\n        visited.remove(start)\n\n    input_list = list(map(int, stdin.split()))\n    N, M = input_list[0], input_list[1]\n    input_list = input_list[2:]\n\n    graph = {i: [] for i in range(1, N + 1)}\n    for i in range(M):\n        origin, destination, length = input_list[i * 3], input_list[i * 3 + 1], input_list[i * 3 + 2]\n        graph[origin].append((destination, length))\n\n    shortest_paths_count = [0] * M\n    for i in range(M):\n        origin, destination, length = input_list[i * 3], input_list[i * 3 + 1], input_list[i * 3 + 2]\n        shortest_paths = []\n        get_shortest_paths(graph, origin, destination, set(), shortest_paths)\n        shortest_paths_count[i] = get_modulo_sum(shortest_paths_count[i], len(shortest_paths))\n\n    return \"\\n\".join(map(str, shortest_paths_count))"
    },
    {
        "number": 3092,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def build_graph(N, M, edges):\n        graph = [[] for _ in range(N + 1)]\n        for edge in edges:\n            origin, destination, length = edge\n            graph[origin].append((destination, length))\n        return graph\n\n    def shortest_paths(graph, N, modulo):\n        dp = [[0] * (N + 1) for _ in range(N + 1)]\n        for i in range(1, N + 1):\n            dp[i][i] = 1\n\n        for length in range(1, N + 1):\n            for origin in range(1, N + 1):\n                for destination, edge_length in graph[origin]:\n                    if length - edge_length >= 0:\n                        dp[origin][destination] += dp[origin][length - edge_length]\n                        dp[origin][destination] %= modulo\n\n        return dp\n\n    def count_paths_containing_edge(graph, N, M, modulo):\n        shortest = shortest_paths(graph, N, modulo)\n        path_count = [0] * M\n\n        for i, edge in enumerate(graph):\n            origin, destination, length = edge\n            path_count[i] = (shortest[origin][destination] - 1) % modulo\n\n        return path_count\n\n    N, M = map(int, stdin.readline().split())\n    edges = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    graph = build_graph(N, M, edges)\n    modulo = 1000000007\n    result = count_paths_containing_edge(graph, N, M, modulo)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3092,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def build_graph(N: int, M: int, roads: list) -> dict:\n        graph = {i: [] for i in range(1, N + 1)}\n        for origin, destination, length in roads:\n            graph[origin].append((destination, length))\n        return graph\n\n    def shortest_paths(graph: dict, N: int, modulo: int = 1000000007) -> list:\n        paths = {i: [] for i in range(1, N + 1)}\n        paths[1].append(0)\n\n        for i in range(1, N + 1):\n            for j in graph[i]:\n                destination, length = j\n                for path_length in paths[i]:\n                    new_path_length = (path_length + length) % modulo\n                    paths[destination].append(new_path_length)\n\n        return paths\n\n    def count_shortest_paths(graph: dict, shortest_path_lengths: dict, N: int, M: int) -> list:\n        shortest_path_counts = []\n\n        for i in range(M):\n            origin, destination, length = roads[i]\n            shortest_path_count = 0\n            for path_length in shortest_path_lengths[destination]:\n                if path_length == (shortest_path_lengths[origin] + length) % 1000000007:\n                    shortest_path_count += 1\n            shortest_path_counts.append(shortest_path_count)\n\n        return shortest_path_counts\n\n    N, M = map(int, stdin.readline().split())\n    roads = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    graph = build_graph(N, M, roads)\n    shortest_path_lengths = shortest_paths(graph, N)\n    shortest_path_counts = count_shortest_paths(graph, shortest_path_lengths, N, M)\n\n    return \"\\n\".join(map(str, shortest_path_counts)) + \"\\n\""
    },
    {
        "number": 3093,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def factorial(n):\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    N, K = map(int, stdin.split()[0].split(\" \"))\n    f = list(map(int, stdin.split()[1].split(\" \")))\n\n    color_combinations = factorial(K)\n    repeated_colors = [0] * (N + 1)\n\n    for i in range(1, N + 1):\n        if i not in f:\n            repeated_colors[i] += 1\n        elif f[i - 1] != i:\n            repeated_colors[f[i - 1]] += 1\n\n    for color in repeated_colors:\n        if color > 0:\n            color_combinations //= factorial(color)\n\n    return str(color_combinations % 1000000007)"
    },
    {
        "number": 3093,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def nCr(n, r):\n        if r > n:\n            return 0\n        r = min(r, n - r)\n        numerator = 1\n        denominator = 1\n        for i in range(1, r + 1):\n            numerator *= n - r + i\n            denominator *= i\n        return numerator // denominator\n\n    N, K = map(int, stdin.split()[0].split())\n    f = list(map(int, stdin.split()[1].split()))\n\n    total_ways = 1\n    modulo = 1000000007\n\n    for k in range(1, K + 1):\n        unique_images = set()\n        for i in range(N):\n            if i not in unique_images and f[i] != i:\n                unique_images.add(i)\n                unique_images.add(f[i])\n        total_ways = (total_ways * nCr(K - 1, len(unique_images) - 1)) % modulo\n\n    return str(total_ways)"
    },
    {
        "number": 3093,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n\n    def power(a, n, modulo=1000000007):\n        if n == 0:\n            return 1\n        if n % 2 == 0:\n            return power(a, n // 2, modulo) * power(a, n // 2, modulo) % modulo\n        return a * power(a, n - 1, modulo) % modulo\n\n    def calculate_permutations(n, k):\n        return factorial(n) // factorial(n - k)\n\n    input_data = list(map(int, stdin.split()))\n    n, k = input_data[0], input_data[1]\n    f = input_data[2:]\n\n    possible_ways = k\n    for i in range(n):\n        if f[i] != i + 1:\n            possible_ways = (possible_ways * (k - 1)) % 1000000007\n\n    result = power(possible_ways, n)\n    for i in range(n):\n        if f[i] != i + 1:\n            result = (result * calculate_permutations(n - 1, k - 1)) % 1000000007\n\n    return str(result) "
    },
    {
        "number": 3093,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    f = list(map(int, stdin.readline().split()))\n\n    mod = 1000000007\n    dp = [[0] * k for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k):\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][(j - f[i - 1]) % k]) % mod\n\n    return str(dp[n][0])\n"
    },
    {
        "number": 3093,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    f = list(map(int, stdin.readline().split()))\n    dp = [[0] * K for _ in range(N)]\n    MOD = 1000000007\n\n    for i in range(N):\n        dp[i][0] = 1\n\n    for i in range(N):\n        for j in range(K):\n            if i == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][(j - f[i - 1]) % K] + dp[i - 1][(j + f[i - 1]) % K]) % MOD\n\n    return str(sum(dp[-1]) % MOD)\n"
    },
    {
        "number": 3093,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def fast_pow(base, exponent, modulus):\n        result = 1\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % modulus\n            base = (base * base) % modulus\n            exponent //= 2\n        return result\n\n    lines = stdin.splitlines()\n    N, K = map(int, lines[0].split())\n    f = list(map(int, lines[1].split()))\n\n    dp = [0] * N\n    dp[0] = K\n\n    for i in range(1, N):\n        dp[i] = (K - 1) * dp[i - 1] + dp[i - 1]\n        dp[i] %= 1000000007\n\n    result = dp[N - 1]\n    for i in range(1, N):\n        if f[i] == i:\n            result += dp[i - 1] * K\n        elif f[i] != i and f[i] != i - 1:\n            result += dp[i - 1] * K * fast_pow(K - 1, N - i - 1, 1000000007)\n        result %= 1000000007\n\n    return str(result) "
    },
    {
        "number": 3093,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    f = list(map(int, stdin.split()[2:]))\n    modulo = 1000000007\n\n    dp = [[0] * K for _ in range(N + 1)]\n    dp[0] = [1] * K\n\n    for i in range(1, N + 1):\n        for color in range(K):\n            dp[i][color] = (dp[i - 1][color] + dp[i - 1][color ^ 1]) % modulo\n\n        if f[i - 1] != i:\n            for color in range(K):\n                dp[i][color] = (dp[i][color] - dp[i - 1][color]) % modulo\n\n    return sum(dp[N]) % modulo"
    },
    {
        "number": 3093,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    f = list(map(int, stdin.readline().split()))\n    MOD = 1000000007\n    dp = [0] * N\n    dp[0] = K\n    for i in range(1, N):\n        if f[i] != i:\n            dp[i] = dp[i - 1] * (K - 1)\n            dp[i] %= MOD\n        else:\n            dp[i] = dp[i - 1] * K\n            dp[i] %= MOD\n    return dp[N - 1] "
    },
    {
        "number": 3093,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    f = list(map(int, stdin.readline().split()))\n\n    mod = 1000000007\n    dp = [0] * (N + 1)\n    dp[1] = K\n\n    for i in range(2, N + 1):\n        dp[i] = (dp[i - 1] * (K - 1) + dp[i - 1] * (K - 1) + dp[i - 1] * (K - 1)) % mod\n        if f[i - 1] == i:\n            dp[i] = (dp[i] + dp[i - 1] * K) % mod\n\n    return str(dp[N] - dp[N - 1])"
    },
    {
        "number": 3093,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_factorial(n: int, memo: dict) -> int:\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return 1\n        memo[n] = n * get_factorial(n - 1, memo)\n        return memo[n]\n\n    def get_modular_factorial(n: int, modulo: int) -> int:\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % modulo\n        return result\n\n    def get_combination(n: int, r: int, memo: dict) -> int:\n        if r > n:\n            return 0\n        return get_factorial(n, memo) // (get_factorial(r, memo) * get_factorial(n - r, memo))\n\n    def get_modular_combination(n: int, r: int, modulo: int) -> int:\n        if r > n:\n            return 0\n        return get_modular_factorial(n, modulo) * pow(get_modular_factorial(r, modulo) * get_modular_factorial(n - r, modulo), modulo - 2, modulo)\n\n    N, K = map(int, stdin.readline().split())\n    f = list(map(int, stdin.readline().split()))\n\n    modulo = 1000000007\n\n    memo = {}\n    total_ways = 1\n\n    for i in range(1, N + 1):\n        count = 0\n        for j in range(1, K + 1):\n            if i != f[i - 1] or j == i:\n                count += get_modular_combination(K - 1, j - 1, modulo)\n        total_ways = (total_ways * count) % modulo\n\n    return str(total_ways)"
    },
    {
        "number": 3094,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    t = list(map(int, stdin.split(\"\\n\")[1].split()))\n    s = [0] * n\n    mod = 10**9 + 7\n\n    def dfs(i):\n        if i == n:\n            return 1\n        if s[i] != 0:\n            return dfs(i + 1)\n        ans = 0\n        for j in range(1, n + 1):\n            if j not in s[:i] and j != t[i]:\n                s[i] = j\n                ans += dfs(i + 1)\n                ans %= mod\n                s[i] = 0\n        return ans\n\n    return str(dfs(0))"
    },
    {
        "number": 3094,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def factorial(n, memo):\n        if n == 0 or n == 1:\n            return 1\n        if n not in memo:\n            memo[n] = n * factorial(n - 1, memo)\n        return memo[n]\n\n    def count_permutations(n: int, s: List[int]) -> int:\n        memo = {}\n        total = factorial(n, memo)\n        repeated = 1\n        for i in range(n):\n            if s.count(i) > 1:\n                repeated *= factorial(s.count(i), memo)\n        return total // repeated\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    t = list(map(int, lines[1].split()))\n\n    s = [0] * n\n    for i in range(n):\n        s[i] = t[i] - 1\n\n    return str(count_permutations(n, s))"
    },
    {
        "number": 3094,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def compute_permutations(n: int, s: List[int]) -> int:\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n\n        for l in range(2, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                for k in range(i, j + 1):\n                    if k == i:\n                        dp[i][j] += dp[k + 1][j]\n                    elif k == j:\n                        dp[i][j] += dp[i][k - 1]\n                    else:\n                        dp[i][j] += dp[i][k - 1] + dp[k + 1][j]\n                        dp[i][j] -= dp[i][k - 1] * dp[k + 1][j] // (k - i)\n\n        ans = 1\n        for i in range(n):\n            ans *= dp[0][s[i] - 1]\n            ans %= 10**9 + 7\n\n        return ans\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    t = list(map(int, lines[1].split()))\n    s = [i + 1 for i in range(n)]\n\n    return str(compute_permutations(n, s))"
    },
    {
        "number": 3094,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    t = list(map(int, stdin.split('\\n')[1].split()))\n\n    mod = 10**9 + 7\n\n    def factorial(n, memo={}):\n        if n == 0:\n            return 1\n        if n not in memo:\n            memo[n] = n * factorial(n - 1, memo)\n        return memo[n]\n\n    def choose(n, k, memo={}):\n        if k == 0 or k == n:\n            return 1\n        if n - k < k:\n            return choose(n, n - k, memo)\n        if (n, k) not in memo:\n            memo[n, k] = (choose(n - 1, k - 1, memo) * n) // k\n        return memo[n, k]\n\n    total = factorial(n)\n    repeated = 0\n\n    for i in range(n):\n        if t[i] != i + 1:\n            repeated += 1\n\n    repeated //= 2\n\n    total //= factorial(repeated) * choose(n - repeated, repeated)\n\n    return str(total % mod)"
    },
    {
        "number": 3094,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def factorial(n, modulo=10**9 + 7):\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = (fact[i - 1] * i) % modulo\n        return fact\n\n    def inv(n, modulo=10**9 + 7):\n        inv = [1] * (n + 1)\n        inv[1] = 1\n        for i in range(2, n + 1):\n            inv[i] = (modulo - (modulo // i) * inv[modulo % i]) % modulo\n        return inv\n\n    n = int(stdin.readline().strip())\n    t = list(map(int, stdin.readline().strip().split()))\n\n    fact = factorial(n)\n    inv_fact = inv(n)\n\n    total = 0\n    for i in range(1, n + 1):\n        s = t.index(i) + 1\n        total += fact[n - 1] * inv_fact[s - 1] * inv_fact[n - s]\n        t[s - 1], t[i - 1] = t[i - 1], t[s - 1]\n\n    return str(total % (10**9 + 7))"
    },
    {
        "number": 3094,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    t = list(map(int, input().split()))\n    mod = 10**9 + 7\n\n    # initialize the answer with 1\n    answer = 1\n\n    # iterate through each chair and check if it is filled\n    for i in range(1, n + 1):\n        # if the current chair is not filled, skip to the next chair\n        if t[i - 1] != i:\n            continue\n\n        # find the next chair that needs to be filled\n        j = i\n        while j <= n and t[j - 1] == j:\n            j += 1\n\n        # if the next chair is not found, skip to the next chair\n        if j > n:\n            continue\n\n        # update the answer with the number of ways to choose the value for the current chair\n        answer *= j - i + 1\n        answer %= mod\n\n    return str(answer)"
    },
    {
        "number": 3094,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, s_values = map(int, stdin.split())\n    s_values = sorted(s_values)\n\n    modulo = 10**9 + 7\n    factorials = [1] * (n + 1)\n    inverse_factorials = [1] * (n + 1)\n\n    for i in range(1, n + 1):\n        factorials[i] = (factorials[i - 1] * i) % modulo\n        inverse_factorials[i] = pow(factorials[i], modulo - 2, modulo)\n\n    permutations = 1\n    for i in range(1, n + 1):\n        permutations = (permutations * factorials[n - i]) % modulo\n\n    result = permutations * inverse_factorials[n] % modulo\n\n    for i in range(1, n):\n        if s_values[i] == s_values[i - 1]:\n            result = (result * (factorials[n - i] * inverse_factorials[i]) % modulo)\n\n    return str(result)"
    },
    {
        "number": 3094,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def factorial(n):\n        if n == 0 or n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    def find_permutation(n, t):\n        perm = 1\n        for i in range(n - 1, -1, -1):\n            if i == n - 1:\n                perm = perm * factorial(t[i] - 1)\n            else:\n                perm = perm * factorial(t[i] - 1 - i)\n        return perm\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    t = list(map(int, lines[1].split()))\n\n    mod = 10**9 + 7\n    return str(find_permutation(n, t) % mod) "
    },
    {
        "number": 3094,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def modular_inverse(a: int, mod: int) -> int:\n        return pow(a, mod - 2, mod)\n\n    def count_permutations(n: int, k: int) -> int:\n        ans = 1\n        for i in range(k):\n            ans *= n - i\n            ans %= 10**9 + 7\n        return ans\n\n    n = int(stdin.split('\\n')[0])\n    t = list(map(int, stdin.split('\\n')[1].split()))\n\n    s = [0] * n\n    for i in range(n):\n        s[t[i] - 1] = i + 1\n\n    inv = modular_inverse(n, 10**9 + 7)\n    ans = count_permutations(n, n)\n    for i in range(n):\n        if s[i] != i + 1:\n            ans *= inv\n            ans %= 10**9 + 7\n\n    return str(ans)"
    },
    {
        "number": 3094,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def modulo_pow(base, exponent):\n        result = 1\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % modulo\n            base = (base * base) % modulo\n            exponent //= 2\n        return result\n\n    def count_permutations(n):\n        return modulo_pow(n, n - 1)\n\n    def factorial(n):\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % modulo\n        return result\n\n    def inverse_element(n):\n        return modulo_pow(n, modulo - 2)\n\n    modulo = 10**9 + 7\n    n = int(stdin.readline().strip())\n    t = list(map(int, stdin.readline().strip().split()))\n\n    # Calculate the number of ways to choose the values of s_i\n    total_permutations = count_permutations(n)\n    repeated_permutations = 1\n    for i in range(n):\n        if t[i] != i + 1:\n            repeated_permutations = (repeated_permutations * factorial(t.index(i + 1))) % modulo\n            t[t.index(i + 1)], t[i] = t[i], t[t.index(i + 1)]\n\n    result = (total_permutations * inverse_element(repeated_permutations)) % modulo\n\n    return str(result)"
    },
    {
        "number": 3095,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix, r, s):\n        for i in range(1, r):\n            for j in range(1, s):\n                if matrix[i][j] >= matrix[0][j] + matrix[i][0]:\n                    return False\n        return True\n\n    def is_extremely_cool(matrix, r, s):\n        for i in range(2, r):\n            for j in range(2, s):\n                submatrix = [[matrix[k][l] for l in range(j - 1, j + 1)] for k in range(i - 1, i + 1)]\n                if not is_cool(submatrix, 3, 3):\n                    return False\n        return True\n\n    lines = stdin.split('\\n')\n    R, S = map(int, lines[0].split())\n    matrix = [list(map(int, line.split())) for line in lines[1:]]\n\n    if is_extremely_cool(matrix, R, S):\n        return str(R * S)\n    else:\n        return str(0) "
    },
    {
        "number": 3095,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix, r, s):\n        return matrix[0][0] + matrix[r - 1][s - 1] <= matrix[0][s - 1] + matrix[r - 1][0]\n\n    def is_extremely_cool(matrix, r, s):\n        if r < 2 or s < 2:\n            return False\n\n        for i in range(1, r - 1):\n            for j in range(1, s - 1):\n                submatrix = [row[j - 1 : j + 1] for row in matrix[i - 1 : i + 1]]\n                if not is_cool(submatrix, 3, 3):\n                    return False\n        return True\n\n    lines = stdin.splitlines()\n    R, S = map(int, lines[0].split())\n    matrix = [list(map(int, line.split())) for line in lines[1:]]\n\n    max_size = 0\n    for i in range(R - 1):\n        for j in range(S - 1):\n            submatrix = [row[j:j + 2] for row in matrix[i:i + 2]]\n            if is_extremely_cool(submatrix, 2, 2):\n                max_size = max(max_size, 4)\n\n    for i in range(R - 1):\n        for j in range(S - 1):\n            submatrix = [row[j:j + 2] for row in matrix[i:i + 3]]\n            if is_extremely_cool(submatrix, 3, 2):\n                max_size = max(max_size, 6)\n\n    for i in range(R - 1):\n        for j in range(S - 1):\n            submatrix = [row[j:j + 3] for row in matrix[i:i + 2]]\n            if is_extremely_cool(submatrix, 2, 3):\n                max_size = max(max_size, 6)\n\n    for i in range(R - 2):\n        for j in range(S - 2):\n            submatrix = [row[j:j + 3] for row in matrix[i:i + 3]]\n            if is_extremely_cool(submatrix, 3, 3):\n                max_size = max(max_size, 9)\n\n    return str(max_size)"
    },
    {
        "number": 3095,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix, r, s):\n        if r < 2 or s < 2:\n            return False\n        return matrix[0][0] + matrix[r-1][s-1] <= matrix[0][s-1] + matrix[r-1][0]\n\n    def is_extremely_cool(matrix, r, s):\n        if not is_cool(matrix, r, s):\n            return False\n        for i in range(1, r-1):\n            for j in range(1, s-1):\n                submatrix = [row[j-1:j+1] for row in matrix[i-1:i+1]]\n                if not is_cool(submatrix, 2, 2):\n                    return False\n        return True\n\n    def find_largest_submatrix(matrix, r, s):\n        largest_submatrix = 0\n        for i in range(r):\n            for j in range(s):\n                for k in range(i, r):\n                    for l in range(j, s):\n                        submatrix = [row[j:l+1] for row in matrix[i:k+1]]\n                        if is_extremely_cool(submatrix, k-i+1, l-j+1):\n                            largest_submatrix = max(largest_submatrix, (k-i+1) * (l-j+1))\n        return largest_submatrix\n\n    lines = stdin.split('\\n')\n    R, S = map(int, lines[0].split())\n    matrix = [list(map(int, line.split())) for line in lines[1:]]\n\n    return str(find_largest_submatrix(matrix, R, S))"
    },
    {
        "number": 3095,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix, r, s):\n        if r < 2 or s < 2:\n            return False\n        return matrix[0][0] + matrix[r - 1][s - 1] <= matrix[0][s - 1] + matrix[r - 1][0]\n\n    def is_extremely_cool(matrix, r, s):\n        for i in range(1, r):\n            for j in range(1, s):\n                if not is_cool(matrix, i, j):\n                    return False\n        return True\n\n    def find_largest_extremely_cool_submatrix(matrix, r, s):\n        max_size = 0\n        for i in range(r):\n            for j in range(s):\n                for k in range(i, r):\n                    for l in range(j, s):\n                        submatrix = [row[j:l + 1] for row in matrix[i:k + 1]]\n                        if is_extremely_cool(submatrix, k - i + 1, l - j + 1):\n                            max_size = max(max_size, (k - i + 1) * (l - j + 1))\n        return max_size\n\n    lines = stdin.split('\\n')\n    R, S = map(int, lines[0].split())\n    matrix = [list(map(int, line.split())) for line in lines[1:]]\n\n    return str(find_largest_extremely_cool_submatrix(matrix, R, S))"
    },
    {
        "number": 3095,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix, r, s):\n        for i in range(1, r):\n            for j in range(1, s):\n                if not matrix[i][j]:\n                    continue\n                if matrix[i][j] != matrix[0][j] + matrix[i][0] - matrix[0][0]:\n                    return False\n        return True\n\n    def is_extremely_cool(matrix, r, s):\n        for i in range(r - 1):\n            for j in range(s - 1):\n                submatrix = [row[j:j + 2] for row in matrix[i:i + 2]]\n                if not is_cool(submatrix, 2, 2):\n                    return False\n        return True\n\n    def max_elements_in_extremely_cool_submatrix(matrix, r, s):\n        if not is_extremely_cool(matrix, r, s):\n            return 0\n\n        max_elements = 0\n        for i in range(r):\n            for j in range(s):\n                submatrix = [row[j:] for row in matrix[i:]]\n                max_elements = max(max_elements, len(submatrix) * len(submatrix[0]))\n\n        return max_elements\n\n    lines = stdin.strip().split('\\n')\n    R, S = map(int, lines[0].strip().split())\n    matrix = [list(map(int, line.strip().split())) for line in lines[1:]]\n\n    return str(max_elements_in_extremely_cool_submatrix(matrix, R, S))"
    },
    {
        "number": 3095,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix, r, s):\n        return matrix[0][0] + matrix[r - 1][s - 1] <= matrix[0][s - 1] + matrix[r - 1][0]\n\n    def is_extremely_cool(matrix, r, s):\n        if r < 2 or s < 2:\n            return False\n        for i in range(1, r):\n            for j in range(1, s):\n                submatrix = [row[j - 1 :] for row in matrix[:i]] + [row[j - 1 :] for row in matrix[i:]]\n                if not is_cool(submatrix, len(submatrix), len(submatrix[0])):\n                    return False\n        return True\n\n    lines = stdin.splitlines()\n    R, S = map(int, lines[0].split())\n    matrix = [list(map(int, line.split())) for line in lines[1:]]\n\n    max_elements = 0\n    for i in range(R):\n        for j in range(S):\n            for k in range(i + 1, R + 1):\n                for l in range(j + 1, S + 1):\n                    submatrix = [row[j:l] for row in matrix[i:k]]\n                    if is_extremely_cool(submatrix, k - i, l - j):\n                        max_elements = max(max_elements, (k - i) * (l - j))\n\n    return str(max_elements)"
    },
    {
        "number": 3095,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix, row, col):\n        r, s = len(matrix), len(matrix[0])\n        return matrix[0][0] + matrix[r - 1][s - 1] <= matrix[0][s - 1] + matrix[r - 1][0]\n\n    def is_extremely_cool(matrix):\n        if len(matrix) < 2 or len(matrix[0]) < 2:\n            return False\n        return all(is_cool(matrix, i, j) for i in range(len(matrix) - 1) for j in range(len(matrix[0]) - 1))\n\n    def find_extremely_cool_submatrices(matrix):\n        submatrices = []\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                for r in range(i, len(matrix)):\n                    for s in range(j, len(matrix[0])):\n                        submatrix = [row[j:s + 1] for row in matrix[i:r + 1]]\n                        if is_extremely_cool(submatrix):\n                            submatrices.append(submatrix)\n        return submatrices\n\n    def max_elements_in_submatrices(submatrices):\n        return max(sum(sum(submatrix) for submatrix in submatrices) if submatrices else 0)\n\n    R, S = map(int, stdin.readline().split())\n    matrix = [list(map(int, stdin.readline().split())) for _ in range(R)]\n\n    submatrices = find_extremely_cool_submatrices(matrix)\n    return str(max_elements_in_submatrices(submatrices))"
    },
    {
        "number": 3095,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix):\n        rows = len(matrix)\n        cols = len(matrix[0])\n        for i in range(1, rows):\n            for j in range(1, cols):\n                if not (matrix[0][0] + matrix[i][j] <= matrix[0][j] + matrix[i][0]):\n                    return False\n        return True\n\n    def is_extremely_cool(matrix):\n        rows = len(matrix)\n        cols = len(matrix[0])\n        if rows < 2 or cols < 2:\n            return False\n        for i in range(rows - 1):\n            for j in range(cols - 1):\n                submatrix = [row[j:j + 2] for row in matrix[i:i + 2]]\n                if not is_cool(submatrix):\n                    return False\n        return True\n\n    def max_elements_in_extremely_cool_submatrix(matrix):\n        max_elements = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                for k in range(i, len(matrix)):\n                    for l in range(j, len(matrix[0])):\n                        submatrix = [row[j:l + 1] for row in matrix[i:k + 1]]\n                        if is_extremely_cool(submatrix):\n                            max_elements = max(max_elements, (k - i + 1) * (l - j + 1))\n        return max_elements\n\n    lines = stdin.strip().split('\\n')\n    rows, cols = map(int, lines[0].split())\n    matrix = [list(map(int, line.split())) for line in lines[1:]]\n    return str(max_elements_in_extremely_cool_submatrix(matrix))"
    },
    {
        "number": 3095,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix, r, s):\n        return matrix[0][0] + matrix[r-1][s-1] <= matrix[0][s-1] + matrix[r-1][0]\n\n    def is_extremely_cool(matrix, r, s):\n        if r < 2 or s < 2:\n            return False\n\n        for i in range(1, r):\n            for j in range(1, s):\n                submatrix = [row[j-1:j+1] for row in matrix[i-1:i+1]]\n                if not is_cool(submatrix, 2, 2):\n                    return False\n\n        return True\n\n    lines = stdin.split('\\n')\n    R, S = map(int, lines[0].split())\n    matrix = [list(map(int, line.split())) for line in lines[1:]]\n\n    max_elements = 0\n    for i in range(1, R):\n        for j in range(1, S):\n            submatrix = [row[j-1:j+1] for row in matrix[i-1:i+1]]\n            if is_extremely_cool(submatrix, 2, 2):\n                max_elements = max(max_elements, 4)\n\n    return str(max_elements)"
    },
    {
        "number": 3095,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix, r, s):\n        return matrix[0][0] + matrix[r - 1][s - 1] <= matrix[0][s - 1] + matrix[r - 1][0]\n\n    def is_extremely_cool(matrix, r, s):\n        if r < 2 or s < 2:\n            return False\n        for i in range(1, r):\n            for j in range(1, s):\n                if not is_cool(matrix[i - 1:i + 1, j - 1:j + 1], 2, 2):\n                    return False\n        return True\n\n    lines = stdin.splitlines()\n    R, S = map(int, lines[0].split())\n    matrix = [list(map(int, line.split())) for line in lines[1:]]\n\n    if is_extremely_cool(matrix, R, S):\n        return str(R * S)\n    else:\n        return str(0)"
    },
    {
        "number": 3096,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_superiors(superiors, index):\n        return [i for i, x in enumerate(superiors) if x == index]\n\n    def is_valid_set(jokes):\n        jokes = sorted(list(set(jokes)))\n        for i in range(len(jokes) - 1):\n            if jokes[i + 1] - jokes[i] != 1:\n                return False\n        return True\n\n    def count_valid_sets(N, jokes, superiors):\n        valid_sets = set()\n        for i in range(N):\n            if not jokes[i] in valid_sets:\n                valid_sets.add(jokes[i])\n                if is_valid_set(jokes[i:]):\n                    valid_sets.update(jokes[i:])\n                if is_valid_set(jokes[:i + 1]):\n                    valid_sets.update(jokes[:i + 1])\n        return len(valid_sets)\n\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    jokes = list(map(int, lines[1].split()))\n    superiors = [int(x) for x in lines[2:]]\n\n    return count_valid_sets(N, jokes, superiors)"
    },
    {
        "number": 3096,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, V = int(stdin.split(\"\\n\")[0]), [int(x) for x in stdin.split(\"\\n\")[1].split()]\n    employees = [[] for _ in range(N + 1)]\n    for i in range(2, N + 1):\n        A, B = map(int, stdin.split(\"\\n\")[i].split())\n        employees[A].append(B)\n\n    def get_jokes(superior, seen=set()):\n        if superior == 1:\n            return set(V)\n        jokes = set()\n        for subordinate in employees[superior]:\n            if subordinate not in seen:\n                jokes.add(V[subordinate - 1])\n                seen.add(subordinate)\n        for subordinate in employees[superior]:\n            if subordinate not in seen:\n                jokes.update(get_jokes(subordinate, seen))\n        return jokes\n\n    jokes = get_jokes(1)\n    ans = 0\n    for i in range(min(jokes), max(jokes) + 1):\n        if i in jokes and (i - 1 not in jokes or i + 1 not in jokes):\n            continue\n        ans += 1\n\n    return str(ans)"
    },
    {
        "number": 3096,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, V, adj_list, supervisors, jokes = parse_input(stdin)\n    supervisors = build_supervisors_dict(supervisors)\n    jokes = build_jokes_dict(jokes)\n    parties = get_possible_parties(N, V, adj_list, supervisors, jokes)\n    return str(len(parties))\n\ndef"
    },
    {
        "number": 3096,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def sort_jokes(jokes):\n        sorted_jokes = sorted(jokes)\n        return sorted_jokes\n\n    def is_consecutive(jokes):\n        if jokes == []:\n            return True\n        sorted_jokes = sort_jokes(jokes)\n        return all(sorted_jokes[i] + 1 == sorted_jokes[i + 1] for i in range(len(sorted_jokes) - 1))\n\n    def find_all_jokes(jokes, employees, supervisors):\n        all_jokes = set()\n        for i in range(1, len(jokes) + 1):\n            if i not in supervisors:\n                all_jokes.add(jokes[i - 1])\n        return all_jokes\n\n    def find_invitees(employees, jokes, supervisors):\n        invitees = {}\n        for i in range(1, len(employees) + 1):\n            if i not in supervisors:\n                if jokes[i - 1] not in invitees:\n                    invitees[jokes[i - 1]] = [i]\n                else:\n                    invitees[jokes[i - 1]].append(i)\n        return invitees\n\n    def find_difference(jokes, supervisors):\n        differences = {}\n        for i in range(1, len(jokes) + 1):\n            if i not in supervisors:\n                if jokes[i - 1] not in differences:\n                    differences[jokes[i - 1]] = 1\n                else:\n                    differences[jokes[i - 1]] += 1\n        return differences\n\n    def check_invitees(invitees, differences, all_jokes):\n        count = 0\n        for i in invitees:\n            if differences[i] == len(invitees[i]):\n                count += 1\n        return count\n\n    def process(stdin):\n        lines = stdin.split(\"\\n\")\n        N = int(lines[0])\n        jokes = [int(x) for x in lines[1].split()]\n        supervisors = {}\n        for i in range(2, N):\n            A, B = [int(x) for x in lines[i].split()]\n            if A not in supervisors:\n                supervisors[A] = [B]\n            else:\n                supervisors[A].append(B)\n\n        all_jokes = find_all_jokes(jokes, range(1, N + 1), supervisors)\n        invitees = find_invitees(range(1, N + 1), jokes, supervisors)\n        differences = find_difference(jokes, supervisors)\n        count = check_invitees(invitees, differences, all_jokes)\n        return count\n\n    return process(stdin) "
    },
    {
        "number": 3096,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_consecutive(lst):\n        return sorted(lst) == list(range(min(lst), max(lst) + 1))\n\n    def dfs(node):\n        visited[node] = True\n        for child in graph[node]:\n            if not visited[child]:\n                dfs(child)\n\n    def check_constraints(jokes_set):\n        for i in range(len(jokes_set)):\n            if jokes_set[i] in jokes_set[:i] or jokes_set[i] in jokes_set[i + 1:]:\n                return False\n        return True\n\n    def count_valid_sets(jokes_type, N, graph, visited):\n        valid_sets = 0\n        for i in range(1, N + 1):\n            if not visited[i]:\n                dfs(i)\n        for jokes_set in itertools.product(*jokes_type):\n            if check_constraints(jokes_set):\n                valid_sets += 1\n        return valid_sets\n\n    N = int(stdin.readline().strip())\n    jokes_type = list(map(int, stdin.readline().strip().split()))\n    graph = {i: [] for i in range(1, N + 1)}\n    for _ in range(N - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        graph[a].append(b)\n\n    visited = {i: False for i in range(1, N + 1)}\n    dfs(1)\n    return str(count_valid_sets(jokes_type, N, graph, visited))"
    },
    {
        "number": 3096,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def build_tree(supervisors):\n        tree = {}\n        for superior, subordinate in supervisors:\n            if superior not in tree:\n                tree[superior] = []\n            tree[superior].append(subordinate)\n        return tree\n\n    def dfs(employee, tree, types_of_jokes, visited, all_types_of_jokes, result):\n        visited.add(employee)\n        types_of_jokes[employee - 1] = True\n        all_types_of_jokes.add(employee)\n\n        if employee in tree:\n            for subordinate in tree[employee]:\n                if subordinate not in visited:\n                    dfs(subordinate, tree, types_of_jokes, visited, all_types_of_jokes, result)\n\n        if all(types_of_jokes) and len(all_types_of_jokes) == len(set(all_types_of_jokes)):\n            result.add(tuple(sorted(all_types_of_jokes)))\n\n        types_of_jokes[employee - 1] = False\n        all_types_of_jokes.remove(employee)\n        visited.remove(employee)\n\n    data = list(map(int, stdin.split()))\n    N = data[0]\n    types_of_jokes = data[1:]\n\n    supervisors = []\n    for i in range(N - 1):\n        A, B = map(int, input().split())\n        supervisors.append((A, B))\n\n    tree = build_tree(supervisors)\n    types_of_jokes = [False] * N\n    visited = set()\n    all_types_of_jokes = set()\n    result = set()\n\n    dfs(1, tree, types_of_jokes, visited, all_types_of_jokes, result)\n\n    return len(result)"
    },
    {
        "number": 3096,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_jokes(parent, jokes):\n        if parent != 1:\n            jokes = find_jokes(parent, jokes)\n        return jokes.union({jokes_dict[parent]})\n\n    def is_consecutive(numbers):\n        sorted_numbers = sorted(numbers)\n        return all(sorted_numbers[i] - sorted_numbers[i - 1] == 1 for i in range(1, len(sorted_numbers)))\n\n    def is_valid(jokes, invitees_jokes):\n        return jokes not in invitees_jokes and is_consecutive(sorted(list(jokes.union(invitees_jokes))))\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    jokes_dict = {i + 1: int(j) for i, j in enumerate(lines[1].split())}\n    supervisors = {int(line.split()[1]): int(line.split()[0]) for line in lines[2:]}\n\n    invitees = set()\n    invitees_jokes = set()\n    for i in range(1, N + 1):\n        jokes = find_jokes(i, set())\n        for invitee in invitees:\n            if not is_valid(jokes, invitees_jokes.intersection(jokes_dict)):\n                return str(len(invitees_jokes))\n        if jokes not in invitees_jokes:\n            invitees.add(i)\n            invitees_jokes.update(jokes)\n\n    return str(len(invitees_jokes))"
    },
    {
        "number": 3096,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, supervisors: dict, jokes: dict) -> set:\n        jokes_set = set()\n        if node in jokes:\n            jokes_set.add(jokes[node])\n        for subordinate in supervisors[node]:\n            jokes_set |= dfs(subordinate, supervisors, jokes)\n        return jokes_set\n\n    def is_consecutive(jokes_set: set) -> bool:\n        jokes_list = sorted(list(jokes_set))\n        for i in range(len(jokes_list) - 1):\n            if jokes_list[i + 1] - jokes_list[i] != 1:\n                return False\n        return True\n\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    jokes = {}\n    for i, v in enumerate(input_list[1].split()):\n        jokes[i + 1] = int(v)\n\n    supervisors = {i: set() for i in range(1, N + 1)}\n    for i in range(2, N):\n        A, B = map(int, input_list[i].split())\n        supervisors[A].add(B)\n\n    valid_jokes_sets = set()\n    for subordinate in range(1, N + 1):\n        jokes_set = dfs(subordinate, supervisors, jokes)\n        if len(jokes_set) == N and is_consecutive(jokes_set):\n            valid_jokes_sets.add(tuple(sorted(list(jokes_set))))\n\n    return str(len(valid_jokes_sets))"
    },
    {
        "number": 3096,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_consecutive(arr):\n        arr = sorted(arr)\n        return all(arr[i] - arr[i - 1] == 1 for i in range(1, len(arr)))\n\n    def dfs(node, visited, supervisors, jokes_set, jokes_count):\n        if node not in visited:\n            visited.add(node)\n            for subordinate in supervisors[node]:\n                dfs(subordinate, visited, supervisors, jokes_set, jokes_count)\n\n            jokes_set.add(node)\n            for subordinate in supervisors[node]:\n                jokes_set.add(subordinate)\n\n            if is_consecutive(list(jokes_set)):\n                jokes_count.add(tuple(sorted(list(jokes_set))))\n\n            jokes_set.remove(node)\n            for subordinate in supervisors[node]:\n                jokes_set.remove(subordinate)\n\n    def party_planner(N, jokes_types, supervisors):\n        visited = set()\n        jokes_set = set()\n        jokes_count = set()\n        dfs(1, visited, supervisors, jokes_set, jokes_count)\n        return len(jokes_count)\n\n    N = int(stdin.readline().strip())\n    jokes_types = list(map(int, stdin.readline().strip().split()))\n    supervisors = {i: [] for i in range(1, N + 1)}\n\n    for _ in range(N - 1):\n        A, B = map(int, stdin.readline().strip().split())\n        supervisors[A].append(B)\n\n    return str(party_planner(N, jokes_types, supervisors)) + '\\n' "
    },
    {
        "number": 3096,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, jokes, supervisors = int(stdin.split(\"\\n\")[0]), list(map(int, stdin.split(\"\\n\")[1].split())), list(map(lambda x: tuple(map(int, x.split())), stdin.split(\"\\n\")[2:]))\n    types = {}\n    for i in range(1, N + 1):\n        types[i] = set()\n    for i in range(N):\n        types[i + 1].add(jokes[i])\n    for supervisor, employee in supervisors:\n        types[supervisor].update(types[employee])\n    for i in range(1, N):\n        types[1].update(types[i])\n    jokes_set = set()\n    for i in range(1, N + 1):\n        for j in range(1, 101):\n            if j in types[i]:\n                jokes_set.add(j)\n    jokes_list = list(jokes_set)\n    jokes_list.sort()\n    total = 0\n    for i in range(len(jokes_list) - 1):\n        if jokes_list[i + 1] - jokes_list[i] == 1:\n            total += 1\n    return str(total)"
    },
    {
        "number": 3097,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Split input into lines\n    lines = stdin.splitlines()\n    \n    # Parse the number of queries\n    Q = int(lines[0])\n    \n    # Initialize the output string\n    output = \"\"\n    \n    # Iterate through the queries\n    for i in range(1, Q + 1):\n        # Parse the interval\n        A, B = map(int, lines[i].split())\n        \n        # Initialize the count variable\n        count = 0\n        \n        # Iterate through the rows\n        for j in range(1, B + 1):\n            # Iterate through the columns\n            for k in range(1, A + 1):\n                # Calculate the value at the current cell\n                value = A(j, k)\n                \n                # Check if the value is in the interval\n                if A <= value <= B:\n                    count += 1\n                    \n        # Add the count to the output string\n        output += str(count) + \"\\n\"\n    \n    # Return the output string\n    return output"
    },
    {
        "number": 3097,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def reverse(n: int) -> int:\n        return int(str(n)[::-1])\n\n    def count_appearances(A: int, B: int) -> int:\n        count = 0\n        for i in range(1, 10**6):\n            for j in range(1, 10**6):\n                num = A(i, j)\n                if A <= num <= B:\n                    count += 1\n                if num > B:\n                    break\n        return count\n\n    def A(i: int, j: int) -> int:\n        if j == 1:\n            return i\n        else:\n            return A(i, j - 1) + reverse(A(i, j - 1))\n\n    queries = [tuple(map(int, line.split())) for line in stdin.strip().split('\\n')]\n    results = []\n\n    for A, B in queries:\n        results.append(count_appearances(A, B))\n\n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 3097,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def rev(num):\n        return int(str(num)[::-1])\n\n    def count_appearances(A, B):\n        appearances = 0\n        for i in range(1, B + 1):\n            row = [0] * (A + 1)\n            for j in range(2, len(row)):\n                row[j] = row[j - 1] + rev(row[j - 1])\n                if A <= row[j] <= B:\n                    appearances += 1\n        return appearances\n\n    def process_query(query: str) -> str:\n        A, B = map(int, query.split())\n        return str(count_appearances(A, B))\n\n    lines = stdin.split('\\n')\n    Q = int(lines[0])\n    queries = lines[1:]\n    results = []\n\n    for query in queries:\n        results.append(process_query(query))\n\n    return '\\n'.join(results)"
    },
    {
        "number": 3097,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    Q = int(lines[0])\n    output = []\n\n    for i in range(1, Q + 1):\n        A, B = map(int, lines[i].split())\n        count = 0\n\n        for num in range(A, B + 1):\n            row = num\n            col = 1\n            seen = set()\n\n            while col <= row:\n                if (row, col) in seen:\n                    break\n                seen.add((row, col))\n                row = row - col + int(str(col)[::-1])\n                col += 1\n\n            if col > row:\n                count += 1\n\n        output.append(str(count))\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3097,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def reverse_number(n: int) -> int:\n        return int(str(n)[::-1])\n\n    def count_appearances(A: int, B: int) -> int:\n        count = 0\n        for i in range(1, 10**6):\n            for j in range(2, 10**6):\n                value = A(i, j)\n                if value >= A and value <= B:\n                    count += 1\n        return count\n\n    def process_query(query: str) -> str:\n        A, B = map(int, query.split())\n        return str(count_appearances(A, B))\n\n    queries = stdin.strip().split('\\n')\n    return '\\n'.join(process_query(query) for query in queries[1:])"
    },
    {
        "number": 3097,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    Q = int(lines[0])\n    result = []\n\n    def rev(n: int) -> int:\n        return int(str(n)[::-1])\n\n    def count_appearances(A: int, B: int) -> int:\n        appearances = 0\n        for i in range(1, 11):\n            for j in range(2, 11):\n                if A <= A(i, j) <= B:\n                    appearances += 1\n        return appearances\n\n    for i in range(1, Q + 1):\n        A, B = map(int, lines[i].split())\n        result.append(count_appearances(A, B))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3097,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def rev(num):\n        return int(str(num)[::-1])\n\n    def count_appearances(A, B):\n        count = 0\n        for i in range(1, B + 1):\n            for j in range(1, A + 1):\n                if A(i, j) <= B:\n                    count += 1\n        return count\n\n    Q = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(Q):\n        A, B = map(int, stdin.readline().strip().split())\n        result.append(count_appearances(A, B))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3097,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def reverse_decimal(n: int) -> int:\n        return int(str(n)[::-1])\n\n    def count_interval_appearances(A: int, B: int) -> int:\n        count = 0\n        for i in range(1, B + 1):\n            for j in range(1, i + 1):\n                if A <= A(i, j) <= B:\n                    count += 1\n        return count\n\n    def A(i: int, j: int) -> int:\n        if j == 1:\n            return i\n        else:\n            return A(i, j - 1) + reverse_decimal(A(i, j - 1))\n\n    def process_query(query: str) -> int:\n        A, B = map(int, query.split())\n        return count_interval_appearances(A, B)\n\n    queries = stdin.split('\\n')\n    output = [process_query(query) for query in queries[1:]]\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3097,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    query_count = int(lines[0])\n    queries = []\n\n    for i in range(1, query_count + 1):\n        a, b = map(int, lines[i].split())\n        queries.append((a, b))\n\n    result = []\n\n    for a, b in queries:\n        count = 0\n        for i in range(1, b + 1):\n            for j in range(1, i + 1):\n                if i == j:\n                    value = j\n                else:\n                    value = int(str(j)[::-1]) + j\n\n                if a <= value <= b:\n                    count += 1\n\n        result.append(count)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3097,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def reverse_number(n: int) -> int:\n        return int(str(n)[::-1])\n\n    def count_interval_appearances(A: int, B: int) -> int:\n        total_appearances = 0\n        for i in range(1, B + 1):\n            for j in range(2, A + 1):\n                if i <= B and i <= reverse_number(i):\n                    total_appearances += 1\n            if i <= B and i <= reverse_number(i):\n                total_appearances += 1\n        return total_appearances\n\n    def process_query(query: str) -> int:\n        A, B = map(int, query.split())\n        return count_interval_appearances(A, B)\n\n    lines = stdin.split('\\n')\n    Q = int(lines[0])\n    queries = lines[1:]\n\n    outputs = []\n    for query in queries:\n        outputs.append(str(process_query(query)))\n\n    return '\\n'.join(outputs)"
    },
    {
        "number": 3098,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def area(p1, p2, p3):\n        return abs((p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) / 2)\n\n    n, k = map(int, stdin.split())\n    vertices = [tuple(map(float, input().split())) for _ in range(n)]\n\n    total_area = area(*vertices)\n    expected_area = 0\n\n    for i in range(k):\n        for j in range(k - 1):\n            for l in range(j + 1, k):\n                if i != j and i != l and j != l:\n                    a = vertices[i]\n                    b = vertices[j]\n                    c = vertices[l]\n\n                    ab = distance(a, b)\n                    bc = distance(b, c)\n                    ca = distance(c, a)\n\n                    s = (ab + bc + ca) / 2\n                    triangle_area = (s * (s - ab) * (s - bc) * (s - ca)) ** 0.5\n                    angle_a = (bc * bc + ca * ca - ab * ab) / (2 * bc * ca)\n                    angle_b = (ca * ca + ab * ab - bc * bc) / (2 * ca * ab)\n                    angle_c = (ab * ab + bc * bc - ca * ca) / (2 * ab * bc)\n\n                    part_area = triangle_area * angle_a * angle_b * angle_c\n                    expected_area += part_area\n\n    return '{:.9f}'.format(expected_area / total_area)"
    },
    {
        "number": 3098,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p3[0] - p1[0]) * (p2[1] - p1[1])\n\n    def area_of_polygon(vertices):\n        n = len(vertices)\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            area += vertices[i][0] * vertices[j][1]\n            area -= vertices[j][0] * vertices[i][1]\n        return abs(area) / 2\n\n    def expected_area_of_piece(vertices, k):\n        n = len(vertices)\n        total_area = area_of_polygon(vertices)\n        expected_area = 0\n        for i in range(n - k + 1):\n            j = (i + k - 1) % n\n            area = 0\n            for l in range(k - 2):\n                m = (l + 1) % k\n                area += cross_product(vertices[i], vertices[(i + l + 1) % n],\n                                           vertices[(i + l + 2) % n])\n            expected_area += abs(area) / (2 * k)\n        return expected_area / total_area\n\n    input_data = stdin.split(\"\\n\")\n    n, k = map(int, input_data[0].split())\n    vertices = [list(map(float, input_data[i + 1].split())) for i in range(n)]\n\n    return f\"{expected_area_of_piece(vertices, k):.9f}\""
    },
    {
        "number": 3098,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0])**2 + (a[1] - b[1])**2)**0.5\n\n    def cross(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    def area(vertices):\n        vertices = [vertices[-1]] + vertices + [vertices[0]]\n        return abs(sum(cross(vertices[i], vertices[i + 1]) for i in range(len(vertices) - 1))) / 2\n\n    def expected_area(n, k, vertices):\n        total_area = area(vertices)\n        total_length = sum(distance(vertices[i], vertices[(i + 1) % n]) for i in range(n))\n        expected_length = total_length / k\n\n        pieces_area = []\n        for i in range(n):\n            pieces_area.append(distance(vertices[i], vertices[(i + 1) % n]) / total_length * total_area)\n\n        return sum(pieces_area) - (k - 1) * expected_length / 2\n\n    data = [line.split() for line in stdin.split('\\n') if line]\n    n, k = map(int, data[0])\n    vertices = [(float(x), float(y)) for x, y in data[1:]]\n\n    return '{:.9f}'.format(expected_area(n, k, vertices))"
    },
    {
        "number": 3098,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from math import sqrt, pi\n\n    def distance(p1, p2):\n        return sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\n    def area_of_polygon(vertices):\n        area = 0\n        n = len(vertices)\n        for i in range(n):\n            j = (i + 1) % n\n            area += vertices[i][0] * vertices[j][1]\n            area -= vertices[j][0] * vertices[i][1]\n        return abs(area) / 2\n\n    def expected_area(vertices, k):\n        n = len(vertices)\n        total_area = area_of_polygon(vertices)\n        probabilities = [1 / n] * n\n\n        for i in range(k - 1):\n            new_probabilities = []\n            for j in range(n):\n                probability = 0\n                for l in range(n):\n                    if l != j:\n                        probability += probabilities[l] / (n - 1) * distance(vertices[l], vertices[j])\n                new_probabilities.append(probability)\n            probabilities = new_probabilities\n\n        expected_area = sum(p * area_of_polygon([vertices[i] for i in range(n) if probabilities[i] > 0]) for i, p in enumerate(probabilities))\n        return expected_area\n\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    n, k = map(int, input_data[0].split())\n    vertices = [tuple(map(float, input_data[i].split())) for i in range(1, n + 1)]\n\n    result = expected_area(vertices, k)\n    return '{:.10f}'.format(result)"
    },
    {
        "number": 3098,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def area(a, b, c):\n        return abs((a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) / 2)\n\n    n, k = map(int, stdin.readline().split())\n    vertices = [tuple(map(float, stdin.readline().split())) for _ in range(n)]\n\n    total_area = area(*vertices)\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            d = distance(vertices[i], vertices[j])\n            total_area -= d * (d ** 2).is_integer()\n\n    return f\"{total_area / k:.8f}\""
    },
    {
        "number": 3098,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def perimeter(vertices):\n        perimeter = 0\n        for i in range(len(vertices)):\n            perimeter += distance(vertices[i], vertices[(i + 1) % len(vertices)])\n        return perimeter\n\n    def area(vertices):\n        area = 0\n        for i in range(len(vertices)):\n            area += vertices[i][0] * vertices[(i + 1) % len(vertices)][1]\n            area -= vertices[(i + 1) % len(vertices)][0] * vertices[i][1]\n        return abs(area) / 2\n\n    input_data = [line.split() for line in stdin.split('\\n') if line]\n    n, k = map(int, input_data[0])\n    vertices = [(float(x), float(y)) for x, y in input_data[1:n + 1]]\n    polygon_area = area(vertices)\n    polygon_perimeter = perimeter(vertices)\n    expected_area = polygon_area * (k / n) + (polygon_perimeter / n) ** 2 * (1 - (k / n))\n    return '{:.9f}'.format(expected_area)"
    },
    {
        "number": 3098,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def area(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            area += points[i][0] * points[(i + 1) % n][1]\n            area -= points[(i + 1) % n][0] * points[i][1]\n        return abs(area) / 2\n\n    def compute_expec_area(n, k, points):\n        total_area = 0\n        for i in range(n):\n            polygon = [points[j % n] for j in range(i, i + k)]\n            total_area += area(polygon)\n        return total_area / n\n\n    input_data = list(map(str.strip, stdin.split()))\n    n, k = map(int, input_data[0].split())\n    points = [tuple(map(float, input_data[i + 1].split())) for i in range(1, n + 1)]\n\n    if k == n:\n        return area(points)\n    else:\n        return compute_expec_area(n, k, points)"
    },
    {
        "number": 3098,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def area(vertices):\n        result = 0\n        n = len(vertices)\n        for i in range(n):\n            result += vertices[i][0] * vertices[i - 1][1]\n            result -= vertices[i][1] * vertices[i - 1][0]\n        return abs(result) / 2\n\n    n, k = map(int, stdin.readline().split())\n    vertices = [tuple(map(float, stdin.readline().split())) for _ in range(n)]\n\n    total_area = area(vertices)\n    expected_area = 0\n    for i in range(k):\n        remaining_vertices = vertices[:i] + vertices[i + 1:]\n        expected_area += area(remaining_vertices) / (n - 1)\n\n    return f\"{expected_area / total_area:.10f}\"\n"
    },
    {
        "number": 3098,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_area(vertices):\n        area = 0\n        for i in range(len(vertices)):\n            area += vertices[i][0] * vertices[i - 1][1]\n            area -= vertices[i][1] * vertices[i - 1][0]\n        return abs(area) / 2\n\n    def cut_cake(vertices, k):\n        total_area = get_area(vertices)\n        expected_area = total_area / (len(vertices) - k)\n        return expected_area\n\n    n, k = map(int, stdin.readline().strip().split())\n    vertices = [tuple(map(float, stdin.readline().strip().split())) for _ in range(n)]\n\n    return f\"{cut_cake(vertices, k):.9f}\""
    },
    {
        "number": 3098,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from bisect import bisect_left\n    from itertools import permutations\n    from math import pi, cos, sin\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def area(p1, p2, p3):\n        return abs((p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) / 2)\n\n    n, k = map(int, stdin.readline().split())\n    vertices = [tuple(map(float, stdin.readline().split())) for _ in range(n)]\n\n    def angle_cmp(p1, p2):\n        return (p2[0] - p1[0]) * vertices[0][1] - (p2[1] - p1[1]) * vertices[0][0]\n\n    vertices = [p for p in vertices if angle_cmp(p, vertices[0]) >= 0]\n    vertices.sort(key=lambda p: (-area(p, vertices[0], vertices[-1]), -distance(p, vertices[0])))\n    vertices = vertices[:k]\n    angles = sorted(set(sum(angle_cmp(p, q) for q in vertices) for p in vertices), reverse=True)\n    result = pi * sum(abs(p[0] * q[1] - q[0] * p[1]) / 2 for p, q in permutations(vertices, 2))\n    for a in angles:\n        if a == 0:\n            result += area(vertices[-1], vertices[0], vertices[1])\n        else:\n            p = max(vertices, key=lambda p: abs(angle_cmp(p, vertices[0]) - a))\n            i = bisect_left(vertices, p)\n            result += area(vertices[i - 1], p, vertices[i])\n\n    return f\"{result:.9f}\""
    },
    {
        "number": 3099,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, start):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(graph, visited, neighbor)\n\n    def bfs(graph, visited, start):\n        queue = [start]\n        visited[start] = True\n        while queue:\n            current = queue.pop(0)\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n    input_list = stdin.split('\\n')\n    S, E, C = map(int, input_list[0].split())\n    connections = [list(map(int, input_list[i+1].split())) for i in range(C)]\n    enemies = list(map(int, input_list[C+1].split()))\n\n    graph = {i: [] for i in range(S)}\n    for connection in connections:\n        graph[connection[0]].append(connection[1])\n        graph[connection[1]].append(connection[0])\n\n    visited = [False] * S\n    dfs(graph, visited, 0)\n    bfs(graph, visited, 0)\n\n    spy_count = 0\n    for i in range(S):\n        if visited[i]:\n            spy_count += 1\n        else:\n            for j in range(C):\n                if connections[j][0] == i:\n                    graph[connections[j][1]].remove(i)\n                elif connections[j][1] == i:\n                    graph[connections[j][0]].remove(i)\n            visited[i] = True\n            bfs(graph, visited, i)\n\n    return str(spy_count)"
    },
    {
        "number": 3099,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    input_data = list(map(str, stdin.split('\\n')))\n    S, E, C = map(int, input_data[0].split())\n    connections = [list(map(int, line.split())) for line in input_data[1:C+1]]\n    enemies = list(map(int, input_data[C+1].split()))\n\n    # Create a graph of connections\n    graph = {i: [] for i in range(S)}\n    for c1, c2 in connections:\n        graph[c1].append(c2)\n\n    # Initialize variables\n    visited = [False] * S\n    messages = 0\n\n    # Function to traverse the graph and send messages\n    def send_message(node, private=True):\n        nonlocal messages\n        visited[node] = True\n        if private:\n            messages += 1\n        for neighbor in graph[node]:\n            if not visited[neighbor] and neighbor not in enemies:\n                send_message(neighbor, private)\n\n    # Send messages to all spies\n    for spy in range(S):\n        if not visited[spy]:\n            send_message(spy, private=False)\n\n    return str(messages)"
    },
    {
        "number": 3099,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    S, E, C = map(int, stdin.readline().split())\n    connections = [tuple(map(int, stdin.readline().split())) for _ in range(C)]\n    enemies = set(map(int, stdin.readline().split()))\n\n    spy_connections = {spy: set() for spy in range(S)}\n    for spy1, spy2 in connections:\n        spy_connections[spy1].add(spy2)\n\n    def bfs(start, visited):\n        queue = [(start, False)]  # (spy, is_private)\n        visited.add(start)\n\n        while queue:\n            spy, is_private = queue.pop(0)\n            if spy in enemies:\n                return False\n            for connected_spy in spy_connections[spy]:\n                if connected_spy not in visited:\n                    queue.append((connected_spy, is_private or connected_spy in enemies))\n                    visited.add(connected_spy)\n\n        return True\n\n    visited = set()\n    messages = 0\n\n    for spy in range(S):\n        if spy not in visited:\n            is_reachable = bfs(spy, visited)\n            if not is_reachable:\n                return -1  # Unreachable network\n            messages += is_reachable\n\n    return messages\n"
    },
    {
        "number": 3099,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(graph, start, visited, spy_set):\n        queue = [start]\n        visited[start] = True\n        while queue:\n            node = queue.pop(0)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    spy_set.add(neighbor)\n\n    def reachable_spies(graph, start, enemies):\n        visited = [False] * len(graph)\n        spy_set = set()\n        bfs(graph, start, visited, spy_set)\n        for enemy in enemies:\n            if enemy in spy_set:\n                return False\n        return True\n\n    S, E, C = map(int, stdin.split()[0].split())\n    connections = [list(map(int, line.split())) for line in stdin.split()[1:1 + C]]\n    enemies = set(map(int, stdin.split()[-1].split()))\n\n    graph = [[] for _ in range(S)]\n    for connection in connections:\n        graph[connection[0]].append(connection[1])\n\n    min_messages = float('inf')\n    for i in range(S):\n        if reachable_spies(graph, i, enemies):\n            min_messages = min(min_messages, len(enemies) + 1)\n\n    return str(min_messages) "
    },
    {
        "number": 3099,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(graph, visited, neighbor)\n\n    input_list = stdin.split('\\n')\n    S, E, C = map(int, input_list[0].split())\n    connections = [list(map(int, line.split())) for line in input_list[1:C + 1]]\n    enemies = list(map(int, input_list[C + 1].split()))\n\n    graph = [[] for _ in range(S)]\n    for connection in connections:\n        graph[connection[0]].append(connection[1])\n        graph[connection[1]].append(connection[0])\n\n    visited = [False] * S\n    for enemy in enemies:\n        dfs(graph, visited, enemy)\n\n    spies_to_message = 0\n    for i in range(S):\n        if not visited[i]:\n            spies_to_message += 1\n\n    return str(spies_to_message + E)"
    },
    {
        "number": 3099,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, node, enemy_spies):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited and neighbor not in enemy_spies:\n                dfs(graph, visited, neighbor, enemy_spies)\n\n    num_spies, num_enemies, num_connections = map(int, stdin.readline().split())\n    spy_connections = [list(map(int, stdin.readline().split())) for _ in range(num_connections)]\n    enemy_spies = set(map(int, stdin.readline().split()))\n\n    graph = {i: [] for i in range(num_spies)}\n    for spy1, spy2 in spy_connections:\n        graph[spy1].append(spy2)\n        graph[spy2].append(spy1)\n\n    min_messages = num_spies - num_enemies\n    for spy in range(num_spies):\n        visited = set()\n        dfs(graph, visited, spy, enemy_spies)\n        min_messages = min(min_messages, num_spies - len(visited) - num_enemies)\n\n    return str(min_messages) "
    },
    {
        "number": 3099,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(graph, start, visited, enemy):\n        queue = [start]\n        visited[start] = True\n        while queue:\n            node = queue.pop(0)\n            for neighbor in graph[node]:\n                if not visited[neighbor] and neighbor not in enemy:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n    \n    data = list(map(int, stdin.split()))\n    S, E, C = data[0], data[1], data[2]\n    data = data[3:]\n    \n    graph = [[] for _ in range(S)]\n    for i in range(C):\n        s1, s2 = data[i * 2], data[i * 2 + 1]\n        graph[s1].append(s2)\n        graph[s2].append(s1)\n    \n    enemy = set(data[-E:])\n    visited = [False] * S\n    \n    count = 0\n    for i in range(S):\n        if not visited[i]:\n            bfs(graph, i, visited, enemy)\n            count += 1\n    \n    return str(count)"
    },
    {
        "number": 3099,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start, connections, visited):\n        queue = [start]\n        visited[start] = True\n        while queue:\n            current = queue.pop(0)\n            for neighbor in connections[current]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n\n    input_list = list(map(str, stdin.strip().split('\\n')))\n    S, E, C = map(int, input_list[0].split())\n\n    connections = [[] for _ in range(S)]\n    for i in range(1, C + 1):\n        s1, s2 = map(int, input_list[i].split())\n        connections[s1].append(s2)\n\n    enemies = set(map(int, input_list[C + 1].split()))\n\n    visited = [False] * S\n    count = 0\n\n    for i in range(S):\n        if not visited[i]:\n            if i in enemies:\n                continue\n            count += 1\n            bfs(i, connections, visited)\n\n    return str(count)"
    },
    {
        "number": 3099,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.splitlines()\n    S, E, C = map(int, lines[0].split())\n    connections = [tuple(map(int, line.split())) for line in lines[1:C + 1]]\n    enemies = set(map(int, lines[C + 1].split()))\n\n    # Initialize spy connection graph\n    spy_connections = [set() for _ in range(S)]\n    for conn in connections:\n        spy_connections[conn[0]].add(conn[1])\n\n    # Perform BFS to count the number of enemy spies each spy can reach\n    enemy_reach_count = [0] * S\n    visited = [False] * S\n\n    def bfs(start):\n        queue = [(start, 0)]\n        while queue:\n            spy, distance = queue.pop(0)\n            if not visited[spy]:\n                visited[spy] = True\n                enemy_reach_count[spy] += distance\n                for conn in spy_connections[spy]:\n                    if not visited[conn]:\n                        queue.append((conn, distance + 1))\n\n    for i in range(S):\n        if not visited[i]:\n            bfs(i)\n\n    # Calculate the minimum number of messages required\n    total_enemy_reach = sum(enemy_reach_count[e] for e in enemies)\n    if total_enemy_reach == 0:\n        return str(S)\n    return str(len(enemies) + (total_enemy_reach - len(enemies)) // S + 1)"
    },
    {
        "number": 3099,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split(\"\\n\")\n    S, E, C = map(int, lines[0].split())\n    connections = []\n    for i in range(1, C + 1):\n        s1, s2 = map(int, lines[i].split())\n        connections.append((s1, s2))\n    enemies = set(map(int, lines[C + 1].split()))\n\n    # Create adjacency list\n    adjacency_list = [set() for _ in range(S)]\n    for s1, s2 in connections:\n        adjacency_list[s1].add(s2)\n\n    # Perform DFS to count spies reachable from each spy\n    reachable_spies = [set() for _ in range(S)]\n    visited = [False] * S\n\n    def dfs(spy):\n        visited[spy] = True\n        reachable_spies[spy].add(spy)\n        for neighbor in adjacency_list[spy]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n                reachable_spies[spy].update(reachable_spies[neighbor])\n\n    for spy in range(S):\n        if not visited[spy]:\n            dfs(spy)\n\n    # Count private messages needed\n    private_messages = 0\n    for spy in range(S):\n        if spy not in enemies:\n            reachable_enemies = enemies.intersection(reachable_spies[spy])\n            if reachable_enemies:\n                private_messages += 1\n\n    # Count public messages needed\n    public_messages = 0\n    for spy in range(S):\n        if spy not in enemies:\n            unreachable_enemies = enemies.difference(reachable_spies[spy])\n            if unreachable_enemies:\n                public_messages += 1\n\n    return str(private_messages + public_messages)"
    },
    {
        "number": 3100,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    mod = 10**9 + 7\n    A, C, M = map(int, stdin.split())\n\n    def count_ways(A, C, M):\n        if A == 0 and C == 0 and M == 0:\n            return 1\n        if A < 0 or C < 0 or M < 0:\n            return 0\n        return (count_ways(A - 1, C, M) + count_ways(A, C - 1, M) + count_ways(A, C, M - 1)) % mod\n\n    return str(count_ways(A, C, M))"
    },
    {
        "number": 3100,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    mod = 10**9 + 7\n    total_boxes = A + C + M\n    num_fruit_types = 3\n\n    # If there are not enough boxes for all fruit types\n    if total_boxes < num_fruit_types:\n        return \"0\"\n\n    # Calculate the total number of arrangements\n    total_arrangements = 1\n    for i in range(1, total_boxes + 1):\n        total_arrangements *= i\n        total_arrangements %= mod\n\n    # Calculate the number of arrangements with at least one constraint violation\n    invalid_arrangements = 0\n    for i in range(1, A + 1):\n        invalid_arrangements += pow(A - i, total_boxes - A, mod)\n        invalid_arrangements %= mod\n\n    for i in range(1, C + 1):\n        invalid_arrangements += pow(C - i, total_boxes - C, mod)\n        invalid_arrangements %= mod\n\n    for i in range(1, M + 1):\n        invalid_arrangements += pow(M - i, total_boxes - M, mod)\n        invalid_arrangements %= mod\n\n    # Calculate the final result\n    final_result = total_arrangements - invalid_arrangements\n    final_result %= mod\n\n    return str(final_result)"
    },
    {
        "number": 3100,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    mod = 10**9 + 7\n    A, C, M = map(int, stdin.split())\n    total = A + C + M\n\n    if total % 2 == 1:\n        return \"0\"\n\n    num_pairs = total // 2\n    num_apples = min(A, num_pairs)\n    num_cherries = min(C, num_pairs - num_apples)\n    num_mangos = num_pairs - num_apples - num_cherries\n\n    # count the number of ways to choose num_apples out of A apples and num_cherries out of C cherries\n    # the remaining M-num_mangos mangos are already determined by the choice of apples and cherries\n    count = (factorial(A) // (factorial(num_apples) * factorial(A - num_apples)))\n    count *= (factorial(C) // (factorial(num_cherries) * factorial(C - num_cherries)))\n\n    return str(count % mod)\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n    n = A + C + M\n    num_permutations = 1\n    for i in range(1, n):\n        num_permutations *= i\n        num_permutations %= MOD\n    num_permutations *= n\n    num_permutations %= MOD\n    num_permutations *= pow(2, A, MOD)\n    num_permutations %= MOD\n    num_permutations *= pow(2, C, MOD)\n    num_permutations %= MOD\n    num_permutations *= pow(2, M, MOD)\n    num_permutations %= MOD\n    return str(num_permutations)"
    },
    {
        "number": 3100,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def count_ways(a, c, m):\n        if a < 0 or c < 0 or m < 0:\n            return 0\n        if a == 0 == c == 0 == m:\n            return 1\n        return (count_ways(a-1, c, m) + count_ways(a, c-1, m) + count_ways(a, c, m-1)) % mod\n\n    return str(count_ways(A, C, M))"
    },
    {
        "number": 3100,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_ways(apples, cherries, mangos):\n        if apples > 0:\n            if cherries > 0:\n                return (count_ways(apples - 1, cherries - 1, mangos) +\n                        count_ways(apples - 1, cherries, mangos) +\n                        count_ways(apples - 1, cherries, mangos + 1)) % MOD\n            else:\n                return (count_ways(apples - 1, cherries, mangos) +\n                        count_ways(apples - 1, cherries, mangos + 1)) % MOD\n        else:\n            return 1\n\n    return str(count_ways(A, C, M))"
    },
    {
        "number": 3100,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n    \n    # The number of possible arrangements can be computed using dynamic programming\n    dp = [[[0] * (M + 1) for _ in range(C + 1)] for _ in range(A + 1)]\n    \n    # If there are no fruits of a particular type, there is only one possible arrangement\n    for i in range(A + 1):\n        for j in range(C + 1):\n            dp[i][j][0] = 1\n    \n    # If there is only one fruit of a particular type, there is only one possible arrangement\n    for i in range(A):\n        for j in range(C):\n            for k in range(M):\n                dp[i+1][j][k] = 1\n                dp[i][j+1][k] = 1\n                dp[i][j][k+1] = 1\n    \n    # If there are at least two fruits of a particular type, compute the number of possible arrangements\n    for i in range(2, A+1):\n        for j in range(2, C+1):\n            for k in range(2, M+1):\n                dp[i][j][k] = (dp[i-1][j][k] + dp[i][j-1][k] + dp[i][j][k-1]) % MOD\n                if i == j == k:\n                    dp[i][j][k] -= 1\n    \n    return str(dp[A][C][M])"
    },
    {
        "number": 3100,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def combinations(a, b, c):\n        if a == 0 or b == 0 or c == 0:\n            return 1\n        if a >= b + c:\n            return combinations(a - b - c, b, c) * (b + c) % MOD\n        if b >= a + c:\n            return combinations(a, b - a - c, c) * (a + c) % MOD\n        if c >= a + b:\n            return combinations(a, b, c - a - b) * (a + b) % MOD\n        return (combinations(a, b, c - 1) + combinations(a - 1, b, c) - combinations(a - 1, b - 1, c) + combinations(a, b - 1, c - 1) - combinations(a - 1, b, c - 1)) % MOD\n\n    return str(combinations(A, C, M))"
    },
    {
        "number": 3100,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n    total = (A + C + M)\n    \n    if total < 2:\n        return \"0\"\n    \n    dp = [[0, 0, 0] for _ in range(total)]\n    dp[0][0] = A\n    dp[0][1] = C\n    dp[0][2] = M\n    \n    for i in range(1, total):\n        for j in range(3):\n            for k in range(3):\n                if j != k:\n                    dp[i][j] += dp[i - 1][k]\n                    dp[i][j] %= MOD\n    \n    result = (dp[total - 1][0] * dp[total - 1][1] * dp[total - 1][2]) % MOD\n    return str(result)"
    },
    {
        "number": 3100,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[0, 0], [0, 0]]\n    dp[0][0] = C + M\n    dp[0][1] = M\n    dp[1][0] = C\n\n    for i in range(A):\n        dp[i % 2] = [sum(x) % MOD for x in zip(dp[i % 2], dp[(i + 1) % 2])]\n\n    return str(dp[A % 2][0])"
    },
    {
        "number": 3101,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    zeus_answer = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    # Check if the list is already sorted\n    if zeus_answer == sorted(zeus_answer):\n        return \"impossible\"\n\n    # Find the index of the number to modify\n    index_to_modify = None\n    for i in range(n - 1):\n        if zeus_answer[i] > zeus_answer[i + 1]:\n            index_to_modify = i\n            break\n\n    # Check if there is a digit to modify\n    if index_to_modify is None:\n        return \"impossible\"\n\n    # Modify the digit\n    modified_number = zeus_answer[index_to_modify]\n    for i in range(9, 0, -1):\n        if str(i) in str(modified_number):\n            modified_number = int(str(modified_number).replace(str(i), str(i - 1), 1))\n            break\n\n    # Check if the modified number has leading zeros\n    if len(str(modified_number)) != len(str(zeus_answer[index_to_modify])):\n        modified_number = modified_number * (10 ** (len(str(zeus_answer[index_to_modify]) - len(str(modified_number))))\n\n    # Create the output list\n    output = zeus_answer.copy()\n    output[index_to_modify] = modified_number\n\n    return \" \".join(str(x) for x in output) "
    },
    {
        "number": 3101,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_sorted(numbers):\n        for i in range(1, len(numbers)):\n            if numbers[i] < numbers[i - 1]:\n                return False\n        return True\n\n    def change_digit(numbers):\n        for i in range(len(numbers)):\n            for j in range(9):\n                if j < numbers[i] % 10:\n                    continue\n                new_number = numbers[i] - numbers[i] % 10 + j\n                new_numbers = numbers[:i] + [new_number] + numbers[i + 1:]\n                if not is_sorted(new_numbers):\n                    return new_numbers\n        return None\n\n    n = int(stdin.readline().strip())\n    numbers = list(map(int, stdin.readline().strip().split()))\n\n    if not is_sorted(numbers):\n        return \"impossible\"\n\n    new_numbers = change_digit(numbers)\n\n    if new_numbers is None:\n        return \"impossible\"\n    else:\n        return \" \".join(str(x) for x in new_numbers) "
    },
    {
        "number": 3101,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_sorted(arr):\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n\n    def find_candidate_numbers(a):\n        candidates = []\n        for i in range(len(a)):\n            for j in range(10):\n                b = a.copy()\n                if b[i] != 0 or j != 0:\n                    b[i] = b[i] * 10 + j\n                    candidates.append(b)\n        return candidates\n\n    def check_candidate_numbers(candidates):\n        for c in candidates:\n            if not is_sorted(c):\n                return c\n        return None\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return \"impossible\"\n\n    if not is_sorted(a):\n        return \" \".join(str(x) for x in a)\n\n    candidates = find_candidate_numbers(a)\n    result = check_candidate_numbers(candidates)\n\n    if result is None:\n        return \"impossible\"\n    else:\n        return \" \".join(str(x) for x in result)"
    },
    {
        "number": 3101,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_sorted(numbers):\n        return all(numbers[i] <= numbers[i + 1] for i in range(len(numbers) - 1))\n\n    def replace_digit(number, digit, replacement):\n        if number == 0:\n            return replacement\n        else:\n            return number - digit + replacement\n\n    n = int(stdin.readline().strip())\n    numbers = list(map(int, stdin.readline().strip().split()))\n\n    if not is_sorted(numbers):\n        return \"impossible\"\n\n    for i in range(n):\n        for digit in range(10):\n            if numbers[i] % 10 != digit:\n                replacement = replace_digit(numbers[i], digit, digit + 1)\n                if i == 0 or numbers[i - 1] <= replacement:\n                    numbers[i] = replacement\n                    if i == n - 1 or numbers[i + 1] >= numbers[i]:\n                        return \" \".join(str(x) for x in numbers)\n    return \"impossible\""
    },
    {
        "number": 3101,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    if len(numbers) != n:\n        return \"impossible\"\n\n    for i in range(n):\n        if i == 0 or numbers[i] <= numbers[i - 1]:\n            continue\n        else:\n            for j in range(9, 0, -1):\n                if j < numbers[i]:\n                    numbers[i] = j + 1\n                    break\n\n    for i in range(1, n):\n        if numbers[i] < numbers[i - 1]:\n            return \"impossible\"\n\n    return \" \".join([str(x) for x in numbers])"
    },
    {
        "number": 3101,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    if len(numbers) != n:\n        return \"impossible\"\n\n    for i in range(n):\n        for digit in range(9):\n            if str(digit) in str(numbers[i]):\n                new_number = str(numbers[i]).replace(str(digit), str(digit + 1))\n                new_numbers = numbers[:i] + [int(new_number)] + numbers[i + 1:]\n                if new_numbers != sorted(new_numbers):\n                    return ' '.join(str(x) for x in new_numbers)\n\n    return \"impossible\""
    },
    {
        "number": 3101,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n\n    if len(numbers) != n:\n        return \"impossible\"\n\n    for i in range(n):\n        if i < n - 1 and numbers[i] > numbers[i + 1]:\n            numbers[i] -= 1\n            return \" \".join(str(x) for x in numbers)\n\n    return \"impossible\""
    },
    {
        "number": 3101,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_sorted(numbers):\n        return all(numbers[i] <= numbers[i + 1] for i in range(len(numbers) - 1))\n\n    def replace_digit(numbers, index, digit):\n        if index == 0:\n            return [int(str(numbers[index])[1:]), int(str(numbers[index + 1])[0] + str(digit) + str(numbers[index + 1])[1:])] + numbers[index + 2:]\n        elif index == len(numbers) - 1:\n            return numbers[:index] + [int(str(numbers[index - 1])[:-1] + str(digit)), numbers[-1]]\n        else:\n            return numbers[:index] + [int(str(numbers[index - 1])[:-1] + str(digit) + str(numbers[index + 1])[1:])] + numbers[index + 1:]\n\n    n = int(stdin.readline().strip())\n    numbers = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1 or is_sorted(numbers):\n        print(\"impossible\")\n    else:\n        for i in range(n):\n            if numbers[i] > 0 and numbers[i] // 10 != 0:\n                for digit in range(10):\n                    if digit != numbers[i] % 10:\n                        new_numbers = replace_digit(numbers, i, digit)\n                        if not is_sorted(new_numbers):\n                            print(\" \".join(map(str, new_numbers)))\n                            return\n\n    print(\"impossible\")"
    },
    {
        "number": 3101,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    numbers = list(map(int, stdin.readline().strip().split()))\n\n    # Check if the list is already sorted\n    is_sorted = all(numbers[i] <= numbers[i + 1] for i in range(n - 1))\n\n    if not is_sorted:\n        return \"impossible\"\n\n    # Find the index of the number that can be changed\n    index = -1\n    for i in range(n - 1):\n        if numbers[i] == numbers[i + 1]:\n            index = i\n            break\n\n    # If there is no number that can be changed, return \"impossible\"\n    if index == -1:\n        return \"impossible\"\n\n    # Replace the digit in the selected number\n    changed_number = numbers[index]\n    for digit in range(10):\n        if changed_number % 10 != digit:\n            numbers[index] += digit - changed_number % 10\n            break\n\n    return \" \".join(str(num) for num in numbers)"
    },
    {
        "number": 3101,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    numbers = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return \"impossible\"\n\n    for i in range(n):\n        if i == 0 or numbers[i - 1] <= numbers[i]:\n            continue\n        for j in range(9):\n            if j < int(numbers[i] / 10) or (j == int(numbers[i] / 10) and numbers[i] % 10 > j):\n                new_number = int(numbers[i] / 10) * 10 + j\n                if i == 1:\n                    return \"impossible\"\n                else:\n                    for k in range(i - 1, -1, -1):\n                        if numbers[k] <= new_number:\n                            continue\n                        else:\n                            if k == 0 or numbers[k - 1] <= new_number:\n                                return \" \".join(map(str, numbers[:k] + [new_number] + numbers[k:]))\n            else:\n                break\n\n    return \"impossible\""
    },
    {
        "number": 3102,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    def is_valid(num: int) -> bool:\n        str_num = str(num)\n        count_6_8 = str_num.count('6') + str_num.count('8')\n        count_not_6_8 = len(str_num) - count_6_8\n        return '4' not in str_num and count_6_8 == count_not_6_8\n\n    MOD = 10**9 + 7\n    count = 0\n    for num in range(L, R + 1):\n        if is_valid(num):\n            count += 1\n    return str(count % MOD)"
    },
    {
        "number": 3102,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    def has_no_4(num):\n        while num:\n            if num % 10 == 4:\n                return False\n            num //= 10\n        return True\n\n    def count_6_8(num):\n        count_6_8 = 0\n        count_not_6_8 = 0\n        while num:\n            digit = num % 10\n            if digit == 6 or digit == 8:\n                count_6_8 += 1\n            else:\n                count_not_6_8 += 1\n            num //= 10\n        return count_6_8, count_not_6_8\n\n    mod = 10**9 + 7\n    count = 0\n    for num in range(L, R + 1):\n        if has_no_4(num):\n            c6, cn6 = count_6_8(num)\n            if c6 == cn6:\n                count += 1\n                count %= mod\n\n    return str(count)"
    },
    {
        "number": 3102,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    def is_valid(number):\n        if '4' in str(number):\n            return False\n        six_count = str(number).count('6')\n        eight_count = str(number).count('8')\n        if six_count != eight_count:\n            return False\n        return True\n\n    valid_houses = [i for i in range(L, R + 1) if is_valid(i)]\n    return str(len(valid_houses) % (10**9 + 7))"
    },
    {
        "number": 3102,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    MOD = 10**9 + 7\n    total = 0\n\n    for num in range(L, R + 1):\n        str_num = str(num)\n        digits = [int(d) for d in str_num]\n        sixes_or_eights = sum(1 for d in digits if d in [6, 8])\n        non_sixes_or_eights = sum(1 for d in digits if d not in [6, 8])\n\n        if \"4\" not in str_num and sixes_or_eights == non_sixes_or_eights:\n            total += 1\n\n    return str(total % MOD)"
    },
    {
        "number": 3102,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    def is_valid(num: int) -> bool:\n        num_str = str(num)\n        count_6_8 = sum(1 for d in num_str if d in ('6', '8'))\n        count_not_6_8 = sum(1 for d in num_str if d not in ('6', '8'))\n        return '4' not in num_str and count_6_8 == count_not_6_8\n    valid_houses = [num for num in range(L, R + 1) if is_valid(num)]\n    return str((len(valid_houses) % (10**9 + 7)))"
    },
    {
        "number": 3102,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    MOD = 10**9 + 7\n    houses = 0\n\n    for num in range(L, R + 1):\n        if '4' not in str(num) and str(num).count('6') == str(num).count('8'):\n            houses += 1\n\n    return str(houses % MOD)"
    },
    {
        "number": 3102,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = 0\n    for num in range(L, R + 1):\n        has_four = False\n        num_six_eight = 0\n        num_other = 0\n        for digit in str(num):\n            if digit == '4':\n                has_four = True\n                break\n            if digit == '6' or digit == '8':\n                num_six_eight += 1\n            else:\n                num_other += 1\n        if not has_four and num_six_eight == num_other:\n            count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3102,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n\n    for i in range(L, R + 1):\n        has_4 = any(digit == '4' for digit in str(i))\n        num_6_8 = sum(1 for digit in str(i) if digit in ('6', '8'))\n        num_not_6_8 = len(str(i)) - num_6_8\n        if not has_4 and num_6_8 == num_not_6_8:\n            count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 3102,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    n_houses = 0\n    mod = 10**9 + 7\n\n    for house_num in range(L, R + 1):\n        has_four = '4' in str(house_num)\n        count_six_eight = 0\n        count_not_six_eight = 0\n\n        for digit in str(house_num):\n            if digit in ('6', '8'):\n                count_six_eight += 1\n            else:\n                count_not_six_eight += 1\n\n        if not has_four and count_six_eight == count_not_six_eight:\n            n_houses += 1\n\n    return str(n_houses % mod)"
    },
    {
        "number": 3102,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    mod = 10**9 + 7\n    count = 0\n\n    for i in range(l, r + 1):\n        if '4' not in str(i):\n            s = str(i)\n            six_count = s.count('6')\n            eight_count = s.count('8')\n            if six_count == eight_count:\n                count += 1\n\n    return str(count % mod)"
    },
    {
        "number": 3103,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    Y, X, x_init, map = list(map(int, stdin.split()))\n    map = [list(row) for row in map]\n\n    # Initialize variables\n    paths = set()\n    visited = set()\n    castle_pos = (-1, -1)\n\n    # Find the castle position\n    for y in range(Y):\n        for x in range(X):\n            if map[y][x] == '@':\n                castle_pos = (y, x)\n\n    # Recursive function to explore all paths\n    def explore_path(pos: tuple, curr_path: str):\n        y, x = pos\n\n        # Base case: reached the castle\n        if pos == castle_pos:\n            paths.add(curr_path)\n            return\n\n        # Check if the current position has already been visited\n        if pos in visited:\n            return\n        visited.add(pos)\n\n        # Check for valid movements\n        if y > 0 and map[y - 1][x] not in '#~':\n            explore_path((y - 1, x), curr_path + 'N')\n        if x < X - 1 and map[y][x + 1] not in '#~':\n            explore_path((y, x + 1), curr_path + 'E')\n        if x > 0 and map[y][x - 1] not in '#~':\n            explore_path((y, x - 1), curr_path + 'W')\n\n    # Explore all paths starting from the initial position\n    explore_path((Y - 1, x_init), 'S')\n\n    # Calculate the number of distinct paths modulo 100003\n    num_paths = len(paths)\n    if num_paths == 0:\n        return \"begin repairs\"\n    return num_paths % 100003"
    },
    {
        "number": 3103,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init, map = list(map(int, stdin.split()))\n    map = list(map(list, map.split('\\n')))\n\n    def dfs(x, y, curr_path):\n        if x == X - 1 and map[y][x] == '@':\n            return [curr_path]\n        if x < 0 or x >= X or y < 0 or y >= Y or map[y][x] == '#':\n            return []\n\n        paths = []\n        if map[y][x] == '>':\n            for i in range(x + 1, X):\n                if map[y][i] not in ('<', '#'):\n                    paths.extend(dfs(i, y, curr_path + [f'{y},{i}']))\n                    break\n        elif map[y][x] == '<':\n            for i in range(x - 1, -1, -1):\n                if map[y][i] not in ('>', '#'):\n                    paths.extend(dfs(i, y, curr_path + [f'{y},{i}']))\n                    break\n        else:\n            paths.extend(dfs(x + 1, y, curr_path + [f'{y},{x+1}']))\n            paths.extend(dfs(x - 1, y, curr_path + [f'{y},{x-1}']))\n\n        return paths\n\n    paths = dfs(x_init, Y - 1, [f'{Y-1},{x_init}'])\n    if not paths:\n        return \"begin repairs\"\n    return str(len(paths) % 1000003)"
    },
    {
        "number": 3103,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Helper functions\n    def dfs(x: int, y: int, x_init: int, direction: str, visited: set, paths: set) -> None:\n        if (x, y) in visited:\n            return\n        if (x, y) == (0, 0) and direction == 'west':\n            paths.add(tuple(visited))\n            return\n        if (x, y) == (X - 1, 0) and direction == 'east':\n            paths.add(tuple(visited))\n            return\n        visited.add((x, y))\n        if C[x][y] == '>':\n            dfs(x + 1, y, x_init, direction, visited, paths)\n        elif C[x][y] == '<':\n            dfs(x - 1, y, x_init, direction, visited, paths)\n        elif C[x][y] == '~' and direction != 'north':\n            if x > x_init:\n                dfs(x, y, x_init, 'east', visited, paths)\n                dfs(x - 1, y, x_init, 'west', visited, paths)\n            else:\n                dfs(x, y, x_init, 'west', visited, paths)\n                dfs(x + 1, y, x_init, 'east', visited, paths)\n        dfs(x, y + 1, x_init, direction, visited, paths)\n\n    # Parse input\n    Y, X, x_init = map(int, stdin.split()[:3])\n    C = [list(stdin.split()[3 + i]) for i in range(Y)]\n\n    # Initialize variables\n    castle_pos = (0, 0)\n    for y in range(Y):\n        for x in range(X):\n            if C[y][x] == '@':\n                castle_pos = (x, y)\n\n    # DFS to find all possible paths\n    paths = set()\n    dfs(castle_pos[0], 0, x_init, 'north', set(), paths)\n\n    # Calculate output\n    if not paths:\n        return \"begin repairs\"\n    return str(len(paths)) + \" \" + str(1000003)"
    },
    {
        "number": 3103,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    Y, X, x_init, map = list(map(int, stdin.split()))\n    map = [list(line) for line in map.split('\\n')]\n\n    # DFS to find all possible paths\n    def dfs(x, y):\n        if map[y][x] == '@':\n            return 1\n        if map[y][x] == '#' or y == 0:\n            return 0\n        map[y][x] = '#'\n        ret = dfs(x, y - 1) + dfs(x - 1, y) + dfs(x + 1, y)\n        map[y][x] = '.'\n        return ret\n\n    # Call DFS and count the number of paths\n    count = 0\n    for i in range(X):\n        count += dfs(i, Y - 1)\n        if i != x_init:\n            count += dfs(i, Y - 1)\n    count %= 1000003\n\n    # Check if there is no way to get to the castle\n    if count == 0:\n        return \"begin repairs\"\n    else:\n        return str(count)"
    },
    {
        "number": 3103,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x, y, direction, visited):\n        if (x, y) in visited and visited[(x, y)] != direction:\n            return 0\n        visited[(x, y)] = direction\n        \n        if grid[y][x] == '@':\n            return 1\n        \n        if grid[y][x] == '#':\n            return 0\n        \n        if grid[y][x] == '>':\n            return dfs(x+1, y, direction, visited)\n        \n        if grid[y][x] == '<':\n            return dfs(x-1, y, direction, visited)\n        \n        if grid[y][x] == '~':\n            res = 0\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                res += dfs(x+dx, y+dy, direction, visited)\n            return res\n        \n        return 0\n    \n    Y, X, x_init = map(int, stdin.readline().strip().split())\n    grid = [stdin.readline().strip() for _ in range(Y)]\n    \n    mod = 1000003\n    res = dfs(x_init, Y-1, '~', {})\n    \n    if res == 0:\n        return \"begin repairs\"\n    else:\n        return str(res % mod) "
    },
    {
        "number": 3103,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    Y, X, x_init = map(int, input_data[0].split())\n    map_data = input_data[1:]\n\n    MODIFIER = 1000003\n    total_routes = 0\n    visited = [[False for _ in range(X)] for _ in range(Y)]\n    castle_position = None\n\n    def dfs(y, x, curr_routes):\n        nonlocal total_routes\n        if y < 0 or y >= Y or x < 0 or x >= X:\n            return\n        if map_data[y][x] == '#' or visited[y][x]:\n            return\n        if map_data[y][x] == '@':\n            total_routes += curr_routes\n            return\n\n        visited[y][x] = True\n        if map_data[y][x] == '>':\n            dfs(y, x + 1, curr_routes)\n        elif map_data[y][x] == '<':\n            dfs(y, x - 1, curr_routes)\n        dfs(y + 1, x, curr_routes + 1)\n\n        visited[y][x] = False\n\n    for y, row in enumerate(map_data):\n        for x, col in enumerate(row):\n            if col == '@':\n                castle_position = (y, x)\n            elif col == '>':\n                if x + 1 < X and map_data[y][x + 1] not in ('<', '#'):\n                    dfs(y, x + 1, 1)\n            elif col == '<':\n                if 0 <= x - 1 and map_data[y][x - 1] not in ('>', '#'):\n                    dfs(y, x - 1, 1)\n\n    if total_routes == 0:\n        return \"begin repairs\"\n    else:\n        return total_routes % MODIFIER "
    },
    {
        "number": 3103,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x, y, dx, dy, visited, modulo):\n        if y == 0 and '@' in visited:\n            return 1\n        if x < 0 or x >= len(map[0]) or y < 0 or y >= len(map):\n            return 0\n        if map[y][x] == '#' or (x, y) in visited:\n            return 0\n\n        visited.add((x, y))\n        result = 0\n        for nx, ny, ndx, ndy in [(x + 1, y, dx, dy), (x - 1, y, dx, dy), (x, y + 1, dx, dy), (x, y - 1, dx, dy)]:\n            if (ndx, ndy) != (dx, dy):\n                result += dfs(nx, ny, ndx, ndy, visited.copy(), modulo)\n                result %= modulo\n            else:\n                result += dfs(nx, ny, ndx, ndy, visited, modulo)\n                result %= modulo\n\n        visited.remove((x, y))\n        return result\n\n    Y, X, x_init = map(int, stdin.split()[:3])\n    map = [list(stdin.split()[3 + i]) for i in range(Y)]\n    visited = set()\n    modulo = 1000003\n    answer = dfs(x_init, Y - 1, 0, 0, visited, modulo)\n\n    return str(answer) if answer != 0 else \"begin repairs\""
    },
    {
        "number": 3103,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.readline().split())\n    map_data = [list(stdin.readline().strip()) for _ in range(Y)]\n    castle_pos = next((x, y) for y in range(Y) for x in range(X) if map_data[y][x] == '@')\n    if x_init == castle_pos[0]:\n        return \"begin repairs\"\n    paths = dfs(map_data, castle_pos, x_init, X)\n    return str(len(paths) % 1000003)\n\ndef"
    },
    {
        "number": 3103,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    Y, X, x_init, map = list(map(int, stdin.split()))\n    map = list(map(list, map.split()))\n\n    # Initialize variables\n    directions = {'<', '>', '@'}\n    visited = set()\n    paths = []\n\n    # Define recursive function to traverse the map\n    def dfs(x, y, curr_path, curr_count):\n        # Check if we've reached the castle\n        if map[y][x] == '@':\n            curr_path.append((x, y))\n            paths.append(curr_path)\n            return\n\n        # Check if we've already been to this cell\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n\n        # Check if we can move in any direction\n        if map[y][x] == '>':\n            if x + 1 < X and map[y][x + 1] not in directions:\n                dfs(x + 1, y, curr_path + [(x, y)], curr_count * 2)\n        elif map[y][x] == '<':\n            if 0 <= x - 1 and map[y][x - 1] not in directions:\n                dfs(x - 1, y, curr_path + [(x, y)], curr_count * 2)\n\n        # Move north\n        if y + 1 < Y and map[y + 1][x] not in directions:\n            dfs(x, y + 1, curr_path + [(x, y)], curr_count)\n\n    # Call the recursive function\n    dfs(x_init, Y - 1, [], 1)\n\n    # Check if there are any valid paths\n    if not paths:\n        return \"begin repairs\"\n\n    # Calculate the number of distinct paths\n    num_paths = len(paths)\n    for path1 in paths:\n        for path2 in paths:\n            if path1 != path2 and path1[-len(path2):] == path2:\n                num_paths += 1\n    return str(num_paths % 1000003)"
    },
    {
        "number": 3103,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split()[:3])\n    map_data = [list(line) for line in stdin.split('\\n')[1:]]\n\n    def is_valid(x, y):\n        if 0 <= x < X and 0 <= y < Y:\n            return True\n        return False\n\n    def get_currents(x, y):\n        if map_data[y][x] == '>':\n            return [(x + 1, y)]\n        elif map_data[y][x] == '<':\n            return [(x - 1, y)]\n        return [(x, y)]\n\n    def dfs(x, y, route=None):\n        if route is None:\n            route = []\n\n        if map_data[Y - 1][x] == '@':\n            return [route + [(x, Y - 1)]]\n\n        next_routes = []\n        for next_x, next_y in get_currents(x, y):\n            if map_data[next_y][next_x] != '#' and (next_x, next_y) not in route:\n                next_routes.extend(dfs(next_x, next_y, route + [(x, y)]))\n\n        return next_routes\n\n    routes = dfs(x_init, Y - 1)\n    if not routes:\n        return \"begin repairs\"\n\n    unique_routes = set(tuple(route) for route in routes)\n    return f\"{len(unique_routes)}\""
    },
    {
        "number": 3104,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.split('=')\n    n = len(A)\n    result = []\n\n    for i in range(n):\n        if A[i] == S[i]:\n            result.append(A[i])\n        else:\n            j = i + 1\n            while j < n and A[j] == '0':\n                j += 1\n            if j < n:\n                result.append(f'{A[i:j]}+')\n                i = j - 1\n            else:\n                result.append(A[i])\n\n    return ''.join(result) + '=' + S"
    },
    {
        "number": 3104,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Split the equation into left and right sides\n    A, S = stdin.split('=')\n    \n    # Convert the left side to an integer\n    A = int(A)\n    \n    # Find all possible partitions of A\n    def partitions(n):\n        if n == 0:\n            return [[]]\n        result = []\n        for i in range(1, n + 1):\n            for p in partitions(n - i):\n                result.append([i] + p)\n        return result\n    \n    # Check if a partition can make the equation correct\n    def is_valid_partition(partition):\n        for i in range(len(partition) - 1):\n            if partition[i] + partition[i + 1] >= 100:\n                return False\n        return sum(partition) == S\n    \n    # Find the smallest valid partition\n    for partition in partitions(len(A)):\n        if is_valid_partition(partition):\n            break\n    \n    # Construct the corrected equation\n    equation = ''\n    for i, digit in enumerate(A):\n        if i in partition:\n            equation += '+'\n        equation += digit\n    \n    return equation + '=' + str(S)"
    },
    {
        "number": 3104,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.strip().split('=')\n    A = list(A)\n    S = int(S)\n    result = []\n    i = 0\n    while i < len(A):\n        if i < len(A) - 1 and int(A[i]) + int(A[i + 1]) == S:\n            result.append(f\"{A[i]}+{A[i+1]}\")\n            i += 2\n        else:\n            result.append(A[i])\n            i += 1\n    return \"=\".join((\"\".join(result), str(S)))"
    },
    {
        "number": 3104,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, s = stdin.split('=')\n    a = list(a)\n    s = int(s)\n    i = 0\n    while i < len(a) - 1:\n        if s == 0:\n            break\n        if a[i] == '0' and int(a[i + 1]) > 9:\n            a.pop(i)\n            a[i] = str(int(a[i]) + int(a.pop(i) + a[i]))\n        else:\n            i += 1\n        s -= int(a[i])\n    return ''.join(a) + '=' + str(s)"
    },
    {
        "number": 3104,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.strip().split('=')\n    n = len(A)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n, -1, -1):\n        for j in range(n - i, -1, -1):\n            if A[i:i + j + 1].startswith('0'):\n                dp[i][j] = 0\n                continue\n\n            for k in range(1, j + 1):\n                dp[i][j] = max(dp[i][j], dp[i + k][j - k] + int(A[i:i + k]) * int(A[i + k:i + 2 * k]))\n\n    ans = []\n    i, j = 0, n\n    while j > 0:\n        for k in range(1, j + 1):\n            if dp[i][j - 1] == dp[i][j] + dp[i + k][j - k] + int(A[i:i + k]) * int(A[i + k:i + 2 * k]):\n                ans.append(A[i:i + k])\n                i += k\n                j -= k\n                break\n\n    return '+'.join(ans) + '=' + S"
    },
    {
        "number": 3104,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, s = map(int, stdin.split('='))\n    a_str = str(a)\n    s_str = str(s)\n\n    def add_operators(num: str, target: int) -> List[str]:\n        res = []\n        def backtrack(curr: str, start: int, temp_sum: int, prev_val: int) -> None:\n            if start == len(num):\n                if temp_sum == target:\n                    res.append(curr)\n                return\n\n            for i in range(start, len(num)):\n                val = int(num[start:i+1])\n                if str(val) != num[start:i+1]:\n                    break\n                if start == 0:\n                    backtrack(f\"{val}+{num[i+1:]}\", i+1, temp_sum + val - prev_val, val)\n                else:\n                    backtrack(f\"{curr[:-1]}+{val}+{num[i+1:]}\", i+1, temp_sum + val - prev_val, val)\n\n        backtrack(num, 0, 0, 0)\n        return res\n\n    def find_min_operations(ops: List[str]) -> str:\n        min_ops = float('inf')\n        min_str = ''\n        for op in ops:\n            if op.count('+') < min_ops:\n                min_ops = op.count('+')\n                min_str = op\n            elif op.count('+') == min_ops:\n                min_str = min(min_str, op)\n        return min_str\n\n    ops = add_operators(a_str, s)\n    min_ops_str = find_min_operations(ops)\n\n    return min_ops_str.replace('+', '+ ')"
    },
    {
        "number": 3104,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, s = map(int, stdin.split('='))\n    a_str = str(a)\n    s_str = str(s)\n    while len(a_str) > 1:\n        for i in range(1, len(a_str)):\n            if int(a_str[:i]) + int(a_str[i:]) == int(s_str):\n                a_str = a_str[:i] + '+' + a_str[i:]\n                break\n    return a_str + '=' + s_str"
    },
    {
        "number": 3104,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, s = stdin.split('=')\n    result = []\n    i = 0\n    while i < len(a):\n        if a[i] != '0':\n            j = i + 1\n            while j < len(a) and a[j] != '0':\n                j += 1\n            result.append(int(a[i:j]))\n            i = j\n        else:\n            i += 1\n\n    return '+'.join(map(str, result)) + '=' + s"
    },
    {
        "number": 3104,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.split('=')\n    A = list(A)\n    S = int(S)\n    \n    def dfs(index: int, A: list, S: int, result: list):\n        if index == len(A) - 1:\n            num = int(''.join(A))\n            if num == S:\n                result.append(''.join(A))\n            return\n        \n        if A[index] == '0':\n            A[index] = '+'\n            dfs(index + 1, A, S, result)\n            A[index] = '0'\n            return\n        \n        for i in range(index + 1, len(A) + 1):\n            num = int(''.join(A[index:i]))\n            if num < S:\n                A[index:i] = ['+'] * (i - index) + A[i:]\n                A[index] = '0'\n                dfs(index + 1, A, S, result)\n                A[index:i] = A[index + 1:i] + [A[index]]\n                A[index + 1:i] = ['0'] * (i - index - 1)\n            elif num == S:\n                result.append(''.join(A[:index] + [str(num)] + A[i:]))\n                return\n            else:\n                break\n    \n    result = []\n    dfs(0, A, S, result)\n    \n    return result[0] if result else \"No solution\""
    },
    {
        "number": 3104,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.split('=')\n    i = 0\n    while i < len(A) - 1:\n        if int(A[i]) + int(A[i+1]) <= 9:\n            A = A[:i] + str(int(A[i]) + int(A[i+1])) + A[i+2:]\n        else:\n            i += 1\n    return A + '=' + S "
    },
    {
        "number": 3105,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    S = [int(x) for x in stdin.readlines()]\n\n    found_pattern = False\n    for c in range(N - 3):\n        if S[c] == S[c + 2] and S[c] != S[c + 1]:\n            found_pattern = True\n            A = S[c]\n            B = S[c + 1]\n            break\n\n    if found_pattern:\n        return f\"{A} {B}\"\n    else:\n        return \"-1\""
    },
    {
        "number": 3105,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_pattern(arr):\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] != arr[j]:\n                    for k in range(j + 1, len(arr)):\n                        if arr[i] == arr[k] and arr[j] == arr[k + 1]:\n                            return (arr[i], arr[j])\n        return None\n\n    def lexicographically_smallest_pair(pair):\n        if pair is not None:\n            if pair[0] < pair[1]:\n                return pair\n            elif pair[1] < pair[0]:\n                return (pair[1], pair[0])\n            else:\n                return (pair[0], pair[1])\n        else:\n            return -1\n\n    stdin_list = [int(x) for x in stdin.splitlines()]\n    n = stdin_list[0]\n    arr = stdin_list[1:]\n\n    pattern = find_pattern(arr)\n    return f\"{lexicographically_smallest_pair(pattern)}\\n\""
    },
    {
        "number": 3105,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    S = [int(x) for x in stdin.read().strip().split()]\n\n    for i in range(N - 3):\n        for j in range(i + 1, N - 2):\n            if S[i] == S[j] or S[i + 1] == S[j + 1]:\n                continue\n            if S[i] == S[j + 1] and S[i + 1] == S[j + 2]:\n                return f\"{S[i]} {S[i + 1]}\\n\"\n            elif S[i + 1] == S[j] and S[i] == S[j + 2]:\n                return f\"{S[i]} {S[i + 1]}\\n\"\n    return \"-1\\n\""
    },
    {
        "number": 3105,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    S = [int(x) for x in stdin.read().split()]\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if S[i] != S[j]:\n                for k in range(j + 1, N):\n                    if S[i] == S[k] and S[j] == S[k + 1]:\n                        return f\"{S[i]} {S[j]}\"\n                    elif S[i] == S[k + 1] and S[j] == S[k]:\n                        return f\"{S[j]} {S[i]}\"\n\n    return \"-1\""
    },
    {
        "number": 3105,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    S = [int(line) for line in lines[1:]]\n\n    def is_pattern(A: int, B: int) -> bool:\n        for i in range(N - 3):\n            if S[i] == A and S[i + 1] == B and S[i + 2] == A and S[i + 3] == B:\n                return True\n        return False\n\n    A, B = -1, -1\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            if is_pattern(i, j):\n                if A == -1 or (i < A or (i == A and j < B)):\n                    A, B = i, j\n\n    if A == -1 or B == -1:\n        return \"-1\\n\"\n    else:\n        return f\"{A} {B}\\n\""
    },
    {
        "number": 3105,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    S = [0] * (N + 1)\n    for i in range(N):\n        S[int(stdin.readline().strip())] = i + 1\n    \n    found_pattern = False\n    A, B = -1, -1\n    \n    for i in range(1, N):\n        if S[i] > 0 and S[i] != S[i - 1]:\n            if S[i] == S[i + 2] and S[i + 1] != S[i - 1]:\n                if not found_pattern:\n                    A, B = S[i], S[i + 1]\n                    found_pattern = True\n                elif A > S[i] or (A == S[i] and B > S[i + 1]):\n                    A, B = S[i], S[i + 1]\n                    \n    return f\"{A} {B}\" if found_pattern else \"-1\""
    },
    {
        "number": 3105,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    S = [int(line.strip()) for line in stdin.readlines()]\n\n    for c in range(N - 3):\n        for d in range(c + 1, N - 2):\n            for e in range(d + 1, N - 1):\n                for f in range(e + 1, N):\n                    if S[c] == S[e] and S[d] == S[f] and S[c] != S[d]:\n                        return f\"{S[c]} {S[d]}\"\n    return \"-1\""
    },
    {
        "number": 3105,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_pattern(s: List[int], n: int) -> Tuple[int, int]:\n        for i in range(n - 3):\n            for j in range(i + 1, n - 2):\n                if s[i] != s[j] and s[i + 1] == s[j + 1]:\n                    return s[i], s[j]\n        return -1, -1\n\n    n = int(stdin.readline().strip())\n    s = [int(stdin.readline().strip()) for _ in range(n)]\n\n    a, b = find_pattern(s, n)\n\n    if a != -1 and b != -1:\n        return f\"{a} {b}\\n\"\n    else:\n        return \"-1\\n\""
    },
    {
        "number": 3105,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    S = [int(line.strip()) for line in stdin.readlines()]\n\n    for i in range(N - 3):\n        for j in range(i + 1, N - 2):\n            for k in range(j + 1, N - 1):\n                for l in range(k + 1, N):\n                    if S[i] == S[k] and S[j] == S[l] and S[i] != S[j]:\n                        return f\"{S[i]} {S[j]}\"\n    return \"-1\""
    },
    {
        "number": 3105,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_pattern(arr):\n        for i in range(len(arr) - 3):\n            if arr[i] != arr[i + 2] and arr[i + 1] == arr[i + 3]:\n                return arr[i], arr[i + 1]\n        return None\n\n    def is_valid(c, d, e, f):\n        return S[c] != S[d] and S[e] == S[d] and S[c] == S[f]\n\n    N = int(stdin.readline().strip())\n    S = [int(x) for x in stdin.readlines()]\n\n    for c in range(N - 3):\n        for d in range(c + 1, N - 2):\n            for e in range(d + 1, N - 1):\n                for f in range(e + 1, N):\n                    if is_valid(c, d, e, f):\n                        return f\"{S[c]} {S[d]}\"\n\n    pattern = find_pattern(S)\n    if pattern:\n        return f\"{pattern[0]} {pattern[1]}\"\n    else:\n        return \"-1\""
    },
    {
        "number": 3106,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(i) for i in stdin]\n    n = len(lights)\n\n    if lights.count(0) == 0:\n        return \"0\"\n\n    time_steps = 0\n    while True:\n        new_lights = [0] * n\n        for i in range(n):\n            if lights[i] == 1:\n                continue\n            j = i + 1\n            while j < n and lights[j] == 0:\n                new_lights[j] = 1\n                j += 1\n        if new_lights.count(1) == 0:\n            return str(time_steps)\n        time_steps += 1\n        lights = new_lights"
    },
    {
        "number": 3106,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lights = list(stdin)\n    n = len(lights)\n    presses = []\n\n    # Check if all lights are off at the start\n    if '1' not in lights:\n        return '0'\n\n    # Check if there are any on lights to the right of the first off light\n    first_off_index = lights.index('0')\n    if '1' not in lights[first_off_index + 1:]:\n        return '1'\n\n    # Check if there are any off lights to the right of the last on light\n    last_on_index = lights.index('1')\n    if '0' not in lights[last_on_index + 1:]:\n        return '1'\n\n    # Press the first button before the first timestep\n    presses.append(1)\n\n    # Press the last button before the second timestep\n    presses.append(n)\n\n    # Press the button for the last on light before the third timestep\n    presses.append(last_on_index + 1)\n\n    return str(max(presses))"
    },
    {
        "number": 3106,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    lights = [int(i) for i in stdin]\n    buttons_pushed = []\n    max_time = 0\n\n    for i in range(n):\n        if lights[i] == 0:\n            buttons_pushed.append(i)\n            for j in range(i, n):\n                if (j - i) % 2 == 1:\n                    lights[j] = 1\n            break\n\n    for i in range(len(buttons_pushed)):\n        if buttons_pushed[i] == 0:\n            max_time = max_time + i + 1\n        else:\n            max_time = max_time + (i + 1) * 2\n\n    return str(max_time)"
    },
    {
        "number": 3106,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(i) for i in stdin]\n    n = len(lights)\n    time = 0\n\n    for i in range(n):\n        if lights[i] == 0:\n            time = max(time, i + 1)\n\n    for i in range(n):\n        if lights[i] == 0:\n            time = max(time, i + 1)\n\n        for j in range(i + 1, n):\n            if lights[j] == 0:\n                time = max(time, j + 1)\n\n            lights[j] ^= 1\n\n    return str(time)"
    },
    {
        "number": 3106,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    lights = [int(x) for x in stdin]\n    toggle = [0] * n\n    time = 0\n\n    for i in range(n):\n        if lights[i] == 1:\n            toggle[i] = 1\n\n    while sum(toggle) < n:\n        time += 1\n        new_toggle = [0] * n\n        for i in range(n):\n            if toggle[i] == 1:\n                for j in range(i + 1, n):\n                    if j - i <= n - j:\n                        new_toggle[j] = 1\n                    else:\n                        break\n                toggle[i] = 0\n        toggle = new_toggle\n\n    return str(time - 1)"
    },
    {
        "number": 3106,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(i) for i in stdin]\n    n = len(lights)\n    for i in range(n):\n        if lights[i] == 0:\n            break\n    else:\n        return \"0\"\n    for j in range(i, n):\n        if lights[j] == 0:\n            break\n    else:\n        return str(i + 1)\n    for k in range(j, n):\n        if lights[k] == 0:\n            break\n    else:\n        return str(i + 2)\n    return str(i + 3)"
    },
    {
        "number": 3106,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(i) for i in stdin]\n    n = len(lights)\n    time = 0\n\n    while 0 in lights:\n        time += 1\n        index = lights.index(0)\n        for i in range(index, n):\n            lights[i] = (lights[i] + 1) % 2\n\n    return str(time)"
    },
    {
        "number": 3106,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(i) for i in stdin]\n    n = len(lights)\n    time_on = -1\n    next_on = []\n    next_off = []\n    for i in range(n):\n        if lights[i] == 1:\n            next_on.append(i)\n        else:\n            next_off.append(i)\n    while next_on or next_off:\n        time_on += 1\n        new_next_on = []\n        new_next_off = []\n        for i in next_on:\n            if i < n - 1:\n                new_next_off.append(i + 1)\n        for i in next_off:\n            if i > 0:\n                new_next_on.append(i - 1)\n        next_on = new_next_on\n        next_off = new_next_off\n    return str(time_on)"
    },
    {
        "number": 3106,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(i) for i in stdin]\n    n = len(lights)\n    times = [0] * n\n\n    for i in range(n):\n        if lights[i] == 1:\n            times[i] = 1\n        else:\n            times[i] = -1\n\n        for j in range(i + 1, n):\n            if lights[j] == 1:\n                times[j] = max(times[j], times[i] + j - i)\n            else:\n                times[j] = min(times[j], times[i] - j + i)\n\n    return str(max(times) - n + 1)\n"
    },
    {
        "number": 3106,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(i) for i in stdin]\n    n = len(lights)\n    on_lights = [i + 1 for i in range(n) if lights[i] == 1]\n    on_lights.append(n + 1)\n    on_lights = sorted(on_lights)\n    for i in range(1, len(on_lights)):\n        if on_lights[i] - on_lights[i - 1] > 1:\n            return str(on_lights[i] - 2)\n    return \"0\""
    },
    {
        "number": 3107,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_encounters(route1, route2):\n        encounters = 0\n        for i in range(len(route1) - 1):\n            for j in range(i + 1, len(route1)):\n                for k in range(len(route2) - 1):\n                    for l in range(k + 1, len(route2)):\n                        if (route1[i] < route1[j] > route1[i + 1] < route2[k] > route2[k + 1] < route2[l] and\n                                route1[j] < route1[i] > route1[i + 1] < route2[k] > route2[k + 1] < route2[l]):\n                            encounters += 1\n        return encounters\n\n    stdin_list = stdin.split('\\n')\n    N, M = map(int, stdin_list[0].split())\n    routes = [list(map(int, line.split()))[1:] for line in stdin_list[1:N + 1]]\n    pairs = [list(map(int, line.split())) for line in stdin_list[N + 1:]]\n\n    result = []\n    for pair in pairs:\n        result.append(count_encounters(routes[pair[0] - 1], routes[pair[1] - 1]))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3107,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_between(x, a, b):\n        return a <= x <= b or b <= x <= a\n\n    def is_encounter(a, b, c, d):\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n        return is_between(a, c, d) and is_between(b, c, d)\n\n    N, M = map(int, stdin.readline().split())\n    routes = [list(map(int, stdin.readline().split()))[1:] for _ in range(N)]\n    encounters = [0] * M\n\n    for i in range(M):\n        a, b = map(int, stdin.readline().split())\n        a -= 1\n        b -= 1\n\n        for j in range(len(routes[a]) - 1):\n            for k in range(len(routes[b]) - 1):\n                if is_encounter(routes[a][j], routes[a][j + 1], routes[b][k], routes[b][k + 1]):\n                    encounters[i] += 1\n\n    return '\\n'.join(map(str, encounters))"
    },
    {
        "number": 3107,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_encounters(truck1, truck2):\n        encounters = 0\n        for i in range(len(truck1) - 1):\n            for j in range(i + 1, len(truck1)):\n                if truck1[i] < truck1[j] > truck2[i] < truck2[j]:\n                    encounters += 1\n        return encounters\n\n    def parse_input(stdin: str):\n        input_data = stdin.split(\"\\n\")\n        N, M = map(int, input_data[0].split())\n        trucks = [list(map(int, line.split()[1:])) for line in input_data[1:1 + N]]\n        pairs = [list(map(int, line.split())) for line in input_data[1 + N:]]\n        return N, M, trucks, pairs\n\n    N, M, trucks, pairs = parse_input(stdin)\n    result = []\n    for a, b in pairs:\n        result.append(count_encounters(trucks[a - 1], trucks[b - 1]))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3107,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_encounters(truck1, truck2):\n        encounters = 0\n        for i in range(len(truck1) - 1):\n            for j in range(i + 1, len(truck1)):\n                if truck1[i] < truck1[j] and truck2[i] > truck2[j]:\n                    encounters += 1\n                elif truck1[i] > truck1[j] and truck2[i] < truck2[j]:\n                    encounters += 1\n        return encounters\n\n    stdin = list(map(str, stdin.split()))\n    N, M = int(stdin[0]), int(stdin[1])\n    trucks = [stdin[2: 2 + N * 2 + 1: 2]]\n    trucks = [list(map(int, t)) for t in trucks]\n\n    pairs = [stdin[2 + N * 2 + 1:: 2]]\n    pairs = [list(map(int, p)) for p in pairs]\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if (i + 1, j + 1) in pairs or (j + 1, i + 1) in pairs:\n                encounters = count_encounters(trucks[i], trucks[j])\n                print(encounters)"
    },
    {
        "number": 3107,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_encounters(trucks, truck_pairs):\n        def find_intersection(route1, route2):\n            intersection_points = []\n            for i in range(len(route1) - 1):\n                for j in range(len(route2) - 1):\n                    if (\n                        route1[i] < route1[i + 1]\n                        and route2[j] > route2[j + 1]\n                    ) or (\n                        route1[i] > route1[i + 1]\n                        and route2[j] < route2[j + 1]\n                    ):\n                        x1, y1, x2, y2 = (\n                            route1[i],\n                            route2[j],\n                            route1[i + 1],\n                            route2[j + 1],\n                        )\n                        if x1 != x2:\n                            m = (y2 - y1) / (x2 - x1)\n                            b = y1 - m * x1\n                            x = (route1[i] + route1[i + 1]) / 2\n                            y = m * x + b\n                            intersection_points.append((x, y))\n            return intersection_points\n\n        encounters = []\n        for pair in truck_pairs:\n            truck1, truck2 = pair\n            route1, route2 = trucks[truck1 - 1], trucks[truck2 - 1]\n            intersection_points = find_intersection(route1, route2)\n            encounters.append(len(intersection_points))\n        return encounters\n\n    stdin = stdin.split(\"\\n\")\n    N, M = map(int, stdin[0].split())\n    trucks = []\n    for i in range(1, N + 1):\n        route = list(map(int, stdin[i].split()[1:]))\n        trucks.append(route)\n    truck_pairs = []\n    for i in range(N + 1, N + 1 + M):\n        pair = list(map(int, stdin[i].split()))\n        truck_pairs.append(pair)\n\n    encounters = count_encounters(trucks, truck_pairs)\n    return \"\\n\".join(map(str, encounters))"
    },
    {
        "number": 3107,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_encounters(truck1, truck2):\n        encounters = 0\n        for i in range(len(truck1) - 1):\n            for j in range(len(truck2) - 1):\n                if (truck1[i] < truck1[i + 1] > truck2[j] < truck2[j + 1]) or (truck1[i] > truck1[i + 1] < truck2[j] > truck2[j + 1]):\n                    encounters += 1\n        return encounters\n\n    def read_input(stdin):\n        N, M = map(int, stdin.readline().split())\n        routes = []\n        for _ in range(N):\n            K, *A = map(int, stdin.readline().split())\n            routes.append(A)\n        pairs = []\n        for _ in range(M):\n            a, b = map(int, stdin.readline().split())\n            pairs.append((a, b))\n        return N, M, routes, pairs\n\n    N, M, routes, pairs = read_input(stdin)\n    result = []\n    for a, b in pairs:\n        result.append(count_encounters(routes[a - 1], routes[b - 1]))\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3107,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_intervals(route):\n        intervals = []\n        for i in range(len(route) - 1):\n            if route[i] < route[i + 1]:\n                intervals.append((route[i], route[i + 1]))\n            else:\n                intervals.append((route[i], 10 ** 9))\n                intervals.append((1, route[i + 1]))\n        return intervals\n\n    def get_encounters(truck1_route, truck2_route):\n        truck1_intervals = get_intervals(truck1_route)\n        truck2_intervals = get_intervals(truck2_route)\n        encounters = 0\n\n        for interval1 in truck1_intervals:\n            for interval2 in truck2_intervals:\n                if interval1[0] <= interval2[0] <= interval1[1] and interval2[0] <= interval1[0] <= interval2[1]:\n                    encounters += 1\n\n        return encounters\n\n    stdin_list = stdin.split('\\n')\n    N, M = map(int, stdin_list[0].split())\n    truck_routes = [list(map(int, line.split()[1:])) for line in stdin_list[1:N + 1]]\n    encounters = []\n\n    for i in range(N, N + M):\n        truck1, truck2 = map(int, stdin_list[i].split())\n        encounters.append(get_encounters(truck_routes[truck1 - 1], truck_routes[truck2 - 1]))\n\n    return '\\n'.join(map(str, encounters))\n"
    },
    {
        "number": 3107,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_encounters(truck1, truck2) -> int:\n        encounters = 0\n        i, j = 0, 0\n        while i < len(truck1) - 1 and j < len(truck2) - 1:\n            if truck1[i] < truck1[i + 1]:\n                if truck2[j] < truck2[j + 1]:\n                    if truck1[i + 1] < truck2[j] or truck2[j + 1] < truck1[i]:\n                        i += 1\n                    elif truck1[i] <= truck2[j] < truck1[i + 1] and truck2[j] <= truck1[i] < truck2[j + 1]:\n                        encounters += 1\n                        i += 1\n                        j += 1\n                    else:\n                        j += 1\n                else:\n                    if truck1[i + 1] < truck2[j] or truck2[j + 1] < truck1[i]:\n                        i += 1\n                    elif truck1[i] <= truck2[j] < truck1[i + 1] and truck2[j] <= truck1[i] < truck2[j + 1]:\n                        encounters += 1\n                        i += 1\n                        j += 1\n                    else:\n                        j += 1\n            else:\n                if truck2[j] < truck2[j + 1]:\n                    if truck1[i + 1] < truck2[j] or truck2[j + 1] < truck1[i]:\n                        i += 1\n                    elif truck1[i] <= truck2[j] < truck1[i + 1] and truck2[j] <= truck1[i] < truck2[j + 1]:\n                        encounters += 1\n                        i += 1\n                        j += 1\n                    else:\n                        j += 1\n                else:\n                    if truck1[i + 1] < truck2[j] or truck2[j + 1] < truck1[i]:\n                        i += 1\n                    elif truck1[i] <= truck2[j] < truck1[i + 1] and truck2[j] <= truck1[i] < truck2[j + 1]:\n                        encounters += 1\n                        i += 1\n                        j += 1\n                    else:\n                        j += 1\n        return encounters\n\n    stdin = stdin.split('\\n')\n    N, M = map(int, stdin[0].split())\n    trucks = []\n    for i in range(1, N + 1):\n        route = list(map(int, stdin[i].split()))\n        trucks.append(route[1:])\n\n    encounters = []\n    for i in range(N + 1, N + 1 + M):\n        truck1, truck2 = map(int, stdin[i].split())\n        encounters.append(count_encounters(trucks[truck1 - 1], trucks[truck2 - 1]))\n\n    return '\\n'.join(map(str, encounters))"
    },
    {
        "number": 3107,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_intersections(a1, a2, b1, b2):\n        if a1 > a2:\n            a1, a2 = a2, a1\n        if b1 > b2:\n            b1, b2 = b2, b1\n\n        if a1 <= b1 <= a2:\n            return b1, min(a2, b2)\n        elif a1 <= b2 <= a2:\n            return b2, min(a2, b1)\n        else:\n            return None, None\n\n    def count_encounters(routes, truck1, truck2):\n        encounters = 0\n\n        for i in range(len(routes[truck1]) - 1):\n            a1, a2 = routes[truck1][i], routes[truck1][i + 1]\n\n            for j in range(len(routes[truck2]) - 1):\n                b1, b2 = routes[truck2][j], routes[truck2][j + 1]\n\n                start, end = find_intersections(a1, a2, b1, b2)\n\n                if start is not None and end is not None:\n                    length = end - start\n                    encounters += length - 1\n\n        return encounters\n\n    stdin_list = stdin.split(\"\\n\")\n    N, M = map(int, stdin_list[0].split())\n\n    routes = [[] for _ in range(N)]\n\n    for i in range(N):\n        route = list(map(int, stdin_list[i + 1].split()[1:]))\n        routes[i] = route\n\n    result = []\n\n    for i in range(M):\n        truck1, truck2 = map(int, stdin_list[N + i + 1].split())\n        result.append(count_encounters(routes, truck1 - 1, truck2 - 1))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3107,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def meet_points(route1, route2):\n        meet_points = []\n        for i in range(len(route1) - 1):\n            for j in range(len(route2) - 1):\n                if route1[i] < route1[i + 1] > route2[j] < route2[j + 1]:\n                    meet_points.append((route1[i + 1], route2[j + 1]))\n                elif route1[i] > route1[i + 1] < route2[j] > route2[j + 1]:\n                    meet_points.append((route1[i + 1], route2[j + 1]))\n        return meet_points\n\n    def count_meetings(N, routes, pairs):\n        meet_count = []\n        for pair in pairs:\n            route1, route2 = routes[pair[0] - 1], routes[pair[1] - 1]\n            meet_points_list = meet_points(route1, route2)\n            meet_count.append(len(meet_points_list))\n        return meet_count\n\n    stdin_list = stdin.split('\\n')\n    N, M = map(int, stdin_list[0].split())\n    routes = []\n    for i in range(1, N + 1):\n        route = list(map(int, stdin_list[i].split()))[1:]\n        routes.append(route)\n    pairs = [list(map(int, stdin_list[N + i].split())) for i in range(M)]\n\n    meet_count = count_meetings(N, routes, pairs)\n    return '\\n'.join(map(str, meet_count))"
    },
    {
        "number": 3108,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_avg = sum(a[:K]) / K\n    min_sum = sum(a[:K])\n    max_sum = min_sum + (N - K) * a[K-1]\n    max_sum_prev = max_sum - a[K-1]\n\n    for i in range(K, N):\n        min_sum = min(min_sum, max_sum_prev)\n        max_sum = min_sum + (N - i - 1) * a[i]\n\n        max_avg = max(max_avg, (max_sum - min_sum) / (N - K + 1))\n        max_sum_prev = max_sum - a[i]\n\n    return format(max_avg, '.6f')"
    },
    {
        "number": 3108,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    arr = list(map(int, input().split()))\n\n    max_avg = sum(arr[:k]) / k\n    current_avg = max_avg\n\n    for i in range(1, n - k + 1):\n        current_avg += (arr[i + k - 1] - arr[i - 1]) / k\n        max_avg = max(max_avg, current_avg)\n\n    return '{:.6f}'.format(max_avg)"
    },
    {
        "number": 3108,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split('\\n')[0].split())\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_avg = -1\n    for i in range(N - K + 1):\n        subseq = numbers[i:i + K]\n        avg = sum(subseq) / K\n        if avg > max_avg:\n            max_avg = avg\n\n    return f\"{max_avg:.6f}\""
    },
    {
        "number": 3108,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    arr = list(map(int, stdin.readline().split()))\n    max_avg = 0\n    for i in range(N - K + 1):\n        subseq = arr[i:i + K]\n        avg = sum(subseq) / K\n        max_avg = max(max_avg, avg)\n    return \"{:.6f}\".format(max_avg)"
    },
    {
        "number": 3108,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split('\\n')[0].split())\n    nums = list(map(int, stdin.split('\\n')[1].split()))\n    \n    max_avg = sum(nums[:K]) / K\n    current_sum = sum(nums[:K])\n    current_len = K\n    \n    for i in range(K, N):\n        current_sum += nums[i] - nums[i - K]\n        current_avg = current_sum / current_len\n        max_avg = max(max_avg, current_avg)\n        \n    return f\"{max_avg:.6f}\""
    },
    {
        "number": 3108,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    numbers = list(map(int, input().split()))\n    \n    max_avg = sum(numbers[:K]) / K\n    max_sum = sum(numbers[:K])\n    max_start = 0\n    \n    for i in range(1, N - K + 1):\n        current_sum = max_sum - numbers[i - 1] + numbers[i + K - 1]\n        current_avg = current_sum / K\n        \n        if current_avg > max_avg:\n            max_avg = current_avg\n            max_sum = current_sum\n            max_start = i\n            \n    return f\"{max_avg:.6f}\""
    },
    {
        "number": 3108,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split('\\n')[0].split())\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_avg = sum(arr[:K]) / K\n    min_sum = sum(arr[:K])\n    max_sum = sum(arr[:K])\n    min_index = 0\n\n    for i in range(K, N):\n        min_sum = min(min_sum, min_sum - arr[i - K] + arr[i])\n        max_sum = max(max_sum, max_sum - arr[i - K] + arr[i])\n\n        if (i - K + 1) * min_sum < (i + 1) * max_sum:\n            min_index = i - K + 1\n            min_sum = (i + 1) * max_sum // (i - K + 1)\n            max_avg = max_sum / K\n\n    return f\"{max_avg:.6f}\""
    },
    {
        "number": 3108,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    nums = list(map(int, stdin.readline().split()))\n\n    max_avg = sum(nums[:K]) / K\n    min_sum = sum(nums[:K])\n    max_sum = max_avg * K\n\n    for i in range(K, N):\n        min_sum = min_sum - nums[i - K] + nums[i]\n        max_sum = max_avg * K\n\n        if min_sum <= max_sum:\n            max_avg = max(max_avg, (max_sum + min_sum) / (2 * K))\n\n    return f\"{max_avg:.6f}\""
    },
    {
        "number": 3108,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    nums = list(map(int, stdin.readline().split()))\n\n    max_avg = sum(nums[:K]) / K\n    current_avg = max_avg\n\n    for i in range(N - K):\n        current_avg = current_avg - nums[i] + nums[i + K]\n        max_avg = max(max_avg, current_avg)\n\n    return f\"{max_avg:.6f}\""
    },
    {
        "number": 3108,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N, K = map(int, lines[0].split())\n    arr = list(map(int, lines[1].split()))\n\n    max_avg = 0\n    for i in range(N - K + 1):\n        subseq = arr[i:i + K]\n        avg = sum(subseq) / K\n        if avg > max_avg:\n            max_avg = avg\n\n    return f\"{max_avg:.6f}\""
    },
    {
        "number": 3109,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_line() -> list:\n        return list(map(float, input().split()))\n\n    def min_max_difference(sand_volumes, section_minimums, section_maximums):\n        sand_volumes_copy = sand_volumes.copy()\n        total_sand_volume = sum(sand_volumes)\n        sand_heights = [total_sand_volume / w for w in sand_volumes_copy]\n\n        for i in range(n):\n            for j in range(m):\n                if section_minimums[i][j] <= section_maximums[i][j]:\n                    height = sand_heights[j]\n                    volume = sand_volumes_copy[j]\n                    while height > section_minimums[i][j]:\n                        height -= 1\n                        volume -= w\n                    sand_heights[j] = height\n                    sand_volumes_copy[j] = volume\n\n        sand_heights_sum = sum(sand_heights)\n        min_height = min(sand_heights)\n        max_height = max(sand_heights)\n        return max_height - min_height\n\n    line = read_line()\n    n, m, w, h = line\n    sand_volumes = read_line()\n    x = read_line()\n    section_minimums = [read_line() for _ in range(n)]\n    section_maximums = [read_line() for _ in range(n)]\n\n    result = min_max_difference(sand_volumes, section_minimums, section_maximums)\n    return f\"{result:.3f}\""
    },
    {
        "number": 3109,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def can_fill_constraints(volume_list, min_height_list, max_height_list, x_list, n, m):\n        for i in range(n):\n            for j in range(m):\n                min_volume = min_height_list[i][j] * x_list[i]\n                max_volume = max_height_list[i][j] * x_list[i]\n                if min_volume <= volume_list[j] <= max_volume:\n                    volume_list[j] -= min_volume\n                else:\n                    return False\n        return True\n\n    def find_min_difference(volume_list, x_list, n, m):\n        heights = [0] * n\n        for i in range(n):\n            for j in range(m):\n                heights[i] += volume_list[j] / x_list[i]\n        return max(heights) - min(heights)\n\n    def read_input(stdin):\n        input_list = stdin.split(\"\\n\")\n        n, m, w, h = list(map(int, input_list[0].split()))\n        volume_list = list(map(float, input_list[1].split()))\n        x_list = list(map(float, input_list[2].split()))\n        min_height_list = [list(map(float, input_list[i + 3].split())) for i in range(n)]\n        max_height_list = [list(map(float, input_list[i + n + 3].split())) for i in range(n)]\n        return n, m, w, h, volume_list, x_list, min_height_list, max_height_list\n\n    n, m, w, h, volume_list, x_list, min_height_list, max_height_list = read_input(stdin)\n\n    if can_fill_constraints(volume_list, min_height_list, max_height_list, x_list, n, m):\n        min_difference = find_min_difference(volume_list, x_list, n, m)\n        return f\"{min_difference:.3f}\"\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3109,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = list(map(int, stdin.readline().split()))\n    v = list(map(float, stdin.readline().split()))\n    x = list(map(float, stdin.readline().split()))\n    min_sand = [list(map(float, stdin.readline().split())) for _ in range(n)]\n    max_sand = [list(map(float, stdin.readline().split())) for _ in range(n)]\n\n    def is_valid(sand_levels: list) -> bool:\n        for i in range(n):\n            for j in range(m):\n                if not (min_sand[i][j] <= sand_levels[i][j] <= max_sand[i][j]):\n                    return False\n        return True\n\n    def dfs(sand_levels: list, current_section: int) -> float:\n        if current_section == n:\n            heights = [sum(sand_levels[i]) for i in range(n)]\n            return round(max(heights) - min(heights), 3)\n\n        for i in range(m):\n            for j in range(1, m - i):\n                sand_levels[current_section][i:i + j] = [0] * j\n                if is_valid(sand_levels):\n                    return dfs(sand_levels, current_section + 1)\n                sand_levels[current_section][i:i + j] = [v[k] for k in range(i, i + j)]\n\n    sand_levels = [[0] * m for _ in range(n)]\n    return dfs(sand_levels, 0)"
    },
    {
        "number": 3109,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def read_line() -> list:\n        return list(map(float, input().split()))\n\n    def read_grid(n: int, m: int) -> list:\n        grid = []\n        for _ in range(n):\n            row = read_line()\n            if len(row) == m:\n                grid.append(row)\n        return grid\n\n    def min_max(n: int, m: int, v: list, x: list, min_grid: list, max_grid: list) -> float:\n        volumes = [0] * m\n        for i in range(n):\n            for j in range(m):\n                volumes[j] += min_grid[i][j]\n\n        for i in range(n):\n            for j in range(m):\n                volumes[j] -= min_grid[i][j]\n                if volumes[j] < 0:\n                    return -1\n                volumes[j] += max_grid[i][j]\n                if volumes[j] > v[j]:\n                    return -1\n\n        heights = [0] * n\n        for i in range(n):\n            heights[i] = sum(max_grid[i])\n\n        return max(heights) - min(heights)\n\n    def binary_search(n: int, m: int, v: list, x: list, min_grid: list, max_grid: list) -> float:\n        lo, hi = 0, 1000000\n        while lo < hi:\n            mid = (lo + hi) / 2\n            if min_max(n, m, v, x, min_grid, [[mid * volume / sum(min_grid[i]) for volume in min_grid[i]] for i in range(n)]) >= 0:\n                lo = mid + 1e-5\n            else:\n                hi = mid - 1e-5\n        return lo\n\n    n, m, w, h = map(int, read_line())\n    v = read_line()\n    x = read_line()\n    min_grid = read_grid(n, m)\n    max_grid = read_grid(n, m)\n\n    return \"{:.3f}\".format(binary_search(n, m, v, x, min_grid, max_grid))"
    },
    {
        "number": 3109,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h, volumes, dividers, minimums, maximums = parse_input(stdin)\n    distribution = fill_sand(n, m, w, h, volumes, dividers, minimums, maximums)\n    return f\"{min_max_difference(distribution):.3f}\"\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h, volumes, x, min_sand, max_sand = parse_input(stdin)\n    total_volume = sum(volumes)\n    section_volumes = [total_volume / n] * n\n    for i in range(n):\n        section_volumes[i] -= sum(min_sand[i])\n    for i in range(n):\n        for j in range(m):\n            section_volumes[i] = min(section_volumes[i], max_sand[i][j] - min_sand[i][j])\n    section_heights = [section_volume / (w * (x[i] - x[i - 1])) if i > 0 else section_volume / (w * x[0]) for i, section_volume in enumerate(section_volumes)]\n    return \"{:.3f}\".format(max(section_heights) - min(section_heights))\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h, v, x, min_sand, max_sand = parse_input(stdin)\n    min_heights = [0] * n\n    max_heights = [0] * n\n\n    for i in range(n):\n        for j in range(m):\n            min_heights[i] += min_sand[i][j]\n            max_heights[i] += max_sand[i][j]\n\n    min_height = min(min_heights)\n    max_height = max(max_heights)\n    min_difference = max_height - min_height\n\n    for i in range(n):\n        for j in range(m):\n            min_sand[i][j] -= v[j] / (w * h)\n            max_sand[i][j] -= v[j] / (w * h)\n\n    for i in range(n):\n        for j in range(m):\n            min_heights[i] += min_sand[i][j]\n            max_heights[i] += max_sand[i][j]\n\n        min_height = min(min_heights)\n        max_height = max(max_heights)\n        difference = max_height - min_height\n        min_difference = min(min_difference, difference)\n\n    return format(min_difference, \".3f\")\n\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h, volume, x, min_sand, max_sand = read_input(stdin)\n    min_height = min_section_height(w, x, min_sand)\n    max_height = max_section_height(w, h, x, volume, min_sand, max_sand)\n    min_difference = float('inf')\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            difference = max_height[i] - min_height[j]\n            min_difference = min(min_difference, difference)\n    \n    return format(min_difference, \".3f\")\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def readline() -> str:\n        return stdin.readline().strip()\n\n    def readline_ints() -> List[int]:\n        return list(map(int, readline().split()))\n\n    def readline_floats() -> List[float]:\n        return list(map(float, readline().split()))\n\n    n, m, w, h = readline_ints()\n    vs = readline_floats()\n    xs = readline_floats()\n    min_amounts = [readline_floats() for _ in range(n)]\n    max_amounts = [readline_floats() for _ in range(n)]\n\n    def distribute_sand(sand_amounts: List[float], max_height: float) -> float:\n        sand_heights = [0.0] * m\n        for i in range(m):\n            remaining_sand = sand_amounts[i]\n            while remaining_sand > 0:\n                for j in range(m):\n                    if sand_heights[j] < sand_heights[j - 1]:\n                        sand_heights[j] += 1\n                        remaining_sand -= w\n                        if remaining_sand <= 0:\n                            break\n                else:\n                    return -1.0  # Unsatisfiable\n        return max_height - min(sand_heights)\n\n    def binary_search_min_max_height(lower: float, upper: float) -> float:\n        while upper - lower > 0.001:\n            mid = (lower + upper) / 2\n            if distribute_sand([min(vs[i], max_amounts[j][i]) for i in range(m)] + [0.0] * (m - n), mid) >= 0:\n                lower = mid\n            else:\n                upper = mid\n        return lower\n\n    min_max_height = binary_search_min_max_height(0.0, h)\n    return f\"{distribute_sand([min(vs[i], max_amounts[j][i]) for i in range(m)] + [0.0] * (m - n), min_max_height):.3f}\""
    },
    {
        "number": 3109,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def fill_sand(sand_volumes, section_minimums, section_maximums, n, m, left_distances):\n        sand_distribution = [[0 for _ in range(m)] for _ in range(n)]\n        total_sand_volume = sum(sand_volumes)\n\n        for i in range(n):\n            for j in range(m):\n                if i == 0:\n                    sand_distribution[i][j] = min(section_minimums[i][j], total_sand_volume)\n                else:\n                    sand_distribution[i][j] = min(section_minimums[i][j], total_sand_volume - sum(sand_distribution[i - 1]))\n\n            total_sand_volume -= sum(sand_distribution[i])\n\n        for i in range(n):\n            for j in range(m):\n                sand_distribution[i][j] = min(sand_distribution[i][j], section_maximums[i][j])\n\n        sand_levels = [sum(sand_distribution[i]) for i in range(n)]\n        sand_heights = [sand_levels[i] + left_distances[i] for i in range(n)]\n\n        return max(sand_heights) - min(sand_heights)\n\n    def main():\n        n, m, w, h = map(int, stdin.readline().strip().split())\n        sand_volumes = list(map(float, stdin.readline().strip().split()))\n        left_distances = list(map(float, stdin.readline().strip().split()))\n        section_minimums = [list(map(float, stdin.readline().strip().split())) for _ in range(n)]\n        section_maximums = [list(map(float, stdin.readline().strip().split())) for _ in range(n)]\n\n        min_difference = fill_sand(sand_volumes, section_minimums, section_maximums, n, m, left_distances)\n        return round(min_difference, 3)\n\n    return str(main())"
    },
    {
        "number": 3110,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.readline().split())\n    grid = [[int(x) for x in stdin.readline().split()] for _ in range(m)]\n\n    def is_valid(i: int, j: int, value: int) -> bool:\n        if value == 0 or value > 9:\n            return False\n\n        if i == 0 and j == 0:\n            return True\n\n        if i == 0:\n            return grid[i][j - 1] * value == grid[i][j] or grid[i][j - 1] + value == grid[i][j]\n        if j == 0:\n            return grid[i - 1][j] * value == grid[i][j] or grid[i - 1][j] + value == grid[i][j]\n\n        return (\n            (grid[i - 1][j] * value == grid[i][j] or grid[i - 1][j] + value == grid[i][j])\n            and (grid[i][j - 1] * value == grid[i][j] or grid[i][j - 1] + value == grid[i][j])\n            or (grid[i - 1][j] * value == grid[i][j] or grid[i - 1][j] + value == grid[i][j])\n            and (grid[i][j - 1] * value == grid[i][j] or grid[i][j - 1] + value == grid[i][j])\n        )\n\n    def backtrack(i: int, j: int, count: int) -> int:\n        if i == m - 1 and j == n - 1:\n            return count\n\n        if j == n - 1:\n            i += 1\n            j = 0\n\n        if grid[i][j] == 0:\n            for value in range(1, 10):\n                if is_valid(i, j, value):\n                    grid[i][j] = value\n                    count = backtrack(i, j + 1, count)\n                    grid[i][j] = 0\n        else:\n            count = backtrack(i, j + 1, count)\n\n        return count\n\n    return str(backtrack(0, 0, 0))"
    },
    {
        "number": 3110,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(matrix, row, col):\n        if row > 0:\n            for c in range(n):\n                if matrix[row - 1][c] == matrix[row][col] and c != col:\n                    return False\n        if col > 0:\n            for r in range(m):\n                if matrix[r][col - 1] == matrix[row][col] and r != row:\n                    return False\n        return True\n\n    def dfs(matrix, row, col, count):\n        if row == m - 1 and col == n - 1:\n            return count\n        if col == n:\n            row += 1\n            col = 0\n        if row < m and col < n:\n            if matrix[row][col] == 0:\n                for value in range(1, 10):\n                    matrix[row][col] = value\n                    if is_valid(matrix, row, col):\n                        count = dfs(matrix, row, col + 1, count)\n            else:\n                count = dfs(matrix, row, col + 1, count)\n        return count\n\n    m, n = map(int, stdin.readline().split())\n    matrix = []\n    for i in range(m):\n        row = list(map(int, stdin.readline().split()))\n        matrix.append(row)\n\n    count = dfs(matrix, 0, 0, 0)\n    return count"
    },
    {
        "number": 3110,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(matrix, row, col, value):\n        if row > 0:\n            if matrix[row - 1][col] == value:\n                return False\n        if col > 0:\n            if matrix[row][col - 1] == value:\n                return False\n        if row < len(matrix) - 1:\n            if matrix[row + 1][col] == value:\n                return False\n        if col < len(matrix[0]) - 1:\n            if matrix[row][col + 1] == value:\n                return False\n        return True\n\n    def dfs(matrix, row, col, missing):\n        if missing == 0:\n            return 1\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return 1\n\n        total = 0\n        for i in range(1, 10):\n            if is_valid(matrix, row, col, i):\n                matrix[row][col] = i\n                if col + 1 < len(matrix[0]) and matrix[row][col + 1] == 0:\n                    total += dfs(matrix, row, col + 1, missing - 1)\n                elif row + 1 < len(matrix) and matrix[row + 1][col] == 0:\n                    total += dfs(matrix, row + 1, col, missing - 1)\n        matrix[row][col] = 0\n        return total\n\n    m, n = map(int, stdin.readline().split())\n    matrix = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    missing = sum(row.count(0) for row in matrix)\n    return str(dfs(matrix, 0, 0, missing))"
    },
    {
        "number": 3110,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(row, col, num):\n        if row == 0 and col == 0:\n            return True\n        if row == 0:\n            if grid[row][col - 1] == 0 or grid[row][col - 1] * grid[row][col + 1] == num:\n                return True\n        if col == 0:\n            if grid[row - 1][col] == 0 or grid[row - 1][col] + grid[row + 1][col] == num:\n                return True\n        if grid[row][col - 1] * grid[row][col + 1] == num or grid[row - 1][col] + grid[row + 1][col] == num or grid[row - 1][col] - grid[row + 1][col] == num or grid[row - 1][col] - grid[row][col + 1] == num:\n            return True\n        return False\n\n    def dfs(row, col):\n        if row == m - 1 and col == n - 1:\n            nonlocal count\n            count += 1\n            return\n        for i in range(1, 10):\n            if is_valid(row, col, i):\n                grid[row][col] = i\n                if col < n - 1:\n                    dfs(row, col + 1)\n                elif row < m - 1:\n                    dfs(row + 1, 0)\n        grid[row][col] = 0\n\n    m, n = map(int, stdin.split()[0:2])\n    grid = [list(map(int, input().split())) for _ in range(m)]\n    count = 0\n    dfs(0, 0)\n    return str(count)"
    },
    {
        "number": 3110,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.readline().strip().split())\n    grid = []\n    for i in range(m):\n        row = list(map(int, stdin.readline().strip().split()))\n        grid.append(row)\n\n    unknown_count = sum(1 for row in grid for num in row if num == 0)\n    missing_count = (m * n - unknown_count) // 2\n\n    def count_completed_codes(grid, missing_count):\n        if missing_count < 0:\n            return 0\n        if missing_count == 0:\n            return 1\n\n        completed_codes = 0\n        for i, row in enumerate(grid):\n            for j, num in enumerate(row):\n                if num == 0:\n                    for k in range(1, 10):\n                        if k not in row and k not in grid[i - 1] and k != grid[i - 1][j]:\n                            grid[i][j] = k\n                            completed_codes += count_completed_codes(grid, missing_count - 1)\n                    grid[i][j] = 0\n        return completed_codes\n\n    return str(count_completed_codes(grid, missing_count))"
    },
    {
        "number": 3110,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(matrix: List[List[int]], i: int, j: int) -> bool:\n        for k in range(i + 1, len(matrix)):\n            if matrix[k][j] == matrix[i][j]:\n                return False\n        for k in range(j + 1, len(matrix[i])):\n            if matrix[i][k] == matrix[i][j]:\n                return False\n        return True\n\n    def dfs(matrix: List[List[int]], i: int, j: int, remaining_zeros: int) -> int:\n        if remaining_zeros == 0:\n            return 1\n        if i == len(matrix) - 1 and j == len(matrix[i]) - 1:\n            return 0\n        if j == len(matrix[i]) - 1:\n            i += 1\n            j = 0\n        if matrix[i][j] == 0:\n            count = 0\n            for digit in range(1, 10):\n                if is_valid(matrix, i, j):\n                    matrix[i][j] = digit\n                    count += dfs(matrix, i, j + 1, remaining_zeros - 1)\n                    matrix[i][j] = 0\n            return count\n        else:\n            return dfs(matrix, i, j + 1, remaining_zeros)\n\n    m, n = map(int, stdin.readline().split())\n    matrix = [[int(x) for x in stdin.readline().split()] for _ in range(m)]\n    total_zeros = sum(row.count(0) for row in matrix)\n    return str(dfs(matrix, 0, 0, total_zeros))"
    },
    {
        "number": 3110,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(row, col, digit):\n        if row == 0:\n            return True\n        for i in range(n):\n            if i == col:\n                continue\n            if not (is_valid(row - 1, i, digit) or\n                    is_valid(row - 1, col, digit) or\n                    is_valid(row, i, digit) or\n                    is_valid(row, col, digit)):\n                return False\n        return True\n\n    def count_codes(row, col, digits):\n        if row == m:\n            return 1\n        if col == n:\n            return count_codes(row + 1, 0, digits)\n        if digits[row][col] != 0:\n            return count_codes(row, col + 1, digits)\n        count = 0\n        for digit in range(1, 10):\n            if is_valid(row, col, digit):\n                digits[row][col] = digit\n                count += count_codes(row, col + 1, digits)\n                digits[row][col] = 0\n        return count\n\n    m, n = map(int, stdin.readline().split())\n    digits = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    return str(count_codes(0, 0, digits))"
    },
    {
        "number": 3110,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(matrix, i, j, m, n):\n        if i == 0 and j == 0:\n            return True\n        if i == 0:\n            for k in range(i + 1, m):\n                if matrix[k][j] == matrix[i][j]:\n                    return False\n            return True\n        if j == 0:\n            for k in range(j + 1, n):\n                if matrix[i][k] == matrix[i][j]:\n                    return False\n            return True\n        for k in range(i):\n            if matrix[k][j] == matrix[i][j]:\n                return False\n        for k in range(j):\n            if matrix[i][k] == matrix[i][j]:\n                return False\n        return True\n\n    def dfs(matrix, i, j, m, n):\n        if i == m - 1 and j == n - 1:\n            return 1\n        if i == m or j == n:\n            return 0\n\n        count = 0\n        for k in range(1, 10):\n            matrix[i][j] = k\n            if is_valid(matrix, i, j, m, n):\n                if i == m - 1 and j == n - 1:\n                    count += 1\n                else:\n                    count += dfs(matrix, i + 1, j, m, n)\n                    count += dfs(matrix, i, j + 1, m, n)\n        return count\n\n    m, n = map(int, stdin.readline().split())\n    matrix = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    return str(dfs(matrix, 0, 0, m, n))"
    },
    {
        "number": 3110,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(matrix, i, j):\n        for k in range(i - 1, -1, -1):\n            if matrix[k][j] == matrix[i][j]:\n                return False\n        for k in range(j - 1, -1, -1):\n            if matrix[i][k] == matrix[i][j]:\n                return False\n        return True\n\n    def dfs(matrix, i, j, count):\n        if i == m - 1 and j == n - 1:\n            return count\n        for value in range(1, 10):\n            if is_valid(matrix, i, j):\n                matrix[i][j] = value\n                if j < n - 1:\n                    count = dfs(matrix, i, j + 1, count)\n                elif i < m - 1:\n                    count = dfs(matrix, i + 1, 0, count)\n                if count >= 1000000:\n                    return count\n        matrix[i][j] = 0\n        return count\n\n    m, n = map(int, stdin.split())\n    grid = [list(map(int, input().split())) for _ in range(m)]\n    count = 1\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                count *= 9\n\n    return str(dfs(grid, 0, 0, count) % 1000000)"
    },
    {
        "number": 3110,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(code: List[List[int]]) -> bool:\n        for row in code:\n            if len(set(row)) != len(row):\n                return False\n\n        for j in range(len(code[0])):\n            col = [code[i][j] for i in range(len(code))]\n            if len(set(col)) != len(col):\n                return False\n\n        for i in range(1, len(code) - 1):\n            for j in range(1, len(code[0]) - 1):\n                l = code[i][j]\n                u = code[i - 1][j]\n                r = code[i][j + 1]\n\n                if (u != l * r and u != l + r and u != abs(l - r) and (l != 0 or r != 0)) or (l == 0 and r == 0):\n                    return False\n\n        return True\n\n    def backtrack(code: List[List[int]], i: int, j: int, missing: int) -> int:\n        if missing == 0:\n            return int(is_valid(code))\n\n        if i == len(code) and j == 0:\n            return 0\n\n        if j == len(code[0]):\n            i += 1\n            j = 0\n\n        if code[i][j] != 0:\n            return backtrack(code, i, j + 1, missing)\n\n        count = 0\n        for digit in range(1, 10):\n            code[i][j] = digit\n            count += backtrack(code, i, j + 1, missing - 1)\n            code[i][j] = 0\n\n        return count\n\n    m, n = map(int, stdin.readline().split())\n    code = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    missing = sum(row.count(0) for row in code)\n\n    return str(backtrack(code, 0, 0, missing))"
    },
    {
        "number": 3111,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def press_button(dials: List[int], a: int, b: int) -> None:\n        for i in range(a - 1, b):\n            if dials[i] == 9:\n                dials[i] = 0\n            else:\n                dials[i] += 1\n\n    def calculate_sum(dials: List[int], a: int, b: int) -> int:\n        return sum(dials[a - 1:b])\n\n    lines = stdin.splitlines()\n    N, M = map(int, lines[0].split())\n    dials = list(map(int, lines[1]))\n    result = []\n\n    for i in range(2, 2 + M):\n        A, B = map(int, lines[i].split())\n        result.append(calculate_sum(dials, A, B))\n        press_button(dials, A, B)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3111,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split('\\n')[0].split())\n    dials = list(stdin.split('\\n')[1])\n    commands = [list(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def sum_dials(dials: list, A: int, B: int) -> int:\n        return sum(int(dials[i]) for i in range(A - 1, B))\n\n    output = []\n    for A, B in commands:\n        output.append(sum_dials(dials, A, B))\n        for i in range(A - 1, B):\n            dials[i] = str((int(dials[i]) + 1) % 10)\n\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3111,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    dials = stdin.readline()\n    sums = []\n    \n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        current_sum = sum(int(dials[i-1]) for i in range(a, b+1))\n        sums.append(current_sum)\n        \n        dials = dials[:a-1] + '0'*(b-a+1) + dials[b:]\n        dials = dials[:a-1] + '0' + dials[a:]\n    \n    return '\\n'.join(str(s) for s in sums)"
    },
    {
        "number": 3111,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    dials = list(stdin.readline())\n    sums = []\n\n    for i in range(m):\n        a, b = map(int, stdin.readline().split())\n        total = 0\n        for j in range(a - 1, b):\n            total += int(dials[j])\n            dials[j] = str((int(dials[j]) + 1) % 10)\n        sums.append(total)\n\n    return \"\\n\".join(map(str, sums))\n"
    },
    {
        "number": 3111,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_sum(dials: str, A: int, B: int) -> int:\n        return sum(int(dials[i - 1]) for i in range(A, B + 1))\n\n    def press_button(dials: str, A: int, B: int) -> str:\n        dials_list = list(dials)\n        for i in range(A - 1, B):\n            if dials_list[i] == '9':\n                dials_list[i] = '0'\n            else:\n                dials_list[i] = str(int(dials_list[i]) + 1)\n        return ''.join(dials_list)\n\n    N, M = map(int, stdin.split('\\n')[0].split())\n    dials = stdin.split('\\n')[1]\n    sums = []\n\n    for i in range(2, 2 + M):\n        A, B = map(int, stdin.split('\\n')[i].split())\n        sums.append(calculate_sum(dials, A, B))\n        dials = press_button(dials, A, B)\n\n    return '\\n'.join(map(str, sums))"
    },
    {
        "number": 3111,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def sum_of_digits(dials: List[int], A: int, B: int) -> int:\n        return sum(dials[A - 1:B])\n\n    def update_dials(dials: List[int], A: int, B: int) -> None:\n        for i in range(A - 1, B):\n            dials[i] = (dials[i] + 1) % 10\n\n    input_data = stdin.split(\"\\n\")\n    N, M = map(int, input_data[0].split())\n    dials = list(map(int, input_data[1]))\n    output = []\n\n    for i in range(2, 2 + M):\n        A, B = map(int, input_data[i].split())\n        output.append(sum_of_digits(dials, A, B))\n        update_dials(dials, A, B)\n\n    return \"\\n\".join(map(str, output))\n"
    },
    {
        "number": 3111,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def increase_dials(dials: str, A: int, B: int) -> str:\n        dials = list(dials)\n        for i in range(A - 1, B):\n            if dials[i] == '9':\n                dials[i] = '0'\n            else:\n                dials[i] = str(int(dials[i]) + 1)\n        return ''.join(dials)\n\n    lines = stdin.strip().split('\\n')\n    N, M = map(int, lines[0].split())\n    dials = lines[1]\n    results = []\n\n    for i in range(2, 2 + M):\n        A, B = map(int, lines[i].split())\n        results.append(sum(map(int, dials[A - 1:B])))\n        dials = increase_dials(dials, A, B)\n\n    return '\\n'.join(map(str, results)) + '\\n' "
    },
    {
        "number": 3111,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    N, M = map(int, stdin.readline().strip().split())\n    dials = list(stdin.readline().strip())\n    A_B_pairs = [list(map(int, stdin.readline().strip().split())) for _ in range(M)]\n\n    # Calculate the sums\n    sums = []\n    for A, B in A_B_pairs:\n        sum_ = sum(int(dials[i - 1]) for i in range(A, B + 1))\n        sums.append(sum_)\n        for i in range(A, B + 1):\n            if dials[i - 1] == '9':\n                dials[i - 1] = '0'\n            else:\n                dials[i - 1] = str(int(dials[i - 1]) + 1)\n\n    # Return the output\n    return '\\n'.join(map(str, sums))"
    },
    {
        "number": 3111,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def press_button(dials: list, start: int, end: int) -> None:\n        for i in range(start - 1, end):\n            dials[i] += 1\n            if dials[i] == 10:\n                dials[i] = 0\n\n    N, M = map(int, stdin.readline().split())\n    dials = list(map(int, stdin.readline()))\n    sums = []\n\n    for _ in range(M):\n        A, B = map(int, stdin.readline().split())\n        press_button(dials, A, B + 1)\n        sums.append(sum(dials[A - 1:B]))\n\n    return \"\\n\".join(map(str, sums))"
    },
    {
        "number": 3111,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def update_dials(a, b, dials):\n        return dials[:a-1] + '0' * (b-a+1) + dials[b:]\n    \n    def calculate_sum(a, b, dials):\n        return sum(int(dials[i]) for i in range(a-1, b))\n\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    dials = input_list[1]\n    output_list = []\n\n    for i in range(2, 2+M):\n        A, B = map(int, input_list[i].split())\n        dials = update_dials(A, B, dials)\n        output_list.append(calculate_sum(A, B, dials))\n\n    return '\\n'.join(str(x) for x in output_list)"
    },
    {
        "number": 3112,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    params = list(map(int, stdin.split()))\n    N, K, M = params[0], params[1], params[2]\n    conveyor_belts = []\n    for i in range(M):\n        conveyor_belts.append(list(map(int, input().split())))\n\n    # Create directed graph\n    graph = [[] for _ in range(N + 1)]\n    for a, b in conveyor_belts:\n        graph[a].append(b)\n\n    # Check if conveyor belts transport more than one product\n    for node in graph:\n        if len(node) > 1:\n            return \"0\"\n\n    # Find the maximum number of producers\n    max_producers = K\n    for i in range(1, K + 1):\n        visited = [False] * (N + 1)\n        stack = [(1, i)]  # (node, producer)\n        while stack:\n            node, producer = stack.pop()\n            if not visited[node]:\n                visited[node] = True\n                if node == N:\n                    max_producers = min(max_producers, producer)\n                else:\n                    for neighbor in graph[node]:\n                        stack.append((neighbor, producer))\n\n    return str(max_producers)"
    },
    {
        "number": 3112,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    edge_list = []\n    for i in range(M):\n        a, b = map(int, stdin.split()[3 * i + 3:3 * i + 5])\n        edge_list.append((a, b))\n\n    belt_dict = {}\n    for a, b in edge_list:\n        if a not in belt_dict:\n            belt_dict[a] = []\n        belt_dict[a].append(b)\n\n    in_degree = [0] * (N + 1)\n    for a, b_list in belt_dict.items():\n        for b in b_list:\n            in_degree[b] += 1\n\n    queue = []\n    for i in range(1, N + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n\n    count = 0\n    for i in range(1, K + 1):\n        if queue:\n            junction = queue.pop(0)\n            count += 1\n            for b in belt_dict.get(junction, []):\n                in_degree[b] -= 1\n                if in_degree[b] == 0:\n                    queue.append(b)\n\n    return str(count)"
    },
    {
        "number": 3112,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.readline().split())\n    adj = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        adj[a].append(b)\n\n    def dfs(u: int, par: int) -> bool:\n        if u == N:\n            return True\n        for v in adj[u]:\n            if v != par and dfs(v, u):\n                return True\n        return False\n\n    for i in range(1, K + 1):\n        if not dfs(i, -1):\n            return str(i - 1)\n    return str(K)"
    },
    {
        "number": 3112,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def check_route(producer_route, routes):\n        for route in routes:\n            if producer_route[-1] == route[0]:\n                return False\n        return True\n\n    def get_route(start, end, belts):\n        route = [start]\n        while route[-1] != end:\n            for belt in belts:\n                if belt[0] == route[-1]:\n                    route.append(belt[1])\n                    break\n        return route\n\n    def can_producer_run(producer, producers_running, routes):\n        if producers_running[producer - 1] == 1:\n            return True\n        producer_route = get_route(producer, N, edges)\n        for other_producer in range(1, K + 1):\n            if other_producer != producer and producers_running[other_producer - 1] == 1:\n                other_producer_route = get_route(other_producer, N, edges)\n                if producer_route == other_producer_route:\n                    return False\n        return True\n\n    N, K, M = map(int, stdin.readline().strip().split())\n    edges = [tuple(map(int, stdin.readline().strip().split())) for _ in range(M)]\n    producers_running = [1] * K\n    max_producers = K\n\n    for producer in range(1, K + 1):\n        producer_route = get_route(producer, N, edges)\n        if not check_route(producer_route, edges):\n            producers_running[producer - 1] = 0\n            max_producers -= 1\n\n    for producer in range(1, K + 1):\n        if producers_running[producer - 1] == 1:\n            if not can_producer_run(producer, producers_running, edges):\n                producers_running[producer - 1] = 0\n                max_producers -= 1\n\n    return str(max_producers)"
    },
    {
        "number": 3112,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, K, M = map(int, stdin.readline().split())\n    edges = []\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        edges.append((a, b))\n    \n    # Initialize data structures\n    adj_list = [[] for _ in range(N + 1)]\n    for a, b in edges:\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n    \n    # Initialize visited and path_used arrays\n    visited = [False] * (N + 1)\n    path_used = [False] * (N + 1)\n    \n    # Recursive DFS function\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if not path_used[neighbor]:\n                    path_used[neighbor] = True\n                    dfs(neighbor)\n                    path_used[neighbor] = False\n        visited[node] = False\n    \n    # Iterate through all producers and count the number of producers that can be left running\n    max_producers = 0\n    for producer in range(1, K + 1):\n        path_used[producer] = True\n        dfs(producer)\n        max_producers += 1\n        path_used[producer] = False\n    \n    return str(max_producers)"
    },
    {
        "number": 3112,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n\n    producers = [i for i in range(1, K + 1)]\n    robots = [[] for _ in range(N + 1)]\n\n    for i in producers:\n        for j in range(1, N + 1):\n            if (i, j) not in edges:\n                robots[i].append(j)\n\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if (i, j) not in edges:\n                robots[i].append(j)\n\n    def check_conveyor_belts(left_producers: set) -> bool:\n        conveyor_belts = [[] for _ in range(N + 1)]\n        for i in left_producers:\n            for j in robots[i]:\n                conveyor_belts[i].append(j)\n        for i in range(1, N + 1):\n            for j in robots[i]:\n                conveyor_belts[i].append(j)\n\n        for belt in conveyor_belts:\n            if len(belt) > 1:\n                return False\n        return True\n\n    left_producers = set(producers)\n    while True:\n        if check_conveyor_belts(left_producers):\n            return str(len(left_producers))\n        left_producers -= {min(left_producers)}"
    },
    {
        "number": 3112,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[0:3])\n    conveyor_belts = []\n    for _ in range(M):\n        a, b = map(int, stdin.split()[_ * 2 + 2: _ * 2 + 4])\n        conveyor_belts.append((a, b))\n\n    robot_programs = [[] for _ in range(N)]\n    for i in range(K):\n        robot_programs[i].append((i + 1) * K + i + 1)\n        for j in range(N - 1):\n            if (i + 1, j + 2) in conveyor_belts:\n                robot_programs[i].append(j + 2)\n            else:\n                robot_programs[i].append(i + 1)\n\n    for i in range(K, N):\n        robot_programs[i].append(i + 1)\n\n    def deliver(start, end, time, conveyor_belts, robot_programs):\n        if start == end:\n            return True\n        for i, (a, b) in enumerate(conveyor_belts):\n            if a == start and b == end and time % 2 == 0:\n                if deliver(b, robot_programs[b - 1][i], time + 1, conveyor_belts, robot_programs):\n                    return True\n            elif b == start and a == end and time % 2 == 1:\n                if deliver(a, robot_programs[a - 1][i], time + 1, conveyor_belts, robot_programs):\n                    return True\n        return False\n\n    count = K\n    for i in range(K):\n        if not deliver(i + 1, N, 0, conveyor_belts, robot_programs):\n            count -= 1\n            break\n\n    return str(count)"
    },
    {
        "number": 3112,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    adj_list = [[] for _ in range(N + 1)]\n    in_degree = [0] * (N + 1)\n\n    for _ in range(M):\n        u, v = map(int, input().split())\n        adj_list[u].append(v)\n        in_degree[v] += 1\n\n    queue = []\n    for i in range(1, N + 1):\n        if in_degree[i] == 0:\n            queue.append(i)\n\n    while queue:\n        u = queue.pop(0)\n        for v in adj_list[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n\n    return \"1\" if sum(in_degree) == 0 else \"0\""
    },
    {
        "number": 3112,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    producers = [[] for _ in range(K)]\n    adj_list = [[] for _ in range(N + 1)]\n\n    for i in range(M):\n        a, b = map(int, stdin.split()[3 + 2 * i:5 + 2 * i])\n        adj_list[a].append(b)\n\n    for i in range(1, K + 1):\n        producers[i - 1].append(i)\n        producers[i - 1].append(i * K + i)\n\n    visited = [False] * (N + 1)\n    stack = []\n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node)\n        stack.append(node)\n\n    for i in range(1, N + 1):\n        if not visited[i]:\n            dfs(i, None)\n\n    while stack:\n        node = stack.pop()\n        for neighbor in adj_list[node]:\n            if node in producers[neighbor - 1]:\n                producers[neighbor - 1].remove(node)\n            if not producers[neighbor - 1]:\n                return str(node - 1)\n\n    return str(K)"
    },
    {
        "number": 3112,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(producers: int) -> bool:\n        time = [0] * (N + 1)\n        for i in range(1, K + 1):\n            time[i] = (x * K + i) % M\n        for i in range(K + 1, N + 1):\n            time[i] = 1\n\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                if (i, j) in edges:\n                    for k in range(1, producers + 1):\n                        if time[i] == time[j]:\n                            return False\n                        time[i] += 1\n        return True\n\n    def binary_search(left: int, right: int) -> int:\n        while left <= right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left - 1\n\n    data = stdin.split('\\n')\n    N, K, M = map(int, data[0].split())\n    edges = set()\n    for i in range(1, M + 1):\n        a, b = map(int, data[i].split())\n        edges.add((a, b))\n\n    return str(binary_search(0, K))"
    },
    {
        "number": 3113,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_degenerate(a, b, c):\n        return (a[0] == b[0] and a[1] == b[1] and c[0] == a[0] and c[1] == a[1]) or \\\n               (a[0] == b[0] and a[1] == b[1] and c[0] == b[0] and c[1] == b[1]) or \\\n               (b[0] == c[0] and b[1] == c[1] and a[0] == b[0] and a[1] == b[1])\n\n    def is_intersecting(a, b, c, d):\n        def cross_product(a, b):\n            return a[0] * b[1] - a[1] * b[0]\n\n        def area(a, b, c):\n            return abs(cross_product(b, c) - cross_product(a, c) + cross_product(a, b)) / 2\n\n        a1, b1, c1 = a, b, c\n        a2, b2, c2 = d\n\n        if is_degenerate(a1, b1, c1) or is_degenerate(a2, b2, c2):\n            return False\n\n        s1 = cross_product(b1 - a1, c1 - a1)\n        s2 = cross_product(b2 - a2, c2 - a2)\n        s3 = cross_product(b2 - a1, c1 - a1)\n        s4 = cross_product(b1 - a2, c2 - a2)\n\n        if s1 * s2 <= 0 and s3 * s4 <= 0:\n            a1_area = area(a1, b1, c1)\n            a2_area = area(a2, b2, c2)\n            intersect_area = abs(cross_product(a1, b2) - cross_product(a1, a2) + cross_product(a2, b1) - cross_product(a2, c1) + cross_product(c1, a1) - cross_product(c1, b2)) / 2\n            return a1_area + a2_area <= intersect_area\n        else:\n            return False\n\n    def is_same_cloud(triangles1, triangles2):\n        for triangle1 in triangles1:\n            intersect_flag = False\n            for triangle2 in triangles2:\n                if is_intersecting(triangle1, triangle2):\n                    intersect_flag = True\n                    break\n            if not intersect_flag:\n                return False\n        return True\n\n    def read_triangles(n):\n        triangles = []\n        for _ in range(n):\n            x1, y1, x2, y2, x3, y3 = map(int, input().split())\n            triangles.append([(x1, y1), (x2, y2), (x3, y3)])\n        return triangles\n\n    n = int(input())\n    triangles1 = read_triangles(n)\n    m = int(input())\n    triangles2 = read_triangles(m)\n\n    if is_same_cloud(triangles1, triangles2):\n        print(\"yes\")\n    else:\n        print(\"no\")"
    },
    {
        "number": 3113,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def check_intersection(tri1, tri2):\n        def area(p1, p2, p3):\n            return abs((p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) / 2)\n\n        def is_inside(point, triangle):\n            A = area(triangle[0], triangle[1], triangle[2])\n            A1 = area(point, triangle[0], triangle[1])\n            A2 = area(point, triangle[1], triangle[2])\n            A3 = area(point, triangle[2], triangle[0])\n            return A == A1 + A2 + A3\n\n        for vertex in tri1:\n            if is_inside(vertex, tri2):\n                return True\n        for vertex in tri2:\n            if is_inside(vertex, tri1):\n                return True\n        return False\n\n    def is_degenerate(triangle):\n        return area(triangle[0], triangle[1], triangle[2]) == 0\n\n    n, m = map(int, stdin.readline().split())\n    garry = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    jerry = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    garry_triangles = [tri for tri in garry if not is_degenerate(tri)]\n    jerry_triangles = [tri for tri in jerry if not is_degenerate(tri)]\n\n    if len(garry_triangles) != len(jerry_triangles):\n        return \"no\"\n\n    for tri1 in garry_triangles:\n        if any(check_intersection(tri1, tri2) for tri2 in jerry_triangles):\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3113,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_degenerate(triangle: list) -> bool:\n        a, b, c = sorted([triangle[0], triangle[2], triangle[4]])\n        return a + b <= c\n\n    def area(triangle: list) -> float:\n        x1, y1, x2, y2, x3, y3 = triangle\n        return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)\n\n    def is_intersecting(triangle1: list, triangle2: list) -> bool:\n        area1, area2 = area(triangle1), area(triangle2)\n        total_area = area1 + area2\n\n        for i in range(0, 6, 2):\n            total_area -= abs(\n                (triangle1[i] - triangle2[i])\n                * (triangle1[i + 3] - triangle2[i + 1])\n                - (triangle1[i + 1] - triangle2[i + 2])\n                * (triangle1[i] - triangle2[i + 3])\n            ) / 2.0\n\n        return abs(total_area) > 1e-9\n\n    def are_same_clouds(triangles1: list, triangles2: list) -> bool:\n        n, m = len(triangles1), len(triangles2)\n\n        for i in range(n):\n            for j in range(m):\n                if not is_degenerate(triangles1[i]) and not is_degenerate(triangles2[j]):\n                    if not is_intersecting(triangles1[i], triangles2[j]):\n                        return True\n        return False\n\n    input_data = list(map(str.split, stdin.split('\\n')))[:-1]\n    n, garrys_triangles, m, jerrys_triangles = int(input_data[0][0]), input_data[1:1 + n], int(input_data[1 + n][0]), input_data[2 + n:]\n\n    garrys_triangles = [list(map(int, t)) for t in garrys_triangles]\n    jerrys_triangles = [list(map(int, t)) for t in jerrys_triangles]\n\n    return 'yes' if are_same_clouds(garrys_triangles, jerrys_triangles) else 'no' "
    },
    {
        "number": 3113,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_degenerate(triangle):\n        return triangle[0] == triangle[1] == triangle[2] == triangle[3] == triangle[4] == triangle[5]\n\n    def is_valid(triangles):\n        for i in range(len(triangles)):\n            for j in range(i + 1, len(triangles)):\n                if not is_degenerate(triangles[i]) and not is_degenerate(triangles[j]):\n                    if (triangles[i][0] == triangles[j][0] and triangles[i][1] == triangles[j][1] and triangles[i][2] == triangles[j][2]) or \\\n                       (triangles[i][0] == triangles[j][0] and triangles[i][1] == triangles[j][2] and triangles[i][2] == triangles[j][1]) or \\\n                       (triangles[i][0] == triangles[j][1] and triangles[i][1] == triangles[j][0] and triangles[i][2] == triangles[j][2]) or \\\n                       (triangles[i][0] == triangles[j][2] and triangles[i][1] == triangles[j][1] and triangles[i][2] == triangles[j][0]):\n                        return False\n        return True\n\n    def area(triangle):\n        return abs((triangle[0] * (triangle[3] - triangle[5]) + triangle[2] * (triangle[5] - triangle[1]) + triangle[4] * (triangle[1] - triangle[3])) / 2)\n\n    def are_equal(triangles1, triangles2):\n        if len(triangles1) != len(triangles2):\n            return False\n\n        for i in range(len(triangles1)):\n            for j in range(len(triangles2)):\n                if area(triangles1[i]) == area(triangles2[j]) and not is_degenerate(triangles1[i]) and not is_degenerate(triangles2[j]):\n                    if (triangles1[i][0] == triangles2[j][0] and triangles1[i][1] == triangles2[j][1] and triangles1[i][2] == triangles2[j][2]) or \\\n                       (triangles1[i][0] == triangles2[j][0] and triangles1[i][1] == triangles2[j][2] and triangles1[i][2] == triangles2[j][1]) or \\\n                       (triangles1[i][0] == triangles2[j][1] and triangles1[i][1] == triangles2[j][0] and triangles1[i][2] == triangles2[j][2]) or \\\n                       (triangles1[i][0] == triangles2[j][2] and triangles1[i][1] == triangles2[j][1] and triangles1[i][2] == triangles2[j][0]):\n                        break\n            else:\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    garrys_triangles = [list(map(int, lines[i + 1].split())) for i in range(n)]\n\n    m = int(lines[n + 1])\n    jerrys_triangles = [list(map(int, lines[n + i + 2].split())) for i in range(m)]\n\n    if not is_valid(garrys_triangles) or not is_valid(jerrys_triangles):\n        return \"no\"\n\n    return \"yes\" if are_equal(garrys_triangles, jerrys_triangles) else \"no\""
    },
    {
        "number": 3113,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def area_triangle(x1, y1, x2, y2, x3, y3):\n        return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n\n    def is_valid_triangle(x1, y1, x2, y2, x3, y3):\n        return area_triangle(x1, y1, x2, y2, x3, y3) != 0\n\n    def is_intersecting_triangle(triangle1, triangle2):\n        x1, y1, x2, y2, x3, y3 = triangle1\n        x4, y4, x5, y5, x6, y6 = triangle2\n        area1 = area_triangle(x1, y1, x2, y2, x3, y3)\n        area2 = area_triangle(x4, y4, x5, y5, x6, y6)\n        area_intersection = abs(area1 + area2 - area_triangle(x1, y1, x2, y2, x5, y5) - area_triangle(x1, y1, x5, y5, x6, y6) - area_triangle(x4, y4, x5, y5, x2, y2) - area_triangle(x4, y4, x2, y2, x6, y6) - area_triangle(x4, y4, x6, y6, x3, y3) - area_triangle(x4, y4, x3, y3, x5, y5))\n        return area_intersection != 0\n\n    def is_same_cloud(garry_triangles, jerry_triangles):\n        garry_triangles = set(tuple(triangle) for triangle in garry_triangles)\n        jerry_triangles = set(tuple(triangle) for triangle in jerry_triangles)\n\n        if len(garry_triangles) != len(jerry_triangles):\n            return False\n\n        for triangle1 in garry_triangles:\n            if not any(is_intersecting_triangle(triangle1, triangle2) for triangle2 in jerry_triangles):\n                return False\n\n        return True\n\n    n = int(stdin.readline())\n    garry_triangles = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    garry_triangles = [triangle for triangle in garry_triangles if is_valid_triangle(*triangle)]\n\n    m = int(stdin.readline())\n    jerry_triangles = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    jerry_triangles = [triangle for triangle in jerry_triangles if is_valid_triangle(*triangle)]\n\n    if is_same_cloud(garry_triangles, jerry_triangles):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3113,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, garry, m, jerry = 0, [], 0, []\n    for line in stdin.split('\\n'):\n        if not n:\n            n = int(line)\n            continue\n        if n and len(garry) < n:\n            garry.append(list(map(int, line.split())))\n            continue\n        if not m:\n            m = int(line)\n            continue\n        if m and len(jerry) < m:\n            jerry.append(list(map(int, line.split())))\n            continue\n    break\n\n    def area(triangle):\n        x1, y1, x2, y2, x3, y3 = triangle\n        return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n\n    def is_intersecting(t1, t2):\n        if area([*t1[0:2], *t2[2:4], *t2[0:2]]) + area([*t1[2:4], *t2[0:2], *t1[0:2]]) == area(t1) + area(t2):\n            return True\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if is_intersecting(garry[i], jerry[j]):\n                return 'no'\n    return 'yes'"
    },
    {
        "number": 3113,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_degenerate(triangle: list) -> bool:\n        x1, y1, x2, y2, x3, y3 = triangle\n        return (x1 == x2 and y1 == y2) or (x2 == x3 and y2 == y3) or (x1 == x3 and y1 == y3)\n\n    def is_intersecting(triangle1: list, triangle2: list) -> bool:\n        x1, y1, x2, y2, x3, y3 = triangle1\n        p1, p2, p3 = (x1, y1), (x2, y2), (x3, y3)\n        x1, y1, x2, y2, x3, y3 = triangle2\n        q1, q2, q3 = (x1, y1), (x2, y2), (x3, y3)\n\n        def is_collision(p1, p2, q1, q2):\n            return (p1[0] - p2[0]) * (p1[1] - q2[1]) != (p1[0] - q2[0]) * (p1[1] - p2[1])\n\n        if is_collision(p1, p2, q1, q2) and is_collision(p2, p3, q1, q2) and is_collision(p3, p1, q1, q2):\n            return True\n        if is_collision(p1, p2, q2, q3) and is_collision(p2, p3, q2, q3) and is_collision(p3, p1, q2, q3):\n            return True\n        if is_collision(p1, p2, q3, q1) and is_collision(p2, p3, q3, q1) and is_collision(p3, p1, q3, q1):\n            return True\n        return False\n\n    def normalize_triangle(triangle: list) -> tuple:\n        x1, y1, x2, y2, x3, y3 = triangle\n        return tuple(sorted([(x1, y1), (x2, y2), (x3, y3)]))\n\n    def process_triangles(triangles: list) -> set:\n        normalized_triangles = set()\n        for triangle in triangles:\n            if not is_degenerate(triangle):\n                normalized_triangle = normalize_triangle(triangle)\n                if normalized_triangle not in normalized_triangles:\n                    normalized_triangles.add(normalized_triangle)\n        return normalized_triangles\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    garry_triangles = [list(map(int, line.split())) for line in lines[1:n + 1]]\n    m = int(lines[n + 1])\n    jerry_triangles = [list(map(int, line.split())) for line in lines[n + 2:n + m + 2]]\n\n    garry_triangles = process_triangles(garry_triangles)\n    jerry_triangles = process_triangles(jerry_triangles)\n\n    for triangle1 in garry_triangles:\n        for triangle2 in jerry_triangles:\n            if is_intersecting(triangle1, triangle2):\n                return \"no\"\n    return \"yes\""
    },
    {
        "number": 3113,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def area(x1, y1, x2, y2, x3, y3):\n        return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n\n    def intersect(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6):\n        A1 = area(x1, y1, x2, y2, x3, y3)\n        A2 = area(x4, y4, x5, y5, x6, y6)\n        A3 = area(x1, y1, x2, y2, x4, y4)\n        A4 = area(x1, y1, x2, y2, x5, y5)\n        A5 = area(x1, y1, x2, y2, x6, y6)\n        A6 = area(x2, y2, x3, y3, x4, y4)\n        A7 = area(x2, y2, x3, y3, x5, y5)\n        A8 = area(x2, y2, x3, y3, x6, y6)\n        A9 = area(x3, y3, x1, y1, x4, y4)\n        A10 = area(x3, y3, x1, y1, x5, y5)\n        A11 = area(x3, y3, x1, y1, x6, y6)\n        A12 = area(x4, y4, x5, y5, x6, y6)\n        A13 = area(x4, y4, x5, y5, x1, y1)\n        A14 = area(x4, y4, x5, y5, x2, y2)\n        A15 = area(x4, y4, x5, y5, x3, y3)\n        A16 = area(x5, y5, x6, y6, x1, y1)\n        A17 = area(x5, y5, x6, y6, x2, y2)\n        A18 = area(x5, y5, x6, y6, x3, y3)\n        A19 = area(x6, y6, x1, y1, x2, y2)\n        A20 = area(x6, y6, x1, y1, x3, y3)\n        A21 = area(x6, y6, x2, y2, x3, y3)\n        if any(A in [0, A1, A2] for A in [A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21]):\n            return True\n        return False\n\n    def compare_clouds(Garrys_clouds, Jerrys_clouds):\n        if len(Garrys_clouds) != len(Jerrys_clouds):\n            return False\n        for Garrys_cloud in Garrys_clouds:\n            found = False\n            for Jerrys_cloud in Jerrys_clouds:\n                if not intersect(*Garrys_cloud, *Jerrys_cloud):\n                    found = True\n                    break\n            if not found:\n                return False\n        return True\n\n    lines = stdin.split(\"\\n\")\n    Garrys_clouds = [tuple(map(int, lines[i].split())) for i in range(1, 1 + int(lines[0]))]\n    Jerrys_clouds = [tuple(map(int, lines[i].split())) for i in range(2 + int(lines[0]), 2 + int(lines[0]) + int(lines[1]))]\n\n    if compare_clouds(Garrys_clouds, Jerrys_clouds):\n        return \"yes\"\n    return \"no\""
    },
    {
        "number": 3113,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(triangle):\n        x1, y1, x2, y2, x3, y3 = triangle\n        area = abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n        if area == 0:\n            return False\n        for i in range(3):\n            j = (i + 1) % 3\n            k = (i + 2) % 3\n            if (x1 - x2) * (y3 - y2) == (y1 - y2) * (x2 - x3):\n                return False\n        return True\n\n    def intersect(triangle1, triangle2):\n        pass\n\n    input_data = stdin.split(\"\\n\")\n    garry_triangles = [list(map(int, input_data[i + 1].split())) for i in range(int(input_data[0]))]\n    jerry_triangles = [list(map(int, input_data[int(input_data[0]) + i + 1].split())) for i in range(int(input_data[int(input_data[0])]))]\n\n    garry_triangles = [triangle for triangle in garry_triangles if is_valid(triangle)]\n    jerry_triangles = [triangle for triangle in jerry_triangles if is_valid(triangle)]\n\n    for i in range(len(garry_triangles)):\n        for j in range(i + 1, len(garry_triangles)):\n            if not intersect(garry_triangles[i], garry_triangles[j]):\n                return \"no\"\n\n    for i in range(len(jerry_triangles)):\n        for j in range(i + 1, len(jerry_triangles)):\n            if not intersect(jerry_triangles[i], jerry_triangles[j]):\n                return \"no\"\n\n    for garry_triangle in garry_triangles:\n        for jerry_triangle in jerry_triangles:\n            if not intersect(garry_triangle, jerry_triangle):\n                return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3113,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def area_triangle(x1, y1, x2, y2, x3, y3):\n        return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n\n    def is_point_in_triangle(x1, y1, x2, y2, x3, y3, x, y):\n        A = area_triangle(x1, y1, x2, y2, x3, y3)\n        A1 = area_triangle(x, y, x2, y2, x3, y3)\n        A2 = area_triangle(x1, y1, x, y, x3, y3)\n        A3 = area_triangle(x1, y1, x2, y2, x, y)\n        return A == A1 + A2 + A3\n\n    def is_triangle_intersecting(triangle1, triangle2):\n        x1, y1, x2, y2, x3, y3 = triangle1\n        for point in [(x1, y1), (x2, y2), (x3, y3)]:\n            if is_point_in_triangle(triangle2[0], triangle2[1], triangle2[2], triangle2[3], triangle2[4], triangle2[5], *point):\n                return True\n        return False\n\n    def is_set_of_triangles_intersecting(triangles1, triangles2):\n        for triangle1 in triangles1:\n            for triangle2 in triangles2:\n                if is_triangle_intersecting(triangle1, triangle2):\n                    return True\n        return False\n\n    def is_set_of_triangles_valid(triangles):\n        for i in range(len(triangles)):\n            for j in range(i + 1, len(triangles)):\n                if is_triangle_intersecting(triangles[i], triangles[j]):\n                    return False\n        return True\n\n    def get_triangles_from_input(stdin):\n        n = int(stdin.readline())\n        triangles = []\n        for _ in range(n):\n            x1, y1, x2, y2, x3, y3 = map(int, stdin.readline().split())\n            triangles.append((x1, y1, x2, y2, x3, y3))\n        return triangles\n\n    garry_triangles = get_triangles_from_input(stdin)\n    jerry_triangles = get_triangles_from_input(stdin)\n\n    if not (is_set_of_triangles_valid(garry_triangles) and is_set_of_triangles_valid(jerry_triangles)):\n        return \"no\"\n\n    if is_set_of_triangles_intersecting(garry_triangles, jerry_triangles):\n        return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3114,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(node, visited, parent, graph):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if find_cycle(neighbor, visited, node, graph):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n\n    def is_possible(N, M, roads):\n        graph = [[] for _ in range(N + 1)]\n        for road in roads:\n            x, y = road\n            graph[x].append(y)\n            graph[y].append(x)\n\n        visited = [False] * (N + 1)\n        for node in range(1, N + 1):\n            if not visited[node] and find_cycle(node, visited, -1, graph):\n                return False\n        return True\n\n    def direction_assignment(N, M, roads):\n        assignment = []\n        graph = [[] for _ in range(N + 1)]\n        for road in roads:\n            x, y = road\n            graph[x].append(y)\n\n        for node in range(1, N + 1):\n            for neighbor in graph[node]:\n                assignment.append((node, neighbor))\n\n        return assignment\n\n    def process_case(N, M, roads):\n        if is_possible(N, M, roads):\n            return \"YES\\n\" + \"\\n\".join(\" \".join(map(str, road)) for road in direction_assignment(N, M, roads))\n        else:\n            return \"NO\"\n\n    cases = stdin.split(\"\\n\")\n    output = []\n    case_count = int(cases[0])\n    for i in range(1, case_count + 1):\n        N, M = map(int, cases[2 * i - 1].split())\n        roads = [tuple(map(int, cases[2 * i + j - 1].split())) for j in range(M)]\n        output.append(process_case(N, M, roads))\n\n    return \"\\n\\n\".join(output) + \"\\n\" "
    },
    {
        "number": 3114,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(n, m, roads):\n        graph = [[] for _ in range(n)]\n        for x, y in roads:\n            graph[x - 1].append(y - 1)\n            graph[y - 1].append(x - 1)\n\n        visited = [False] * n\n        stack = [(0, -1)]\n\n        while stack:\n            node, parent = stack.pop()\n            if visited[node]:\n                continue\n            visited[node] = True\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    stack.append((neighbor, node))\n\n        return all(visited)\n\n    def find_cycle(n, m, roads):\n        graph = [[] for _ in range(n)]\n        for x, y in roads:\n            graph[x - 1].append(y - 1)\n            graph[y - 1].append(x - 1)\n\n        visited = [False] * n\n        stack = [(0, -1)]\n        while stack:\n            node, parent = stack.pop()\n            if visited[node]:\n                continue\n            visited[node] = True\n            for neighbor in graph[node]:\n                if neighbor != parent:\n                    stack.append((neighbor, node))\n                    if neighbor in graph[parent]:\n                        cycle = []\n                        while node != parent:\n                            cycle.append(node + 1)\n                            node = parent\n                            parent = stack.pop()[1]\n                        cycle.append(node + 1)\n                        return cycle[::-1]\n\n        return None\n\n    lines = stdin.strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    roads = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    if is_possible(n, m, roads):\n        cycle = find_cycle(n, m, roads)\n        if cycle is None:\n            return 'YES\\n' + '\\n'.join(' '.join(map(str, road)) for road in roads)\n        else:\n            return 'NO'\n    else:\n        return 'NO'"
    },
    {
        "number": 3114,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(n, visited, graph, ans):\n        for v in graph[n]:\n            if not visited[v]:\n                visited[v] = True\n                ans.append((n, v))\n                dfs(v, visited, graph, ans)\n\n    def is_possible(n, m, roads):\n        graph = [[] for _ in range(n + 1)]\n        for x, y in roads:\n            graph[x].append(y)\n            graph[y].append(x)\n\n        visited = [False] * (n + 1)\n        ans = []\n\n        for i in range(1, n + 1):\n            if not visited[i]:\n                visited[i] = True\n                dfs(i, visited, graph, ans)\n\n        return ans\n\n    def main():\n        n, m = map(int, stdin.readline().strip().split())\n        roads = [tuple(map(int, stdin.readline().strip().split())) for _ in range(m)]\n\n        if len(roads) != n * (n - 1) // 2:\n            print(\"NO\")\n            return\n\n        ans = is_possible(n, m, roads)\n        if not ans:\n            print(\"NO\")\n            return\n\n        print(\"YES\")\n        for x, y in ans:\n            print(x, y)\n\n    main()\n"
    },
    {
        "number": 3114,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, current, parent):\n        for neighbor in graph[current]:\n            if neighbor != parent and not visited[neighbor]:\n                visited[neighbor] = True\n                if not dfs(graph, visited, neighbor, current):\n                    return False\n        return True\n\n    def is_possible(graph):\n        visited = [False] * (len(graph) + 1)\n        for vertex in graph:\n            if not visited[vertex]:\n                visited[vertex] = True\n                if not dfs(graph, visited, vertex, -1):\n                    return False\n        return True\n\n    def assign_directions(graph):\n        result = []\n        for vertex in graph:\n            for neighbor in graph[vertex]:\n                result.append((vertex, neighbor))\n                graph[neighbor].remove(vertex)\n                break\n        return result\n\n    cases = int(stdin.readline())\n    output = []\n\n    for _ in range(cases):\n        N, M = map(int, stdin.readline().split())\n        graph = {i: set() for i in range(1, N + 1)}\n\n        for _ in range(M):\n            X, Y = map(int, stdin.readline().split())\n            graph[X].add(Y)\n\n        if is_possible(graph):\n            output.append(\"YES\")\n            directions = assign_directions(graph)\n            for direction in directions:\n                output.append(f\"{direction[0]} {direction[1]}\")\n        else:\n            output.append(\"NO\")\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3114,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, node, visited, rec_stack):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if find_cycle(graph, neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    def is_possible(graph, nodes):\n        for node in range(1, nodes + 1):\n            if not graph[node]:\n                return True\n\n        for node in range(1, nodes + 1):\n            if not graph[node]:\n                continue\n\n            visited = [False] * (nodes + 1)\n            rec_stack = [False] * (nodes + 1)\n\n            if find_cycle(graph, node, visited, rec_stack):\n                return True\n\n        return False\n\n    def dfs(graph, node, visited, direction, result):\n        visited[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                direction[neighbor] = node\n                dfs(graph, neighbor, visited, direction, result)\n\n        result.append((node, direction[node]))\n\n    cases = stdin.strip().split('\\n')\n    for case_no, data in enumerate(cases, start=1):\n        N, M = map(int, data.split())\n        graph = {i: [] for i in range(1, N + 1)}\n        for i in range(M):\n            x, y = map(int, input().split())\n            graph[x].append(y)\n            graph[y].append(x)\n\n        if is_possible(graph, N):\n            print(\"YES\")\n            visited = [False] * (N + 1)\n            direction = [0] * (N + 1)\n            result = []\n\n            for node in range(1, N + 1):\n                if not visited[node]:\n                    dfs(graph, node, visited, direction, result)\n\n            for node, neighbor in result:\n                print(node, neighbor)\n        else:\n            print(\"NO\")"
    },
    {
        "number": 3114,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited, stack):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(graph, neighbor, visited, stack)\n        stack.append(start)\n\n    def topological_sort(graph, indegree):\n        stack = []\n        for i in range(1, len(indegree)):\n            if indegree[i] == 0:\n                dfs(graph, i, [False] * len(indegree), stack)\n        return stack\n\n    input_data = [list(map(int, line.split())) for line in stdin.split('\\n')[:-1]]\n    n, m = input_data[0]\n    roads = input_data[1:]\n    graph = [[] for _ in range(n + 1)]\n    indegree = [0] * (n + 1)\n    for x, y in roads:\n        graph[x].append(y)\n        indegree[y] += 1\n\n    sorted_cities = topological_sort(graph, indegree)\n\n    if len(sorted_cities) == n:\n        return 'YES\\n' + '\\n'.join(f'{x} {y}' for x, y in roads)\n    else:\n        return 'NO'"
    },
    {
        "number": 3114,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(parent, visited, start, end):\n        if visited[start] and visited[start] != end:\n            return False\n        if visited[start] == end:\n            return True\n        visited[start] = end\n        for i in range(1, N + 1):\n            if parent[start][i]:\n                if i == end:\n                    continue\n                if find_cycle(parent, visited, i, end):\n                    return True\n        return False\n\n    for case in range(1, int(stdin.split('\\n')[0]) + 1):\n        N, M = map(int, stdin.split('\\n')[case].split())\n        parent = [[0] * (N + 1) for _ in range(N + 1)]\n        for i in range(M):\n            X, Y = map(int, stdin.split('\\n')[case + i + 1].split())\n            parent[X][Y] = 1\n            parent[Y][X] = 1\n\n        visited = [0] * (N + 1)\n        has_cycle = False\n        for start in range(1, N + 1):\n            for end in range(1, N + 1):\n                if start != end and find_cycle(parent, visited, start, end):\n                    has_cycle = True\n                    break\n            if has_cycle:\n                break\n\n        if has_cycle:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            for i in range(1, N + 1):\n                for j in range(1, N + 1):\n                    if parent[i][j]:\n                        print(i, j)\n            print()\n"
    },
    {
        "number": 3114,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited):\n        stack = [start]\n        while stack:\n            node = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                stack.extend(neighbor for neighbor in graph[node] if neighbor not in visited)\n\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    roads = [list(map(int, line.split())) for line in input_list[1:M + 1]]\n    graph = {i: set() for i in range(1, N + 1)}\n    for road in roads:\n        graph[road[0]].add(road[1])\n    visited = set()\n    dfs(graph, 1, visited)\n    if len(visited) == N:\n        result = ['YES']\n        for road in roads:\n            if road[1] not in graph[road[0]]:\n                result.append(f'{road[0]} {road[1]}')\n        return '\\n'.join(result)\n    else:\n        return 'NO'"
    },
    {
        "number": 3114,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, node, visited, rec_stack):\n        visited[node] = True\n        rec_stack[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if find_cycle(graph, neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n        rec_stack[node] = False\n        return False\n\n    def is_possible(roads):\n        graph = [[] for _ in range(N)]\n        for road in roads:\n            graph[road[0]].append(road[1])\n        visited = [False] * N\n        rec_stack = [False] * N\n        for node in range(N):\n            if not visited[node]:\n                if find_cycle(graph, node, visited, rec_stack):\n                    return False\n        return True\n\n    input_data = [line.strip() for line in stdin.split('\\n')]\n    N, M = map(int, input_data[0].split())\n    roads = [list(map(int, line.split())) for line in input_data[1:]]\n\n    if is_possible(roads):\n        output = ['YES']\n        for road in roads:\n            output.append(f'{road[0]} {road[1]}')\n        return '\\n'.join(output)\n    else:\n        return 'NO' "
    },
    {
        "number": 3114,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, node, visited):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(graph, neighbor, visited)\n\n    num_cases = 0\n    result = []\n\n    for line in stdin.split('\\n'):\n        if not line:\n            continue\n\n        if num_cases == 0:\n            N, M = map(int, line.split())\n            graph = {i: set() for i in range(1, N + 1)}\n            num_cases += 1\n        elif num_cases == 1:\n            X, Y = map(int, line.split())\n            graph[X].add(Y)\n            graph[Y].add(X)\n            if num_cases == M:\n                num_cases += 1\n        elif num_cases == M + 1:\n            if line == 'YES':\n                result.append('YES\\n')\n                for i in range(1, N + 1):\n                    for j in graph[i]:\n                        result.append(f'{i} {j}\\n')\n                break\n            elif line == 'NO':\n                result.append('NO')\n                break\n\n    return ''.join(result)"
    },
    {
        "number": 3115,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    match_list = []\n    for _ in range(m):\n        k, symbol, l = stdin.readline().split()\n        k, l = int(k), int(l)\n        match_list.append((k, symbol, l))\n\n    skill_level = [0] * n\n\n    for k, symbol, l in match_list:\n        if symbol == '>':\n            if skill_level[k] <= skill_level[l]:\n                skill_level[k] = skill_level[l] + 1\n            if skill_level[l] >= skill_level[k]:\n                skill_level[l] = skill_level[k] + 1\n        elif symbol == '=':\n            if skill_level[k] != skill_level[l]:\n                skill_level[k] = skill_level[l] = max(skill_level[k], skill_level[l]) + 1\n\n    is_consistent = True\n    for k, symbol, l in match_list:\n        if symbol == '>' and skill_level[k] <= skill_level[l]:\n            is_consistent = False\n            break\n        elif symbol == '=' and skill_level[k] != skill_level[l]:\n            is_consistent = False\n            break\n\n    return \"consistent\" if is_consistent else \"inconsistent\" "
    },
    {
        "number": 3115,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    wins = [0] * N\n    losses = [0] * N\n    draws = [0] * N\n\n    for _ in range(M):\n        K, symbol, L = stdin.readline().split()\n        K, L = int(K), int(L)\n\n        if symbol == '>':\n            wins[K] += 1\n            losses[L] += 1\n        elif symbol == '=':\n            draws[K] += 1\n            draws[L] += 1\n\n    for i in range(N):\n        if wins[i] + draws[i] > (N - 1) / 2:\n            return \"inconsistent\"\n\n    return \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    skill_level = [0] * n\n    opponent_skill_level = [0] * n\n\n    for _ in range(m):\n        player1, symbol, player2 = stdin.readline().split()\n        player1, player2 = map(int, [player1, player2])\n\n        if symbol == '=':\n            skill_level[player1] += 0.5\n            skill_level[player2] += 0.5\n            opponent_skill_level[player1] += skill_level[player2]\n            opponent_skill_level[player2] += skill_level[player1]\n        elif symbol == '>':\n            skill_level[player1] += 1\n            opponent_skill_level[player2] += skill_level[player1]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if opponent_skill_level[i] == opponent_skill_level[j]:\n                if skill_level[i] != skill_level[j]:\n                    return \"inconsistent\"\n            elif opponent_skill_level[i] > opponent_skill_level[j]:\n                return \"inconsistent\"\n\n    return \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().strip().split())\n    players = [0] * N\n    for _ in range(M):\n        u, symbol, v = stdin.readline().strip().split()\n        u, v = map(int, (u, v))\n        if symbol == '=':\n            players[u] = players[v] = max(players[u], players[v]) + 1\n        elif symbol == '>':\n            if players[u] < players[v]:\n                players[u], players[v] = players[v], players[u]\n            players[u] = max(players[u], players[v]) + 1\n    return 'inconsistent' if any(x == 0 for x in players) else 'consistent'"
    },
    {
        "number": 3115,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    players = [0] * N\n    matches = stdin.split(\"\\n\")[1:]\n\n    for match in matches:\n        player1, symbol, player2 = list(match)\n        player1, player2 = int(player1), int(player2)\n\n        if symbol == \"=\":\n            players[player1] = players[player2] = 0\n        elif symbol == \">\":\n            if players[player1] == 0:\n                players[player1] = 1\n            elif players[player1] == -1:\n                return \"inconsistent\"\n\n            if players[player2] == 0:\n                players[player2] = -1\n            elif players[player2] == 1:\n                return \"inconsistent\"\n\n    return \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_consistent(N, reported_matches):\n        skills = [0] * N\n\n        for match in reported_matches:\n            player1, symbol, player2 = match\n\n            if symbol == '=':\n                skills[player1] += 1\n                skills[player2] += 1\n            elif symbol == '>':\n                skills[player1] += 3\n                skills[player2] -= 3\n\n        for skill in skills:\n            if skill < 0:\n                return \"inconsistent\"\n\n        return \"consistent\"\n\n    N, M = map(int, stdin.split())\n    reported_matches = []\n\n    for _ in range(M):\n        player1, symbol, player2 = stdin.split()\n        reported_matches.append((int(player1), symbol, int(player2)))\n\n    return is_consistent(N, reported_matches)"
    },
    {
        "number": 3115,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def build_graph(matches):\n        graph = [[] for _ in range(n)]\n        for match in matches:\n            p1, symbol, p2 = match\n            if symbol == '>':\n                graph[p1].append((p2, 1))\n                graph[p2].append((p1, -1))\n            else:\n                graph[p1].append((p2, 0))\n                graph[p2].append((p1, 0))\n        return graph\n\n    def dfs(graph, node, visited, skills):\n        if node not in visited:\n            visited.add(node)\n            for neighbor, skill in graph[node]:\n                if neighbor not in visited:\n                    skills[neighbor] = skills[node] + skill\n                    dfs(graph, neighbor, visited, skills)\n\n    n, m = map(int, stdin.readline().strip().split())\n    matches = [tuple(stdin.readline().strip().split()) for _ in range(m)]\n    graph = build_graph(matches)\n    skills = {}\n    dfs(graph, 0, set(), skills)\n\n    for match in matches:\n        p1, symbol, p2 = match\n        if symbol == '>' and skills[p1] <= skills[p2]:\n            return 'inconsistent'\n        elif symbol == '=' and skills[p1] != skills[p2]:\n            return 'inconsistent'\n    return 'consistent'"
    },
    {
        "number": 3115,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    records = [x.split() for x in stdin.split(\"\\n\")[1:]]\n    players = [0] * N\n\n    for record in records:\n        K, symbol, L = record\n        K, L = int(K), int(L)\n        if symbol == \"=\":\n            players[K] += 0.5\n            players[L] += 0.5\n        elif symbol == \">\":\n            players[K] += 1\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if players[i] == players[j]:\n                continue\n            if players[i] > players[j]:\n                return \"inconsistent\"\n            elif players[i] < players[j]:\n                return \"inconsistent\"\n            else:\n                continue\n    return \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    games = stdin.split('\\n')[1:]\n\n    scores = [0] * N\n\n    for game in games:\n        player1, symbol, player2 = game.split()\n        player1, player2 = int(player1), int(player2)\n\n        if symbol == '=':\n            scores[player1] += 0.5\n            scores[player2] += 0.5\n        elif symbol == '>':\n            scores[player1] += 1\n\n    if all(score in [0, 1, 0.5] for score in scores):\n        return 'consistent'\n    else:\n        return 'inconsistent'"
    },
    {
        "number": 3115,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N, M = map(int, lines[0].split())\n    matches = [line.split() for line in lines[1:]]\n\n    results = {}\n    for match in matches:\n        player1, symbol, player2 = match\n        player1, player2 = int(player1), int(player2)\n        if symbol == \"=\":\n            results[(player1, player2)] = 0\n            results[(player2, player1)] = 0\n        else:\n            results[(player1, player2)] = 1\n            results[(player2, player1)] = -1\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if (i, j) not in results:\n                return \"inconsistent\"\n\n            result = results[(i, j)]\n            if result == 1 and results[(j, i)] != -1:\n                return \"inconsistent\"\n            elif result == -1 and results[(j, i)] != 1:\n                return \"inconsistent\"\n\n    return \"consistent\""
    },
    {
        "number": 3116,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    stars = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.readline().split())\n        stars.append((x, y, z))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def volume(p1, p2, r):\n        return 2 * 3.14159 * r ** 2 * distance(p1, p2)\n\n    def find_diameter(center, stars):\n        max_distance = 0\n        for star in stars:\n            max_distance = max(max_distance, distance(center, star))\n        return max_distance * 2\n\n    diameter = find_diameter(stars[0], stars[1:])\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            d = find_diameter(stars[i], [stars[k] for k in range(n) if k != i and k != j])\n            diameter = max(diameter, d)\n\n    return str(volume(stars[0], stars[1], diameter / 2))"
    },
    {
        "number": 3116,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    stars = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.readline().split())\n        stars.append((x, y, z))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** 0.5\n\n    def smallest_enclosing_cylinder(stars):\n        min_volume = float('inf')\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    axis = ((stars[i][0] + stars[j][0] + stars[k][0]) / 3,\n                            (stars[i][1] + stars[j][1] + stars[k][1]) / 3,\n                            (stars[i][2] + stars[j][2] + stars[k][2]) / 3)\n                    radius = max(distance(stars[i], axis),\n                                  distance(stars[j], axis),\n                                  distance(stars[k], axis))\n                    height = max(distance(stars[i], axis),\n                                  distance(stars[j], axis),\n                                  distance(stars[k], axis))\n                    volume = 3.14159265 * radius ** 2 * height\n                    min_volume = min(min_volume, volume)\n        return min_volume\n\n    return smallest_enclosing_cylinder(stars)"
    },
    {
        "number": 3116,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dot(a, b):\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\n    def cross(a, b):\n        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** 0.5\n\n    def smallest_cylinder(points):\n        min_base = float(\"inf\")\n        min_height = float(\"inf\")\n        min_radius = float(\"inf\")\n\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    a = [points[i][0] - points[j][0], points[i][1] - points[j][1], points[i][2] - points[j][2]]\n                    b = [points[i][0] - points[k][0], points[i][1] - points[k][1], points[i][2] - points[k][2]]\n                    c = cross(a, b)\n                    height = abs(dot(c, points[i]))\n                    base = distance(points[j], points[k])\n                    radius = abs(dot(c, [0, 0, 1])) / (distance([0, 0, 0], c) ** 2) ** 0.5\n\n                    if base < min_base or (base == min_base and height < min_height) or (base == min_base and height == min_height and radius < min_radius):\n                        min_base = base\n                        min_height = height\n                        min_radius = radius\n\n        return min_base * min_height * 2 * pi * min_radius\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    points = [list(map(int, line.split())) for line in lines[1:n + 1]]\n\n    return \"{:.10f}\".format(smallest_cylinder(points))"
    },
    {
        "number": 3116,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    stars = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    from itertools import combinations\n    from math import sqrt, inf\n\n    def distance(a, b):\n        return sqrt(sum((x1 - x2) ** 2 for x1, x2 in zip(a, b)))\n\n    def volume(a, b, r):\n        return r ** 2 * distance(a, b) * 2 * sqrt(1 - (distance(a, b) ** 2 / (2 * r ** 2)))\n\n    def max_volume(n, stars):\n        max_volume = 0\n        for c in combinations(stars, 3):\n            a, b, c = c\n            r = max(distance(a, b), distance(b, c), distance(c, a))\n            max_volume = max(max_volume, volume(a, b, r))\n        return max_volume\n\n    return str(max_volume(n, stars))"
    },
    {
        "number": 3116,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from math import sqrt, pi\n\n    def distance(p1, p2):\n        return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2)\n\n    def get_cylinder_volume(diameter, height):\n        return (pi * (diameter ** 2)) / 4 * height\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    stars = []\n    for i in range(1, n + 1):\n        x, y, z = map(int, lines[i].split())\n        stars.append((x, y, z))\n\n    diameter = max(distance(stars[i], stars[j]) for i in range(n) for j in range(i + 1, n))\n    height = max(stars, key=lambda x: x[2])[2] - min(stars, key=lambda x: x[2])[2]\n\n    return f\"{get_cylinder_volume(diameter, height):.10f}\""
    },
    {
        "number": 3116,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    stars = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.readline().strip().split())\n        stars.append((x, y, z))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def get_diameter(p1, p2, p3):\n        a, b, c = distance(p1, p2), distance(p1, p3), distance(p2, p3)\n        return (a * b * c) / ((a + b + c) * ((a + b - c) * (a - b + c) * (b - c + a)) ** 0.5)\n\n    max_diameter = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if not (len(set([stars[i], stars[j], stars[k]])) == 3):\n                    continue\n                d = get_diameter(stars[i], stars[j], stars[k])\n                max_diameter = max(max_diameter, d)\n\n    return f\"{max_diameter:.6f}\""
    },
    {
        "number": 3116,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(a, b):\n        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** 0.5\n\n    def volume_of_cylinder(r, h):\n        return r ** 2 * h\n\n    def find_cylinder(points):\n        n = len(points)\n        min_volume = float(\"inf\")\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    a = [points[i][0] - points[j][0], points[i][1] - points[j][1], points[i][2] - points[j][2]]\n                    b = [points[i][0] - points[k][0], points[i][1] - points[k][1], points[i][2] - points[k][2]]\n                    axis = cross_product(a, b)\n\n                    for l in range(k + 1, n):\n                        p = points[l]\n                        r = max([distance(p, points[m]) for m in range(n) if m != l])\n                        h = max([abs(axis[0] * (p[0] - points[m][0]) + axis[1] * (p[1] - points[m][1]) + axis[2] * (p[2] - points[m][2])) for m in range(n) if m != l])\n\n                        volume = volume_of_cylinder(r, h)\n                        min_volume = min(min_volume, volume)\n\n        return min_volume\n\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.readline().strip().split())\n        points.append((x, y, z))\n\n    return \"{:.10f}\".format(find_cylinder(points))"
    },
    {
        "number": 3116,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    from math import sqrt\n\n    def distance(p1, p2):\n        return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2)\n\n    def cylinder_volume(d, h):\n        return 3.14159 * d ** 2 * h\n\n    n = int(stdin.readline())\n    stars = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    max_volume = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                d1 = distance(stars[i], stars[j])\n                d2 = distance(stars[i], stars[k])\n                d3 = distance(stars[j], stars[k])\n\n                height = max(d1, d2, d3)\n                bases = [d1, d2, d3]\n                bases.remove(height)\n\n                if bases[0] ** 2 + bases[1] ** 2 >= height ** 2:\n                    diameter = (bases[0] + bases[1]) / 2\n                    volume = cylinder_volume(diameter, height)\n                    if volume > max_volume:\n                        max_volume = volume\n\n    return \"{:.9f}\".format(max_volume)"
    },
    {
        "number": 3116,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_angle(a, b, c):\n        return math.acos((b**2 + c**2 - a**2) / (2 * b * c))\n\n    def distance(a, b):\n        return ((a[0] - b[0])**2 + (a[1] - b[1])**2 + (a[2] - b[2])**2)**0.5\n\n    def cylinder_volume(diameter, height):\n        return math.pi * (diameter / 2)**2 * height\n\n    input_data = [list(map(int, line.split())) for line in stdin.split('\\n') if line]\n    n = input_data[0][0]\n    stars = input_data[1:]\n\n    max_volume = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if not math.isclose(distance(stars[i], stars[j]), distance(stars[i], stars[k]), rel_tol=1e-6):\n                    height = distance(stars[i], stars[j])\n                    diameter = distance(stars[i], stars[k])\n                    volume = cylinder_volume(diameter, height)\n                    max_volume = max(max_volume, volume)\n\n                if not math.isclose(distance(stars[i], stars[j]), distance(stars[i], stars[k]), rel_tol=1e-6):\n                    height = distance(stars[i], stars[j])\n                    diameter = distance(stars[i], stars[k])\n                    volume = cylinder_volume(diameter, height)\n                    max_volume = max(max_volume, volume)\n\n    return round(max_volume, 6)"
    },
    {
        "number": 3116,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def dist_from_center(points, center):\n        return [distance(center, point) for point in points]\n\n    def find_diameter(points):\n        max_distance = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                max_distance = max(max_distance, distance(points[i], points[j]))\n        return max_distance\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    points = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    if n < 4:\n        return \"0\"\n\n    diameter = find_diameter(points)\n    center_candidates = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if distance(points[i], points[j]) == distance(points[j], points[k]) == distance(points[i], points[k]):\n                    center = points[i], points[j], points[k]\n                    if len(set(center)) == 3:\n                        center_candidates.append(center)\n\n    min_volume = float(\"inf\")\n\n    for center in center_candidates:\n        radii = dist_from_center(points, center)\n        max_radius = max(radii)\n        min_volume = min(min_volume, max_radius ** 2 * diameter)\n\n    return f\"{min_volume:.6f}\""
    },
    {
        "number": 3117,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.readline().strip())\n    message = stdin.readline().strip()\n    \n    d = {}\n    for i in range(L):\n        for j in range(i+1, L):\n            if message[i:j+1] in d:\n                d[message[i:j+1]] += 1\n            else:\n                d[message[i:j+1]] = 1\n    \n    max_length = 0\n    for k, v in d.items():\n        if v >= 2 and len(k) > max_length:\n            max_length = len(k)\n            \n    return str(max_length)"
    },
    {
        "number": 3117,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    L, string = stdin.split('\\n')\n    L = int(L)\n    string = string.strip()\n    seen = set()\n    max_len = 0\n\n    for i in range(L):\n        for j in range(i + 1, L + 1):\n            substring = string[i:j]\n            if substring in seen:\n                max_len = max(max_len, len(substring))\n            else:\n                seen.add(substring)\n\n    return str(max_len)"
    },
    {
        "number": 3117,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.readline().strip())\n    string = stdin.readline().strip()\n    longest_substring = ''\n    substrings = {}\n\n    for i in range(L):\n        for j in range(i + 1, L + 1):\n            substring = string[i:j]\n            if substring in substrings:\n                if len(substring) > len(longest_substring):\n                    longest_substring = substring\n            else:\n                substrings[substring] = True\n\n    return len(longest_substring) if longest_substring else 0\n\nprint(solution(sys.stdin)) "
    },
    {
        "number": 3117,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    L, string = map(str, stdin.split())\n    L = int(L)\n    string_set = set()\n    max_length = 0\n\n    for i in range(L):\n        for j in range(i + 1, L + 1):\n            substring = string[i:j]\n            if substring in string_set:\n                max_length = max(max_length, len(substring))\n            else:\n                string_set.add(substring)\n\n    return str(max_length)"
    },
    {
        "number": 3117,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    seen = set()\n    longest_string = \"\"\n\n    i = 0\n    j = 0\n\n    while j < L:\n        if s[i:j+1] in seen:\n            if j - i > len(longest_string):\n                longest_string = s[i:j+1]\n            seen.remove(s[i:j+1])\n            i += 1\n        else:\n            seen.add(s[i:j+1])\n            j += 1\n\n    return len(longest_string)"
    },
    {
        "number": 3117,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.readline().strip())\n    message = stdin.readline().strip()\n    \n    longest_substring = \"\"\n    for i in range(L):\n        for j in range(i+1, L):\n            substring = message[i:j+1]\n            if substring in message[:i] or substring in message[j+1:]:\n                if len(substring) > len(longest_substring):\n                    longest_substring = substring\n                    \n    return len(longest_substring) if longest_substring else 0"
    },
    {
        "number": 3117,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    if len(s) != n:\n        raise ValueError(\"Input length does not match the given length.\")\n\n    longest_substring = \"\"\n    substrings = {}\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if len(substring) > len(longest_substring):\n                if substring in substrings and substrings[substring] >= 1:\n                    longest_substring = substring\n            if substring not in substrings:\n                substrings[substring] = 1\n            else:\n                substrings[substring] += 1\n\n    return len(longest_substring)"
    },
    {
        "number": 3117,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.readline().strip())\n    string = stdin.readline().strip()\n\n    seen = set()\n    max_length = 0\n\n    i, j = 0, 0\n    while j < L:\n        if string[j] not in seen:\n            seen.add(string[j])\n            j += 1\n        else:\n            if j - i + 1 > max_length:\n                max_length = j - i + 1\n            while string[i] != string[j]:\n                seen.remove(string[i])\n                i += 1\n            i += 1\n            j += 1\n\n    return str(max_length)"
    },
    {
        "number": 3117,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    L = int(lines[0])\n    s = lines[1]\n    longest = 0\n    for i in range(L):\n        for j in range(i + 1, L):\n            substring = s[i:j+1]\n            if s.count(substring) > 1 and len(substring) > longest:\n                longest = len(substring)\n    return str(longest)"
    },
    {
        "number": 3117,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.readline().strip())\n    messages = stdin.readline().strip()\n    \n    if L == 1:\n        return 0\n    \n    longest_repeated_substring = \"\"\n    for i in range(L):\n        for j in range(i + 1, L):\n            substring = messages[i:j+1]\n            if messages.count(substring) >= 2 and len(substring) > len(longest_repeated_substring):\n                longest_repeated_substring = substring\n                \n    return len(longest_repeated_substring)"
    },
    {
        "number": 3118,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    deck = [i for i in range(1, n + 1)]\n    alice_shuffled_deck = [deck[a[i - 1] - 1] for i in a]\n    bob_shuffled_deck = [alice_shuffled_deck[b[i - 1] - 1] for i in b]\n    if bob_shuffled_deck == deck:\n        return 2\n    else:\n        return \"huge\""
    },
    {
        "number": 3118,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_permutation_cycle_length(permutation: List[int]) -> int:\n        visited = [False] * len(permutation)\n        cycle_length = 0\n        for i in range(len(permutation)):\n            if not visited[i]:\n                cycle_length += 1\n                j = permutation[i]\n                while not visited[j]:\n                    visited[j] = True\n                    j = permutation[j]\n        return cycle_length\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    alice_permutation = list(map(int, lines[1].split()))\n    bob_permutation = list(map(int, lines[2].split()))\n\n    alice_cycle_length = get_permutation_cycle_length(alice_permutation)\n    bob_cycle_length = get_permutation_cycle_length(bob_permutation)\n\n    if alice_cycle_length == 1 and bob_cycle_length == 1:\n        return \"1\"\n    else:\n        if alice_cycle_length == 1:\n            return str(bob_cycle_length)\n        elif bob_cycle_length == 1:\n            return str(alice_cycle_length)\n        else:\n            return str(lcm(alice_cycle_length, bob_cycle_length))\n\n    if n > 10**5:\n        return \"huge\"\n\n    if n == 1:\n        return \"1\"\n\n    # Check if Alice's or Bob's permutation is a single cycle\n    alice_single_cycle = True\n    bob_single_cycle = True\n    for i in range(n):\n        if alice_permutation[alice_permutation[i] - 1] != i + 1:\n            alice_single_cycle = False\n            break\n        if bob_permutation[bob_permutation[i] - 1] != i + 1:\n            bob_single_cycle = False\n            break\n\n    if alice_single_cycle and bob_single_cycle:\n        return \"2\"\n    elif alice_single_cycle:\n        return \"1\"\n    elif bob_single_cycle:\n        return \"1\"\n    else:\n        alice_cycle_length = get_permutation_cycle_length(alice_permutation)\n        bob_cycle_length = get_permutation_cycle_length(bob_permutation)\n        lcm_cycle_length = lcm(alice_cycle_length, bob_cycle_length)\n        if lcm_cycle_length > 10**12:\n            return \"huge\"\n        else:\n            return str(lcm_cycle_length) "
    },
    {
        "number": 3118,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = [x.strip() for x in stdin.split('\\n')]\n    n, a, b = int(n), list(map(int, a.split())), list(map(int, b.split()))\n\n    def shuffle(perm):\n        return [perm[i - 1] for i in perm]\n\n    def compose(a, b):\n        return [a[i - 1] for i in b]\n\n    def identity(n):\n        return list(range(1, n + 1))\n\n    def inverse(perm):\n        return [perm.index(i) + 1 for i in range(1, len(perm) + 1)]\n\n    def order(perm):\n        n = len(perm)\n        i = 0\n        visited = set()\n        while i < n and perm[i] not in visited:\n            visited.add(perm[i])\n            i = perm[i] - 1\n        return len(visited)\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    deck = identity(n)\n    alice_order = order(a)\n    bob_order = order(b)\n\n    if alice_order == 1 and bob_order == 1:\n        return \"huge\"\n\n    l = lcm(alice_order, bob_order)\n\n    if n == 1:\n        return str(l)\n\n    deck = identity(n)\n    alice_perm = shuffle(a)\n    bob_perm = shuffle(b)\n\n    for i in range(l):\n        if deck == identity(n):\n            return str(i + 1)\n        deck = compose(alice_perm, deck)\n        deck = compose(bob_perm, deck)\n\n    return \"huge\""
    },
    {
        "number": 3118,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = [x for x in stdin.split('\\n')]\n    n = int(n)\n    a = list(map(int, a.split()))\n    b = list(map(int, b.split()))\n\n    def count_cycles(perm):\n        visited = [False] * n\n        cycles = []\n        for i in range(n):\n            if not visited[i]:\n                cycle = [i]\n                j = i\n                while not visited[j]:\n                    visited[j] = True\n                    j = perm[j]\n                    cycle.append(j)\n                cycles.append(cycle)\n        return cycles\n\n    cycles_a = count_cycles(a)\n    cycles_b = count_cycles(b)\n\n    lcm = 1\n    for c in cycles_a + cycles_b:\n        lcm = lcm * len(c) // gcd(lcm, len(c))\n\n    if lcm > 10**12:\n        return 'huge'\n    else:\n        return str(lcm)\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = [[int(x) for x in line.strip().split()] for line in stdin.split('\\n')]\n    a = [0] + a\n    b = [0] + b\n    a_inv = [0] * (n + 1)\n    b_inv = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        a_inv[a[i]] = i\n        b_inv[b[i]] = i\n\n    cycle_lengths = []\n    for i in range(1, n + 1):\n        if a[i] == 0 or b[i] == 0:\n            continue\n        cycle_length = 0\n        while a[i] != i or b[i] != i:\n            i = a_inv[i]\n            cycle_length += 1\n            i = b_inv[i]\n            cycle_length += 1\n        cycle_lengths.append(cycle_length)\n\n    lcm = 1\n    for cycle_length in cycle_lengths:\n        lcm = lcm * cycle_length // gcd(lcm, cycle_length)\n\n    if lcm > 10**12:\n        return \"huge\"\n    else:\n        return str(lcm)\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def matrix_multiply(a, b):\n        result = [[0] * len(b[0]) for _ in range(len(a))]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n        return result\n\n    def matrix_power(matrix, n):\n        if n == 1:\n            return matrix\n        if n % 2 == 0:\n            half_power = matrix_power(matrix, n // 2)\n            return matrix_multiply(half_power, half_power)\n        else:\n            return matrix_multiply(matrix, matrix_power(matrix, n - 1))\n\n    n, a, b = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    deck = list(range(1, n + 1))\n    alice_matrix = [deck[i - 1] for i in a]\n    bob_matrix = [deck[i - 1] for i in b]\n\n    result_matrix = matrix_multiply([alice_matrix], bob_matrix)\n    result_matrix = matrix_power(result_matrix, 1000000000000)\n    final_deck = [0] * n\n    for i in range(n):\n        final_deck[i] = result_matrix[i].index(i + 1) + 1\n\n    if final_deck == deck:\n        return \"huge\"\n    else:\n        return str(len(result_matrix)) "
    },
    {
        "number": 3118,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_cycle_length(perm):\n        n = len(perm)\n        cycle_lengths = []\n        for i in range(n):\n            if perm[i] == i:\n                continue\n            cycle = [i]\n            while perm[i] not in cycle:\n                i = perm[i]\n                cycle.append(i)\n            cycle_lengths.append(len(cycle))\n        return cycle_lengths\n\n    def get_lcm(cycle_lengths):\n        lcm = cycle_lengths[0]\n        for i in range(1, len(cycle_lengths)):\n            lcm = lcm * cycle_lengths[i] // gcd(lcm, cycle_lengths[i])\n        return lcm\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    n = int(stdin.readline().strip())\n    alice_perm = list(map(int, stdin.readline().strip().split()))\n    bob_perm = list(map(int, stdin.readline().strip().split()))\n\n    alice_cycle_lengths = get_cycle_length(alice_perm)\n    bob_cycle_lengths = get_cycle_length(bob_perm)\n\n    lcm = get_lcm(alice_cycle_lengths + bob_cycle_lengths)\n\n    if lcm > 10**12:\n        return \"huge\"\n    else:\n        return str(lcm)"
    },
    {
        "number": 3118,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def check_sorted(permutation):\n        return all(permutation[i] <= permutation[i + 1] for i in range(len(permutation) - 1))\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def min_shuffles(alice, bob, n):\n        if check_sorted(alice) or check_sorted(bob):\n            return 0\n\n        l = lcm(n, n)\n        cycles = [0] * l\n\n        for i in range(l):\n            cycles[i] = alice[bob[i]]\n\n        min_cycle = min(cycles)\n        min_cycle_idx = cycles.index(min_cycle)\n\n        alice_cycle_length = (alice.index(min_cycle) + 1)\n        bob_cycle_length = (bob.index(min_cycle) + 1)\n\n        if min_cycle_idx == 0:\n            total_cycle_length = lcm(alice_cycle_length, bob_cycle_length)\n        else:\n            total_cycle_length = min(alice_cycle_length, bob_cycle_length)\n\n        return l // total_cycle_length\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    alice = list(map(int, lines[1].split()))\n    bob = list(map(int, lines[2].split()))\n\n    min_shuffles_count = min_shuffles(alice, bob, n)\n    return str(min_shuffles_count) if min_shuffles_count <= 10**12 else \"huge\""
    },
    {
        "number": 3118,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    alice = list(map(int, stdin.readline().strip().split()))\n    bob = list(map(int, stdin.readline().strip().split()))\n\n    if alice == list(range(1, n + 1)):\n        return \"0\"\n\n    permutation = [0] * n\n    for i in range(n):\n        permutation[alice[i] - 1] = i\n\n    cycles = []\n    visited = [False] * n\n\n    for start in range(n):\n        if not visited[start]:\n            cycle = []\n            current = start\n            while not visited[current]:\n                cycle.append(current)\n                visited[current] = True\n                current = alice[current] - 1\n            if cycle:\n                cycles.append(cycle)\n\n    lcm = 1\n    for cycle in cycles:\n        cycle_length = len(cycle)\n        lcm = lcm * cycle_length // gcd(lcm, cycle_length)\n\n    if lcm > 10**12:\n        return \"huge\"\n    else:\n        return str(lcm)\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def count_cycles(perm):\n        visited = [False] * len(perm)\n        cycles = []\n        for i in range(len(perm)):\n            if not visited[i]:\n                cycle = [i]\n                while not visited[cycle[-1]]:\n                    visited[cycle[-1]] = True\n                    cycle.append(perm[cycle[-1]])\n                if len(cycle) == 1:\n                    continue\n                cycles.append(cycle)\n        return cycles\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    n = int(stdin.readline().strip())\n    a_perm = list(map(int, stdin.readline().strip().split()))\n    b_perm = list(map(int, stdin.readline().strip().split()))\n\n    a_cycles = count_cycles(a_perm)\n    b_cycles = count_cycles(b_perm)\n\n    lcm_length = 1\n    for cycle in a_cycles + b_cycles:\n        lcm_length = lcm(lcm_length, len(cycle))\n\n    if lcm_length > 10**12:\n        return \"huge\"\n    else:\n        return str(lcm_length) "
    },
    {
        "number": 3119,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_overlap(s1, e1, s2, e2):\n        if s1 <= s2 <= e1 or s1 <= e2 <= e1:\n            return True\n        return False\n\n    def calculate_score(notes, sp_phrases):\n        score = 0\n        sp_meter = 0\n        sp_activated = False\n        sp_start = -1\n\n        for i in range(len(notes)):\n            if sp_activated:\n                score += 2\n                sp_meter -= (notes[i] - notes[sp_start]) / 1000\n                if sp_meter <= 0:\n                    sp_activated = False\n                    sp_meter = 0\n            else:\n                score += 1\n\n            for j in range(len(sp_phrases)):\n                if is_overlap(sp_phrases[j][0], sp_phrases[j][1], notes[i], notes[i]):\n                    if sp_meter == 0:\n                        sp_start = i\n                        sp_activated = True\n                    else:\n                        sp_meter = 0\n                        sp_activated = False\n                        score -= 1\n                    break\n\n        return score\n\n    lines = stdin.strip().split('\\n')\n    n, p = map(int, lines[0].split())\n    notes = list(map(int, lines[1].split()))\n    sp_phrases = [list(map(int, lines[i + 2].split())) for i in range(p)]\n\n    return str(calculate_score(notes, sp_phrases))"
    },
    {
        "number": 3119,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.readline().split())\n    times = list(map(int, stdin.readline().split()))\n    phrases = [list(map(int, stdin.readline().split())) for _ in range(p)]\n\n    def score(time: int) -> int:\n        points = 0\n        sp_meter = 0\n        for start, end in phrases:\n            if start <= time <= end:\n                sp_meter += end - start\n        if sp_meter > 0:\n            points += 2 * sum(1 for t in times if t <= time)\n            return points\n        else:\n            return sum(1 for t in times if t <= time)\n\n    return max(score(time) for time in times)"
    },
    {
        "number": 3119,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.readline().split())\n    notes = list(map(int, stdin.readline().split()))\n    sp_phrases = [list(map(int, stdin.readline().split())) for _ in range(p)]\n\n    def is_overlapping(start, end, sp_phrase):\n        return start <= sp_phrase[0] <= end and start <= sp_phrase[1] <= end\n\n    def score_notes(start, end, sp_charge, sp_active):\n        if sp_charge > 0 and sp_active:\n            return (end - start) * 2\n        else:\n            return end - start\n\n    def score_sp_phrase(start, end, sp_charge, sp_active):\n        if not is_overlapping(start, end, sp_phrases[0]):\n            sp_charge += (end - start) / 1000\n        else:\n            sp_charge += (sp_phrases[0][0] - start) / 1000\n        sp_phrases.pop(0)\n        return sp_charge\n\n    def calculate_score(start, end, sp_charge, sp_active):\n        score = 0\n        i = start\n        while i < end:\n            for sp_phrase in sp_phrases:\n                if is_overlapping(i, notes[i + 1], sp_phrase):\n                    if sp_charge > 0:\n                        score += score_notes(i, sp_phrase[0], sp_charge, True)\n                        score += score_notes(sp_phrase[1], notes[i + 1], sp_charge, False)\n                    else:\n                        score += score_notes(i, sp_phrase[0], sp_charge, False)\n                        score += score_notes(sp_phrase[1], notes[i + 1], sp_charge, False)\n                    sp_charge = score_sp_phrase(sp_phrase[0], sp_phrase[1], sp_charge, True)\n                else:\n                    if sp_charge > 0 and sp_active:\n                        score += score_notes(i, notes[i + 1], sp_charge, True)\n                    else:\n                        score += score_notes(i, notes[i + 1], sp_charge, False)\n            i += 1\n\n        return score\n\n    return calculate_score(0, n, 0, False)"
    },
    {
        "number": 3119,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.readline().split())\n    notes = list(map(int, stdin.readline().split()))\n    sp_phrases = [list(map(int, stdin.readline().split())) for _ in range(p)]\n\n    def score(sp_charge, last_note_index):\n        return (last_note_index + 1) * 2 * sp_charge + (n - last_note_index - 1)\n\n    def degrade_sp_phrase(phrase_index, start, end, sp_charge, last_note_index):\n        nonlocal notes, sp_phrases\n        degrade_start = max(start, notes[last_note_index] + 1)\n        degrade_end = min(end, notes[last_note_index + 1])\n        if degrade_start <= degrade_end:\n            sp_phrases.append([degrade_start, degrade_end])\n            sp_charge -= (degrade_end - degrade_start) / 1000\n        if sp_charge > 0:\n            sp_charge = max(0, sp_charge - (end - start) / 1000)\n        else:\n            sp_charge = 0\n        return sp_charge, last_note_index\n\n    def update_sp_charge(sp_charge, last_note_index):\n        nonlocal notes, sp_phrases\n        sp_charge = max(0, sp_charge - (notes[last_note_index + 1] - notes[last_note_index]) / 1000)\n        for i, (start, end) in enumerate(sp_phrases):\n            if start <= notes[last_note_index] < end:\n                sp_charge, last_note_index = degrade_sp_phrase(i, start, end, sp_charge, last_note_index)\n        return sp_charge, last_note_index\n\n    max_score = 0\n    for i in range(n):\n        max_score = max(max_score, score(0, i))\n        sp_charge = 0\n        last_note_index = i\n        for j in range(i + 1, n):\n            sp_charge, last_note_index = update_sp_charge(sp_charge, last_note_index)\n            max_score = max(max_score, score(sp_charge, j))\n\n    return str(max_score)"
    },
    {
        "number": 3119,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.readline().split())\n    t = list(map(int, stdin.readline().split()))\n    sp = []\n    for _ in range(p):\n        sp.append(list(map(int, stdin.readline().split())))\n\n    def get_score(t, sp):\n        t = sorted(t)\n        sp = sorted(sp, key=lambda x: x[0])\n\n        score = 0\n        sp_meter = 0\n\n        i = 0  # to iterate through notes\n        j = 0  # to iterate through SP phrases\n\n        while i < len(t) and j < len(sp):\n            if t[i] < sp[j][0]:\n                if sp_meter == 0:\n                    score += 1\n                else:\n                    score += 2\n                    sp_meter -= (sp[j][1] - sp[j][0]) - (t[i] - sp[j][0])\n                    if sp_meter < 0:\n                        sp_meter = 0\n            elif sp[j][0] <= t[i] <= sp[j][1]:\n                if sp_meter == 0:\n                    sp_meter = (sp[j][1] - sp[j][0]) - (t[i] - sp[j][0])\n                else:\n                    sp_meter = (sp[j][1] - sp[j][0])\n            else:\n                j += 1\n\n            i += 1\n\n        while i < len(t):\n            if sp_meter == 0:\n                score += 1\n            else:\n                score += 2\n                sp_meter -= (t[i] - t[i - 1])\n                if sp_meter < 0:\n                    sp_meter = 0\n            i += 1\n\n        return score\n\n    return get_score(t, sp)"
    },
    {
        "number": 3119,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.readline().split())\n    positions = list(map(int, stdin.readline().split()))\n    sp_phrases = [list(map(int, stdin.readline().split())) for _ in range(p)]\n\n    def score(positions, sp_phrases):\n        total_score = 0\n        sp_charge = 0\n        sp_activated = False\n        note_idx = 0\n        sp_idx = 0\n\n        while note_idx < len(positions) or sp_idx < len(sp_phrases):\n            if note_idx < len(positions) and positions[note_idx] < positions[sp_idx]:\n                if sp_charge > 0:\n                    total_score += 2\n                    sp_charge -= (positions[note_idx] - positions[note_idx - 1]) / 1000\n                else:\n                    total_score += 1\n                note_idx += 1\n            elif note_idx < len(positions) and positions[note_idx] == positions[sp_idx]:\n                if sp_charge > 0:\n                    total_score += 2\n                    sp_charge -= (positions[note_idx] - positions[note_idx - 1]) / 1000\n                else:\n                    total_score += 1\n                note_idx += 1\n            else:\n                if not sp_activated:\n                    sp_charge += pi + sqrt(7)\n                    sp_activated = True\n                else:\n                    sp_charge -= (positions[sp_idx - 1] - positions[sp_idx - 2]) / 1000\n                if sp_charge <= 0:\n                    sp_activated = False\n                sp_idx += 1\n\n        return total_score\n\n    return score(positions, sp_phrases)"
    },
    {
        "number": 3119,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_score(notes, sp_phrases):\n        n = len(notes)\n        sp_phrases.sort(key=lambda x: x[1])  # Sort by end position\n        sp_meter = 0  # Current SP meter\n        sp_activations = []  # List of tuples (start_time, end_time)\n        max_score = 0\n\n        for i in range(n):\n            if i == 0 or notes[i] > notes[i - 1]:  # Check if notes are strictly increasing\n                max_score += 1  # Regular note\n            else:\n                max_score += 2  # Star Power note\n\n            # Update SP meter and activations\n            while sp_phrases and notes[i] >= sp_phrases[0][0]:\n                start, end = sp_phrases.pop(0)\n                if start <= notes[i]:\n                    sp_meter = max(sp_meter, end - start)\n                    sp_activations.append((start, end))\n                else:\n                    break\n\n            # Use SP meter if possible\n            while sp_activations and notes[i] >= sp_activations[0][0]:\n                start, end = sp_activations.pop(0)\n                if notes[i] < end:\n                    max_score += 2  # Star Power note\n                else:\n                    sp_meter = max(sp_meter, end - start)\n                    if i + 1 < n and notes[i + 1] <= end:\n                        sp_activations.append((start, end))\n                    else:\n                        max_score += 2  # Star Power note\n                        break\n\n        return max_score\n\n    input_data = list(map(int, stdin.split()))\n    n, p = input_data[0], input_data[1]\n    notes = input_data[2:n + 2]\n    sp_phrases = []\n\n    for i in range(p):\n        start, end = input_data[2 + n + 2 * i], input_data[2 + n + 2 * i + 1]\n        sp_phrases.append((start, end))\n\n    return str(get_max_score(notes, sp_phrases))"
    },
    {
        "number": 3119,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.readline().split())\n    notes = list(map(int, stdin.readline().split()))\n    sp_phrases = [list(map(int, stdin.readline().split())) for _ in range(p)]\n\n    def get_score(index, sp_charge, sp_active):\n        if index == n:\n            return 0\n\n        if notes[index] in [phrase[0] for phrase in sp_phrases]:\n            sp_charge = max(sp_charge, sp_phrases[0][1] - sp_phrases[0][0])\n\n        if sp_charge > 0 and not sp_active:\n            sp_active = True\n            return max(get_score(index + 1, sp_charge, sp_active) + 2, 2 + get_score(index + 1, 0, False))\n        else:\n            sp_active = False\n            return get_score(index + 1, 0, False) + 1\n\n    return get_score(0, 0, False)"
    },
    {
        "number": 3119,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_score(notes, sp_phrases):\n        score = 0\n        sp_meter = 0\n        sp_active = False\n\n        for note in notes:\n            if sp_active:\n                if sp_meter <= 0:\n                    sp_active = False\n                else:\n                    sp_meter -= 1\n                    note_value = 2\n            else:\n                note_value = 1\n\n            score += note_value\n\n            if note in sp_phrases:\n                sp_meter += sp_phrases[note]\n                if sp_meter > 0:\n                    sp_active = True\n\n        return score\n\n    stdin_list = stdin.split('\\n')\n    n, p = map(int, stdin_list[0].split())\n    t = list(map(int, stdin_list[1].split()))\n    sp_phrases = {int(line.split()[0]): float(line.split()[1]) for line in stdin_list[2:]}\n\n    notes = sorted(set(t + list(sp_phrases.keys())))\n\n    return calculate_score(notes, sp_phrases)"
    },
    {
        "number": 3119,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    input_list = stdin.split('\\n')\n    n, p = map(int, input_list[0].split())\n    t_list = list(map(int, input_list[1].split()))\n    s_list = []\n    e_list = []\n    for i in range(2, 2 + p):\n        s, e = map(int, input_list[i].split())\n        s_list.append(s)\n        e_list.append(e)\n\n    # initialize variables\n    max_score = 0\n    sp_meter = 0\n    sp_charge = []\n    for i in range(n):\n        sp_charge.append(0)\n\n    # calculate score\n    for i in range(n):\n        if i == 0:\n            max_score += 2 if sp_meter > 0 else 1\n        elif i == n - 1:\n            max_score += 2 if sp_meter > 0 else 1\n            max_score += sum(sp_charge) * 2\n        else:\n            if sp_meter > 0:\n                max_score += 2\n                sp_meter -= (t_list[i] - t_list[i - 1]) / 1000\n                if sp_meter < 0:\n                    sp_meter = 0\n            else:\n                max_score += 1\n\n            # calculate SP charge\n            sp_charge_delta = 0\n            for j in range(len(s_list)):\n                if s_list[j] <= t_list[i] <= e_list[j]:\n                    if sp_meter > 0 and s_list[j] == t_list[i]:\n                        continue\n                    sp_charge[j] += (min(e_list[j], t_list[i + 1]) - t_list[i]) / 1000\n                    if sp_meter == 0 and s_list[j] == t_list[i]:\n                        sp_charge_delta += sp_charge[j]\n            sp_meter += sp_charge_delta\n\n    return str(max_score)"
    },
    {
        "number": 3120,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def shuffle(lst):\n        return random.sample(lst, len(lst))\n\n    def sorted(lst):\n        return sorted(lst)\n\n    def concat(lst1, lst2):\n        return lst1 + lst2\n\n    def parse_expr(expr):\n        if expr[0] == \"[\":\n            return [int(x) for x in expr[1:-1].split(\",\")]\n        else:\n            func, args = expr.split(\"(\")\n            args = [parse_expr(arg.strip()) for arg in args[:-1].split(\",\")]\n            if func == \"shuffle\":\n                return shuffle(args[0])\n            elif func == \"sorted\":\n                return sorted(args[0])\n            elif func == \"concat\":\n                return concat(*args)\n\n    A, B = stdin.strip().split(\"\\n\")\n    A_eval = parse_expr(A)\n    B_eval = parse_expr(B)\n\n    if set(A_eval) != set(B_eval):\n        return \"not equal\"\n\n    A_eval.sort()\n    B_eval.sort()\n\n    if A_eval == B_eval:\n        return \"equal\"\n    else:\n        return \"not equal\""
    },
    {
        "number": 3120,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_equal(A, B):\n        for i in range(2, 10**6):\n            L1 = A.replace('1', '0') if '1' in A else A.replace('2', '1').replace('1', '0')\n            L2 = B.replace('1', '0') if '1' in B else B.replace('2', '1').replace('1', '0')\n            if L1 != L2:\n                return False\n        return True\n\n    A, B = stdin.split('\\n')\n    return 'equal' if is_equal(A, B) else 'not equal'"
    },
    {
        "number": 3120,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B = stdin.strip().split('\\n')\n\n    def evaluate(expr: str, state: dict) -> List[int]:\n        if expr.startswith('[') and expr.endswith(']'):\n            return [int(x) for x in expr[1:-1].split(',')]\n        elif expr.startswith('concat(') and expr.endswith(')'):\n            subexprs = expr[7:-1].split(',')\n            result = []\n            for subexpr in subexprs:\n                result.extend(evaluate(subexpr, state))\n            return result\n        elif expr.startswith('shuffle(') and expr.endswith(')'):\n            subexpr = expr[8:-1]\n            result = evaluate(subexpr, state)\n            random.shuffle(result)\n            return result\n        elif expr.startswith('sorted(') and expr.endswith(')'):\n            subexpr = expr[7:-1]\n            result = evaluate(subexpr, state)\n            result.sort()\n            return result\n        else:\n            raise ValueError(f\"Invalid expression: {expr}\")\n\n    state = {'shuffle': random.getstate(), 'random': random.getstate()}\n    A_results = set(tuple(evaluate(A, state)) for _ in range(100))\n    B_results = set(tuple(evaluate(B, state)) for _ in range(100))\n\n    if A_results == B_results:\n        return \"equal\"\n    else:\n        return \"not equal\""
    },
    {
        "number": 3120,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import permutations\n\n    def parse_program(program):\n        stack = []\n        i = 0\n        while i < len(program):\n            if program[i] == \"[\":\n                stack.append([])\n                i += 1\n            elif program[i] == \",\":\n                i += 1\n            elif program[i] == \"]\":\n                lst = stack.pop()\n                if stack:\n                    stack[-1].append(lst)\n                else:\n                    return lst\n                i += 1\n            else:\n                j = i\n                while j < len(program) and program[j].isdigit():\n                    j += 1\n                stack[-1].append(int(program[i:j]))\n                i = j\n\n        return stack[0]\n\n    def shuffle(lst):\n        return [lst[:1] + p for p in permutations(lst[1:])]\n\n    def sorted_lists(lst):\n        if not lst:\n            return [[]]\n        head = lst[0]\n        tail = lst[1:]\n        sorted_tails = sorted_lists(tail)\n        return [[head] + st for st in sorted_tails] + sorted_tails\n\n    def evaluate(program, input_list):\n        if isinstance(program, int):\n            return [input_list[program - 1]] if 1 <= program <= len(input_list) else []\n        elif program[0] == \"concat\":\n            return evaluate(program[1], input_list) + evaluate(program[2], input_list)\n        elif program[0] == \"shuffle\":\n            return shuffle(evaluate(program[1], input_list))\n        elif program[0] == \"sorted\":\n            return sorted_lists(evaluate(program[1], input_list))\n        else:\n            return []\n\n    A, B = stdin.split(\"\\n\")\n    A_parsed = parse_program(A)\n    B_parsed = parse_program(B)\n\n    all_lists = set(evaluate(A_parsed, list(range(1, 10**6))))\n    for lst in evaluate(B_parsed, list(range(1, 10**6))):\n        if lst not in all_lists:\n            return \"not equal\"\n    return \"equal\"\n"
    },
    {
        "number": 3120,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Split input into two strings\n    A, B = stdin.split('\\n')\n\n    # Parse A and B into lists of integer lists\n    A = A.replace('shuffle', 'shuffle(').replace('concat', 'concat(').split('(')\n    B = B.replace('shuffle', 'shuffle(').replace('concat', 'concat(').split('(')\n\n    A = [int(x) for x in A if x.isdigit()]\n    B = [int(x) for x in B if x.isdigit()]\n\n    # Create permutations of A and B\n    def permute(lst):\n        if len(lst) <= 1:\n            return [lst]\n        result = []\n        for i in range(len(lst)):\n            rest = lst[:i] + lst[i+1:]\n            for p in permute(rest):\n                result.append([lst[i]] + p)\n        return result\n\n    A_perms = permute(A)\n    B_perms = permute(B)\n\n    # Check if each permutation of A is equal to a permutation of B\n    for a in A_perms:\n        a_set = set(a)\n        for b in B_perms:\n            b_set = set(b)\n            if a_set == b_set:\n                return 'equal'\n\n    return 'not equal'"
    },
    {
        "number": 3120,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_equivalent(program_a: str, program_b: str) -> bool:\n        def evaluate(program: str, input_list: list[int]) -> list[int]:\n            stack = []\n            for token in program:\n                if token.isdigit():\n                    stack.append(int(token))\n                elif token == '[':\n                    stack.append('[')\n                elif token == ']':\n                    sub_program = stack.pop()\n                    result = []\n                    for element in sub_program:\n                        if isinstance(element, list):\n                            result.extend(element)\n                        else:\n                            result.append(element)\n                    stack.append(result)\n                elif token == ',':\n                    pass\n                elif token == '(':\n                    stack.append(token)\n                elif token == ')':\n                    args = []\n                    while stack[-1] != '(':\n                        args.append(stack.pop())\n                    stack.pop()\n                    sub_program = stack.pop()\n                    if sub_program == 'shuffle':\n                        random.shuffle(args[0])\n                        result = args[0]\n                    elif sub_program == 'concat':\n                        result = []\n                        for arg in args:\n                            result.extend(arg)\n                    elif sub_program == 'sorted':\n                        result = sorted(args[0])\n                    stack.append(result)\n            return stack[-1]\n\n        all_inputs = set(itertools.permutations(input_list))\n        results_a = set(evaluate(program_a, list(input_list)) for input_list in all_inputs)\n        results_b = set(evaluate(program_b, list(input_list)) for input_list in all_inputs)\n\n        return results_a == results_b\n\n    program_a, program_b = stdin.strip().split('\\n')\n\n    if is_equivalent(program_a, program_b):\n        return \"equal\"\n    else:\n        return \"not equal\" "
    },
    {
        "number": 3120,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from random import shuffle\n\n    def evaluate(expr: str) -> list:\n        stack = []\n        for c in expr:\n            if c == '[':\n                stack.append([])\n            elif c == ']':\n                lst = stack.pop()\n                if stack:\n                    stack[-1].append(lst)\n                else:\n                    return lst\n            elif c == ',':\n                pass\n            else:\n                num = int(c)\n                if stack:\n                    stack[-1].append(num)\n                else:\n                    return [num]\n\n    def is_equal(a: list, b: list) -> bool:\n        if len(a) != len(b):\n            return False\n        for i in range(len(a)):\n            if isinstance(a[i], list) and isinstance(b[i], list):\n                if not is_equal(a[i], b[i]):\n                    return False\n            elif a[i] != b[i]:\n                return False\n        return True\n\n    A, B = stdin.split('\\n')\n    A_list = evaluate(A)\n    B_list = evaluate(B)\n\n    if is_equal(A_list, B_list):\n        return \"equal\"\n    else:\n        return \"not equal\""
    },
    {
        "number": 3120,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B = stdin.split('\\n')\n\n    def parse(expression: str) -> List[str]:\n        stack = []\n        i = 0\n        while i < len(expression):\n            if expression[i] == '[':\n                stack.append(i)\n            elif expression[i] == ']':\n                start = stack.pop()\n                if not stack:\n                    yield expression[start + 1:i]\n            i += 1\n\n    def shuffle(lst: List[int]) -> List[int]:\n        return random.sample(lst, len(lst))\n\n    def is_equal(A: str, B: str) -> bool:\n        A_lists = list(parse(A))\n        B_lists = list(parse(B))\n\n        if len(A_lists) != len(B_lists):\n            return False\n\n        for i in range(len(A_lists)):\n            A_list = list(map(int, A_lists[i].split(',')))\n            B_list = list(map(int, B_lists[i].split(',')))\n\n            if len(A_list) != len(B_list):\n                return False\n\n            A_list = shuffle(A_list)\n            B_list = shuffle(B_list)\n\n            A_list.sort()\n            B_list.sort()\n\n            if A_list != B_list:\n                return False\n\n        return True\n\n    return \"equal\" if is_equal(A, B) else \"not equal\" "
    },
    {
        "number": 3120,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, B = stdin.split('\\n')\n    \n    # Check if the two programs are equal\n    # Two programs are equivalent if for any list L of integers, both programs have an equal probability of returning L.\n    \n    return \"equal\" if A == B else \"not equal\"\n\ndef"
    },
    {
        "number": 3120,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    import random\n\n    def parse_expression(expression):\n        if expression[0] == \"[\" and expression[-1] == \"]\":\n            return [int(x) for x in expression[1:-1].split(\",\")]\n        elif expression.startswith(\"concat(\"):\n            left, right = expression[6:-1].split(\",\", 1)\n            return parse_expression(left) + parse_expression(right)\n        elif expression.startswith(\"shuffle(\"):\n            inner_expression = expression[8:-1]\n            inner_list = parse_expression(inner_expression)\n            random.shuffle(inner_list)\n            return inner_list\n        elif expression.startswith(\"sorted(\"):\n            inner_expression = expression[7:-1]\n            inner_list = parse_expression(inner_expression)\n            return sorted(inner_list)\n        else:\n            raise ValueError(\"Invalid expression\")\n\n    def is_equal_probability(program_a, program_b):\n        test_list = [1, 2, 3]\n        a_result = parse_expression(program_a)\n        b_result = parse_expression(program_b)\n        return all(a_result.count(x) == b_result.count(x) for x in set(test_list))\n\n    program_a, program_b = stdin.split(\"\\n\")\n    if is_equal_probability(program_a, program_b):\n        return \"equal\"\n    else:\n        return \"not equal\" "
    },
    {
        "number": 3121,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, H = map(int, stdin.readline().split())\n    n, m = map(int, stdin.readline().split())\n    enemies = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def dfs(area, health):\n        if area == n:\n            return health\n        if (area, health) in memo:\n            return memo[(area, health)]\n\n        for e, b, a, h in enemies:\n            if e == area:\n                new_health = health - a + h\n                if new_health >= H:\n                    memo[(area, health)] = max(memo[(area, health)], dfs(b, new_health))\n\n        return memo[(area, health)]\n\n    memo = {(i, j): 0 for i in range(1, n + 1) for j in range(1, H + 1)}\n\n    result = dfs(1, H)\n\n    if result == 0:\n        return \"Oh no\"\n    return result\n"
    },
    {
        "number": 3121,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, health, visited, graph):\n        if start == n:\n            return health\n        if (start, health) in visited:\n            return float('-inf')\n        visited.add((start, health))\n        for neighbor, enemy_attack, enemy_health in graph[start]:\n            new_health = health - enemy_attack\n            if new_health >= 1:\n                res = dfs(neighbor, new_health, visited, graph)\n                if res != float('-inf'):\n                    return res\n        return float('-inf')\n\n    A, H, n, m = map(int, stdin.split()[:4])\n    graph = {i: [] for i in range(1, n + 1)}\n    for _ in range(m):\n        e, b, a, h = map(int, stdin.split())\n        graph[e].append((b, a, h))\n\n    visited = set()\n    res = dfs(1, H, visited, graph)\n    return 'Oh no' if res == float('-inf') else str(res)"
    },
    {
        "number": 3121,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    input_list = stdin.split(\"\\n\")\n    A, H = map(int, input_list[0].split())\n    n, m = map(int, input_list[1].split())\n\n    # Create a graph to represent the cave\n    graph = {}\n    for i in range(2, m + 2):\n        e, b, a, h = map(int, input_list[i].split())\n        if e not in graph:\n            graph[e] = []\n        if b not in graph:\n            graph[b] = []\n        graph[e].append((b, a, h))\n\n    # DFS to traverse the graph\n    def dfs(node, health, visited, path):\n        if node == n:\n            return health\n        if node in visited:\n            return -1\n        visited.add(node)\n        for neighbor, enemy_attack, enemy_health in graph.get(node, []):\n            new_health = health - enemy_attack\n            if new_health >= 1:\n                path.append((node, neighbor, new_health))\n                result = dfs(neighbor, new_health, visited, path)\n                if result != -1:\n                    return result\n                path.pop()\n        visited.remove(node)\n        return -1\n\n    # Start the traversal from the first area\n    visited = set()\n    path = []\n    result = dfs(1, H, visited, path)\n\n    # If Unnar can't get through the cave, output 'Oh no'\n    if result == -1:\n        return \"Oh no\"\n\n    # Calculate the maximum health Unnar can have after getting through the cave\n    max_health = H\n    for node, neighbor, new_health in path:\n        max_health = max(max_health, new_health)\n\n    return str(max_health)"
    },
    {
        "number": 3121,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    A, H = [int(x) for x in input_list[0].split()]\n    n, m = [int(x) for x in input_list[1].split()]\n\n    enemies = []\n    for i in range(2, m + 2):\n        e, b, a, h = [int(x) for x in input_list[i].split()]\n        enemies.append((e, b, a, h))\n\n    dp = [[float('inf')] * (H + 1) for _ in range(n)]\n    dp[0][H] = 0\n\n    for i in range(1, n + 1):\n        for j in range(H + 1):\n            for e, b, a, h in enemies:\n                if e == i:\n                    for k in range(j, -1, -1):\n                        if k - a >= 0:\n                            dp[b - 1][k] = min(dp[b - 1][k], dp[e - 1][k - a] + 1)\n\n    return 'Oh no' if all(dp[n - 1][i] == float('inf') for i in range(H + 1)) else min(i for i in range(H + 1) if dp[n - 1][i] != float('inf'))"
    },
    {
        "number": 3121,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_lines = stdin.strip().split('\\n')\n    A, H = map(int, input_lines[0].split())\n    n, m = map(int, input_lines[1].split())\n    enemies = []\n    for i in range(2, m + 2):\n        e, b, a, h = map(int, input_lines[i].split())\n        enemies.append((e, b, a, h))\n\n    # Initialize DP table\n    dp = [[float('inf')] * (H + 1) for _ in range(n + 1)]\n    dp[1][H] = 0\n\n    # Calculate minimum health needed for each area\n    for i in range(n - 1, 0, -1):\n        for j in range(H, -1, -1):\n            for e, b, a, h in enemies:\n                if e == i + 1:\n                    new_health = max(j - a, 0)\n                    dp[i][j] = min(dp[i][j], max(dp[b][new_health], h - a))\n\n    # Check if it's possible to get through the cave-system\n    if dp[1][H] == float('inf'):\n        return 'Oh no'\n    else:\n        return str(dp[1][H])"
    },
    {
        "number": 3121,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    A, H = map(int, lines[0].split())\n    n, m = map(int, lines[1].split())\n    graph = [[False] * n for _ in range(n)]\n    enemies = [(int(a), int(b), int(c), int(d)) for a, b, c, d in [line.split() for line in lines[2:]]]\n\n    for i, j, _, _ in enemies:\n        i -= 1\n        j -= 1\n        graph[i][j] = True\n\n    dp = [float(\"-inf\")] * n\n    dp[0] = H\n    for i in range(n - 1):\n        for j in range(n):\n            if graph[j][i]:\n                dp[i + 1] = max(dp[i + 1], dp[i] - enemies[j][3] + A)\n\n    return \"Oh no\" if dp[-1] < 1 else dp[-1]"
    },
    {
        "number": 3121,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.splitlines()\n    A, H = map(int, lines[0].split())\n    n, m = map(int, lines[1].split())\n    passages = []\n    for i in range(2, m + 2):\n        e, b, a, h = map(int, lines[i].split())\n        passages.append((e, b, a, h))\n\n    # Create adjacency list\n    adj_list = [[] for _ in range(n + 1)]\n    for passage in passages:\n        e, b, a, h = passage\n        adj_list[e].append((b, a, h))\n\n    # DFS to find if Unnar can get to the end\n    visited = [False] * (n + 1)\n    max_health = float('-inf')\n\n    def dfs(current, health):\n        nonlocal max_health\n        if current == n:\n            max_health = max(max_health, health)\n            return True\n\n        visited[current] = True\n        for neighbor, enemy_attack, enemy_health in adj_list[current]:\n            new_health = health - enemy_attack\n            if new_health >= 1 and not visited[neighbor]:\n                if dfs(neighbor, new_health):\n                    return True\n        visited[current] = False\n        return False\n\n    dfs(1, H)\n\n    if max_health == float('-inf'):\n        return 'Oh no'\n    else:\n        return str(max_health) "
    },
    {
        "number": 3121,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.splitlines()\n    A, H = map(int, lines[0].split())\n    n, m = map(int, lines[1].split())\n    enemies = []\n    for i in range(2, m + 2):\n        ei, bi, ai, hi = map(int, lines[i].split())\n        enemies.append((ei, bi, ai, hi))\n\n    # Create graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for ei, bi, _, _ in enemies:\n        graph[ei].append(bi)\n\n    # Run DFS to find the path\n    visited = {i: False for i in range(1, n + 1)}\n    path = []\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        path.append(node)\n\n    dfs(1)\n\n    # Calculate the maximum health\n    max_health = H\n    for i in range(len(path) - 1):\n        ei = path[i]\n        bi = path[i + 1]\n        for j in range(m):\n            if enemies[j][0] == ei and enemies[j][1] == bi:\n                ai, hi = enemies[j][2:]\n                break\n        max_health = min(max_health + A - ai, H)\n        if max_health <= 0:\n            return 'Oh no'\n\n    return str(max_health)"
    },
    {
        "number": 3121,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    attack, health = map(int, lines[0].split())\n    num_areas, num_passages = map(int, lines[1].split())\n\n    enemies = []\n    for i in range(2, 2 + num_passages):\n        e, b, a, h = map(int, lines[i].split())\n        enemies.append((e, b, a, h))\n\n    dp = [float('inf')] * (num_areas + 1)\n    dp[1] = health\n\n    for i in range(1, num_areas + 1):\n        for e, b, a, h in enemies:\n            if e == i:\n                new_health = dp[e] - a\n                if new_health > 0:\n                    dp[b] = min(dp[b], new_health)\n\n    return 'Oh no' if dp[-1] == float('inf') else dp[-1]"
    },
    {
        "number": 3121,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, H, n, m = map(int, stdin.readline().split())\n    cave = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        e, b, a, h = map(int, stdin.readline().split())\n        cave[e].append((b, a, h))\n\n    def dfs(area, health):\n        if area == n:\n            return health\n        for next_area, enemy_attack, enemy_health in cave[area]:\n            new_health = health - enemy_attack\n            if new_health >= 1:\n                res = dfs(next_area, new_health)\n                if res is not None:\n                    return res\n        return None\n\n    res = dfs(1, H)\n    if res is None:\n        return \"Oh no\"\n    return str(res)"
    },
    {
        "number": 3122,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    routes = [list(map(int, line.split())) for line in lines[1:]]\n    \n    lounges_required = [0] * n\n    \n    for route in routes:\n        a, b, c = route\n        if c == 0:\n            continue\n        elif c == 1:\n            lounges_required[a] += 1\n            lounges_required[b] += 1\n        elif c == 2:\n            lounges_required[a] += 1\n            lounges_required[b] += 1\n            if a != b:\n                return \"impossible\"\n    \n    return str(sum(lounges_required))"
    },
    {
        "number": 3122,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    airports = [[] for _ in range(n)]\n\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        airports[a - 1].append((b - 1, c))\n        airports[b - 1].append((a - 1, c))\n\n    lounges_required = 0\n    visited = [False] * n\n\n    def dfs(airport, lounge_built):\n        nonlocal lounges_required\n        visited[airport] = True\n\n        for neighbor, lounge_requirement in airports[airport]:\n            if not visited[neighbor]:\n                if lounge_requirement == 1 or lounge_requirement == 2:\n                    lounges_required += lounge_built\n                dfs(neighbor, lounge_requirement == 2)\n\n    try:\n        dfs(0, False)\n        return str(lounges_required)\n    except:\n        return \"impossible\""
    },
    {
        "number": 3122,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    airport_routes = {i: set() for i in range(1, n + 1)}\n    lounges_required = {i: 0 for i in range(1, n + 1)}\n\n    for line in lines[1:]:\n        a, b, c = map(int, line.split())\n        airport_routes[a].add(b)\n        airport_routes[b].add(a)\n        lounges_required[a] += c\n        lounges_required[b] += c\n\n    total_lounges = sum(lounges_required.values())\n    for i in range(1, n + 1):\n        for j in airport_routes[i]:\n            if j in airport_routes[i]:\n                total_lounges -= 1\n\n    return str(total_lounges) if total_lounges >= 0 else 'impossible'"
    },
    {
        "number": 3122,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    routes = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        routes.append((a, b, c))\n\n    lounges = [0] * (n + 1)\n\n    for a, b, c in routes:\n        if c == 0:\n            continue\n        elif c == 1:\n            lounges[a] += 1\n            lounges[b] += 1\n        elif c == 2:\n            lounges[a] += 1\n            lounges[b] += 1\n            if a != b:\n                lounges[a] -= 1\n                lounges[b] -= 1\n                lounges[n + 1] += 1\n\n    if max(lounges) > 1 or lounges[n + 1] != 0:\n        return \"impossible\"\n    else:\n        return str(sum(lounges[:n]))"
    },
    {
        "number": 3122,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    lounges = [0] * n\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        if c == 2:\n            lounges[a - 1] += 1\n            lounges[b - 1] += 1\n        else:\n            lounges[a - 1] += 1\n            if c == 1:\n                lounges[b - 1] += 1\n    return \"impossible\" if max(lounges) > 1 else str(sum(lounges))"
    },
    {
        "number": 3122,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    req = [[0, 0, 0] for _ in range(n)]\n    for i in range(m):\n        a, b, c = map(int, lines[i + 1].split())\n        if c == 0:\n            continue\n        elif c == 1:\n            req[a-1][1] += 1\n            req[b-1][1] += 1\n        elif c == 2:\n            req[a-1][0] += 1\n            req[b-1][0] += 1\n            req[a-1][1] += 1\n            req[b-1][1] += 1\n    \n    total = sum(sum(r) for r in req)\n    if total % 2 == 1:\n        return 'impossible'\n    \n    count = total // 2\n    for r in req:\n        if r[0] > r[1]:\n            count -= r[0] - r[1]\n        elif r[1] > r[0]:\n            count -= r[1] - r[0]\n    \n    return str(count)"
    },
    {
        "number": 3122,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_lines = stdin.split(\"\\n\")\n    n, m = map(int, input_lines[0].split())\n    routes = []\n    for i in range(1, m + 1):\n        routes.append(list(map(int, input_lines[i].split())))\n\n    # Calculate total lounges needed\n    total_lounges = 0\n    airport_lounges = {}\n    for route in routes:\n        airport1, airport2, lounge_type = route\n\n        if lounge_type == 0:\n            continue\n        elif lounge_type == 1:\n            if airport1 not in airport_lounges:\n                airport_lounges[airport1] = 1\n                total_lounges += 1\n            if airport2 not in airport_lounges:\n                airport_lounges[airport2] = 1\n                total_lounges += 1\n        elif lounge_type == 2:\n            if airport1 not in airport_lounges:\n                airport_lounges[airport1] = 1\n                total_lounges += 1\n            if airport2 not in airport_lounges:\n                airport_lounges[airport2] = 1\n                total_lounges += 1\n            else:\n                return \"impossible\"\n\n    return str(total_lounges) "
    },
    {
        "number": 3122,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    airport_count = [0] * (n + 1)\n    route_count = [[0, 0] for _ in range(n + 1)]\n\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        if c == 0:\n            continue\n        elif c == 1:\n            airport_count[a] += 1\n            airport_count[b] += 1\n        elif c == 2:\n            route_count[a][0] += 1\n            route_count[a][1] += 1\n            route_count[b][0] += 1\n            route_count[b][1] += 1\n\n    total_lounges = sum(airport_count) + sum(route_count[i][0] for i in range(1, n + 1))\n\n    for i in range(1, n + 1):\n        if route_count[i][1] > 0 and airport_count[i] > 0:\n            return \"impossible\"\n\n    return str(total_lounges)"
    },
    {
        "number": 3122,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num_airports, num_routes = map(int, stdin.readline().split())\n    airport_lounge_req = {i: [] for i in range(1, num_airports + 1)}\n\n    for _ in range(num_routes):\n        a, b, c = map(int, stdin.readline().split())\n        if c == 0:\n            continue\n        elif c == 1:\n            airport_lounge_req[a].append(b)\n            airport_lounge_req[b].append(a)\n        else:\n            airport_lounge_req[a].append(b)\n            airport_lounge_req[b].append(a)\n\n    visited = set()\n    lounges_required = 0\n\n    def dfs(airport, visited):\n        visited.add(airport)\n        for connected_airport in airport_lounge_req[airport]:\n            if connected_airport not in visited:\n                dfs(connected_airport, visited)\n\n    for airport in airport_lounge_req:\n        if airport not in visited:\n            dfs(airport, visited)\n            lounges_required += 1\n\n    return str(lounges_required) if lounges_required <= num_airports else \"impossible\""
    },
    {
        "number": 3122,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    routes = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    airport_count = [0] * (n + 1)\n    for route in routes:\n        a, b, c = route\n        airport_count[a] += c\n        airport_count[b] += c\n\n    lounge_count = sum(1 for count in airport_count if count >= 2)\n    no_lounge_count = sum(1 for count in airport_count if count == 1)\n\n    if no_lounge_count == 0:\n        if lounge_count == 0:\n            return \"0\"\n        else:\n            return str(lounge_count)\n    elif lounge_count == 0:\n        return \"impossible\"\n    else:\n        return str(lounge_count + no_lounge_count) "
    },
    {
        "number": 3123,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    quote_count = 0\n    max_nesting = 0\n\n    for i in range(n):\n        quote_count += a[i]\n        if quote_count % 2 == 0:\n            max_nesting += 1\n        else:\n            return \"no quotation\"\n\n    return str(max_nesting)"
    },
    {
        "number": 3123,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    k = 1\n    for i in range(n):\n        if a[i] % k == 0:\n            k += 1\n        else:\n            break\n\n    if k == 1:\n        return \"no quotation\"\n    else:\n        return str(k - 1) "
    },
    {
        "number": 3123,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    levels = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    if n == 1:\n        if levels[0] > 1:\n            return 'no quotation'\n        else:\n            return '1'\n\n    max_level = 1\n    level = 1\n\n    for i in range(n):\n        if levels[i] == 2 * level:\n            level += 1\n            max_level = max(max_level, level)\n        elif levels[i] == level:\n            return str(max_level)\n        else:\n            return 'no quotation'\n\n    return str(max_level)"
    },
    {
        "number": 3123,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n\n    if n == 1 and a[0] == 0:\n        return \"no quotation\"\n\n    k = 1\n    while k <= n // 2:\n        q = 0\n        for i in range(k, n - k + 1):\n            if a[i] != a[i - k]:\n                break\n            q += 1\n        if q == n - 2 * k:\n            return str(k + 1)\n        k += 1\n\n    return \"no quotation\""
    },
    {
        "number": 3123,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    a_list = input_list[1:]\n\n    if n == 1:\n        if a_list[0] % 2 == 0:\n            return 'no quotation'\n        else:\n            return 1\n\n    max_level = 1\n    stack = []\n    stack.append(a_list[0])\n\n    for i in range(1, n):\n        if a_list[i] % 2 == 1:\n            stack.append(a_list[i])\n        else:\n            if len(stack) == 0:\n                return 'no quotation'\n            else:\n                stack.pop()\n                if len(stack) == 0:\n                    max_level = max(max_level, 2)\n\n    if len(stack) == 0:\n        return max_level\n    else:\n        return 'no quotation'"
    },
    {
        "number": 3123,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    \n    if n == 1:\n        return \"no quotation\"\n    \n    k = 1\n    for i in range(n):\n        if a[i] != k:\n            break\n        k += 1\n    \n    if k == 1:\n        return \"no quotation\"\n    \n    return k - 1"
    },
    {
        "number": 3123,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    quote_sequence = [int(x) for x in stdin.split(\"\\n\")[1].split()]\n\n    max_nesting_level = 1\n\n    for i in range(1, n):\n        if quote_sequence[i] == quote_sequence[i - 1] * 2:\n            max_nesting_level += 1\n        else:\n            break\n\n    if max_nesting_level == 1 and quote_sequence[0] > 1:\n        return \"no quotation\"\n\n    return str(max_nesting_level)\n"
    },
    {
        "number": 3123,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    quote_count = a[0]\n    max_nesting_level = 1\n\n    for i in range(1, n):\n        if a[i] == quote_count:\n            max_nesting_level += 1\n            quote_count = 0\n        else:\n            quote_count = a[i]\n\n        if quote_count > max_nesting_level:\n            return \"No quotation\"\n\n    return max_nesting_level"
    },
    {
        "number": 3123,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    \n    if a[0] == 0:\n        return \"no quotation\"\n    \n    max_nesting = 1\n    for i in range(1, n):\n        if a[i] == 0:\n            return str(max_nesting)\n        if a[i] > 1:\n            max_nesting += 1\n    \n    return str(max_nesting)"
    },
    {
        "number": 3123,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [int(i) for i in stdin.split('\\n')[1].split()]\n    k = 1\n    for i in a:\n        if i % 2 == 1:\n            k += 1\n        else:\n            k = 1\n    if k == 1:\n        return \"no quotation\"\n    return str(k)"
    },
    {
        "number": 3124,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, numbers = [int(x) for x in stdin.split()]\n    odd_numbers = [x for x in numbers if x % 2 != 0]\n    total_odds = sum(odd_numbers)\n    max_odd = max(odd_numbers)\n    total_evens = sum([x for x in numbers if x % 2 == 0])\n    count = 0\n    \n    for i in range(N):\n        current_number = numbers[i]\n        next_numbers = []\n        \n        if i == N - 1:\n            next_numbers = [numbers[0]]\n        else:\n            next_numbers = [numbers[i + 1]]\n        \n        total_next_odds = sum([x for x in next_numbers if x % 2 != 0])\n        total_next_evens = sum([x for x in next_numbers if x % 2 == 0])\n        \n        if total_next_odds > total_odds - max_odd or (total_next_odds == total_odds - max_odd and total_next_evens < total_evens):\n            count += 1\n    \n    return str(count)"
    },
    {
        "number": 3124,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def check_win(numbers: list, taken: list, cur_player: int) -> bool:\n        odd_count = sum([1 for num in taken if num % 2 != 0])\n        if odd_count > len(taken) // 2:\n            return cur_player == 1\n        return None\n\n    N, numbers = [int(x) for x in stdin.split('\\n')[0:2]]\n    max_games = 0\n    for start_num in range(N):\n        taken = [numbers[start_num]]\n        cur_player = 2\n        while check_win(numbers, taken, cur_player) is None:\n            valid_moves = [i for i in range(len(numbers)) if numbers[i] in [taken[len(taken)-1]-1, taken[len(taken)-1], taken[len(taken)-1]+1] and numbers[i] not in taken]\n            if not valid_moves:\n                break\n            taken.append(numbers[valid_moves[0]])\n            cur_player = 1 if cur_player == 2 else 2\n        result = check_win(numbers, taken, cur_player)\n        if result is not None:\n            max_games = max(max_games, len(taken))\n    return str(max_games)"
    },
    {
        "number": 3124,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    numbers = input_data[1:]\n\n    # Calculate the total number of odd numbers\n    total_odd_numbers = sum(1 for number in numbers if number % 2 != 0)\n\n    # Calculate the number of even numbers\n    even_numbers = len(numbers) - total_odd_numbers\n\n    # If all numbers are odd, Ivana can only choose the first number\n    if total_odd_numbers == len(numbers):\n        return 1\n\n    # If there are no odd numbers, Ivana cannot win\n    if total_odd_numbers == 0:\n        return 0\n\n    # If there are an even number of odd numbers, Ivana can choose any number\n    if even_numbers == total_odd_numbers:\n        return n\n\n    # If there are more even numbers than odd numbers, Ivana can choose any odd number\n    if even_numbers > total_odd_numbers:\n        return total_odd_numbers\n\n    # If there are more odd numbers than even numbers, Ivana can choose any even number\n    return n - total_odd_numbers"
    },
    {
        "number": 3124,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_odd(nums):\n        return sum(x % 2 != 0 for x in nums)\n\n    def find_moves(nums, visited, first_move):\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return count_odd(nums)\n        if (first_move, len(nums)) in visited:\n            return 0\n\n        visited.add((first_move, len(nums)))\n        moves = []\n        for i in range(len(nums)):\n            if i == 0:\n                new_nums = nums[1:]\n            else:\n                new_nums = nums[:i] + nums[i+1:]\n            moves.append(count_odd(new_nums) + find_moves(new_nums, visited, i))\n        return max(moves)\n\n    N = int(stdin.split('\\n')[0])\n    nums = list(map(int, stdin.split('\\n')[1].split()))\n    visited = set()\n\n    return str(find_moves(nums, visited, 0))"
    },
    {
        "number": 3124,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, nums = map(int, stdin.split())\n    total_odds = sum(1 for num in nums if num % 2 != 0)\n\n    # Case 1: All numbers are odd\n    if total_odds == n:\n        return 2\n\n    # Case 2: All numbers are even\n    if total_odds == 0:\n        return 1\n\n    # Case 3: Mixture of odd and even numbers\n    return 2\n"
    },
    {
        "number": 3124,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, numbers = int(stdin.split('\\n')[0]), sorted(map(int, stdin.split('\\n')[1].split()))\n    possible_moves = set(numbers)\n    if N % 2 == 0:\n        for i in range(1, N, 2):\n            possible_moves.discard(i)\n    else:\n        for i in range(N // 2):\n            possible_moves.discard(i)\n            possible_moves.discard(N - 1 - i)\n    return str(len(possible_moves))"
    },
    {
        "number": 3124,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    numbers = list(map(int, lines[1].split()))\n    odd_numbers = [x for x in numbers if x % 2 != 0]\n    even_numbers = [x for x in numbers if x % 2 == 0]\n\n    if len(odd_numbers) > len(even_numbers):\n        return len(even_numbers)\n    else:\n        return len(odd_numbers)\n"
    },
    {
        "number": 3124,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    numbers = list(map(int, stdin.readline().strip().split()))\n    \n    count = 0\n    for i in range(n):\n        if i == 0 or i == n - 1:\n            if numbers[i] % 2 != 0:\n                count += 1\n        else:\n            if numbers[i] % 2 != 0 and (numbers[i-1] % 2 != 0 or numbers[i+1] % 2 != 0):\n                count += 1\n                \n    return str(count)"
    },
    {
        "number": 3124,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num_numbers, numbers = map(int, stdin.split())\n    taken = set(numbers)\n    remaining = set(range(1, 1001)) - taken\n\n    count = 0\n    for number in remaining:\n        if number not in taken:\n            count += 1\n            taken.add(number)\n\n            for adjacent in (number - 1, number + 1):\n                if adjacent in taken:\n                    taken.remove(adjacent)\n\n    return str(count)"
    },
    {
        "number": 3124,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_winning(numbers: list, current_index: int, current_sum: int) -> bool:\n        if current_index == len(numbers):\n            return current_sum % 2 == 1\n\n        for i in range(1, len(numbers)):\n            if (current_index + i) % len(numbers) != 0:\n                if is_winning(numbers, (current_index + i) % len(numbers), current_sum ^ numbers[current_index]):\n                    return True\n\n        return False\n\n    N, numbers = map(int, stdin.split())\n    winning_moves = 0\n\n    for i in range(N):\n        if is_winning(numbers, i, 0):\n            winning_moves += 1\n\n    return str(winning_moves)"
    },
    {
        "number": 3125,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_string, output_string = stdin.split('\\n')\n    input_string = input_string.replace('+', \"'\").replace('-', '\"')\n    output_string = output_string.replace('+', \"'\").replace('-', '\"')\n\n    if input_string == \"\" and output_string == \"\":\n        return \"<any> <empty>\"\n\n    if len(input_string) != len(output_string):\n        return \"corrupted\"\n\n    for i in range(len(input_string)):\n        if input_string[i] != output_string[i]:\n            input_char = input_string[i]\n            output_char = output_string[i]\n            break\n\n    if input_char == '\"':\n        input_char = \"-\"\n        output_char = \"+\"\n    elif input_char == \"'\":\n        input_char = \"+\"\n        output_char = \"-\"\n    else:\n        return \"corrupted\"\n\n    return f\"{input_char} {output_char}\\n\""
    },
    {
        "number": 3125,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split('\\n')\n    input_str = input_str.replace('+', 'a+').replace('-', 'a-')\n    output_str = output_str.replace('+', 'b+').replace('-', 'b-')\n    \n    input_parts = input_str.split('a')\n    output_parts = output_str.split('b')\n    \n    if len(input_parts) != len(output_parts):\n        return 'corrupted'\n    \n    result = []\n    for i in range(len(input_parts)):\n        if input_parts[i] == output_parts[i]:\n            result.append(('<any>', '<empty>'))\n        else:\n            a_plus = 'a' + output_parts[i]\n            a_minus = input_parts[i].replace('+', '-')\n            result.append((a_plus, a_minus))\n    \n    return '\\n'.join([' '.join(r) for r in result])"
    },
    {
        "number": 3125,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split(\"\\n\")\n    input_str = input_str.replace(\"+\", \"'\").replace(\"-\", '\"')\n    output_str = output_str.replace(\"+\", \"'\").replace(\"-\", '\"')\n\n    if input_str == \"\" and output_str == \"\":\n        return \"<any> <empty>\"\n\n    input_set = set(input_str)\n    output_set = set(output_str)\n\n    encoded_chars = []\n\n    for char in input_set:\n        if char in output_set:\n            encoded_chars.append(char)\n\n    if len(encoded_chars) == 0:\n        return \"corrupted\"\n\n    encoded_chars.sort()\n\n    result = []\n\n    for char in encoded_chars:\n        encoded_char = output_str.find(char)\n        if encoded_char == -1:\n            return \"corrupted\"\n        else:\n            result.append((char, output_str[encoded_char]))\n\n    output = \"\"\n\n    for char1, char2 in result:\n        output += f\"{char1}+ {char2}-\"\n\n    return output"
    },
    {
        "number": 3125,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split('\\n')\n    \n    if not input_str and not output_str:\n        return \"corrupted\\n\"\n    \n    input_str = input_str.replace('+', 'a').replace('-', 'b')\n    output_str = output_str.replace('+', 'a').replace('-', 'b')\n    \n    if input_str.replace('a', '').replace('b', '') != output_str.replace('a', '').replace('b', ''):\n        return \"corrupted\\n\"\n    \n    possible_encodings = []\n    for i in range(len(input_str)):\n        for j in range(i, len(input_str)):\n            if input_str[i:j+1] != output_str[i:j+1] and (input_str[i:j+1].count('a') == 1 or input_str[i:j+1].count('b') == 1):\n                if input_str[i:j+1].count('a') == 1:\n                    a_plus = input_str[i:j+1].replace('a', '+')\n                    a_minus = input_str[i:j+1].replace('a', '-')\n                else:\n                    a_plus = input_str[i:j+1].replace('b', '+')\n                    a_minus = input_str[i:j+1].replace('b', '-')\n                \n                if output_str[i:j+1].count('a') == 1:\n                    a_plus = output_str[i:j+1].replace('a', '+')\n                    a_minus = output_str[i:j+1].replace('a', '-')\n                else:\n                    a_plus = output_str[i:j+1].replace('b', '+')\n                    a_minus = output_str[i:j+1].replace('b', '-')\n                \n                possible_encodings.append((a_plus, a_minus))\n    \n    if not possible_encodings:\n        return \"corrupted\\n\"\n    \n    output = \"\"\n    for pair in possible_encodings:\n        output += pair[0] + \" \" + pair[1] + \"\\n\"\n    \n    return output"
    },
    {
        "number": 3125,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split('\\n')\n    input_str = input_str.replace('+', \"'\").replace('-', '\"')\n    output_str = output_str.replace('+', \"'\").replace('-', '\"')\n\n    if input_str == \"\" and output_str == \"\":\n        return \"<empty> <empty>\"\n    elif input_str == \"\" and output_str != \"\":\n        return \"<empty> <any>\"\n    elif input_str != \"\" and output_str == \"\":\n        return \"<any> <empty>\"\n    else:\n        input_set = set(input_str)\n        output_set = set(output_str)\n\n        for input_char in input_set:\n            if input_char not in output_set:\n                return \"corrupted\"\n\n        for output_char in output_set:\n            if output_char not in input_set:\n                return \"corrupted\"\n\n        if len(input_set) == len(output_set):\n            return \"<any> <any>\"\n        else:\n            return \"<any> \" + output_str"
    },
    {
        "number": 3125,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_string, output_string = stdin.split('\\n')\n    input_length, output_length = len(input_string), len(output_string)\n\n    if input_length != output_length:\n        return \"corrupted\"\n\n    a_plus = set()\n    a_minus = set()\n\n    for i in range(input_length):\n        if input_string[i] == '+' and output_string[i] != '-':\n            a_plus.add(output_string[i])\n        elif input_string[i] == '-' and output_string[i] != '+':\n            a_minus.add(output_string[i])\n\n    if not a_plus and not a_minus:\n        return \"<any> <empty>\"\n    elif not a_plus:\n        return \"<any> \" + \"-\".join(sorted(a_minus))\n    elif not a_minus:\n        return \"+\".join(sorted(a_plus)) + \" <empty>\"\n    else:\n        return \"+\".join(sorted(a_plus)) + \" \" + \"-\".join(sorted(a_minus))"
    },
    {
        "number": 3125,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_string, output_string = stdin.split('\\n')\n    \n    if input_string == \"\" and output_string == \"\":\n        return \"<any> <empty>\"\n    \n    if len(input_string) != len(output_string):\n        return \"corrupted\"\n    \n    encoded_chars = []\n    for i in range(len(input_string)):\n        if input_string[i] == '+' and output_string[i] != '-':\n            encoded_chars.append(output_string[i])\n        elif input_string[i] == '-' and output_string[i] != '+':\n            encoded_chars.append(output_string[i])\n            \n    if len(set(encoded_chars)) == 1:\n        return f\"- {set(encoded_chars).pop()} -\"\n    elif len(set(encoded_chars)) == 0:\n        return \"<any> <empty>\"\n    else:\n        return \"corrupted\""
    },
    {
        "number": 3125,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_string, output_string = stdin.split('\\n')\n    input_string = input_string.replace('+', '-').replace('-', '+')\n\n    if input_string == output_string:\n        return \"<any> <empty>\"\n    else:\n        return \"corrupted\"\n\n    # Unreachable code\n    encoded_symbols = []\n    for i in range(len(input_string)):\n        encoded_symbols.append((input_string[i], output_string[i]))\n\n    symbols = set(encoded_symbols)\n    result = []\n\n    for symbol in symbols:\n        if symbol[0] == '+' or symbol[0] == '-':\n            if symbol[1] != '-' and symbol[1] != '+':\n                result.append((symbol[0], symbol[1]))\n\n    if not result:\n        return \"<any> <empty>\"\n    else:\n        output = []\n        for pair in result:\n            output.append(\"{} {}\".format(pair[0], pair[1]))\n        return \"\\n\".join(output) "
    },
    {
        "number": 3125,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    I, O = stdin.split('\\n')\n    I = I.replace('+', 'a').replace('-', 'b')\n    O = O.replace('+', 'a').replace('-', 'b')\n\n    if len(I) != len(O):\n        return 'corrupted'\n\n    possible_encodings = set()\n    for i in range(len(I)):\n        if I[i] != O[i]:\n            possible_encodings.add((O[i], '-' if I[i] == 'a' else '+'))\n\n    if not possible_encodings:\n        return '<empty> <any>'\n\n    output = []\n    for a_plus, a_minus in possible_encodings:\n        if a_plus == 'a':\n            output.append(('-', a_minus))\n        else:\n            output.append((a_plus, '-'))\n\n    return '\\n'.join(['{} {}'.format(a_plus, a_minus) for a_plus, a_minus in output]) "
    },
    {
        "number": 3125,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_string, output_string = stdin.split('\\n')\n    if len(input_string) != len(output_string):\n        return \"corrupted\"\n\n    apostrophe_encodings = set()\n    double_quote_encodings = set()\n\n    for i in range(len(input_string)):\n        if input_string[i] == \"'\":\n            apostrophe_encodings.add(output_string[i])\n        elif input_string[i] == '\"':\n            double_quote_encodings.add(output_string[i])\n\n    apostrophe_encoding = \"+\"\n    double_quote_encoding = \"-\"\n\n    if len(apostrophe_encodings) > 1 or len(double_quote_encodings) > 1:\n        return \"corrupted\"\n    elif len(apostrophe_encodings) == 0:\n        apostrophe_encoding = \"<empty>\"\n    else:\n        apostrophe_encoding = list(apostrophe_encodings)[0]\n\n    if len(double_quote_encodings) == 0:\n        double_quote_encoding = \"<empty>\"\n    else:\n        double_quote_encoding = list(double_quote_encodings)[0]\n\n    if apostrophe_encoding == \"<empty>\" and double_quote_encoding == \"<empty>\":\n        return \"<any>\"\n    elif apostrophe_encoding == \"<empty>\":\n        apostrophe_encoding = \"<any>\"\n    elif double_quote_encoding == \"<empty>\":\n        double_quote_encoding = \"<any>\"\n\n    return f\"{apostrophe_encoding} {double_quote_encoding}\\n\""
    },
    {
        "number": 3126,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_jumps(positions, tower_pos):\n        jumps = [0] * len(positions)\n        for i in range(len(positions)):\n            jumps[i] = abs(positions[i] - tower_pos)\n            for j in range(i):\n                if positions[j] < positions[i] < tower_pos or positions[i] < positions[j] < tower_pos:\n                    jumps[i] = max(jumps[i], abs(positions[j] - tower_pos) + j + 1)\n        return sum(jumps)\n\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.strip().split('\\n')\n        n, tower_pos = map(int, lines[0].split())\n        positions = list(map(int, lines[1].split()))\n        C = int(lines[2])\n        modifications = lines[3:]\n        return n, tower_pos, positions, C, modifications\n\n    n, tower_pos, positions, C, modifications = parse_input(stdin)\n    jumps = count_jumps(positions, tower_pos)\n    result = [str(jumps)]\n\n    for modification in modifications:\n        action, value = modification.split()\n        if action == '+':\n            positions.append(int(value))\n        elif action == '-':\n            positions.remove(int(value))\n        elif action == 't':\n            tower_pos = int(value)\n        jumps = count_jumps(positions, tower_pos)\n        result.append(str(jumps))\n\n    return '\\n'.join(result) + '\\n'"
    },
    {
        "number": 3126,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def frog_dance(n: int, tower_pos: int, frogs: List[int]) -> int:\n        frogs.sort()\n        jumps = 0\n        for i in range(n):\n            jumps += (i + 1) * (frogs[i] - tower_pos)\n        return jumps\n\n    def find_frog(frogs: List[int], pos: int) -> int:\n        left, right = 0, len(frogs) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if frogs[mid] == pos:\n                return mid\n            elif frogs[mid] < pos:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    lines = stdin.splitlines()\n    n, tower_pos = map(int, lines[0].split())\n    frogs = list(map(int, lines[1].split()))\n    C = int(lines[2])\n    changes = lines[3:]\n\n    res = []\n    for change in changes:\n        action, val = change.split()\n        val = int(val)\n\n        if action == '+':\n            frogs.append(val)\n            jumps = frog_dance(n, tower_pos, frogs)\n            res.append(jumps)\n            n += 1\n        elif action == '-':\n            idx = find_frog(frogs, val)\n            if idx != -1:\n                frogs.pop(idx)\n                jumps = frog_dance(n, tower_pos, frogs)\n                res.append(jumps)\n                n -= 1\n            else:\n                res.append(frog_dance(n, tower_pos, frogs))\n        else:\n            tower_pos = val\n            jumps = frog_dance(n, tower_pos, frogs)\n            res.append(jumps)\n\n    return '\\n'.join(map(str, res))"
    },
    {
        "number": 3126,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_jumps(n, positions):\n        jumps = [0] * n\n        for i in range(n):\n            jumps[i] = positions[i] + i\n        return jumps\n\n    def min_jumps(jumps):\n        jumps.sort()\n        min_jumps = 0\n        for i in range(len(jumps)):\n            min_jumps += jumps[i] - i\n        return min_jumps\n\n    input_lines = stdin.strip().split('\\n')\n    initial_params = list(map(int, input_lines[0].split()))\n    n, t = initial_params\n    positions = list(map(int, input_lines[1].split()))\n    jumps = calculate_jumps(n, positions)\n    min_total_jumps = min_jumps(jumps)\n    result = [str(min_total_jumps)]\n\n    for i in range(2, len(input_lines)):\n        change = input_lines[i].strip().split()\n        if change[0] == '+':\n            a = int(change[1])\n            jumps.append(a)\n            n += 1\n        elif change[0] == '-':\n            a = int(change[1])\n            jumps.remove(a)\n            n -= 1\n        else:\n            a = int(change[1])\n            jumps = [j - a for j in jumps]\n        min_total_jumps = min_jumps(jumps)\n        result.append(str(min_total_jumps))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3126,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dance(frogs, final_pos):\n        total_jumps = 0\n        for i, frog in enumerate(frogs):\n            total_jumps += abs(frog - final_pos)\n        return total_jumps\n\n    n, final_pos = map(int, stdin.readline().strip().split())\n    frogs = list(map(int, stdin.readline().strip().split()))\n    c = int(stdin.readline().strip())\n\n    results = []\n    for _ in range(c):\n        command, value = stdin.readline().strip().split()\n        if command == '+':\n            frogs.append(int(value))\n        elif command == '-':\n            frogs.remove(int(value))\n        else:\n            final_pos = int(value)\n        results.append(dance(frogs, final_pos))\n\n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 3126,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def frog_dance(n, t, frogs, changes):\n        dp = [[0] * 1000001 for _ in range(n + 1)]\n\n        for i in range(n):\n            dp[i + 1][frogs[i] + i] = i + 1\n\n        for c in changes:\n            if c[0] == \"+\":\n                frogs.append(c[1])\n                frogs.sort()\n            elif c[0] == \"-\":\n                frogs.remove(c[1])\n            else:\n                t = c[1]\n\n        result = float(\"inf\")\n        for i in range(n):\n            jumps = dp[i + 1][t - i]\n            if jumps != 0:\n                result = min(result, jumps)\n\n        return result\n\n    def process_input(stdin: str) -> tuple:\n        lines = stdin.split(\"\\n\")\n        n, t = map(int, lines[0].split())\n        frogs = list(map(int, lines[1].split()))\n        changes = []\n        for i in range(2, len(lines), 1):\n            change = lines[i].split()\n            if change[0] == \"+\":\n                changes.append((\"+\", int(change[1])))\n            elif change[0] == \"-\":\n                changes.append((\"-\", int(change[1])))\n            else:\n                changes.append((\"t\", int(change[1])))\n\n        return n, t, frogs, changes\n\n    n, t, frogs, changes = process_input(stdin)\n    result = frog_dance(n, t, frogs, changes)\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3126,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_jumps(frogs):\n        return sum([(2 * i - 1) for i in range(1, len(frogs) + 1)])\n\n    def find_frog_index(frogs, position):\n        for i, frog in enumerate(frogs):\n            if frog == position:\n                return i\n        return None\n\n    input_data = stdin.split(\"\\n\")\n    initial_frogs_count, initial_tower_position = map(int, input_data[0].split())\n    frogs = list(map(int, input_data[1].split()))\n    changes_count = int(input_data[2])\n    changes = input_data[3:]\n\n    current_jumps = calculate_jumps(frogs)\n    result = [current_jumps]\n\n    for change in changes:\n        command, value = change.split()\n        if command == \"+\":\n            frogs.append(int(value))\n            frogs.sort()\n        elif command == \"-\":\n            index = find_frog_index(frogs, int(value))\n            frogs.pop(index)\n        elif command == \"t\":\n            initial_tower_position = int(value)\n        else:\n            raise ValueError(\"Invalid command\")\n\n        current_jumps = calculate_jumps(frogs)\n        result.append(current_jumps)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3126,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def frog_dance(frogs: list, tower_pos: int) -> int:\n        frogs.sort()\n        total_jumps = 0\n        for i, frog in enumerate(frogs):\n            jumps = i + 1\n            total_jumps += jumps\n            if frog + jumps > tower_pos:\n                return total_jumps\n        return total_jumps\n\n    input_list = list(map(str.strip, stdin.split('\\n')))\n    n, tower_pos = map(int, input_list[0].split())\n    frogs = list(map(int, input_list[1].split()))\n    changes = int(input_list[2])\n\n    result = []\n    for i in range(3, changes + 3):\n        change_type, *change_value = input_list[i].split()\n        change_value = int(change_value[0])\n\n        if change_type == '+':\n            frogs.append(change_value)\n        elif change_type == '-':\n            frogs.remove(change_value)\n        elif change_type == 't':\n            tower_pos = change_value\n        result.append(frog_dance(frogs, tower_pos))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3126,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def min_jumps(n: int, t: int) -> int:\n        return n * (n + 1) // 2 - (t + 1)\n\n    input_list = stdin.split('\\n')\n    n, t = map(int, input_list[0].split())\n    p = list(map(int, input_list[1].split()))\n    c = int(input_list[2])\n    modifications = input_list[3:]\n\n    result = []\n    for modification in modifications:\n        if modification[0] == '+':\n            p.append(int(modification[2:]))\n        elif modification[0] == '-':\n            p.remove(int(modification[2:]))\n        else:\n            t = int(modification[2:])\n        result.append(min_jumps(len(p), t))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3126,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def min_jumps(n: int, t: int) -> int:\n        return n * (n + 1) // 2 - (t + 1) * (t + 2) // 2\n\n    def process_input(stdin: str) -> tuple:\n        n, t = map(int, stdin.split()[0:2])\n        p = list(map(int, stdin.split()[2:2 + n]))\n        C = int(stdin.split()[2 + n])\n        modifications = []\n        for i in range(2 + n, 2 + n + C):\n            line = stdin.split()[i]\n            if line[0] == \"+\":\n                modifications.append((\"+\", int(line[1:])))\n            elif line[0] == \"-\":\n                modifications.append((\"-\", int(line[1:])))\n            else:\n                modifications.append((\"t\", int(line[1:])))\n        return n, t, p, modifications\n\n    n, t, p, modifications = process_input(stdin)\n\n    for modification in modifications:\n        if modification[0] == \"+\":\n            p.append(modification[1])\n        elif modification[0] == \"-\":\n            p.remove(modification[1])\n        else:\n            t = modification[1]\n        print(min_jumps(len(p), t)) "
    },
    {
        "number": 3126,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def min_jumps(frogs: list, tower: int) -> int:\n        n = len(frogs)\n        jumps = 0\n        for i in range(1, n):\n            distance = abs(frogs[i] - frogs[i - 1])\n            jumps += distance\n        return jumps\n\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        n, tower = map(int, lines[0].split())\n        frogs = list(map(int, lines[1].split()))\n        return n, frogs, tower\n\n    def process_modifications(frogs: list, tower: int, modifications: list) -> list:\n        result = []\n        for modification in modifications:\n            if modification[0] == '+':\n                frogs.append(int(modification[1:]))\n            elif modification[0] == '-':\n                frogs.remove(int(modification[1:]))\n            elif modification[0] == 't':\n                tower = int(modification[1:])\n            result.append(min_jumps(sorted(frogs) + [tower], tower))\n        return result\n\n    n, frogs, tower = read_input(stdin)\n    modifications = [input() for _ in range(int(input()))]\n    return '\\n'.join(map(str, process_modifications(frogs, tower, modifications)))"
    },
    {
        "number": 3127,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n + 1)]\n    visited = [False] * (n + 1)\n    path_length = [float('inf')] * (n + 1)\n    path_length[1] = 0\n\n    for _ in range(m):\n        a, b, l = map(int, stdin.readline().split())\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    dfs(1)\n\n    unused_switches = [i for i in range(2, n + 1) if not visited[i]]\n    k = len(unused_switches)\n\n    return f\"{k}\\n{' '.join(map(str, unused_switches))}\"\n"
    },
    {
        "number": 3127,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n + 1)]\n    visited = [False] * (n + 1)\n    length = [float('inf')] * (n + 1)\n\n    for _ in range(m):\n        a, b, l = map(int, stdin.readline().split())\n        adj_list[a].append((b, l))\n        adj_list[b].append((a, l))\n\n    def dijkstra(start):\n        length[start] = 0\n        for _ in range(n - 1):\n            min_dist = float('inf')\n            min_vertex = None\n            for i in range(1, n + 1):\n                if not visited[i] and length[i] < min_dist:\n                    min_dist = length[i]\n                    min_vertex = i\n            if min_vertex is None:\n                break\n            visited[min_vertex] = True\n            for neighbor, dist in adj_list[min_vertex]:\n                length[neighbor] = min(length[neighbor], length[min_vertex] + dist)\n\n    dijkstra(1)\n\n    unused_switches = [i for i in range(1, n + 1) if not visited[i]]\n    k = len(unused_switches)\n\n    output = [str(k)]\n    output.append(' '.join(map(str, unused_switches)))\n    return '\\n'.join(output)"
    },
    {
        "number": 3127,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    switches = set()\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, _ = map(int, stdin.readline().split())\n        switches.add(a)\n        switches.add(b)\n        adj[a].append(b)\n        adj[b].append(a)\n\n    unused_switches = []\n    for i in range(1, n + 1):\n        if i not in switches:\n            unused_switches.append(i)\n\n    return f\"{len(unused_switches)}\\n{' '.join(map(str, unused_switches))}\""
    },
    {
        "number": 3127,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj_matrix = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        adj_matrix[i][i] = 0\n    for _ in range(m):\n        a, b, l = map(int, stdin.readline().split())\n        adj_matrix[a - 1][b - 1] = l\n        adj_matrix[b - 1][a - 1] = l\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if adj_matrix[i][k] != float('inf') and adj_matrix[k][j] != float('inf'):\n                    adj_matrix[i][j] = min(adj_matrix[i][j], adj_matrix[i][k] + adj_matrix[k][j])\n    unused_switches = [i for i in range(1, n + 1) if adj_matrix[0][i] == float('inf')]\n    k = len(unused_switches)\n    return f\"{k}\\n{' '.join(map(str, unused_switches))}\""
    },
    {
        "number": 3127,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n\n    for _ in range(m):\n        a, b, l = map(int, stdin.readline().split())\n        adj[a].append((b, l))\n        adj[b].append((a, l))\n\n    used_switches = [False for _ in range(n + 1)]\n    used_switches[1] = True\n\n    queue = [1]\n    while queue:\n        node = queue.pop(0)\n        for neighbor, _ in adj[node]:\n            if not used_switches[neighbor]:\n                used_switches[neighbor] = True\n                queue.append(neighbor)\n\n    unused_switches = [i for i in range(2, n + 1) if not used_switches[i]]\n    k = len(unused_switches)\n\n    return f\"{k}\\n{' '.join(map(str, unused_switches))}\""
    },
    {
        "number": 3127,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def build_graph(n, m, edges):\n        graph = [[] for _ in range(n + 1)]\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n        return graph\n\n    def find_unused_switches(graph, n):\n        visited = set()\n        unused = set()\n        stack = [(1, 0)]\n\n        while stack:\n            node, depth = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                min_depth = depth\n\n                for neighbor, weight in graph[node]:\n                    if neighbor not in visited:\n                        stack.append((neighbor, depth + weight))\n                        min_depth = min(min_depth, depth + weight)\n\n                if node != 1 and min_depth > 0:\n                    unused.add(node)\n\n        return unused\n\n    n, m = map(int, stdin.readline().split())\n    edges = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    graph = build_graph(n, m, edges)\n    unused = find_unused_switches(graph, n)\n\n    return f\"{len(unused)}\\n{' '.join(map(str, sorted(unused)))}\""
    },
    {
        "number": 3127,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, node, start, end):\n        if node == end:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                if dfs(graph, visited, neighbor, start, end):\n                    return True\n        return False\n\n    def build_graph(n, connections):\n        graph = {i: set() for i in range(1, n + 1)}\n        for a, b, _ in connections:\n            graph[a].add(b)\n            graph[b].add(a)\n        return graph\n\n    n, m = map(int, stdin.readline().strip().split())\n    connections = [list(map(int, stdin.readline().strip().split())) for _ in range(m)]\n\n    graph = build_graph(n, connections)\n    visited = set()\n    dfs(graph, visited, 1, 1, n)\n\n    unused_switches = [i for i in range(1, n + 1) if i not in visited]\n    k = len(unused_switches)\n\n    return f\"{k}\\n{' '.join(map(str, unused_switches))}\""
    },
    {
        "number": 3127,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n + 1)]\n    switches = set(range(1, n + 1))\n    unused_switches = set()\n\n    for _ in range(m):\n        a, b, _ = map(int, stdin.readline().split())\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    def dfs(current, visited):\n        if current not in visited:\n            visited.add(current)\n            for neighbor in adj_list[current]:\n                dfs(neighbor, visited)\n\n    dfs(1, visited=set())\n\n    for switch in switches:\n        if switch not in visited:\n            unused_switches.add(switch)\n\n    k = len(unused_switches)\n    output = [str(k)]\n\n    if k > 0:\n        output.append(' '.join(map(str, sorted(unused_switches))))\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3127,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_redundant(node, visited, switches, adjacency):\n        if node not in visited:\n            visited.add(node)\n            for neighbor in adjacency[node]:\n                if neighbor not in visited:\n                    is_redundant(neighbor, visited, switches, adjacency)\n                    switches.add(node)\n\n    input_data = list(map(int, stdin.split()))\n    n, m = input_data[0], input_data[1]\n    input_data = input_data[2:]\n    adjacency = {i: set() for i in range(1, n + 1)}\n\n    for i in range(m):\n        a, b, _ = input_data[3 * i:3 * (i + 1)]\n        adjacency[a].add(b)\n        adjacency[b].add(a)\n\n    visited = set()\n    switches = set()\n    is_redundant(1, visited, switches, adjacency)\n\n    k = len(switches)\n    output = [str(k)]\n    output.extend(sorted(switches))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3127,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, l = map(int, stdin.readline().split())\n        adj_list[a].append((b, l))\n        adj_list[b].append((a, l))\n\n    def dfs(v: int, visited: set, distance: list):\n        visited.add(v)\n        for u, l in adj_list[v]:\n            if u not in visited:\n                distance[u] = distance[v] + l\n                dfs(u, visited, distance)\n\n    distance = [0] * (n + 1)\n    dfs(1, set(), distance)\n\n    unused_switches = [i for i in range(2, n + 1) if distance[i] == 0]\n    k = len(unused_switches)\n\n    return f\"{k}\\n{' '.join(map(str, unused_switches))}\"\n"
    },
    {
        "number": 3128,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = 0\n    plot_order = []\n    creation_order = []\n    for line in stdin.split('\\n'):\n        query, value = map(int, line.split())\n        if query == 1:\n            n += 1\n            plot_order.insert(value - 1, n)\n            creation_order.append(n)\n        else:\n            yield creation_order[plot_order.index(value)]"
    },
    {
        "number": 3128,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    plot_order = []\n    creation_order = []\n    num_queries = int(stdin.readline())\n    for i in range(num_queries):\n        query = stdin.readline().split()\n        if query[0] == \"1\":\n            plot_order.append(int(query[1]))\n        else:\n            creation_order.append(int(query[1]))\n    \n    plot_order.sort()\n    for i in range(len(plot_order)):\n        if plot_order[i] == i + 1:\n            creation_order.append(i + 1)\n    \n    return \"\\n\".join(str(creation_order[i - 1]) for i in creation_order)"
    },
    {
        "number": 3128,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def insert(arr, x):\n        for i in range(len(arr)):\n            if arr[i] > x:\n                arr.insert(i, x)\n                break\n        else:\n            arr.append(x)\n\n    def find_index(arr, x):\n        for i in range(len(arr)):\n            if arr[i] == x:\n                return i + 1\n        return -1\n\n    lines = stdin.split(\"\\n\")\n    Q = int(lines[0])\n    plot_order = []\n    creation_order = []\n\n    for i in range(1, Q + 1):\n        q, x = map(int, lines[i].split())\n        if q == 1:\n            insert(plot_order, x)\n        elif q == 2:\n            if x <= len(plot_order):\n                creation_index = find_index(creation_order, plot_order[x - 1])\n                if creation_index != -1:\n                    print(creation_index)\n                else:\n                    print(\"Invalid query\")\n            else:\n                print(\"Invalid query\")"
    },
    {
        "number": 3128,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(str.strip, stdin.split('\\n')))\n    num_queries = int(input_list[0])\n    plot_order = []\n    creation_order = []\n    for i in range(1, num_queries + 1):\n        query = input_list[i]\n        q, x = query.split()\n        x = int(x)\n        if q == '1':\n            plot_order.insert(x - 1, len(creation_order) + 1)\n            creation_order.append(len(creation_order) + 1)\n        elif q == '2':\n            result = creation_order[plot_order.index(x)]\n            print(result)\n    return \"\""
    },
    {
        "number": 3128,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    queries = [line.split() for line in stdin.split(\"\\n\")[1:]]\n\n    creation_order = []\n    plot_order = []\n\n    for q, x in queries:\n        x = int(x)\n        if q == \"1\":\n            creation_order.append(x)\n            plot_order.append(len(creation_order))\n        elif q == \"2\":\n            print(creation_order[plot_order.index(x)])\n\n    return \"\""
    },
    {
        "number": 3128,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = 0\n    plot_order = {}\n    creation_order = {}\n    result = []\n\n    for line in stdin.split('\\n')[1:]:\n        query, x = map(int, line.split())\n\n        if query == 1:\n            n += 1\n            plot_order[x] = n\n            creation_order[n] = x\n        elif query == 2:\n            result.append(str(creation_order[x]))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3128,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def process_query(query: str) -> str:\n        q, x = map(int, query.split())\n        if q == 1:\n            movies.append(x)\n            return \"\"\n        else:\n            return str(movies.index(x) + 1)\n\n    def main():\n        queries = stdin.split(\"\\n\")[1:]\n        for query in queries:\n            output.append(process_query(query))\n\n    movies = []\n    output = []\n    main()\n    return \"\\n\".join(output)"
    },
    {
        "number": 3128,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def process_query(q, x):\n        if q == 1:\n            plot_order.append(x)\n        else:\n            return creation_order[plot_order.index(x)]\n\n    plot_order = []\n    creation_order = []\n    output = []\n\n    for line in stdin.split('\\n'):\n        q, x = map(int, line.split())\n        output.append(process_query(q, x))\n\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3128,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    q, queries = int(stdin.split('\\n', 1)[0]), stdin.split('\\n')[1:]\n    plot_order = []\n    creation_order = []\n    for query in queries:\n        q, x = query.split()\n        x = int(x)\n        if q == '1':\n            creation_order.append(x)\n            plot_order.insert(x - 1, len(creation_order))\n        else:\n            yield creation_order[plot_order.index(x)]\n\ndef"
    },
    {
        "number": 3128,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def create_movie(x, plot_order, creation_order):\n        for i in range(x):\n            if plot_order[i] is None:\n                plot_order[i] = len(creation_order) + 1\n                creation_order.append(plot_order[i])\n                break\n\n    def find_movie(x, plot_order, creation_order):\n        for i in range(len(plot_order)):\n            if plot_order[i] == x:\n                return i + 1\n\n    query = [x.split() for x in stdin.strip().split('\\n')[1:]]\n    n = int(stdin.strip().split('\\n')[0])\n    plot_order = [None] * n\n    creation_order = []\n    for q in query:\n        if q[0] == '1':\n            create_movie(int(q[1]), plot_order, creation_order)\n        else:\n            print(find_movie(int(q[1]), plot_order, creation_order))"
    },
    {
        "number": 3129,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    steps = 0\n\n    for i in range(n - 2):\n        if s[i] == 'C' and s[i + 1] == 'P' and s[i + 2] == 'C':\n            steps += 1\n            s = s[:i + 1] + 'C' + s[i + 1] + 'P' + s[i + 3:]\n        elif s[i] == 'C' and s[i + 1] == 'P' and s[i + 2] == 'P':\n            steps += 1\n            s = s[:i + 1] + 'P' + s[i + 1:i + 2] + 'C' + s[i + 3:]\n        elif s[i] == 'P' and s[i + 1] == 'C' and s[i + 2] == 'C':\n            steps += 1\n            s = s[:i] + 'C' + s[i + 1:i + 2] + 'P' + s[i + 3:]\n        elif s[i] == 'P' and s[i + 1] == 'C' and s[i + 2] == 'P':\n            steps += 1\n            s = s[:i + 1] + 'P' + s[i + 1] + 'C' + s[i + 3:]\n        elif s[i] == 'P' and s[i + 1] == 'P' and s[i + 2] == 'C':\n            steps += 1\n            s = s[:i] + 'P' + s[i + 1:i + 2] + 'P' + s[i + 3:]\n\n    return str(steps)"
    },
    {
        "number": 3129,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    infected_bales = [i for i, bale in enumerate(stdin) if bale == 'P']\n    operations = 0\n\n    for i in range(n - 2):\n        if i in infected_bales:\n            if i + 1 in infected_bales or i + 2 in infected_bales:\n                infected_bales.remove(i)\n                infected_bales.append(n - 1 - operations)\n                operations += 1\n\n    return str(operations)"
    },
    {
        "number": 3129,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    total_operations = 0\n\n    for i in range(n - 2):\n        if s[i] == 'P' and s[i + 1] == 'P' and s[i + 2] == 'P':\n            total_operations += 1\n            s = s[:i] + ''.join(sorted(s[i:i + 3])) + s[i + 3:]\n        else:\n            s = s[:i] + ''.join(sorted(s[i:i + 3])) + s[i + 3:]\n            total_operations += 1\n\n    return str(total_operations)"
    },
    {
        "number": 3129,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    infected_haybales = [i for i, bale in enumerate(s) if bale == 'P']\n    n_steps = 0\n    n_infected = len(infected_haybales)\n\n    for i in range(len(s) - n_infected):\n        if s[i:i+3].count('P') > 1:\n            n_steps += 1\n\n    return str(n_steps + n_infected - 1)"
    },
    {
        "number": 3129,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count = 0\n    for i in range(0, n - 2):\n        if s[i] == 'P' and s[i + 1] == 'P' and s[i + 2] == 'P':\n            count += 1\n    return count"
    },
    {
        "number": 3129,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    clean = 0\n    infected = 0\n    for i in stdin:\n        if i == 'C':\n            clean += 1\n        else:\n            infected += 1\n    if clean == 0:\n        return str(infected - 1)\n    if infected == 0:\n        return \"0\"\n    return str(min(clean, infected)) "
    },
    {
        "number": 3129,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    clean = stdin.count('C')\n    parasite = stdin.count('P')\n    total = len(stdin)\n    \n    if parasite == 0:\n        return 0\n    \n    # Calculate the number of operations required to move all parasites to the back\n    operations = (total - parasite) // 2\n    \n    # Calculate the number of operations required to sort the clean hay bales\n    operations += clean - 1\n    \n    return str(operations)"
    },
    {
        "number": 3129,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    hay_bales = stdin\n    n = len(hay_bales)\n    moves = 0\n    for i in range(n - 2):\n        if hay_bales[i:i+3] == \"PPP\":\n            moves += 1\n            hay_bales = hay_bales[:i] + hay_bales[i+3:] + \"PPP\"\n        elif hay_bales[i:i+3] == \"CPP\" or hay_bales[i:i+3] == \"CCP\":\n            moves += 1\n            hay_bales = hay_bales[:i] + hay_bales[i+1:] + hay_bales[i]\n        elif hay_bales[i:i+3] == \"CCC\":\n            hay_bales = hay_bales[:i] + hay_bales[i+1:] + hay_bales[i]\n            if hay_bales[i:i+3] == \"CCC\":\n                moves += 1\n    return str(moves)"
    },
    {
        "number": 3129,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    clean_count = stdin.count('C')\n    parasite_count = len(stdin) - clean_count\n    return str(parasite_count)"
    },
    {
        "number": 3129,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    if n <= 3:\n        return 0\n    infected_bales = [i for i in range(n) if s[i] == 'P']\n    if not infected_bales:\n        return 0\n    infected_bales_set = set(infected_bales)\n    moves = 0\n    for i in range(n):\n        if i in infected_bales_set:\n            if i - 2 in infected_bales_set:\n                if i - 1 in infected_bales_set:\n                    moves += 1\n                else:\n                    moves += 2\n            elif i - 1 in infected_bales_set:\n                moves += 1\n        else:\n            if i - 2 in infected_bales_set:\n                moves += 1\n            elif i - 1 in infected_bales_set:\n                if i - 1 in infected_bales_set:\n                    moves += 1\n                else:\n                    moves += 2\n    return moves"
    },
    {
        "number": 3130,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    D, M, N = map(int, stdin.readline().split())\n    implications = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n    events = [int(stdin.readline()) for _ in range(N)]\n\n    # Create implication graph\n    implication_graph = {i: [] for i in range(1, D + 1)}\n    for a, b in implications:\n        implication_graph[a].append(b)\n\n    # Calculate events that have certainly occurred\n    certain_events = set(events)\n    new_certain_events = set()\n    while certain_events != new_certain_events:\n        for a in certain_events:\n            for b in implication_graph[a]:\n                new_certain_events.add(b)\n        certain_events = new_certain_events\n\n    # Sort and format output\n    output = \" \".join(map(str, sorted(list(certain_events))))\n    return output"
    },
    {
        "number": 3130,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_data = list(map(int, stdin.split()))\n    D, M, N = input_data[0], input_data[1], input_data[2]\n    implications = []\n    for i in range(M):\n        implications.append(input_data[3 + i*2:5 + i*2])\n    evidence = input_data[-N:]\n\n    # Create adjacency matrix\n    adj_matrix = [[0] * D for _ in range(D)]\n    for implication in implications:\n        source, target = implication[0] - 1, implication[1] - 1\n        adj_matrix[source][target] = 1\n\n    # Transitive closure\n    for k in range(D):\n        for i in range(D):\n            for j in range(D):\n                adj_matrix[i][j] = max(adj_matrix[i][j], adj_matrix[i][k] + adj_matrix[k][j])\n\n    # Find events that have certainly occurred\n    events_that_have_certainly_occurred = set()\n    for event in evidence:\n        source = event - 1\n        target_events = [i for i in range(D) if adj_matrix[source][i] == 1]\n        for target_event in target_events:\n            events_that_have_certainly_occurred.add(target_event + 1)\n\n    return \" \".join(map(str, sorted(list(events_that_have_certainly_occurred))))"
    },
    {
        "number": 3130,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.split()[:3])\n    graph = {i: [] for i in range(1, D + 1)}\n    events = set()\n\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        graph[A].append(B)\n\n    for _ in range(N):\n        X = int(stdin.split())\n        events.add(X)\n\n    def dfs(node, visited):\n        if node in visited:\n            return\n        visited.add(node)\n        for child in graph[node]:\n            dfs(child, visited)\n\n    result = set()\n    for event in events:\n        visited = set()\n        dfs(event, visited)\n        for node in visited:\n            result.add(node)\n\n    return \" \".join(map(str, sorted(list(result))))"
    },
    {
        "number": 3130,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        input_data = list(map(int, stdin.split()))\n        D, M, N = input_data[0], input_data[1], input_data[2]\n        implications = []\n        for i in range(M):\n            A, B = input_data[3 + i * 2], input_data[3 + i * 2 + 1]\n            implications.append((A, B))\n        evidences = []\n        for i in range(N):\n            X = input_data[-N + i]\n            evidences.append(X)\n        return D, M, N, implications, evidences\n\n    def find_causes(D, implications, event):\n        causes = set()\n        for implication in implications:\n            if implication[1] == event:\n                causes.add(implication[0])\n        return causes\n\n    def deduce_events(D, implications, evidences):\n        events = set(evidences)\n        new_events = True\n        while new_events:\n            new_events = set()\n            for event in events:\n                causes = find_causes(D, implications, event)\n                for cause in causes:\n                    if cause not in events:\n                        new_events.add(cause)\n            events.update(new_events)\n        return sorted(events)\n\n    D, M, N, implications, evidences = read_input()\n    events = deduce_events(D, implications, evidences)\n    return ' '.join(map(str, events))"
    },
    {
        "number": 3130,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    D, M, N = map(int, stdin.readline().split())\n    implications = []\n    for _ in range(M):\n        A, B = map(int, stdin.readline().split())\n        implications.append((A, B))\n    events = [int(stdin.readline()) for _ in range(N)]\n\n    # Build graph\n    graph = {i: [] for i in range(1, D + 1)}\n    for A, B in implications:\n        graph[A].append(B)\n\n    # Perform depth-first search\n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor)\n\n    certain_events = set()\n    for event in events:\n        visited = set()\n        dfs(event)\n        certain_events |= visited\n\n    return \" \".join(map(str, sorted(certain_events)))"
    },
    {
        "number": 3130,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.readline().split())\n    graph = [[] for _ in range(D + 1)]\n    events = [False] * (D + 1)\n\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n\n    for _ in range(N):\n        x = int(stdin.readline())\n        events[x] = True\n\n    def dfs(v):\n        for u in graph[v]:\n            if not events[u]:\n                events[u] = True\n                dfs(u)\n\n    for i in range(1, D + 1):\n        if events[i]:\n            dfs(i)\n\n    return \" \".join(map(str, [i for i in range(1, D + 1) if events[i]]))\n"
    },
    {
        "number": 3130,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.split()[:3])\n    events = [set() for _ in range(D + 1)]\n    causal_implications = []\n    evidence = set()\n\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        causal_implications.append((A, B))\n\n    for _ in range(N):\n        X = int(stdin.split())\n        evidence.add(X)\n\n    for A, B in causal_implications:\n        events[A].add(B)\n\n    changed = True\n    while changed:\n        changed = False\n        for A in range(1, D + 1):\n            for B in events[A]:\n                if evidence.issuperset(events[B]):\n                    evidence.add(A)\n                    changed = True\n                    break\n\n    return \" \".join(map(str, sorted(evidence)))"
    },
    {
        "number": 3130,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    D, M, N = map(int, stdin.readline().split())\n    implications = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n    evidence = [int(stdin.readline()) for _ in range(N)]\n\n    # Create a dictionary to store all implications\n    implication_dict = {i: set() for i in range(1, D + 1)}\n    for implication in implications:\n        cause, effect = implication\n        implication_dict[cause].add(effect)\n\n    # Use DFS to find all events that have certainly occurred\n    def dfs(event):\n        if visited[event]:\n            return\n        visited[event] = True\n        for child in implication_dict[event]:\n            dfs(child)\n\n    result = set()\n    for event in evidence:\n        visited = [False] * (D + 1)\n        dfs(event)\n        for i in range(1, D + 1):\n            if visited[i]:\n                result.add(i)\n\n    # Return the result\n    return \" \".join(map(str, sorted(list(result))))"
    },
    {
        "number": 3130,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.split('\\n')[0].split())\n    implications = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:1 + M]]\n    evidence = set(map(int, stdin.split('\\n')[-N:]))\n\n    causal_implications = [set() for _ in range(D)]\n    for a, b in implications:\n        causal_implications[b - 1].add(a)\n\n    result = set()\n    for e in evidence:\n        result.add(e)\n        for c in causal_implications[e - 1]:\n            result.add(c)\n\n    return ' '.join(map(str, sorted(list(result))))"
    },
    {
        "number": 3130,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    D, M, N = map(int, stdin.readline().split())\n    implications = [list(map(int, stdin.readline().split())) for _ in range(M)]\n    known_events = [int(stdin.readline()) for _ in range(N)]\n\n    # Build a dictionary to store implications\n    event_dict = {i: set() for i in range(1, D + 1)}\n    for a, b in implications:\n        event_dict[a].add(b)\n\n    # Use DFS to find all events that have certainly occurred\n    def dfs(event):\n        result.add(event)\n        for child in event_dict[event]:\n            if child not in result:\n                dfs(child)\n\n    result = set()\n    for event in known_events:\n        if event not in result:\n            dfs(event)\n\n    # Return the result as a sorted string\n    return \" \".join(map(str, sorted(result)))"
    },
    {
        "number": 3131,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split('\\n')[0].split())\n    values = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_sum = 0\n    for combination in itertools.combinations(values, K):\n        max_sum += max(combination)\n\n    return str(max_sum % 1000000007)"
    },
    {
        "number": 3131,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    mod = 1000000007\n    result = 0\n\n    for i in range(N):\n        result += a[i]\n        result %= mod\n\n    for i in range(K):\n        max_value = 0\n        for j in range(N - K + i + 1):\n            max_value = max(max_value, a[j + i])\n        result += max_value\n        result %= mod\n\n    return str(result)"
    },
    {
        "number": 3131,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    key_values = list(map(int, input().split()))\n    key_values.sort(reverse=True)\n    total_sum = 0\n    for i in range(K):\n        total_sum += key_values[i]\n    return total_sum % 1000000007"
    },
    {
        "number": 3131,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def mod_pow(base, exponent):\n        result = 1\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % 1000000007\n            base = (base * base) % 1000000007\n            exponent = exponent // 2\n        return result\n\n    N, K = map(int, stdin.readline().split())\n    keys = list(map(int, stdin.readline().split()))\n    keys.sort(reverse=True)\n\n    result = 0\n    for i in range(K):\n        result = (result + keys[i]) % 1000000007\n\n    for i in range(K, N):\n        result = (result + keys[i] * mod_pow(K, i - K + 1)) % 1000000007\n\n    return str(result)"
    },
    {
        "number": 3131,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    values = list(map(int, stdin.readline().split()))\n\n    modulo = 1000000007\n    combinations = 0\n\n    for i in range(N - K + 1):\n        largest = max(values[i:i + K])\n        combinations += largest\n        combinations %= modulo\n\n    return str(combinations)\n"
    },
    {
        "number": 3131,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    keys = list(map(int, stdin.readline().split()))\n    max_sum = 0\n    mod = 1000000007\n\n    for combination in itertools.combinations(keys, k):\n        max_sum += max(combination)\n\n    return str(max_sum % mod)"
    },
    {
        "number": 3131,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    a.sort(reverse=True)\n    mod = 1000000007\n    result = 0\n\n    for i in range(k):\n        result += a[i]\n\n    for i in range(k, n):\n        result += a[i] * (n - i)\n\n    return result % mod\n"
    },
    {
        "number": 3131,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    result = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if len({i, j, k}) == 3:\n                    result += max(a[i], a[j], a[k])\n    return result % 1000000007"
    },
    {
        "number": 3131,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    keys = list(map(int, input().split()))\n    keys.sort(reverse=True)\n    total_sum = 0\n    for i in range(k):\n        total_sum += keys[i]\n    return total_sum % 1000000007\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 3131,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_sum_of_combinations(keys: list, k: int, n: int, modulo: int = 1000000007) -> int:\n        return sum(sorted(keys)[-k:]) * (n - k + 1) % modulo\n\n    input_data = list(map(int, stdin.split()))\n    n, k = input_data[0], input_data[1]\n    keys = input_data[2:]\n\n    return str(get_sum_of_combinations(keys, k, n))"
    },
    {
        "number": 3132,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    grid = []\n    for i in range(R):\n        grid.append(stdin.readline().strip())\n\n    building1_found = False\n    building2_found = False\n\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'x':\n                if not building1_found:\n                    building1_found = True\n                    building1_row = i\n                    building1_col = j\n                elif not building2_found:\n                    building2_found = True\n                    building2_row = i\n                    building2_col = j\n\n    if not building2_found:\n        building2_row = building1_row\n        building2_col = building1_col\n        building2_size = 0\n    else:\n        building1_size = 1\n        building2_size = 1\n\n        while building1_row + building1_size < R and building1_col + building1_size < C and grid[building1_row + building1_size][building1_col + building1_size] == 'x':\n            building1_size += 1\n\n        while building2_row + building2_size < R and building2_col + building2_size < C and grid[building2_row + building2_size][building2_col + building2_size] == 'x':\n            building2_size += 1\n\n        while building1_size > 1 and building1_row + building1_size - 1 < R and building1_col + building1_size - 1 < C and all(grid[building1_row + i][building1_col + j] == 'x' for i in range(building1_size) for j in range(building1_size)):\n            building1_size -= 1\n\n        while building2_size > 1 and building2_row + building2_size - 1 < R and building2_col + building2_size - 1 < C and all(grid[building2_row + i][building2_col + j] == 'x' for i in range(building2_size) for j in range(building2_size)):\n            building2_size -= 1\n\n    return f\"{building1_row + 1} {building1_col + 1} {building1_size}\\n{building2_row + 1} {building2_col + 1} {building2_size}\\n\""
    },
    {
        "number": 3132,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_buildings(grid):\n        buildings = []\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == \"x\":\n                    size = 1\n                    while i + size <= len(grid) and j + size <= len(grid[0]) and all(grid[x][y] == \"x\" for x in range(i, i + size) for y in range(j, j + size)):\n                        size += 1\n                    buildings.append((i, j, size))\n        return buildings\n\n    def print_buildings(buildings):\n        result = []\n        for building in buildings:\n            result.append(\"{} {} {}\".format(*building))\n        return \"\\n\".join(result)\n\n    R, C = map(int, stdin.split())\n    grid = [list(input()) for _ in range(R)]\n\n    buildings = find_buildings(grid)\n    return print_buildings(buildings)"
    },
    {
        "number": 3132,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_building(grid, rows, cols):\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 'x':\n                    size = 1\n                    while i + size - 1 < rows and j + size - 1 < cols and all(grid[k][l] == 'x' for k in range(i, i + size) for l in range(j, j + size)):\n                        size += 1\n                    return i, j, size\n        return None, None, None\n\n    lines = stdin.split('\\n')\n    R, C = map(int, lines[0].split())\n    grid = [list(line) for line in lines[1:]]\n\n    row1, col1, size1 = find_building(grid, R, C)\n    for i in range(R):\n        for j in range(C):\n            if i < row1 + size1 and j < col1 + size1:\n                grid[i][j] = '.'\n\n    row2, col2, size2 = find_building(grid, R, C)\n\n    return f\"{row1 + 1} {col1 + 1} {size1}\\n{row2 + 1} {col2 + 1} {size2}\\n\" "
    },
    {
        "number": 3132,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    grid = [list(line) for line in stdin.split('\\n')[1:]]\n    building1 = []\n    building2 = []\n    \n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'x':\n                if not building1:\n                    building1 = [i, j]\n                elif not building2:\n                    building2 = [i, j]\n    \n    for i in range(building1[0], R):\n        if 'x' not in grid[i][building1[1]:building2[1] + 1]:\n            building1.append(i - building1[0])\n            break\n    \n    for j in range(building1[1], C):\n        if 'x' not in [grid[i][j] for i in range(building1[0], building1[0] + building1[2])]:\n            building1.append(j - building1[1])\n            break\n    \n    for i in range(building2[0], R):\n        if 'x' not in grid[i][building2[1]:building1[1] - 1:-1]:\n            building2.append(i - building2[0])\n            break\n    \n    for j in range(building2[1], C):\n        if 'x' not in [grid[i][j] for i in range(building2[0], building2[0] + building2[2])]:\n            building2.append(j - building2[1])\n            break\n    \n    return f\"{building1[0]} {building1[1]} {building1[2]}\\n{building2[0]} {building2[1]} {building2[2]}\" "
    },
    {
        "number": 3132,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(R)]\n\n    # Find first building\n    first_building = None\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == 'x':\n                first_building = (r, c)\n                break\n        if first_building:\n            break\n\n    # Calculate size of first building\n    r, c = first_building\n    size = 1\n    while r + size - 1 < R and c + size - 1 < C and all(grid[i][j] == 'x' for i in range(r, r + size) for j in range(c, c + size)):\n        size += 1\n\n    # Remove first building from grid\n    for i in range(r, r + size):\n        for j in range(c, c + size):\n            grid[i][j] = '.'\n\n    # Find second building\n    second_building = None\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == 'x':\n                second_building = (r, c)\n                break\n        if second_building:\n            break\n\n    # Calculate size of second building\n    r, c = second_building\n    size = 1\n    while r + size - 1 < R and c + size - 1 < C and all(grid[i][j] == 'x' for i in range(r, r + size) for j in range(c, c + size)):\n        size += 1\n\n    # Return output\n    return f\"{first_building[0]+1} {first_building[1]+1} {size}\\n{second_building[0]+1} {second_building[1]+1} {size}\""
    },
    {
        "number": 3132,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    matrix = [list(stdin.readline().strip()) for _ in range(R)]\n    building1 = None\n    building2 = None\n\n    for i in range(R):\n        for j in range(C):\n            if matrix[i][j] == 'x':\n                if building1 is None:\n                    building1 = (i, j)\n                else:\n                    building2 = (i, j)\n                    break\n        if building2 is not None:\n            break\n\n    size1 = 1\n    while building1[0] + size1 <= R and building1[1] + size1 <= C:\n        if all(matrix[building1[0] + k][building1[1] + k] == 'x' for k in range(size1 + 1)):\n            size1 += 1\n        else:\n            break\n\n    size2 = 1\n    while building2[0] + size2 <= R and building2[1] + size2 <= C:\n        if all(matrix[building2[0] + k][building2[1] + k] == 'x' for k in range(size2 + 1)):\n            size2 += 1\n        else:\n            break\n\n    return f\"{building1[0]} {building1[1]} {size1}\\n{building2[0]} {building2[1]} {size2}\""
    },
    {
        "number": 3132,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(R)]\n\n    building1_found = False\n    building2_found = False\n\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'x':\n                if not building1_found:\n                    building1_found = True\n                    building1_row, building1_col = i, j\n                    building1_size = 1\n                    continue\n\n                if not building2_found:\n                    if i == building1_row and j > building1_col:\n                        building2_found = True\n                        building2_row, building2_col = i, j\n                        building2_size = 1\n                    elif i > building1_row and j == building1_col:\n                        building2_found = True\n                        building2_row, building2_col = i, j\n                        building2_size = 1\n\n                if building1_found and building2_found:\n                    break\n\n    if building1_size == 1 and building2_size == 1:\n        building1_size = 2\n        building2_size = 2\n    elif building1_size == 1:\n        building1_size = 2\n    elif building2_size == 1:\n        building2_size = 2\n\n    return f\"{building1_row} {building1_col} {building1_size}\\n{building2_row} {building2_col} {building2_size}\""
    },
    {
        "number": 3132,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().strip().split())\n    matrix = [list(stdin.readline().strip()) for _ in range(R)]\n\n    building1_found = False\n    building2_found = False\n    building1_start = (0, 0)\n    building2_start = (0, 0)\n    building1_length = 0\n    building2_length = 0\n\n    for i in range(R):\n        for j in range(C):\n            if matrix[i][j] == 'x':\n                if not building1_found:\n                    building1_found = True\n                    building1_start = (i, j)\n                    building1_length += 1\n                else:\n                    building2_found = True\n                    building2_start = (i, j)\n                    building2_length += 1\n            else:\n                if building1_found and building2_found:\n                    building1_length = max(building1_length, i - building1_start[0] + 1)\n                    building2_length = max(building2_length, i - building2_start[0] + 1)\n                    break\n                elif building1_found:\n                    building1_length = max(building1_length, i - building1_start[0] + 1)\n                elif building2_found:\n                    building2_length = max(building2_length, i - building2_start[0] + 1)\n\n    for j in range(C):\n        for i in range(R):\n            if matrix[i][j] == 'x':\n                if not building1_found:\n                    building1_found = True\n                    building1_start = (i, j)\n                    building1_length += 1\n                else:\n                    building2_found = True\n                    building2_start = (i, j)\n                    building2_length += 1\n            else:\n                if building1_found and building2_found:\n                    building1_length = max(building1_length, j - building1_start[1] + 1)\n                    building2_length = max(building2_length, j - building2_start[1] + 1)\n                    break\n                elif building1_found:\n                    building1_length = max(building1_length, j - building1_start[1] + 1)\n                elif building2_found:\n                    building2_length = max(building2_length, j - building2_start[1] + 1)\n\n    return f\"{building1_start[0]} {building1_start[1]} {building1_length}\\n{building2_start[0]} {building2_start[1]} {building2_length}\""
    },
    {
        "number": 3132,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_buildings(matrix, r, c):\n        buildings = []\n        for i in range(r):\n            for j in range(c):\n                if matrix[i][j] == \"x\":\n                    size = 1\n                    while i + size - 1 < r and j + size - 1 < c and all(matrix[k][l] == \"x\" for k in range(i, i + size) for l in range(j, j + size)):\n                        size += 1\n                    buildings.append((i, j, size))\n        return buildings\n\n    def find_non_overlapping_buildings(buildings):\n        non_overlapping_buildings = []\n        for building in buildings:\n            if not any(set(range(building[0], building[0] + building[2])).intersection(set(range(b[0], b[0] + b[2]))) and\n                       set(range(building[1], building[1] + building[2])).intersection(set(range(b[1], b[1] + b[2])))\n                       for b in non_overlapping_buildings):\n                non_overlapping_buildings.append(building)\n        return non_overlapping_buildings\n\n    r, c = map(int, stdin.readline().split())\n    matrix = [list(stdin.readline().strip()) for _ in range(r)]\n\n    buildings = find_buildings(matrix, r, c)\n    non_overlapping_buildings = find_non_overlapping_buildings(buildings)\n\n    return \"\\n\".join(f\"{b[0]} {b[1]} {b[2]}\" for b in non_overlapping_buildings)"
    },
    {
        "number": 3132,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    grid = []\n    for i in range(R):\n        row = stdin.readline().strip()\n        grid.append(row)\n\n    # Determine the location and size of the first building\n    building1_row, building1_col = -1, -1\n    building1_size = 0\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'x':\n                building1_row, building1_col = i, j\n                building1_size = 1\n                break\n        if building1_size > 0:\n            break\n\n    while True:\n        expandable = False\n        for i in range(building1_row, building1_row + building1_size):\n            for j in range(building1_col, building1_col + building1_size):\n                if i < R and j < C and grid[i][j] == '.':\n                    expandable = True\n                    grid[i][j] = 'x'\n        if not expandable:\n            break\n        building1_size += 1\n\n    # Determine the location and size of the second building\n    building2_row, building2_col = -1, -1\n    building2_size = 0\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'x' and (building1_row <= i < building1_row + building1_size and building1_col <= j < building1_col + building1_size) == False:\n                building2_row, building2_col = i, j\n                building2_size = 1\n                break\n        if building2_size > 0:\n            break\n\n    while True:\n        expandable = False\n        for i in range(building2_row, building2_row + building2_size):\n            for j in range(building2_col, building2_col + building2_size):\n                if i < R and j < C and grid[i][j] == '.':\n                    expandable = True\n                    grid[i][j] = 'x'\n        if not expandable:\n            break\n        building2_size += 1\n\n    # Output the results\n    return f\"{building1_row + 1} {building1_col + 1} {building1_size}\\n{building2_row + 1} {building2_col + 1} {building2_size}\\n\""
    },
    {
        "number": 3133,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, graph, tower_visible):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if dfs(neighbor, visited, graph, tower_visible):\n                return True\n        return tower_visible[node] == 1\n\n    n, A, B = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    tower_visible = [0] * n\n    for i in range(n):\n        l, r, t = map(int, stdin.readline().split())\n        graph[i].append(l)\n        graph[i].append(r)\n        tower_visible[i] = t\n\n    return \"indistinguishable\" if dfs(A, set(), graph, tower_visible) == dfs(B, set(), graph, tower_visible) else 0"
    },
    {
        "number": 3133,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n, A, B = input_data[0], input_data[1], input_data[2]\n    intersections = input_data[3:]\n\n    def dfs(start, path):\n        if start == 0 or start == 1:\n            return path\n        left, right, tower_visible = intersections[start]\n        if tower_visible:\n            return path\n        if left in path:\n            return -1\n        path.append(start)\n        return dfs(left, path)\n\n    A_path = dfs(A, [])\n    B_path = dfs(B, [])\n\n    if A_path == -1 or B_path == -1:\n        return \"indistinguishable\"\n\n    for i, j in zip(A_path, B_path):\n        if i != j:\n            return str(len(A_path) - A_path.index(i))\n\n    return \"indistinguishable\""
    },
    {
        "number": 3133,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n = map(int, stdin.split())\n    intersections = []\n    for _ in range(n):\n        l, r, t = map(int, input().split())\n        intersections.append((l, r, t))\n\n    def find_path(start: int, goal: int) -> int:\n        visited = [False] * n\n        visited[start] = True\n        queue = [(start, 0)]\n\n        while queue:\n            current, turns = queue.pop(0)\n            if current == goal:\n                return turns\n\n            l, r, _ = intersections[current]\n            if not visited[l]:\n                visited[l] = True\n                queue.append((l, turns + 1))\n\n            if not visited[r]:\n                visited[r] = True\n                queue.append((r, turns + 1))\n\n        return -1\n\n    alice_path = find_path(A, B)\n    bob_path = find_path(B, A)\n\n    if alice_path == -1 and bob_path == -1:\n        return \"indistinguishable\"\n\n    return str(min(alice_path, bob_path))"
    },
    {
        "number": 3133,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n = map(int, stdin.split())\n    intersections = []\n    for i in range(n):\n        intersections.append(list(map(int, input().split())) + [i])\n\n    def find_path(start, intersection):\n        path = [start]\n        while path[-1] != intersection:\n            path.append(intersections[path[-1]][1])\n        return path\n\n    path_A = find_path(A, intersections[B][1])\n    path_B = find_path(B, intersections[A][0])\n\n    for i, j in zip(path_A, path_B):\n        if i != j:\n            tower_A = intersections[i][2]\n            tower_B = intersections[j][2]\n            if tower_A and not tower_B:\n                return len(path_A) - path_A.index(i) + len(path_B) - path_B.index(j)\n            elif not tower_A and tower_B:\n                return len(path_A) - path_A.index(i) + len(path_B) - path_B.index(j)\n            else:\n                return \"indistinguishable\"\n\n    return \"indistinguishable\""
    },
    {
        "number": 3133,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B = map(int, stdin.split())\n    intersections = []\n    for _ in range(n):\n        intersections.append(list(map(int, input().split())))\n\n    def find_route(start, target):\n        visited = [False] * n\n        queue = [(start, 0)]\n\n        while queue:\n            node, turns = queue.pop(0)\n            if node == target:\n                return turns\n\n            visited[node] = True\n            for neighbor in intersections[node][:2]:\n                if not visited[neighbor]:\n                    queue.append((neighbor, turns + 1))\n\n        return None\n\n    alice_route = find_route(A, B)\n    bob_route = find_route(B, A)\n\n    if alice_route is not None and bob_route is not None:\n        return min(alice_route, bob_route)\n    else:\n        return \"indistinguishable\""
    },
    {
        "number": 3133,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Split input into lines\n    lines = stdin.splitlines()\n\n    # Extract values from first line\n    n, A, B = map(int, lines[0].split())\n\n    # Initialize lists to store data from subsequent lines\n    left = []\n    right = []\n    tower_visible = []\n\n    # Extract values from subsequent lines\n    for line in lines[1:]:\n        l, r, t = map(int, line.split())\n        left.append(l)\n        right.append(r)\n        tower_visible.append(t)\n\n    # Initialize variables to track the state of Alice's and Bob's positions\n    alice_state = [A]\n    bob_state = [B]\n\n    # Initialize variables to track the number of turns taken\n    alice_turns = 0\n    bob_turns = 0\n\n    # Iterate until Alice and Bob reach a distinguishable position or the maximum number of turns is reached\n    while alice_state[-1] != bob_state[-1] and alice_turns < n - 1 and bob_turns < n - 1:\n        # Update Alice's position\n        if tower_visible[alice_state[-1]] == 1:\n            alice_state.append(left[alice_state[-1]])\n            alice_turns += 1\n        else:\n            alice_state.append(right[alice_state[-1]])\n            alice_turns += 1\n\n        # Update Bob's position\n        if tower_visible[bob_state[-1]] == 1:\n            bob_state.append(left[bob_state[-1]])\n            bob_turns += 1\n        else:\n            bob_state.append(right[bob_state[-1]])\n            bob_turns += 1\n\n    # Determine if Alice and Bob can be distinguished\n    if alice_state[-1] == bob_state[-1]:\n        return \"indistinguishable\"\n    else:\n        return min(alice_turns, bob_turns)"
    },
    {
        "number": 3133,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, A, B = map(int, stdin.readline().split())\n    intersections = []\n    for i in range(n):\n        intersections.append(list(map(int, stdin.readline().split())))\n\n    # Perform the experiment\n    def get_path(start, intersection_list):\n        path = [start]\n        while intersection_list[path[-1]][0] != path[0]:\n            path.append(intersection_list[path[-1]][0])\n        return path\n\n    path_A = get_path(A, intersections)\n    path_B = get_path(B, intersections)\n\n    # Check if there is a distinguishable point\n    for i in range(min(len(path_A), len(path_B))):\n        if path_A[i] != path_B[i]:\n            return 0\n\n    return \"indistinguishable\""
    },
    {
        "number": 3133,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_visible(intersection):\n        return intersection == \"T\"\n\n    def find_route(start, turn):\n        route = [start]\n        while len(route) < len(intersections):\n            last_intersection = route[-1]\n            next_intersection = intersections[last_intersection][turn]\n            if next_intersection in route:\n                return None\n            route.append(next_intersection)\n            if is_visible(next_intersection):\n                return route\n            turn = (turn + 1) % 2\n        return None\n\n    stdin_list = stdin.strip().split(\"\\n\")\n    n, A, B = map(int, stdin_list[0].split())\n    intersections = [[\"X\"] * 2 for _ in range(n)]\n\n    for i, line in enumerate(stdin_list[1:]):\n        l, r, visible = map(int, line.split())\n        intersections[i][0] = l\n        intersections[i][1] = r\n        if visible:\n            intersections[i] = \"T\"\n\n    route_A = find_route(A, 0)\n    route_B = find_route(B, 0)\n\n    if route_A is None or route_B is None:\n        return \"indistinguishable\"\n\n    for i in range(1, len(route_A)):\n        if route_A[i] != route_B[i]:\n            return i - 1\n\n    return \"indistinguishable\""
    },
    {
        "number": 3133,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B = map(int, stdin.readline().split())\n    intersections = []\n    for i in range(n):\n        intersections.append(list(map(int, stdin.readline().split())))\n\n    def get_route(start, intersection):\n        route = []\n        visited = set()\n        while intersection not in visited:\n            visited.add(intersection)\n            route.append(intersection)\n            left, right, tower = intersections[intersection]\n            if start in (left, right):\n                return None\n            intersection = left if intersection == right else right\n        return route\n\n    route_A = get_route(A, B)\n    route_B = get_route(B, A)\n\n    if not route_A or not route_B:\n        return \"indistinguishable\"\n\n    turns_A = 0\n    for i in range(len(route_A) - 1):\n        left, right, tower = intersections[route_A[i]]\n        if route_A[i + 1] == right:\n            turns_A += 1\n\n    turns_B = 0\n    for i in range(len(route_B) - 1):\n        left, right, tower = intersections[route_B[i]]\n        if route_B[i + 1] == right:\n            turns_B += 1\n\n    return min(turns_A, turns_B)"
    },
    {
        "number": 3133,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def can_see_pisa(intersection):\n        return pisa_visibility[intersection] == 1\n\n    def trace_route(start_intersection):\n        route = [start_intersection]\n        while len(route) < len(pisa_visibility):\n            next_intersection = route[-1]\n            if can_see_pisa(next_intersection):\n                return route\n            left, right, _ = map(int, stdin.readline().split())\n            if left not in route:\n                route.append(left)\n            if right not in route:\n                route.append(right)\n        return None\n\n    n, A, B = map(int, stdin.readline().split())\n    pisa_visibility = [int(stdin.readline().split()[2]) for _ in range(n)]\n\n    A_route = trace_route(A)\n    B_route = trace_route(B)\n\n    if A_route is None or B_route is None:\n        return \"indistinguishable\"\n\n    common_intersection = None\n    for i in range(min(len(A_route), len(B_route))):\n        if A_route[i] == B_route[i]:\n            common_intersection = A_route[i]\n        else:\n            break\n\n    if common_intersection is not None and can_see_pisa(common_intersection):\n        return \"indistinguishable\"\n    else:\n        return str(len(A_route) + len(B_route) - 2 * (common_intersection is not None)) "
    },
    {
        "number": 3134,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    row_parities, col_parities = stdin.strip().split('\\n')\n    n = len(row_parities)\n    m = len(col_parities)\n    \n    # If any column parity is 0 and the corresponding row has no 1s, then it's impossible to recover the original matrix\n    for i in range(m):\n        if col_parities[i] == '0' and all(row_parities[j] == '0' for j in range(n)):\n            return '-1'\n    \n    # Initialize the matrix with 1s in the top-left corner\n    matrix = [['1' for _ in range(m)] for _ in range(n)]\n    \n    # Fill the rest of the matrix with 0s and 1s based on the parities\n    for i in range(n):\n        for j in range(m):\n            if row_parities[i] == '1' and col_parities[j] == '1':\n                matrix[i][j] = '0'\n    \n    # Sort the rows and columns in the desired order\n    sorted_matrix = []\n    for row in matrix:\n        row = ''.join(row)\n        sorted_row = ''.join(sorted(row, key=lambda x: (-int(x), x)))\n        sorted_matrix.append(sorted_row)\n    sorted_matrix.sort(key=lambda x: (-int(x[0]), x))\n    \n    # Convert the sorted matrix back to a list of lists\n    sorted_matrix = [list(row) for row in sorted_matrix]\n    \n    # Output the sorted matrix\n    return '\\n'.join(''.join(row) for row in sorted_matrix)"
    },
    {
        "number": 3134,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(list, stdin.split('\\n'))\n    n, m = len(R), len(C)\n    if n != m:\n        return '-1'\n    \n    matrix = [[0] * m for _ in range(n)]\n    for i in range(n):\n        ones_count = R[i]\n        for j in range(m):\n            if ones_count % 2 == C[j]:\n                matrix[i][j] = 1\n                ones_count -= 1\n    \n    return '\\n'.join([''.join(map(str, row)) for row in matrix])\n\ndef"
    },
    {
        "number": 3134,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def check_validity(matrix: list) -> bool:\n        for row in matrix:\n            if sum(row) % 2 != 0:\n                return False\n        for j in range(len(matrix[0])):\n            col_sum = 0\n            for i in range(len(matrix)):\n                col_sum += matrix[i][j]\n            if col_sum % 2 != 0:\n                return False\n        return True\n\n    def matrix_to_str(matrix: list) -> str:\n        return '\\n'.join([''.join(map(str, row)) for row in matrix])\n\n    row_parity, col_parity = stdin.strip().split('\\n')\n    n, m = len(row_parity), len(col_parity)\n\n    matrix = [[0] * m for _ in range(n)]\n    for i in range(n):\n        if row_parity[i] == '1':\n            for j in range(m):\n                matrix[i][j] = 1\n                if check_validity(matrix):\n                    break\n                matrix[i][j] = 0\n\n    for j in range(m):\n        if col_parity[j] == '1':\n            for i in range(n):\n                matrix[i][j] = 1\n                if check_validity(matrix):\n                    break\n                matrix[i][j] = 0\n\n    if not check_validity(matrix):\n        return '-1'\n\n    return matrix_to_str(matrix) "
    },
    {
        "number": 3134,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    row_parities, col_parities = stdin.split('\\n')\n    \n    # Calculate row and column counts\n    row_counts = [bin(int(p, 2)).count('1') for p in row_parities]\n    col_counts = [bin(int(p, 2)).count('1') for p in col_parities]\n    \n    # Create matrix with most 1's\n    matrix = []\n    for row_count in row_counts:\n        col_index = 0\n        row = []\n        for col_count in col_counts:\n            if row_count + col_count >= len(row) + col_count:\n                row += [1] * (col_count - len(row))\n            else:\n                row += [0] * (col_count - len(row))\n            col_index += 1\n        matrix.append(row)\n    \n    # Check if matrix can be recovered\n    if matrix[0] == [int(p) for p in row_parities[0]]:\n        # Check if matrix can be uniquely recovered\n        if all(row == [int(p) for p in row_parities[i]] for i, row in enumerate(matrix)) and all(col_counts[i] == sum(row[i] for row in matrix) for i in range(len(col_counts))):\n            # Output matrix\n            output = '\\n'.join([''.join(str(cell) for cell in row) for row in matrix])\n            return output\n    \n    # Cannot recover matrix\n    return -1"
    },
    {
        "number": 3134,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    row_parities, col_parities = stdin.split('\\n')\n    n, m = len(row_parities), len(col_parities)\n    \n    if n * m % 2 == 1:\n        return \"-1\"\n    \n    # Create a matrix with the most 1s possible\n    matrix = [['0' for _ in range(m)] for _ in range(n)]\n    \n    # Fill the matrix with the maximum number of 1s possible\n    for i in range(n):\n        for j in range(m):\n            if row_parities[i] == col_parities[j]:\n                matrix[i][j] = '1'\n    \n    # Check if the parities match the matrix\n    for i in range(n):\n        parity = sum(int(x) for x in matrix[i]) % 2\n        if parity != int(row_parities[i]):\n            return \"-1\"\n    \n    for j in range(m):\n        parity = sum(int(matrix[i][j]) for i in range(n)) % 2\n        if parity != int(col_parities[j]):\n            return \"-1\"\n    \n    # Sort the rows and columns\n    for i in range(n):\n        matrix[i] = ''.join(sorted(matrix[i]))\n    \n    matrix = [''.join(sorted(matrix[j])) for j in range(m)]\n    \n    # Return the matrix as output\n    return '\\n'.join(matrix)"
    },
    {
        "number": 3134,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    row_parities, col_parities = stdin.strip().split('\\n')\n    n, m = len(row_parities), len(col_parities)\n\n    def is_possible(matrix: list) -> bool:\n        for i in range(n):\n            row_sum = sum(matrix[i])\n            if row_sum % 2 != int(row_parities[i]):\n                return False\n\n        for j in range(m):\n            col_sum = sum(matrix[i][j] for i in range(n))\n            if col_sum % 2 != int(col_parities[j]):\n                return False\n\n        return True\n\n    def generate_matrix(matrix: list, i: int, j: int) -> None:\n        if i == n and j == m:\n            return True\n\n        if j == m:\n            i += 1\n            j = 0\n\n        if matrix[i][j] == -1:\n            matrix[i][j] = 0\n            if is_possible(matrix):\n                if generate_matrix(matrix, i, j + 1):\n                    return True\n            matrix[i][j] = 1\n            if is_possible(matrix):\n                if generate_matrix(matrix, i, j + 1):\n                    return True\n            matrix[i][j] = -1\n            return False\n\n        matrix[i][j] = -1\n        if generate_matrix(matrix, i, j + 1):\n            return True\n        matrix[i][j] = 1\n        if generate_matrix(matrix, i, j + 1):\n            return True\n\n        return False\n\n    matrix = [[-1 for _ in range(m)] for _ in range(n)]\n    if not generate_matrix(matrix, 0, 0):\n        return \"-1\\n\"\n\n    result = \"\"\n    for row in matrix:\n        result += \"\".join(str(x) for x in row) + \"\\n\"\n\n    return result"
    },
    {
        "number": 3134,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(list, stdin.strip().split('\\n'))\n    n, m = len(R), len(C)\n    A = [[0] * m for _ in range(n)]\n\n    def binary_value(A):\n        value = 0\n        for row in A:\n            for cell in row:\n                value = (value << 1) | cell\n        return value\n\n    def find_next_cell(A):\n        for i in range(n):\n            for j in range(m):\n                if A[i][j] == -1:\n                    return i, j\n        return None, None\n\n    def is_valid(A, row_parity, col_parity):\n        if row_parity != [sum(row) % 2 for row in A]:\n            return False\n        if col_parity != [sum(A[i][j] for i in range(n)) % 2 for j in range(m)]:\n            return False\n        return True\n\n    def recover_matrix(A, row_parity, col_parity):\n        i, j = find_next_cell(A)\n        if i is None:\n            return is_valid(A, row_parity, col_parity)\n\n        for value in (0, 1):\n            A[i][j] = value\n            if recover_matrix(A, row_parity, col_parity):\n                return True\n            A[i][j] = -1\n\n        return False\n\n    A[0][0] = 1\n    recover_matrix(A, R, C)\n\n    if any(-1 in row for row in A):\n        return \"-1\\n\"\n\n    return \"\\n\".join(\"\".join(map(str, row)) for row in A) + \"\\n\""
    },
    {
        "number": 3134,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    row_parities, col_parities = map(list, stdin.split('\\n'))\n    n, m = len(row_parities), len(col_parities)\n    \n    def get_binary_matrix():\n        binary_matrix = [[0] * m for _ in range(n)]\n        for i in range(n):\n            row_parity = int(row_parities[i])\n            for j in range(m):\n                col_parity = int(col_parities[j])\n                if row_parity % 2 == col_parity:\n                    binary_matrix[i][j] = 1\n                row_parity -= binary_matrix[i][j]\n            assert row_parity == 0\n        return binary_matrix\n    \n    def get_unique_matrix():\n        binary_matrix = get_binary_matrix()\n        unique_matrix = []\n        for i in range(n):\n            row = ''.join(map(str, binary_matrix[i]))\n            while row.count('1') < m - row.count('0'):\n                row = '1' + row[:-1]\n            unique_matrix.append(list(map(int, row)))\n        return unique_matrix\n    \n    def get_output(matrix):\n        output = '\\n'.join([''.join(map(str, row)) for row in matrix])\n        return output\n    \n    try:\n        unique_matrix = get_unique_matrix()\n        output = get_output(unique_matrix)\n    except AssertionError:\n        output = -1\n    \n    return output"
    },
    {
        "number": 3134,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    row_parities, col_parities = stdin.split(\"\\n\")\n    n, m = len(row_parities), len(col_parities)\n    row_parities = [int(p) for p in row_parities]\n    col_parities = [int(p) for p in col_parities]\n    \n    # Initialize the matrix with ones\n    matrix = [[1 for _ in range(m)] for _ in range(n)]\n    \n    # Fill in the first row\n    for j in range(m):\n        if col_parities[j] == 1:\n            matrix[0][j] = 0\n    \n    # Fill in the other rows\n    for i in range(1, n):\n        for j in range(m):\n            if row_parities[i] == col_parities[j]:\n                matrix[i][j] = 0\n                \n    # Check if the matrix is valid\n    for i in range(n):\n        row_sum = sum(matrix[i])\n        if row_sum != row_parities[i]:\n            return \"-1\"\n    for j in range(m):\n        col_sum = sum(matrix[i][j] for i in range(n))\n        if col_sum != col_parities[j]:\n            return \"-1\"\n    \n    # Output the matrix\n    return \"\\n\".join(\"\".join(str(x)) for x in matrix)"
    },
    {
        "number": 3134,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    row_parities, col_parities = stdin.split('\\n')\n    n = len(row_parities)\n    m = len(col_parities)\n\n    def get_all_matrices():\n        for row in range(2 ** n):\n            for col in range(2 ** m):\n                matrix = [[0] * m for _ in range(n)]\n                for i in range(n):\n                    for j in range(m):\n                        if (row >> i) & 1 == (col >> j) & 1:\n                            matrix[i][j] = 1\n                yield matrix\n\n    def is_valid(matrix):\n        for i in range(n):\n            row_sum = sum(matrix[i])\n            if row_sum % 2 != int(row_parities[i]):\n                return False\n        for j in range(m):\n            col_sum = sum(matrix[i][j] for i in range(n))\n            if col_sum % 2 != int(col_parities[j]):\n                return False\n        return True\n\n    def matrix_to_binary(matrix):\n        return ''.join(str(x) for row in matrix for x in row)\n\n    matrices = list(filter(is_valid, get_all_matrices()))\n    if not matrices:\n        return '-1'\n\n    matrices.sort(key=matrix_to_binary)\n    return '\\n'.join(''.join(str(x) for x in row) for row in matrices[0])"
    },
    {
        "number": 3135,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    if n == 0:\n        return \"0\"\n    k = n.bit_length()\n    min_len = k + 1\n    min_representation = \"\"\n\n    for sign in [1, -1]:\n        for i in range(k):\n            if n & (1 << i):\n                b = sign\n            else:\n                b = 0\n            n ^= b << i\n            representation = bin(b)[2:] + \"0\" * (k - i - 1)\n            if len(representation.strip(\"0\")) < min_len:\n                min_len = len(representation.strip(\"0\"))\n                min_representation = representation\n\n    return min_representation.replace(\"0\", \"0\").replace(\"1\", \"+\").replace(\"-1\", \"-\")"
    },
    {
        "number": 3135,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    if n == 0:\n        return \"0\"\n    \n    sign_n = []\n    while n != 0:\n        sign_n.append(n % 3)\n        n //= 3\n    \n    sign_n = sign_n[::-1]\n    \n    # Replace 0s with +1s\n    for i in range(len(sign_n)):\n        if sign_n[i] == 0:\n            sign_n[i] = 1\n        else:\n            break\n    \n    # Remove leading +1s\n    while len(sign_n) > 1 and sign_n[-1] == 1:\n        sign_n.pop()\n    \n    # Convert to string\n    sign_n_str = \"\".join([str(x) for x in sign_n])\n    \n    # Replace 1s and 2s with + and -\n    sign_n_str = sign_n_str.replace(\"1\", \"+\").replace(\"2\", \"-\")\n    \n    return sign_n_str"
    },
    {
        "number": 3135,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    min_non_zero_digits = float('inf')\n    min_representation = \"\"\n\n    for sign in [1, -1, 0]:\n        if sign == 0:\n            binary_representation = bin(n)[2:]\n        else:\n            binary_representation = bin(n * sign)[2:]\n\n        non_zero_digits = binary_representation.count('1') + binary_representation.count('-')\n\n        if non_zero_digits < min_non_zero_digits:\n            min_non_zero_digits = non_zero_digits\n            min_representation = binary_representation\n\n    return min_representation.replace('1', '+').replace('-', '-').replace('0', '0')"
    },
    {
        "number": 3135,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    k = 0\n    while n >> k:\n        k += 1\n    \n    best = float('inf')\n    result = None\n    \n    for mask in range(3**k):\n        binary_representation = []\n        for i in range(k):\n            bit = (mask >> (2*i)) & 3\n            if bit == 0:\n                binary_representation.append('0')\n            elif bit == 1:\n                binary_representation.append('+')\n            elif bit == 2:\n                binary_representation.append('-')\n        \n        masked_number = n ^ ((1 << k) - 1)\n        masked_number >>= count_trailing_zeros(mask)\n        masked_number |= (1 << k)\n        \n        if count_non_zero_digits(binary_representation) < best:\n            best = count_non_zero_digits(binary_representation)\n            result = binary_representation\n        elif count_non_zero_digits(binary_representation) == best:\n            if binary_representation < result:\n                result = binary_representation\n    \n    return ''.join(result)\n\ndef"
    },
    {
        "number": 3135,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    min_len = float('inf')\n    min_rep = ''\n\n    for i in range(-1, 2):\n        for j in range(n + i):\n            rep = ['0'] * n\n            rep[j] = str(i)\n            rep = ''.join(rep)\n\n            if len(rep) < min_len or (len(rep) == min_len and rep < min_rep):\n                min_len = len(rep)\n                min_rep = rep\n\n    return min_rep.replace('1', '+').replace('-1', '-').replace('0', '0')"
    },
    {
        "number": 3135,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    if n == 0:\n        return '0'\n    result = []\n    i = 0\n    while n != 0:\n        if n % 2 == 1:\n            result.append('+' if len(result) == 0 else '-')\n        n //= 2\n        i += 1\n    return ''.join(result)"
    },
    {
        "number": 3135,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    if n == 0:\n        return \"0\"\n    if n == 1:\n        return \"+\"\n    if n == 2:\n        return \"-\"\n    k = 0\n    while n >= 2**(k+1):\n        k += 1\n    if n == 2**k:\n        return \"-\" + \"0\"*(k-1)\n    elif n == 2**k - 1:\n        return \"+\" + \"0\"*(k-1)\n    else:\n        s = bin(n)[2:]\n        s = s.replace(\"1\", \"+\").replace(\"0\", \"0\").replace(\"-1\", \"-\")\n        return s"
    },
    {
        "number": 3135,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    sign = '-' if n < 0 else '+'\n    n = abs(n)\n    binary_rep = bin(n)[2:]\n    binary_rep = binary_rep.rjust(len(binary_rep) + 1, '0')\n    if n == 0:\n        return '0'\n    return sign + binary_rep"
    },
    {
        "number": 3135,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    min_len = len(stdin)\n    min_rep = \"\"\n    \n    for i in range(len(stdin)):\n        for j in range(i, len(stdin)):\n            rep = stdin[:i] + \"0\" * (j - i) + stdin[j:]\n            rep = rep.replace(\"0\", \"\").replace(\"1\", \"+\")\n            rep = rep.replace(\"-\", \"0\").replace(\"+\", \"1\").replace(\"0\", \"-\")\n            if len(rep) < min_len and (len(rep) == min_len - 1 or rep < min_rep):\n                min_len = len(rep)\n                min_rep = rep\n                \n    return min_rep"
    },
    {
        "number": 3135,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    k = 0\n    while n >> k:\n        k += 1\n    res = []\n    for i in range(k):\n        res.append('0')\n    if n != 0:\n        res[0] = '-' if n % 2 == 0 else '+'\n    for i in range(1, k):\n        if n & (1 << i):\n            res[k - i] = '+'\n    return ''.join(res)\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 3136,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.readline().split())\n    a, b = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    y = list(map(int, stdin.readline().split()))\n    graph = [[0] * n for _ in range(n)]\n\n    for _ in range(m):\n        u, v, d = map(int, stdin.readline().split())\n        graph[u - 1][v - 1] = d\n        graph[v - 1][u - 1] = d\n\n    dist = [[0] * n for _ in range(s)]\n    for i in range(s):\n        for j in range(n):\n            dist[i][j] = graph[x[i] - 1][j]\n\n    total_distance = 0\n    for i in range(t):\n        min_dist = float('inf')\n        min_index = -1\n        for j in range(s):\n            if dist[j][y[i] - 1] < min_dist:\n                min_dist = dist[j][y[i] - 1]\n                min_index = j\n        total_distance += min_dist\n        for k in range(s):\n            dist[k][y[i] - 1] = min(dist[k][y[i] - 1], dist[min_index][y[i] - 1] + graph[x[k] - 1][x[min_index] - 1])\n\n    return str(total_distance)"
    },
    {
        "number": 3136,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_path(graph, start, end, path=[]):\n        path = path + [start]\n        if start == end:\n            return path\n        if start not in graph:\n            return None\n        shortest_path = None\n        for node in graph[start]:\n            if node not in path:\n                new_path = find_shortest_path(graph, node, end, path)\n                if new_path:\n                    if not shortest_path or len(new_path) < len(shortest_path):\n                        shortest_path = new_path\n        return shortest_path\n\n    def build_graph(roads):\n        graph = {}\n        for road in roads:\n            u, v, d = road\n            if u not in graph:\n                graph[u] = []\n            if v not in graph:\n                graph[v] = []\n            graph[u].append(v)\n            graph[v].append(u)\n        return graph\n\n    def distance_between(start, end, roads):\n        shortest_path = find_shortest_path(roads, start, end)\n        return sum([roads[shortest_path[i]][shortest_path[i+1]] for i in range(len(shortest_path) - 1)])\n\n    lines = stdin.strip().split('\\n')\n    n, m, s, t, a, b, x, y = map(int, lines[0].split()), lines[1].split(), lines[2].split(), lines[3].split()\n    roads = [list(map(int, lines[4+i].split())) for i in range(m)]\n\n    graph = build_graph(roads)\n    total_distance = 0\n\n    for i in range(t):\n        min_distance = float('inf')\n        for j in range(s):\n            min_distance = min(min_distance, distance_between(x[j], y[i], graph))\n        total_distance += min_distance\n\n    return str(total_distance) "
    },
    {
        "number": 3136,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    n, m, s, t, warehouses, employees, clients = parse_input(stdin)\n\n    # Create the graph\n    graph = create_graph(n, m, stdin)\n\n    # Find the shortest paths\n    shortest_paths = find_shortest_paths(graph, employees, clients)\n\n    # Calculate the total distance\n    total_distance = calculate_total_distance(shortest_paths)\n\n    return str(total_distance)\n\n\ndef"
    },
    {
        "number": 3136,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t, a, b, x, y, roads = read_input(stdin)\n    min_total_distance = float('inf')\n\n    for combination in itertools.combinations(range(s), t):\n        employees_distances = [0] * s\n        clients_distances = [0] * t\n\n        for i, x_i in enumerate(x):\n            if i in combination:\n                employees_distances[i] = dijkstra(x_i, a, roads)\n\n        for j, y_i in enumerate(y):\n            clients_distances[j] = dijkstra(y_i, b, roads)\n\n        total_distance = sum(employees_distances) + sum(clients_distances)\n        min_total_distance = min(min_total_distance, total_distance)\n\n    return str(min_total_distance)\n\ndef"
    },
    {
        "number": 3136,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t, a, b, x, y = parse_input(stdin)\n    adj_list = create_adj_list(m)\n    warehouses = {a, b}\n    employees = set(x)\n    clients = set(y)\n\n    min_distance = float('inf')\n\n    for warehouse in warehouses:\n        for employee in employees:\n            if employee in clients:\n                continue\n            distance = dijkstra(adj_list, warehouse, employee)\n            min_distance = min(min_distance, distance)\n\n    for employee in employees:\n        for client in clients:\n            distance = dijkstra(adj_list, employee, client)\n            min_distance += distance\n\n    return str(min_distance)\n\n\ndef"
    },
    {
        "number": 3136,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.readline().split())\n    a, b = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    y = list(map(int, stdin.readline().split()))\n\n    graph = [[0] * (n + 1) for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, d = map(int, stdin.readline().split())\n        graph[u][v] = d\n        graph[v][u] = d\n\n    for i in range(1, n + 1):\n        graph[i][i] = 0\n\n    floyd_warshall(graph, n)\n\n    total_distance = 0\n    for i in range(s):\n        min_distance = float('inf')\n        for j in range(t):\n            min_distance = min(min_distance, graph[x[i]][a] + graph[a][b] + graph[b][y[j]])\n        total_distance += min_distance\n\n    return str(total_distance)\n\ndef"
    },
    {
        "number": 3136,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(graph, start, end, path=[]):\n        path = path + [start]\n        if start == end:\n            return path\n        if start not in graph:\n            return None\n        for node in graph[start]:\n            if node not in path:\n                newpath = find_path(graph, node, end, path)\n                if newpath:\n                    return newpath\n        return None\n\n    def min_distance(graph, start, end):\n        path = find_path(graph, start, end)\n        distance = 0\n        for i in range(len(path) - 1):\n            distance += graph[path[i]][path[i + 1]]\n        return distance\n\n    n, m, s, t, a, b, w1, w2, clients = map(int, stdin.split())\n    graph = {}\n    for i in range(m):\n        u, v, d = map(int, input().split())\n        if u not in graph:\n            graph[u] = {}\n        if v not in graph:\n            graph[v] = {}\n        graph[u][v] = d\n        graph[v][u] = d\n\n    total_distance = 0\n    for i in range(t):\n        total_distance += min_distance(graph, a, clients[i])\n        total_distance += min_distance(graph, clients[i], b)\n\n    return str(total_distance)"
    },
    {
        "number": 3136,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    from heapq import heappop, heappush\n    from sys import stdin\n\n    n, m, s, t = map(int, stdin.readline().split())\n    a, b = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    y = list(map(int, stdin.readline().split()))\n\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, d = map(int, stdin.readline().split())\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n\n    pq = []\n    dist = [float('inf')] * (n + 1)\n    dist[a] = 0\n    heappush(pq, (0, a))\n\n    while pq:\n        d, u = heappop(pq)\n\n        if d > dist[u]:\n            continue\n\n        for v, dd in graph[u]:\n            alt = dist[u] + dd\n            if alt < dist[v]:\n                dist[v] = alt\n                heappush(pq, (alt, v))\n\n    ans = float('inf')\n    for i in range(s):\n        for j in range(t):\n            ans = min(ans, dist[x[i]] + dist[y[j]])\n\n    return str(ans)"
    },
    {
        "number": 3136,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from heapq import heappush, heappop\n\n    n, m, s, t, a, b, x, y, roads = (map(int, stdin.split()))\n    x = list(map(int, x.split()))\n    y = list(map(int, y.split()))\n\n    graph = [[] for _ in range(n + 1)]\n    for u, v, d in roads:\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n\n    # Dijkstra's algorithm to find the shortest path from each warehouse to all other intersections\n    dist = [float(\"inf\")] * (n + 1)\n    dist[a] = 0\n    dist[b] = 0\n    q = [(0, a), (0, b)]\n\n    while q:\n        d, u = heappop(q)\n        if d > dist[u]:\n            continue\n        for v, d_uv in graph[u]:\n            if dist[u] + d_uv < dist[v]:\n                dist[v] = dist[u] + d_uv\n                heappush(q, (dist[v], v))\n\n    # Find the closest warehouse for each employee\n    closest_warehouse = [0] * s\n    for i, x_i in enumerate(x):\n        if dist[a] < dist[b]:\n            closest_warehouse[i] = a\n        else:\n            closest_warehouse[i] = b\n\n    # Calculate the total distance travelled by the employees\n    total_distance = 0\n    for i, y_i in enumerate(y):\n        total_distance += dist[closest_warehouse[i]] + dist[y_i]\n\n    return str(total_distance)"
    },
    {
        "number": 3136,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t, a, b, x, y, d = map(int, stdin.split())\n    warehouses = [a, b]\n    employees = x.split()\n    clients = y.split()\n    roads = []\n    for i in range(m):\n        u, v, d = map(int, input().split())\n        roads.append([u, v, d])\n\n    total_distance = 0\n    for i in range(t):\n        min_distance = float('inf')\n        min_path = []\n        for w in warehouses:\n            for e in employees:\n                for c in clients:\n                    path = bfs(w, e, c, roads)\n                    distance = calculate_distance(path, roads)\n                    if distance < min_distance:\n                        min_distance = distance\n                        min_path = path\n        total_distance += min_distance\n        for e in min_path[1:-1]:\n            if e in employees:\n                employees.remove(e)\n    return str(total_distance)\n\ndef"
    },
    {
        "number": 3137,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 1 <= x <= N and 1 <= y <= M\n\n    def move(x, y, direction):\n        if direction == 'U':\n            return x - 1, y\n        elif direction == 'D':\n            return x + 1, y\n        elif direction == 'L':\n            return x, y - 1\n        elif direction == 'R':\n            return x, y + 1\n\n    lines = stdin.split('\\n')\n    N, M, K = map(int, lines[0].split())\n    X, Y = map(int, lines[1].split())\n\n    bacteria = []\n    for i in range(K):\n        X_i, Y_i = map(int, lines[2 + i * (N + 1)].split())\n        C_i = lines[2 + i * (N + 1) + 1][0]\n        matrix = [list(map(int, line)) for line in lines[2 + i * (N + 1) + 2:2 + i * (N + 1) + N + 2]]\n        bacteria.append((X_i, Y_i, C_i, matrix))\n\n    time = 0\n    while True:\n        time += 1\n        for bacterium in bacteria:\n            x, y, direction, matrix = bacterium\n            x, y = move(x, y, direction)\n            if not is_valid(x, y):\n                x, y = move(x, y, 'U')\n                x, y = move(x, y, 'U')\n            direction = 'ULDR'[('ULDR'.index(direction) + matrix[x - 1][y - 1]) % 4]\n            bacterium[0], bacterium[1], bacterium[2] = x, y, direction\n\n        bacteria_count = sum(1 for bacterium in bacteria if bacterium[0] == X and bacterium[1] == Y)\n        if bacteria_count >= K:\n            return str(time)\n\n    return '-1'"
    },
    {
        "number": 3137,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_lines = stdin.split('\\n')\n    N, M, K = map(int, input_lines[0].split())\n    X, Y = map(int, input_lines[1].split())\n    bacteria = []\n    for i in range(K):\n        Xi, Yi, Ci = input_lines[2 + i].split()\n        Xi, Yi = int(Xi), int(Yi)\n        matrix = [list(map(int, input_lines[2 + i + j + 1])) for j in range(N)]\n        bacteria.append((Xi, Yi, Ci, matrix))\n\n    # Initialize directions and board\n    directions = {'U': (-1, 0), 'R': (0, 1), 'D': (1, 0), 'L': (0, -1)}\n    board = [[0 for _ in range(M)] for _ in range(N)]\n    board[X - 1][Y - 1] = -1\n\n    # Simulate bacteria\n    time = 0\n    while True:\n        time += 1\n        alive = False\n        for bacterium in bacteria:\n            Xi, Yi, Ci, matrix = bacterium\n            # Read number\n            X = matrix[Xi - 1][Yi - 1]\n            # Turn and move\n            for _ in range(X):\n                dx, dy = directions[Ci]\n                Ci = 'URDL'['URDL'.index(Ci) - 1]\n            if Xi + dx < 1 or Xi + dx > N or Yi + dy < 1 or Yi + dy > M:\n                Ci = 'LRUD'[2 - 'LRUD'.index(Ci)]\n            Xi += dx\n            Yi += dy\n            # Check if trap was activated\n            if board[Xi - 1][Yi - 1] == -1:\n                return str(time)\n            alive = True\n            # Update bacterium position\n            bacterium = Xi, Yi, Ci, matrix\n        if not alive:\n            return '-1'\n\n    return '-1'"
    },
    {
        "number": 3137,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbor(x, y, direction):\n        if direction == 'U':\n            return x - 1, y\n        elif direction == 'D':\n            return x + 1, y\n        elif direction == 'L':\n            return x, y - 1\n        else:\n            return x, y + 1\n\n    def is_outside_board(x, y, rows, cols):\n        return x < 1 or x > rows or y < 1 or y > cols\n\n    def get_trap_location(trap_row, trap_col, direction, rows, cols):\n        if direction == 'U':\n            return trap_row - 1, trap_col\n        elif direction == 'D':\n            return trap_row + 1, trap_col\n        elif direction == 'L':\n            return trap_row, trap_col - 1\n        else:\n            return trap_row, trap_col + 1\n\n    def move_bacteria(rows, cols, bacteria, trap_location):\n        active_bacteria = [True] * len(bacteria)\n        steps = 0\n\n        while any(active_bacteria):\n            steps += 1\n            new_active_bacteria = []\n\n            for i, bacterium in enumerate(bacteria):\n                if not active_bacteria[i]:\n                    continue\n\n                x, y = bacterium['location']\n                direction = bacterium['direction']\n                num_turns = bacterium['numbers'][x - 1][y - 1]\n\n                for _ in range(num_turns):\n                    direction = {'U': 'L', 'D': 'R', 'L': 'D', 'R': 'U'}[direction]\n\n                new_x, new_y = get_neighbor(x, y, direction)\n\n                if is_outside_board(new_x, new_y, rows, cols):\n                    direction = {'U': 'D', 'D': 'U', 'L': 'R', 'R': 'L'}[direction]\n                    new_x, new_y = get_neighbor(x, y, direction)\n\n                bacterium['location'] = new_x, new_y\n                bacterium['direction'] = direction\n\n                if (new_x, new_y) == trap_location:\n                    active_bacteria[i] = False\n\n                new_active_bacteria.append(active_bacteria[i])\n\n            active_bacteria = new_active_bacteria\n\n        return steps\n\n    N, M, K = map(int, stdin.readline().strip().split())\n    trap_row, trap_col = map(int, stdin.readline().strip().split())\n    bacteria = []\n\n    for _ in range(K):\n        X, Y = map(int, stdin.readline().strip().split())\n        direction = stdin.readline().strip()\n        numbers = [list(map(int, stdin.readline().strip())) for _ in range(N)]\n        bacteria.append({'location': (X, Y), 'direction': direction, 'numbers': numbers})\n\n    trap_location = get_trap_location(trap_row, trap_col, bacteria[0]['direction'], N, M)\n    return str(move_bacteria(N, M, bacteria, trap_location))"
    },
    {
        "number": 3137,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, X, Y = map(int, stdin.split('\\n')[0].split())\n    X, Y = X - 1, Y - 1\n    bacteria_data = stdin.split('\\n')[2:]\n    bacteria_directions = [bacteria_data[i].split('\\n')[0] for i in range(K)]\n    bacteria_numbers = [bacteria_data[i].split('\\n')[1:] for i in range(K)]\n\n    def move_bacteria(bacteria_idx: int) -> None:\n        global bacteria_directions, bacteria_numbers, bacteria_positions\n        direction = bacteria_directions[bacteria_idx]\n        x, y = bacteria_positions[bacteria_idx]\n        if direction == 'U':\n            x -= 1\n        elif direction == 'D':\n            x += 1\n        elif direction == 'L':\n            y -= 1\n        else:\n            y += 1\n\n        if x < 0:\n            x = N - 1\n        elif x >= N:\n            x = 0\n        elif y < 0:\n            y = M - 1\n        elif y >= M:\n            y = 0\n\n        bacteria_positions[bacteria_idx] = x, y\n\n    def turn_bacteria(bacteria_idx: int, times: int) -> None:\n        global bacteria_directions\n        direction = bacteria_directions[bacteria_idx]\n        if direction == 'U':\n            new_direction = ['L', 'D', 'R'][times % 4]\n        elif direction == 'D':\n            new_direction = ['R', 'U', 'L'][times % 4]\n        elif direction == 'L':\n            new_direction = ['U', 'R', 'D'][times % 4]\n        else:\n            new_direction = ['D', 'L', 'U'][times % 4]\n\n        bacteria_directions[bacteria_idx] = new_direction\n\n    def bacteria_collision() -> bool:\n        global bacteria_positions\n        bacteria_count = [0] * N * M\n        for x, y in bacteria_positions:\n            bacteria_count[x * M + y] += 1\n\n        return any(count > 1 for count in bacteria_count)\n\n    bacteria_positions = [(int(direction[0]), int(direction[1])) for direction in bacteria_directions]\n    total_seconds = 0\n\n    while True:\n        for i in range(K):\n            x, y = bacteria_positions[i]\n            number = int(bacteria_numbers[i][x][y])\n            turn_bacteria(i, number)\n            move_bacteria(i)\n\n        if bacteria_collision():\n            return str(total_seconds)\n\n        total_seconds += 1\n\n        if total_seconds == 7200:\n            return '-1'\n\n    return '0'"
    },
    {
        "number": 3137,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        N, M, K = map(int, lines[0].split())\n        X, Y = map(int, lines[1].split())\n        bacteria = []\n        for i in range(K):\n            X_i, Y_i, C_i = lines[2 + i * (N + 1)].split()\n            X_i, Y_i = int(X_i), int(Y_i)\n            numbers = []\n            for j in range(N):\n                numbers.append(list(map(int, lines[3 + i * (N + 1) + j].split())))\n            bacteria.append((X_i, Y_i, C_i, numbers))\n        return N, M, K, X, Y, bacteria\n\n    def find_next_position(x: int, y: int, direction: str) -> tuple:\n        if direction == 'U':\n            return x - 1, y\n        elif direction == 'R':\n            return x, y + 1\n        elif direction == 'D':\n            return x + 1, y\n        else:\n            return x, y - 1\n\n    def simulate(N: int, M: int, K: int, X: int, Y: int, bacteria: list) -> int:\n        state = [[0 for _ in range(M)] for _ in range(N)]\n        for i in range(K):\n            x, y, direction, numbers = bacteria[i]\n            state[x - 1][y - 1] = i + 1\n\n        time = 0\n        while True:\n            new_state = [[0 for _ in range(M)] for _ in range(N)]\n            for i in range(K):\n                x, y, direction, numbers = bacteria[i]\n                X_i = numbers[x - 1][y - 1]\n                for _ in range(X_i):\n                    direction = {'U': 'L', 'R': 'U', 'D': 'R', 'L': 'D'}[direction]\n                new_x, new_y = find_next_position(x, y, direction)\n                if 1 <= new_x <= N and 1 <= new_y <= M:\n                    x, y = new_x, new_y\n                else:\n                    direction = {'U': 'D', 'R': 'L', 'D': 'U', 'L': 'R'}[direction]\n                new_state[x - 1][y - 1] = i + 1\n\n            if new_state == state:\n                break\n\n            state = new_state\n            time += 1\n\n            if state[X - 1][Y - 1] == K:\n                break\n\n        return time\n\n    N, M, K, X, Y, bacteria = read_input(stdin)\n    result = simulate(N, M, K, X, Y, bacteria)\n    return str(result)"
    },
    {
        "number": 3137,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, X, Y = list(map(int, stdin.split('\\n')[0].split()))\n    X, Y = X - 1, Y - 1\n    bacteria = []\n    for i in range(K):\n        Xi, Yi, direction = stdin.split('\\n')[i + 1].split()\n        Xi, Yi = int(Xi) - 1, int(Yi) - 1\n        data = [list(map(int, row)) for row in stdin.split('\\n')[i + 2].split('\\n')]\n        bacteria.append((Xi, Yi, direction, data))\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M\n\n    def move(x, y, direction):\n        if direction == 'U':\n            return x - 1, y\n        elif direction == 'R':\n            return x, y + 1\n        elif direction == 'D':\n            return x + 1, y\n        else:\n            return x, y - 1\n\n    def turn(direction, times):\n        if direction == 'U':\n            return 'R' if times % 4 == 1 else 'L' if times % 4 == 3 else 'U'\n        elif direction == 'R':\n            return 'U' if times % 4 == 1 else 'D' if times % 4 == 3 else 'R'\n        elif direction == 'D':\n            return 'L' if times % 4 == 1 else 'R' if times % 4 == 3 else 'D'\n        else:\n            return 'D' if times % 4 == 1 else 'U' if times % 4 == 3 else 'L'\n\n    def update_bacteria(bacteria, time):\n        new_bacteria = []\n        for xi, yi, direction, data in bacteria:\n            x, y = move(xi, yi, direction)\n            if is_valid(x, y):\n                new_direction = turn(direction, data[xi][yi])\n                new_xi, new_yi = x, y\n            else:\n                new_direction = turn(direction, 2)\n                new_xi, new_yi = xi, yi\n\n            new_bacteria.append((new_xi, new_yi, new_direction, data))\n        return new_bacteria\n\n    time = 0\n    while True:\n        if all(xi == X and yi == Y for xi, yi, direction, data in bacteria):\n            return time\n\n        bacteria = update_bacteria(bacteria, time)\n        time += 1\n\n        if time > 1000:\n            return -1"
    },
    {
        "number": 3137,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 1 <= x <= N and 1 <= y <= M\n\n    def next_pos(x, y, direction):\n        if direction == 'U':\n            return x - 1, y\n        elif direction == 'D':\n            return x + 1, y\n        elif direction == 'L':\n            return x, y - 1\n        else:\n            return x, y + 1\n\n    def simulate(board, x, y, direction):\n        for _ in range(K * N * M):\n            new_x, new_y = next_pos(x, y, direction)\n            if not is_valid(new_x, new_y):\n                direction = 'D' if direction == 'U' else 'U' if direction == 'D' else 'R' if direction == 'L' else 'L'\n            else:\n                x, y = new_x, new_y\n                number = int(board[x - 1][y - 1])\n                direction = (direction * number)[:2]\n            if x == X and y == Y:\n                return _ + 1\n        return -1\n\n    lines = stdin.split('\\n')\n    N, M, K = map(int, lines[0].split())\n    X, Y = map(int, lines[1].split())\n    board = [list(map(int, lines[2 + i].strip())) for i in range(K)]\n\n    return str(simulate(board, X, Y, 'R'))"
    },
    {
        "number": 3137,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def move_bacteria(bacteria, board, steps):\n        moved = set()\n        for i, bacterium in enumerate(bacteria):\n            x, y, direction, x_count = bacterium\n            if (x, y) not in moved:\n                if direction == 'U':\n                    new_x = max(x - 1, 1)\n                    new_y = y\n                elif direction == 'D':\n                    new_x = min(x + 1, len(board))\n                    new_y = y\n                elif direction == 'L':\n                    new_x = x\n                    new_y = max(y - 1, 1)\n                else:\n                    new_x = x\n                    new_y = min(y + 1, len(board[0]))\n                if board[new_x - 1][new_y - 1] != '0':\n                    x_count = int(board[new_x - 1][new_y - 1])\n                else:\n                    x_count = 0\n                bacterium[0] = new_x\n                bacterium[1] = new_y\n            if x_count > 0:\n                if direction == 'U':\n                    bacterium[2] = 'R' if bacterium[2] != 'L' else 'L'\n                elif direction == 'D':\n                    bacterium[2] = 'L' if bacterium[2] != 'L' else 'R'\n                elif direction == 'L':\n                    bacterium[2] = 'U' if bacterium[2] != 'D' else 'D'\n                else:\n                    bacterium[2] = 'D' if bacterium[2] != 'D' else 'U'\n                bacterium[3] -= 1\n            moved.add((x, y))\n        return bacteria, steps + 1\n\n    def is_finished(bacteria, board, steps):\n        if steps > 10000:\n            return -1\n        if len(bacteria) == 0:\n            return -1\n        trap_x, trap_y = trap_location\n        trap_count = 0\n        for bacterium in bacteria:\n            x, y, direction, x_count = bacterium\n            if x == trap_x and y == trap_y:\n                trap_count += 1\n        if trap_count == len(bacteria):\n            return steps\n        else:\n            return -1\n\n    lines = stdin.split('\\n')\n    N, M, K = map(int, lines[0].split())\n    X, Y = map(int, lines[1].split())\n    board = []\n    for i in range(N):\n        row = list(map(int, lines[2 + i]))\n        board.append(row)\n    trap_location = (X, Y)\n    bacteria = []\n    for i in range(K):\n        x, y = map(int, lines[2 + N + i].split())\n        direction = lines[2 + N + K + i][0]\n        bacteria.append([x, y, direction, 0])\n    steps = 0\n    while True:\n        bacteria, steps = move_bacteria(bacteria, board, steps)\n        result = is_finished(bacteria, board, steps)\n        if result != -1:\n            return str(result)"
    },
    {
        "number": 3137,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.readline().split())\n    X, Y = map(int, stdin.readline().split())\n    bacteria = []\n    for i in range(K):\n        X_i, Y_i = map(int, stdin.readline().split())\n        C_i = stdin.readline().strip()\n        matrix = []\n        for _ in range(N):\n            matrix.append(list(stdin.readline().strip()))\n        bacteria.append((X_i, Y_i, C_i, matrix))\n\n    def move(x, y, direction):\n        if direction == 'U':\n            return x - 1, y\n        elif direction == 'R':\n            return x, y + 1\n        elif direction == 'D':\n            return x + 1, y\n        elif direction == 'L':\n            return x, y - 1\n\n    def read_number(x, y, matrix):\n        return int(matrix[x - 1][y - 1])\n\n    def get_new_direction(direction, turns):\n        for _ in range(turns):\n            if direction == 'U':\n                direction = 'L'\n            elif direction == 'L':\n                direction = 'D'\n            elif direction == 'D':\n                direction = 'R'\n            elif direction == 'R':\n                direction = 'U'\n        return direction\n\n    def is_out_of_bounds(x, y):\n        return x < 1 or x > N or y < 1 or y > M\n\n    def get_new_position(x, y, direction):\n        new_x, new_y = move(x, y, direction)\n        if is_out_of_bounds(new_x, new_y):\n            return x, y, get_new_direction(direction, 180)\n        return new_x, new_y, direction\n\n    def play_game(bacteria):\n        time = 0\n        while True:\n            time += 1\n            for i, bacterium in enumerate(bacteria):\n                x, y, direction, matrix = bacterium\n                if x == X and y == Y:\n                    return time\n                number = read_number(x, y, matrix)\n                direction = get_new_direction(direction, number)\n                x, y, direction = get_new_position(x, y, direction)\n                bacteria[i] = (x, y, direction, matrix)\n\n    return str(play_game(bacteria))"
    },
    {
        "number": 3137,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.readline().split())\n    X, Y = map(int, stdin.readline().split())\n    bacteria = []\n    for _ in range(K):\n        Xi, Yi, Ci = stdin.readline().split()\n        Xi, Yi = int(Xi), int(Yi)\n        matrix = []\n        for _ in range(N):\n            row = stdin.readline()\n            matrix.append([int(d) for d in row])\n        bacteria.append((Xi, Yi, Ci, matrix))\n\n    def next_pos(x, y, direction):\n        if direction == 'U':\n            return x - 1, y\n        elif direction == 'R':\n            return x, y + 1\n        elif direction == 'D':\n            return x + 1, y\n        elif direction == 'L':\n            return x, y - 1\n\n    def valid_pos(x, y):\n        return 1 <= x <= N and 1 <= y <= M\n\n    def bacteria_turn(bacteria):\n        for i, (xi, yi, ci, matrix) in enumerate(bacteria):\n            x, y = next_pos(xi, yi, ci)\n            if not valid_pos(x, y):\n                x, y = xi, yi\n                if ci == 'U':\n                    ci = 'L'\n                elif ci == 'R':\n                    ci = 'U'\n                elif ci == 'D':\n                    ci = 'R'\n                elif ci == 'L':\n                    ci = 'D'\n            else:\n                x, y = x, y\n                for _ in range(matrix[xi - 1][yi - 1]):\n                    if ci == 'U':\n                        ci = 'R'\n                    elif ci == 'R':\n                        ci = 'D'\n                    elif ci == 'D':\n                        ci = 'L'\n                    elif ci == 'L':\n                        ci = 'U'\n            bacteria[i] = (x, y, ci, matrix)\n\n    def bacteria_move(bacteria):\n        pos = set()\n        for xi, yi, _, _ in bacteria:\n            pos.add((xi, yi))\n        return pos\n\n    time = 0\n    while True:\n        if (X, Y) in bacteria_move(bacteria):\n            return time\n        bacteria_turn(bacteria)\n        time += 1\n\n    return -1"
    },
    {
        "number": 3138,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    for i in range(n - 1):\n        if arr[i] == arr[i + 1]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3138,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n    total_sum = sum(numbers)\n    total_product = 1\n    for num in numbers:\n        total_product *= num\n    s = [0] * (n + 1)\n    p = [1] * (n + 1)\n    for i in range(1, n + 1):\n        s[i] = s[i - 1] + numbers[i - 1]\n        p[i] = p[i - 1] * numbers[i - 1]\n    count = 0\n    for i in range(2, n + 1):\n        for j in range(i, n + 1):\n            if s[j] - s[i - 1] == total_sum - s[j]:\n                count += 1\n            if p[j] // numbers[i - 1] == p[j - i] // numbers[i - 1]:\n                count += 1\n    return str(count // 2)"
    },
    {
        "number": 3138,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(n - 1):\n        if numbers[i] == numbers[i + 1]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3138,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    pages = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    for i in range(n - 1):\n        if pages[i] == pages[i + 1]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3138,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(n - 1):\n        if arr[i] == arr[i + 1]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3138,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n    count = 0\n    for i in range(n - 1):\n        if arr[i] == arr[i + 1]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3138,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = list(map(int, stdin.split(\"\\n\")[1].split()))\n    count = 0\n    for i in range(n - 1):\n        if arr[i] == arr[i + 1]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3138,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pages = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(n - 1):\n        if pages[i] == pages[i + 1]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3138,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    numbers = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    for i in range(n - 1):\n        if numbers[i] == numbers[i + 1]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3138,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    integers = [int(x) for x in stdin.split('\\n')[1].split(' ') if x]\n\n    s = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if sum(integers[i:j + 1]) == 10 * integers[i] + integers[j]:\n                s += 1\n\n    return str(s)"
    },
    {
        "number": 3139,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    students = []\n    output = []\n\n    for line in input_list[1:]:\n        if line[0] == 'D':\n            A, B = map(int, line.split()[1:])\n            students.append((A, B))\n        elif line[0] == 'P':\n            i = int(line.split()[1]) - 1\n            helper = -1\n            min_diff = float('inf')\n            for j, (A, B) in enumerate(students):\n                if A >= students[i][0] and B >= students[i][1]:\n                    diff = abs(A - students[i][0]) + abs(B - students[i][1])\n                    if diff < min_diff:\n                        helper = j + 1\n                        min_diff = diff\n            output.append(f\"{helper}\" if helper != -1 else \"NE\")\n\n    return '\\n'.join(output)\n\nsample_input_1 = \"\"\"6\nD 3 1\nD 2 2\nD 1 3\nP 1\nP 2\nP 3\"\"\"\n\nsample_output_1 = \"\"\"NE\nNE\nNE\"\"\"\n\nassert solution(sample_input_1) == sample_output_1\n\nsample_input_2 = \"\"\"6\nD 8 8\nD 2 4\nD 5 6\nP 2\nD 6 2\nP 4\"\"\"\n\nsample_output_2 = \"\"\"3\n1\nNE\"\"\"\n\nassert solution(sample_input_2) == sample_output_2 "
    },
    {
        "number": 3139,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    students = []\n    for line in stdin.split('\\n'):\n        if line.startswith('D'):\n            _, A, B = line.split()\n            students.append((int(A), int(B)))\n        elif line.startswith('P'):\n            _, i = line.split()\n            i = int(i) - 1\n            can_help = False\n            for j, (A, B) in enumerate(students):\n                if A >= students[i][0] and B >= students[i][1]:\n                    can_help = True\n                    break\n            if can_help:\n                print(j + 1)\n            else:\n                print(\"NE\")"
    },
    {
        "number": 3139,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    students = []\n    for line in stdin.split(\"\\n\"):\n        if line.startswith(\"D\"):\n            _, a, b = line.split()\n            students.append((int(a), int(b)))\n        elif line.startswith(\"P\"):\n            _, i = line.split()\n            i = int(i) - 1\n            found = False\n            for j, (a, b) in enumerate(students):\n                if i != j and a >= students[i][0] and b >= students[i][1] and (not found or abs(a - students[i][0]) <= abs(students[found][0] - students[i][0]) or (abs(a - students[i][0]) == abs(students[found][0] - students[i][0]) and abs(b - students[i][1]) < abs(students[found][1] - students[i][1]))):\n                    found = j\n            print(students[i][0], students[i][1], found)\n            if found is not False:\n                print(found + 1)\n            else:\n                print(\"NE\")"
    },
    {
        "number": 3139,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    class Student:\n        def __init__(self, a, b):\n            self.a = a\n            self.b = b\n\n    students = []\n    num_queries = int(stdin.splitlines()[0])\n    queries = stdin.splitlines()[1:]\n\n    for query in queries:\n        if query[0] == 'D':\n            a, b = map(int, query.split()[1:])\n            students.append(Student(a, b))\n        elif query[0] == 'P':\n            i = int(query.split()[1]) - 1\n            best_match = None\n            min_diff_a = min_diff_b = float('inf')\n\n            for j, student in enumerate(students):\n                if student.a >= students[i].a and student.b >= students[i].b:\n                    diff_a = student.a - students[i].a\n                    diff_b = student.b - students[i].b\n\n                    if diff_a < min_diff_a or (diff_a == min_diff_a and diff_b < min_diff_b):\n                        min_diff_a = diff_a\n                        min_diff_b = diff_b\n                        best_match = j + 1\n\n            print(best_match if best_match else 'NE')"
    },
    {
        "number": 3139,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    n = int(stdin[0])\n    students = []\n    output = []\n\n    for i in range(1, n):\n        line = stdin[i].split()\n        if line[0] == \"D\":\n            students.append((int(line[1]), int(line[2]), i))\n        elif line[0] == \"P\":\n            i_student = int(line[1])\n            max_a, max_b, best_student = -1, -1, -1\n            for student in students:\n                if student[0] >= max_a and student[1] >= max_b:\n                    if student[0] > max_a or student[1] > max_b:\n                        max_a, max_b, best_student = student[0], student[1], student[2]\n            output.append(best_student if best_student != -1 else \"NE\")\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3139,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_best_student(A, B):\n        best_student = None\n        min_diff = float('inf')\n        for i, (a, b) in enumerate(students, 1):\n            if a >= A and b >= B:\n                diff = abs(a - A) + abs(b - B)\n                if diff < min_diff:\n                    min_diff = diff\n                    best_student = i\n        return best_student\n\n    def process_query(query):\n        if query[0] == 'D':\n            A, B = map(int, query[1:])\n            students.append((A, B))\n        else:\n            i = int(query[1])\n            best_student = find_best_student(students[i-1][0], students[i-1][1])\n            if best_student is None:\n                print(\"NE\")\n            else:\n                print(best_student)\n\n    students = []\n    for query in stdin.splitlines():\n        process_query(query.split())\n"
    },
    {
        "number": 3139,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_helper(student_a, student_b, candidates):\n        best_candidate = None\n        min_diff = float('inf')\n\n        for candidate in candidates:\n            candidate_a, candidate_b = candidate\n\n            if candidate_a >= student_a and candidate_b >= student_b:\n                diff = abs(candidate_a - student_a) + abs(candidate_b - student_b)\n\n                if diff < min_diff:\n                    min_diff = diff\n                    best_candidate = candidate\n\n        return best_candidate\n\n    students = []\n    queries = []\n\n    for line in stdin.split('\\n'):\n        command, *args = line.split()\n\n        if command == 'D':\n            a, b = map(int, args)\n            students.append((a, b))\n        elif command == 'P':\n            i = int(args[0])\n            queries.append(i)\n\n    result = []\n    for i in queries:\n        candidates = [student for j, student in enumerate(students, start=1) if j != i]\n        helper = find_helper(students[i-1][0], students[i-1][1], candidates)\n\n        if helper is not None:\n            result.append(students.index(helper) + 1)\n        else:\n            result.append('NE')\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3139,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_help(A, B, students):\n        best_match = None\n        min_diff = float('inf')\n        for i, (A_, B_) in enumerate(students):\n            if A_ >= A and B_ >= B:\n                diff = abs(A - A_) + abs(B - B_)\n                if diff < min_diff:\n                    min_diff = diff\n                    best_match = i + 1\n        return best_match\n\n    def process_query(query, students):\n        if query[0] == 'D':\n            A, B = map(int, query[1:])\n            students.append((A, B))\n        elif query[0] == 'P':\n            i = int(query[1])\n            return find_help(students[i - 1][0], students[i - 1][1], students)\n\n    N = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n    students = []\n\n    output = []\n    for query in queries:\n        result = process_query(query.split(), students)\n        if result is not None:\n            output.append(str(result))\n        else:\n            output.append(\"NE\")\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3139,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    N = int(lines[0])\n    students = []\n\n    for i in range(1, N):\n        query, A, B = lines[i].split()\n        A = int(A)\n        B = int(B)\n\n        if query == 'D':\n            students.append((A, B))\n        else:\n            i = int(query[1:]) - 1\n            best_student = -1\n            best_diff = float('inf')\n\n            for j, (A2, B2) in enumerate(students):\n                if A <= A2 and B <= B2:\n                    diff = abs(A2 - A) + abs(B2 - B)\n                    if diff < best_diff:\n                        best_diff = diff\n                        best_student = j\n\n            if best_student == -1:\n                print(\"NE\")\n            else:\n                print(best_student + 1)"
    },
    {
        "number": 3139,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    students = []\n    for i in range(int(stdin[0])):\n        query, *args = stdin[i + 1].split(' ')\n        if query == 'D':\n            A, B = map(int, args)\n            students.append((A, B))\n        elif query == 'P':\n            i = int(args[0]) - 1\n            candidates = []\n            for j, (A2, B2) in enumerate(students):\n                if A2 >= students[i][0] and B2 >= students[i][1]:\n                    candidates.append((j + 1, abs(A2 - students[i][0]) + abs(B2 - students[i][1])))\n            if not candidates:\n                print(\"NE\")\n            else:\n                candidates.sort(key=lambda x: x[1])\n                print(candidates[0][0])\n                if len(candidates) > 1 and candidates[0][1] != candidates[1][1]:\n                    candidates = [c for c in candidates if c[1] == candidates[0][1]]\n                    candidates.sort(key=lambda x: abs(x[0] - i - 1))\n                    print(candidates[0][0])\n\ninput_str = '''10\nD 3 1\nD 2 2\nD 1 3\nP 1\nD 8 8\nD 2 4\nD 5 6\nP 2\nP 3\nD 6 2\nP 4'''\n\nsolution(input_str)"
    },
    {
        "number": 3140,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    r, c, k, l = map(int, stdin.readline().split())\n    x0, y0 = map(int, stdin.readline().split())\n    t = [list(map(int, stdin.readline().split())) for _ in range(r)]\n\n    # Initialize variables\n    visited = set()\n    queue = [(x0, y0, 0)]\n\n    # BFS to find fishable points\n    while queue:\n        x, y, time = queue.pop(0)\n        visited.add((x, y))\n\n        # Check if fish are available\n        if t[x][y] + k > time >= t[x][y]:\n            for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < r and 0 <= ny < c and (nx, ny) not in visited and time + 1 <= t[nx][ny] + k:\n                    queue.append((nx, ny, time + 1))\n\n    # Count fishable points\n    fishable_points = len(visited)\n    return str(fishable_points)"
    },
    {
        "number": 3140,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y, t, k, l):\n        return t + k <= l\n\n    def dfs(x, y, visited, t, k, l, r, c):\n        if not (0 <= x < r and 0 <= y < c) or visited[x][y]:\n            return 0\n        if not is_valid(x, y, t[x][y], k, l):\n            return 0\n        visited[x][y] = True\n        return 1 + dfs(x + 1, y, visited, t, k, l, r, c) + \\\n               dfs(x - 1, y, visited, t, k, l, r, c) + \\\n               dfs(x, y + 1, visited, t, k, l, r, c) + \\\n               dfs(x, y - 1, visited, t, k, l, r, c)\n\n    r, c, k, l = map(int, stdin.readline().split())\n    x0, y0 = map(int, stdin.readline().split())\n    t = [[0] * c for _ in range(r)]\n    for i in range(r):\n        t[i] = list(map(int, stdin.readline().split()))\n\n    visited = [[False] * c for _ in range(r)]\n    return str(dfs(x0, y0, visited, t, k, l, r, c))"
    },
    {
        "number": 3140,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    r, c, k, l, x0, y0, t = map(int, stdin.split())\n    t = [list(map(int, line.split())) for line in t.split('\\n')]\n\n    # Initialize variables\n    points_caught = [[0 for _ in range(c)] for _ in range(r)]\n    points_visited = [[False for _ in range(c)] for _ in range(r)]\n\n    def can_catch_fish(x: int, y: int, time: int) -> bool:\n        return t[x][y] <= time <= t[x][y] + k\n\n    def move(x: int, y: int, dx: int, dy: int) -> tuple:\n        return x + dx, y + dy\n\n    def dfs(x: int, y: int, time: int) -> None:\n        if not (0 <= x < r and 0 <= y < c) or points_visited[x][y]:\n            return\n\n        if can_catch_fish(x, y, time):\n            points_caught[x][y] = 1\n\n        points_visited[x][y] = True\n\n        for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\n            dfs(*move(x, y, dx, dy), time + 1)\n\n        points_visited[x][y] = False\n\n    # Calculate points caught\n    dfs(x0, y0, 1)\n\n    # Count total points caught\n    total_points_caught = sum(sum(row) for row in points_caught)\n\n    return str(total_points_caught)"
    },
    {
        "number": 3140,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l = map(int, stdin.readline().split())\n    x0, y0 = map(int, stdin.readline().split())\n\n    fish_times = []\n    for i in range(r):\n        fish_times.append(list(map(int, stdin.readline().split())))\n\n    def is_valid(x, y, t):\n        if 0 <= x < r and 0 <= y < c:\n            if t >= fish_times[x][y]:\n                return True\n        return False\n\n    def dfs(x, y, t, visited):\n        if not is_valid(x, y, t):\n            return 0\n\n        if (x, y, t) in visited:\n            return 0\n\n        visited.add((x, y, t))\n\n        if t + k >= l:\n            return 1\n\n        n = dfs(x - 1, y, t + 1, visited)\n        w = dfs(x, y - 1, t + 1, visited)\n        s = dfs(x + 1, y, t + 1, visited)\n        e = dfs(x, y + 1, t + 1, visited)\n\n        return n + w + s + e\n\n    visited = set()\n    result = dfs(x0, y0, 1, visited)\n    return str(result)"
    },
    {
        "number": 3140,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l, x0, y0, t = map(int, stdin.split())\n    t = list(map(int, t.split()))\n    t = [t[i:i + c] for i in range(0, len(t), c)]\n\n    def is_available(x, y, time):\n        if 0 <= x < r and 0 <= y < c and t[x][y] <= time < t[x][y] + k:\n            return True\n        return False\n\n    def dfs(x, y, time, visited):\n        if not is_available(x, y, time):\n            return 0\n        if (x, y) in visited:\n            return 0\n        if time >= l:\n            return 1\n        visited.add((x, y))\n        return (dfs(x - 1, y, time + 1, visited) +\n                dfs(x, y - 1, time + 1, visited) +\n                dfs(x + 1, y, time + 1, visited) +\n                dfs(x, y + 1, time + 1, visited))\n\n    return str(dfs(x0, y0, 1, set()))"
    },
    {
        "number": 3140,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l, x_0, y_0, t = 0, 0, 0, 0, 0, 0, []\n    # Read input\n    for i, line in enumerate(stdin.split('\\n')):\n        if i == 0:\n            r, c, k, l = list(map(int, line.split()))\n        elif i == 1:\n            x_0, y_0 = list(map(int, line.split()))\n        else:\n            t.append(list(map(int, line.split())))\n    # Initialize variables\n    max_points = 0\n    visited = [[False for _ in range(c)] for _ in range(r)]\n    # Move up\n    for i in range(x_0 - 1, -1, -1):\n        if t[i][y_0] <= l:\n            max_points += 1\n            visited[i][y_0] = True\n        else:\n            break\n    # Move down\n    for i in range(x_0 + 1, r):\n        if t[i][y_0] <= l:\n            max_points += 1\n            visited[i][y_0] = True\n        else:\n            break\n    # Move left\n    for j in range(y_0 - 1, -1, -1):\n        if t[x_0][j] <= l:\n            max_points += 1\n            visited[x_0][j] = True\n        else:\n            break\n    # Move right\n    for j in range(y_0 + 1, c):\n        if t[x_0][j] <= l:\n            max_points += 1\n            visited[x_0][j] = True\n        else:\n            break\n    return str(max_points)"
    },
    {
        "number": 3140,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y, t):\n        return 1 <= x < r and 1 <= y < c and t >= t_[x][y] and t < t_[x][y] + k\n\n    def dfs(x, y, t, visited):\n        if not is_valid(x, y, t):\n            return 0\n        if (x, y) in visited:\n            return 0\n        if t > l:\n            return 0\n\n        visited.add((x, y))\n        return 1 + dfs(x + 1, y, t + 1, visited) + dfs(x - 1, y, t + 1, visited) + dfs(x, y + 1, t + 1, visited) + dfs(x, y - 1, t + 1, visited)\n\n    r, c, k, l, x0, y0 = map(int, stdin.split()[0].split())\n    t_ = [[int(x) for x in stdin.split()[i + 1]] for i in range(r)]\n\n    visited = set()\n    return str(dfs(x0, y0, 1, visited))"
    },
    {
        "number": 3140,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l, x0, y0, t = map(int, stdin.split())\n    t = [list(map(int, input().split())) for _ in range(r)]\n\n    def dfs(x, y, time):\n        if time > l:\n            return 0\n        if x < 0 or x >= r or y < 0 or y >= c or t[x][y] + k < time:\n            return 0\n        if (x, y, time) in visited:\n            return visited[(x, y, time)]\n\n        visited[(x, y, time)] = max(dfs(x - 1, y, time + 1), dfs(x, y - 1, time + 1), dfs(x + 1, y, time + 1), dfs(x, y + 1, time + 1), 1)\n        return visited[(x, y, time)]\n\n    visited = {}\n    return str(dfs(x0, y0, 1))"
    },
    {
        "number": 3140,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l, x0, y0, t = map(int, stdin.split())\n    t = [list(map(int, input().split())) for _ in range(r)]\n\n    def dfs(x, y, time):\n        if time > l:\n            return 0\n        if x < 0 or x >= r or y < 0 or y >= c or time < t[x][y]:\n            return 0\n        if (x, y) in visited:\n            return visited[(x, y)]\n\n        visited[(x, y)] = dfs(x - 1, y, time + 1) + dfs(x + 1, y, time + 1) + \\\n                     dfs(x, y - 1, time + 1) + dfs(x, y + 1, time + 1) + 1\n        return visited[(x, y)]\n\n    visited = {}\n    result = dfs(x0, y0, 1)\n\n    return str(result)"
    },
    {
        "number": 3140,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    r, c, k, l = map(int, lines[0].split())\n    x_0, y_0 = map(int, lines[1].split())\n    t = [[0] * c for _ in range(r)]\n    for i in range(r):\n        t[i] = list(map(int, lines[2 + i].split()))\n\n    def can_catch_fish(x: int, y: int, time: int) -> bool:\n        if 0 <= x < r and 0 <= y < c:\n            return t[x][y] <= time < t[x][y] + k\n        return False\n\n    def dfs(x: int, y: int, time: int, visited: set) -> int:\n        if not can_catch_fish(x, y, time):\n            return 0\n        if (x, y) in visited:\n            return 0\n        visited.add((x, y))\n\n        next_positions = [(x - 1, y), (x, y - 1), (x, y + 1), (x + 1, y)]\n        max_points = 0\n        for x_next, y_next in next_positions:\n            max_points = max(max_points, dfs(x_next, y_next, time + 1, visited))\n\n        return 1 + max_points\n\n    max_points = dfs(x_0, y_0, 1, set())\n    return str(max_points)"
    },
    {
        "number": 3141,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def euclidean_distance(x1, y1, z1, x2, y2, z2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2) ** 0.5\n\n    def smallest_diameter(flaws):\n        flaws = sorted(flaws, key=lambda flaw: flaw[0])\n        diameter = 0\n        for i in range(len(flaws) - 1):\n            max_distance = max(\n                euclidean_distance(flaws[i][0], flaws[i][1], flaws[i][2], flaws[i + 1][0], flaws[i + 1][1], flaws[i + 1][2]),\n                euclidean_distance(flaws[i][0], flaws[i][1] + 1, flaws[i][2], flaws[i + 1][0], flaws[i + 1][1] + 1, flaws[i + 1][2]),\n                euclidean_distance(flaws[i][0], flaws[i][1], flaws[i][2] + 1, flaws[i + 1][0], flaws[i + 1][1], flaws[i + 1][2] + 1)\n            )\n            diameter = max(diameter, max_distance)\n        return diameter\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    flaws = [list(map(float, line.split())) for line in lines[1:N + 1]]\n\n    return f\"{smallest_diameter(flaws):.10f}\""
    },
    {
        "number": 3141,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_diameter(flaws: List[Tuple[float]]) -> float:\n        xs, ys, zs = zip(*flaws)\n        x_range, y_range, z_range = max(xs) - min(xs), max(ys) - min(ys), max(zs) - min(zs)\n        return 2 * (x_range + y_range + z_range)\n\n    N = int(stdin.readline().strip())\n    flaws = [tuple(map(float, stdin.readline().strip().split())) for _ in range(N)]\n\n    return f\"{calculate_diameter(flaws):.10f}\""
    },
    {
        "number": 3141,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_radius(x, y, z):\n        return abs(x) + abs(y) + abs(z)\n\n    N = int(stdin.readline())\n    flaws = [list(map(float, stdin.readline().split())) for _ in range(N)]\n\n    radius = 0\n    for flaw in flaws:\n        radius = max(radius, calculate_radius(*flaw))\n\n    return f\"{radius:.10f}\"\n"
    },
    {
        "number": 3141,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    flaws = [list(map(float, stdin.readline().strip().split())) for _ in range(N)]\n    \n    x_values = [flaw[0] for flaw in flaws]\n    y_values = [flaw[1] for flaw in flaws]\n    z_values = [flaw[2] for flaw in flaws]\n    \n    max_x = max(x_values)\n    min_x = min(x_values)\n    max_y = max(y_values)\n    min_y = min(y_values)\n    max_z = max(z_values)\n    min_z = min(z_values)\n    \n    diameter = max(max_x - min_x, max_y - min_y, max_z - min_z)\n    \n    return f\"{diameter:.10f}\""
    },
    {
        "number": 3141,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    flaws = []\n    for i in range(n):\n        x, y, z = map(float, lines[i+1].split())\n        flaws.append((x, y, z))\n    \n    xs, ys, zs = zip(*flaws)\n    x_range = max(xs) - min(xs)\n    y_range = max(ys) - min(ys)\n    z_range = max(zs) - min(zs)\n    \n    diam = max(x_range, y_range, z_range) * 2\n    return str(diam)"
    },
    {
        "number": 3141,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    flaws = []\n    for i in range(1, n+1):\n        flaws.append(list(map(float, lines[i].split())))\n    \n    diameter = 0.0\n    for i in range(n):\n        for j in range(i+1, n):\n            x1, y1, z1 = flaws[i]\n            x2, y2, z2 = flaws[j]\n            distance = ((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)**0.5\n            diameter = max(diameter, distance)\n    \n    return \"{:.10f}\".format(diameter)"
    },
    {
        "number": 3141,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    flaws = [(float(x), float(y), float(z)) for x, y, z in [line.split(' ') for line in lines[1:N+1]]]\n\n    x_min, x_max = min(flaws, key=lambda x: x[0])[0], max(flaws, key=lambda x: x[0])[0]\n    y_min, y_max = min(flaws, key=lambda x: x[1])[1], max(flaws, key=lambda x: x[1])[1]\n    z_min, z_max = min(flaws, key=lambda x: x[2])[2], max(flaws, key=lambda x: x[2])[2]\n\n    diameter = max(x_max - x_min, y_max - y_min, z_max - z_min)\n    return f\"{diameter:.10f}\""
    },
    {
        "number": 3141,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    flaws = [(float(x.split()[0]), float(x.split()[1]), float(x.split()[2])) for x in stdin.split('\\n')[1:]]\n\n    diameter = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            diameter = max(diameter, ((flaws[i][0]-flaws[j][0])**2 + (flaws[i][1]-flaws[j][1])**2 + (flaws[i][2]-flaws[j][2])**2)**0.5)\n\n    return format(diameter, \".10f\")"
    },
    {
        "number": 3141,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_diameter(flaws):\n        max_distance = 0.0\n        for i in range(len(flaws)):\n            for j in range(i + 1, len(flaws)):\n                distance = ((flaws[i][0] - flaws[j][0]) ** 2 +\n                           (flaws[i][1] - flaws[j][1]) ** 2 +\n                           (flaws[i][2] - flaws[j][2]) ** 2) ** 0.5\n                if distance > max_distance:\n                    max_distance = distance\n        return max_distance * 2\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    flaws = []\n    for i in range(1, N + 1):\n        flaw = list(map(float, lines[i].split()))\n        flaws.append(flaw)\n\n    diameter = calculate_diameter(flaws)\n    return f\"{diameter:.10f}\""
    },
    {
        "number": 3141,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    flaws = []\n    for line in lines[1:]:\n        x, y, z = map(float, line.split())\n        flaws.append((x, y, z))\n    diam = 0\n    for flaw in flaws:\n        dist = max(abs(flaw[0]), abs(flaw[1]), abs(flaw[2]))\n        diam = max(diam, 2 * dist)\n    return f\"{diam:.10f}\""
    },
    {
        "number": 3142,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    min_num = None\n    for num in range(A, B + 1):\n        digit_sum = sum(int(digit) for digit in str(num))\n        if digit_sum == S:\n            count += 1\n            if min_num is None or num < min_num:\n                min_num = num\n    return f\"{count}\\n{min_num}\""
    },
    {
        "number": 3142,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    min_num = None\n    for num in range(A, B + 1):\n        digit_sum = sum(int(digit) for digit in str(num))\n        if digit_sum == S:\n            count += 1\n            if min_num is None or num < min_num:\n                min_num = num\n    return f\"{count}\\n{min_num}\""
    },
    {
        "number": 3142,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    min_num = None\n\n    for num in range(A, B + 1):\n        digit_sum = sum(int(digit) for digit in str(num))\n        if digit_sum == S:\n            count += 1\n            if min_num is None or num < min_num:\n                min_num = num\n\n    return f\"{count}\\n{min_num}\""
    },
    {
        "number": 3142,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n\n    count = 0\n    min_num = float('inf')\n\n    for num in range(A, B + 1):\n        digit_sum = sum(int(digit) for digit in str(num))\n\n        if digit_sum == S:\n            count += 1\n            min_num = min(min_num, num)\n\n    return f\"{count}\\n{min_num}\""
    },
    {
        "number": 3142,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    \n    count = 0\n    smallest = None\n\n    for num in range(A, B + 1):\n        digit_sum = sum(map(int, str(num)))\n\n        if digit_sum == S:\n            count += 1\n            if smallest is None or num < smallest:\n                smallest = num\n\n    return f\"{count}\\n{smallest}\""
    },
    {
        "number": 3142,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    min_num = None\n\n    for num in range(A, B + 1):\n        if sum(int(digit) for digit in str(num)) == S:\n            count += 1\n            if min_num is None or num < min_num:\n                min_num = num\n\n    return f\"{count}\\n{min_num}\""
    },
    {
        "number": 3142,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    min_num = None\n    \n    for num in range(A, B + 1):\n        digit_sum = sum(int(digit) for digit in str(num))\n        if digit_sum == S:\n            count += 1\n            if min_num is None or num < min_num:\n                min_num = num\n                \n    return f\"{count}\\n{min_num}\""
    },
    {
        "number": 3142,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    min_number = None\n    \n    for i in range(A, B + 1):\n        digit_sum = sum(int(digit) for digit in str(i))\n        if digit_sum == S:\n            count += 1\n            if min_number is None or i < min_number:\n                min_number = i\n    \n    return f\"{count}\\n{min_number}\""
    },
    {
        "number": 3142,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    min_num = None\n    for num in range(A, B + 1):\n        if sum(int(digit) for digit in str(num)) == S:\n            count += 1\n            if min_num is None or num < min_num:\n                min_num = num\n    return f\"{count}\\n{min_num}\""
    },
    {
        "number": 3142,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    result = B\n\n    for i in range(A, B + 1):\n        if sum(int(digit) for digit in str(i)) == S:\n            count += 1\n            result = min(result, i)\n\n    return f\"{count}\\n{result}\""
    },
    {
        "number": 3143,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(x: int, y: int) -> int:\n        return (x * y) // gcd(x, y)\n\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    def binary_search(arr: List[int], target: int) -> int:\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    def find_positions(names: List[int], initial: List[int]) -> List[int]:\n        positions = []\n        for name in names:\n            index = binary_search(initial, name)\n            positions.append(index)\n        return positions\n\n    def find_optimal_positions(names: List[int], initial: List[int]) -> List[int]:\n        positions = find_positions(names, initial)\n        optimal_positions = [0] * len(positions)\n        for i, pos in enumerate(positions):\n            optimal_positions[i] = pos\n            initial.insert(pos, initial.pop(0))\n        return optimal_positions\n\n    def count_inspections(names: List[int], positions: List[int]) -> int:\n        inspections = 0\n        for i, name in enumerate(names):\n            if positions[i] == -1:\n                continue\n            while positions[i] < len(positions) - 1 and positions[i] != name - 1:\n                positions[i] += 1\n                inspections += 1\n        return inspections\n\n    def find_minimal_inspections(names: List[int], initial: List[int]) -> Tuple[int, List[int]]:\n        positions = find_optimal_positions(names, initial)\n        inspections = count_inspections(names, positions)\n        return inspections, positions\n\n    def parse_input(stdin: str) -> Tuple[int, List[int], List[int]]:\n        N, M = map(int, stdin.split()[0:2])\n        names = list(map(int, stdin.split()[2:2 + M]))\n        initial = list(map(int, stdin.split()[2 + M:]))\n        return N, names, initial\n\n    N, names, initial = parse_input(stdin)\n    inspections, positions = find_minimal_inspections(names, initial)\n    return f\"{inspections}\\n{' '.join(map(str, positions))}\" "
    },
    {
        "number": 3143,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_position(name, order):\n        for i, val in enumerate(order):\n            if val == name:\n                return i + 1\n        return -1\n\n    def find_new_position(current_position, new_position, order):\n        if current_position <= new_position:\n            return new_position - current_position\n        else:\n            return new_position + (len(order) - current_position)\n\n    def count_inspections(names, order):\n        inspections = []\n        for i, name in enumerate(names):\n            current_position = find_position(name, order)\n            new_position = find_new_position(current_position, len(inspections), order)\n            inspections.insert(new_position - 1, name)\n        return len(inspections), inspections\n\n    lines = stdin.strip().split('\\n')\n    N, M = map(int, lines[0].split())\n    names = list(map(int, lines[1].split()))\n    order = list(map(int, lines[2].split()))\n\n    min_inspections, optimal_order = count_inspections(names, order)\n    output = f\"{min_inspections}\\n\"\n    output += \" \".join(map(str, optimal_order))\n    return output"
    },
    {
        "number": 3143,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_next_name(list_names, start_index):\n        for i in range(start_index, len(list_names)):\n            if list_names[i] is not None:\n                return list_names[i], i\n        return None, -1\n\n    def find_name_position(list_names, name):\n        for i in range(len(list_names)):\n            if list_names[i] == name:\n                return i\n        return -1\n\n    def find_optimal_positions(list_names, initial_order):\n        positions = []\n        for i in range(len(list_names)):\n            name, index = find_next_name(list_names, i)\n            if name is not None:\n                position = find_name_position(initial_order, name)\n                positions.append(position)\n                list_names[index] = None\n        return positions\n\n    lines = stdin.splitlines()\n    N, M = map(int, lines[0].split())\n    list_names = list(map(int, lines[1].split()))\n    initial_order = list(map(int, lines[2].split()))\n\n    optimal_positions = find_optimal_positions(list_names, initial_order)\n\n    output = [str(len(optimal_positions)), ' '.join(map(str, optimal_positions))]\n    return '\\n'.join(output) "
    },
    {
        "number": 3143,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, M = map(int, stdin.readline().split())\n    attendance_list = list(map(int, stdin.readline().split()))\n    initial_order = list(map(int, stdin.readline().split()))\n\n    # Create a dictionary to store the position of each student in the initial line\n    position_dict = {}\n    for i in range(N):\n        position_dict[initial_order[i]] = i\n\n    # Create a set to store the students who have already been inspected\n    inspected = set()\n\n    # Initialize variables\n    inspections = 0\n    optimal_positions = []\n\n    # Iterate through the attendance list\n    for name in attendance_list:\n        # If the student has not been inspected yet, inspect them\n        if name not in inspected:\n            # Update the inspections count\n            inspections += 1\n\n            # Find the position of the student in the initial line\n            current_position = position_dict[name]\n\n            # Find the new position of the student (move to the back of the line)\n            new_position = N - 1\n\n            # Update the position dictionary\n            position_dict[name] = new_position\n\n            # Update the optimal positions list\n            optimal_positions.append(new_position + 1)\n\n            # Add the student to the inspected set\n            inspected.add(name)\n\n    # Return the output\n    return f\"{inspections}\\n{' '.join(map(str, optimal_positions))}\" "
    },
    {
        "number": 3143,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_new_position(name: int, current_position: int, list_order: List[int]) -> int:\n        for i in range(current_position + 1, len(list_order) + 1):\n            if list_order[i - 1] == name:\n                return i\n        return 1\n\n    def count_inspections(list_order: List[int], student_positions: List[int]) -> Tuple[int, List[int]]:\n        inspections = []\n        current_position = 1\n        inspection_count = 0\n\n        for name in list_order:\n            new_position = find_new_position(name, current_position, student_positions)\n            inspections.append(new_position)\n            inspection_count += 1\n            current_position = new_position\n\n        return inspection_count, inspections\n\n    def find_optimal_positions(list_order: List[int], student_positions: List[int]) -> Tuple[int, List[int]]:\n        students_count = len(student_positions)\n        min_inspections = students_count\n        optimal_positions = []\n\n        for i in range(students_count):\n            new_list_order = list_order[i:] + list_order[:i]\n            new_student_positions = student_positions[i:] + student_positions[:i]\n\n            inspection_count, inspections = count_inspections(new_list_order, new_student_positions)\n\n            if inspection_count < min_inspections:\n                min_inspections = inspection_count\n                optimal_positions = inspections\n\n        return min_inspections, optimal_positions\n\n    lines = stdin.strip().split('\\n')\n    students_count, names_count = map(int, lines[0].split())\n    list_order = list(map(int, lines[1].split()))\n    student_positions = list(map(int, lines[2].split()))\n\n    min_inspections, optimal_positions = find_optimal_positions(list_order, student_positions)\n\n    return f\"{min_inspections}\\n\" + ' '.join(map(str, optimal_positions)) + '\\n'"
    },
    {
        "number": 3143,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split('\\n')[0].split())\n    lst = list(map(int, stdin.split('\\n')[1].split()))\n    order = list(map(int, stdin.split('\\n')[2].split()))\n    \n    cnt = 0\n    res = []\n    \n    while lst:\n        cnt += 1\n        name = lst.pop(0)\n        idx = order.index(name)\n        res.append(idx + 1)\n        order.remove(name)\n        order.append(name)\n    \n    return f\"{cnt}\\n{' '.join(map(str, res))}\""
    },
    {
        "number": 3143,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_next_index(arr, index):\n        if index == len(arr) - 1:\n            return 0\n        return index + 1\n\n    def find_position(line_order, index, name):\n        return line_order.index(name) + 1\n\n    N, M = map(int, stdin.readline().split())\n    attendance_list = list(map(int, stdin.readline().split()))\n    line_order = list(map(int, stdin.readline().split()))\n\n    positions = []\n    for i, name in enumerate(attendance_list):\n        index = line_order.index(name)\n        line_order[index] = -1\n        positions.append(find_position(line_order, index, name))\n        line_order[index] = name\n\n    output = [str(len(attendance_list)), \" \".join(map(str, positions))]\n    return \"\\n\".join(output)"
    },
    {
        "number": 3143,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_position(name, b):\n        for i in range(len(b)):\n            if b[i] == name:\n                return i + 1\n        return -1\n\n    def optimal_position(name, b):\n        position = find_position(name, b)\n        if position == len(b):\n            return 1\n        return position + 1\n\n    def calculate_min_inspections(N, M, a, b):\n        students_dict = {}\n        for i in range(M):\n            if a[i] in students_dict:\n                students_dict[a[i]].append(i)\n            else:\n                students_dict[a[i]] = [i]\n\n        inspections = []\n        for name, positions in students_dict.items():\n            inspection_positions = [optimal_position(name, b)] * len(positions)\n            inspections.extend(inspection_positions)\n\n        return len(inspections), inspections\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n\n    min_inspections, optimal_positions = calculate_min_inspections(N, M, a, b)\n\n    return f\"{min_inspections}\\n{' '.join(map(str, optimal_positions))}\""
    },
    {
        "number": 3143,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    attendance_list = list(map(int, stdin.readline().split()))\n    initial_order = list(map(int, stdin.readline().split()))\n\n    attendance_dict = {}\n    for i in range(len(attendance_list)):\n        if attendance_list[i] in attendance_dict:\n            attendance_dict[attendance_list[i]].append(i)\n        else:\n            attendance_dict[attendance_list[i]].append(i)\n\n    final_order = initial_order.copy()\n    inspections = []\n    total_inspections = 0\n\n    for name in attendance_list:\n        if len(attendance_dict[name]) > 1:\n            indices = attendance_dict[name]\n            for i in range(len(indices) - 1):\n                final_order[indices[i]] = initial_order[indices[-1]]\n                inspections.append(initial_order[indices[-1]])\n                total_inspections += 1\n        attendance_dict[name] = [0]\n\n    inspections.append(final_order[0])\n    total_inspections += 1\n\n    output = [str(total_inspections)]\n    output.append(\" \".join(map(str, inspections)))\n    return \"\\n\".join(output)"
    },
    {
        "number": 3143,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_next_name(name_list, index):\n        for i in range(index + 1, len(name_list)):\n            if name_list[i] == name_list[index]:\n                return i\n        return -1\n\n    def find_position(name_list, position_list, index):\n        name = name_list[index]\n        next_index = find_next_name(name_list, index)\n        if next_index == -1:\n            return position_list[name - 1]\n        if next_index == len(name_list) - 1:\n            return position_list[name - 1]\n        if name_list[next_index + 1] == name:\n            return position_list[name - 1]\n        return position_list[next_index + 1]\n\n    def find_optimal_positions(name_list, position_list):\n        optimal_positions = []\n        index = 0\n        while index < len(name_list):\n            optimal_positions.append(find_position(name_list, position_list, index))\n            index += 1\n        return optimal_positions\n\n    def count_inspections(name_list, position_list):\n        inspections = 0\n        for i in range(len(name_list)):\n            if position_list[i] != name_list[i]:\n                inspections += 1\n        return inspections\n\n    N, M = map(int, stdin.readline().split())\n    name_list = list(map(int, stdin.readline().split()))\n    position_list = list(map(int, stdin.readline().split()))\n\n    optimal_positions = find_optimal_positions(name_list, position_list)\n    inspections = count_inspections(name_list, optimal_positions)\n\n    return f\"{inspections}\\n{' '.join(map(str, optimal_positions))}\" "
    },
    {
        "number": 3144,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    d_coins = [d] * n\n    g_coins = [g] * n\n    distractions = [False] * n\n    for i in range(k):\n        distractions[i] = True\n\n    for i in range(n):\n        if not distractions[i]:\n            d_coins[i] += 1\n            g_coins[i] += 1\n\n    d_wins = [False] * n\n    for i in range(n):\n        if d_coins[i] > g_coins[i]:\n            d_wins[i] = True\n\n    d_score = 0\n    g_score = 0\n    for i in range(n):\n        if d_wins[i]:\n            d_score += d_coins[i] + g_coins[i]\n            g_score += g_coins[i]\n        else:\n            d_score += d_coins[i]\n            g_score += d_coins[i] + g_coins[i]\n\n    return max(d_score, g_score)"
    },
    {
        "number": 3144,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n\n    # Calculate the maximum amount of coins that can be won by each player, assuming they always win\n    max_donald = (d + g) * n // 2\n    max_gladstone = (d + g) * n // 2\n\n    # Calculate the minimum amount of coins that can be won by each player, assuming they always lose\n    min_donald = max(0, d - g)\n    min_gladstone = max(0, g - d)\n\n    # Update the maximum and minimum amounts of coins based on the number of rounds Gladstone is distracted\n    max_donald -= k * g\n    min_donald += k * d\n    max_gladstone += k * g\n    min_gladstone -= k * d\n\n    # Return the maximum amount of coins that can be won by Donald\n    return max(max_donald, min_donald)"
    },
    {
        "number": 3144,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n\n    M = d + g\n    for i in range(1, n + 1):\n        if i <= k:\n            M += d\n        else:\n            M += g\n\n    return str(M)"
    },
    {
        "number": 3144,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n\n    # At the start of the game, Donald has 0 coins and Gladstone has g coins\n    donald_coins = 0\n    gladstone_coins = g\n\n    # Calculate the maximum number of coins that Gladstone can have in the worst case scenario\n    max_gladstone_coins = min(n - k, n) * g\n\n    # Calculate the maximum number of coins that Donald can have in the worst case scenario\n    max_donald_coins = max(0, (n - k) * d)\n\n    # Calculate the minimum number of coins that Gladstone can have in the worst case scenario\n    min_gladstone_coins = max(0, (n - k) * g - (k * d))\n\n    # Calculate the minimum number of coins that Donald can have in the worst case scenario\n    min_donald_coins = max(0, (n - k) * d + (k * min_gladstone_coins))\n\n    # Calculate the maximum number of coins that Donald can be certain to have at the end of the game\n    max_donald_coins_certain = max(0, donald_coins + min_donald_coins)\n\n    return str(max_donald_coins_certain)"
    },
    {
        "number": 3144,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    M = d + g\n    for i in range(k):\n        M += 2 * (g // d)\n        g = max(0, g - d)\n        M = min(M, g)\n    return str(M)"
    },
    {
        "number": 3144,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    M = max(d + g - k, 0)\n    return str(M)"
    },
    {
        "number": 3144,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n\n    # Calculate the maximum amount of coins Donald can have at the end of the game\n    M = max(d, g) + min(d, g) * (n - k)\n\n    return str(M)"
    },
    {
        "number": 3144,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n\n    # If Gladstone is never distracted, Donald can only win n times (max)\n    if k == 0:\n        return min(d, g) * n\n\n    # If Gladstone is always distracted, Donald can win all the time\n    if k == n:\n        return max(d, g) * n\n\n    # If n is even and k is odd, or vice versa, then Gladstone will be distracted at the end\n    if (n % 2 != k % 2) and (d <= g):\n        return d * n + (min(d, g) - d)\n\n    # If n is even and k is even, or vice versa, then Gladstone will not be distracted at the end\n    if (n % 2 == k % 2) and (d < g):\n        return d * n + (min(d, g) - d)\n\n    # If n is odd and k is odd, or vice versa, then Gladstone will be distracted at the end\n    if (n % 2 != k % 2) and (d < g):\n        return d * n + (min(d, g) - d)\n\n    # If n is odd and k is even, or vice versa, then Gladstone will not be distracted at the end\n    if (n % 2 == k % 2) and (d <= g):\n        return d * n + (min(d, g) - d)"
    },
    {
        "number": 3144,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    M = max(d, g)\n    \n    for i in range(k):\n        if i % 2 == 0:\n            d += 2\n        else:\n            g += 2\n\n    if d > g:\n        M += (n - k) * d\n    else:\n        M += (n - k) * g\n\n    return str(M) "
    },
    {
        "number": 3144,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    d_coins = d\n    g_coins = g\n    for _ in range(n):\n        if d_coins > g_coins:\n            d_coins, g_coins = g_coins, d_coins\n        if k > 0:\n            d_coins += (d_coins * 2) // 3\n            k -= 1\n        else:\n            d_coins, g_coins = g_coins // 2, d_coins // 2\n    return str(max(d_coins, g_coins))"
    },
    {
        "number": 3145,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    line1, line2 = stdin.split('\\n')\n    X, A, B = map(int, line1.split())\n    allowed_digits = set(line2)\n\n    count = 0\n    for i in range(A, B + 1):\n        if all(d in allowed_digits for d in str(i)):\n            if i % X == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B, allowed_digits = map(int, stdin.split())\n    allowed_digits = set(map(int, allowed_digits))\n\n    count = 0\n    for i in range(A, B + 1):\n        if i % X == 0 and all(digit in allowed_digits for digit in map(int, str(i))):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    line1, line2 = stdin.split('\\n')\n    X, A, B = map(int, line1.split())\n    allowed_digits = set(line2)\n\n    count = 0\n    for i in range(A, B + 1):\n        if all(d in allowed_digits for d in str(i)):\n            if i % X == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B = map(int, stdin.split('\\n')[0].split())\n    allowed_digits = set(stdin.split('\\n')[1])\n\n    count = 0\n    for i in range(A, B + 1):\n        if '0' not in allowed_digits and i == 0:\n            continue\n        if all(d in allowed_digits for d in str(i)):\n            if i % X == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    line1 = list(map(int, stdin.split('\\n')[0].split()))\n    line2 = stdin.split('\\n')[1]\n    X, A, B = line1[0], line1[1], line1[2]\n    allowed_digits = set(line2)\n\n    count = 0\n    for i in range(A, B + 1):\n        if all(digit in allowed_digits for digit in str(i)):\n            if i % X == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B = map(int, stdin.split('\\n')[0].split())\n    allowed_digits = set(stdin.split('\\n')[1])\n    count = 0\n    for i in range(A, B + 1):\n        if all(d in allowed_digits for d in str(i)):\n            if i % X == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B, allowed_digits = map(int, stdin.split('\\n')[0].split())\n    allowed_digits = list(map(int, stdin.split('\\n')[1]))\n    count = 0\n\n    for num in range(A, B + 1):\n        num_digits = [int(digit) for digit in str(num)]\n        if all(digit in allowed_digits for digit in num_digits) and num % X == 0:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B, X, allowed_digits = map(int, stdin.split(\"\\n\"))\n    allowed_digits = set(list(map(int, allowed_digits)))\n    count = 0\n\n    for i in range(A, B + 1):\n        if i % X == 0:\n            digits = set(map(int, str(i)))\n            if digits.issubset(allowed_digits):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x, a, b, allowed_digits = map(int, stdin.split('\\n')[0].split()), sorted(map(int, stdin.split('\\n')[1])), set()\n\n    for digit in allowed_digits:\n        allowed_digits.add(digit)\n\n    count = 0\n\n    for i in range(a, b + 1):\n        if set(str(i)).issubset(allowed_digits) and i % x == 0:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B = map(int, stdin.split()[:3])\n    allowed_digits = set(map(int, stdin.split()[3]))\n    count = 0\n    \n    for i in range(A, B + 1):\n        if i % X == 0:\n            digits = set(map(int, str(i)))\n            if digits.issubset(allowed_digits):\n                count += 1\n                \n    return str(count)"
    },
    {
        "number": 3146,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def avg_time(prescriptions, technicians):\n        in_store = [p for p in prescriptions if p[1] == 'S']\n        remote = [p for p in prescriptions if p[1] == 'R']\n        in_store.sort(key=lambda x: x[0])\n        remote.sort(key=lambda x: x[0])\n\n        in_store_time = 0\n        remote_time = 0\n        in_store_count = 0\n        remote_count = 0\n        technicians_free = technicians\n\n        while in_store or remote:\n            if in_store and technicians_free:\n                prescription = in_store.pop(0)\n                in_store_time += prescription[0]\n                in_store_count += 1\n                technicians_free -= 1\n            elif remote and technicians_free:\n                prescription = remote.pop(0)\n                remote_time += prescription[0]\n                remote_count += 1\n                technicians_free -= 1\n\n            technicians_free = min(technicians_free + 1, technicians)\n\n        in_store_avg = in_store_time / in_store_count if in_store_count else 0\n        remote_avg = remote_time / remote_count if remote_count else 0\n\n        return in_store_avg, remote_avg\n\n    n, t = map(int, stdin.readline().strip().split())\n    prescriptions = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    in_store_avg, remote_avg = avg_time(prescriptions, t)\n\n    return f\"{in_store_avg:.6f} {remote_avg:.6f}\""
    },
    {
        "number": 3146,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def avg_completion_time(prescriptions, technicians):\n        in_store = [p for p in prescriptions if p[1] == 'S']\n        remote = [p for p in prescriptions if p[1] == 'R']\n        in_store.sort(key=lambda x: x[2])\n        remote.sort(key=lambda x: x[2])\n\n        time = 0\n        in_store_times = []\n        remote_times = []\n        in_store_index, remote_index = 0, 0\n\n        while in_store_index < len(in_store) or remote_index < len(remote):\n            if in_store_index < len(in_store) and (remote_index >= len(remote) or in_store[in_store_index][2] <= remote[remote_index][2]):\n                current_time = time + in_store[in_store_index][0]\n                time += in_store[in_store_index][2]\n                in_store_times.append(current_time)\n                in_store_index += 1\n            else:\n                current_time = time + remote[remote_index][0]\n                time += remote[remote_index][2]\n                remote_times.append(current_time)\n                remote_index += 1\n\n        in_store_avg = sum(in_store_times) / len(in_store_times) if in_store_times else 0\n        remote_avg = sum(remote_times) / len(remote_times) if remote_times else 0\n\n        return in_store_avg, remote_avg\n\n    input_list = [line.strip().split() for line in stdin.split('\\n') if line.strip()]\n    n, t = map(int, input_list[0])\n    prescriptions = input_list[1:]\n    prescriptions = [(int(p[0]), p[1], int(p[2])) for p in prescriptions]\n\n    in_store_avg, remote_avg = avg_completion_time(prescriptions, t)\n    return f\"{in_store_avg:.6f} {remote_avg:.6f}\""
    },
    {
        "number": 3146,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def avg_time(prescriptions, technicians):\n        store_prescriptions = [prescription for prescription in prescriptions if prescription[1] == 'S']\n        remote_prescriptions = [prescription for prescription in prescriptions if prescription[1] == 'R']\n\n        store_time = 0\n        remote_time = 0\n\n        for i in range(technicians):\n            store_time += store_prescriptions[i][2]\n            remote_time += remote_prescriptions[i][2]\n\n        return (store_time / len(store_prescriptions), remote_time / len(remote_prescriptions))\n\n    lines = stdin.split('\\n')\n    n, t = map(int, lines[0].split())\n    prescriptions = [list(map(int, line.split()[1:])) for line in lines[1:n+1]]\n\n    prescriptions.sort(key=lambda x: (x[0], -ord(x[1]), x[2]))\n\n    o, r = avg_time(prescriptions, t)\n\n    return f\"{o:.6f} {r:.6f}\""
    },
    {
        "number": 3146,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def process_prescription(prescriptions, technicians):\n        in_store_prescriptions = []\n        remote_prescriptions = []\n\n        for prescription in prescriptions:\n            if prescription[1] == 'R':\n                remote_prescriptions.append(prescription)\n            else:\n                in_store_prescriptions.append(prescription)\n\n        in_store_prescriptions.sort(key=lambda x: x[0])\n        remote_prescriptions.sort(key=lambda x: x[0])\n\n        in_store_time = 0\n        remote_time = 0\n        in_store_count = 0\n        remote_count = 0\n\n        while in_store_prescriptions or remote_prescriptions:\n            if in_store_prescriptions and in_store_count < technicians:\n                prescription = in_store_prescriptions.pop(0)\n                in_store_time += prescription[2]\n                in_store_count += 1\n            elif remote_prescriptions:\n                prescription = remote_prescriptions.pop(0)\n                remote_time += prescription[2]\n                remote_count += 1\n\n        return in_store_time / (in_store_count or 1), remote_time / (remote_count or 1)\n\n    def parse_input(stdin):\n        lines = stdin.split('\\n')\n        n, technicians = map(int, lines[0].split())\n        prescriptions = [list(map(int, line.split()[0])) + [int(line.split()[2])] for line in lines[1:]]\n        return n, technicians, prescriptions\n\n    n, technicians, prescriptions = parse_input(stdin)\n    in_store_avg, remote_avg = process_prescription(prescriptions, technicians)\n\n    return f\"{in_store_avg:.6f} {remote_avg:.6f}\\n\""
    },
    {
        "number": 3146,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def avg_completion_time(prescriptions, technicians):\n        store_prescriptions = [p for p in prescriptions if p[1] == 'S']\n        remote_prescriptions = [p for p in prescriptions if p[1] == 'R']\n\n        store_completion_times = []\n        remote_completion_times = []\n\n        store_index = 0\n        remote_index = 0\n\n        current_time = 0\n        while store_index < len(store_prescriptions) or remote_index < len(remote_prescriptions):\n            if store_index < len(store_prescriptions) and (remote_index >= len(remote_prescriptions) or store_prescriptions[store_index][0] < remote_prescriptions[remote_index][0]):\n                current_time = max(current_time, store_prescriptions[store_index][0])\n                store_completion_times.append(current_time + store_prescriptions[store_index][2])\n                current_time += store_prescriptions[store_index][2]\n                store_index += 1\n            else:\n                current_time = max(current_time, remote_prescriptions[remote_index][0])\n                remote_completion_times.append(current_time + remote_prescriptions[remote_index][2])\n                current_time += remote_prescriptions[remote_index][2]\n                remote_index += 1\n\n        return sum(store_completion_times) / len(store_completion_times), sum(remote_completion_times) / len(remote_completion_times)\n\n    lines = stdin.strip().split('\\n')\n    n, technicians = map(int, lines[0].split())\n    prescriptions = [list(map(int, line.split()[1:])) for line in lines[1:]]\n    prescriptions.sort(key=lambda x: (x[0], -x[2]))\n\n    o, r = avg_completion_time(prescriptions, technicians)\n\n    return f\"{o:.6f} {r:.6f}\""
    },
    {
        "number": 3146,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def avg_completion_time(prescriptions, num_technicians):\n        in_store_prescriptions = []\n        remote_prescriptions = []\n\n        for prescription in prescriptions:\n            if prescription[1] == \"S\":\n                in_store_prescriptions.append(prescription)\n            else:\n                remote_prescriptions.append(prescription)\n\n        in_store_prescriptions.sort(key=lambda x: x[0])\n        remote_prescriptions.sort(key=lambda x: x[0])\n\n        in_store_completion_times = []\n        remote_completion_times = []\n\n        technicians = [0] * num_technicians\n        in_store_index = 0\n        remote_index = 0\n\n        while in_store_index < len(in_store_prescriptions) or remote_index < len(remote_prescriptions):\n            for i in range(num_technicians):\n                if technicians[i] <= min(in_store_prescriptions[in_store_index][0] if in_store_index < len(in_store_prescriptions) else float('inf'), remote_prescriptions[remote_index][0] if remote_index < len(remote_prescriptions) else float('inf')):\n                    if in_store_index < len(in_store_prescriptions) and remote_index < len(remote_prescriptions):\n                        if in_store_prescriptions[in_store_index][0] < remote_prescriptions[remote_index][0]:\n                            in_store_completion_times.append(in_store_prescriptions[in_store_index][0] + in_store_prescriptions[in_store_index][2])\n                            technicians[i] += in_store_prescriptions[in_store_index][2]\n                            in_store_index += 1\n                        else:\n                            remote_completion_times.append(remote_prescriptions[remote_index][0] + remote_prescriptions[remote_index][2])\n                            technicians[i] += remote_prescriptions[remote_index][2]\n                            remote_index += 1\n                    elif in_store_index < len(in_store_prescriptions):\n                        in_store_completion_times.append(in_store_prescriptions[in_store_index][0] + in_store_prescriptions[in_store_index][2])\n                        technicians[i] += in_store_prescriptions[in_store_index][2]\n                        in_store_index += 1\n                    else:\n                        remote_completion_times.append(remote_prescriptions[remote_index][0] + remote_prescriptions[remote_index][2])\n                        technicians[i] += remote_prescriptions[remote_index][2]\n                        remote_index += 1\n\n        if not in_store_completion_times:\n            in_store_avg_completion_time = 0\n        else:\n            in_store_avg_completion_time = sum(in_store_completion_times) / len(in_store_completion_times)\n\n        if not remote_completion_times:\n            remote_avg_completion_time = 0\n        else:\n            remote_avg_completion_time = sum(remote_completion_times) / len(remote_completion_times)\n\n        return in_store_avg_completion_time, remote_avg_completion_time\n\n    prescriptions = []\n    num_technicians = 0\n\n    lines = stdin.split(\"\\n\")\n    n, T = map(int, lines[0].split())\n    for i in range(1, n + 1):\n        d, t, k = lines[i].split()\n        prescriptions.append((int(d), t, int(k)))\n\n    num_technicians = T\n\n    in_store_avg_completion_time, remote_avg_completion_time = avg_completion_time(prescriptions, num_technicians)\n\n    return f\"{in_store_avg"
    },
    {
        "number": 3146,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def avg_completion_time(prescriptions, num_technicians):\n        in_store_prescriptions = [p for p in prescriptions if p[1] == 'S']\n        remote_prescriptions = [p for p in prescriptions if p[1] == 'R']\n\n        in_store_completion_times = []\n        remote_completion_times = []\n\n        in_store_index = 0\n        remote_index = 0\n\n        current_time = 0\n        for _ in range(num_technicians):\n            while in_store_index < len(in_store_prescriptions) and in_store_prescriptions[in_store_index][0] <= current_time:\n                in_store_completion_times.append(in_store_prescriptions[in_store_index][2] + current_time)\n                current_time += in_store_prescriptions[in_store_index][2]\n                in_store_index += 1\n\n            while remote_index < len(remote_prescriptions) and remote_prescriptions[remote_index][0] <= current_time:\n                remote_completion_times.append(remote_prescriptions[remote_index][2] + current_time)\n                current_time += remote_prescriptions[remote_index][2]\n                remote_index += 1\n\n        return sum(in_store_completion_times) / len(in_store_completion_times), sum(remote_completion_times) / len(remote_completion_times)\n\n    lines = stdin.split('\\n')\n    num_prescriptions, num_technicians = map(int, lines[0].split())\n    prescriptions = [list(map(int, line.split()[0])) + [line.split()[1]] + [int(line.split()[2])] for line in lines[1:num_prescriptions + 1]]\n    prescriptions.sort(key=lambda x: (x[0], 'RS'.index(x[1]), x[2]))\n\n    return f\"{avg_completion_time(prescriptions, num_technicians)[0]:.6f} {avg_completion_time(prescriptions, num_technicians)[1]:.6f}\""
    },
    {
        "number": 3146,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def avg_completion_time(prescriptions, num_techs):\n        store_prescriptions = [p for p in prescriptions if p[1] == 'S']\n        remote_prescriptions = [p for p in prescriptions if p[1] == 'R']\n\n        store_prescriptions.sort(key=lambda x: x[0])\n        remote_prescriptions.sort(key=lambda x: x[0])\n\n        store_completion_times = []\n        remote_completion_times = []\n\n        store_index = 0\n        remote_index = 0\n\n        time = 0\n\n        while store_index < len(store_prescriptions) or remote_index < len(remote_prescriptions):\n            if store_index < len(store_prescriptions) and (remote_index == len(remote_prescriptions) or store_prescriptions[store_index][0] <= remote_prescriptions[remote_index][0]):\n                time += store_prescriptions[store_index][2]\n                store_completion_times.append(time)\n                store_index += 1\n            else:\n                time += remote_prescriptions[remote_index][2]\n                remote_completion_times.append(time)\n                remote_index += 1\n\n        store_avg = sum(store_completion_times) / len(store_completion_times) if store_completion_times else 0\n        remote_avg = sum(remote_completion_times) / len(remote_completion_times) if remote_completion_times else 0\n\n        return store_avg, remote_avg\n\n    lines = stdin.strip().split('\\n')\n    num_prescriptions, num_techs = map(int, lines[0].split())\n    prescriptions = [list(map(int, line.split()[0])) + [int(line.split()[1][1])] + [int(line.split()[2])] for line in lines[1:]]\n\n    store_avg, remote_avg = avg_completion_time(prescriptions, num_techs)\n\n    return f\"{store_avg:.6f} {remote_avg:.6f}\""
    },
    {
        "number": 3146,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def avg_completion_time(prescriptions):\n        in_store_prescriptions = [prescription for prescription in prescriptions if prescription[1] == 'S']\n        remote_prescriptions = [prescription for prescription in prescriptions if prescription[1] == 'R']\n\n        total_completion_time = 0\n        for i, prescription in enumerate(in_store_prescriptions):\n            completion_time = (prescription[0] + i) + prescription[2]\n            total_completion_time += completion_time\n        in_store_avg = total_completion_time / len(in_store_prescriptions) if in_store_prescriptions else 0\n\n        total_completion_time = 0\n        for i, prescription in enumerate(remote_prescriptions):\n            completion_time = prescription[0] + prescription[2]\n            total_completion_time += completion_time\n        remote_avg = total_completion_time / len(remote_prescriptions) if remote_prescriptions else 0\n\n        return in_store_avg, remote_avg\n\n    lines = stdin.split('\\n')\n    n, t = map(int, lines[0].split())\n    prescriptions = []\n    for i in range(1, n + 1):\n        d, p_type, k = lines[i].split()\n        prescriptions.append((int(d), p_type, int(k)))\n\n    prescriptions.sort(key=lambda x: (x[0], 'R' if x[1] == 'R' else 'S'))\n\n    in_store_avg, remote_avg = avg_completion_time(prescriptions)\n\n    return f\"{in_store_avg:.6f} {remote_avg:.6f}\\n\""
    },
    {
        "number": 3146,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_data = list(map(str.split, stdin.split('\\n')))\n    n, t = map(int, input_data[0])\n    prescriptions = sorted(input_data[1:n+1], key=lambda x: (x[0], 'S' not in x))\n\n    # Calculate average completion time for in-store and remote prescriptions\n    in_store_completion_times = []\n    remote_completion_times = []\n    in_store_count = 0\n    remote_count = 0\n    technicians = [0] * t\n\n    for prescription in prescriptions:\n        if prescription[1] == 'R':\n            remote_count += 1\n            remote_completion_times.append(int(prescription[0]) + int(prescription[2]))\n        else:\n            in_store_count += 1\n            while any(technicians):\n                technicians[technicians.index(min(technicians))] += 1\n            technicians[0] += int(prescription[2])\n            in_store_completion_times.append(int(prescription[0]) + technicians[0])\n\n    if in_store_count == 0:\n        in_store_avg = 0\n    else:\n        in_store_avg = sum(in_store_completion_times) / in_store_count\n\n    if remote_count == 0:\n        remote_avg = 0\n    else:\n        remote_avg = sum(remote_completion_times) / remote_count\n\n    return f\"{in_store_avg:.6f} {remote_avg:.6f}\\n\""
    },
    {
        "number": 3147,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    memory = [list(stdin.readline().strip()) for _ in range(R)]\n    killers = []\n\n    def is_killer(matrix):\n        rotated = [[matrix[j][R - i - 1] for j in range(len(matrix))] for i in range(len(matrix))]\n        for i in range(len(matrix)):\n            for j in range(len(matrix)):\n                if matrix[i][j] != rotated[i][j]:\n                    return False\n        return True\n\n    for i in range(R):\n        for j in range(C):\n            for k in range(min(R, C) // 2):\n                if is_killer([[memory[x][y] for y in range(j, j + 2 * k + 1)] for x in range(i, i + 2 * k + 1)]]):\n                    killers.append(2 * k + 1)\n\n    return max(killers) if killers else -1"
    },
    {
        "number": 3147,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    memory = []\n    for _ in range(R):\n        memory.append(list(stdin.readline().strip()))\n\n    def is_killer(matrix):\n        rotated = [''.join(list(reversed(row))) for row in zip(*matrix)]\n        for row in matrix:\n            if row not in rotated:\n                return False\n        return True\n\n    def get_killer_size(x, y):\n        for size in range(min(R - x + 1, C - y + 1), 0, -1):\n            submatrix = [row[y:y + size] for row in memory[x:x + size]]\n            if is_killer(submatrix):\n                return size\n        return 0\n\n    largest_killer = -1\n    for x in range(R):\n        for y in range(C):\n            killer_size = get_killer_size(x, y)\n            if killer_size > largest_killer:\n                largest_killer = killer_size\n\n    return str(largest_killer)"
    },
    {
        "number": 3147,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    memory = [list(map(int, input().strip())) for _ in range(R)]\n    max_killer_size = -1\n\n    def is_killer(matrix: list, size: int) -> bool:\n        for row in matrix:\n            if sum(row) != size:\n                return False\n        return True\n\n    def rotate(matrix: list) -> list:\n        return list(zip(*matrix[::-1]))\n\n    for size in range(2, min(R, C) + 1):\n        for row in range(R - size + 1):\n            for col in range(C - size + 1):\n                killer = [memory[row + i][col:col + size] for i in range(size)]\n                if is_killer(killer, size) and is_kiler(rotate(killer), size):\n                    max_killer_size = max(max_killer_size, size)\n\n    return str(max_killer_size)"
    },
    {
        "number": 3147,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    memory = [list(map(int, line.rstrip())) for line in stdin.split('\\n')[1:]]\n\n    def is_killer(killer_size: int) -> bool:\n        for i in range(R - killer_size + 1):\n            for j in range(C - killer_size + 1):\n                if all(memory[i + x][j:j + killer_size] == memory[i + x][j + killer_size - 1:j - 1 if j > 0 else C - 1:j - 1 if j > 0 else C - 1][::-1] for x in range(killer_size)):\n                    return True\n        return False\n\n    max_killer_size = -1\n    for killer_size in range(2, min(R, C) + 1):\n        if is_killer(killer_size):\n            max_killer_size = killer_size\n\n    return str(max_killer_size)"
    },
    {
        "number": 3147,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.readline().split())\n    memory = [stdin.readline().strip() for _ in range(r)]\n    max_size = -1\n\n    for i in range(r):\n        for j in range(c):\n            for size in range(1, min(r - i + 1, c - j + 1) + 1):\n                if is_square_killer(memory, i, j, size):\n                    max_size = max(max_size, size)\n\n    return str(max_size)\n\ndef"
    },
    {
        "number": 3147,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_matrix(matrix):\n        return list(zip(*matrix[::-1]))\n\n    def is_square_killer(matrix, row, col, size):\n        for i in range(size):\n            for j in range(size):\n                if matrix[row + i][col + j] != 1:\n                    return False\n        return True\n\n    def find_square_killers(matrix, max_size):\n        square_killers = []\n        for size in range(1, max_size + 1):\n            for row in range(R - size + 1):\n                for col in range(C - size + 1):\n                    if is_square_killer(matrix, row, col, size):\n                        if rotate_matrix(matrix[row:row + size][col:col + size]) == matrix[row:row + size][col:col + size]:\n                            square_killers.append(size)\n        return square_killers\n\n    R, C = map(int, stdin.readline().strip().split())\n    matrix = [list(map(int, stdin.readline().strip())) for _ in range(R)]\n\n    square_killers = find_square_killers(matrix, min(R, C))\n    if square_killers:\n        return str(max(square_killers))\n    else:\n        return \"-1\""
    },
    {
        "number": 3147,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    memory = []\n    for _ in range(R):\n        memory.append(list(map(int, input().split())))\n    \n    def rotate_matrix(matrix):\n        return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]) - 1, -1, -1)]\n    \n    def check_square_killer(matrix):\n        for i in range(len(matrix) - 1):\n            for j in range(len(matrix[0]) - 1):\n                square_size = 2\n                while square_size <= len(matrix) - i and square_size <= len(matrix[0]) - j:\n                    square = [row[j:j + square_size] for row in matrix[i:i + square_size]]\n                    if all(row.count(1) == square_size for row in square) and all(col.count(1) == square_size for col in zip(*square)):\n                        if square == rotate_matrix(square):\n                            return square_size\n                    square_size += 1\n        return -1\n    \n    max_size = max(check_square_killer(memory), check_square_killer(rotate_matrix(memory)))\n    return str(max_size)"
    },
    {
        "number": 3147,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_killer(matrix, row, col, size):\n        for i in range(size):\n            for j in range(size):\n                if matrix[row + i][col + j] != matrix[row + i][col + size - j - 1]:\n                    return False\n        return True\n\n    def find_largest_killer(matrix, rows, cols):\n        max_size = 1\n        for size in range(2, min(rows, cols) + 1):\n            for i in range(rows - size + 1):\n                for j in range(cols - size + 1):\n                    if is_killer(matrix, i, j, size):\n                        max_size = max(max_size, size)\n        return max_size if max_size > 1 else -1\n\n    input_list = stdin.split('\\n')\n    rows, cols = map(int, input_list[0].split())\n    matrix = [list(map(int, row)) for row in input_list[1:]]\n\n    result = find_largest_killer(matrix, rows, cols)\n    return str(result)"
    },
    {
        "number": 3147,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().strip().split())\n    memory = []\n    for _ in range(R):\n        memory.append(list(stdin.readline().strip()))\n\n    def is_killer(matrix):\n        rotated = [[row[i] for row in matrix] for i in range(len(matrix[0]))]\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] != rotated[i][j]:\n                    return False\n        return True\n\n    killers = []\n    for i in range(R):\n        for j in range(C):\n            for size in range(min(R - i, C - j) + 1):\n                if size == 1:\n                    killers.append(1)\n                elif size > 1 and is_killer([row[j:j + size] for row in memory[i:i + size]]):\n                    killers.append(size)\n\n    if not killers:\n        return \"-1\\n\"\n    else:\n        return str(max(killers)) + \"\\n\""
    },
    {
        "number": 3147,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.readline().strip().split())\n    memory = []\n    killers = []\n\n    for _ in range(r):\n        memory.append(list(stdin.readline().strip()))\n\n    for i in range(r):\n        for j in range(c):\n            for k in range(i + 1, r + 1):\n                for l in range(j + 1, c + 1):\n                    killer = [row[j:l] for row in memory[i:k]]\n                    if killer == killer[::-1]:\n                        killers.append((k - i, l - j))\n\n    max_size = -1\n    for size in killers:\n        max_size = max(max_size, max(size))\n\n    return str(max_size)"
    },
    {
        "number": 3148,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2\n\n    n = int(stdin.readline())\n    swimmers = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    best_distance = float('inf')\n    best_division = None\n\n    for x1 in range(-10**9, 10**9):\n        for y1 in range(-10**9, 10**9):\n            for x2 in range(-10**9, 10**9):\n                for y2 in range(-10**9, 10**9):\n                    count1 = 0\n                    count2 = 0\n                    tie = 0\n\n                    for swimmer in swimmers:\n                        d1 = distance(swimmer[0], swimmer[1], x1, y1)\n                        d2 = distance(swimmer[0], swimmer[1], x2, y2)\n\n                        if d1 < d2:\n                            count1 += 1\n                        elif d1 > d2:\n                            count2 += 1\n                        else:\n                            tie += 1\n\n                    if count1 == count2 and tie <= 1:\n                        total_distance = sum(distance(*swimmer, x1, y1) for swimmer in swimmers) + \\\n                                     sum(distance(*swimmer, x2, y2) for swimmer in swimmers)\n\n                        if total_distance < best_distance:\n                            best_distance = total_distance\n                            best_division = ((x1, y1), (x2, y2))\n\n    return '\\n'.join(f'{x} {y}' for x, y in best_division)"
    },
    {
        "number": 3148,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    n = int(stdin.readline())\n    swimmers = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    x_coords = sorted(set(x for x, _ in swimmers))\n    y_coords = sorted(set(y for _, y in swimmers))\n\n    for x in x_coords:\n        for y in y_coords:\n            if (x, y) not in swimmers:\n                continue\n\n            swimmers_by_dist = [[] for _ in range(n)]\n            for i, (sx, sy) in enumerate(swimmers):\n                dx, dy = sx - x, sy - y\n                dist = dx * dx + dy * dy\n                swimmers_by_dist[dist].append(i)\n\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if len(swimmers_by_dist[i]) != len(swimmers_by_dist[j]):\n                        continue\n                    if gcd(i, j) == 1:\n                        return f\"{x} {y}\\n{x + i} {y + j}\\n\"\n\n    return \"No solution found\""
    },
    {
        "number": 3148,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    swimmers = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        swimmers.append((x, y))\n\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    swimmers.sort(key=lambda s: (s[0], s[1]))\n    you = swimmers[0]\n    your_group = {you}\n    next_group = set()\n    next_swimmer = swimmers[1]\n    for i in range(2, n):\n        if distance(you, swimmers[i]) < distance(next_swimmer, swimmers[i]):\n            your_group.add(swimmers[i])\n        else:\n            next_group.add(swimmers[i])\n\n    if len(your_group) != len(next_group):\n        for swimmer in swimmers:\n            if swimmer not in your_group and swimmer not in next_group:\n                if distance(you, swimmer) == distance(next_swimmer, swimmer):\n                    if swimmer in your_group:\n                        your_group.remove(swimmer)\n                    else:\n                        next_group.add(swimmer)\n                    break\n\n    return f\"{you[0]} {you[1]}\\n{(next_swimmer[0] + you[0]) // 2} {(next_swimmer[1] + you[1]) // 2}\""
    },
    {
        "number": 3148,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2\n\n    n = int(stdin.readline().strip())\n    swimmers = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        swimmers.append((x, y))\n\n    swimmers.sort()\n    left_guard_x, left_guard_y = swimmers[0]\n    right_guard_x, right_guard_y = swimmers[-1]\n\n    for i in range(1, n - 1):\n        if distance(swimmers[0][0], swimmers[0][1], swimmers[i][0], swimmers[i][1]) < \\\n                distance(swimmers[-1][0], swimmers[-1][1], swimmers[i][0], swimmers[i][1]):\n            left_guard_x, left_guard_y = swimmers[i]\n        else:\n            right_guard_x, right_guard_y = swimmers[i]\n\n    return f\"{left_guard_x} {left_guard_y}\\n{right_guard_x} {right_guard_y}\""
    },
    {
        "number": 3148,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2\n\n    def closest_lifeguard(x, y, lifeguards):\n        closest_dist = float(\"inf\")\n        closest_lifeguard = None\n        for i, (lx, ly) in enumerate(lifeguards):\n            d = distance(x, y, lx, ly)\n            if d < closest_dist:\n                closest_dist = d\n                closest_lifeguard = i\n        return closest_lifeguard\n\n    def problem_solver(n, swimmers):\n        lifeguards = [(0, 0), (0, 1)]\n        for x, y in swimmers:\n            closest = closest_lifeguard(x, y, lifeguards)\n            lifeguards[closest] = (lifeguards[closest][0] + x, lifeguards[closest][1] + y)\n\n        return lifeguards\n\n    n = int(stdin.readline().strip())\n    swimmers = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    lifeguards = problem_solver(n, swimmers)\n    return f\"{lifeguards[0][0]} {lifeguards[0][1]}\\n{lifeguards[1][0]} {lifeguards[1][1]}\""
    },
    {
        "number": 3148,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    n = int(stdin.readline().strip())\n    swimmers = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        swimmers.append((x, y))\n\n    swimmers.sort()\n    x1, y1, x2, y2 = swimmers[0][0], swimmers[0][1], swimmers[0][0], swimmers[0][1]\n\n    for i in range(1, n):\n        if i % 2 == 0:\n            x1, y1 = swimmers[i][0], swimmers[i][1]\n        else:\n            x2, y2 = swimmers[i][0], swimmers[i][1]\n\n    if n % 2 == 0:\n        x2, y2 = swimmers[n - 1][0], swimmers[n - 1][1]\n\n    lcm_x, lcm_y = lcm(abs(x1 - x2), abs(y1 - y2))\n\n    if x1 < x2:\n        x1 -= lcm_x\n        x2 += lcm_x\n    else:\n        x1 += lcm_x\n        x2 -= lcm_x\n\n    if y1 < y2:\n        y1 -= lcm_y\n        y2 += lcm_y\n    else:\n        y1 += lcm_y\n        y2 -= lcm_y\n\n    return f\"{x1} {y1}\\n{x2} {y2}\""
    },
    {
        "number": 3148,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_valid(x1, y1, x2, y2, swimmers):\n        for swimmer in swimmers:\n            if distance(swimmer[0], swimmer[1], x1, y1) == distance(swimmer[0], swimmer[1], x2, y2):\n                return False\n        return True\n\n    def closest_swimmers(x, y, swimmers):\n        closest_x = x\n        closest_y = y\n        for swimmer in swimmers:\n            if distance(swimmer[0], swimmer[1], x, y) < distance(closest_x, closest_y, x, y):\n                closest_x = swimmer[0]\n                closest_y = swimmer[1]\n        return closest_x, closest_y\n\n    n = int(stdin.readline().strip())\n    swimmers = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    x1, y1 = closest_swimmers(0, 0, swimmers)\n    x2, y2 = closest_swimmers(x1, y1, swimmers)\n\n    while not is_valid(x1, y1, x2, y2, swimmers):\n        x1, y1 = x2, y2\n        x2, y2 = closest_swimmers(x1, y1, swimmers)\n\n    return f\"{x1} {y1}\\n{x2} {y2}\""
    },
    {
        "number": 3148,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    n = int(stdin.readline())\n    swimmers = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        swimmers.append((x, y))\n\n    swimmers.sort()\n    x1, y1, x2, y2 = swimmers[0][0], swimmers[0][1], swimmers[-1][0], swimmers[-1][1]\n\n    if n % 2 == 0:\n        for i in range(1, n // 2):\n            x1, y1 = lcm(x1, swimmers[i][0]), lcm(y1, swimmers[i][1])\n            x2, y2 = lcm(x2, swimmers[-i][0]), lcm(y2, swimmers[-i][1])\n    else:\n        for i in range(1, (n + 1) // 2):\n            x1, y1 = lcm(x1, swimmers[i][0]), lcm(y1, swimmers[i][1])\n            x2, y2 = lcm(x2, swimmers[-i][0]), lcm(y2, swimmers[-i][1])\n        x1, y1 = lcm(x1, swimmers[n // 2][0]), lcm(y1, swimmers[n // 2][1])\n\n    return f\"{x1} {y1}\\n{x2} {y2}\""
    },
    {
        "number": 3148,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    n = int(stdin.readline().strip())\n    swimmers = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    x_coords = sorted(x[0] for x in swimmers)\n    y_coords = sorted(x[1] for x in swimmers)\n\n    def split(coords, mid):\n        return sum(abs(x - mid) for x in coords)\n\n    def binary_search(coords):\n        lo, hi = min(coords), max(coords)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if split(coords, mid) <= split(coords, (lo + hi) // 2 + 1):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo\n\n    x_mid = binary_search(x_coords)\n    y_mid = binary_search(y_coords)\n\n    x1, x2 = x_mid, lcm(x_mid, n // 2)\n    y1, y2 = y_mid, lcm(y_mid, n // 2)\n\n    return f\"{x1} {y1}\\n{x2} {y2}\""
    },
    {
        "number": 3148,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def get_total_distance(x, y, swimmers):\n        return sum(get_distance(x, y, s[0], s[1]) for s in swimmers)\n\n    def find_lifeguard_positions(swimmers):\n        x, y = 0, 0\n        swimmers_count = len(swimmers)\n        while swimmers_count > 1:\n            for i in range(swimmers_count):\n                x += swimmers[i][0]\n                y += swimmers[i][1]\n            x //= swimmers_count\n            y //= swimmers_count\n            swimmers = [s for s in swimmers if get_distance(x, y, s[0], s[1]) == 1]\n            swimmers_count = len(swimmers)\n        return x, y\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    swimmers = [list(map(int, line.split())) for line in lines[1:]]\n\n    x1, y1 = find_lifeguard_positions(swimmers)\n    swimmers = sorted(swimmers, key=lambda s: get_distance(x1, y1, s[0], s[1]))\n    x2, y2 = find_lifeguard_positions(swimmers)\n\n    return f\"{x1} {y1}\\n{x2} {y2}\""
    },
    {
        "number": 3149,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(x: float, y: float, theta: float) -> tuple[float, float]:\n        return x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta)\n\n    def distance_to_wall(x: float, y: float, theta: float, w: float) -> float:\n        return abs(x * sin(theta) + y * cos(theta) - w)\n\n    def time_to_wall(x: float, y: float, theta: float, v0: float, omega: float) -> float:\n        return distance_to_wall(x, y, theta, w) / (v0 * sin(theta) + 1 / 2 * omega * distance_to_wall(x, y, theta, w) ** 2)\n\n    def parabola_equation(t: float, v0: float, theta: float) -> float:\n        return v0 * t * sin(theta) - 1 / 2 * 9.81 * t ** 2 * cos(theta) ** 2\n\n    def corner_time(i: int, n: int, theta: float, v0: float, omega: float, w: float) -> tuple[int, float]:\n        x, y = corners[i - 1]\n        t1 = time_to_wall(x, y, theta, v0, omega)\n        x, y = rotate(x, y, theta * t1)\n        t2 = time_to_wall(x, y, theta, v0, omega)\n\n        while abs(t1 - t2) > 1e-3:\n            tm = (t1 + t2) / 2\n            x, y = rotate(x, y, theta * (tm - t1))\n            t1, t2 = t2, time_to_wall(x, y, theta, v0, omega)\n\n        x, y = rotate(x, y, theta * (tm - t1))\n        y -= distance_to_wall(x, y, theta, w)\n        p = parabola_equation(tm, v0, theta)\n        x_max = x + (p - y) / tan(theta)\n        t_max = tm + (x_max - x) / (v0 * sin(theta))\n\n        if t_max <= tm:\n            return i, tm\n\n        x, y = rotate(x, y, theta * (t_max - tm))\n        y -= distance_to_wall(x, y, theta, w)\n\n        if y <= 0:\n            return i, t_max\n        else:\n            return i, tm\n\n    n, omega, v0, theta, w = map(float, stdin.readline().split())\n    theta = theta / 180 * pi\n    corners = [tuple(map(float, stdin.readline().split())) for _ in range(int(n))]\n\n    i, t = min(corner_time(i, n, theta, v0, omega, w) for i in range(1, int(n) + 1))\n    return f\"{i} {t:.6f}\""
    },
    {
        "number": 3149,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_list = stdin.split('\\n')\n    n, omega, v0, theta, w = map(float, input_list[0].split())\n    theta = theta * (pi / 180)\n    cookie_corners = []\n    for i in range(1, int(n) + 1):\n        x, y = map(float, input_list[i].split())\n        cookie_corners.append((x, y))\n\n    # Calculate time\n    def find_time_first_corner(corner_index):\n        x, y = cookie_corners[corner_index]\n        if y == 0:\n            t = abs(x / v0)\n        else:\n            a = v0 ** 2 / (w - x)\n            b = 2 * y / w\n            c = -2 * x * y / w ** 2\n            delta = b ** 2 - 4 * a * c\n            t1 = (-b + sqrt(delta)) / (2 * a)\n            t2 = (-b - sqrt(delta)) / (2 * a)\n            t = max(t1, t2)\n        return t\n\n    times = [find_time_first_corner(i) for i in range(int(n))]\n    min_index = times.index(min(times))\n    min_time = min(times)\n\n    # Calculate error\n    def calculate_error(t):\n        error = 0\n        for i in range(int(n)):\n            x, y = cookie_corners[i]\n            if y == 0:\n                time_corner = abs(x / v0)\n            else:\n                a = v0 ** 2 / (w - x)\n                b = 2 * y / w\n                c = -2 * x * y / w ** 2\n                delta = b ** 2 - 4 * a * c\n                time_corner1 = (-b + sqrt(delta)) / (2 * a)\n                time_corner2 = (-b - sqrt(delta)) / (2 * a)\n                time_corner = max(time_corner1, time_corner2)\n            error += abs(time_corner - t)\n        return error\n\n    error = calculate_error(min_time)\n    while error > 1e-3:\n        min_time -= 0.001\n        error = calculate_error(min_time)\n\n    # Return output\n    output = f\"{min_index + 1} {min_time:.6f}\"\n    return output"
    },
    {
        "number": 3149,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from math import sin, cos, pi\n\n    def rotate(x, y, theta):\n        return x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta)\n\n    def distance_to_wall(x, y, w):\n        return abs(x - w)\n\n    def parabola(t, v0, theta):\n        return v0 * t * sin(theta) - 0.5 * 9.81 * t ** 2\n\n    def get_time(corner, w, n, v0, theta, omega):\n        x, y = corner\n        t = 0\n        while x >= -w:\n            t += 0.01\n            x, y = rotate(x, y, omega * t)\n            x += v0 * sin(theta) * t\n            y += v0 * (1 - cos(theta)) * t - 0.5 * 9.81 * t ** 2\n\n        return t\n\n    def find_first_corner(n, w, v0, theta, omega):\n        first_corner = None\n        min_time = float('inf')\n        for i in range(n):\n            time = get_time(corners[i], w, n, v0, theta, omega)\n            if time < min_time:\n                min_time = time\n                first_corner = i + 1\n\n        return first_corner, min_time\n\n    stdin = stdin.split('\\n')\n    n, omega, v0, theta, w = map(float, stdin[0].split())\n    theta = theta * pi / 180\n\n    corners = [tuple(map(float, stdin[i + 1].split())) for i in range(n)]\n\n    first_corner, min_time = find_first_corner(n, w, v0, theta, omega)\n\n    return f\"{first_corner} {min_time:.6f}\""
    },
    {
        "number": 3149,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from math import sin, cos, radians\n    import re\n\n    def distance(x, y, theta, omega, v0, time):\n        return x + v0 * time * sin(radians(theta + omega * time))\n\n    def time_to_hit_wall(x, y, theta, omega, v0, wall_x, corner):\n        x_corner = x[corner - 1]\n        y_corner = y[corner - 1]\n\n        if theta < 45:\n            time = (wall_x - x_corner) / (v0 * sin(radians(theta)))\n            y_hit = y_corner + v0 * time * cos(radians(theta + omega * time))\n            if y_hit >= 0:\n                return time\n        elif theta < 90:\n            time = (wall_x - x_corner) / (v0 * cos(radians(theta)))\n            y_hit = y_corner - v0 * time * sin(radians(theta + omega * time))\n            if y_hit <= 0:\n                return time\n        elif theta < 135:\n            time = (wall_x - x_corner) / (v0 * sin(radians(theta)))\n            y_hit = y_corner - v0 * time * cos(radians(theta + omega * time))\n            if y_hit >= 0:\n                return time\n        elif theta < 180:\n            time = (wall_x - x_corner) / (v0 * cos(radians(theta)))\n            y_hit = y_corner + v0 * time * sin(radians(theta + omega * time))\n            if y_hit <= 0:\n                return time\n        elif theta < 225:\n            time = (wall_x - x_corner) / (v0 * sin(radians(theta)))\n            y_hit = y_corner + v0 * time * cos(radians(theta + omega * time))\n            if y_hit >= 0:\n                return time\n        elif theta < 270:\n            time = (wall_x - x_corner) / (v0 * cos(radians(theta)))\n            y_hit = y_corner - v0 * time * sin(radians(theta + omega * time))\n            if y_hit <= 0:\n                return time\n        elif theta < 315:\n            time = (wall_x - x_corner) / (v0 * sin(radians(theta)))\n            y_hit = y_corner - v0 * time * cos(radians(theta + omega * time))\n            if y_hit >= 0:\n                return time\n        else:\n            time = (wall_x - x_corner) / (v0 * cos(radians(theta)))\n            y_hit = y_corner + v0 * time * sin(radians(theta + omega * time))\n            if y_hit <= 0:\n                return time\n\n    stdin = stdin.split('\\n')\n    n, omega, v0, theta, wall_x = map(float, re.findall(r\"[-+]?\\d*\\.\\d+|\\d+\", stdin[0]))\n    theta = radians(theta)\n    x, y = [], []\n\n    for i in range(int(n)):\n        x_i, y_i = map(float, stdin[i + 1].split())\n        x.append(x_i)\n        y.append(y_i)\n\n    min_time = float('inf')\n    min_corner = 0\n\n    for corner in range(1, int(n) + 1):\n        time = time_to_hit_wall(x, y, theta, omega, v0, wall_x, corner)\n        if time is not None:\n            if time < min_time:\n                min_time = time\n                min_corner = corner\n\n    return f\"{min_corner} {round(min_time, 6)}\\n\""
    },
    {
        "number": 3149,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from math import sin, cos, radians, pi\n    from bisect import bisect_left\n\n    def parabola_equation(x, initial_angle, initial_speed, angular_velocity):\n        angle = radians(initial_angle)\n        return initial_speed * x * tan(angle) - 0.5 * angular_velocity * (x ** 2)\n\n    def rotate(x, y, angle):\n        rad = radians(angle)\n        return x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad)\n\n    def find_first_corner_to_hit_wall(corner_indices, corner_positions, initial_angle, initial_speed, angular_velocity, wall_x):\n        times = [parabola_equation(corner_positions[i][0], initial_angle, initial_speed, angular_velocity) for i in corner_indices]\n        times.sort()\n\n        for i, time in enumerate(times):\n            rotated_positions = [rotate(x, y, time * angular_velocity) for x, y in corner_positions]\n            valid_indices = [i for i, (x, y) in enumerate(rotated_positions) if x <= wall_x]\n\n            if valid_indices:\n                return corner_indices[i], time\n\n        return None, None\n\n    def main():\n        n, omega, v0, theta, w = map(float, stdin.readline().split())\n        n = int(n)\n        theta = int(theta)\n        w = int(w)\n\n        corner_positions = [list(map(float, stdin.readline().split())) for _ in range(n)]\n\n        corner_indices = list(range(1, n + 1))\n        first_corner_index, first_corner_time = find_first_corner_to_hit_wall(corner_indices, corner_positions, theta, v0, omega, w)\n\n        if first_corner_index is not None:\n            return f\"{first_corner_index} {first_corner_time:.6f}\"\n        else:\n            return \"No corner hits the wall.\"\n\n    return main() "
    },
    {
        "number": 3149,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(x, y, angle):\n        return x * cos(angle) - y * sin(angle), x * sin(angle) + y * cos(angle)\n\n    def project(x, y, velocity, angle):\n        return x + velocity * cos(angle), y + velocity * sin(angle)\n\n    def distance_to_wall(x, y, wall_x):\n        return abs(x - wall_x)\n\n    def compute_time(x, y, velocity, angle, angular_velocity):\n        dx, dy = 0, 1\n        time = 0\n        while distance_to_wall(x, y, wall_x) >= 1e-3:\n            dx, dy = rotate(dx, dy, angular_velocity)\n            x, y = project(x, y, velocity, angle + angular_velocity * time)\n            time += 1e-6\n        return time\n\n    def find_first_corner_to_hit_wall(corners, velocity, angle, angular_velocity, wall_x):\n        times = []\n        for i, (x, y) in enumerate(corners):\n            time = compute_time(x, y, velocity, angle, angular_velocity)\n            times.append((i + 1, time))\n        return min(times, key=lambda x: x[1])\n\n    # Parse input\n    n, omega, v0, theta, w, *corner_coordinates = map(float, stdin.split())\n    n = int(n)\n    theta = theta * pi / 180\n    wall_x = w\n\n    # Parse corner coordinates\n    corners = []\n    for i in range(n):\n        x, y = map(float, corner_coordinates[i * 2:i * 2 + 2])\n        corners.append((x, y))\n\n    # Find first corner to hit wall\n    corner_index, time = find_first_corner_to_hit_wall(corners, v0, theta, omega, wall_x)\n\n    # Format output\n    output = f\"{corner_index} {time:.6f}\"\n    return output"
    },
    {
        "number": 3149,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(x, y, theta):\n        return x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta)\n\n    def distance_to_wall(x, y, w):\n        return abs(x - w)\n\n    def compute_time(v0, theta, distance):\n        return distance / v0 * cos(theta)\n\n    def parse_input(stdin):\n        lines = stdin.split(\"\\n\")\n        n, omega, v0, theta_deg, w = map(float, lines[0].split())\n        theta = theta_deg * pi / 180\n        corners = [(float(x), float(y)) for x, y in map(lambda x: x.split(), lines[1:])]\n        return n, omega, v0, theta, w, corners\n\n    n, omega, v0, theta, w, corners = parse_input(stdin)\n\n    for i, (x, y) in enumerate(corners):\n        corner_x, corner_y = rotate(x, y, theta)\n        distance = distance_to_wall(corner_x, corner_y, w)\n        time = compute_time(v0, theta, distance)\n        if i == 0:\n            min_i = i\n            min_time = time\n        elif time < min_time:\n            min_i = i\n            min_time = time\n\n    return f\"{min_i + 1} {min_time:.6f}\""
    },
    {
        "number": 3149,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    def dot_product(a, b):\n        return a[0] * b[0] + a[1] * b[1]\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def project_vector(a, b):\n        return dot_product(a, b) / distance(b, (0, 0)) ** 2\n\n    def is_clockwise(corners):\n        n = len(corners)\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            area += corners[i][0] * corners[j][1]\n            area -= corners[j][0] * corners[i][1]\n        return area > 0\n\n    def find_first_corner_to_hit_wall(corners, initial_angle, initial_speed, angular_velocity, wall_x):\n        time_to_hit = float('inf')\n        corner_to_hit = None\n\n        for i, corner in enumerate(corners):\n            corner_angle = math.atan2(corner[1], corner[0]) * 180 / math.pi\n            relative_angle = (corner_angle - initial_angle) % 360\n            angle_to_corner = math.radians(relative_angle)\n\n            distance_to_corner = distance(corner, (0, 0))\n            time_to_corner = distance_to_corner / initial_speed * math.cos(angle_to_corner)\n\n            time_to_rotate = angle_to_corner / angular_velocity\n\n            if time_to_rotate < time_to_corner:\n                time_to_corner -= 2 * time_to_rotate\n\n            time_to_hit_wall = abs(wall_x / math.cos(angle_to_corner))\n            time_to_hit_wall -= time_to_corner\n\n            if time_to_hit_wall < 0:\n                time_to_hit_wall += 2 * time_to_corner\n\n            if time_to_hit_wall < time_to_hit:\n                time_to_hit = time_to_hit_wall\n                corner_to_hit = i + 1\n\n        return corner_to_hit, time_to_hit\n\n    n, angular_velocity, initial_speed, initial_angle, wall_x = map(float, stdin.readline().split())\n    n = int(n)\n    initial_angle = math.radians(initial_angle)\n    corners = [list(map(float, stdin.readline().split())) for _ in range(n)]\n\n    if not is_clockwise(corners):\n        corners = corners[::-1]\n\n    corner_to_hit, time_to_hit = find_first_corner_to_hit_wall(corners, initial_angle, initial_speed, angular_velocity, wall_x)\n\n    return f\"{corner_to_hit} {time_to_hit:.6f}\"\n"
    },
    {
        "number": 3149,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    import math\n\n    n, omega, v_0, theta, w, *corner_coordinates = map(float, stdin.split())\n    n = int(n)\n    theta = math.radians(theta)\n\n    def projectile_trajectory(x, v_0, theta, omega):\n        return x * math.cos(omega * t) + v_0 * math.sin(theta) * t - 0.5 * 9.81 * t ** 2\n\n    def find_wall_collision(corner_index, corner_coordinate, v_0, theta, omega):\n        x, y = corner_coordinate\n        t = (x - y * math.tan(theta)) / math.cos(theta)\n        height = projectile_trajectory(t, v_0, theta, omega)\n        return t, height\n\n    wall_collisions = []\n    for i, (x, y) in enumerate(zip(corner_coordinates[::2], corner_coordinates[1::2])):\n        corner_coordinate = (x, y)\n        collision_time, height = find_wall_collision(i + 1, corner_coordinate, v_0, theta, omega)\n        if height <= 0:\n            wall_collisions.append((i + 1, collision_time))\n\n    first_collision = min(wall_collisions, key=lambda x: x[1])\n    return f\"{first_collision[0]} {round(first_collision[1], 6)}\\n\""
    },
    {
        "number": 3149,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_point(point, angle):\n        x, y = point\n        radians = angle * math.pi / 180\n        new_x = x * math.cos(radians) - y * math.sin(radians)\n        new_y = x * math.sin(radians) + y * math.cos(radians)\n        return new_x, new_y\n\n    def get_parabola_y(x, v0, theta, omega):\n        return x * math.tan(theta * math.pi / 180) - 0.5 * (omega ** 2) * (x ** 2) / (v0 ** 2)\n\n    def get_time_to_hit_wall(cookie, wall_x, v0, theta, omega):\n        x, y = cookie\n        y_parabola = get_parabola_y(x, v0, theta, omega)\n        time_to_hit_wall = (x - abs(y - y_parabola)) / v0\n        return time_to_hit_wall\n\n    def get_time_to_hit_wall_for_all_corners(corners, wall_x, v0, theta, omega):\n        times_to_hit_wall = [get_time_to_hit_wall(corner, wall_x, v0, theta, omega) for corner in corners]\n        return times_to_hit_wall\n\n    def find_first_corner_to_hit_wall(corners, times_to_hit_wall):\n        first_corner_index = times_to_hit_wall.index(min(times_to_hit_wall))\n        first_corner_time = min(times_to_hit_wall)\n        return first_corner_index + 1, first_corner_time\n\n    n, omega, v0, theta, wall_x = list(map(float, stdin.readline().split()))\n    theta = theta * math.pi / 180\n    corners = [list(map(float, stdin.readline().split())) for _ in range(int(n))]\n\n    times_to_hit_wall = get_time_to_hit_wall_for_all_corners(corners, wall_x, v0, theta, omega)\n    first_corner_index, first_corner_time = find_first_corner_to_hit_wall(corners, times_to_hit_wall)\n\n    return f\"{first_corner_index} {first_corner_time:.6f}\\n\""
    },
    {
        "number": 3150,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def slope(a, b):\n        return (b[1] - a[1]) / (b[0] - a[0])\n\n    def is_collinear(a, b, c):\n        return slope(a, b) == slope(b, c)\n\n    def count_guards(points):\n        guards = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if is_collinear(points[i], points[j], [0, 0]):\n                    guards += 1\n        return guards\n\n    def remove_endpoints(trenches):\n        new_trenches = []\n        for trench in trenches:\n            new_trenches.append((trench[0], trench[1], trench[2], trench[3]))\n            new_trenches.append((trench[2], trench[3], trench[0], trench[1]))\n        return new_trenches\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    trenches = [list(map(int, line.split())) for line in lines[1:N + 1]]\n    points = remove_endpoints(trenches)\n    return str(count_guards(points))"
    },
    {
        "number": 3150,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_between(p1, p2, p3):\n        return (p1[0] <= p2[0] <= p3[0]) or (p1[0] >= p2[0] >= p3[0])\n\n    def is_visible(p1, p2, trenches):\n        for t in trenches:\n            if (is_between(t[0], p1, p2) and is_between(t[1], p1, p2)):\n                return False\n        return True\n\n    def count_placements(trenches, guards, curr_guard):\n        if curr_guard == len(guards):\n            return 1\n\n        count = 0\n        for i in range(len(guards)):\n            if is_visible(guards[curr_guard], guards[i], trenches):\n                count += count_placements(trenches, guards, curr_guard + 1)\n\n        return count\n\n    N = int(stdin.readline().strip())\n    trenches = []\n    for _ in range(N):\n        X1, Y1, X2, Y2 = map(int, stdin.readline().strip().split())\n        trenches.append(((X1, Y1), (X2, Y2)))\n\n    guards = [(0, 0), (1000, 0), (0, 1000)]\n    return str(count_placements(trenches, guards, 0))"
    },
    {
        "number": 3150,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x1, y1, x2, y2, X1, Y1, X2, Y2):\n        if x1 == X1 and y1 == Y1:\n            return False\n        if x2 == X2 and y2 == Y2:\n            return False\n        if x1 == x2:\n            return False\n        if y1 == y2:\n            return False\n        return True\n\n    def count_ways(x1, y1, x2, y2):\n        dx = x2 - x1\n        dy = y2 - y1\n        if dx == 0:\n            return 2 * (N - 1)\n        if dy == 0:\n            return 2 * (N - 1)\n        return N - 1\n\n    N, trenches = int(stdin.readline().strip()), [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n    valid_trenches = [trench for trench in trenches if is_valid(*trench)]\n    total_ways = 1\n    for x1, y1, x2, y2 in valid_trenches:\n        total_ways *= count_ways(x1, y1, x2, y2)\n        total_ways %= 1000000007\n    return str(total_ways) "
    },
    {
        "number": 3150,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    trenches = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def can_see(guard1, guard2, trenches):\n        x1, y1 = guard1\n        x2, y2 = guard2\n        for x3, y3, x4, y4 in trenches:\n            if x1 == x2 == x3 == x4:\n                if y1 < y3 < y2 or y1 > y3 > y2:\n                    return False\n            elif y1 == y2 == y3 == y4:\n                if x1 < x3 < x2 or x1 > x3 > x2:\n                    return False\n        return True\n\n    def count_ways(guards, trenches):\n        if len(guards) == 3:\n            return 1\n        ways = 0\n        for i in range(len(guards)):\n            for j in range(i + 1, len(guards)):\n                if can_see(guards[i], guards[j], trenches):\n                    new_guards = guards[:i] + guards[i + 1:j] + guards[j + 1:] + [(guards[i], guards[j])]\n                    ways += count_ways(new_guards, trenches)\n        return ways\n\n    guards = [(0, 0), (1000, 0), (0, 1000), (1000, 1000)]\n    return str(count_ways(guards, trenches))"
    },
    {
        "number": 3150,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def slope(x1, y1, x2, y2):\n        return (x2 - x1) / (y2 - y1)\n\n    def is_collinear(x1, y1, x2, y2, x3, y3):\n        return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0\n\n    def is_collinear_trench(x1, y1, x2, y2, trench):\n        return is_collinear(x1, y1, x2, y2, trench[0], trench[1]) and is_collinear(x1, y1, x2, y2, trench[2], trench[3])\n\n    def can_see(x1, y1, x2, y2, trenches):\n        for trench in trenches:\n            if is_collinear_trench(x1, y1, x2, y2, trench):\n                return False\n        return True\n\n    def count_ways(trenches, current_guard_position, remaining_guards):\n        if remaining_guards == 0:\n            return 1\n\n        count = 0\n        for i in range(len(trenches)):\n            if can_see(current_guard_position, 0, trenches[i][0], trenches[i][1], trenches):\n                count += count_ways(trenches[:i] + trenches[i+1:], trenches[i][0], remaining_guards - 1)\n        return count\n\n    N = int(stdin.readline().strip())\n    trenches = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        trenches.append((x1, y1, x2, y2))\n\n    return str(count_ways(trenches, 0, 3))"
    },
    {
        "number": 3150,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def slope(x1, y1, x2, y2):\n        if x1 == x2:\n            return float('inf')\n        return (y2 - y1) / (x2 - x1)\n\n    def is_collinear(x1, y1, x2, y2, x3, y3):\n        if x1 == x2 == x3:\n            return True\n        if y1 == y2 == y3:\n            return True\n        return slope(x1, y1, x2, y2) == slope(x2, y2, x3, y3)\n\n    def find_collinear_pairs(trenches):\n        collinear_pairs = []\n        for i in range(len(trenches)):\n            for j in range(i + 1, len(trenches)):\n                if is_collinear(*trenches[i], *trenches[j]):\n                    collinear_pairs.append((trenches[i], trenches[j]))\n        return collinear_pairs\n\n    def find_visible_pairs(collinear_pairs):\n        visible_pairs = []\n        for pair in collinear_pairs:\n            if pair[0][0] < pair[1][0] and pair[0][1] < pair[1][1]:\n                visible_pairs.append(pair)\n        return visible_pairs\n\n    N = int(stdin.readline())\n    trenches = [tuple(map(int, stdin.readline().split())) for _ in range(N)]\n\n    collinear_pairs = find_collinear_pairs(trenches)\n    visible_pairs = find_visible_pairs(collinear_pairs)\n\n    return str(len(visible_pairs) * (len(visible_pairs) - 1) // 2)"
    },
    {
        "number": 3150,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def are_visible(p1, p2, points):\n        x1, y1 = p1\n        x2, y2 = p2\n        for x, y in points:\n            if (x1 < x < x2 or x1 > x > x2) and (y1 < y < y2 or y1 > y > y2):\n                return False\n        return True\n\n    def can_see_trench(guard, trench, points):\n        x1, y1, x2, y2 = trench\n        return are_visible((x1, y1), (x2, y2), points)\n\n    def count_ways(guards, trenches, points):\n        if not trenches:\n            return 1\n        count = 0\n        for guard in guards:\n            if can_see_trench(guard, trenches[0], points):\n                count += count_ways(guards - {guard}, trenches[1:], points | {guard})\n        return count\n\n    def read_input(stdin):\n        lines = stdin.split('\\n')\n        N = int(lines[0])\n        trenches = []\n        for i in range(1, N + 1):\n            trench = [int(x) for x in lines[i].split()]\n            trenches.append(trench)\n        return N, trenches\n\n    N, trenches = read_input(stdin)\n    guards = {(0, 0), (1000, 0), (0, 1000)}\n    points = set()\n    for trench in trenches:\n        points.add((trench[0], trench[1]))\n        points.add((trench[2], trench[3]))\n\n    return count_ways(guards, trenches, points)"
    },
    {
        "number": 3150,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def slope(x1, y1, x2, y2):\n        return (x2 - x1) / (y2 - y1)\n\n    def can_see(x1, y1, x2, y2, m1, m2):\n        if x1 == x2 and y1 == y2:\n            return False\n        if x1 == x2:\n            return abs(y1 - y2) > 1\n        if y1 == y2:\n            return abs(x1 - x2) > 1\n        s1, s2 = slope(x1, y1, x2, y2), slope(x2, y2, m1, m2)\n        return s1 == s2\n\n    def count_ways(x1, y1, x2, y2, trenches):\n        return sum(can_see(x1, y1, x2, y2, m1, m2) for m1, m2 in trenches)\n\n    N = int(stdin.readline().strip())\n    trenches = [tuple(map(int, stdin.readline().strip().split())) for _ in range(N)]\n    result = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            result += count_ways(trenches[i][0], trenches[i][1], trenches[i][2], trenches[i][3], trenches)\n            result += count_ways(trenches[j][0], trenches[j][1], trenches[j][2], trenches[j][3], trenches)\n    return str(result // 2)"
    },
    {
        "number": 3150,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    trenches = []\n    for i in range(1, N + 1):\n        X1, Y1, X2, Y2 = map(int, lines[i].split())\n        trenches.append(((X1, Y1), (X2, Y2)))\n\n    # Check which trenches can be seen from each point\n    visible_trenches = {}\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                if (trenches[i][0] == trenches[j][0] or trenches[i][0] == trenches[j][1] or\n                        trenches[i][1] == trenches[j][0] or trenches[i][1] == trenches[j][1]):\n                    if (trenches[i][0], trenches[j][0]) not in visible_trenches:\n                        visible_trenches[(trenches[i][0], trenches[j][0])] = set()\n                    visible_trenches[(trenches[i][0], trenches[j][0])].add(i)\n                    visible_trenches[(trenches[i][0], trenches[j][0])].add(j)\n                    visible_trenches[(trenches[i][1], trenches[j][1])] = set()\n                    visible_trenches[(trenches[i][1], trenches[j][1])].add(i)\n                    visible_trenches[(trenches[i][1], trenches[j][1])].add(j)\n\n    # Find all points where there are at least two trenches visible\n    potential_guard_points = []\n    for point, visible in visible_trenches.items():\n        if len(visible) >= 2:\n            potential_guard_points.append(point)\n\n    # Check each pair of potential guard points to see if they can see each other\n    guard_points = []\n    for i in range(len(potential_guard_points)):\n        for j in range(i + 1, len(potential_guard_points)):\n            if (potential_guard_points[i], potential_guard_points[j]) in visible_trenches:\n                guard_points.append((potential_guard_points[i], potential_guard_points[j]))\n\n    # Count the number of ways the guards can be placed\n    count = 0\n    for i in range(len(guard_points)):\n        for j in range(i + 1, len(guard_points)):\n            if guard_points[i][0] != guard_points[j][0] and guard_points[i][1] != guard_points[j][1]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3150,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_visible(point1, point2, points):\n        x1, y1 = point1\n        x2, y2 = point2\n        for p in points:\n            px, py = p\n            if x1 == x2 == px:\n                if min(y1, y2) < py < max(y1, y2):\n                    return False\n            elif y1 == y2 == py:\n                if min(x1, x2) < px < max(x1, x2):\n                    return False\n        return True\n\n    def count_ways(points, guards, current_guard):\n        if current_guard == 3:\n            return 1\n\n        count = 0\n        for i in range(len(points)):\n            if is_visible(guards[current_guard], points[i], guards):\n                count += count_ways(points[:i] + points[i+1:], guards + [points[i]], current_guard + 1)\n\n        return count\n\n    N = int(stdin.readline())\n    trenches = [tuple(map(int, stdin.readline().split())) for _ in range(N)]\n\n    trenches = sorted(trenches, key=lambda x: (x[0], x[1], x[2], x[3]))\n\n    points = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if trenches[i][0] == trenches[i][2]:\n                if trenches[j][0] == trenches[j][2] and trenches[i][0] == trenches[j][0]:\n                    points.append((trenches[i][1], trenches[i][3]))\n            elif trenches[i][1] == trenches[i][3]:\n                if trenches[j][1] == trenches[j][3] and trenches[i][1] == trenches[j][1]:\n                    points.append((trenches[i][0], trenches[i][2]))\n\n    points = sorted(set(points))\n\n    return str(count_ways(points, [], 0))"
    },
    {
        "number": 3151,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    m = int(n ** 0.5)\n    \n    if m * m == n:\n        return \"impossible\"\n    \n    while m > 0:\n        if n % m == 0:\n            k = n // m\n            if k < m and m * m - k * k == n:\n                return f\"{m} {k}\"\n        m -= 1\n    \n    return \"impossible\""
    },
    {
        "number": 3151,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for m in range(1, n+1):\n        for k in range(1, m):\n            if n == m**2 - k**2:\n                return f\"{m} {k}\"\n    return \"impossible\""
    },
    {
        "number": 3151,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    for m in range(1, n + 1):\n        k = n - m * m\n        if k < 0:\n            break\n        if k % m == 0:\n            k_prime = k // m\n            return f\"{m} {k_prime}\\n\"\n    return \"impossible\\n\""
    },
    {
        "number": 3151,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    for m in range(1, int(n**0.5) + 1):\n        k = n - m**2\n        if k < 0:\n            break\n        k = int(k**0.5)\n        if k**2 == n - m**2:\n            return f\"{m} {k}\"\n    return \"impossible\""
    },
    {
        "number": 3151,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    for m in range(1, n):\n        k = n - m * m\n        if k < 0:\n            break\n        if (int(k ** 0.5)) ** 2 == k:\n            return f\"{m} {int(k ** 0.5)}\"\n    \n    return \"impossible\""
    },
    {
        "number": 3151,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 0:\n        return \"impossible\"\n    for m in range(int(n**0.5), -1, -1):\n        if m**2 - n >= 0:\n            k = int((m**2 - n)**0.5)\n            if (m**2 - n) == k**2:\n                return f\"{m} {k}\"\n    return \"impossible\""
    },
    {
        "number": 3151,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    if n < 1 or n > 10**9:\n        return \"impossible\"\n\n    for m in range(1, int(n**0.5) + 1):\n        k = n - m**2\n        if k < 0:\n            break\n        if (k**0.5).is_integer():\n            return f\"{m} {int(k**0.5)}\"\n\n    return \"impossible\""
    },
    {
        "number": 3151,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    m = 1\n    while True:\n        m_squared = m ** 2\n        for k in range(1, m):\n            if m_squared - k ** 2 == n:\n                return f\"{m} {k}\"\n        if m_squared > n:\n            return \"impossible\"\n        m += 1"
    },
    {
        "number": 3151,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    for m in range(1, n + 1):\n        if m * m > n:\n            break\n        k = n - m * m\n        if (k + m) % 2 == 0 and (k - m) % 2 == 0:\n            return f\"{m} {int((k + m) // 2)}\\n{m} {int((k - m) // 2)}\"\n    return \"impossible\""
    },
    {
        "number": 3151,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            m = i\n            k = n // i\n            if n == m**2 - k**2:\n                return f\"{m} {k}\"\n\n    return \"impossible\"\n"
    },
    {
        "number": 3152,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split('\\n')))\n    n = input_data[0]\n    input_data = input_data[1:]\n    input_data.sort()\n\n    total_sum = 0\n    for i in range(n - 1):\n        if input_data[i] == input_data[i + 1]:\n            continue\n        min_val = input_data[i]\n        max_val = input_data[i + 1]\n        length = max_val - min_val + 1\n        subsequence_price = min_val * max_val * length\n        total_sum += subsequence_price\n\n    return str(total_sum)[-9:].lstrip('0')\n"
    },
    {
        "number": 3152,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = [int(x) for x in stdin.split('\\n')[1:]]\n\n    total_sum = 0\n    for i in range(n):\n        for j in range(i, n):\n            sub_arr = arr[i:j+1]\n            min_val = min(sub_arr)\n            max_val = max(sub_arr)\n            length = len(sub_arr)\n            price = min_val * max_val * length\n            total_sum += price\n\n    return str(total_sum)[-9:]"
    },
    {
        "number": 3152,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split('\\n')))\n    N = input_list[0]\n    input_list = input_list[1:]\n    input_list.sort()\n\n    total_sum = 0\n    for i in range(N):\n        min_value = input_list[i]\n        max_value = input_list[i]\n        length = 1\n\n        for j in range(i + 1, N):\n            if input_list[j] == input_list[j - 1] + 1:\n                length += 1\n                max_value = input_list[j]\n            else:\n                break\n\n        total_sum += min_value * max_value * length\n\n    return str(total_sum)[-9:]"
    },
    {
        "number": 3152,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = []\n    for _ in range(n):\n        arr.append(int(stdin.readline().strip()))\n\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i, n):\n            min_val = min(arr[i:j+1])\n            max_val = max(arr[i:j+1])\n            cost = min_val * max_val * (j-i+1)\n            min_cost = min(min_cost, cost)\n\n    return str(min_cost)[-9:]"
    },
    {
        "number": 3152,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = [int(x) for x in stdin.readlines()]\n\n    prices = []\n    for i in range(n):\n        for j in range(i, n):\n            subseq = arr[i:j + 1]\n            min_val = min(subseq)\n            max_val = max(subseq)\n            length = len(subseq)\n            price = min_val * max_val * length\n            prices.append(price)\n\n    total_price = sum(prices)\n    result = total_price % (10 ** 9)\n\n    return str(result)"
    },
    {
        "number": 3152,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    array = [int(x) for x in stdin.readlines()]\n    array.sort()\n    min_ = array[0]\n    max_ = array[-1]\n    length = len(array)\n    prices = []\n    for i in range(length):\n        for j in range(i, length):\n            l = j - i + 1\n            p = min_ * max_ * l\n            prices.append(p)\n    total = sum(prices) % (10 ** 9)\n    return str(total)"
    },
    {
        "number": 3152,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    arr = []\n    for i in range(n):\n        arr.append(int(stdin.readline()))\n\n    min_value = min(arr)\n    max_value = max(arr)\n    length = len(arr)\n\n    total_sum = 0\n    for i in range(length):\n        for j in range(i, length):\n            sub_min = min(arr[i:j + 1])\n            sub_max = max(arr[i:j + 1])\n            sub_length = j - i + 1\n            total_sum += sub_min * sub_max * sub_length\n\n    return str(total_sum % (10 ** 9))\n"
    },
    {
        "number": 3152,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1:]))\n    total_sum = 0\n\n    for i in range(n):\n        min_val = arr[i]\n        max_val = arr[i]\n        length = 1\n\n        for j in range(i + 1, n):\n            if arr[j] == arr[j - 1] + 1:\n                length += 1\n                min_val = min(min_val, arr[j])\n                max_val = max(max_val, arr[j])\n            else:\n                break\n\n        total_sum += min_val * max_val * length\n\n    return str(total_sum % (10 ** 9))\n"
    },
    {
        "number": 3152,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n', 1)[0])\n    arr = [int(x) for x in stdin.split('\\n')[1:]]\n    \n    total_sum = 0\n    for i in range(n):\n        min_val = max_val = arr[i]\n        length = 1\n        j = i + 1\n        while j < n and arr[j] == arr[j - 1] + 1:\n            max_val = arr[j]\n            length += 1\n            j += 1\n        price = min_val * max_val * length\n        total_sum += price\n    \n    return str(total_sum % 1000000000)"
    },
    {
        "number": 3152,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = [int(x) for x in stdin.split(\"\\n\")[1:]]\n    arr.sort()\n    total_sum = 0\n\n    for i in range(n):\n        min_val = arr[i]\n        max_val = arr[n - 1 - i]\n        length = max_val - min_val + 1\n        if length > 0:\n            total_sum += min_val * max_val * length\n\n    return str(total_sum)[-9:].lstrip('0')"
    },
    {
        "number": 3153,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distribute_cards(cards: int, winners: List[int]) -> List[int]:\n        cards_per_winner = cards // len(winners)\n        remainder = cards % len(winners)\n        return [cards_per_winner + (1 if i < remainder else 0) for i, _ in enumerate(winners)]\n\n    def solve(N: int, M: int, cards: List[int], purchases: List[Tuple[int, int]]) -> str:\n        winners = [0] * N\n        total_purchases = 0\n        for purchase in purchases:\n            a, b = purchase\n            cards_a = distribute_cards(cards[a], winners)\n            cards_b = distribute_cards(cards[b], winners)\n            winners[a] += cards_a[0]\n            winners[b] += cards_b[1]\n            total_purchases += 1\n\n        result = [str(total_purchases)]\n        for purchase, i in zip(purchases, range(total_purchases)):\n            a, b = purchase\n            result.append(f\"{a} {b} {winners[a] if i % 2 == 0 else winners[b]}\")\n\n        return \"\\n\".join(result)\n\n    N, M = map(int, stdin.readline().split())\n    cards = list(map(int, stdin.readline().split()))\n    purchases = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n\n    return solve(N, M, cards, purchases) "
    },
    {
        "number": 3153,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    card_counts = list(map(int, input_list[1].split()))\n    purchases = [list(map(int, input_list[i+2].split())) for i in range(M)]\n\n    # Initialize variables\n    card_counts = [0] * N + card_counts\n    total_purchases = 0\n    output = []\n\n    # Loop through purchases\n    for purchase in purchases:\n        total_purchases += 1\n        a, b = purchase\n        card_counts[a] += 1\n        card_counts[b] += 1\n        winner = (a + b) % 2\n        output.append([a, b, winner])\n\n    # Output result\n    result = [str(total_purchases)] + [' '.join(map(str, row)) for row in output]\n    return '\\n'.join(result)"
    },
    {
        "number": 3153,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_purchases(cards, n, m):\n        purchases = []\n        for i in range(m):\n            a, b = purchases[i]\n            cards_a = (cards[a] + 1) // 2\n            cards_b = (cards[b] + 1) // 2\n            cards[a] -= cards_a\n            cards[b] -= cards_b\n            if cards_a == cards_b:\n                continue\n            elif cards_a > cards_b:\n                winner = a\n            else:\n                winner = b\n            purchases.append((a, b, winner))\n        return purchases\n\n    def output_purchases(purchases):\n        output = [str(len(purchases))]\n        for purchase in purchases:\n            output.append(\" \".join(map(str, purchase)))\n        return \"\\n\".join(output)\n\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    cards = list(map(int, lines[1].split()))\n    purchases = find_purchases(cards, n, m)\n    return output_purchases(purchases)"
    },
    {
        "number": 3153,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    card_counts = list(map(int, stdin.split()[2:(N + 2)]))\n    purchases = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            purchases.append((i + 1, j + 1))\n\n    def is_valid(purchases, card_counts, N):\n        total_cards = [0] * N\n        for purchase in purchases:\n            card1 = 1\n            card2 = 1\n            if total_cards[purchase[0] - 1] < card_counts[purchase[0] - 1]:\n                total_cards[purchase[0] - 1] += card1\n            if total_cards[purchase[1] - 1] < card_counts[purchase[1] - 1]:\n                total_cards[purchase[1] - 1] += card2\n\n        return total_cards == card_counts\n\n    def helper(purchases, card_counts, N, result):\n        if len(purchases) == 0:\n            if is_valid(result, card_counts, N):\n                return True\n            else:\n                return False\n\n        for i in range(len(purchases)):\n            purchase = purchases[i]\n            result.append(purchase)\n            if helper(purchases[:i] + purchases[i + 1:], card_counts, N, result):\n                return True\n            result.pop()\n        return False\n\n    def find_purchases(purchases, card_counts, N):\n        result = []\n        if helper(purchases, card_counts, N, result):\n            return result\n        else:\n            return []\n\n    purchase_list = find_purchases(purchases, card_counts, N)\n    output = [str(len(purchase_list))]\n    for purchase in purchase_list:\n        output.append(\" \".join(map(str, purchase)))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3153,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def purchase(child1, child2, cards1, cards2):\n        nonlocal result\n        if cards1 == cards2:\n            result += f\"{child1} {child2} 0\\n\"\n            result += f\"{child1} {child2} 0\\n\"\n        elif cards1 > cards2:\n            result += f\"{child1} {child2} 1\\n\"\n        else:\n            result += f\"{child1} {child2} 2\\n\"\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    counts = list(map(int, lines[1].split()))\n    children = [i for i in range(1, N + 1)]\n    result = str(M) + \"\\n\"\n\n    for i in range(2, M + 1):\n        for j in range(i):\n            child1, child2 = map(int, lines[j + 2].split())\n            cards1, cards2 = counts[children.index(child1)], counts[children.index(child2)]\n            purchase(child1, child2, cards1, cards2)\n            counts[children.index(child1)] -= 1\n            counts[children.index(child2)] -= 1\n\n    return result"
    },
    {
        "number": 3153,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def buy_cards(children: int, funds: int) -> int:\n        return funds // (2 * children)\n\n    def win_cards(race: tuple, cards: int) -> tuple:\n        winner = sorted(race, key=lambda x: -race.index(x))\n        loser = [x for x in race if x != winner[0]][0]\n        cards_won = min(cards, 2)\n        if winner[0] == winner[1]:\n            cards_won = 1\n        return (winner[0], loser, cards_won)\n\n    def cards_count(purchases: list, children: int) -> int:\n        cards = [0] * children\n        for purchase in purchases:\n            cards[purchase[0] - 1] += purchase[2]\n            cards[purchase[1] - 1] += 2 - purchase[2]\n        return cards\n\n    def solve(N: int, M: int, children_counts: list, purchases: list) -> str:\n        result = []\n        for purchase in purchases:\n            cards_bought = buy_cards(N, children_counts[purchase[0] - 1] + children_counts[purchase[1] - 1])\n            children_counts[purchase[0] - 1] += cards_bought\n            children_counts[purchase[1] - 1] += cards_bought\n            result.append(win_cards(purchase, cards_bought))\n\n        return \"\\n\".join([\" \".join(map(str, purchase)) for purchase in result])\n\n    input_data = list(map(str.strip, stdin.split(\"\\n\")))\n    N, M = map(int, input_data[0].split())\n    children_counts = list(map(int, input_data[1].split()))\n    purchases = [list(map(int, line.split())) for line in input_data[2:]]\n\n    output = f\"{M}\\n{solve(N, M, children_counts, purchases)}\"\n    return output"
    },
    {
        "number": 3153,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, M = map(int, stdin.readline().split())\n    card_counts = list(map(int, stdin.readline().split()))\n    purchases = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    # Initialize variables\n    total_purchases = 0\n    card_pool = [0] * N\n\n    # Function to simulate a race and update the card_pool\n    def race(card_pool, first_child, second_child):\n        if card_pool[first_child] == card_pool[second_child]:\n            card_pool[first_child] += 1\n            card_pool[second_child] -= 1\n            return 0\n        elif card_pool[first_child] > card_pool[second_child]:\n            card_pool[first_child] += 1\n            card_pool[second_child] -= 1\n            return 1\n        else:\n            card_pool[second_child] += 1\n            card_pool[first_child] -= 1\n            return 2\n\n    # Loop through purchases and simulate races\n    for purchase in purchases:\n        first_child, second_child = purchase\n        total_purchases += 1\n        card_pool[first_child] += 1\n        card_pool[second_child] += 1\n        winner = race(card_pool, first_child, second_child)\n        print(f\"{first_child} {second_child} {winner}\")\n\n    return str(total_purchases)"
    },
    {
        "number": 3153,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    N, M = map(int, stdin.readline().split())\n    counts = list(map(int, stdin.readline().split()))\n    purchases = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    # Initialize variables\n    total_purchases = 0\n    cards = [0] * N\n\n    # Process the purchases\n    for a, b in purchases:\n        # Determine the winner of the race\n        if counts[a - 1] > counts[b - 1]:\n            winner = a\n        elif counts[a - 1] < counts[b - 1]:\n            winner = b\n        else:\n            winner = a\n\n        # Update the cards counts\n        cards[a - 1] += 1\n        cards[b - 1] += 1\n\n        # Update the counts\n        counts[winner - 1] += 1\n\n        # Increment the total number of purchases\n        total_purchases += 1\n\n    # Generate the output\n    output = [str(total_purchases)]\n    for i in range(M):\n        a, b = purchases[i]\n        if counts[a - 1] > counts[b - 1]:\n            winner = a\n        elif counts[a - 1] < counts[b - 1]:\n            winner = b\n        else:\n            winner = a\n\n        if winner == a:\n            output.append(f\"{a} {b} 2\")\n        else:\n            output.append(f\"{a} {b} 0\")\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3153,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_purchase(cards):\n        for i in range(len(cards)):\n            if cards[i] < 2:\n                return i, 2 - cards[i]\n            elif cards[i] > 1:\n                return i, 1\n        return None, None\n\n    def output_purchase(purchase, winner):\n        return f\"{purchase[0]} {purchase[1]} {winner}\\n\"\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    cards = list(map(int, lines[1].split()))\n    purchases = []\n\n    for i in range(M):\n        purchase = tuple(map(int, lines[i + 2].split()))\n        purchases.append(purchase)\n        cards[purchase[0] - 1] -= 1\n        cards[purchase[1] - 1] -= 1\n\n    output = ''\n    output += str(len(purchases)) + '\\n'\n\n    for purchase in purchases:\n        winner = find_purchase(cards)\n        output += output_purchase(purchase, winner[1])\n        cards[winner[0]] += winner[1]\n\n    return output"
    },
    {
        "number": 3153,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_lines = stdin.split('\\n')\n    N, M = map(int, input_lines[0].split())\n    card_counts = list(map(int, input_lines[1].split()))\n    purchases = [list(map(int, input_lines[i+2].split())) for i in range(M)]\n\n    # Initialize variables\n    total_purchases = 0\n    purchase_descriptions = []\n    purchases_by_child = [[] for _ in range(N)]\n\n    # Create purchases\n    for child1, child2 in purchases:\n        total_purchases += 1\n        card_counts[child1] += 1\n        card_counts[child2] += 1\n        purchases_by_child[child1].append((child1, child2))\n        purchases_by_child[child2].append((child2, child1))\n\n    # Simulate races\n    for child in range(N):\n        for purchase in purchases_by_child[child]:\n            if purchase[0] == child:\n                # Child won the race\n                purchase_descriptions.append(purchase + [2])\n            else:\n                # Child lost the race\n                purchase_descriptions.append(purchase + [0])\n\n    # Verify card counts\n    for i, count in enumerate(card_counts):\n        if count != 0 and count != total_purchases:\n            raise ValueError(f\"Card count {count} for child {i+1} is invalid\")\n\n    # Format output\n    output = [str(total_purchases)] + [' '.join(map(str, pd)) for pd in purchase_descriptions]\n    return '\\n'.join(output)"
    },
    {
        "number": 3154,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        n, m = map(int, lines[0].split())\n        d, e = map(int, lines[1].split())\n        events = []\n        for i in range(2, e + 2):\n            s, k, t = map(int, lines[i].split())\n            events.append((s, k, t))\n        return n, m, d, e, events\n\n    def assign_toys(n: int, m: int, d: int, e: int, events: list) -> list:\n        toy_count = [0] * (m + 1)\n        last_played = [0] * (n + 1)\n        toy_players = [[] for _ in range(m + 1)]\n\n        for event in events:\n            s, k, t = event\n            if t > 0:\n                toy_count[t] += 1\n                toy_players[t].append(k)\n                if s > last_played[k]:\n                    last_played[k] = s\n            else:\n                toy_count[t] -= 1\n                toy_players[t].remove(k)\n\n        toy_allocation = [0] * (n + 1)\n        for t in range(1, m + 1):\n            for k in toy_players[t]:\n                toy_allocation[k] = t\n\n        return toy_allocation\n\n    def check_crying(n: int, m: int, d: int, e: int, events: list, toy_allocation: list) -> bool:\n        envy = [[False] * (n + 1) for _ in range(n + 1)]\n        for i in range(e):\n            s, k, t = events[i]\n            if t > 0:\n                for j in range(1, k):\n                    if toy_allocation[j] == t and last_played[j] < last_played[k]:\n                        envy[j][k] = True\n                        envy[k][j] = True\n\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if envy[i][j] and toy_allocation[i] > 0 and toy_allocation[i] != toy_allocation[j]:\n                    return True\n        return False\n\n    n, m, d, e, events = parse_input(stdin)\n    toy_allocation = assign_toys(n, m, d, e, events)\n\n    if check_crying(n, m, d, e, events, toy_allocation):\n        return \"impossible\"\n    else:\n        return \" \".join(map(str, toy_allocation[1:])) "
    },
    {
        "number": 3154,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n, m, d, e = map(int, stdin.split(\"\\n\", 1)[0].split())\n    events = []\n    for line in stdin.strip().split(\"\\n\")[1:]:\n        s, k, t = map(int, line.split())\n        events.append((s, k, t))\n\n    # Calculate envy matrix\n    envy = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                for s, k, t in events:\n                    if k == i and t != 0:\n                        if events[-1][0] == d:\n                            envy[i][j] += d\n                        else:\n                            envy[i][j] += d - s\n                        break\n                for s, k, t in events:\n                    if k == j and t != 0:\n                        if events[-1][0] == d:\n                            envy[i][j] -= d\n                        else:\n                            envy[i][j] -= d - s\n                        break\n\n    # Assign toys\n    toy_assignment = [0] * n\n    assigned_toys = [False] * m\n    for i in range(n):\n        candidates = [(0, 0)] * m\n        for s, k, t in events:\n            if k == i:\n                if t == 0:\n                    break\n                candidates[t - 1] = (envy[i][k - 1], s)\n        best_candidate = max(candidates)\n        toy_assignment[i] = candidates.index(best_candidate) + 1\n        assigned_toys[toy_assignment[i] - 1] = True\n\n    # Check if any crying occurs\n    for s, k, t in events:\n        if k < n and t != 0:\n            for j in range(n):\n                if j != k and not assigned_toys[toy_assignment[j] - 1] and envy[k][j] > 0:\n                    return \"impossible\"\n\n    return \" \".join(map(str, toy_assignment))"
    },
    {
        "number": 3154,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d, e = map(int, stdin.readline().split())\n    time_to_play = [0] * n\n    playtime_events = []\n    toy_count = [0] * m\n\n    for _ in range(e):\n        s, k, t = map(int, stdin.readline().split())\n        playtime_events.append((s, k, t))\n\n    # Sort events by time\n    playtime_events.sort(key=lambda x: x[0])\n\n    # Process events\n    for event in playtime_events:\n        s, k, t = event\n        if t != 0:\n            toy_count[t - 1] += 1\n        if time_to_play[k - 1] == 0:\n            time_to_play[k - 1] = s\n\n    # Check if crying will occur\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                for k in range(m):\n                    if time_to_play[i] < time_to_play[j] and toy_count[k] > 0:\n                        return \"impossible\"\n\n    # Assign toys\n    toy_assignment = [0] * n\n    for i in range(n):\n        for k in range(m):\n            if toy_count[k] > 0:\n                toy_assignment[i] = k + 1\n                toy_count[k] -= 1\n                break\n\n    return \" \".join(map(str, toy_assignment))"
    },
    {
        "number": 3154,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_toy_envy(playtime, toy_players, toy_times):\n        envy = set()\n        for i in range(len(playtime)):\n            for j in range(len(playtime)):\n                if i != j:\n                    for toy in range(1, m + 1):\n                        if toy_players[i][toy] > 0 and toy_players[j][toy] == 0:\n                            envy.add((i, j, toy))\n        return envy\n\n    def assign_toys(kids, toys, envy, toy_players, toy_times):\n        assigned_toys = [-1] * kids\n        for toy in range(1, toys + 1):\n            for i in range(kids):\n                if assigned_toys[i] == -1 and toy_players[i][toy] > 0:\n                    assigned_toys[i] = toy\n                    break\n        for i in range(kids):\n            if assigned_toys[i] == -1:\n                for toy in range(1, toys + 1):\n                    if toy_players[i][toy] > 0:\n                        assigned_toys[i] = toy\n                        break\n        return assigned_toys\n\n    def check_crying(kids, assigned_toys, envy, toy_players, toy_times):\n        for i in range(kids):\n            for j in range(kids):\n                if i != j and (i, j, assigned_toys[i]) in envy:\n                    return True\n        return False\n\n    def play_time(stdin):\n        n, m, d, e = map(int, stdin.readline().split())\n        playtime = [[] for _ in range(n)]\n        toy_players = [[0] * (m + 1) for _ in range(n)]\n        toy_times = [0] * (m + 1)\n        for _ in range(e):\n            s, k, t = map(int, stdin.readline().split())\n            k -= 1\n            if t != 0:\n                toy_players[k][t] += 1\n                playtime[k].append((s, t))\n            else:\n                t = playtime[k].pop()[1]\n                toy_players[k][t] -= 1\n\n        for i in range(n):\n            playtime[i].sort(key=lambda x: x[0])\n            for j in range(1, len(playtime[i])):\n                toy = playtime[i][j][1]\n                if toy_players[i][toy] > 0:\n                    toy_times[toy] += playtime[i][j][0] - playtime[i][j - 1][0]\n\n        return n, m, toy_players, toy_times, get_toy_envy(playtime, toy_players, toy_times)\n\n    n, m, toy_players, toy_times, envy = play_time(stdin)\n\n    assigned_toys = assign_toys(n, m, envy, toy_players, toy_times)\n\n    if check_crying(n, assigned_toys, envy, toy_players, toy_times):\n        return \"impossible\"\n    else:\n        return \" \".join(map(str, assigned_toys))"
    },
    {
        "number": 3154,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d, e = map(int, stdin.split()[:4])\n    events = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    toy_used = [[] for _ in range(m)]\n    kids_toys = [0] * n\n\n    for event in events:\n        s, k, t = event\n        if kids_toys[k - 1] != 0:\n            toy_used[kids_toys[k - 1] - 1].append(k)\n        if t != 0:\n            kids_toys[k - 1] = t\n\n    for toy in toy_used:\n        if len(toy) > 1:\n            return \"impossible\"\n\n    return \" \".join(map(str, kids_toys))"
    },
    {
        "number": 3154,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_toy(kid):\n        for toy in range(m):\n            if toy not in assignments:\n                return toy\n        return -1\n\n    def check_cry(kid, toy):\n        for other_kid in range(n):\n            if other_kid == kid:\n                continue\n            if other_kid not in assignments:\n                continue\n            other_toy = assignments[other_kid]\n            if envies[other_kid][kid][other_toy] and other_toy > toy:\n                return True\n        return False\n\n    def assign_toy(kid, toy):\n        if check_cry(kid, toy):\n            return False\n        assignments[kid] = toy\n        return True\n\n    def assign_toys():\n        for kid in range(n):\n            if kid not in assignments:\n                toy = find_toy(kid)\n                if toy == -1:\n                    return False\n                if not assign_toy(kid, toy):\n                    return False\n        return True\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    d, e = map(int, lines[1].split())\n    events = [list(map(int, line.split())) for line in lines[2:2 + e]]\n\n    assignments = {}\n    envies = [[[0] * m for _ in range(n)] for _ in range(n)]\n\n    for s, kid, toy in events:\n        if toy == 0:\n            continue\n        for other_kid in range(n):\n            if other_kid == kid:\n                continue\n            if envies[other_kid][kid][toy] == 0:\n                envies[other_kid][kid][toy] = s\n            else:\n                envies[other_kid][kid][toy] = min(envies[other_kid][kid][toy], s)\n\n    if not assign_toys():\n        return \"impossible\"\n    else:\n        return \" \".join(map(str, assignments.values()))"
    },
    {
        "number": 3154,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def assign_toys(kids, toys, total_duration, events):\n        toys_assigned = [0] * kids\n        toy_play_count = [0] * toys\n        kids_play_count = [0] * kids\n\n        for event in events:\n            start_time, kid, toy = event\n            if toy == 0:\n                toy_play_count[toys_assigned[kid]] -= 1\n            else:\n                toys_assigned[kid] = toy\n                toy_play_count[toy] += 1\n                kids_play_count[kid] += 1\n\n        for kid in range(kids):\n            for toy in range(1, toys + 1):\n                if toy_play_count[toy] > kids_play_count[kid]:\n                    toys_assigned[kid] = toy\n                    break\n\n        return toys_assigned\n\n    def read_input(stdin: str) -> tuple:\n        input_list = stdin.split(\"\\n\")\n        kids, toys = map(int, input_list[0].split())\n        total_duration, events_count = map(int, input_list[1].split())\n        events = [list(map(int, event.split())) for event in input_list[2:]]\n\n        return kids, toys, total_duration, events_count, events\n\n    kids, toys, total_duration, events_count, events = read_input(stdin)\n    toys_assigned = assign_toys(kids, toys, total_duration, events)\n\n    if all(toy != 0 for toy in toys_assigned):\n        return \" \".join(map(str, toys_assigned))\n    else:\n        return \"impossible\""
    },
    {
        "number": 3154,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def read_line() -> List[str]:\n        return stdin.readline().strip().split()\n\n    def read_int() -> int:\n        return int(stdin.readline().strip())\n\n    def read_ints() -> List[int]:\n        return list(map(int, stdin.readline().strip().split()))\n\n    n, m = read_ints()\n    d, e = read_ints()\n    events = [read_ints() for _ in range(e)]\n\n    # Initialize the toy_playtime matrix\n    toy_playtime = [[0] * (m + 1) for _ in range(n)]\n\n    # Initialize the envy matrix\n    envy = [[False] * n for _ in range(n)]\n\n    # Calculate the toy playtime matrix and envy matrix\n    for event in events:\n        s, k, t = event\n        for i in range(n):\n            if envy[i][k - 1]:\n                envy[i][k - 1] = False\n            if i != k - 1 and toy_playtime[i][t] < toy_playtime[k - 1][t]:\n                envy[i][k - 1] = True\n        for i in range(n):\n            if t == 0:\n                toy_playtime[i][t] = 0\n            else:\n                toy_playtime[i][t] += (d - s) // 1000000\n\n    # Initialize the toy_count matrix\n    toy_count = [0] * (m + 1)\n\n    # Calculate the toy_count matrix\n    for k in range(n):\n        for t in range(m + 1):\n            toy_count[t] += toy_playtime[k][t]\n\n    # Initialize the toy_priority matrix\n    toy_priority = [[] for _ in range(n)]\n\n    # Calculate the toy_priority matrix\n    for k in range(n):\n        for t in range(m + 1):\n            if toy_playtime[k][t] > 0:\n                toy_priority[k].append((t, toy_playtime[k][t], toy_count[t]))\n        toy_priority[k].sort(key=lambda x: (-x[1], -x[2], x[0]))\n\n    # Initialize the assignment matrix\n    assignment = [-1] * n\n\n    # Assign toys to kids without crying\n    for k in range(n):\n        if assignment[k] == -1:\n            for (t, _, _) in toy_priority[k]:\n                if not envy[k][assignment.index(t)] or assignment.count(t) < 2:\n                    assignment[k] = t\n                    break\n\n    # Check if there is any crying\n    for k in range(n):\n        for (t, _, _) in toy_priority[k][1:]:\n            if envy[k][assignment.index(t)] and assignment.count(t) < 2:\n                return \"impossible\"\n\n    return \" \".join(map(str, assignment))"
    },
    {
        "number": 3154,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> tuple:\n        n, m, d, e = map(int, input_str.split())\n        return n, m, d, e\n\n    def assign_toys(n: int, m: int, d: int, e: int, events: list) -> str:\n        toy_count = [0] * (m + 1)\n        last_played = [[0] * (m + 1) for _ in range(n)]\n        envy = [[False] * n for _ in range(n)]\n\n        for s, k, t in events:\n            if t == 0:\n                toy_count[last_played[k - 1][t] + 1] -= 1\n            else:\n                toy_count[last_played[k - 1][t]] -= 1\n                toy_count[t] += 1\n                last_played[k - 1] = [s, t]\n\n        for k1 in range(n):\n            for k2 in range(n):\n                if k1 != k2 and last_played[k1][last_played[k1][1]] < last_played[k2][last_played[k2][1]]:\n                    envy[k1][k2] = True\n\n        for k1 in range(n):\n            for k2 in range(n):\n                if envy[k1][k2] and not envy[k2][k1]:\n                    for t in range(1, m + 1):\n                        if last_played[k1][t] > last_played[k2][t]:\n                            return \"impossible\"\n                    return [k1] * n\n\n        return [1] * n\n\n    input_str = stdin.split('\\n')\n    n, m, d, e = parse_input(input_str[0])\n    events = []\n    for i in range(1, e + 1):\n        s, k, t = map(int, input_str[i].split())\n        events.append((s, k, t))\n\n    result = assign_toys(n, m, d, e, events)\n    return '\\n'.join(map(str, result)) if isinstance(result, list) else result"
    },
    {
        "number": 3154,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def read_int() -> int:\n        return int(stdin.readline().strip())\n\n    def read_ints() -> List[int]:\n        return list(map(int, stdin.readline().strip().split()))\n\n    n, m = read_ints()\n    d, e = read_ints()\n\n    toy_times = [[0] * (n + 1) for _ in range(m + 1)]\n    last_played = [0] * n\n\n    for _ in range(e):\n        s, k, t = read_ints()\n        if t != 0:\n            toy_times[t][k] = s\n            last_played[k - 1] = t\n\n    def can_play_with(kid: int, toy: int) -> bool:\n        for other in range(n):\n            if other == kid:\n                continue\n            if toy == last_played[other]:\n                return False\n            if toy_times[toy][other] > toy_times[toy][kid] and toy_times[last_played[kid]][other] < toy_times[last_played[kid]][kid]:\n                return False\n        return True\n\n    assignments = [0] * n\n    for kid in range(n):\n        for toy in range(1, m + 1):\n            if can_play_with(kid, toy):\n                assignments[kid] = toy\n                break\n        else:\n            return \"impossible\"\n\n    return \" \".join(map(str, assignments))"
    },
    {
        "number": 3155,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n, k = 0, 0\n    for i in range(X+1):\n        if binomial(i, X) == X:\n            if n == 0 or i < n or (i == n and X < k):\n                n, k = i, X\n    return f\"{n} {k}\\n\"\n\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n, k = 0, 0\n    min_n = float('inf')\n    min_k = float('inf')\n\n    for i in range(1, X + 1):\n        for j in range(i + 1):\n            if binomial_coefficient(i, j) == X:\n                if i < min_n or (i == min_n and j < min_k):\n                    min_n = i\n                    min_k = j\n\n    return f\"{min_n} {min_k}\\n\"\n\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n\n    # Initialize variables\n    n = k = 0\n\n    # Loop through values of n and k\n    for i in range(1, X + 1):\n        for j in range(i + 1):\n            # Calculate binomial coefficient\n            bin_coeff = math.comb(i, j)\n\n            # Check if binomial coefficient equals X\n            if bin_coeff == X:\n                if i < n or (i == n and j < k):\n                    n = i\n                    k = j\n\n    return f\"{n} {k}\\n\""
    },
    {
        "number": 3155,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 0\n    k = 0\n    min_n = float('inf')\n    min_k = float('inf')\n\n    for i in range(X + 1):\n        for j in range(i + 1):\n            if binomial_coefficient(i, j) == X:\n                if i < min_n or (i == min_n and j < min_k):\n                    min_n = i\n                    min_k = j\n\n    return f\"{min_n} {min_k}\\n\"\n\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    n, k = 0, 0\n    if x == 0:\n        n, k = 1, 0\n    elif x == 1:\n        n, k = 1, 1\n    else:\n        n = x\n        k = 1\n        while n > x:\n            n -= 1\n            k = (x - 1) // n\n            x = x - (n - k)\n            if x <= n // 2:\n                k = n - x\n                x = (n * k) // n\n    return f\"{n} {k}\""
    },
    {
        "number": 3155,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = k = 0\n    if X == 0:\n        n, k = 1, 0\n    elif X == 1:\n        n, k = 1, 1\n    else:\n        for i in range(X):\n            if binomial(i, X-i) == X:\n                n, k = i, X-i\n                break\n    return f\"{n} {k}\\n\"\n\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 0\n    k = 0\n    min_n = float('inf')\n    min_k = float('inf')\n\n    for i in range(X + 1):\n        if binomial(X, i) == X:\n            if i <= min_k and X <= min_n:\n                min_n = X\n                min_k = i\n                n = X\n                k = i\n\n    return f\"{n} {k}\\n\"\n\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    n, k = 0, 0\n    min_n = float('inf')\n    min_k = float('inf')\n\n    for i in range(1, x + 1):\n        for j in range(i + 1):\n            if binomial_coefficient(i, j) == x:\n                if i < min_n or (i == min_n and j < min_k):\n                    min_n = i\n                    min_k = j\n\n    if min_n == float('inf'):\n        return \"No solution found\"\n    else:\n        return f\"{min_n} {min_k}\"\n\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n, k = 0, 0\n    for i in range(X + 1):\n        if n * (n - 1) // 2 <= X:\n            n += 1\n        else:\n            n -= 1\n            k += 1\n            while n * (n - 1) // 2 > X:\n                n -= 1\n                k += 1\n            break\n    return f\"{n} {k}\\n\""
    },
    {
        "number": 3155,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n, k = 0, 0\n    min_n = float('inf')\n    min_k = float('inf')\n\n    for i in range(X + 1):\n        if binomial(i, X // i) == X:\n            if i < min_n or (i == min_n and X // i < min_k):\n                min_n = i\n                min_k = X // i\n\n    return f\"{min_n} {min_k}\\n\"\n\ndef"
    },
    {
        "number": 3156,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_unique_path(stores, items, index):\n        if index == len(items):\n            return True\n        for store in stores:\n            if store[items[index]]:\n                store[items[index]] -= 1\n                if check_unique_path(stores, items, index + 1):\n                    return True\n                store[items[index]] += 1\n        return False\n\n    def check_ambiguous_path(stores, items, index):\n        if index == len(items):\n            return True\n        next_stores = []\n        for store in stores:\n            if store[items[index]]:\n                store[items[index]] -= 1\n                next_stores.append(store.copy())\n                store[items[index]] += 1\n        if not next_stores:\n            return False\n        for store in next_stores:\n            if not check_ambiguous_path([store], items, index + 1):\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    N, K = map(int, lines[0].split())\n    stores = [{} for _ in range(N)]\n    for i in range(K):\n        store_id, item = lines[i + 1].split()\n        store_id = int(store_id)\n        stores[store_id][item] = stores[store_id].get(item, 0) + 1\n\n    M = int(lines[K + 1])\n    items = lines[K + 2:K + 2 + M]\n\n    if check_unique_path(stores, items, 0):\n        if check_ambiguous_path(stores, items, 0):\n            return 'ambiguous'\n        else:\n            return 'unique'\n    else:\n        return 'impossible' "
    },
    {
        "number": 3156,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_item(stores, item, start_idx):\n        for i in range(start_idx, len(stores)):\n            if item in stores[i]:\n                return i\n        return -1\n\n    def find_path(stores, items, start_idx):\n        if not items:\n            return True\n\n        for i in range(start_idx, len(stores)):\n            if items[0] in stores[i]:\n                if len(items) == 1:\n                    return True\n                else:\n                    next_idx = find_item(stores, items[1], i + 1)\n                    if next_idx != -1:\n                        if find_path(stores, items[1:], next_idx):\n                            return True\n        return False\n\n    lines = stdin.split('\\n')\n    N, K = map(int, lines[0].split())\n    stores = [set() for _ in range(N)]\n    for i in range(K):\n        i_item = lines[i + 1].split()\n        stores[int(i_item[0])].add(i_item[1])\n\n    M = int(lines[K + 1])\n    items = [lines[K + i + 2] for i in range(M)]\n\n    if find_path(stores, items, 0):\n        return \"unique\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3156,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def check_unique(inventory, orders):\n        if len(orders) != len(set(orders)):\n            return False\n        for order in orders:\n            found = False\n            for store, items in inventory.items():\n                if order in items:\n                    if found:\n                        return False\n                    found = True\n            if not found:\n                return False\n        return True\n\n    def check_ambiguous(inventory, orders):\n        path = []\n        for order in orders:\n            stores = []\n            for store, items in inventory.items():\n                if store not in path and order in items:\n                    stores.append(store)\n            if not stores:\n                return \"impossible\"\n            if not path:\n                path.append(stores[0])\n            elif stores[0] != path[-1]:\n                return \"ambiguous\"\n            else:\n                path.append(stores[0])\n        return \"unique\"\n\n    lines = stdin.split(\"\\n\")\n    N, K = map(int, lines[0].split())\n    inventory = {}\n    for i in range(K):\n        store, *items = lines[1 + i].split()\n        inventory[int(store)] = items\n\n    M = int(lines[1 + K])\n    orders = lines[2 + K:]\n\n    if check_unique(inventory, orders):\n        return \"unique\"\n    return check_ambiguous(inventory, orders) "
    },
    {
        "number": 3156,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(store, items, visited, path):\n        if not items:\n            return True\n        if store not in visited:\n            visited.add(store)\n            for item in inventory[store]:\n                if item in items:\n                    if dfs(store, items.replace(item, '', 1), visited, path):\n                        path.append((store, item))\n                        return True\n            visited.remove(store)\n        return False\n\n    lines = stdin.split('\\n')\n    N, K = map(int, lines[0].split())\n    inventory = {i: set() for i in range(N)}\n    for i in range(K):\n        store, item = lines[i + 1].split()\n        inventory[int(store)].add(item)\n\n    M = int(lines[K + 1])\n    items = '\\n'.join(lines[K + 2:K + 2 + M])\n\n    visited = set()\n    path = []\n    if dfs(0, items, visited, path):\n        if len(path) == M:\n            return \"unique\"\n        else:\n            return \"ambiguous\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3156,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_store(item):\n        for i in range(len(stores)):\n            if item in stores[i]:\n                return i\n        return None\n\n    def remove_item(store, item):\n        stores[store].remove(item)\n        for i in range(store + 1, len(stores)):\n            if item in stores[i]:\n                stores[i].remove(item)\n\n    def is_unique(path):\n        for i in range(len(stores)):\n            if len(stores[i]) == 1 and stores[i][0] not in path:\n                return False\n        return True\n\n    lines = stdin.splitlines()\n    N, K = map(int, lines[0].split())\n    stores = [set() for _ in range(N)]\n    for i in range(K):\n        store, item = lines[i + 1].split()\n        stores[int(store)].add(item)\n\n    M = int(lines[K + 1])\n    path = [None] * M\n    for i in range(M):\n        item = lines[K + 2 + i]\n        path[i] = item\n        store = find_store(item)\n        if store is None:\n            return \"impossible\"\n        remove_item(store, item)\n\n    if is_unique(path):\n        return \"unique\"\n    else:\n        return \"ambiguous\""
    },
    {
        "number": 3156,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_unique_path(stores, order):\n        path = []\n        for item in order:\n            for store_id in stores:\n                if item in stores[store_id]:\n                    if store_id not in path:\n                        path.append(store_id)\n                    break\n            else:\n                return None\n        return path\n\n    def find_ambiguous_path(stores, order):\n        paths = []\n        for permutation in itertools.permutations(stores.keys()):\n            path = find_unique_path(stores, order)\n            if path is not None:\n                paths.append(path)\n        return paths\n\n    stores = {}\n    items = []\n    num_stores, num_items = map(int, stdin.split())\n    for _ in range(num_stores):\n        store_id, item = stdin.split()\n        store_id = int(store_id)\n        if store_id not in stores:\n            stores[store_id] = set()\n        stores[store_id].add(item)\n\n    for _ in range(num_items):\n        item = stdin.strip()\n        items.append(item)\n\n    path = find_unique_path(stores, items)\n    if path is None:\n        return \"impossible\"\n    else:\n        ambiguous_paths = find_ambiguous_path(stores, items)\n        if len(ambiguous_paths) > 1:\n            return \"ambiguous\"\n        else:\n            return \"unique\""
    },
    {
        "number": 3156,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(order, inventory, items):\n        if not items:\n            return True\n        if not order:\n            return False\n        store, item = order.pop(0)\n        if item in items and item in inventory[store]:\n            for s in range(store, len(inventory)):\n                if item in inventory[s]:\n                    inventory[s].remove(item)\n            items.remove(item)\n            return find_path(order, inventory, items)\n        return False\n\n    lines = stdin.split('\\n')\n    N, K = map(int, lines[0].split())\n    inventory = [set() for _ in range(N)]\n    for i in range(K):\n        store, item = lines[i + 1].split()\n        inventory[int(store)].add(item)\n    M = int(lines[K + 1])\n    items = set(lines[K + 2:K + 2 + M])\n    order = [(i, item) for i, item in enumerate(lines[K + 2:K + 2 + M])]\n\n    if find_path(order, inventory, items):\n        if not items:\n            return \"unique\"\n        return \"ambiguous\"\n    return \"impossible\""
    },
    {
        "number": 3156,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def search(inventory, items):\n        if not items:\n            return True\n        for i, item in enumerate(inventory):\n            if item == items[0]:\n                if search(inventory[i + 1:], items[1:]):\n                    return True\n        return False\n\n    def is_unique(inventory, items):\n        if not items:\n            return True\n        for i, item in enumerate(inventory):\n            if item == items[0]:\n                if is_unique(inventory[i + 1:], items[1:]):\n                    return True\n        return False\n\n    lines = stdin.split(\"\\n\")\n    N, K = map(int, lines[0].split())\n    inventory = [item.split() for item in lines[2:K + 2]]\n    items = lines[K + 3:K + 3 + N]\n\n    if search(inventory, items):\n        if is_unique(inventory, items):\n            return \"unique\"\n        else:\n            return \"ambiguous\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3156,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(graph, start, end, path=[]):\n        path = path + [start]\n        if start == end:\n            return path\n        if start not in graph:\n            return None\n        for node in graph[start]:\n            if node not in path:\n                new_path = find_path(graph, node, end, path)\n                if new_path:\n                    return new_path\n        return None\n\n    input_list = stdin.split('\\n')\n    N, K = map(int, input_list[0].split())\n    graph = {}\n    for i in range(1, K + 1):\n        store, item = input_list[i].split()\n        if int(store) not in graph:\n            graph[int(store)] = []\n        graph[int(store)].append(item)\n\n    M = int(input_list[K + 1])\n    items = input_list[K + 2:K + 2 + M]\n\n    path = find_path(graph, 0, items[0], [])\n    if path is None:\n        return \"impossible\"\n\n    for i in range(1, len(items)):\n        new_path = find_path(graph, path[-1], items[i], [])\n        if new_path is None:\n            return \"impossible\"\n        path = path[:-1] + new_path\n\n    return \"unique\" if len(path) == N else \"ambiguous\""
    },
    {
        "number": 3156,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(inventory, items):\n        if not items:\n            return True\n        for store in inventory:\n            if items[0] in inventory[store]:\n                inventory[store].remove(items[0])\n                if find_path(inventory, items[1:]):\n                    return True\n                inventory[store].append(items[0])\n        return False\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    K = int(lines[1])\n    inventory = {}\n    for i in range(K):\n        store, item = lines[2 + i].split()\n        store = int(store)\n        if store not in inventory:\n            inventory[store] = []\n        inventory[store].append(item)\n\n    M = int(lines[2 + K])\n    items = [lines[3 + K + i] for i in range(M)]\n\n    if find_path(inventory, items):\n        return 'unique'\n    elif any(items[i] in inventory[store] for i in range(len(items)) for store in inventory):\n        return 'ambiguous'\n    else:\n        return 'impossible'"
    },
    {
        "number": 3157,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n\n    def hash_function(word: str) -> int:\n        if not word:\n            return 0\n        previous_hash = hash_function(word[:-1])\n        current_letter_value = ord(word[-1])\n        combined_hash = (previous_hash * 33) ^ current_letter_value\n        return combined_hash % (2 ** M)\n\n    count = 0\n    for i in range(26 ** N):\n        word = ''\n        for _ in range(N):\n            word += chr(i % 26 + ord('a'))\n            i //= 26\n        if hash_function(word) == K:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3157,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, MOD = map(int, stdin.split())\n\n    def f(word: str) -> int:\n        if not word:\n            return 0\n        else:\n            return ((f(word[:-1]) * 33) ^ ord(word[-1])) % MOD\n\n    words = [\"a\"]\n    for _ in range(N - 1):\n        words = [word + letter for letter in \"abcdefghijklmnopqrstuvwxyz\" for word in words if len(word) < N]\n\n    return str(sum(1 for word in words if f(word) == K))\n"
    },
    {
        "number": 3157,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, MOD = map(int, stdin.split())\n\n    def f(word: str) -> int:\n        if not word:\n            return 0\n        return (f(word[:-1]) * 33 + ord(word[-1])) % MOD\n\n    count = 0\n    for i in range(1, N + 1):\n        for word in itertools.product(string.ascii_lowercase, repeat=i):\n            if f(\"\".join(word)) == K:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3157,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, MOD = map(int, stdin.split())\n    memo = {}\n\n    def hash_function(word):\n        if word in memo:\n            return memo[word]\n\n        if word == \"\":\n            return 0\n\n        if len(word) == 1:\n            memo[word] = ord(word) - ord(\"a\") + 1\n            return memo[word]\n\n        memo[word] = (hash_function(word[:-1]) * 33 + ord(word[-1]) - ord(\"a\") + 1) % MOD\n        return memo[word]\n\n    count = 0\n    for i in range(MOD):\n        if hash_function(N * \"a\") == i:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3157,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    ALPHABET_SIZE = 26\n    MOD = 2**M\n    BASE = 33\n\n    def hash_function(word: str) -> int:\n        result = 0\n        for letter in word:\n            result = (result * BASE + ord(letter)) % MOD\n        return result\n\n    def count_words_with_hash(n: int, k: int) -> int:\n        if n == 0:\n            return 1 if k == 0 else 0\n        count = 0\n        for i in range(ALPHABET_SIZE):\n            new_hash = (k * BASE + i) % MOD\n            count += count_words_with_hash(n - 1, new_hash)\n        return count\n\n    return str(count_words_with_hash(N, K))"
    },
    {
        "number": 3157,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, K, MOD = map(int, stdin.split())\n\n    # Define function to calculate hash value of a word\n    def hash_value(word):\n        if not word:\n            return 0\n        else:\n            return (hash_value(word[:-1]) * 33 + ord(word[-1])) % MOD\n\n    # Count the number of words with the given hash value\n    count = 0\n    for word in range(26 ** N):\n        encoded_word = \"\"\n        for _ in range(N):\n            encoded_word += chr(word % 26 + 97)\n            word //= 26\n        if hash_value(encoded_word) == K:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3157,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    N, K, M = map(int, stdin.split())\n\n    # Define the hash function\n    def hash_function(word: str) -> int:\n        if word == \"\":\n            return 0\n        else:\n            hash_value = (hash_function(word[:-1]) * 33) ^ ord(word[-1])\n            return hash_value % (2 ** M)\n\n    # Count the number of words with the given hash value\n    count = 0\n    for word in itertools.product(\"abcdefghijklmnopqrstuvwxyz\", repeat=N):\n        if hash_function(\"\".join(word)) == K:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3157,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, K, M = map(int, stdin.split())\n\n    def f(word: str) -> int:\n        if not word:\n            return 0\n        return (f(word[:-1]) * 33 + ord(word[-1])) % (2 ** M)\n\n    # Calculate the hash value of all words of length N\n    words = [chr(i) * N for i in range(ord('a'), ord('z') + 1)]\n    hash_values = [f(word) for word in words]\n\n    # Count the number of words with the given hash value\n    count = hash_values.count(K)\n\n    return str(count)"
    },
    {
        "number": 3157,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, MOD = map(int, stdin.split())\n    memo = {}\n\n    def f(word):\n        if word in memo:\n            return memo[word]\n        if not word:\n            memo[word] = 0\n            return 0\n        result = (f(word[:-1]) * 33 + ord(word[-1])) % MOD\n        memo[word] = result\n        return result\n\n    count = 0\n    for i in range(1, N + 1):\n        for word in itertools.product(\"abcdefghijklmnopqrstuvwxyz\", repeat=i):\n            if f(\"\".join(word)) == K:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3157,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, MOD = map(int, stdin.split())\n    words = []\n\n    def hash_function(word, MOD):\n        if not word:\n            return 0\n        else:\n            return ((hash_function(word[:-1], MOD) * 33) ^ ord(word[-1])) % MOD\n\n    def generate_words(N):\n        if N == 0:\n            return ['']\n        else:\n            new_words = []\n            for word in generate_words(N - 1):\n                for letter in 'abcdefghijklmnopqrstuvwxyz':\n                    new_words.append(word + letter)\n            return new_words\n\n    for word in generate_words(N):\n        if hash_function(word, MOD) == K:\n            words.append(word)\n\n    return str(len(words))"
    },
    {
        "number": 3158,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input into two images\n    images = [line.split() for line in stdin.split('\\n') if line]\n    initial_image = images[0]\n    final_image = images[1]\n\n    # Function to get the touch points from an image\n    def get_touch_points(image):\n        touch_points = []\n        for row in range(len(image)):\n            for col in range(len(image[0])):\n                if image[row][col] == 'X':\n                    touch_points.append((row, col))\n        return touch_points\n\n    # Get the touch points for both images\n    initial_touch_points = get_touch_points(initial_image)\n    final_touch_points = get_touch_points(final_image)\n\n    # Calculate the grip points and touch vectors\n    def get_grip_point(touch_points):\n        if len(touch_points) == 0:\n            return None\n        x = sum(row for row, col in touch_points) / len(touch_points)\n        y = sum(col for row, col in touch_points) / len(touch_points)\n        return (x, y)\n\n    def get_touch_vector(grip_point, touch_point):\n        return (touch_point[0] - grip_point[0], touch_point[1] - grip_point[1])\n\n    initial_grip_point = get_grip_point(initial_touch_points)\n    final_grip_point = get_grip_point(final_touch_points)\n\n    def get_touch_vectors(grip_point, touch_points):\n        return [get_touch_vector(grip_point, touch_point) for touch_point in touch_points]\n\n    initial_touch_vectors = get_touch_vectors(initial_grip_point, initial_touch_points)\n    final_touch_vectors = get_touch_vectors(final_grip_point, final_touch_points)\n\n    # Calculate the pan distance\n    def distance(point1, point2):\n        return ((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)**0.5\n\n    pan_distance = distance(initial_grip_point, final_grip_point)\n\n    # Calculate the zoom distance\n    def average(numbers):\n        return sum(numbers) / len(numbers)\n\n    def grip_spread(grip_point, touch_points):\n        return average([distance(grip_point, touch_point) for touch_point in touch_points])\n\n    initial_grip_spread = grip_spread(initial_grip_point, initial_touch_points)\n    final_grip_spread = grip_spread(final_grip_point, final_touch_points)\n\n    zoom_distance = abs(initial_grip_spread - final_grip_spread)\n\n    # Calculate the rotation distance\n    def dot_product(vector1, vector2):\n        return vector1[0] * vector2[0] + vector1[1] * vector2[1]\n\n    def cross_product_length(vector1, vector2):\n        return vector1[0] * vector2[1] - vector1[1] * vector2[0]\n\n    def signed_angle(vector1, vector2):\n        angle = math.acos(dot_product(vector1, vector2) / (distance((0, 0), vector1) * distance((0, 0), vector2)))\n        return cross_product_length(vector1, vector2) / abs(cross_product_length(vector1, vector2)) * angle\n\n    def grip_rotation(grip_point, touch_vectors):\n        return sum([signed_angle(touch_vectors[i - 1], touch_vectors[i]) for i in range(len(touch_vectors))]) / len(touch_vectors)\n\n    initial_grip_rotation = grip_rotation(initial_grip_point, initial_touch_vectors)\n    final_grip_rotation = grip_rotation(final_grip_point, final_"
    },
    {
        "number": 3158,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_touches(image: str) -> list:\n        touches = []\n        for i in range(15):\n            for j in range(30):\n                if image[i * 31 + j] == 'X':\n                    touches.append((i, j))\n        return touches\n\n    def get_grip(touches: list) -> tuple:\n        grip_points = set()\n        for touch in touches:\n            neighbors = [(touch[0] + i, touch[1] + j) for i in [-1, 0, 1] for j in [-1, 0, 1] if 0 <= touch[0] + i < 15 and 0 <= touch[1] + j < 30]\n            grip_points.update(neighbors)\n        grip_point = tuple(sum(p) / len(grip_points) for p in zip(*grip_points))\n        return grip_points, grip_point\n\n    def get_gesture_type(initial_grip: tuple, final_grip: tuple) -> str:\n        initial_grip_points, initial_grip_point = initial_grip\n        final_grip_points, final_grip_point = final_grip\n\n        def get_distance(point1: tuple, point2: tuple) -> float:\n            return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5\n\n        def get_angle(vector1: tuple, vector2: tuple) -> float:\n            return math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1])\n\n        pan_distance = get_distance(initial_grip_point, final_grip_point)\n        grip_spread = (get_distance(initial_grip_point, (initial_grip_point[0], initial_grip_point[1] + 1)) + get_distance(final_grip_point, (final_grip_point[0], final_grip_point[1] + 1))) / 2\n        zoom_distance = abs(len(initial_grip_points) - len(final_grip_points))\n\n        touch_rotations = []\n        for touch1 in initial_grip_points:\n            for touch2 in final_grip_points:\n                touch1_vector = (touch1[0] - initial_grip_point[0], touch1[1] - initial_grip_point[1])\n                touch2_vector = (touch2[0] - final_grip_point[0], touch2[1] - final_grip_point[1])\n                touch_rotations.append(get_angle(touch1_vector, touch2_vector))\n        grip_rotation = sum(touch_rotations) / len(touch_rotations)\n        rotation_distance = abs(grip_rotation) * grip_spread\n\n        gesture_type = None\n        if max(pan_distance, zoom_distance, rotation_distance) == pan_distance:\n            gesture_type = 'pan'\n        elif max(pan_distance, zoom_distance, rotation_distance) == zoom_distance:\n            gesture_type = 'zoom'\n        else:\n            gesture_type = 'rotate'\n\n        return gesture_type\n\n    initial_image, final_image = stdin.strip().split('\\n')\n    initial_touches = get_touches(initial_image)\n    final_touches = get_touches(final_image)\n    initial_grip = get_grip(initial_touches)\n    final_grip = get_grip(final_touches)\n    gesture_type = get_gesture_type(initial_grip, final_grip)\n\n    if gesture_type == 'pan':\n        return f\"{len(initial_touches)} pan\\n\"\n    elif gesture_type == 'zoom':\n        zoom_direction = 'out' if len(final_touches) < len(initial_touches) else 'in'\n        return"
    },
    {
        "number": 3158,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_touch_points(image):\n        touch_points = []\n        in_touch = False\n        for y, row in enumerate(image):\n            for x, pixel in enumerate(row):\n                if pixel == \"X\":\n                    if not in_touch:\n                        touch_points.append(set())\n                        in_touch = True\n                    touch_points[-1].add((x, y))\n                else:\n                    in_touch = False\n        return touch_points\n\n    def get_grip_point(touch_points):\n        x_sum = sum(x for touch in touch_points for x, y in touch)\n        y_sum = sum(y for touch in touch_points for x, y in touch)\n        num_pixels = sum(len(touch) for touch in touch_points)\n        return x_sum / num_pixels, y_sum / num_pixels\n\n    def get_touch_vectors(initial_grip_point, final_grip_point, initial_touch_points, final_touch_points):\n        touch_vectors = []\n        for initial_touch, final_touch in zip(initial_touch_points, final_touch_points):\n            initial_center = get_grip_point([initial_touch])\n            final_center = get_grip_point([final_touch])\n            touch_vectors.append((final_center[0] - initial_center[0], final_center[1] - initial_center[1]))\n        return touch_vectors\n\n    def get_grip_spread(touch_points, grip_point):\n        return sum(abs(x - grip_point[0]) + abs(y - grip_point[1]) for touch in touch_points for x, y in touch) / len(touch_points)\n\n    def get_pan_distance(initial_grip_point, final_grip_point):\n        return abs(final_grip_point[0] - initial_grip_point[0]) + abs(final_grip_point[1] - initial_grip_point[1])\n\n    def get_zoom_distance(initial_grip_spread, final_grip_spread):\n        return final_grip_spread - initial_grip_spread\n\n    def get_rotation_distance(touch_vectors):\n        rotation_sum = sum(angle(v1, v2) for v1, v2 in zip(touch_vectors[:-1], touch_vectors[1:]))\n        return abs(rotation_sum) / len(touch_vectors)\n\n    def angle(v1, v2):\n        dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n        length_product = math.sqrt(v1[0] ** 2 + v1[1] ** 2) * math.sqrt(v2[0] ** 2 + v2[1] ** 2)\n        return math.acos(dot_product / length_product)\n\n    initial_image, final_image = stdin.strip().split(\"\\n\")\n    initial_touch_points = get_touch_points(initial_image)\n    final_touch_points = get_touch_points(final_image)\n\n    if len(initial_touch_points) != len(final_touch_points):\n        raise ValueError(\"Both images must have the same number of touches\")\n\n    initial_grip_point = get_grip_point(initial_touch_points)\n    final_grip_point = get_grip_point(final_touch_points)\n    initial_grip_spread = get_grip_spread(initial_touch_points, initial_grip_point)\n    final_grip_spread = get_grip_spread(final_touch_points, final_grip_point)\n    touch_vectors = get_touch_vectors(initial_grip_point, final_grip_point, initial_touch_points, final_touch_points)\n\n    pan_distance = get_pan_distance(initial_grip_point, final_grip_point)\n    zoom_distance = get_zoom_distance(initial_grip_spread, final_g"
    },
    {
        "number": 3158,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def create_grip(image: str) -> tuple:\n        points = [(i, j) for i, row in enumerate(image.split('\\n')) for j, pixel in enumerate(row) if pixel == 'X']\n        grip_points = set()\n        for point in points:\n            x, y = point\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_point = (x + dx, y + dy)\n                if new_point in points and new_point not in grip_points:\n                    grip_points.add(new_point)\n        grip_center = (sum(x for x, y in grip_points) / len(grip_points),\n                        sum(y for x, y in grip_points) / len(grip_points))\n        return grip_points, grip_center\n\n    def distance(point1: tuple, point2: tuple) -> float:\n        return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5\n\n    def closest_point(point: tuple, points: set) -> tuple:\n        closest = None\n        closest_distance = float('inf')\n        for p in points:\n            d = distance(point, p)\n            if d < closest_distance:\n                closest = p\n                closest_distance = d\n        return closest\n\n    def grip_distance(grip1: tuple, grip2: tuple) -> float:\n        grip_points1, grip_center1 = grip1\n        grip_points2, grip_center2 = grip2\n        total_distance = 0\n        for point in grip_points1:\n            closest_point2 = closest_point(point, grip_points2)\n            total_distance += distance(point, closest_point2)\n        return total_distance\n\n    def pan_distance(grip1: tuple, grip2: tuple) -> float:\n        grip_points1, grip_center1 = grip1\n        grip_points2, grip_center2 = grip2\n        return distance(grip_center1, grip_center2)\n\n    def zoom_distance(grip1: tuple, grip2: tuple) -> float:\n        grip_points1, grip_center1 = grip1\n        grip_points2, grip_center2 = grip2\n        spread1 = sum(distance(grip_center1, p) for p in grip_points1) / len(grip_points1)\n        spread2 = sum(distance(grip_center2, p) for p in grip_points2) / len(grip_points2)\n        return spread1 - spread2\n\n    def rotation_distance(grip1: tuple, grip2: tuple) -> float:\n        grip_points1, grip_center1 = grip1\n        grip_points2, grip_center2 = grip2\n        total_angle = 0\n        for point1 in grip_points1:\n            closest_point2 = closest_point(point1, grip_points2)\n            vector1 = (point1[0] - grip_center1[0], point1[1] - grip_center1[1])\n            vector2 = (closest_point2[0] - grip_center2[0], closest_point2[1] - grip_center2[1])\n            angle = ((vector1[0] * vector2[1]) - (vector1[1] * vector2[0])) / (distance(point1, grip_center1) * distance(closest_point2, grip_center2))\n            total_angle += angle\n        return abs(total_angle) / len(grip_points1)\n\n    initial_image, final_image = stdin.split()\n    initial_grip = create_grip(initial_image)\n    final_grip = create_grip(final_image)\n    num_touches = len(initial_grip[0])\n\n    pan_distance_value = pan_distance(initial_grip, final_grip)\n    zoom"
    },
    {
        "number": 3158,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_touches(image):\n        touches = []\n        for i in range(15):\n            for j in range(30):\n                if image[i][j] == \"X\":\n                    touch_points = [(i, j)]\n                    visited = set(touch_points)\n                    while touch_points:\n                        x, y = touch_points.pop()\n                        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                            new_x, new_y = x + dx, y + dy\n                            if (new_x, new_y) not in visited and 0 <= new_x < 15 and 0 <= new_y < 30 and image[new_x][new_y] == \"X\":\n                                touch_points.append((new_x, new_y))\n                                visited.add((new_x, new_y))\n                    touches.append(touch_points)\n        return touches\n\n    def get_grip_point(touches):\n        x_sum, y_sum = 0, 0\n        for touch in touches:\n            x, y = 0, 0\n            for point in touch:\n                x += point[0]\n                y += point[1]\n            x_sum += x / len(touch)\n            y_sum += y / len(touch)\n        return (x_sum / len(touches), y_sum / len(touches))\n\n    def get_grip_spread(grip_point, touches):\n        distance_sum = 0\n        for touch in touches:\n            distance_sum += sum(abs(grip_point[0] - point[0]) + abs(grip_point[1] - point[1])) / len(touch)\n        return distance_sum / len(touches)\n\n    def get_touch_vectors(grip_point, touches):\n        vectors = []\n        for touch in touches:\n            x, y = 0, 0\n            for point in touch:\n                x += point[0] - grip_point[0]\n                y += point[1] - grip_point[1]\n            vectors.append((x / len(touch), y / len(touch)))\n        return vectors\n\n    def get_grip_rotation(vectors):\n        rotation_sum = 0\n        for v1, v2 in zip(vectors[0], vectors[1]):\n            rotation_sum += atan2(v1[1], v1[0]) - atan2(v2[1], v2[0])\n        return rotation_sum / len(vectors[0])\n\n    def classify_gesture(initial_touches, final_touches):\n        initial_grip = get_grip_point(initial_touches)\n        final_grip = get_grip_point(final_touches)\n\n        initial_spread = get_grip_spread(initial_grip, initial_touches)\n        final_spread = get_grip_spread(final_grip, final_touches)\n\n        initial_vectors = get_touch_vectors(initial_grip, initial_touches)\n        final_vectors = get_touch_vectors(final_grip, final_touches)\n\n        grip_rotation = abs(get_grip_rotation(zip(initial_vectors, final_vectors)))\n\n        pan_distance = sum(abs(final_grip[0] - initial_grip[0]) + abs(final_grip[1] - initial_grip[1]))\n        zoom_distance = final_spread - initial_spread\n        rotation_distance = grip_rotation * final_spread\n\n        max_distance = max(pan_distance, abs(zoom_distance), rotation_distance)\n\n        if max_distance == pan_distance:\n            return \"pan\"\n        elif max_distance == abs(zoom_distance):\n            return \"zoom \" + (\"in\" if zoom_distance > 0 else \"out\")\n        else:\n            return \"rotate \" + (\"clockwise\" if grip_rotation > 0 else \"counter-clockwise\")"
    },
    {
        "number": 3158,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_touches(image):\n        touches = []\n        for i, row in enumerate(image):\n            for j, pixel in enumerate(row):\n                if pixel == \"X\":\n                    touches.append((i, j))\n        return touches\n\n    def get_grip_point(touches):\n        return tuple(sum(p) / len(touches) for p in zip(*touches))\n\n    def get_touch_vector(grip_point, touch_point):\n        return tuple(t - g for t, g in zip(touch_point, grip_point))\n\n    def get_grip_spread(grip_point, touches):\n        return sum(sum(abs(t - g) for t, g in zip(touch_point, grip_point)) for touch_point in touches) / len(touches)\n\n    def get_rotation_distance(grip_point, touches):\n        total_rotation = 0\n        for i in range(len(touches) - 1):\n            v1 = get_touch_vector(grip_point, touches[i])\n            v2 = get_touch_vector(grip_point, touches[i + 1])\n            total_rotation += atan2(v1[0] * v2[1] - v1[1] * v2[0], v1[0] * v2[0] + v1[1] * v2[1])\n        return abs(total_rotation / (2 * pi))\n\n    images = [list(filter(None, row.split(\" \"))) for row in stdin.split(\"\\n\")]\n    initial_touches = get_touches(images[0])\n    final_touches = get_touches(images[1])\n\n    if len(initial_touches) != len(final_touches):\n        raise ValueError(\"Images must have the same number of touches\")\n\n    initial_grip_point = get_grip_point(initial_touches)\n    final_grip_point = get_grip_point(final_touches)\n\n    initial_grip_spread = get_grip_spread(initial_grip_point, initial_touches)\n    final_grip_spread = get_grip_spread(final_grip_point, final_touches)\n\n    pan_distance = sum(abs(t - f) for t, f in zip(initial_grip_point, final_grip_point))\n    zoom_distance = abs(initial_grip_spread - final_grip_spread)\n    rotation_distance = get_rotation_distance(initial_grip_point, initial_touches)\n\n    gesture = max((\"pan\", pan_distance), (\"zoom\", zoom_distance), (\"rotate\", rotation_distance))\n\n    if gesture[0] == \"zoom\":\n        direction = \"out\" if final_grip_spread < initial_grip_spread else \"in\"\n        return f\"{len(initial_touches)} {gesture[0]} {direction}\"\n    elif gesture[0] == \"rotate\":\n        direction = \"clockwise\" if gesture[1] > 0.5 else \"counter-clockwise\"\n        return f\"{len(initial_touches)} {gesture[0]} {direction}\"\n    else:\n        return f\"{len(initial_touches)} {gesture[0]}\" "
    },
    {
        "number": 3158,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_touches(image):\n        touches = []\n        for i in range(15):\n            for j in range(30):\n                if image[i][j] == 'X':\n                    touches.append((i, j))\n        return touches\n\n    def get_grip_point(touches):\n        center_x = sum(x for x, y in touches) / len(touches)\n        center_y = sum(y for x, y in touches) / len(touches)\n        return (center_x, center_y)\n\n    def get_touch_vectors(grip_point, touches):\n        vectors = []\n        for touch in touches:\n            vectors.append((touch[0] - grip_point[0], touch[1] - grip_point[1]))\n        return vectors\n\n    def get_grip_spread(grip_point, touches):\n        return sum(distance(grip_point, touch) for touch in touches) / len(touches)\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def get_grip_rotation(initial_touches, final_touches):\n        rotation_sum = 0\n        for i in range(len(initial_touches)):\n            initial_vector = get_touch_vectors(get_grip_point(initial_touches), initial_touches)[i]\n            final_vector = get_touch_vectors(get_grip_point(final_touches), final_touches)[i]\n            rotation_sum += angle_between_vectors(initial_vector, final_vector)\n        return rotation_sum / len(initial_touches)\n\n    def angle_between_vectors(v1, v2):\n        return math.atan2(v1[0] * v2[1] - v1[1] * v2[0], v1[0] * v2[0] + v1[1] * v2[1])\n\n    def classify_gesture(initial_touches, final_touches):\n        pan_distance = distance(get_grip_point(initial_touches), get_grip_point(final_touches))\n        zoom_distance = get_grip_spread(get_grip_point(initial_touches), initial_touches) - get_grip_spread(get_grip_point(final_touches), final_touches)\n        rotation_distance = abs(get_grip_rotation(initial_touches, final_touches)) * get_grip_spread(get_grip_point(initial_touches), initial_touches)\n\n        if pan_distance > max(zoom_distance, rotation_distance):\n            return \"pan\"\n        elif zoom_distance > max(pan_distance, rotation_distance):\n            if zoom_distance < 0:\n                return \"zoom out\"\n            else:\n                return \"zoom in\"\n        else:\n            if rotation_distance > 0:\n                return \"rotate clockwise\"\n            else:\n                return \"rotate counter-clockwise\"\n\n    initial_image, final_image = stdin.strip().split()\n    initial_touches = get_touches(initial_image)\n    final_touches = get_touches(final_image)\n\n    if len(initial_touches) != len(final_touches):\n        return \"Invalid input\"\n\n    gesture = classify_gesture(initial_touches, final_touches)\n    return f\"{len(initial_touches)} {gesture}\" "
    },
    {
        "number": 3158,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def find_touch_points(image):\n        touches = []\n        for i in range(15):\n            for j in range(30):\n                if image[i][j] == \"X\":\n                    if not touches or distance((i, j), touches[-1]) > 1:\n                        touches.append((i, j))\n        return touches\n\n    def find_grip_point(touch_points):\n        return (\n            sum(t[0] for t in touch_points) // len(touch_points),\n            sum(t[1] for t in touch_points) // len(touch_points),\n        )\n\n    def find_touch_vectors(touch_points, grip_point):\n        return [grip_point[0] - t[0], grip_point[1] - t[1]] for t in touch_points\n\n    def find_grip_spread(touch_points, grip_point):\n        return sum(distance(t, grip_point) for t in touch_points) / len(touch_points)\n\n    def find_rotation_distance(touch_vectors, grip_point):\n        rotation = sum(\n            (touch_vectors[i][0] * touch_vectors[i - 1][1] - touch_vectors[i][1] * touch_vectors[i - 1][0])\n            for i in range(len(touch_vectors))\n        ) / len(touch_vectors)\n        return rotation / find_grip_spread([(0, 0)] + touch_vectors, (0, 0))\n\n    images = stdin.strip().split(\"\\n\")\n    initial_image = images[0]\n    final_image = images[1]\n\n    initial_touches = find_touch_points(initial_image)\n    final_touches = find_touch_points(final_image)\n\n    if len(initial_touches) != len(final_touches):\n        raise ValueError(\"Incorrect input: Number of touches in both images should be the same.\")\n\n    initial_grip_point = find_grip_point(initial_touches)\n    final_grip_point = find_grip_point(final_touches)\n\n    initial_touch_vectors = find_touch_vectors(initial_touches, initial_grip_point)\n    final_touch_vectors = find_touch_vectors(final_touches, final_grip_point)\n\n    pan_distance = distance(initial_grip_point, final_grip_point)\n    grip_spread_initial = find_grip_spread(initial_touches, initial_grip_point)\n    grip_spread_final = find_grip_spread(final_touches, final_grip_point)\n    zoom_distance = abs(grip_spread_final - grip_spread_initial)\n    rotation_distance = find_rotation_distance(final_touch_vectors, final_grip_point)\n\n    pan_score = pan_distance\n    zoom_score = zoom_distance\n    rotation_score = abs(rotation_distance)\n\n    max_score = max(pan_score, zoom_score, rotation_score)\n\n    if max_score == pan_score:\n        return f\"{len(initial_touches)} pan\"\n    elif max_score == zoom_score:\n        return f\"{len(initial_touches)} zoom {'out' if grip_spread_final < grip_spread_initial else 'in'}\"\n    else:\n        return f\"{len(initial_touches)} rotate {'clockwise' if rotation_distance > 0 else 'counter-clockwise'}\""
    },
    {
        "number": 3158,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    images = [line.split() for line in stdin.split(\"\\n\") if line]\n    initial_touches = get_touches(images[0][0])\n    final_touches = get_touches(images[1][0])\n\n    initial_grip_point = get_grip_point(initial_touches)\n    final_grip_point = get_grip_point(final_touches)\n\n    initial_grip_spread = get_grip_spread(initial_touches, initial_grip_point)\n    final_grip_spread = get_grip_spread(final_touches, final_grip_point)\n\n    pan_distance = get_pan_distance(initial_grip_point, final_grip_point)\n    zoom_distance = abs(final_grip_spread - initial_grip_spread)\n    rotation_distance = get_rotation_distance(initial_touches, final_touches, initial_grip_point)\n\n    if pan_distance > zoom_distance and pan_distance > rotation_distance:\n        return f\"{len(initial_touches)} pan\"\n    elif zoom_distance > pan_distance and zoom_distance > rotation_distance:\n        return f\"{len(initial_touches)} {'zoom in' if final_grip_spread < initial_grip_spread else 'zoom out'}\"\n    else:\n        return f\"{len(initial_touches)} {'counterclockwise' if rotation_distance > 0 else 'clockwise'} rotate\"\n\ndef"
    },
    {
        "number": 3158,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input images\n    image1, image2 = stdin.strip().split()\n\n    def parse_image(image):\n        touches = []\n        for i in range(15):\n            for j in range(30):\n                if image[i][j] == 'X':\n                    touches.append((i, j))\n        return touches\n\n    touches1 = parse_image(image1)\n    touches2 = parse_image(image2)\n\n    # Calculate the grip points and vectors\n    def grip_point(touches):\n        center_x = sum(x for x, y in touches) / len(touches)\n        center_y = sum(y for x, y in touches) / len(touches)\n        return center_x, center_y\n\n    def touch_vector(grip_point, touch_point):\n        gx, gy = grip_point\n        tx, ty = touch_point\n        return tx - gx, ty - gy\n\n    def grip_spread(grip_point, touches):\n        gx, gy = grip_point\n        return sum(abs(tx - gx) + abs(ty - gy) for tx, ty in touches) / len(touches)\n\n    grip1 = grip_point(touches1)\n    grip2 = grip_point(touches2)\n\n    vectors1 = [touch_vector(grip1, t) for t in touches1]\n    vectors2 = [touch_vector(grip2, t) for t in touches2]\n\n    # Calculate the pan distance\n    pan_distance = sum(abs(tx - ty) for tx, ty in zip(grip1, grip2))\n\n    # Calculate the zoom distance\n    zoom_distance = abs(grip_spread(grip1, touches1) - grip_spread(grip2, touches2))\n\n    # Calculate the rotation distance\n    def touch_rotation(vectors1, vectors2):\n        dot_products = sum(tx * ty for tx, ty in zip(vectors1, vectors2))\n        lengths1 = sum(tx * tx + ty * ty for tx, ty in vectors1)\n        lengths2 = sum(tx * tx + ty * ty for tx, ty in vectors2)\n        return dot_products / (lengths1 * lengths2) ** 0.5\n\n    grip_rotation = touch_rotation(vectors1, vectors2)\n    rotation_distance = 2 * abs(grip_rotation) * min(grip_spread(grip1, touches1), grip_spread(grip2, touches2))\n\n    # Determine the gesture type and direction\n    gestures = [('pan', pan_distance), ('zoom', zoom_distance), ('rotate', rotation_distance)]\n    gesture_type, gesture_distance = max(gestures, key=lambda x: x[1])\n\n    if gesture_type == 'pan':\n        direction = 'pan'\n    elif gesture_type == 'zoom':\n        direction = 'out' if grip_spread(grip1, touches1) > grip_spread(grip2, touches2) else 'in'\n    else:\n        direction = 'clockwise' if grip_rotation > 0 else 'counter-clockwise'\n\n    return f'{len(touches1)} {gesture_type} {direction}'"
    },
    {
        "number": 3159,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_char(char: str) -> bool:\n        return char.isalnum() or char in ['?', '!', ',', '.', ' ']\n\n    def find_images(matrix: List[List[str]]) -> List[List[List[int]]]:\n        images = []\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == '+':\n                    for di in range(2):\n                        for dj in range(2):\n                            if di == dj == 0:\n                                continue\n                            new_i = i + di\n                            new_j = j + dj\n                            if 0 <= new_i < len(matrix) and 0 <= new_j < len(matrix[0]) and matrix[new_i][new_j] == '+':\n                                images.append([i, j, i + di, j + dj])\n        return images\n\n    def remove_ads(matrix: List[List[str]], images: List[List[List[int]]]) -> None:\n        for image in images:\n            ad = True\n            for i in range(image[0] + 1, image[2]):\n                for j in range(image[1] + 1, image[3]):\n                    if not is_valid_char(matrix[i][j]):\n                        ad = False\n                        break\n                if not ad:\n                    break\n            if ad:\n                for i in range(image[0] + 1, image[2]):\n                    for j in range(image[1] + 1, image[3]):\n                        matrix[i][j] = ' '\n\n    def print_matrix(matrix: List[List[str]]) -> str:\n        result = ''\n        for row in matrix:\n            result += ''.join(row) + '\\n'\n        return result[:-1]\n\n    lines = stdin.strip().split('\\n')\n    height, width = map(int, lines[0].split())\n    matrix = [list(line) for line in lines[1:]]\n\n    images = find_images(matrix)\n    remove_ads(matrix, images)\n\n    return print_matrix(matrix) "
    },
    {
        "number": 3159,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_char(char: str) -> bool:\n        if char.isalnum() or char in ['?', '!', ',', '.', ' ', '$', '+']:\n            return True\n        return False\n\n    def is_image(x: int, y: int) -> bool:\n        if board[x][y] == '+':\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < h and 0 <= new_y < w and board[new_x][new_y] == '+':\n                    return True\n        return False\n\n    def remove_image(x: int, y: int) -> int:\n        if not is_image(x, y):\n            return 0\n        board[x][y] = ' '\n        count = 1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < h and 0 <= new_y < w and board[new_x][new_y] == '+':\n                count += remove_image(new_x, new_y)\n        return count\n\n    lines = stdin.splitlines()\n    h, w = map(int, lines[0].split())\n    board = [list(line) for line in lines[1:]]\n\n    ad_count = {}\n    for x in range(h):\n        for y in range(w):\n            if board[x][y] == '+':\n                if is_image(x, y):\n                    count = remove_image(x, y)\n                    for char in board[x][y + 1:y + count - 1]:\n                        if not is_valid_char(char):\n                            ad_count[char] = min(ad_count.get(char, float('inf')), count)\n                            break\n    for char, count in ad_count.items():\n        for x in range(h):\n            for y in range(w):\n                if board[x][y] == char:\n                    board[x][y] = ' '\n                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        new_x, new_y = x + dx, y + dy\n                        if 0 <= new_x < h and 0 <= new_y < w and board[new_x][new_y] == char:\n                            board[new_x][new_y] = ' '\n\n    return ''.join([''.join(line) for line in board]).strip()"
    },
    {
        "number": 3159,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_ad(image: list[str]) -> bool:\n        for row in image:\n            for char in row:\n                if char not in \"?!,. 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                    return True\n        return False\n\n    def find_images(webpage: list[str]) -> list[list[str]]:\n        images = []\n        for i in range(len(webpage) - 3):\n            for j in range(len(webpage[i]) - 3):\n                image = [webpage[i + k][j:j + 5] for k in range(5)]\n                if image[0][0] == \"+\" and image[0][-1] == \"+\" and image[-1][0] == \"+\" and image[-1][-1] == \"+\":\n                    images.append(image)\n        return images\n\n    def remove_ads(webpage: list[str], ads: list[list[str]]) -> None:\n        for ad in ads:\n            for i in range(len(ad)):\n                for j in range(len(ad[i])):\n                    if ad[i][j] == \"+\":\n                        webpage[i + 1][j + 1] = \" \"\n\n    height, width = map(int, stdin.split()[0].split(\" \"))\n    webpage = [list(line) for line in stdin.split(\"\\n\")[1:]]\n\n    images = find_images(webpage)\n    ads = [image for image in images if is_ad(image)]\n\n    remove_ads(webpage, ads)\n\n    return \"\".join([\"\".join(row) + \"\\n\" for row in webpage])[:-1]  # Remove last newline character"
    },
    {
        "number": 3159,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_ad(image: list) -> bool:\n        for row in image:\n            for char in row:\n                if char not in \"?!,. 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                    return True\n        return False\n\n    def remove_ad(image: list) -> None:\n        for i in range(len(image)):\n            for j in range(len(image[0])):\n                if image[i][j] == \"+\":\n                    image[i] = \" \" * len(image[i])\n                else:\n                    image[i] = list(image[i])\n                    image[i][j] = \" \"\n                    image[i] = \"\".join(image[i])\n\n    def process_image(image: list, web_page: list) -> None:\n        image_border = []\n        for i in range(len(image)):\n            for j in range(len(image[0])):\n                if image[i][j] == \"+\":\n                    image_border.append((i, j))\n\n        for row, col in image_border:\n            if (\n                (row > 0 and image[row - 1][col] == \"+\")\n                or (row < len(image) - 1 and image[row + 1][col] == \"+\")\n                or (col > 0 and image[row][col - 1] == \"+\")\n                or (col < len(image[0]) - 1 and image[row][col + 1] == \"+\")\n            ):\n                continue\n\n            for i in range(len(web_page)):\n                for j in range(len(web_page[0])):\n                    if (i, j) in image_border:\n                        continue\n                    if web_page[i][j] not in \"?!,. 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                        web_page[i] = list(web_page[i])\n                        web_page[i][j] = \" \"\n                        web_page[i] = \"\".join(web_page[i])\n\n    def process_web_page(stdin: str) -> list:\n        height, width = map(int, stdin.split()[:2])\n        web_page = [list(stdin.split()[2 + i]) for i in range(height)]\n\n        for i in range(height):\n            for j in range(width):\n                if web_page[i][j] == \"+\":\n                    image = [list(web_page[i + k][j:j + 3]) for k in range(3)]\n                    if not is_ad(image):\n                        process_image(image, web_page)\n                    else:\n                        remove_ad(image)\n                        for k in range(3):\n                            web_page[i + k][j:j + 3] = image[k]\n\n        return web_page\n\n    web_page = process_web_page(stdin)\n    return \"\".join([\"\".join(row) for row in web_page])"
    },
    {
        "number": 3159,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_char(c: str) -> bool:\n        return c.isalnum() or c in ['?', '!', ',', '.', ' ']\n\n    def dfs(board: List[List[str]], x: int, y: int, visited: set, image_sizes: List[int]) -> int:\n        if x < 0 or y < 0 or x >= H or y >= W or (x, y) in visited or not is_valid_char(board[x][y]):\n            return -1\n\n        visited.add((x, y))\n        image_sizes.append(1)\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            dfs(board, x + dx, y + dy, visited, image_sizes)\n\n        return 1\n\n    def remove_ads(board: List[List[str]]) -> List[List[str]]:\n        images = []\n        visited = set()\n\n        for x in range(H):\n            for y in range(W):\n                if (x, y) in visited or board[x][y] != '+':\n                    continue\n\n                image_sizes = []\n                if dfs(board, x, y, visited, image_sizes) == -1:\n                    continue\n\n                images.append((x, y, max(image_sizes)))\n\n        images.sort(key=lambda x: x[2])\n\n        for x, y, size in images:\n            for dx in range(3):\n                for dy in range(3):\n                    board[x + dx][y + dy] = ' '\n\n        return board\n\n    lines = stdin.split('\\n')\n    H, W = map(int, lines[0].split())\n    board = [list(line) for line in lines[1:]]\n\n    result = remove_ads(board)\n    return ''.join([''.join(row) for row in result])"
    },
    {
        "number": 3159,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_image(image):\n        for row in image:\n            for char in row:\n                if char not in ['+', ' ', '$', '.', ',', '?', '!', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']:\n                    return False\n        return True\n\n    def remove_ads(webpage):\n        rows = webpage.split(\"\\n\")\n        images = []\n        for i in range(len(rows)):\n            for j in range(len(rows[i])):\n                if rows[i][j] == \"+\":\n                    image, top_left = find_image(i, j, rows)\n                    images.append((image, top_left))\n\n        smallest_ads = []\n        for image, top_left in images:\n            if not is_valid_image(image):\n                smallest_ads.append((image, top_left))\n\n        if not smallest_ads:\n            return webpage\n\n        smallest_ad = min(smallest_ads, key=lambda x: len(x[0]))\n        for i in range(len(smallest_ad[0])):\n            for j in range(len(smallest_ad[0][0])):\n                rows[smallest_ad[1][0] + i][smallest_ad[1][1] + j] = \" \"\n\n        return \"\\n\".join(rows)\n\n    def find_image(i, j, rows):\n        image = []\n        top_left = (i, j)\n        while j < len(rows[i]) and rows[i][j] == \"+\":\n            image_row = []\n            for k in range(len(rows)):\n                if rows[k][j] == \"+\":\n                    image_row.append(rows[k][i:j])\n            image.append(image_row)\n            j += 1\n        return image, top_left\n\n    height, width = map(int, stdin.readline().split())\n    webpage = [stdin.readline().strip() for _ in range(height)]\n    webpage = remove_ads(\"\\n\".join(webpage))\n\n    return webpage\n"
    },
    {
        "number": 3159,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    web_page = [input() for _ in range(H)]\n    images = []\n\n    def is_valid_image(image):\n        for row in image:\n            for char in row:\n                if char not in \"?!,. \":\n                    return False\n        return True\n\n    def find_images(x, y):\n        image = [[\" \" for _ in range(3)] for _ in range(3)]\n        for i in range(3):\n            for j in range(3):\n                if web_page[y + i][x + j] == \"+\":\n                    image[i][j] = \"+\"\n        if is_valid_image(image):\n            images.append((x, y, image))\n        return image\n\n    for y in range(H - 2):\n        for x in range(W - 2):\n            if web_page[y][x] == \"+\" and web_page[y][x + 1] == \"+\" and web_page[y][x + 2] == \"+\" and \\\n                    web_page[y + 1][x] == \"+\" and web_page[y + 1][x + 1] == \"+\" and web_page[y + 1][x + 2] == \"+\" and \\\n                    web_page[y + 2][x] == \"+\" and web_page[y + 2][x + 1] == \"+\" and web_page[y + 2][x + 2] == \"+\":\n                image = find_images(x, y)\n\n    for x, y, image in images:\n        for i in range(3):\n            for j in range(3):\n                if image[i][j] == \"+\":\n                    web_page[y + i] = web_page[y + i][:x + j] + \" \" + web_page[y + i][x + j + 1:]\n\n    return \"\".join(web_page)"
    },
    {
        "number": 3159,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_char(c: str) -> bool:\n        return c.isalnum() or c in ['?', '!', ',', '.', ' ']\n\n    def is_image(x: int, y: int) -> bool:\n        if 0 <= x < W and 0 <= y < H:\n            return stdin[y][x] == '+'\n        return False\n\n    def find_images(x: int, y: int) -> int:\n        if not is_image(x, y):\n            return 0\n\n        stdin[y][x] = ' '\n        count = 1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            count += find_images(x + dx, y + dy)\n\n        return count\n\n    def find_ads(x: int, y: int, count: int) -> int:\n        if not is_image(x, y):\n            return 0\n\n        stdin[y][x] = ' '\n        total = 1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            total += find_ads(x + dx, y + dy, count)\n\n        if total == count:\n            return 1\n        return 0\n\n    def replace_ads(x: int, y: int) -> None:\n        if is_image(x, y):\n            stdin[y][x] = ' '\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                replace_ads(x + dx, y + dy)\n\n    H, W = map(int, stdin.readline().split())\n    image_count = 0\n    ad_count = 0\n\n    for y in range(H):\n        for x in range(W):\n            if stdin[y][x] == '+':\n                image_count += find_images(x, y)\n                ad_count += find_ads(x, y, image_count)\n\n    if ad_count > 0:\n        for y in range(H):\n            for x in range(W):\n                if stdin[y][x] == '+':\n                    replace_ads(x, y)\n\n    for y in range(H):\n        for x in range(W):\n            if stdin[y][x] == '+':\n                stdin[y][x] = ' '\n\n    return '\\n'.join([''.join(line.split()) for line in stdin.splitlines()])"
    },
    {
        "number": 3159,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_char(char):\n        return char.isalnum() or char in \"?!,.\"\n\n    def find_images(grid, visited):\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == \"+\" and not visited[i][j]:\n                    start = (i, j)\n                    image = []\n                    stack = [start]\n                    visited[i][j] = True\n                    while stack:\n                        r, c = stack.pop()\n                        if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] != \"+\":\n                            continue\n                        image.append((r, c))\n                        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                            new_r, new_c = r + dr, c + dc\n                            if (new_r, new_c) not in image and not visited[new_r][new_c]:\n                                stack.append((new_r, new_c))\n                                visited[new_r][new_c] = True\n                    yield image\n\n    def remove_ads(grid, images):\n        banned_images = []\n        for image in images:\n            if any(not is_valid_char(grid[r][c]) for r, c in image):\n                banned_images.append(image)\n        if not banned_images:\n            return grid\n\n        banned_image = min(banned_images, key=lambda x: len(x))\n        for r, c in banned_image:\n            grid[r][c] = \" \"\n        return grid\n\n    lines = stdin.splitlines()\n    height, width = map(int, lines[0].split())\n    grid = [list(line) for line in lines[1:]]\n    visited = [[False] * width for _ in range(height)]\n    images = list(find_images(grid, visited))\n    cleaned_grid = remove_ads(grid, images)\n    return \"\".join([\"\".join(row) for row in cleaned_grid])"
    },
    {
        "number": 3159,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_char(char: str) -> bool:\n        allowed_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789?!,.\"\n        return char in allowed_chars\n\n    def find_images(grid: List[str]) -> List[Tuple[int, int, int, int]]:\n        images = []\n        rows, cols = len(grid), len(grid[0])\n\n        for row in range(rows):\n            for col in range(cols):\n                if grid[row][col] == \"+\":\n                    for d_row, d_col in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        new_row, new_col = row + d_row, col + d_col\n                        if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == \"+\":\n                            start_row, end_row = min(row, new_row), max(row, new_row)\n                            start_col, end_col = min(col, new_col), max(col, new_col)\n                            while start_row > 0 and grid[start_row - 1][start_col] == \"+\":\n                                start_row -= 1\n                            while start_col > 0 and grid[start_row][start_col - 1] == \"+\":\n                                start_col -= 1\n                            while end_row < rows - 1 and grid[end_row + 1][end_col] == \"+\":\n                                end_row += 1\n                            while end_col < cols - 1 and grid[end_row][end_col + 1] == \"+\":\n                                end_col += 1\n                            images.append((start_row, start_col, end_row, end_col))\n\n        return images\n\n    def find_ads(grid: List[str], images: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int, int, int]]:\n        ads = []\n        for image in images:\n            has_invalid_char = False\n            for row in range(image[0] + 1, image[2]):\n                for col in range(image[1] + 1, image[3]):\n                    if not is_valid_char(grid[row][col]):\n                        has_invalid_char = True\n                        break\n                if has_invalid_char:\n                    break\n            if has_invalid_char:\n                ads.append(image)\n\n        return ads\n\n    def remove_ads(grid: List[str], ads: List[Tuple[int, int, int, int]]) -> None:\n        for ad in ads:\n            for row in range(ad[0], ad[2] + 1):\n                for col in range(ad[1], ad[3] + 1):\n                    grid[row][col] = \" \"\n\n    def print_webpage(grid: List[str]) -> str:\n        return \"\".join([\"\".join(row) for row in grid])\n\n    height, width = map(int, stdin.readline().strip().split())\n    grid = [list(stdin.readline().strip()) for _ in range(height)]\n\n    images = find_images(grid)\n    ads = find_ads(grid, images)\n    remove_ads(grid, ads)\n    result = print_webpage(grid)\n\n    return result"
    },
    {
        "number": 3160,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    n = len(S)\n    total = 0\n    count = 0\n\n    for C in range(2**n):\n        binary = bin(C)[2:].zfill(n)\n        H = [S[i] for i in range(n) if binary[i] == '1']\n        T = [S[i] for i in range(n) if binary[i] == '0']\n\n        if '?' in T:\n            for i in range(len(H) + 1):\n                new_S = list(S)\n                new_S[T.index('?')] = 'H' if i % 2 == 0 else 'T'\n                new_S = ''.join(new_S)\n                L = 1 + solution(new_S)\n                total += L\n                count += 1\n        else:\n            L = len(T) + len(H)\n            total += L\n            count += 1\n\n    return total / count"
    },
    {
        "number": 3160,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    n = len(S)\n    total = 0\n\n    for C in range(2 ** n):\n        L = 0\n        H = 0\n        for i in range(n):\n            if C & (1 << i):\n                H += 1\n                if S[i] == \"H\" or S[i] == \"?\":\n                    L += 1\n                    H = 1\n                else:\n                    H = 0\n            else:\n                if S[i] == \"T\" or S[i] == \"?\":\n                    L += 1\n                else:\n                    break\n        else:\n            total += L\n\n    return str(total / (2 ** n))"
    },
    {
        "number": 3160,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    total_count = 0\n    total_length = 0\n    for i in range(len(S)):\n        if S[i] == \"H\":\n            total_count += 1\n        elif S[i] == \"T\":\n            total_count = 0\n        else:\n            continue\n        if total_count > 0:\n            total_length += total_count\n        else:\n            total_length += 1\n    return str(total_length / len(S))"
    },
    {
        "number": 3160,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from collections import Counter\n    from itertools import product\n    from math import factorial\n\n    S = stdin.strip()\n    n = S.count(\"?\") + S.count(\"H\") + S.count(\"T\")\n\n    def count_operations(s: str) -> int:\n        counter = Counter(s)\n        count_h = counter[\"H\"]\n        operations = 0\n\n        while count_h > 0:\n            counter[\"T\"] += 1\n            count_h = counter[\"H\"]\n            operations += 1\n\n        return operations\n\n    total_operations = 0\n    for h_count in range(n + 1):\n        for seq in product([\"H\", \"T\"], repeat=n - h_count):\n            seq = \"\".join(seq)\n            for i in range(n - h_count):\n                seq = seq[:i] + \"H\" + seq[i + 1 :]\n                total_operations += count_operations(seq)\n\n    total_sequences = factorial(n)\n    average_operations = total_operations / total_sequences\n\n    return f\"{average_operations:.1f}\"\n"
    },
    {
        "number": 3160,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    sequence = stdin.strip()\n    total_length = len(sequence)\n    total_states = 2 ** total_length\n    \n    states = [0] * total_states\n    for i in range(total_states):\n        num_h = 0\n        for j in range(total_length):\n            if i & (1 << j):\n                num_h += 1\n        states[i] = num_h\n    \n    num_seq = [0] * (total_length + 1)\n    den_seq = [0] * (total_length + 1)\n    for i in range(total_states):\n        if sequence == \"??\" * (total_length // 2):\n            num_seq[0] += states[i]\n            den_seq[0] += 1\n        else:\n            for j in range(total_length + 1):\n                mask = (1 << j) - 1\n                if (i & mask) == mask:\n                    num_seq[j] += states[i]\n                    den_seq[j] += 1\n    \n    expected_length = sum(num_seq[i] / den_seq[i] * (2 ** i) for i in range(total_length + 1))\n    return str(expected_length)"
    },
    {
        "number": 3160,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    total_cases = 2 ** len(S)\n    total_operations = 0\n\n    for i in range(total_cases):\n        binary_representation = format(i, f'0{len(S)}b')\n        current_state = []\n\n        for j, char in enumerate(S):\n            if char == 'H':\n                current_state.append(char)\n            elif char == 'T':\n                current_state.append(char)\n            else:\n                if binary_representation[j] == '0':\n                    current_state.append('T')\n                else:\n                    current_state.append('H')\n\n        current_state_str = ''.join(current_state)\n        operations = 0\n\n        while True:\n            count_h = current_state_str.count('H')\n\n            if count_h == 0:\n                break\n\n            index = current_state_str.index('H')\n            current_state_str = current_state_str[:index] + 'T' + current_state_str[index + 1:]\n            operations += 1\n\n        total_operations += operations\n\n    return str(total_operations / total_cases)"
    },
    {
        "number": 3160,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    sequence = stdin.strip()\n    if \"?\" not in sequence:\n        return str(len(sequence))\n\n    total_operations = 0\n    max_operations = len(sequence)\n    for i in range(max_operations):\n        if sequence[i] == \"?\":\n            sequence = sequence[:i] + \"H\" + sequence[i+1:]\n        sequence = sequence.lstrip(\"T\")\n        sequence = sequence.rstrip(\"T\")\n        total_operations += 1\n        if not sequence:\n            break\n\n    return str(total_operations)\n\ndef"
    },
    {
        "number": 3160,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    n = len(S)\n    total_prob = 0\n\n    for i in range(n + 1):\n        p = 1.0 / (2 ** i)\n        total_prob += p\n\n        if S.find('?') == -1 and len(S) == i:\n            break\n\n    return str(total_prob)\n\ndef"
    },
    {
        "number": 3160,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n\n    # Initialize the frequency of H and T in the initial sequence\n    freq_H = S.count('H')\n    freq_T = S.count('T')\n    freq_Q = S.count('?')\n\n    # Initialize the number of unknown states and their possible values\n    num_unknown = freq_Q\n    unknown_values = [[0, 1] for _ in range(num_unknown)]\n\n    # Initialize the total number of configurations and their counts\n    total_configs = 2 ** num_unknown\n    config_counts = [1] * total_configs\n\n    # Calculate the number of coins with the same value in each position\n    same_value_counts = [freq_H, freq_T]\n\n    # Initialize the stopping times for each configuration\n    stopping_times = [0] * total_configs\n\n    for i in range(len(S)):\n        # Update the frequency and counts of coins with the same value in each position\n        same_value_counts = [same_value_counts[0] + 1, same_value_counts[1]]\n\n        # Update the stopping times for each configuration\n        for j in range(total_configs):\n            if j % 2 == 0:\n                # If the coin in the current position is unknown, the stopping time is the sum of the stopping times of all possible values\n                stopping_times[j] += stopping_times[j // 2]\n            else:\n                # If the coin in the current position is known, the stopping time depends on the value of the coin and the frequency of coins with the same value\n                if S[i] == 'H':\n                    stopping_times[j] += same_value_counts[0]\n                else:\n                    stopping_times[j] += same_value_counts[1]\n\n            # If the stopping time is greater than the current configuration count, update the configuration count\n            if stopping_times[j] > config_counts[j]:\n                config_counts[j] = stopping_times[j]\n\n    # Calculate the average stopping time\n    total_config_count = sum(config_counts)\n    expected_stopping_time = sum([stopping_times[i] * config_counts[i] for i in range(total_configs)]) / total_config_count\n\n    return f\"{expected_stopping_time:.1f}\""
    },
    {
        "number": 3160,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    total_count = 0\n    total_length = 0\n    for i in range(len(S)):\n        if S[i] == 'H':\n            total_count += 1\n        elif S[i] == 'T':\n            total_length += 1\n        else:\n            total_count += 1\n            total_length += 1\n\n    return str(total_count / total_length)"
    },
    {
        "number": 3161,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def recursive_paint(n, i, j):\n        if n == 1:\n            return [0, 1]\n        else:\n            new_n = n // 2\n            if i <= new_n and j <= new_n:\n                return [1] + recursive_paint(new_n, i, j)\n            elif i <= new_n and j > new_n:\n                return [0] + recursive_paint(new_n, i, j - new_n)\n            elif i > new_n and j <= new_n:\n                return [0] + recursive_paint(new_n, i - new_n, j)\n            else:\n                return [1] + recursive_paint(new_n, i - new_n, j - new_n)\n\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    target_picture = input_list[1:]\n    min_diff = float('inf')\n    min_painted_picture = None\n\n    for i in range(n):\n        for j in range(n):\n            painted_picture = [''] * n\n            painted_picture[i] = painted_picture[i][:j] + ''.join(map(str, recursive_paint(n, i, j))) + painted_picture[i][j + 1:]\n            painted_picture = '\\n'.join(painted_picture)\n            diff = sum([sum(int(a) ^ int(b) for a, b in zip(line1, line2)) for line1, line2 in zip(target_picture, painted_picture.split('\\n'))])\n            if diff < min_diff:\n                min_diff = diff\n                min_painted_picture = painted_picture\n\n    return f'{min_diff}\\n{min_painted_picture}'"
    },
    {
        "number": 3161,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    target_picture = [list(map(int, stdin.readline().strip())) for _ in range(n)]\n\n    def paint_picture(n: int, target_picture: List[List[int]]) -> Tuple[int, List[List[int]]]:\n        if n == 1:\n            return (0, target_picture)\n\n        new_n = n // 2\n        min_diff = float('inf')\n        min_painting = None\n\n        for i in range(new_n):\n            for j in range(new_n):\n                white_square = [[1] * new_n for _ in range(new_n)]\n                black_square = [[0] * new_n for _ in range(new_n)]\n\n                top_left, top_right, bottom_left, bottom_right = white_square, black_square, black_square, white_square\n\n                if j > 0:\n                    top_left, top_right = black_square, white_square\n                if i > 0:\n                    top_left, bottom_left = white_square, black_square\n\n                new_painting = [[0] * n for _ in range(n)]\n                for x in range(i * new_n, (i + 1) * new_n):\n                    for y in range(j * new_n, (j + 1) * new_n):\n                        if x < new_n and y < new_n:\n                            new_painting[x][y] = top_left[x - i * new_n][y - j * new_n]\n                        elif x < new_n:\n                            new_painting[x][y] = top_right[x - i * new_n][y - j * new_n - new_n]\n                        elif y < new_n:\n                            new_painting[x][y] = bottom_left[x - i * new_n - new_n][y - j * new_n]\n                        else:\n                            new_painting[x][y] = bottom_right[x - i * new_n - new_n][y - j * new_n - new_n]\n\n                diff = sum(sum(abs(target_picture[x][y] - new_painting[x][y]) for y in range(n)) for x in range(n))\n                if diff < min_diff:\n                    min_diff = diff\n                    min_painting = new_painting\n\n        return (min_diff, min_painting)\n\n    min_diff, min_painting = paint_picture(n, target_picture)\n    return f\"{min_diff}\\n\" + \"\\n\".join(\"\".join(str(x)) for x in min_painting)"
    },
    {
        "number": 3161,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def split_squares(square, n):\n        if n == 1:\n            return [square]\n        half_n = n // 2\n        result = []\n        for i in range(2):\n            for j in range(2):\n                new_square = [['.' for _ in range(half_n)] for _ in range(half_n)]\n                for k in range(half_n):\n                    for l in range(half_n):\n                        new_square[k][l] = square[k + i * half_n][l + j * half_n]\n                result.extend(split_squares(new_square, half_n))\n        return result\n\n    def count_differences(square1, square2, n):\n        if n == 1:\n            return 0 if square1[0][0] == square2[0][0] else 1\n        half_n = n // 2\n        result = 0\n        for i in range(2):\n            for j in range(2):\n                new_square1 = [['.' for _ in range(half_n)] for _ in range(half_n)]\n                new_square2 = [['.' for _ in range(half_n)] for _ in range(half_n)]\n                for k in range(half_n):\n                    for l in range(half_n):\n                        new_square1[k][l] = square1[k + i * half_n][l + j * half_n]\n                        new_square2[k][l] = square2[k + i * half_n][l + j * half_n]\n                result += count_differences(new_square1, new_square2, half_n)\n        return result\n\n    def find_best_solution(square, n):\n        solutions = split_squares(square, n)\n        min_diff = n ** 2\n        best_solution = None\n        for solution in solutions:\n            diff = count_differences(solution, target, n)\n            if diff < min_diff:\n                min_diff = diff\n                best_solution = solution\n        return min_diff, best_solution\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    target = [list(map(int, lines[i + 1])) for i in range(n)]\n\n    min_diff, best_solution = find_best_solution(target, n)\n    result = [str(min_diff)] + [''.join(map(str, row)) for row in best_solution]\n    return '\\n'.join(result)"
    },
    {
        "number": 3161,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def josip_paint(n: int, target_pic: list) -> tuple:\n        if n == 1:\n            return (0, [1])\n        else:\n            diff = float('inf')\n            result_pic = []\n            for i in range(4):\n                new_target_pic = []\n                for j in range(n // 2):\n                    new_target_pic.append(target_pic[j][:n // 2])\n                for j in range(n // 2):\n                    new_target_pic.append(target_pic[j + n // 2][:n // 2])\n                for j in range(n // 2):\n                    new_target_pic.append(target_pic[j][n // 2:])\n                for j in range(n // 2):\n                    new_target_pic.append(target_pic[j + n // 2][n // 2:])\n\n                if i == 0:\n                    new_target_pic[0][0] = 1\n                elif i == 1:\n                    new_target_pic[n // 2 - 1][n // 2 - 1] = 1\n                elif i == 2:\n                    new_target_pic[n // 2 - 1][0] = 1\n\n                curr_diff, curr_pic = josip_paint(n // 2, new_target_pic)\n                if curr_diff < diff:\n                    diff = curr_diff\n                    result_pic = curr_pic\n\n            if n == 2:\n                if target_pic[0][0] != result_pic[0][0]:\n                    diff += 1\n                if target_pic[0][1] != result_pic[0][1]:\n                    diff += 1\n                if target_pic[1][0] != result_pic[1][0]:\n                    diff += 1\n                if target_pic[1][1] != result_pic[1][1]:\n                    diff += 1\n            return (diff, result_pic)\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    target_pic = []\n    for i in range(1, n + 1):\n        target_pic.append(list(map(int, lines[i])))\n\n    diff, result_pic = josip_paint(n, target_pic)\n    return f\"{diff}\\n\" + '\\n'.join([''.join(map(str, row)) for row in result_pic])"
    },
    {
        "number": 3161,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def josip(n, target):\n        if n == 1:\n            return target[0][0]\n        else:\n            new_n = n // 2\n            result = [[-1 for _ in range(n)] for _ in range(n)]\n            for i in range(new_n):\n                for j in range(new_n):\n                    if i == 0 and j == 0:\n                        result[i][j] = 1\n                    elif i == 0 and j == 1:\n                        result[i][j] = 0\n                    elif i == 1 and j == 0:\n                        result[i][j] = 0\n                    else:\n                        result[i][j] = 1\n\n            for i in range(new_n):\n                for j in range(new_n):\n                    if result[i][j] == -1:\n                        if i == 0:\n                            result[i][j] = target[i][j]\n                        elif j == 0:\n                            result[i][j] = target[i][j]\n                        else:\n                            result[i][j] = not target[i][j]\n\n            for i in range(new_n):\n                for j in range(new_n):\n                    result[i][j] = josip(new_n, [[result[i][j], result[i][j + new_n]], [result[i + new_n][j], result[i + new_n][j + new_n]]])\n\n            return result\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    target = [[int(x) for x in line] for line in lines[1:]]\n    result = josip(n, target)\n    difference = sum(sum(abs(target[i][j] - result[i][j]) for j in range(n)) for i in range(n))\n    output = f'{difference}\\n'\n    for row in result:\n        output += ''.join(str(x) for x in row) + '\\n'\n    return output"
    },
    {
        "number": 3161,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_color(x, y, n):\n        if n == 1:\n            return target_picture[x][y]\n        new_n = n // 2\n        selected_square = (x // new_n, y // new_n)\n        black_square = None\n        white_square = None\n        for i in range(2):\n            for j in range(2):\n                if selected_square != (i, j):\n                    square_color = find_color(x - i * new_n, y - j * new_n, new_n)\n                    if square_color == '0':\n                        black_square = (i, j)\n                    else:\n                        white_square = (i, j)\n        if black_square is None:\n            return '1'\n        elif white_square is None:\n            return '0'\n        else:\n            return find_color(x + (white_square[0] - black_square[0]) * new_n, y + (white_square[1] - black_square[1]) * new_n, new_n)\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    target_picture = input_data[1:]\n\n    difference = 0\n    result_picture = []\n    for i in range(n):\n        for j in range(n):\n            if target_picture[i][j] != find_color(i, j, n):\n                difference += 1\n                result_picture.append('1' if find_color(i, j, n) == '0' else '0')\n            else:\n                result_picture.append(target_picture[i][j])\n        result_picture.append('\\n')\n\n    return f'{difference}\\n{\"\".join(result_picture)}'"
    },
    {
        "number": 3161,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    target = [list(map(int, line)) for line in lines[1:]]\n\n    def paint(n, target):\n        if n == 1:\n            return target[0][0]\n        else:\n            new_n = n // 2\n            new_target = [[target[x][y] for y in range(new_n, 2 * new_n)] for x in range(new_n, 2 * new_n)]\n            white = paint(new_n, new_target)\n            black = paint(new_n, [[1 - x for x in row] for row in new_target])\n            diff = white[0] + black[0]\n            result = [[white[i + j] if i == j else black[i + j] for j in range(new_n)] for i in range(new_n)]\n            return diff, result\n\n    diff, result = paint(n, target)\n    output = [str(diff)] + [''.join(map(str, row)) for row in result]\n    return '\\n'.join(output)"
    },
    {
        "number": 3161,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    target = [list(map(int, stdin.readline().strip())) for _ in range(n)]\n\n    def paint_helper(n, target):\n        if n == 1:\n            return [target]\n        else:\n            sub_n = n // 2\n            result = []\n            for i in range(sub_n):\n                for j in range(sub_n):\n                    if target[i][j] == 1:\n                        result.append([0] * sub_n)\n                    else:\n                        result.append([1] * sub_n)\n\n            return [result[i:i + n] for i in range(0, len(result), n)]\n\n    def count_diff(painted, target):\n        return sum(sum(x ^ y for x, y in zip(row1, row2)) for row1, row2 in zip(painted, target))\n\n    painted = paint_helper(n, target[0][0])\n    min_diff = count_diff(painted, target)\n\n    for i in range(1, n):\n        for j in range(n):\n            new_painted = paint_helper(n, target[i][j])\n            diff = count_diff(new_painted, target)\n            if diff < min_diff:\n                min_diff = diff\n                painted = new_painted\n\n    return f\"{min_diff}\\n{''.join(''.join(map(str, row)) + '\\\\n' for row in painted)}\""
    },
    {
        "number": 3161,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_power_of_two(n):\n        return (n != 0) and (n & (n - 1) == 0)\n\n    def paint_picture(N, target_picture):\n        if N == 1:\n            return target_picture[0][0]\n\n        # Split the square into four smaller squares\n        split_picture = [\n            [target_picture[i][j] for j in range(N // 2)] for i in range(N // 2)\n        ]\n\n        # Select one of the four squares and colour it white\n        white_square = [\n            [\"1\" if i == j else \"0\" for i in range(N // 2)] for j in range(N // 2)\n        ]\n\n        # Select one of the three remaining squares and colour it black\n        black_square = [\n            [\"1\" if i != j else \"0\" for i in range(N // 2)] for j in range(N // 2)\n        ]\n\n        # Recursively paint the two remaining squares\n        remaining_picture = [[split_picture[i][j] for j in range(N // 2)] for i in range(N // 2)]\n        for i in range(N // 2):\n            for j in range(N // 2):\n                remaining_picture[i][j] = str(1 - int(remaining_picture[i][j]))\n\n        # Merge the squares\n        merged_picture = [\n            [white_square[i][j] if white_square[i][j] == black_square[i][j] else \"*\" for j in range(N // 2)] +\n            [remaining_picture[i][j] if white_square[i][j] == black_square[i][j] else \"*\" for j in range(N // 2)]\n            for i in range(N // 2)\n        ] + [[merged_picture[i][j] for j in range(N)] for i in range(N // 2)]\n\n        return merged_picture\n\n    def count_difference(picture1, picture2):\n        difference = 0\n        for i in range(len(picture1)):\n            for j in range(len(picture1[0])):\n                if picture1[i][j] != picture2[i][j]:\n                    difference += 1\n        return difference\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    target_picture = [list(line) for line in lines[1:]]\n\n    if not is_power_of_two(N) or len(target_picture) != N or any(len(row) != N for row in target_picture):\n        return \"Invalid input\"\n\n    painted_picture = paint_picture(N, target_picture)\n    difference = count_difference(painted_picture, target_picture)\n\n    return f\"{difference}\\n{''.join(str(row) for row in painted_picture)}\" "
    },
    {
        "number": 3161,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    target_picture = [list(map(int, stdin.readline().strip())) for _ in range(n)]\n\n    def helper(square):\n        if len(square) == 1:\n            return square\n\n        white_square = [[1] * len(square) for _ in range(len(square))]\n        black_square = [[0] * len(square) for _ in range(len(square))]\n\n        for i in range(len(square)):\n            for j in range(len(square)):\n                if i % 2 == 0 and j % 2 == 0:\n                    white_square[i][j] = square[i][j]\n                elif i % 2 == 0:\n                    black_square[i][j] = square[i][j]\n                elif j % 2 == 0:\n                    white_square[i][j] = square[i][j]\n                else:\n                    black_square[i][j] = square[i][j]\n\n        return helper(white_square) + helper(black_square)\n\n    josip_picture = helper(target_picture)\n\n    def count_diff(a, b):\n        return sum(x != y for row in zip(a, b) for x, y in zip(row[0], row[1]))\n\n    min_diff = float('inf')\n    min_picture = None\n\n    for i in range(n):\n        for j in range(n):\n            for color in [0, 1]:\n                modified_picture = [row[:] for row in josip_picture]\n                modified_picture[i][j] = color\n                diff = count_diff(target_picture, modified_picture)\n                if diff < min_diff:\n                    min_diff = diff\n                    min_picture = modified_picture\n\n    return f\"{min_diff}\\n\" + \"\\n\".join(\"\".join(map(str, row)) for row in min_picture)"
    },
    {
        "number": 3162,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    pulse_list = []\n    for _ in range(n):\n        pulse_info = stdin.readline().strip().split()\n        pulse_list.append((pulse_info[0], int(pulse_info[1]), int(pulse_info[2]), int(pulse_info[3])))\n    \n    activated_pixels = set()\n    for pulse in pulse_list:\n        if pulse[0] == 'h':\n            for i in range(pulse[3]):\n                for j in range(pulse[1], pulse[1] + pulse[2]):\n                    activated_pixels.add((i, j))\n        else:\n            for i in range(pulse[3]):\n                for j in range(pulse[1], pulse[1] + pulse[2]):\n                    activated_pixels.add((j, i))\n    \n    return str(len(activated_pixels))"
    },
    {
        "number": 3162,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    pulses = []\n    for i in range(n):\n        direction, t, m, a = stdin.readline().split()\n        pulses.append((direction, int(t), int(m), int(a)))\n\n    max_alu = 100000\n    active_pixels = set()\n\n    for pulse in pulses:\n        direction, t, m, a = pulse\n        if direction == 'h':\n            start_alu = (t - 1) // max_alu\n            end_alu = (t + m - 1) // max_alu\n            start_wire = t % max_alu\n            end_wire = start_wire + m\n            for i in range(start_alu, end_alu + 1):\n                if i == start_alu:\n                    start = start_wire\n                else:\n                    start = 1\n                if i == end_alu:\n                    end = end_wire\n                else:\n                    end = max_alu + 1\n                for j in range(start, end):\n                    active_pixels.add((i, j))\n        else:\n            start_alu = (t - 1) // max_alu\n            end_alu = (t + m - 1) // max_alu\n            start_wire = t % max_alu\n            end_wire = start_wire + m\n            for i in range(start_alu, end_alu + 1):\n                if i == start_alu:\n                    start = start_wire\n                else:\n                    start = 1\n                if i == end_alu:\n                    end = end_wire\n                else:\n                    end = max_alu + 1\n                for j in range(start, end):\n                    if (j, a) in active_pixels:\n                        active_pixels.remove((j, a))\n\n    return len(active_pixels)"
    },
    {
        "number": 3162,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_active(pulse1, pulse2):\n        if pulse1[0] == 'h' and pulse2[0] == 'v':\n            if pulse1[3] == pulse2[3]:\n                if pulse1[2] + pulse1[1] <= pulse2[1] < pulse1[2] + pulse1[1] + pulse2[2]:\n                    return True\n        elif pulse1[0] == 'v' and pulse2[0] == 'h':\n            if pulse1[3] == pulse2[3]:\n                if pulse1[2] + pulse1[1] <= pulse2[1] < pulse1[2] + pulse1[1] + pulse2[2]:\n                    return True\n        return False\n\n    n = int(stdin.readline())\n    pulses = [stdin.readline().split() for _ in range(n)]\n    activated_pixels = set()\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_active(pulses[i], pulses[j]):\n                activated_pixels.add((int(pulses[i][3]), int(pulses[j][3])))\n\n    return str(len(activated_pixels))"
    },
    {
        "number": 3162,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    schedule = [stdin.readline().strip().split() for _ in range(n)]\n\n    max_horizontal_wire = max(int(pulse[3]) for pulse in schedule if pulse[0] == 'h')\n    max_vertical_wire = max(int(pulse[3]) for pulse in schedule if pulse[0] == 'v')\n\n    activated_pixels = set()\n\n    for pulse in schedule:\n        direction, start_time, length, wire_number = pulse\n        start_time, length, wire_number = map(int, (start_time, length, wire_number))\n\n        if direction == 'h':\n            for i in range(wire_number, max_horizontal_wire + 1):\n                for j in range(start_time + length, max_vertical_wire + 1):\n                    activated_pixels.add((i, j))\n        else:\n            for i in range(wire_number, max_vertical_wire + 1):\n                for j in range(start_time + length, max_horizontal_wire + 1):\n                    activated_pixels.add((i, j))\n\n    return str(len(activated_pixels))"
    },
    {
        "number": 3162,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_active(pulse1, pulse2):\n        return pulse1[1] <= pulse2[1] <= pulse1[1] + pulse1[2] or pulse2[1] <= pulse1[1] <= pulse2[1] + pulse2[2]\n\n    def is_intersecting(pulse1, pulse2):\n        return pulse1[3] == pulse2[3] and pulse1[0] != pulse2[0]\n\n    def count_activated_pixels(pulses):\n        vertical_pulses = [pulse for pulse in pulses if pulse[0] == 'v']\n        horizontal_pulses = [pulse for pulse in pulses if pulse[0] == 'h']\n\n        activated_pixels = set()\n        for i in range(len(vertical_pulses)):\n            for j in range(len(horizontal_pulses)):\n                if is_intersecting(vertical_pulses[i], horizontal_pulses[j]) and is_active(vertical_pulses[i], horizontal_pulses[j]):\n                    activated_pixels.add((vertical_pulses[i][3], horizontal_pulses[j][3]))\n\n        return len(activated_pixels)\n\n    n = int(stdin.readline())\n    pulses = [tuple(int(x) if x.isdigit() else x for x in stdin.readline().split()) for _ in range(n)]\n\n    result = count_activated_pixels(pulses)\n    return str(result)"
    },
    {
        "number": 3162,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    schedule = []\n    for i in range(n):\n        direction, t, m, a = stdin.readline().split()\n        schedule.append((direction, int(t), int(m), int(a)))\n\n    # Initialize the LCD panel with zeros\n    lcd_panel = [[0 for j in range(100001)] for i in range(100001)]\n\n    # Process the schedule\n    for direction, t, m, a in schedule:\n        if direction == 'h':\n            for i in range(t, t + m):\n                lcd_panel[a][i] += 1\n        else:\n            for j in range(t, t + m):\n                lcd_panel[j][a] += 1\n\n    # Calculate the number of activated pixels\n    activated_pixels = 0\n    for i in range(1, 100001):\n        for j in range(1, 100001):\n            if lcd_panel[i][j] == 2:\n                activated_pixels += 1\n\n    return str(activated_pixels)"
    },
    {
        "number": 3162,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    pulses = []\n    for i in range(1, n + 1):\n        pulse = stdin.split(\"\\n\")[i].split(\" \")\n        pulses.append(pulse)\n    \n    horizontal_wires = [0] * 100001\n    vertical_wires = [0] * 100001\n    \n    for pulse in pulses:\n        if pulse[0] == 'h':\n            start_time = int(pulse[1])\n            length = int(pulse[2])\n            wire_number = int(pulse[3])\n            horizontal_wires[wire_number] = max(horizontal_wires[wire_number], start_time + length)\n        else:\n            start_time = int(pulse[1])\n            length = int(pulse[2])\n            wire_number = int(pulse[3])\n            vertical_wires[wire_number] = max(vertical_wires[wire_number], start_time + length)\n    \n    activated_pixels = 0\n    for i in range(1, 100001):\n        for j in range(1, 100001):\n            if horizontal_wires[i] <= j <= vertical_wires[j]:\n                activated_pixels += 1\n    \n    return str(activated_pixels)"
    },
    {
        "number": 3162,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_pixel_activations(pulses: List[List[int]]) -> int:\n        rows = max(pulse[3] for pulse in pulses)\n        cols = max(pulse[3] for pulse in pulses)\n        grid = [[False for _ in range(cols)] for _ in range(rows)]\n\n        for pulse in pulses:\n            direction, t, m, a = pulse\n            for time in range(t, t + m):\n                if direction == \"h\":\n                    grid[a - 1][time - 1] = True\n                else:\n                    grid[time - 1][a - 1] = True\n\n        activated_pixels = 0\n        for row in grid:\n            for pixel in row:\n                if pixel:\n                    activated_pixels += 1\n\n        return activated_pixels\n\n    n = int(stdin.readline())\n    pulses = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    return str(get_pixel_activations(pulses))"
    },
    {
        "number": 3162,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    lines = [line.strip().split() for line in stdin.readlines()]\n\n    # Initialize the grid\n    max_wires = max([int(line[3]) for line in lines])\n    grid = [[False for _ in range(max_wires + 1)] for _ in range(max_wires + 1)]\n\n    # Process the pulses\n    for line in lines:\n        direction, start_time, length, wire_number = line\n        start_time = int(start_time)\n        length = int(length)\n        wire_number = int(wire_number)\n\n        if direction == 'h':\n            for i in range(start_time, start_time + length):\n                grid[wire_number][i] = True\n        elif direction == 'v':\n            for i in range(start_time, start_time + length):\n                grid[i][wire_number] = True\n\n    # Count the activated pixels\n    count = 0\n    for i in range(1, max_wires + 1):\n        for j in range(1, max_wires + 1):\n            if grid[i][j] and grid[i - 1][j] and grid[i][j - 1] and grid[i - 1][j - 1]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3162,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_activated(p1, p2):\n        return p1[0] == p2[0] or p1[1] == p2[1]\n\n    def activated_pixels(pulses):\n        horizontal_pulses = [pulse for pulse in pulses if pulse[0] == \"h\"]\n        vertical_pulses = [pulse for pulse in pulses if pulse[0] == \"v\"]\n\n        activated = set()\n        for pulse in horizontal_pulses:\n            direction, t, m, a = pulse\n            t, m, a = int(t), int(m), int(a)\n            for x in range(a, a + m):\n                for y in range(1, len(vertical_pulses) + 1):\n                    if is_activated((x, y), (x, y - 1)) and is_activated((x, y), (x - 1, y)):\n                        activated.add((x, y))\n        return len(activated)\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    pulses = [line.split() for line in lines[1:]]\n    result = activated_pixels(pulses)\n    return str(result)"
    },
    {
        "number": 3163,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_state(state1, state2):\n        for i in range(len(state1)):\n            if state1[i] != 0 and state1[i] != state2[i]:\n                return False\n        return True\n\n    def count_moves(shelves, final_shelves):\n        total_moves = 0\n        for i in range(len(shelves)):\n            moves = 0\n            for j in range(len(shelves[i])):\n                if shelves[i][j] != final_shelves[i][j]:\n                    moves += 1\n            total_moves += moves // 2\n        return total_moves\n\n    def find_solution(shelves, final_shelves):\n        if all(is_valid_state(shelves[i], final_shelves[i]) for i in range(len(shelves))):\n            return count_moves(shelves, final_shelves)\n\n        for i in range(len(shelves)):\n            for j in range(len(shelves[i])):\n                if shelves[i][j] != final_shelves[i][j]:\n                    temp_shelves = [shelves[k][:] for k in range(len(shelves))]\n                    temp_shelves[i][j], temp_shelves[i][final_shelves[i].index(shelves[i][j])] = temp_shelves[i][final_shelves[i].index(shelves[i][j])], temp_shelves[i][j]\n                    if all(is_valid_state(temp_shelves[k], final_shelves[k]) for k in range(len(temp_shelves))):\n                        return find_solution(temp_shelves, final_shelves)\n        return -1\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    shelves = []\n    final_shelves = []\n\n    for i in range(1, N + 1):\n        shelves.append(list(map(int, lines[i].split())))\n        final_shelves.append(list(map(int, lines[i + N].split())))\n\n    return str(find_solution(shelves, final_shelves))"
    },
    {
        "number": 3163,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_lifting(shelf1, shelf2):\n        count = 0\n        for i in range(len(shelf1)):\n            if shelf1[i] != shelf2[i]:\n                count += 1\n        return count\n\n    def is_solvable(shelves1, shelves2, shelves_left, shelves_right, shelves_top, shelves_bottom):\n        for i in range(len(shelves1)):\n            for j in range(len(shelves1[i])):\n                if shelves1[i][j] != shelves2[i][j]:\n                    if not (0 < j < len(shelves1[i]) - 1 and shelves1[i][j - 1] == shelves2[i][j - 1] and shelves1[i][j + 1] == shelves2[i][j + 1]):\n                        if j == 0:\n                            if shelves_right[i][0] != shelves2[i][j + 1]:\n                                return False\n                        elif j == len(shelves1[i]) - 1:\n                            if shelves_left[i][j - 1] != shelves2[i][j - 1]:\n                                return False\n                        else:\n                            if shelves_left[i][j - 1] != shelves2[i][j - 1] or shelves_right[i][j] != shelves2[i][j + 1]:\n                                return False\n        return True\n\n    def move_left(shelf):\n        for j in range(len(shelf) - 1):\n            if shelf[j] == 0 and shelf[j + 1] != 0:\n                shelf[j] = shelf[j + 1]\n                shelf[j + 1] = 0\n                return True\n        return False\n\n    def move_right(shelf):\n        for j in range(len(shelf) - 1, 0, -1):\n            if shelf[j] == 0 and shelf[j - 1] != 0:\n                shelf[j] = shelf[j - 1]\n                shelf[j - 1] = 0\n                return True\n        return False\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    shelves1 = [list(map(int, lines[i + 1].split())) for i in range(N)]\n    shelves2 = [list(map(int, lines[N + i + 1].split())) for i in range(N)]\n\n    shelves_left = [[0] * M for _ in range(N)]\n    shelves_right = [[0] * M for _ in range(N)]\n    shelves_top = [0] * N\n    shelves_bottom = [M - 1] * N\n\n    for i in range(N):\n        for j in range(M - 1):\n            shelves_left[i][j + 1] = shelves1[i][j]\n            shelves_right[i][j] = shelves1[i][j + 1]\n\n    for i in range(N - 1):\n        shelves_top[i + 1] = shelves_bottom[i] + 1\n\n    if not is_solvable(shelves1, shelves2, shelves_left, shelves_right, shelves_top, shelves_bottom):\n        return -1\n\n    lifting = count_lifting(shelves1, shelves2)\n\n    for i in range(N):\n        while move_left(shelves1[i]):\n            lifting -= 1\n        while move_right(shelves1[i]):\n            lifting -= 1\n\n    return str(lifting)"
    },
    {
        "number": 3163,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(shelf: List[int]) -> bool:\n        for i in range(1, len(shelf)):\n            if shelf[i] != 0 and shelf[i] != shelf[i - 1] + 1:\n                return False\n        return True\n\n    def count_moves(initial: List[List[int]], final: List[List[int]]) -> int:\n        moves = 0\n        for i in range(len(initial)):\n            for j in range(len(initial[i])):\n                if initial[i][j] != final[i][j]:\n                    moves += 1\n        return moves // 2\n\n    def min_lifting(initial: List[List[int]], final: List[List[int]]) -> int:\n        queue = [(initial, 0)]\n        visited = set()\n\n        while queue:\n            state, lifting = queue.pop(0)\n            if tuple(tuple(row) for row in state) in visited:\n                continue\n            visited.add(tuple(tuple(row) for row in state))\n\n            if state == final:\n                return lifting\n\n            for i in range(len(state)):\n                for j in range(len(state[i])):\n                    if state[i][j] == 0:\n                        for k in range(len(state)):\n                            for l in range(len(state[k])):\n                                if state[k][l] != 0 and is_valid(state[k][:l] + [0] + state[k][l + 1:]) and (i, j) != (k, l) and (i, j) != (k, l - 1):\n                                    new_state = [row[:] for row in state]\n                                    new_state[k][l], new_state[i][j] = new_state[i][j], new_state[k][l]\n                                    queue.append((new_state, lifting + 1))\n\n        return -1\n\n    stdin = stdin.split('\\n')\n    N, M = map(int, stdin[0].split())\n    initial = [list(map(int, stdin[i + 1].split())) for i in range(N)]\n    final = [list(map(int, stdin[N + i + 1].split())) for i in range(N)]\n\n    return str(min_lifting(initial, final))"
    },
    {
        "number": 3163,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_moves(current_state, wanted_state):\n        moves = 0\n        for i in range(len(current_state)):\n            for j in range(len(current_state[i])):\n                if current_state[i][j] != wanted_state[i][j]:\n                    moves += 1\n        return moves\n\n    data = stdin.split('\\n')\n    N, M = map(int, data[0].split())\n    current_state = [list(map(int, line.split())) for line in data[1:N+1]]\n    wanted_state = [list(map(int, line.split())) for line in data[N+1:2*N+1]]\n\n    moves = count_moves(current_state, wanted_state)\n    if moves % 2 != 0:\n        return \"-1\"\n    return str(moves // 2)"
    },
    {
        "number": 3163,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def check_state(initial_state, final_state):\n        for i in range(len(initial_state)):\n            if initial_state[i] != final_state[i]:\n                return False\n        return True\n\n    def find_empty_place(shelf):\n        for i in range(len(shelf)):\n            if shelf[i] == 0:\n                return i\n        return -1\n\n    def count_moves(initial_state, final_state):\n        moves = 0\n        for i in range(len(initial_state)):\n            for j in range(len(initial_state[i])):\n                if initial_state[i][j] != final_state[i][j]:\n                    moves += 1\n        return moves // 2\n\n    def arrange_books(initial_state, final_state):\n        moves = 0\n        for i in range(len(initial_state)):\n            for j in range(len(initial_state[i])):\n                if initial_state[i][j] != final_state[i][j]:\n                    empty_place = find_empty_place(initial_state[i])\n                    if empty_place != -1:\n                        initial_state[i][empty_place], initial_state[i][j] = initial_state[i][j], initial_state[i][empty_place]\n                        moves += 1\n                    else:\n                        return -1\n        return moves\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n\n    initial_state = []\n    final_state = []\n    for i in range(1, N * 2 + 1, 2):\n        initial_state.append(list(map(int, lines[i].split())))\n        final_state.append(list(map(int, lines[i + 1].split())))\n\n    if check_state(initial_state, final_state):\n        return '0'\n\n    moves = count_moves(initial_state, final_state)\n    moves_to_arrange = arrange_books(initial_state, final_state)\n\n    if moves_to_arrange == -1:\n        return '-1'\n\n    return str(moves + moves_to_arrange)"
    },
    {
        "number": 3163,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_diff(shelf1, shelf2):\n        count = 0\n        for i in range(len(shelf1)):\n            if shelf1[i] != shelf2[i]:\n                count += 1\n        return count\n\n    def find_book(shelves, book):\n        for i, shelf in enumerate(shelves):\n            if book in shelf:\n                return i, shelf.index(book)\n        return None\n\n    def move_book(shelves, shelf1_idx, place1, shelf2_idx, place2):\n        book = shelves[shelf1_idx][place1]\n        shelves[shelf1_idx][place1] = 0\n        shelves[shelf2_idx][place2] = book\n\n    def move_books(shelves, shelf1_idx, shelf2_idx):\n        for i, book in enumerate(shelves[shelf1_idx]):\n            if book != 0:\n                if find_book(shelves, book) is None:\n                    return False\n        for i, book in enumerate(shelves[shelf1_idx]):\n            if book != 0:\n                shelf2_place = find_book(shelves, book)\n                move_book(shelves, shelf1_idx, i, shelf2_idx, shelf2_place)\n        return True\n\n    def solve(shelves):\n        min_lifting = 0\n        for i in range(len(shelves)):\n            for j in range(i + 1, len(shelves)):\n                if count_diff(shelves[i], shelves[j]) > 0:\n                    if not move_books(shelves, i, j):\n                        return -1\n                    min_lifting += 1\n        return min_lifting\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    shelves = []\n    for i in range(1, N + 1):\n        shelves.append(list(map(int, lines[i].split())))\n\n    final_shelves = []\n    for i in range(N + 1, 2 * N + 1):\n        final_shelves.append(list(map(int, lines[i].split())))\n\n    return str(solve(shelves))\n"
    },
    {
        "number": 3163,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    initial_state = [list(map(int, stdin.readline().split())) for _ in range(N)]\n    final_state = [list(map(int, stdin.readline().split())) for _ in range(N)]\n\n    def count_moves(initial, final):\n        moves = 0\n        for i in range(N):\n            for j in range(M):\n                if initial[i][j] != final[i][j]:\n                    moves += 1\n        return moves // 2\n\n    def is_valid(state):\n        for i in range(N):\n            for j in range(M - 1):\n                if state[i][j] > state[i][j + 1]:\n                    return False\n        return True\n\n    def find_book(state, book):\n        for i in range(N):\n            if book in state[i]:\n                return i, state[i].index(book)\n        return None\n\n    def move_left(state, i, j):\n        if j > 0 and state[i][j - 1] == 0:\n            state[i][j - 1] = state[i][j]\n            state[i][j] = 0\n            return True\n        return False\n\n    def move_right(state, i, j):\n        if j < M - 1 and state[i][j + 1] == 0:\n            state[i][j + 1] = state[i][j]\n            state[i][j] = 0\n            return True\n        return False\n\n    def move_book(state, from_i, from_j, to_i, to_j):\n        if state[from_i][from_j] == 0 or state[to_i][to_j] != 0:\n            return False\n        state[to_i][to_j] = state[from_i][from_j]\n        state[from_i][from_j] = 0\n        return True\n\n    def arrange_books(initial, final):\n        moves = 0\n        for i in range(N):\n            for j in range(M):\n                if initial[i][j] != final[i][j]:\n                    moves += 1\n                    if not move_book(initial, i, j, find_book(initial, final[i][j])[0], find_book(initial, final[i][j])[1]):\n                        return -1\n                    moves += count_moves(initial, final)\n                    if not is_valid(initial):\n                        return -1\n        return moves\n\n    return str(arrange_books(initial_state, final_state))"
    },
    {
        "number": 3163,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    initial_state = [list(map(int, stdin.readline().split())) for _ in range(N)]\n    final_state = [list(map(int, stdin.readline().split())) for _ in range(N)]\n\n    def is_valid(state):\n        book_count = {}\n        for shelf in state:\n            for book in shelf:\n                if book != 0:\n                    if book in book_count:\n                        return False\n                    book_count[book] = True\n        return True\n\n    def get_book_location(state, book):\n        for shelf_idx, shelf in enumerate(state):\n            for place_idx, place in enumerate(shelf):\n                if place == book:\n                    return shelf_idx, place_idx\n\n    def count_lifting(state, final_state):\n        lifting_count = 0\n        for i in range(N):\n            for j in range(M):\n                if state[i][j] != final_state[i][j]:\n                    lifting_count += 1\n        return lifting_count // 2\n\n    def move_right(state, shelf_idx, place_idx):\n        if place_idx < M - 1 and state[shelf_idx][place_idx + 1] == 0:\n            state[shelf_idx][place_idx], state[shelf_idx][place_idx + 1] = state[shelf_idx][place_idx + 1], state[shelf_idx][place_idx]\n            return True\n        return False\n\n    def move_left(state, shelf_idx, place_idx):\n        if place_idx > 0 and state[shelf_idx][place_idx - 1] == 0:\n            state[shelf_idx][place_idx], state[shelf_idx][place_idx - 1] = state[shelf_idx][place_idx - 1], state[shelf_idx][place_idx]\n            return True\n        return False\n\n    def swap_books(state, book1, book2):\n        shelf1, place1 = get_book_location(state, book1)\n        shelf2, place2 = get_book_location(state, book2)\n        state[shelf1][place1], state[shelf2][place2] = state[shelf2][place2], state[shelf1][place1]\n\n    def arrange_books(state, final_state):\n        if is_valid(state) and state == final_state:\n            return 0\n\n        for i in range(N):\n            for j in range(M):\n                if state[i][j] != final_state[i][j]:\n                    book1 = state[i][j]\n                    book2 = final_state[i][j]\n                    swap_books(state, book1, book2)\n                    if is_valid(state):\n                        return 1 + arrange_books(state, final_state)\n                    else:\n                        swap_books(state, book1, book2)\n\n                    for k in range(i, N):\n                        for l in range(M):\n                            if state[k][l] != final_state[k][l]:\n                                if move_right(state, k, l):\n                                    if is_valid(state):\n                                        return 1 + arrange_books(state, final_state)\n                                    else:\n                                        move_left(state, k, l)\n\n                                if move_left(state, k, l):\n                                    if is_valid(state):\n                                        return 1 + arrange_books(state, final_state)\n                                    else:\n                                        move_right(state, k, l)\n                    return -1\n\n    return str(arrange_books(initial_state, final_state))"
    },
    {
        "number": 3163,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    initial_state = []\n    final_state = []\n\n    for i in range(N):\n        initial_state.append(list(map(int, stdin.readline().split())))\n    for i in range(N):\n        final_state.append(list(map(int, stdin.readline().split())))\n\n    def count_lifting(state1, state2):\n        count = 0\n        for i in range(N):\n            for j in range(M):\n                if state1[i][j] != state2[i][j]:\n                    count += 1\n        return count // 2\n\n    def is_valid(state1, state2):\n        for i in range(N):\n            for j in range(M):\n                if state1[i][j] != state2[i][j] and state1[i][j] != 0:\n                    return False\n        return True\n\n    def find_path(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, depth = queue.pop(0)\n            if current == end:\n                return depth\n            if current not in visited:\n                visited.add(current)\n                queue.extend(((current + 1, depth + 1), (current - 1, depth + 1)) if 0 <= current < N else [])\n        return -1\n\n    def solve():\n        lifting_count = count_lifting(initial_state, final_state)\n        if not is_valid(initial_state, final_state):\n            return -1\n        for i in range(N):\n            for j in range(M):\n                if initial_state[i][j] != final_state[i][j]:\n                    initial_state[i][j], initial_state[i][final_state[i].index(final_state[i][j])] = initial_state[i][final_state[i].index(final_state[i][j])], initial_state[i][j]\n                    lifting_count += find_path(i * M + j, i * M + final_state[i].index(final_state[i][j]))\n        return lifting_count\n\n    return str(solve())"
    },
    {
        "number": 3163,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    initial_state = []\n    final_state = []\n\n    for _ in range(N):\n        initial_state.append(list(map(int, stdin.readline().split())))\n    for _ in range(N):\n        final_state.append(list(map(int, stdin.readline().split())))\n\n    def count_moves(from_shelf, to_shelf, book):\n        if book == 0:\n            return 0\n        moves = 0\n        for i, shelf in enumerate([from_shelf, to_shelf]):\n            for j, place in enumerate(shelf):\n                if place == book:\n                    if i == 0:\n                        moves += 1\n                    else:\n                        moves += 2\n        return moves\n\n    moves = 0\n    for i in range(N):\n        for j in range(M):\n            moves += count_moves(initial_state[i], final_state[i], j + 1)\n\n    return str(moves)"
    },
    {
        "number": 3164,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # read the input\n    N = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    # create a dictionary to store the frequency of each element\n    freq_dict = {}\n    for num in arr:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # find the longest sub-array so that each element appears exactly twice\n    max_length = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if arr[i] == arr[j]:\n                continue\n            if arr[i] + 1 == arr[j] and freq_dict[arr[i]] == 2 and freq_dict[arr[j]] == 2:\n                max_length = max(max_length, 2)\n            elif freq_dict[arr[i]] == 2 and freq_dict[arr[j]] == 2:\n                current_length = 2\n                for k in range(j + 1, N):\n                    if arr[k] == arr[k - 1] + 1:\n                        current_length += 1\n                        if freq_dict[arr[k]] == 2:\n                            max_length = max(max_length, current_length)\n                    else:\n                        break\n\n    return str(max_length)"
    },
    {
        "number": 3164,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i, n):\n            count = 0\n            for k in range(i, j + 1):\n                if arr[k] in freq and freq[arr[k]] == 2:\n                    count += 1\n            if count == (j - i + 1) and (j - i + 1) > max_length:\n                max_length = j - i + 1\n\n    return str(max_length)"
    },
    {
        "number": 3164,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    max_len = 0\n    for i in range(n):\n        for j in range(i, n):\n            nums = set(arr[i:j+1])\n            valid = True\n            for num in nums:\n                if freq[num] != 2:\n                    valid = False\n                    break\n            if valid:\n                max_len = max(max_len, len(nums))\n    return str(max_len)"
    },
    {
        "number": 3164,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n    \n    freq = {}\n    for i in arr:\n        if i not in freq:\n            freq[i] = 0\n        freq[i] += 1\n    \n    max_length = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] == arr[j]:\n                continue\n            if freq[arr[i]] == 2 and freq[arr[j]] == 2:\n                freq[arr[i]] -= 1\n                freq[arr[j]] -= 1\n                max_length = max(max_length, j-i+1)\n                freq[arr[i]] += 1\n                freq[arr[j]] += 1\n    \n    return str(max_length)"
    },
    {
        "number": 3164,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    arr = [int(x) for x in stdin.readline().strip().split()]\n    max_length = 0\n\n    # Create a dictionary to store the frequency of each element in the array\n    freq_dict = {}\n    for num in arr:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    # Iterate through the unique elements in the array\n    for key in freq_dict.keys():\n        # If the element appears exactly twice, check if we can find a sub-array with this element\n        if freq_dict[key] == 2:\n            # Create a new array with only the elements that appear twice\n            new_arr = [num for num in arr if num == key]\n            new_arr.extend([num for num in arr if num != key])\n\n            # Use sliding window to find the longest sub-array with this element\n            left, right = 0, 0\n            curr_length = 0\n            while right < len(new_arr):\n                if new_arr[right] == key:\n                    curr_length += 1\n                if curr_length == 2:\n                    max_length = max(max_length, right - left + 1)\n                    while new_arr[left] != key:\n                        left += 1\n                    left += 1\n                    curr_length -= 1\n                right += 1\n\n    return max_length"
    },
    {
        "number": 3164,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = list(map(int, stdin.split(\"\\n\")[1].split()))\n    freq = {}\n    max_len = 0\n    \n    for i in range(n):\n        if arr[i] in freq:\n            freq[arr[i]] += 1\n        else:\n            freq[arr[i]] = 1\n            \n    for key in freq:\n        if freq[key] == 2:\n            left, right = 0, 0\n            while left < n and right < n:\n                if arr[left] == key:\n                    arr[left] = -1\n                if arr[right] == key:\n                    arr[right] = -1\n                    \n                if left == right:\n                    right += 1\n                elif arr[left] == -1:\n                    left += 1\n                elif arr[right] == -1:\n                    right += 1\n                else:\n                    right += 1\n                    \n                max_len = max(max_len, right - left)\n                \n    return str(max_len)"
    },
    {
        "number": 3164,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    freq = {}\n    for num in arr:\n        if num not in freq:\n            freq[num] = 1\n        else:\n            freq[num] += 1\n\n    longest_subarray = 0\n    for num in freq:\n        if freq[num] == 2:\n            longest_subarray += 2\n        elif freq[num] > 2:\n            longest_subarray += freq[num] - 1\n\n    return str(longest_subarray)"
    },
    {
        "number": 3164,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    arr = list(map(int, stdin.split(\"\\n\")[1].split()))\n    \n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    max_len = 0\n    for num in freq:\n        if freq[num] == 2:\n            max_len += 1\n            if max_len > 1:\n                break\n    \n    return str(max_len)"
    },
    {
        "number": 3164,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    max_length = 0\n    start = 0\n    end = 0\n    current_length = 0\n\n    for i in range(n):\n        if freq[arr[i]] == 1:\n            current_length += 1\n        else:\n            freq[arr[i]] -= 1\n            current_length += 1\n\n        while freq[arr[i]] > 1:\n            freq[arr[start]] -= 1\n            freq[arr[start]] = max(0, freq[arr[start]])\n            start += 1\n            current_length -= 1\n\n        if current_length > max_length:\n            max_length = current_length\n            end = i\n\n    return max_length"
    },
    {
        "number": 3164,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_subarray(arr: List[int]) -> int:\n        num_set = set(arr)\n        num_dict = {}\n        max_length = 0\n\n        for num in arr:\n            if num in num_dict:\n                num_dict[num] += 1\n            else:\n                num_dict[num] = 1\n\n        for num in num_set:\n            if num_dict[num] == 2:\n                left, right = 0, 0\n                current_length = 0\n\n                while right < len(arr):\n                    if arr[right] == num:\n                        current_length += 1\n                        if current_length == 2:\n                            max_length = max(max_length, right - left + 1)\n                            while arr[left] != num:\n                                left += 1\n                            left += 1\n                            current_length -= 1\n                    right += 1\n\n        return max_length\n\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    arr = input_list[1:]\n\n    return str(find_longest_subarray(arr))"
    },
    {
        "number": 3165,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def is_attacked(board: list, row: int, col: int, rooks: list) -> bool:\n        power = rooks[row][col]\n        for i in range(len(board[row])):\n            if i != col and rooks[row][i] != 0:\n                power = xor(power, rooks[row][i])\n        for j in range(len(board)):\n            if j != row and rooks[j][col] != 0:\n                power = xor(power, rooks[j][col])\n        return power > 0\n\n    def count_attacked_fields(board: list, rooks: list) -> int:\n        count = 0\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                if is_attacked(board, i, j, rooks):\n                    count += 1\n        return count\n\n    lines = stdin.split(\"\\n\")\n    N, K, P = map(int, lines[0].split())\n    board = [[0] * N for _ in range(N)]\n    rooks = [[0] * N for _ in range(N)]\n\n    for i in range(1, K + 1):\n        R, C, X = map(int, lines[i].split())\n        rooks[R - 1][C - 1] = X\n\n    for i in range(K + 1, K + 1 + P):\n        R1, C1, R2, C2 = map(int, lines[i].split())\n        board[R1 - 1][C1 - 1] = rooks[R1 - 1][C1 - 1]\n        rooks[R1 - 1][C1 - 1] = 0\n        board[R2 - 1][C2 - 1] = rooks[R2 - 1][C2 - 1]\n        rooks[R2 - 1][C2 - 1] = X\n\n        attacked_fields = count_attacked_fields(board, rooks)\n        print(attacked_fields)"
    },
    {
        "number": 3165,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.readline().split())\n    rooks = []\n    for _ in range(K):\n        R, C, X = map(int, stdin.readline().split())\n        rooks.append((R - 1, C - 1, X))\n    \n    def count_attacked_fields(rooks, N):\n        attacked = [[0] * N for _ in range(N)]\n        for r, c, x in rooks:\n            for i in range(N):\n                if i != c:\n                    attacked[r][i] ^= x\n            for j in range(N):\n                if j != r:\n                    attacked[j][c] ^= x\n        return sum(1 for row in attacked for cell in row if cell > 0)\n\n    results = []\n    for _ in range(P):\n        R1, C1, R2, C2 = map(int, stdin.readline().split())\n        for i, (r, c, x) in enumerate(rooks):\n            if r == R1 - 1 and c == C1 - 1:\n                rooks[i] = (R2 - 1, C2 - 1, x)\n                break\n        \n        results.append(count_attacked_fields(rooks, N))\n\n    return \"\\n\".join(map(str, results))"
    },
    {
        "number": 3165,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a, b):\n        return a ^ b\n\n    def is_attacked(board, row, col):\n        count = 0\n        for i in range(N):\n            if i != row and board[i][col] > 0:\n                count += 1\n        for j in range(N):\n            if j != col and board[row][j] > 0:\n                count += 1\n        return count > 0\n\n    def count_attacked_fields(board):\n        count = 0\n        for i in range(N):\n            for j in range(N):\n                if is_attacked(board, i, j):\n                    count += 1\n        return count\n\n    lines = stdin.split(\"\\n\")\n    N, K, P = map(int, lines[0].split())\n    board = [[0 for _ in range(N)] for _ in range(N)]\n\n    for i in range(K):\n        R, C, X = map(int, lines[i + 1].split())\n        board[R - 1][C - 1] = X\n\n    output = []\n    for i in range(P):\n        R1, C1, R2, C2 = map(int, lines[K + i + 1].split())\n        board[R1 - 1][C1 - 1] = 0\n        board[R2 - 1][C2 - 1] = 1\n        output.append(count_attacked_fields(board))\n\n    return \"\\n\".join(map(str, output))"
    },
    {
        "number": 3165,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a, b):\n        return a ^ b\n\n    def count_attacked_fields(rooks):\n        attacked_fields = {}\n        for (row, col, power) in rooks:\n            for i in range(1, N + 1):\n                if i != row:\n                    attacked_fields[i] = {} if i not in attacked_fields else attacked_fields[i]\n                    attacked_fields[i][col] = xor(attacked_fields[i].get(col, 0), power)\n                if i != col:\n                    attacked_fields[row] = {} if row not in attacked_fields else attacked_fields[row]\n                    attacked_fields[row][i] = xor(attacked_fields[row].get(i, 0), power)\n        count = 0\n        for row in attacked_fields:\n            for col in attacked_fields[row]:\n                if attacked_fields[row][col] > 0:\n                    count += 1\n        return count\n\n    lines = stdin.strip().split('\\n')\n    N, K, P = map(int, lines[0].split())\n    rooks = []\n    for i in range(1, K + 1):\n        R, C, X = map(int, lines[i].split())\n        rooks.append((R, C, X))\n\n    for i in range(K + 1, K + P + 1):\n        R1, C1, R2, C2 = map(int, lines[i].split())\n        for j, (row, col, power) in enumerate(rooks):\n            if row == R1 and col == C1:\n                rooks[j] = (R2, C2, power)\n                break\n\n    attacked_fields_count = [count_attacked_fields(rooks[:i]) for i in range(1, K + P + 1)]\n    return '\\n'.join(map(str, attacked_fields_count))\n"
    },
    {
        "number": 3165,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a, b):\n        return a ^ b\n\n    def is_attacked(board, row, col, rooks):\n        attacked = False\n        for i in range(len(board)):\n            if board[row][i] != -1 and (row, i) not in rooks:\n                attacked = xor(board[row][i], attacked)\n            if board[i][col] != -1 and (i, col) not in rooks:\n                attacked = xor(board[i][col], attacked)\n        return attacked\n\n    def move_rook(board, rooks, row1, col1, row2, col2):\n        power = board[row1][col1]\n        board[row1][col1] = -1\n        board[row2][col2] = power\n        rooks.remove((row1, col1))\n        rooks.add((row2, col2))\n\n    lines = stdin.split('\\n')\n    N, K, P = map(int, lines[0].split())\n    board = [[-1] * N for _ in range(N)]\n    rooks = set()\n\n    for i in range(1, K + 1):\n        R, C, X = map(int, lines[i].split())\n        board[R - 1][C - 1] = X\n        rooks.add((R - 1, C - 1))\n\n    result = []\n    for i in range(K + 1, K + P + 1):\n        R1, C1, R2, C2 = map(int, lines[i].split())\n        move_rook(board, rooks, R1 - 1, C1 - 1, R2 - 1, C2 - 1)\n        attacked_fields = sum([is_attacked(board, r, c, rooks) for r in range(N) for c in range(N)])\n        result.append(attacked_fields)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3165,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_attacked(row, col, rooks):\n        xor_sum = 0\n        for r, c, power in rooks:\n            if r == row or c == col:\n                xor_sum ^= power\n        return xor_sum > 0\n\n    def count_attacked_fields(rooks):\n        count = 0\n        for row in range(N):\n            for col in range(N):\n                if is_attacked(row, col, rooks):\n                    count += 1\n        return count\n\n    def update_rooks(rooks, move):\n        src_row, src_col, dst_row, dst_col = move\n        for i, (row, col, power) in enumerate(rooks):\n            if row == src_row and col == src_col:\n                rooks[i] = (dst_row, dst_col, power)\n                break\n        return rooks\n\n    lines = stdin.split(\"\\n\")\n    N, K, P = map(int, lines[0].split())\n    rooks = []\n    for i in range(1, K + 1):\n        R, C, X = map(int, lines[i].split())\n        rooks.append((R, C, X))\n\n    for i in range(K + 1, K + 1 + P):\n        move = list(map(int, lines[i].split()))\n        rooks = update_rooks(rooks, move)\n        print(count_attacked_fields(rooks))"
    },
    {
        "number": 3165,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def is_attacked(board: List[List[int]], row: int, col: int) -> bool:\n        count = 0\n        for i in range(N):\n            if i != row:\n                count = xor(count, board[i][col])\n        for j in range(N):\n            if j != col:\n                count = xor(count, board[row][j])\n        return count > 0\n\n    def move_rook(board: List[List[int]], from_row: int, from_col: int, to_row: int, to_col: int) -> None:\n        board[to_row][to_col] = board[from_row][from_col]\n        board[from_row][from_col] = 0\n\n    lines = stdin.split('\\n')\n    N, K, P = map(int, lines[0].split())\n    board = [[0] * N for _ in range(N)]\n\n    for i in range(1, K + 1):\n        R, C, X = map(int, lines[i].split())\n        board[R - 1][C - 1] = X\n\n    for i in range(K + 1, K + P + 1):\n        R1, C1, R2, C2 = map(int, lines[i].split())\n        move_rook(board, R1 - 1, C1 - 1, R2 - 1, C2 - 1)\n\n        count = 0\n        for j in range(N):\n            for k in range(N):\n                if is_attacked(board, j, k):\n                    count += 1\n\n        print(count)"
    },
    {
        "number": 3165,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, K, P = map(int, lines[0].split())\n    board = [[0] * N for _ in range(N)]\n    rooks = []\n\n    for i in range(K):\n        R, C, X = map(int, lines[i + 1].split())\n        rooks.append([R - 1, C - 1, X])\n        board[R - 1][C - 1] = X\n\n    for i in range(P):\n        R1, C1, R2, C2 = map(int, lines[K + i + 1].split())\n        X = board[R1 - 1][C1 - 1]\n        board[R1 - 1][C1 - 1] = 0\n        board[R2 - 1][C2 - 1] = X\n\n    def count_attacked_fields(board):\n        attacked_fields = 0\n        for i in range(N):\n            for j in range(N):\n                if board[i][j] == 0:\n                    continue\n                for rook in rooks:\n                    if rook[0] == i or rook[1] == j:\n                        continue\n                    board[rook[0]][rook[1]] ^= rook[2]\n                if bin(board[i][j]).count('1') > 0:\n                    attacked_fields += 1\n                for rook in rooks:\n                    if rook[0] == i or rook[1] == j:\n                        continue\n                    board[rook[0]][rook[1]] ^= rook[2]\n        return attacked_fields\n\n    result = []\n    for _ in range(P):\n        result.append(count_attacked_fields(board))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3165,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def check_attacked(board: list, row: int, col: int, power: int) -> int:\n        count = 0\n        for i in range(len(board)):\n            if i != row and board[i][col] != -1:\n                count += board[i][col] ^ power\n        for j in range(len(board[0])):\n            if j != col and board[row][j] != -1:\n                count += board[row][j] ^ power\n        return count > 0\n\n    def move_rook(board: list, from_row: int, from_col: int, to_row: int, to_col: int) -> None:\n        power = board[from_row][from_col]\n        board[from_row][from_col] = -1\n        board[to_row][to_col] = power\n\n    def count_attacked_fields(board: list) -> int:\n        count = 0\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] != -1 and check_attacked(board, i, j, board[i][j]):\n                    count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    N, K, P = map(int, lines[0].split())\n    board = [[-1] * N for _ in range(N)]\n\n    for i in range(1, K + 1):\n        R, C, X = map(int, lines[i].split())\n        board[R - 1][C - 1] = X\n\n    result = []\n    for i in range(K + 1, K + P + 1):\n        R1, C1, R2, C2 = map(int, lines[i].split())\n        move_rook(board, R1 - 1, C1 - 1, R2 - 1, C2 - 1)\n        result.append(count_attacked_fields(board))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3165,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a, b):\n        return a ^ b\n\n    def is_attacked(board, row, col):\n        count = 0\n        for i in range(N):\n            if board[row][i] > 0:\n                count += board[row][i]\n        for j in range(N):\n            if board[j][col] > 0:\n                count += board[j][col]\n        return count > 0\n\n    def count_attacked(board):\n        count = 0\n        for i in range(N):\n            for j in range(N):\n                if is_attacked(board, i, j):\n                    count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    N, K, P = map(int, lines[0].split())\n    board = [[0 for _ in range(N)] for _ in range(N)]\n    rooks = []\n\n    for i in range(K):\n        R, C, X = map(int, lines[1 + i].split())\n        rooks.append((R - 1, C - 1, X))\n\n    for rook in rooks:\n        board[rook[0]][rook[1]] = rook[2]\n\n    for i in range(P):\n        R1, C1, R2, C2 = map(int, lines[1 + K + i].split())\n        board[R1 - 1][C1 - 1] = 0\n        board[R2 - 1][C2 - 1] = rooks[R1 - 1][2]\n\n    return '\\n'.join(str(count_attacked(board)) for _ in range(P))"
    },
    {
        "number": 3166,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_fair(beats):\n        n = len(beats)\n        for i in range(n):\n            for j in range(n):\n                if beats[i][j] and beats[j][i]:\n                    return False\n        return True\n\n    def find_min_disqualifications(beats, disqualified):\n        n = len(beats)\n        min_disqualifications = n\n\n        for i in range(n):\n            if i in disqualified:\n                continue\n            new_beats = [beats[j] for j in range(n) if j != i]\n            if is_fair(new_beats):\n                min_disqualifications = min(min_disqualifications, n - len(new_beats))\n\n        return min_disqualifications\n\n    lines = stdin.splitlines()\n    n, k = map(int, lines[0].split())\n    beats = [[int(x) for x in line.split()] for line in lines[1:n+1]]\n    disqualified = set(map(int, lines[-1].split()))\n\n    min_disqualifications = find_min_disqualifications(beats, disqualified)\n\n    if min_disqualifications < k:\n        return min_disqualifications\n    else:\n        return \"impossible\""
    },
    {
        "number": 3166,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(candidate, disqualified):\n        for p in candidate:\n            if p in disqualified:\n                return False\n        return True\n\n    def find_smallest_disqualification(matrix, disqualified):\n        n = len(matrix)\n        candidates = set(range(n)) - set(disqualified)\n        min_size = len(disqualified)\n\n        for size in range(min_size, 0, -1):\n            for candidate in itertools.combinations(candidates, size):\n                if is_valid(candidate, disqualified):\n                    return size\n\n        return \"impossible\"\n\n    lines = stdin.splitlines()\n    n, k = map(int, lines[0].split())\n    matrix = [list(map(int, line.split())) for line in lines[1:n + 1]]\n    disqualified = list(map(int, lines[-1].split()))\n\n    return str(find_smallest_disqualification(matrix, disqualified))"
    },
    {
        "number": 3166,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_fair(rankings):\n        for i in range(len(rankings)):\n            for j in range(len(rankings)):\n                if rankings[i][j] and rankings[j][i]:\n                    return False\n        return True\n\n    def find_fair_set(remaining_players, disqualified_players):\n        if not remaining_players:\n            return []\n\n        for i in range(len(remaining_players)):\n            new_remaining_players = remaining_players[:i] + remaining_players[i + 1:]\n            for j in range(len(disqualified_players)):\n                new_disqualified_players = disqualified_players[:j] + disqualified_players[j + 1:]\n                new_rankings = [row[:i] + row[i + 1:] for row in rankings]\n                new_rankings = [col[:j] + col[j + 1:] for col in new_rankings]\n                if is_fair(new_rankings):\n                    return [disqualified_players[j]] + find_fair_set(new_remaining_players, new_disqualified_players)\n        return \"impossible\"\n\n    lines = stdin.split('\\n')\n    n, k = map(int, lines[0].split())\n    rankings = [[int(x) for x in line.split()] for line in lines[1:n + 1]]\n    disqualified_players = list(map(int, lines[n + 1].split()))\n    remaining_players = [i for i in range(n) if i not in disqualified_players]\n\n    result = find_fair_set(remaining_players, disqualified_players)\n    if result == \"impossible\":\n        return result\n    else:\n        return len(result)"
    },
    {
        "number": 3166,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.strip().split('\\n')\n        n, k = map(int, lines[0].split())\n        matches = [list(map(int, line.split())) for line in lines[1:n]]\n        disqualified = set(map(int, lines[n].split()))\n        return n, k, matches, disqualified\n\n    def is_fair(matches: list, disqualified: set) -> bool:\n        n = len(matches)\n        for i in range(n):\n            if i in disqualified:\n                continue\n            for j in range(n):\n                if j in disqualified:\n                    continue\n                if matches[i][j] == 1 and matches[j][i] == 1:\n                    return False\n        return True\n\n    def find_min_disqualification(matches: list, disqualified: set) -> int:\n        n = len(matches)\n        min_disqualification = float('inf')\n\n        for i in range(n):\n            if i not in disqualified:\n                continue\n            temp_disqualified = disqualified.copy()\n            temp_disqualified.remove(i)\n            if is_fair(matches, temp_disqualified):\n                min_disqualification = min(min_disqualification, len(temp_disqualified))\n\n        return min_disqualification if min_disqualification != float('inf') else 'impossible'\n\n    n, k, matches, disqualified = read_input(stdin)\n    return find_min_disqualification(matches, disqualified)"
    },
    {
        "number": 3166,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_fair(beat_matrix, k, s):\n        n = len(beat_matrix)\n        beat_graph = [[] for _ in range(n)]\n\n        for i in range(n):\n            for j in range(n):\n                if beat_matrix[i][j] == 1 and j not in s:\n                    beat_graph[i].append(j)\n\n        visited = [False] * n\n        ranking = []\n\n        def dfs(node, visited, ranking):\n            if visited[node]:\n                return False\n            visited[node] = True\n            for neighbor in beat_graph[node]:\n                if not dfs(neighbor, visited, ranking):\n                    return False\n            ranking.append(node)\n            return True\n\n        for i in range(n):\n            if i not in s:\n                if not dfs(i, visited, ranking):\n                    return False\n\n        return True\n\n    def find_min_disqualified(beat_matrix, k, s):\n        n = len(beat_matrix)\n        for size in range(k - 1, 0, -1):\n            for s_prime in itertools.combinations(s, size):\n                if is_fair(beat_matrix, k, s_prime):\n                    return size\n        return \"impossible\"\n\n    def process_input(stdin: str) -> tuple:\n        lines = stdin.split(\"\\n\")\n        n, k = map(int, lines[0].split())\n        beat_matrix = []\n        for i in range(1, n + 1):\n            beat_matrix.append(list(map(int, lines[i].split()[:n])))\n        s = list(map(int, lines[-1].split()))\n        return beat_matrix, k, s\n\n    beat_matrix, k, s = process_input(stdin)\n    return str(find_min_disqualified(beat_matrix, k, s))"
    },
    {
        "number": 3166,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_fair(beats):\n        n = len(beats)\n        for i in range(n):\n            for j in range(n):\n                if beats[i][j] and beats[j][i]:\n                    return False\n        return True\n\n    def find_min_disqualified(beats, disqualified):\n        n = len(beats)\n        min_disqualified = n\n        for i in range(2**n):\n            binary = bin(i)[2:].zfill(n)\n            current_disqualified = [j for j in range(n) if binary[j] == '1']\n            if all(disqualified[j] not in current_disqualified for j in range(len(disqualified))) and is_fair(beats):\n                min_disqualified = min(min_disqualified, binary.count('1'))\n        return min_disqualified\n\n    input_data = [line.strip().split() for line in stdin.split('\\n')]\n    n, k = map(int, input_data[0])\n    beats = [[int(x) for x in line] for line in input_data[1:n + 1]]\n    disqualified = [int(x) for x in input_data[n + 1]]\n\n    if is_fair(beats):\n        return \"impossible\"\n    else:\n        return find_min_disqualified(beats, disqualified)"
    },
    {
        "number": 3166,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_fair(beat_matrix, disqualified_players):\n        n = len(beat_matrix)\n        fair = [True] * n\n\n        for i in disqualified_players:\n            fair[i] = False\n\n        for i in range(n):\n            for j in range(n):\n                if fair[i] and not fair[j] and beat_matrix[i][j]:\n                    return False\n\n        return True\n\n    def find_smallest_disqualification(beat_matrix, disqualified_players):\n        n = len(beat_matrix)\n        min_disqualifications = n\n        for i in range(1, 2**n):\n            binary = bin(i)[2:].zfill(n)\n            disqualified = [j for j in range(n) if binary[j] == '1']\n            if is_fair(beat_matrix, disqualified):\n                min_disqualifications = min(min_disqualifications, len(disqualified))\n\n        return min_disqualifications if min_disqualifications < n else \"impossible\"\n\n    stdin_list = stdin.split('\\n')\n    n, k = map(int, stdin_list[0].split())\n    beat_matrix = [list(map(int, stdin_list[i+1].split())) for i in range(n)]\n    disqualified_players = list(map(int, stdin_list[n+1].split()))\n\n    return str(find_smallest_disqualification(beat_matrix, disqualified_players))"
    },
    {
        "number": 3166,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_fair(beats, disqualified):\n        n = len(beats)\n        for i in range(n):\n            if i not in disqualified:\n                for j in range(n):\n                    if j != i and j not in disqualified:\n                        if beats[i][j] == 1 and beats[j][i] == 1:\n                            return False\n        return True\n\n    def find_min_disqualifications(beats, k):\n        n = len(beats)\n        min_disqualifications = n\n        for i in range(2 ** n):\n            disqualified = []\n            for j in range(n):\n                if (i >> j) & 1:\n                    disqualified.append(j)\n            if len(disqualified) >= k:\n                continue\n            if is_fair(beats, disqualified):\n                min_disqualifications = min(min_disqualifications, len(disqualified))\n        return min_disqualifications\n\n    input_lines = stdin.strip().split('\\n')\n    n, k = map(int, input_lines[0].split())\n    beats = [[int(x) for x in line.split()] for line in input_lines[1:n]]\n    disqualified = set(map(int, input_lines[-1].split()))\n\n    min_disqualifications = find_min_disqualifications(beats, k)\n    if min_disqualifications < k:\n        return str(min_disqualifications)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3166,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_fair(beat_matrix, removed_players):\n        n = len(beat_matrix)\n        for i in range(n):\n            if i not in removed_players:\n                for j in range(n):\n                    if j not in removed_players:\n                        if beat_matrix[i][j] == 1 and beat_matrix[j][i] == 1:\n                            return False\n        return True\n\n    def find_min_disqualified(beat_matrix, n, k, disqualified_players):\n        removed_players = set(disqualified_players)\n        min_size = k\n\n        for i in range(n):\n            if i not in removed_players:\n                for j in range(i + 1, n):\n                    if j not in removed_players:\n                        removed_players_temp = removed_players.copy()\n                        removed_players_temp.add(i)\n                        removed_players_temp.add(j)\n                        if is_fair(beat_matrix, removed_players_temp):\n                            min_size = min(min_size, len(removed_players_temp))\n\n        return min_size if min_size < k else \"impossible\"\n\n    lines = stdin.strip().split('\\n')\n    n, k = map(int, lines[0].split())\n    beat_matrix = [list(map(int, line.split())) for line in lines[1:n + 1]]\n    disqualified_players = list(map(int, lines[-1].split()))\n\n    return find_min_disqualified(beat_matrix, n, k, disqualified_players)"
    },
    {
        "number": 3166,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_fair(rankings, n, k, s):\n        for i in range(n - k):\n            if i not in s:\n                for j in range(i + 1, n):\n                    if j not in s:\n                        if rankings[i][j] and not rankings[j][i]:\n                            return False\n        return True\n\n    def find_smallest_s(rankings, n, k, s):\n        for i in range(n - k):\n            if i not in s:\n                new_s = set(s)\n                new_s.add(i)\n                if is_fair(rankings, n, k, new_s):\n                    return len(new_s)\n        return \"impossible\"\n\n    lines = stdin.split('\\n')\n    n, k = map(int, lines[0].split())\n    rankings = [[int(x) for x in line.split()] for line in lines[1:n + 1]]\n    s = set(map(int, lines[n + 1].split()))\n\n    return str(find_smallest_s(rankings, n, k, s))"
    },
    {
        "number": 3167,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, Xs, LRs, Q = parse_input(stdin)\n    seq = [0] * N\n    for X in Xs:\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += X\n    return \"\\n\".join(str(sum(seq[L:R+1])) for L, R in LRs)\n\ndef"
    },
    {
        "number": 3167,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def something(jump: int) -> None:\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += jump\n\n    def check_sum(left: int, right: int) -> int:\n        return sum(seq[left:right + 1])\n\n    N, K = map(int, stdin.split('\\n')[0].split())\n    X = list(map(int, stdin.split('\\n')[1].split()))\n    Q = int(stdin.split('\\n')[2])\n    LR = [list(map(int, stdin.split('\\n')[i + 3].split())) for i in range(Q)]\n\n    seq = [0] * N\n\n    for jump in X:\n        something(jump)\n\n    return '\\n'.join(str(check_sum(L, R)) for L, R in LR)"
    },
    {
        "number": 3167,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    X = list(map(int, stdin.readline().split()))\n    Q = int(stdin.readline())\n    L_R = [list(map(int, stdin.readline().split())) for _ in range(Q)]\n\n    seq = [0] * N\n    for jump in X:\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += jump\n\n    return \"\\n\".join(str(seq[L:R+1].sum()) for L, R in L_R)"
    },
    {
        "number": 3167,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    X = list(map(int, stdin.readline().split()))\n    Q = int(stdin.readline())\n    LR = [list(map(int, stdin.readline().split())) for _ in range(Q)]\n\n    seq = [0] * N\n\n    def something(jump: int):\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += jump\n\n    for x in X:\n        something(x)\n\n    return \"\\n\".join(str(sum(seq[L:R + 1])) for L, R in LR)"
    },
    {
        "number": 3167,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    N, K, X, Q, L, R = map(int, stdin.split())\n    seq = [0] * N\n    \n    # Call the 'something' function K times\n    for jump in X:\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += jump\n    \n    # Calculate the sum of elements between L and R\n    results = []\n    for i in range(Q):\n        result = sum(seq[L[i]:R[i] + 1])\n        results.append(str(result))\n    \n    # Return the output\n    return \"\\n\".join(results)"
    },
    {
        "number": 3167,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    seq = [0] * N\n    X = list(map(int, stdin.split()[2:2 + K]))\n    for i in range(K):\n        jump = X[i]\n        for j in range(0, N, jump):\n            seq[j] += 1\n    Q = int(stdin.split()[-2])\n    result = []\n    for i in range(Q):\n        L, R = map(int, stdin.split()[2 + K + i * 2:2 + K + i * 2 + 2])\n        result.append(sum(seq[L:R + 1]))\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3167,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def something(jump):\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += jump\n\n    N, K = map(int, stdin.readline().split())\n    X = list(map(int, stdin.readline().split()))\n    Q = int(stdin.readline())\n    L_R = [list(map(int, stdin.readline().split())) for _ in range(Q)]\n\n    seq = [0] * N\n    for k in range(K):\n        something(X[k])\n\n    return '\\n'.join(str(sum(seq[L:R + 1])) for L, R in L_R)"
    },
    {
        "number": 3167,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    X = list(map(int, stdin.readline().split()))\n    seq = [0] * N\n\n    for jump in X:\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += jump\n\n    Q = int(stdin.readline())\n    output = []\n\n    for _ in range(Q):\n        L, R = map(int, stdin.readline().split())\n        output.append(sum(seq[L:R + 1]))\n\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3167,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def something(jump):\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += jump\n\n    input_list = list(map(int, stdin.strip().split()))\n    N, K = input_list[0], input_list[1]\n    X = input_list[2:2+K]\n    Q = input_list[-1]\n    L_R = [input_list[2+K+i:2+K+i+2] for i in range(Q)]\n\n    seq = [0] * N\n    for jump in X:\n        something(jump)\n\n    output_list = [sum(seq[L:R+1]) for L, R in L_R]\n    return \"\\n\".join(map(str, output_list))"
    },
    {
        "number": 3167,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    X = list(map(int, stdin.readline().split()))\n    Q = int(stdin.readline())\n    L_R = [list(map(int, stdin.readline().split())) for _ in range(Q)]\n\n    seq = [0] * N\n\n    for jump in X:\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += jump\n\n    return \"\\n\".join(str(sum(seq[L:R+1])) for L, R in L_R)"
    },
    {
        "number": 3168,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def insert(node, y, depth):\n        nonlocal counter\n        if node is None:\n            counter += depth\n            return TreeNode(y)\n        if y < node.val:\n            node.left = insert(node.left, y, depth + 1)\n        else:\n            node.right = insert(node.right, y, depth + 1)\n        return node\n\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    sequence = [int(line) for line in lines[1:]]\n\n    root = None\n    counter = 0\n    for num in sequence:\n        root = insert(root, num, 0)\n        print(counter)"
    },
    {
        "number": 3168,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def insert(root, node, depth):\n        if not root:\n            return node, depth + 1\n        if node.val < root.val:\n            root.left, depth = insert(root.left, node, depth + 1)\n        else:\n            root.right, depth = insert(root.right, node, depth + 1)\n        return root, depth\n\n    N = int(stdin.splitlines()[0])\n    seq = [int(x) for x in stdin.splitlines()[1:]]\n    root = None\n    counter = 0\n    depth = 0\n    for num in seq:\n        node = TreeNode(num)\n        root, depth = insert(root, node, depth)\n        counter += depth\n        print(counter)\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right"
    },
    {
        "number": 3168,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def insert(root, y):\n        nonlocal counter\n        if root is None:\n            return Node(y)\n        if y < root.value:\n            root.left = insert(root.left, y)\n        else:\n            root.right = insert(root.right, y)\n        counter += depth(root.left) + 1\n        return root\n\n    def depth(node):\n        if node is None:\n            return 0\n        return 1 + max(depth(node.left), depth(node.right))\n\n    N = int(stdin.readline())\n    sequence = [int(stdin.readline()) for _ in range(N)]\n\n    counter = 0\n    root = None\n    result = []\n    for y in sequence:\n        root = insert(root, y)\n        result.append(counter)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3168,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def insert(x: int, node: TreeNode) -> int:\n        nonlocal counter\n        if node is None:\n            return TreeNode(x)\n        if x < node.val:\n            node.left = insert(x, node.left)\n            counter += 1\n        else:\n            node.right = insert(x, node.right)\n            counter += node.size\n        node.size += 1\n        return node\n\n    N = int(stdin.readline().strip())\n    root = None\n    counter = 0\n    for i in range(N):\n        num = int(stdin.readline().strip())\n        root = insert(num, root)\n        print(counter)\n\nclass TreeNode:\n    def __init__(self, val: int, left: TreeNode = None, right: TreeNode = None) -> None:\n        self.val = val\n        self.left = left\n        self.right = right\n        self.size = 1"
    },
    {
        "number": 3168,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1:]))\n\n    class Node:\n        def __init__(self, value):\n            self.value = value\n            self.left = None\n            self.right = None\n            self.depth = 0\n\n    def insert(node, value):\n        if node is None:\n            return Node(value)\n\n        if value < node.value:\n            node.left = insert(node.left, value)\n        else:\n            node.right = insert(node.right, value)\n\n        if node.left is not None:\n            node.left.depth = node.depth + 1\n        if node.right is not None:\n            node.right.depth = node.depth + 1\n\n        return node\n\n    root = None\n    counter = 0\n    result = []\n\n    for number in numbers:\n        root = insert(root, number)\n        if number == numbers[0]:\n            counter = 0\n        else:\n            counter += root.left.depth + root.right.depth\n        result.append(counter)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3168,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def insert(node, y):\n        nonlocal C\n        if node is None:\n            return TreeNode(y, depth=0)\n        if y == node.val:\n            return node\n        if y < node.val:\n            node.left = insert(node.left, y)\n        else:\n            node.right = insert(node.right, y)\n        node.depth = max(node.left.depth if node.left else 0, node.right.depth if node.right else 0) + 1\n        C += node.depth\n        return node\n\n    class TreeNode:\n        def __init__(self, val, depth=0, left=None, right=None):\n            self.val = val\n            self.depth = depth\n            self.left = left\n            self.right = right\n\n    N = int(stdin.readline().strip())\n    root = None\n    C = 0\n    for i in range(N):\n        x = int(stdin.readline().strip())\n        root = insert(root, x)\n        yield C"
    },
    {
        "number": 3168,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def insert(node, y, depth):\n        if node is None:\n            return TreeNode(y, depth)\n        if y < node.val:\n            node.left = insert(node.left, y, depth + 1)\n        else:\n            node.right = insert(node.right, y, depth + 1)\n        node.size = 1 + (node.left.size if node.left else 0) + (node.right.size if node.right else 0)\n        return node\n\n    class TreeNode:\n        def __init__(self, val, depth):\n            self.val = val\n            self.left = None\n            self.right = None\n            self.size = 1\n            self.depth = depth\n\n    N = int(stdin.split('\\n', 1)[0])\n    sequence = list(map(int, stdin.split('\\n')[1:]))\n    root = None\n    counter = 0\n    output = []\n\n    for num in sequence:\n        root = insert(root, num, 0)\n        counter += root.depth\n        output.append(counter)\n\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3168,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def insert_node(root: TreeNode, value: int) -> int:\n        if not root:\n            return TreeNode(value)\n        if value < root.value:\n            root.left = insert_node(root.left, value)\n        else:\n            root.right = insert_node(root.right, value)\n        return root\n\n    def get_depth(node: TreeNode, depth: int) -> int:\n        if not node:\n            return 0\n        left_depth = get_depth(node.left, depth + 1)\n        right_depth = get_depth(node.right, depth + 1)\n        return max(left_depth, right_depth, depth)\n\n    class TreeNode:\n        def __init__(self, value: int):\n            self.value = value\n            self.left = None\n            self.right = None\n\n    N = int(stdin.readline().strip())\n    root = None\n    counter = 0\n    for i in range(N):\n        value = int(stdin.readline().strip())\n        root = insert_node(root, value)\n        counter += get_depth(root, 0)\n        print(counter)"
    },
    {
        "number": 3168,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = list(map(int, stdin.split('\\n')[1:]))\n\n    class Node:\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n        def insert(self, value) -> int:\n            nonlocal depth\n            depth += 1\n            if value < self.value:\n                if self.left is None:\n                    self.left = Node(value)\n                else:\n                    self.left.insert(value)\n            else:\n                if self.right is None:\n                    self.right = Node(value)\n                else:\n                    self.right.insert(value)\n            return depth\n\n    root = Node(sequence[0])\n    depth = 0\n    result = [depth]\n\n    for i in range(1, n):\n        depth = 0\n        result.append(root.insert(sequence[i]))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3168,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    sequence = [int(x) for x in stdin.readlines()]\n\n    class Node:\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n        def insert(self, value):\n            if value < self.value:\n                if self.left is None:\n                    self.left = Node(value)\n                else:\n                    self.left.insert(value)\n            else:\n                if self.right is None:\n                    self.right = Node(value)\n                else:\n                    self.right.insert(value)\n\n    root = Node(sequence[0])\n    counter = 0\n    result = []\n\n    for i in range(1, n):\n        root.insert(sequence[i])\n        counter += i\n        result.append(counter)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3169,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance_to_x_axis(x1, y1, x2, y2):\n        if x1 == x2:\n            return abs(x1)\n        return abs(x1 + (y2 - y1) / (x2 - x1) * (-x1))\n\n    def translate_stick(x1, y1, x2, y2):\n        dist = distance_to_x_axis(x1, y1, x2, y2)\n        return (x1 - dist, y1, x1 - dist, y2) if x1 > 0 else (x2 + dist, y1, x2 + dist, y2)\n\n    def is_valid(x1, y1, x2, y2):\n        for x, y in [(x1, y1), (x2, y2)]:\n            if not (0 <= x <= 10000 and 0 <= y <= 10000):\n                return False\n        return x1 != x2 or y1 != y2\n\n    def can_translate(x1, y1, x2, y2):\n        if not is_valid(x1, y1, x2, y2):\n            return False\n        translated = translate_stick(x1, y1, x2, y2)\n        if not is_valid(*translated):\n            return False\n        return translated[0] < x1\n\n    N = int(stdin.readline().strip())\n    sticks = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        sticks.append((x1, y1, x2, y2))\n\n    order = []\n    while sticks:\n        best_stick_index = -1\n        best_translated = None\n        for i, stick in enumerate(sticks):\n            translated = translate_stick(*stick)\n            if can_translate(*stick) and (best_stick_index == -1 or distance_to_x_axis(*stick) > distance_to_x_axis(*best_translated)):\n                best_stick_index = i\n                best_translated = translated\n        if best_stick_index == -1:\n            break\n        order.append(best_stick_index)\n        sticks[best_stick_index] = best_translated\n\n    return ' '.join(map(str, order))"
    },
    {
        "number": 3169,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_touching(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        return not ((x1 > x4 or x2 < x3) or (y1 > y4 or y2 < y3))\n\n    def translate_line(line, dx):\n        x1, y1, x2, y2 = line\n        return [x1 + dx, y1, x2 + dx, y2]\n\n    def find_shortest_path(sticks):\n        sorted_sticks = sorted(sticks, key=lambda x: x[0])\n        path = []\n        x = 0\n        while sorted_sticks:\n            min_distance = float('inf')\n            min_index = -1\n            for i, stick in enumerate(sorted_sticks):\n                distance = min(abs(stick[0] - x), abs(stick[2] - x))\n                if distance < min_distance:\n                    min_distance = distance\n                    min_index = i\n            path.append(min_index)\n            x = sorted_sticks[min_index][2]\n            sorted_sticks.pop(min_index)\n        return path\n\n    def remove_touching_sticks(sticks, path):\n        new_sticks = []\n        for i in path:\n            if not any(is_touching(sticks[i], other) for j, other in enumerate(sticks) if j not in path):\n                new_sticks.append(sticks[i])\n        return new_sticks\n\n    N = int(stdin.readline().strip())\n    sticks = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        sticks.append([x1, y1, x2, y2])\n\n    shortest_path = find_shortest_path(sticks)\n    while True:\n        translated_sticks = [translate_line(sticks[i], -sticks[i][0]) for i in shortest_path]\n        non_touching_sticks = remove_touching_sticks(translated_sticks, shortest_path)\n        if len(non_touching_sticks) == len(sticks):\n            break\n        shortest_path = find_shortest_path(translated_sticks)\n\n    return ' '.join(map(str, sorted(shortest_path)))"
    },
    {
        "number": 3169,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x1, y1, x2, y2):\n        if x1 == x2:\n            return True\n        return (y2 - y1) / (x2 - x1) == (y1 + y2 - 20000) / (x1 + x2 - 20000)\n\n    def distance(x1, y1, x2, y2):\n        return abs(x1 + y1 - 10000) + abs(x2 + y2 - 10000)\n\n    N = int(stdin.readline().strip())\n    sticks = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        sticks.append((x1, y1, x2, y2))\n\n    sticks = sorted(sticks, key=lambda x: distance(*x))\n    result = []\n    for i, (x1, y1, x2, y2) in enumerate(sticks):\n        if is_valid(x1, y1, x2, y2):\n            result.append(i)\n\n    return ' '.join(map(str, result))"
    },
    {
        "number": 3169,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def valid_move(x1, y1, x2, y2, x3, y3):\n        if x1 == x3 and y1 == y3:\n            return False\n        if x1 == x2 == x3:\n            return False\n        if y1 == y2 == y3:\n            return False\n        return True\n\n    def nearest_stick(x, y, sticks):\n        nearest = None\n        min_distance = float('inf')\n        for i, (x1, y1, x2, y2) in enumerate(sticks):\n            d = distance(x1, y1, x2, y2, x, y)\n            if d < min_distance:\n                min_distance = d\n                nearest = i\n        return nearest\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    sticks = [tuple(map(int, line.split())) for line in lines[1:N + 1]]\n\n    sticks_to_remove = []\n    for i, (x1, y1, x2, y2) in enumerate(sticks):\n        if x1 == x2:\n            sticks_to_remove.append(i)\n        elif y1 == y2:\n            sticks_to_remove.append(i)\n\n    remaining_sticks = [stick for i, stick in enumerate(sticks) if i not in sticks_to_remove]\n    remaining_sticks.sort(key=lambda s: distance(s[0], s[1], s[2], s[3], 0, 0))\n\n    order = []\n    for x1, y1, x2, y2 in remaining_sticks:\n        x3, y3 = nearest_stick(x2, y2, remaining_sticks)\n        while valid_move(x1, y1, x2, y2, x3, y3):\n            order.append(remaining_sticks.index((x1, y1, x2, y2)))\n            x1, y1, x2, y2 = x2, y2, x3, y3\n            x3, y3 = nearest_stick(x2, y2, remaining_sticks)\n\n    for i in sticks_to_remove:\n        order.append(i)\n\n    return ' '.join(map(str, sorted(order)))"
    },
    {
        "number": 3169,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance_to_axis(x1, y1, x2, y2):\n        return min(abs(x1), abs(x2), abs(y1), abs(y2))\n\n    N = int(stdin.readline())\n    sticks = []\n    for i in range(N):\n        x1, y1, x2, y2 = map(int, stdin.readline().split())\n        sticks.append((i, distance_to_axis(x1, y1, x2, y2)))\n\n    sticks.sort(key=lambda x: x[1])\n    return ' '.join(str(stick[0]) for stick in sticks)"
    },
    {
        "number": 3169,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x1, y1, x2, y2, x_axis):\n        if x1 == x_axis:\n            return True\n        if y1 < y2:\n            return False\n        return (x1 - x_axis) * (y2 - y1) >= (x2 - x1) * (y1 - y_axis)\n\n    def get_order(sticks, x_axis):\n        valid_sticks = [i for i, stick in enumerate(sticks) if is_valid(*stick, x_axis)]\n        return valid_sticks\n\n    def get_next_stick(sticks, x_axis, order):\n        valid_sticks = get_order(sticks, x_axis)\n        for stick in valid_sticks:\n            if stick not in order:\n                return stick\n        return None\n\n    def clean_table(sticks, order):\n        x_axis = 0\n        while sticks:\n            next_stick = get_next_stick(sticks, x_axis, order)\n            if next_stick is None:\n                return None\n            order.append(next_stick)\n            sticks.pop(next_stick)\n            x_axis += 1\n        return order\n\n    N = int(stdin.readline().strip())\n    sticks = [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n\n    order = []\n    result = clean_table(sticks, order)\n    if result is None:\n        return \"IMPOSSIBLE\"\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3169,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_touching(x1, y1, x2, y2, x3, y3):\n        return not ((x1 <= x3 <= x2) or (x1 >= x3 >= x2) or (y1 <= y3 <= y2) or (y1 >= y3 >= y2))\n\n    def find_closest_point(x1, y1, x2, y2):\n        if x1 == x2:\n            return min(x1, 10000 - x1), y1\n        m = (y2 - y1) / (x2 - x1)\n        b = y1 - m * x1\n        x = 0 if m == 0 else -b / m\n        y = m * x + b\n        if distance(x1, y1, x, y) < distance(x1, y1, 0, y1) or distance(x1, y1, x, y) < distance(x1, y1, 10000, y1):\n            return min(x1, 10000 - x1), y1\n        return x, y\n\n    N = int(stdin.readline().strip())\n    sticks = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        sticks.append((x1, y1, x2, y2))\n\n    labels = list(range(N))\n    sticks = sorted(sticks, key=lambda x: (-x[1], x[0]))\n\n    for i in range(N):\n        x1, y1, x2, y2 = sticks[i]\n        closest_x, closest_y = find_closest_point(x1, y1, x2, y2)\n        for j in range(N):\n            x3, y3, x4, y4 = sticks[j]\n            if i == j or (closest_x, closest_y) not in [(x3, y3), (x4, y4)]:\n                continue\n            if is_touching(x1, y1, x2, y2, x3, y3) or is_touching(x1, y1, x2, y2, x4, y4):\n                if distance(x1, y1, x3, y3) < distance(x1, y1, x4, y4):\n                    sticks[j], sticks[i] = sticks[i], sticks[j]\n                    labels[j], labels[i] = labels[i], labels[j]\n                else:\n                    sticks[i], sticks[j] = sticks[j], sticks[i]\n                    labels[i], labels[j] = labels[j], labels[i]\n                break\n\n    return \" \".join(map(str, labels))"
    },
    {
        "number": 3169,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_distance(line):\n        x1, y1, x2, y2 = line\n        distance = min(x1, 10000 - x2)\n        return distance\n\n    def cmp(a, b):\n        return (a > b) - (a < b)\n\n    def sort_lines(lines):\n        lines.sort(key=get_distance, reverse=True)\n        lines.sort(key=lambda line: (line[1], line[0], line[2], line[3]))\n        return lines\n\n    def get_stick_labels(lines, N):\n        stick_labels = []\n        for i in range(N):\n            if lines[i] == sorted_lines[i]:\n                stick_labels.append(i)\n        return stick_labels\n\n    N = int(stdin.readline().strip())\n    lines = []\n    for _ in range(N):\n        line = list(map(int, stdin.readline().strip().split()))\n        lines.append(line)\n\n    sorted_lines = sort_lines(lines)\n    stick_labels = get_stick_labels(lines, N)\n\n    return \" \".join(map(str, stick_labels))"
    },
    {
        "number": 3169,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def shortest_distance(x1, y1, x2, y2):\n        dx, dy = x2 - x1, y2 - y1\n        if dx == 0:\n            return 10000 - x1 if dy > 0 else x1\n        if dy == 0:\n            return 10000 - y1 if dx < 0 else y1\n        k = -dx / dy\n        A, B, C = k ** 2 + 1, 2 * k * (y1 - k * x1) - 2 * k * y1, (y1 - k * x1) ** 2 - 10000 ** 2\n        x = (-B + (B ** 2 - 4 * A * C) ** 0.5) / (2 * A)\n        return distance(x1, y1, x, k * x)\n\n    def should_remove(x1, y1, x2, y2):\n        return x1 == x2 or y1 == y2\n\n    N = int(stdin.readline().strip())\n    sticks = [tuple(map(int, stdin.readline().strip().split())) for _ in range(N)]\n\n    labels = list(range(N))\n    for i in range(N - 1, 0, -1):\n        for j in range(i):\n            x1, y1, x2, y2 = sticks[j]\n            x3, y3, x4, y4 = sticks[j + 1]\n            if should_remove(x1, y1, x2, y2) and shortest_distance(x1, y1, x2, y2) > shortest_distance(x3, y3, x4, y4):\n                sticks[j], sticks[j + 1] = sticks[j + 1], sticks[j]\n                labels[j], labels[j + 1] = labels[j + 1], labels[j]\n\n    return ' '.join(map(str, labels))\n"
    },
    {
        "number": 3169,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2\n\n    def find_closest_stick(sticks):\n        closest_stick = None\n        min_distance = float('inf')\n        for i, stick in enumerate(sticks):\n            d = distance(0, stick[1], stick[2], stick[3])\n            if d < min_distance:\n                min_distance = d\n                closest_stick = i\n        return closest_stick\n\n    def remove_stick(sticks, index):\n        return [stick for i, stick in enumerate(sticks) if i != index]\n\n    sticks = []\n    num_sticks = int(stdin.readline().strip())\n    for i in range(num_sticks):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        sticks.append((i, x1, y1, x2, y2))\n\n    order = []\n    while sticks:\n        closest_stick_index = find_closest_stick(sticks)\n        order.append(sticks[closest_stick_index][0] + 1)\n        sticks = remove_stick(sticks, closest_stick_index)\n\n    return ' '.join(map(str, order))"
    },
    {
        "number": 3170,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_available_slots(card, slot):\n        if card == 'A':\n            return [1]\n        elif card == '2':\n            return [2]\n        elif card == '3':\n            return [3]\n        elif card == '4':\n            return [4]\n        elif card == '5':\n            return [5]\n        elif card == '6':\n            return [6]\n        elif card == '7':\n            return [7]\n        elif card == '8':\n            return [8]\n        elif card == '9':\n            return [9]\n        elif card == 'T':\n            return [10]\n        elif card == 'J':\n            return [slot for slot in range(1, 11)]\n        elif card == 'Q':\n            return [slot for slot in range(1, 11)]\n        elif card == 'K':\n            return [slot for slot in range(1, 11)]\n        return []\n\n    def can_fill_slot(card, available_slots, used_slots):\n        for slot in available_slots:\n            if slot not in used_slots:\n                return True\n        return False\n\n    def is_jack(card):\n        return card == 'J'\n\n    def play_trash(deck, theta_hand, friend_hand, discard_pile):\n        current_player = 'Theta'\n        while True:\n            if current_player == 'Theta':\n                if not theta_hand:\n                    break\n                card = theta_hand.pop(0)\n            else:\n                if not friend_hand:\n                    break\n                card = friend_hand.pop(0)\n\n            if is_jack(card):\n                available_slots = [i for i in range(1, 11) if i not in discard_pile]\n                if not available_slots:\n                    discard_pile.append(1)\n                    continue\n                chosen_slot = min(available_slots)\n                discard_pile.append(chosen_slot)\n                current_player = 'Theta' if current_player == 'Friend' else 'Friend'\n            else:\n                available_slots = get_available_slots(card, discard_pile[-1] if discard_pile else None)\n                if not can_fill_slot(card, available_slots, discard_pile):\n                    discard_pile.append(available_slots[0])\n                    current_player = 'Theta' if current_player == 'Friend' else 'Friend'\n                else:\n                    discard_pile.append(min(available_slots))\n\n    theta_hand = []\n    friend_hand = []\n    discard_pile = []\n\n    for i in range(10):\n        theta_hand.append(stdin[i])\n    for i in range(10, 20):\n        friend_hand.append(stdin[i])\n\n    play_trash(stdin, theta_hand, friend_hand, discard_pile)\n\n    if all(card in discard_pile for card in range(1, 11)):\n        return \"Theta wins\"\n    else:\n        return \"Theta loses\""
    },
    {
        "number": 3170,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def can_fill_slot(card: str, slot: str) -> bool:\n        return card[0] == slot or card == \"A\" or card == \"J\"\n\n    def find_next_slot(slots: list) -> str:\n        for slot in slots:\n            if not slot[1]:\n                return slot[0]\n        return None\n\n    def update_slots(slots: list, card: str, slot: str) -> None:\n        for s in slots:\n            if s[0] == slot:\n                s[1].append(card)\n                return\n\n    def discard_card(discard_pile: list, card: str) -> None:\n        discard_pile.append(card)\n\n    def shuffle_deck(stdin: str) -> list:\n        deck = [card for card in stdin]\n        return deck\n\n    def deal_cards(deck: list) -> tuple:\n        th_face_down = deck[:10]\n        th_slots = [[\"A\", []], [\"2\", []], [\"3\", []], [\"4\", []], [\"5\", []], [\"6\", []], [\"7\", []], [\"8\", []], [\"9\", []], [\"10\", []]]\n\n        f_face_down = deck[10:20]\n        f_slots = [[\"A\", []], [\"2\", []], [\"3\", []], [\"4\", []], [\"5\", []], [\"6\", []], [\"7\", []], [\"8\", []], [\"9\", []], [\"10\", []]]\n\n        return th_face_down, th_slots, f_face_down, f_slots\n\n    deck = shuffle_deck(stdin)\n    th_face_down, th_slots, f_face_down, f_slots = deal_cards(deck)\n    discard_pile = []\n\n    while True:\n        if not th_face_down:\n            break\n        card = th_face_down.pop(0)\n\n        if card in discard_pile:\n            discard_pile.remove(card)\n        elif card == \"J\":\n            next_slot = find_next_slot(th_slots)\n            if next_slot:\n                update_slots(th_slots, card, next_slot)\n        else:\n            for slot in th_slots:\n                if can_fill_slot(card, slot[0]):\n                    update_slots(th_slots, card, slot[0])\n                    break\n            else:\n                discard_card(discard_pile, card)\n\n    if any(not slot[1] for slot in th_slots):\n        return \"Theta loses\"\n    else:\n        return \"Theta wins\""
    },
    {
        "number": 3170,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def draw_card(drawn_card: str, slots: list, discard_pile: list) -> str:\n        if drawn_card in \"A2345\":\n            if \"A\" not in slots[0]:\n                return \"A\"\n            elif \"2\" not in slots[1]:\n                return \"2\"\n            elif \"3\" not in slots[2]:\n                return \"3\"\n            elif \"4\" not in slots[3]:\n                return \"4\"\n            elif \"5\" not in slots[4]:\n                return \"5\"\n        elif drawn_card in \"6789T\":\n            for i in range(5, 9):\n                if str(i + 1) not in slots[i]:\n                    return str(i + 1)\n        elif drawn_card == \"J\":\n            for i in range(9):\n                if str(i + 1) not in slots[i]:\n                    return str(i + 1)\n        discard_pile.append(drawn_card)\n        return \"discarded\"\n\n    deck = stdin.split()\n    th_cards = deck[:10]\n    f_cards = deck[10:20]\n    drawn_card = deck[20]\n    slots = [[\"A\", \"2\", \"3\", \"4\", \"5\"] for _ in range(2)]\n    discard_pile = []\n    players = [th_cards, f_cards]\n\n    while True:\n        for i, player in enumerate(players):\n            for card in player:\n                slot = draw_card(card, slots[i], discard_pile)\n                if slot == \"discarded\":\n                    continue\n                if slot == \"A\":\n                    slots[i][0] = \"THETA\"\n                else:\n                    slots[i][int(slot) - 1] = \"THETA\"\n\n            if all(slot.count(\"THETA\") == 5 for slot in slots[i]):\n                return \"Theta wins\"\n\n            if drawn_card in \"A23456789T\":\n                drawn_card = deck.pop(0)\n            else:\n                drawn_card = deck.pop(20)\n\n    return \"Theta loses\""
    },
    {
        "number": 3170,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def can_fill_slot(card: str, slot: str) -> bool:\n        if slot == \"A\":\n            return card in [\"A\"]\n        elif slot == \"2\":\n            return card in [\"2\"]\n        elif slot == \"3\":\n            return card in [\"3\"]\n        elif slot == \"4\":\n            return card in [\"4\"]\n        elif slot == \"5\":\n            return card in [\"5\"]\n        elif slot == \"6\":\n            return card in [\"6\", \"J\"]\n        elif slot == \"7\":\n            return card in [\"7\", \"J\"]\n        elif slot == \"8\":\n            return card in [\"8\", \"J\"]\n        elif slot == \"9\":\n            return card in [\"9\", \"J\"]\n        elif slot == \"T\":\n            return card in [\"T\", \"J\"]\n        return False\n\n    def get_next_card(cards: str, drawn_cards: set) -> str:\n        for card in cards:\n            if card not in drawn_cards:\n                drawn_cards.add(card)\n                return card\n        return \"\"\n\n    def play_trash(deck: str, friend_slots: list, th_slots: list, drawn_cards: set) -> str:\n        friend_turn = True\n        while friend_slots.count(None) + th_slots.count(None) > 0:\n            if friend_turn:\n                next_card = get_next_card(deck, drawn_cards)\n                if next_card == \"\":\n                    break\n                for i, slot in enumerate(friend_slots):\n                    if slot is not None and can_fill_slot(next_card, slot):\n                        friend_slots[i] = next_card\n                        friend_turn = False\n                        break\n            else:\n                next_card = get_next_card(deck, drawn_cards)\n                if next_card == \"\":\n                    break\n                for i, slot in enumerate(th_slots):\n                    if slot is not None and can_fill_slot(next_card, slot):\n                        th_slots[i] = next_card\n                        friend_turn = True\n                        break\n        return friend_slots, th_slots\n\n    def count_optimal_th_moves(friend_slots: list, th_slots: list) -> int:\n        total_slots = friend_slots + th_slots\n        total_slots.sort(key=lambda x: x if x is not None else \"Z\")\n        th_move_count = 0\n        for slot in total_slots:\n            if slot is None:\n                break\n            elif slot == \"J\":\n                th_move_count += 1\n            elif can_fill_slot(slot, \"J\"):\n                th_move_count += 1\n                break\n        return th_move_count\n\n    def count_min_th_moves(friend_slots: list, th_slots: list) -> int:\n        total_slots = friend_slots + th_slots\n        total_slots.sort(key=lambda x: x if x is not None else \"Z\")\n        th_move_count = 0\n        for slot in total_slots:\n            if slot is None:\n                break\n            elif slot == \"J\":\n                th_move_count += 1\n            elif can_fill_slot(slot, \"J\"):\n                th_move_count += 1\n                break\n            elif can_fill_slot(slot, \"A\"):\n                th_move_count += 1\n                break\n        return th_move_count\n\n    deck = stdin\n    th_slots = [None] * 10\n    friend_slots = [None] * 10\n    drawn_cards = set()\n\n    for i in range(10):\n        th_slots[i] = deck[i]\n    for i in range(10, 20):\n        friend_slots[i - 10] = deck[i]\n    for i in range(21, 52):\n        drawn_cards.add(deck[i])\n\n    friend_slots, th_slots = play_trash(deck"
    },
    {
        "number": 3170,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def fill_slot(card: str, slots: list) -> bool:\n        for i in range(len(slots)):\n            if slots[i] is None and (card == \"A\" or int(card) == i + 1):\n                slots[i] = card\n                return True\n        return False\n\n    def winner(theta_slots: list, friend_slots: list) -> str:\n        for i in range(len(theta_slots)):\n            if theta_slots[i] is None:\n                return \"Theta loses\"\n            if friend_slots[i] is None:\n                return \"Theta wins\"\n        return \"Theta wins\"\n\n    theta_slots = [None] * 10\n    friend_slots = [None] * 10\n    theta_cards = stdin[:10]\n    friend_cards = stdin[10:20]\n    deck = list(stdin[20:])\n\n    for i in range(10):\n        fill_slot(theta_cards[i], theta_slots)\n        fill_slot(friend_cards[i], friend_slots)\n\n    while deck:\n        card = deck.pop(0)\n        if card == \"J\":\n            for i in range(len(theta_slots)):\n                if theta_slots[i] is None:\n                    theta_slots[i] = card\n                    break\n        else:\n            if not fill_slot(card, theta_slots):\n                return \"Theta loses\"\n            if not fill_slot(card, friend_slots):\n                return \"Theta wins\"\n\n    return winner(theta_slots, friend_slots)"
    },
    {
        "number": 3170,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    deck = stdin\n    discard_pile = []\n    theta_slots = [[] for _ in range(10)]\n    friend_slots = [[] for _ in range(10)]\n\n    for i in range(2):\n        for j in range(10):\n            card = deck[j]\n            if i == 0:\n                theta_slots[j // 2].append(card)\n            else:\n                friend_slots[j // 2].append(card)\n\n    for i in range(10, 31):\n        card = deck[i]\n        if card == 'A':\n            for j in range(10):\n                if len(theta_slots[j]) == 0:\n                    theta_slots[j].append(card)\n                    break\n                elif len(theta_slots[j]) == 1 and theta_slots[j][0] == 'J':\n                    theta_slots[j].append(card)\n                    break\n        elif card == 'J':\n            for j in range(10):\n                if len(theta_slots[j]) == 0:\n                    theta_slots[j].append(card)\n                    break\n                elif len(theta_slots[j]) == 1 and theta_slots[j][0] == 'J':\n                    theta_slots[j].append(card)\n                    break\n        else:\n            for j in range(10):\n                if len(theta_slots[j]) == 0:\n                    theta_slots[j].append(card)\n                    break\n                elif len(theta_slots[j]) == 1 and theta_slots[j][0] == 'J':\n                    theta_slots[j].append(card)\n                    break\n\n    theta_won = all(len(slot) > 0 for slot in theta_slots)\n    friend_won = all(len(slot) > 0 for slot in friend_slots)\n\n    if theta_won:\n        return \"Theta wins\"\n    elif friend_won:\n        return \"Theta loses\"\n    else:\n        return \"Theta loses\""
    },
    {
        "number": 3170,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    deck = stdin\n    th_cards = deck[:10]\n    f_cards = deck[10:20]\n    discard_pile = []\n\n    def fill_slot(card: str, slot: list) -> bool:\n        if card in slot:\n            slot.remove(card)\n            return True\n        return False\n\n    def use_jack(hand: list, slots: list) -> bool:\n        for card in hand:\n            if card == 'J':\n                for slot in slots:\n                    if slot:\n                        return True\n                return False\n        return False\n\n    def th_turn(th_cards: list, slots: list, discard_pile: list) -> bool:\n        while th_cards:\n            card = th_cards.pop(0)\n            if card in ['A', '2', '3', '4', '5']:\n                if fill_slot(card, slots[0]):\n                    continue\n            elif card in ['6', '7', '8', '9', '10']:\n                if fill_slot(card, slots[1]):\n                    continue\n            elif card == 'J':\n                if use_jack(th_cards, slots):\n                    continue\n            discard_pile.append(card)\n            break\n        return not th_cards\n\n    def f_turn(f_cards: list, slots: list, discard_pile: list) -> bool:\n        while f_cards:\n            card = f_cards.pop(0)\n            if card in ['A', '2', '3', '4', '5']:\n                if fill_slot(card, slots[0]):\n                    continue\n            elif card in ['6', '7', '8', '9', '10']:\n                if fill_slot(card, slots[1]):\n                    continue\n            discard_pile.append(card)\n            break\n        return not f_cards\n\n    th_slots = [['A', '2', '3', '4', '5'], ['6', '7', '8', '9', '10']]\n    f_slots = [['A', '2', '3', '4', '5'], ['6', '7', '8', '9', '10']]\n\n    while True:\n        if th_turn(th_cards, th_slots, discard_pile):\n            if not f_cards:\n                return \"Theta wins\"\n            if f_turn(f_cards, f_slots, discard_pile):\n                if not th_cards:\n                    return \"Theta wins\"\n            else:\n                return \"Theta wins\"\n        else:\n            if f_turn(f_cards, f_slots, discard_pile):\n                if not th_cards:\n                    return \"Theta wins\"\n                if th_turn(th_cards, th_slots, discard_pile):\n                    return \"Theta wins\"\n            else:\n                return \"Theta wins\""
    },
    {
        "number": 3170,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_card(deck: List[str]) -> str:\n        return deck.pop(0)\n\n    def can_fill_slot(card: str, slot: str) -> bool:\n        if slot == \"A\" and card in \"A2345\":\n            return True\n        if slot == \"2\" and card in \"23456789TJQK\":\n            return True\n        if slot == \"3\" and card in \"3456789TJQK\":\n            return True\n        if slot == \"4\" and card in \"456789TJQK\":\n            return True\n        if slot == \"5\" and card in \"56789TJQK\":\n            return True\n        if slot == \"6\" and card in \"6789TJQK\":\n            return True\n        if slot == \"7\" and card in \"789TJQK\":\n            return True\n        if slot == \"8\" and card in \"89TJQK\":\n            return True\n        if slot == \"9\" and card in \"9TJQK\":\n            return True\n        if slot == \"T\" and card in \"TJQK\":\n            return True\n        if slot == \"J\" and card == \"J\":\n            return True\n        if slot == \"Q\" and card == \"Q\":\n            return True\n        if slot == \"K\" and card == \"K\":\n            return True\n        return False\n\n    def get_slot_number(card: str) -> int:\n        if card in \"A2345\":\n            return 1\n        if card in \"6789TJQK\":\n            return 2\n        if card == \"J\":\n            return 3\n        if card == \"Q\":\n            return 4\n        if card == \"K\":\n            return 5\n        raise ValueError(\"Invalid card\")\n\n    def get_slot_name(card: str) -> str:\n        if card == \"A\":\n            return \"Ace\"\n        if card == \"2\":\n            return \"2\"\n        if card == \"3\":\n            return \"3\"\n        if card == \"4\":\n            return \"4\"\n        if card == \"5\":\n            return \"5\"\n        if card == \"6\":\n            return \"6\"\n        if card == \"7\":\n            return \"7\"\n        if card == \"8\":\n            return \"8\"\n        if card == \"9\":\n            return \"9\"\n        if card == \"T\":\n            return \"10\"\n        if card == \"J\":\n            return \"Jack\"\n        if card == \"Q\":\n            return \"Queen\"\n        if card == \"K\":\n            return \"King\"\n        raise ValueError(\"Invalid card\")\n\n    def play_trash(deck: List[str], theta_hand: List[str], friend_hand: List[str]) -> str:\n        discard_pile = []\n\n        def theta_turn(theta_hand: List[str], friend_hand: List[str]) -> None:\n            drawn_card = get_next_card(deck)\n            if drawn_card == \"J\":\n                for slot in theta_hand:\n                    if slot != \"J\":\n                        theta_hand.remove(slot)\n                        discard_pile.append(slot)\n                        return\n            else:\n                for slot, card in zip(theta_hand, friend_hand):\n                    if can_fill_slot(drawn_card, slot):\n                        theta_hand.remove(slot)\n                        discard_pile.append(slot)\n                        friend_hand.remove(card)\n                        discard_pile.append(card)\n                        return\n                discard_pile.append(drawn_card)\n\n        def friend_turn(theta_hand: List[str], friend_hand: List[str]) -> None:\n            drawn_card = get_next_card(deck)\n            if drawn_card == \"J\":\n                for slot in friend_hand:\n                    if slot != \"J\":\n                        friend_hand.remove(slot)\n                        discard_pile.append(slot)\n                        return"
    },
    {
        "number": 3170,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    deck = stdin\n    theta_cards = deck[:10]\n    friend_cards = deck[10:20]\n    discard_pile = []\n\n    def find_slot(card, theta):\n        slots = [theta_slots, friend_slots][theta]\n        for i, slot in enumerate(slots):\n            if not slot and (card == '1' or int(card) == i + 1):\n                return i\n        return None\n\n    def play_card(card, theta, uncovered=None):\n        if uncovered:\n            uncovered_card = uncovered\n        else:\n            uncovered_card = deck.pop() if deck else None\n\n        if uncovered_card:\n            slot = find_slot(card, theta)\n            if slot is not None:\n                if theta:\n                    theta_slots[slot] = uncovered_card\n                else:\n                    friend_slots[slot] = uncovered_card\n                return True\n            else:\n                discard_pile.append(uncovered_card)\n        return False\n\n    def play_round(theta):\n        uncovered = None\n        while (theta_cards or friend_cards) and (theta_cards and friend_cards):\n            if theta:\n                card = theta_cards.pop(0) if theta_cards else None\n            else:\n                card = friend_cards.pop(0) if friend_cards else None\n\n            if card == '1':\n                for i in range(10):\n                    if not (theta_slots[i] or friend_slots[i]):\n                        if play_card(str(i + 1), theta, uncovered):\n                            uncovered = None\n                            break\n            elif card == 'J':\n                for i in range(10):\n                    if play_card(str(i + 1), theta, uncovered):\n                        uncovered = None\n                        break\n            else:\n                play_card(card, theta, uncovered)\n                uncovered = None\n\n            theta = not theta\n\n    theta_slots = [None] * 10\n    friend_slots = [None] * 10\n\n    play_round(True)\n\n    if all(theta_slots):\n        return \"Theta wins\"\n    else:\n        return \"Theta loses\""
    },
    {
        "number": 3170,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def has_space(slot, cards, card_count):\n        for i in range(len(slot)):\n            if slot[i] == 0 and cards[i] in card_count:\n                return True\n        return False\n\n    def fill_slot(slot, cards, card_count):\n        for i in range(len(slot)):\n            if slot[i] == 0 and cards[i] in card_count:\n                slot[i] = 1\n                card_count.pop(cards[i])\n                return True\n        return False\n\n    def next_card(deck):\n        return deck[0]\n\n    def discard_card(card, discard_pile):\n        discard_pile.append(card)\n\n    def shuffle_deck(deck):\n        random.shuffle(deck)\n\n    def count_cards(deck):\n        card_count = {}\n        for card in deck:\n            if card in card_count:\n                card_count[card] += 1\n            else:\n                card_count[card] = 1\n        return card_count\n\n    def play_trash(deck, theta_slot, friend_slot):\n        theta_turn = True\n        discard_pile = []\n\n        while True:\n            if theta_turn:\n                if not fill_slot(theta_slot, deck, card_count):\n                    if next_card(deck) not in card_count:\n                        discard_card(next_card(deck), discard_pile)\n                        deck.pop(0)\n                        theta_turn = False\n                    else:\n                        deck.pop(0)\n                        theta_turn = False\n                else:\n                    if not has_space(friend_slot, deck, card_count):\n                        break\n                    else:\n                        theta_turn = False\n            else:\n                if not fill_slot(friend_slot, deck, card_count):\n                    if next_card(deck) not in card_count:\n                        discard_card(next_card(deck), discard_pile)\n                        deck.pop(0)\n                        theta_turn = True\n                    else:\n                        deck.pop(0)\n                        theta_turn = True\n                else:\n                    if not has_space(theta_slot, deck, card_count):\n                        break\n                    else:\n                        theta_turn = True\n\n        return discard_pile\n\n    shuffled_deck = list(stdin)\n    deck = shuffled_deck[10:]\n    card_count = count_cards(deck)\n\n    theta_slot = [0] * 10\n    friend_slot = [0] * 10\n\n    for i in range(10):\n        theta_slot[i] = 1 if shuffled_deck[i] == 'A' else 0\n        friend_slot[i] = 1 if shuffled_deck[i + 10] == 'A' else 0\n\n    discard_pile = play_trash(deck, theta_slot, friend_slot)\n\n    if len(discard_pile) > 0:\n        return \"Theta loses\"\n    else:\n        return \"Theta wins\""
    },
    {
        "number": 3171,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, K = map(int, stdin.split()[:2])\n    candidates = [None] * (N + 1)  # Candidates' character types\n    candidates[0] = \"truther\"  # All propositions start with a truther\n    utterances = stdin.split('\\n')[2:]  # Skip first two lines\n\n    # Process utterances\n    for utterance in utterances:\n        speaker, proposition = utterance.split(' ', 1)\n        speaker = int(speaker)\n\n        if 'charlatan' in proposition:\n            candidates[speaker] = 'charlatan'\n        elif 'fabulist' in proposition:\n            candidates[speaker] = 'fabulist'\n        elif 'truther' in proposition:\n            candidates[speaker] = 'truther'\n        elif 'not' in proposition:\n            if 'charlatan' in candidates[speaker]:\n                candidates[speaker] = 'fabulist'\n            elif 'fabulist' in candidates[speaker]:\n                candidates[speaker] = 'charlatan'\n            elif 'truther' in candidates[speaker]:\n                candidates[speaker] = 'charlatan'\n        elif 'and' in proposition:\n            a, b = proposition.split(' and ', 1)\n            if 'truther' in a and 'truther' in b:\n                candidates[speaker] = 'truther'\n            elif 'charlatan' in a and 'charlatan' in b:\n                candidates[speaker] = 'charlatan'\n            elif 'fabulist' in a and 'fabulist' in b:\n                candidates[speaker] = 'fabulist'\n        elif 'xor' in proposition:\n            a, b = proposition.split(' xor ', 1)\n            if 'truther' in a and 'truther' in b:\n                candidates[speaker] = 'fabulist'\n            elif 'charlatan' in a and 'charlatan' in b:\n                candidates[speaker] = 'fabulist'\n            elif 'fabulist' in a and 'fabulist' in b:\n                candidates[speaker] = 'fabulist'\n\n    # Determine character types\n    for i in range(1, N + 1):\n        if candidates[i] is None:\n            candidates[i] = 'truther'\n\n    return '\\n'.join(candidates[1:])"
    },
    {
        "number": 3171,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        n, k = map(int, lines[0].split())\n        return n, k, lines[1:]\n\n    def evaluate(expr: str, character_types: dict) -> bool:\n        if 'truther' in expr:\n            return 'truther' in character_types[int(expr.split()[-1])]\n        elif 'fabulist' in expr:\n            return 'fabulist' in character_types[int(expr.split()[-1])]\n        elif 'charlatan' in expr:\n            return 'charlatan' in character_types[int(expr.split()[-1])]\n        elif 'not' in expr:\n            return not evaluate(expr[4:], character_types)\n        elif 'and' in expr:\n            return evaluate(expr[:expr.index(' and ')], character_types) and evaluate(expr[expr.index(' and ')+5:], character_types)\n        elif 'xor' in expr:\n            return evaluate(expr[:expr.index(' xor ')], character_types) != evaluate(expr[expr.index(' xor ')+4:], character_types)\n\n    def determine_character_types(n: int, k: int, utterances: list) -> dict:\n        character_types = {i: set(['truther', 'fabulist', 'charlatan']) for i in range(1, n+1)}\n        for speaker, utterance in utterances:\n            if 'charlatan' in utterance:\n                character_types[int(speaker)].discard('fabulist')\n                if 'truther' in character_types[int(speaker)]:\n                    character_types[int(speaker)] = set(['truther'])\n                else:\n                    character_types[int(speaker)] = set(['charlatan'])\n            elif 'fabulist' in utterance:\n                character_types[int(speaker)].discard('truther')\n                character_types[int(speaker)].discard('charlatan')\n                character_types[int(speaker)] = set(['fabulist'])\n            elif 'truther' in utterance:\n                character_types[int(speaker)].discard('fabulist')\n                character_types[int(speaker)].discard('charlatan')\n                character_types[int(speaker)] = set(['truther'])\n        return character_types\n\n    n, k, utterances = parse_input(stdin)\n    character_types = determine_character_types(n, k, [line.split(' ', 1) for line in utterances])\n    return '\\n'.join(sorted(character_types.values(), key=lambda x: str(x)))"
    },
    {
        "number": 3171,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def evaluate(expression: str) -> bool:\n        stack = []\n        for token in expression.split():\n            if token in {'truther', 'fabulist', 'charlatan'}:\n                if token == 'truther':\n                    stack.append(True)\n                elif token == 'fabulist':\n                    stack.append(False)\n                else:\n                    stack.append(not stack.pop())\n            elif token == 'not':\n                stack[-1] = not stack[-1]\n            elif token == 'and':\n                stack[-2] = stack[-2] and stack[-1]\n                stack.pop()\n            elif token == 'xor':\n                stack[-2] = stack[-2] != stack[-1]\n                stack.pop()\n        return stack[-1]\n\n    def parse_input(input_str: str) -> tuple:\n        lines = input_str.split('\\n')\n        N, K = map(int, lines[0].split())\n        candidates = {i: {'truther': True, 'fabulist': True, 'charlatan': True} for i in range(1, N + 1)}\n        for line in lines[1:]:\n            speaker, statement = line.split(maxsplit=1)\n            speaker = int(speaker)\n            if evaluate(statement):\n                for key in candidates[speaker]:\n                    candidates[speaker][key] = candidates[speaker][key] and key != 'charlatan'\n            else:\n                for key in candidates[speaker]:\n                    candidates[speaker][key] = candidates[speaker][key] and key != 'truther'\n        return candidates\n\n    def find_char_type(candidates: dict) -> str:\n        char_type = []\n        for i in range(1, len(candidates) + 1):\n            for key, value in candidates[i].items():\n                if value:\n                    char_type.append(key)\n                    break\n        return char_type\n\n    candidates = parse_input(stdin)\n    char_type = find_char_type(candidates)\n    return '\\n'.join(char_type) "
    },
    {
        "number": 3171,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, K = map(int, lines[0].split())\n\n    candidates = [None] * N\n    history = []\n\n    for line in lines[1:]:\n        speaker, statement = line.split(' ', maxsplit=1)\n        speaker = int(speaker)\n\n        if statement.startswith('truther ') or statement.startswith('fabulist ') or statement.startswith('charlatan '):\n            history.append((speaker, statement))\n        elif statement.startswith('not '):\n            history.append((speaker, statement[4:]))\n        elif statement.startswith('and '):\n            history.append((speaker, statement[4:].split(' ', maxsplit=1)))\n        elif statement.startswith('xor '):\n            history.append((speaker, statement[4:].split(' ', maxsplit=1), True))\n\n    def evaluate(expr, speaker):\n        if isinstance(expr, str):\n            if expr.startswith('truther '):\n                return candidates[int(expr[9:])] == 'truther'\n            elif expr.startswith('fabulist '):\n                return candidates[int(expr[10:])] == 'fabulist'\n            elif expr.startswith('charlatan '):\n                return candidates[int(expr[11:])] == 'charlatan'\n            elif expr.startswith('not '):\n                return not evaluate(expr[4:], speaker)\n            else:\n                raise ValueError(\"Invalid expression: \" + expr)\n        elif isinstance(expr, list):\n            if len(expr) == 2:\n                return evaluate(expr[0], speaker) and evaluate(expr[1], speaker)\n            elif len(expr) == 3:\n                return (not evaluate(expr[0], speaker)) ^ evaluate(expr[1], speaker) ^ speaker\n            else:\n                raise ValueError(\"Invalid expression: \" + str(expr))\n        else:\n            raise ValueError(\"Invalid expression: \" + str(expr))\n\n    for name in range(1, N + 1):\n        if not candidates[name - 1]:\n            for speaker, statement in history:\n                if isinstance(statement, str) and statement.startswith(('truther', 'fabulist', 'charlatan')):\n                    _, _, candidate = statement.split(' ')\n                    if int(candidate) == name:\n                        candidates[name - 1] = statement.split(' ', maxsplit=1)[0]\n                        break\n                elif isinstance(statement, list) and len(statement) == 3:\n                    if evaluate(statement, speaker):\n                        candidates[name - 1] = 'charlatan'\n                        break\n\n    return '\\n'.join(candidates)"
    },
    {
        "number": 3171,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_lines = stdin.split(\"\\n\")\n    N, K = map(int, input_lines[0].split())\n    utterances = []\n    for line in input_lines[1:]:\n        speaker, utterance = line.split(\" \", 1)\n        speaker = int(speaker)\n        utterances.append((speaker, utterance))\n\n    # Initialize variables\n    char_types = [\"truther\", \"fabulist\", \"charlatan\"]\n    is_truther = [False] * (N + 1)\n    is_fabulist = [False] * (N + 1)\n    is_charlatan = [False] * (N + 1)\n\n    # Process utterances\n    for speaker, utterance in utterances:\n        if utterance.startswith(\"truther\"):\n            target = int(utterance.split()[1])\n            is_truther[target] = True\n        elif utterance.startswith(\"fabulist\"):\n            target = int(utterance.split()[1])\n            is_fabulist[target] = True\n        elif utterance.startswith(\"charlatan\"):\n            target = int(utterance.split()[1])\n            is_charlatan[target] = True\n\n    # Determine character types\n    char_types = []\n    for i in range(1, N + 1):\n        if is_truther[i]:\n            char_types.append(\"truther\")\n        elif is_fabulist[i]:\n            char_types.append(\"fabulist\")\n        elif is_charlatan[i]:\n            char_types.append(\"charlatan\")\n\n    # Return output\n    return \"\\n\".join(char_types)"
    },
    {
        "number": 3171,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_type(utterances, candidates):\n        type_dict = {}\n        for candidate in candidates:\n            type_dict[candidate] = \"undefined\"\n        \n        for utterance in utterances:\n            speaker, statement = utterance.split(\" \")\n            if statement.startswith(\"truther\") or statement.startswith(\"fabulist\") or statement.startswith(\"charlatan\"):\n                target = int(statement.split(\" \")[1])\n                if target in candidates:\n                    if type_dict[target] == \"undefined\":\n                        type_dict[target] = statement.split(\" \")[0]\n                    elif type_dict[target] != statement.split(\" \")[0]:\n                        return None\n            elif statement.startswith(\"not\"):\n                target_type = statement.split(\" \")[1]\n                if target_type.startswith(\"truther\") or target_type.startswith(\"fabulist\") or target_type.startswith(\"charlatan\"):\n                    target = int(target_type.split(\" \")[1])\n                    if target in candidates:\n                        if type_dict[target] == \"undefined\":\n                            if target_type.startswith(\"truther\"):\n                                type_dict[target] = \"fabulist\"\n                            elif target_type.startswith(\"fabulist\"):\n                                type_dict[target] = \"truther\"\n                            elif target_type.startswith(\"charlatan\"):\n                                type_dict[target] = \"charlatan\"\n                        elif type_dict[target] == target_type.split(\" \")[0]:\n                            return None\n            elif statement.startswith(\"and\"):\n                statement_parts = statement.split(\" \")\n                target_type1 = statement_parts[1]\n                target_type2 = statement_parts[2]\n                if (target_type1.startswith(\"truther\") or target_type1.startswith(\"fabulist\") or target_type1.startswith(\"charlatan\")) and (target_type2.startswith(\"truther\") or target_type2.startswith(\"fabulist\") or target_type2.startswith(\"charlatan\")):\n                    target1 = int(target_type1.split(\" \")[1])\n                    target2 = int(target_type2.split(\" \")[1])\n                    if target1 in candidates and target2 in candidates:\n                        if type_dict[target1] == type_dict[target2]:\n                            continue\n                        else:\n                            return None\n            elif statement.startswith(\"xor\"):\n                statement_parts = statement.split(\" \")\n                target_type1 = statement_parts[1]\n                target_type2 = statement_parts[2]\n                if (target_type1.startswith(\"truther\") or target_type1.startswith(\"fabulist\") or target_type1.startswith(\"charlatan\")) and (target_type2.startswith(\"truther\") or target_type2.startswith(\"fabulist\") or target_type2.startswith(\"charlatan\")):\n                    target1 = int(target_type1.split(\" \")[1])\n                    target2 = int(target_type2.split(\" \")[1])\n                    if target1 in candidates and target2 in candidates:\n                        if type_dict[target1] != type_dict[target2]:\n                            continue\n                        else:\n                            return None\n        \n        for candidate in candidates:\n            if type_dict[candidate] == \"undefined\":\n                return None\n        \n        return type_dict\n    \n    lines = stdin.split(\"\\n\")\n    N, K = map(int, lines[0].split(\" \"))\n    candidates = [i for i in range(1, N+1)]\n    utterances = lines[1:K+1]\n    \n    type_dict = get_type(utterances, candidates)\n    \n    if type_dict is None:\n        return \"Impossible\"\n    else:\n        result = []\n        for candidate in candidates:\n            result.append(type_dict[candidate])\n        return \"\\n\".join(result)"
    },
    {
        "number": 3171,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_truth(propositions, prop):\n        if prop[0] == \"not\":\n            return not is_truth(propositions, prop[1])\n        elif prop[0] == \"and\":\n            return is_truth(propositions, prop[1]) and is_truth(propositions, prop[2])\n        elif prop[0] == \"xor\":\n            return is_truth(propositions, prop[1]) != is_truth(propositions, prop[2])\n        else:\n            return propositions[prop]\n\n    def find_char_type(candidates, debates):\n        for debate in debates:\n            if debate[1][0] == \"truther\":\n                candidates[int(debate[1][1])] = \"truther\"\n            elif debate[1][0] == \"fabulist\":\n                candidates[int(debate[1][1])] = \"fabulist\"\n            elif debate[1][0] == \"charlatan\":\n                candidates[int(debate[1][1])] = \"charlatan\"\n        return candidates\n\n    def parse_debate(debate):\n        lines = debate.strip().split(\"\\n\")\n        debates = []\n        for line in lines:\n            line = line.strip().split()\n            debates.append((int(line[0]), tuple(line[1:])))\n        return debates\n\n    N, K = map(int, stdin.split()[:2])\n    candidates = {i: None for i in range(1, N + 1)}\n    debate = \"\\n\".join(stdin.split(\"\\n\")[2:])\n    debates = parse_debate(debate)\n    candidates = find_char_type(candidates, debates)\n\n    result = []\n    for candidate in range(1, N + 1):\n        if candidates[candidate] is not None:\n            result.append(candidates[candidate])\n        else:\n            result.append(\"truther\")\n    return \"\\n\".join(result)"
    },
    {
        "number": 3171,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def parse_statement(statement: str) -> tuple:\n        tokens = statement.split()\n        if tokens[0] == 'truther':\n            return ('truther', int(tokens[1]))\n        elif tokens[0] == 'fabulist':\n            return ('fabulist', int(tokens[1]))\n        elif tokens[0] == 'charlatan':\n            return ('charlatan', int(tokens[1]))\n        elif tokens[0] == 'not':\n            sub_statement = parse_statement(' '.join(tokens[1:]))\n            if sub_statement[0] == 'truther':\n                return ('fabulist', sub_statement[1])\n            elif sub_statement[0] == 'fabulist':\n                return ('truther', sub_statement[1])\n            else:\n                return sub_statement\n        elif tokens[0] == 'and':\n            sub_statement1 = parse_statement(' '.join(tokens[1:tokens.index('and')]))\n            sub_statement2 = parse_statement(' '.join(tokens[tokens.index('and') + 1:]))\n            if sub_statement1[0] == sub_statement2[0]:\n                return (sub_statement1[0], sub_statement1[1])\n            else:\n                return ('charlatan', sub_statement1[1])\n        elif tokens[0] == 'xor':\n            sub_statement1 = parse_statement(' '.join(tokens[1:tokens.index('xor')]))\n            sub_statement2 = parse_statement(' '.join(tokens[tokens.index('xor') + 1:]))\n            if sub_statement1[0] == sub_statement2[0] == 'truther':\n                return ('charlatan', sub_statement1[1])\n            elif sub_statement1[0] == sub_statement2[0] == 'fabulist':\n                return ('charlatan', sub_statement1[1])\n            elif sub_statement1[0] == 'truther' and sub_statement2[0] == 'fabulist':\n                return ('charlatan', sub_statement1[1])\n            elif sub_statement1[0] == 'fabulist' and sub_statement2[0] == 'truther':\n                return ('charlatan', sub_statement1[1])\n            else:\n                return ('charlatan', sub_statement1[1])\n    \n    N, K = map(int, stdin.readline().split())\n    speaker_dict = {}\n    for _ in range(K):\n        speaker, statement = stdin.readline().split(' ', 1)\n        speaker_dict[speaker] = parse_statement(statement)\n    \n    result = []\n    for i in range(1, N + 1):\n        if i in speaker_dict:\n            result.append(speaker_dict[str(i)][0])\n        else:\n            result.append('charlatan')\n    \n    return '\\n'.join(result) "
    },
    {
        "number": 3171,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split('\\n')[0].split())\n    candidates = [True] * N\n    lines = stdin.split('\\n')[1:]\n\n    for line in lines:\n        speaker, statement = line.split(' ', 1)\n        speaker = int(speaker)\n\n        if statement.startswith('truther'):\n            candidate = int(statement.split()[1])\n            candidates[candidate - 1] = True\n        elif statement.startswith('fabulist'):\n            candidate = int(statement.split()[1])\n            candidates[candidate - 1] = False\n        elif statement.startswith('charlatan'):\n            candidate = int(statement.split()[1])\n            candidates[candidate - 1] = not candidates[candidate - 1]\n        elif statement.startswith('not'):\n            statement = statement.replace('not', '')\n            speaker = int(speaker)\n            if statement.startswith('truther'):\n                candidate = int(statement.split()[1])\n                candidates[candidate - 1] = not candidates[candidate - 1]\n            elif statement.startswith('fabulist'):\n                candidate = int(statement.split()[1])\n                candidates[candidate - 1] = not candidates[candidate - 1]\n            elif statement.startswith('charlatan'):\n                candidate = int(statement.split()[1])\n                candidates[candidate - 1] = candidates[candidate - 1]\n        elif statement.startswith('and'):\n            statement = statement.replace('and', '')\n            first, second = statement.split()\n            if first.startswith('truther'):\n                candidate1 = int(first.split()[1])\n                candidates[candidate1 - 1] = True\n            elif first.startswith('fabulist'):\n                candidate1 = int(first.split()[1])\n                candidates[candidate1 - 1] = False\n            elif first.startswith('charlatan'):\n                candidate1 = int(first.split()[1])\n                candidates[candidate1 - 1] = candidates[candidate1 - 1]\n\n            if second.startswith('truther'):\n                candidate2 = int(second.split()[1])\n                candidates[candidate2 - 1] = True\n            elif second.startswith('fabulist'):\n                candidate2 = int(second.split()[1])\n                candidates[candidate2 - 1] = False\n            elif second.startswith('charlatan'):\n                candidate2 = int(second.split()[1])\n                candidates[candidate2 - 1] = candidates[candidate2 - 1]\n        elif statement.startswith('xor'):\n            statement = statement.replace('xor', '')\n            first, second = statement.split()\n            if first.startswith('truther'):\n                candidate1 = int(first.split()[1])\n                candidates[candidate1 - 1] = True\n            elif first.startswith('fabulist'):\n                candidate1 = int(first.split()[1])\n                candidates[candidate1 - 1] = False\n            elif first.startswith('charlatan'):\n                candidate1 = int(first.split()[1])\n                candidates[candidate1 - 1] = candidates[candidate1 - 1]\n\n            if second.startswith('truther'):\n                candidate2 = int(second.split()[1])\n                candidates[candidate2 - 1] = True\n            elif second.startswith('fabulist'):\n                candidate2 = int(second.split()[1])\n                candidates[candidate2 - 1] = False\n            elif second.startswith('charlatan'):\n                candidate2 = int(second.split()[1])\n                candidates[candidate2 - 1] = candidates[candidate2 - 1]\n\n    result = []\n    for candidate in candidates:\n        if candidate:\n            result.append('truther')\n        elif not candidate:\n            result.append('fabulist')\n        else:\n            result.append('charlatan')\n\n    return '\\n'.join(result) "
    },
    {
        "number": 3171,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_lines = stdin.split(\"\\n\")\n    N, K = map(int, input_lines[0].split())\n\n    # Initialize character types and last_speaker variable\n    char_types = [\"unknown\"] * N\n    last_speaker = None\n\n    # Process utterances\n    for i in range(1, K + 1):\n        speaker, utterance = input_lines[i].split(\" \", 1)\n        speaker = int(speaker)\n\n        # Check for charlatan\n        if last_speaker is not None and char_types[speaker - 1] == \"unknown\":\n            if utterance == f\"charlatan {speaker}\":\n                char_types[speaker - 1] = \"charlatan\"\n            elif utterance == f\"not charlatan {speaker}\":\n                char_types[speaker - 1] = \"truther\"\n            elif last_speaker == speaker and utterance.startswith(\"not charlatan\"):\n                char_types[speaker - 1] = \"fabulist\"\n\n        # Check for truther or fabulist\n        if last_speaker is not None and char_types[speaker - 1] == \"unknown\":\n            if utterance.startswith(\"truther\") or utterance.startswith(\"fabulist\"):\n                subject = int(utterance.split()[-1])\n                if char_types[subject - 1] != \"unknown\":\n                    if utterance.startswith(\"truther\"):\n                        char_types[speaker - 1] = \"truther\"\n                    else:\n                        char_types[speaker - 1] = \"fabulist\"\n\n        last_speaker = speaker\n\n    # Generate output\n    output = \"\"\n    for char_type in char_types:\n        output += char_type + \"\\n\"\n\n    return output.rstrip()"
    },
    {
        "number": 3172,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_fruits(fruits, line):\n        count = 0\n        for x, y in fruits:\n            if (y - line[0]) * (y - line[1]) <= 0:\n                count += 1\n        return count\n\n    def max_fruits(fruits):\n        fruits = [(x, y) for x, y in fruits]\n        fruits.sort()\n        lines = [(x, 10000 * y) for x, y in fruits] + [(x, -10000 * y) for x, y in fruits]\n        lines.sort()\n        max_count = 0\n        for i in range(len(lines) - 1):\n            max_count = max(max_count, count_fruits(fruits, (lines[i], lines[i + 1])))\n        return max_count\n\n    n = int(stdin.readline().strip())\n    fruits = [tuple(map(float, stdin.readline().strip().split())) for _ in range(n)]\n    print(max_fruits(fruits))"
    },
    {
        "number": 3172,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    fruits = [list(map(float, stdin.readline().strip().split())) for _ in range(n)]\n    swipes = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx, dy = fruits[i][0] - fruits[j][0], fruits[i][1] - fruits[j][1]\n            d = dx ** 2 + dy ** 2\n            if d == 0:\n                swipes.append((fruits[i][0], fruits[i][1], fruits[j][0], fruits[j][1]))\n            elif d > 0:\n                cx, cy = (fruits[i][0] + fruits[j][0]) / 2, (fruits[i][1] + fruits[j][1]) / 2\n                r = ((fruits[i][0] - cx) ** 2 + (fruits[i][1] - cy) ** 2) ** 0.5\n                if r < 1:\n                    swipes.append((fruits[i][0], fruits[i][1], fruits[j][0], fruits[j][1]))\n\n    swipes_count = [0] * n\n    for swipe in swipes:\n        swipe_count = 0\n        for i in range(n):\n            if (fruits[i][0] - swipe[0]) * (swipe[1] - swipe[3]) - (swipe[2] - fruits[i][0]) * (swipe[1] - fruits[i][1]) == 0:\n                swipe_count += 1\n        for i in range(n):\n            swipes_count[i] = max(swipes_count[i], swipe_count - (fruits[i][0] - swipe[0]) * (swipe[1] - swipe[3]) + (swipe[2] - fruits[i][0]) * (swipe[1] - fruits[i][1]))\n\n    return max(swipes_count)"
    },
    {
        "number": 3172,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    fruits = []\n    for i in range(1, n+1):\n        x, y = map(float, lines[i].split())\n        fruits.append((x, y))\n    \n    # Helper functions\n    def cross_product(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    def distance(a, b):\n        return ((a[0] - b[0])**2 + (a[1] - b[1])**2)**0.5\n\n    def is_between(a, c, b):\n        return abs(cross_product(c, a) - cross_product(a, b)) < 1e-6\n\n    def is_intersecting(fruit1, fruit2):\n        return distance(fruit1, fruit2) <= 2\n\n    def is_sliceable(fruit, swipe):\n        return is_between(swipe[0], fruit, swipe[1]) or is_between(swipe[1], fruit, swipe[0])\n\n    # Find swipes\n    swipes = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if is_intersecting(fruits[i], fruits[j]):\n                swipes.append((fruits[i], fruits[j]))\n\n    # Count sliceable fruits\n    max_sliceable = 0\n    for fruit in fruits:\n        count = sum(1 for swipe in swipes if is_sliceable(fruit, swipe))\n        max_sliceable = max(max_sliceable, count)\n\n    return str(max_sliceable)"
    },
    {
        "number": 3172,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    fruits = []\n    for _ in range(n):\n        x, y = map(float, stdin.readline().split())\n        fruits.append((x, y))\n\n    def is_intersect(a, b, c, d):\n        def cross(p, q, r):\n            return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0])\n\n        return (a <= c <= b or a <= d <= b) and cross((a, 0), (b, 0), (c, d)) != 0\n\n    max_sliced = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            count = 2\n            for k in range(j + 1, n):\n                if is_intersect(*fruits[i], *fruits[j], *fruits[k]):\n                    count += 1\n            max_sliced = max(max_sliced, count)\n\n    return str(max_sliced)"
    },
    {
        "number": 3172,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_cross(a, b, c, d):\n        if (a <= c <= b) or (a <= d <= b):\n            return True\n        return False\n\n    def is_intersect(a, b, c, d):\n        if is_cross(a[0], a[1], c[0], c[1]) and is_cross(b[0], b[1], d[0], d[1]):\n            return True\n        return False\n\n    def max_slice(fruits):\n        max_slices = 0\n        for i in range(len(fruits)):\n            for j in range(i + 1, len(fruits)):\n                if is_intersect(fruits[i], fruits[j], (0, 1), (0, -1)):\n                    max_slices = max(max_slices, i + j + 1)\n        return max_slices\n\n    input_list = stdin.strip().split('\\n')\n    n = int(input_list[0])\n    fruits = [tuple(map(float, fruit.split())) for fruit in input_list[1:]]\n\n    return str(max_slice(fruits))"
    },
    {
        "number": 3172,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def slope(p1, p2):\n        if p1[0] == p2[0]:\n            return float('inf')\n        return (p2[1] - p1[1]) / (p2[0] - p1[0])\n\n    def intersection(s1, s2):\n        x1, y1, x2, y2 = s1[0][0], s1[0][1], s1[1][0], s1[1][1]\n        x3, y3, x4, y4 = s2[0][0], s2[0][1], s2[1][0], s2[1][1]\n\n        d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if d == 0:\n            return None\n\n        t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / d\n        u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / d\n\n        if 0 <= t <= 1 and 0 <= u <= 1:\n            return (x1 + t * (x2 - x1), y1 + t * (y2 - y1))\n\n        return None\n\n    def fruits_sliced(swipe, fruits):\n        sliced = 0\n        for fruit in fruits:\n            if swipe[0][0] <= fruit[0] <= swipe[1][0] and swipe[0][1] <= fruit[1] <= swipe[1][1]:\n                sliced += 1\n            elif intersection(swipe, fruit):\n                sliced += 1\n        return sliced\n\n    n = int(stdin.readline())\n    fruits = []\n    for i in range(n):\n        x, y = map(float, stdin.readline().strip().split())\n        fruits.append((x, y))\n\n    max_sliced = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            swipe_slope = slope(fruits[i], fruits[j])\n            sliced = fruits_sliced((fruits[i], fruits[j]), fruits)\n            max_sliced = max(max_sliced, sliced)\n\n    return str(max_sliced)"
    },
    {
        "number": 3172,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def count_fruits(sx, sy, ex, ey):\n        count = 0\n        for x, y in fruits:\n            if (sy - ey) * (x - sx) == (sx - ex) * (y - sy):\n                count += 1\n        return count\n\n    n = int(stdin.readline().strip())\n    fruits = [list(map(float, stdin.readline().strip().split())) for _ in range(n)]\n\n    max_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_count = max(max_count, count_fruits(*fruits[i], *fruits[j]))\n\n    return str(max_count)"
    },
    {
        "number": 3172,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    fruits = []\n    for _ in range(n):\n        x, y = map(float, stdin.readline().strip().split())\n        fruits.append((x, y))\n\n    def is_cross(p1, p2, q1, q2):\n        return (p1[0] < q1[0] < p2[0] or p1[0] > q1[0] > p2[0]) and (q1[1] < p1[1] < q2[1] or q1[1] > p1[1] > q2[1])\n\n    max_fruits = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            count = 2\n            for k in range(j + 1, n):\n                if is_cross(fruits[i], fruits[j], fruits[k], fruits[k]):\n                    count += 1\n            max_fruits = max(max_fruits, count)\n\n    return str(max_fruits)"
    },
    {
        "number": 3172,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def slope(p1, p2):\n        if p1[0] == p2[0]:\n            return float('inf')\n        return (p2[1] - p1[1]) / (p2[0] - p1[0])\n\n    def intersection(p1, p2, p3, p4):\n        s1 = slope(p1, p2)\n        s2 = slope(p3, p4)\n\n        if s1 == s2:\n            return None\n\n        b1 = p1[1] - s1 * p1[0]\n        b2 = p3[1] - s2 * p3[0]\n\n        x = (b2 - b1) / (s1 - s2)\n        y = s1 * x + b1\n\n        if min(p1[0], p2[0]) <= x <= max(p1[0], p2[0]) and min(p3[0], p4[0]) <= x <= max(p3[0], p4[0]):\n            return (x, y)\n        return None\n\n    def is_between(p1, p2, p3):\n        return min(p1[0], p2[0]) <= p3[0] <= max(p1[0], p2[0]) and min(p1[1], p2[1]) <= p3[1] <= max(p1[1], p2[1])\n\n    def is_intersecting(p1, p2, p3, p4):\n        if is_between(p1, p2, p3) or is_between(p1, p2, p4):\n            return True\n        if is_between(p3, p4, p1) or is_between(p3, p4, p2):\n            return True\n        return False\n\n    n = int(stdin.readline().strip())\n    fruits = [tuple(map(float, stdin.readline().strip().split())) for _ in range(n)]\n\n    max_slices = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if is_intersecting(fruits[i], fruits[j], fruits[k], fruits[l]):\n                        max_slices = max(max_slices, 4)\n                    else:\n                        for p1, p2 in ((fruits[i], fruits[j]), (fruits[i], fruits[k]), (fruits[i], fruits[l]), (fruits[j], fruits[k]), (fruits[j], fruits[l]), (fruits[k], fruits[l])):\n                            if is_intersecting(fruits[i], fruits[j], fruits[k], fruits[l]):\n                                max_slices = max(max_slices, 3)\n                            else:\n                                p3 = intersection(p1, p2, fruits[k], fruits[l])\n                                if p3 and is_between(p1, p2, p3):\n                                    max_slices = max(max_slices, 2)\n\n    return str(max_slices)"
    },
    {
        "number": 3172,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    fruits = []\n    for _ in range(n):\n        x, y = map(float, stdin.readline().strip().split())\n        fruits.append((x, y))\n\n    # Sort fruits by x-coordinate\n    fruits.sort(key=lambda x: x[0])\n\n    def is_intersect(a, b):\n        return a[0] <= b[0] <= a[1] or a[0] <= b[1] <= a[1]\n\n    max_slices = 0\n    for i in range(n):\n        left_bound = fruits[i][0] - 1\n        right_bound = fruits[i][0] + 1\n        slices = 1\n        for j in range(n):\n            if i == j:\n                continue\n            if is_intersect((left_bound, right_bound), (fruits[j][0] - 1, fruits[j][0] + 1)):\n                slices += 1\n                left_bound = min(left_bound, fruits[j][0] - 1)\n                right_bound = max(right_bound, fruits[j][0] + 1)\n        max_slices = max(max_slices, slices)\n\n    return str(max_slices)"
    },
    {
        "number": 3173,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    R, C, K = map(int, stdin.split('\\n')[0].split())\n    grid = stdin.split('\\n')[1:R+1]\n    scores = list(map(int, stdin.split('\\n')[R+1].split()))\n\n    # Initialize variables\n    max_score = 0\n    ball_x = -1\n    ball_y = 0\n    belt_directions = ['?'] * C\n\n    def get_ball_position(ball_x: int, ball_y: int, belt_directions: list) -> tuple:\n        if ball_y == R:\n            return -1, -1\n\n        # Move ball\n        if grid[ball_y][ball_x] == 'R':\n            ball_x += 1\n        elif grid[ball_y][ball_x] == 'L':\n            ball_x -= 1\n        elif grid[ball_y][ball_x] == '?':\n            if belt_directions[ball_x] == 'R':\n                ball_x += 1\n            elif belt_directions[ball_x] == 'L':\n                ball_x -= 1\n\n        # Check if ball is still inside the grid\n        if ball_x < 0 or ball_x >= C or grid[ball_y][ball_x] == 'X':\n            return -1, -1\n\n        return ball_x, ball_y\n\n    def set_belt_direction(ball_x: int, ball_y: int, belt_directions: list) -> None:\n        if grid[ball_y][ball_x] == '?':\n            if ball_x > 0 and grid[ball_y][ball_x - 1] == 'R':\n                belt_directions[ball_x] = 'R'\n            elif ball_x < C - 1 and grid[ball_y][ball_x + 1] == 'L':\n                belt_directions[ball_x] = 'L'\n\n    def update_score(ball_x: int, ball_y: int, max_score: int) -> int:\n        if ball_y == R:\n            return max_score\n\n        if grid[ball_y][ball_x] == 'R' or grid[ball_y][ball_x] == 'L':\n            ball_x, ball_y = get_ball_position(ball_x, ball_y, belt_directions)\n            if ball_x == -1:\n                return max_score\n            update_score(ball_x, ball_y, max_score)\n\n        if grid[ball_y][ball_x] == '?':\n            set_belt_direction(ball_x, ball_y, belt_directions)\n\n        if grid[ball_y][ball_x] not in ('R', 'L', '?'):\n            max_score += scores[ball_x]\n\n        return max_score\n\n    # Main loop\n    while ball_x != -1 and ball_y < R:\n        ball_x, ball_y = get_ball_position(ball_x, ball_y, belt_directions)\n        if ball_x == -1:\n            break\n        max_score = update_score(ball_x, ball_y, max_score)\n\n    return str(max_score)"
    },
    {
        "number": 3173,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    R, C, K = map(int, stdin.readline().split())\n    grid = []\n    for i in range(R):\n        grid.append(list(stdin.readline().strip()))\n    score = list(map(int, stdin.readline().split()))\n\n    # Set conveyor belts\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '?':\n                grid[i][j] = 'R' if j == 0 else 'L'\n\n    # Find initial position\n    for j in range(C):\n        if grid[R - 1][j] == 'R' or grid[R - 1][j] == 'L':\n            i = R - 1\n            while i >= 0:\n                if grid[i][j] == 'R':\n                    i -= 1\n                elif grid[i][j] == 'L':\n                    i += 1\n                elif grid[i][j] == '.':\n                    i -= 1\n                else:\n                    break\n            if grid[i][j] == '.':\n                break\n\n    # Calculate final score\n    final_score = 0\n    for j in range(C):\n        if grid[i][j] == '.':\n            final_score += score[j]\n\n    return str(final_score)"
    },
    {
        "number": 3173,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def maximize_score(R: int, C: int, K: int, grid: List[List[str]], scores: List[int]) -> int:\n        def can_move(row: int, col: int, direction: str) -> Tuple[int, int]:\n            if direction == 'R':\n                if col + 1 < C and grid[row][col + 1] != 'X':\n                    return row, col + 1\n            elif direction == 'L':\n                if col - 1 >= 0 and grid[row][col - 1] != 'X':\n                    return row, col - 1\n            return -1, -1\n\n        def traverse_grid(row: int, col: int, total_score: int) -> int:\n            if total_score >= 10**20:\n                return total_score\n\n            if row == R - 1:\n                total_score += scores[col]\n\n            direction = 'R' if grid[row][col] == 'R' else 'L' if grid[row][col] == 'L' else '?'\n\n            if direction == '?':\n                next_row, next_col = can_move(row, col, 'R')\n                if next_row != -1 and next_col != -1:\n                    grid[row][col] = 'R'\n                    total_score = traverse_grid(next_row, next_col, total_score)\n\n                grid[row][col] = '?'\n                next_row, next_col = can_move(row, col, 'L')\n                if next_row != -1 and next_col != -1:\n                    grid[row][col] = 'L'\n                    total_score = traverse_grid(next_row, next_col, total_score)\n\n                grid[row][col] = '?'\n            else:\n                next_row, next_col = can_move(row, col, direction)\n                if next_row != -1 and next_col != -1:\n                    total_score = traverse_grid(next_row, next_col, total_score)\n\n            return total_score\n\n        max_score = 0\n        for i in range(K):\n            for j in range(C):\n                if grid[i][j] == '?':\n                    grid[i][j] = 'R'\n                    max_score = max(max_score, traverse_grid(0, 0, 0))\n                    grid[i][j] = 'L'\n                    max_score = max(max_score, traverse_grid(0, 0, 0))\n                    grid[i][j] = '?'\n        return max_score\n\n    def parse_input(stdin: str) -> Tuple[int, int, int, List[List[str]], List[int]]:\n        lines = stdin.split('\\n')\n        R, C, K = map(int, lines[0].split())\n        grid = [list(lines[i + 1]) for i in range(R)]\n        scores = list(map(int, lines[-1].split()))\n        return R, C, K, grid, scores\n\n    R, C, K, grid, scores = parse_input(stdin)\n    return str(maximize_score(R, C, K, grid, scores))"
    },
    {
        "number": 3173,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_score(r, c, k, grid, scores):\n        max_score = 0\n        for direction in [\"R\", \"L\"]:\n            set_conveyor_belt(grid, direction)\n            for col in range(c):\n                ball_pos = (1, col)\n                score = simulate_exam(ball_pos, grid, scores, 0)\n                max_score = max(max_score, score)\n        return max_score\n\n    def set_conveyor_belt(grid, direction):\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j] == \"?\":\n                    grid[i][j] = direction\n\n    def simulate_exam(ball_pos, grid, scores, current_score, steps=0):\n        if steps > 10**20:\n            return current_score\n\n        row, col = ball_pos\n        if row == len(grid) and 0 <= col < len(grid[0]):\n            return current_score + scores[col]\n\n        ball_pos = move_ball(ball_pos, grid)\n        current_score += scores[col] if grid[row][col] == \".\" else 0\n        return simulate_exam(ball_pos, grid, scores, current_score, steps + 1)\n\n    def move_ball(ball_pos, grid):\n        row, col = ball_pos\n        if row == len(grid) or grid[row][col] == \"X\":\n            return None\n\n        if grid[row][col] == \".\":\n            next_row, next_col = row + 1, col\n        else:\n            next_row, next_col = row, col + (1 if grid[row][col] == \"R\" else -1)\n\n        if next_row == len(grid) and next_col >= 0 and next_col < len(grid[0]):\n            return (next_row, next_col)\n        else:\n            return None\n\n    stdin_list = stdin.split(\"\\n\")\n    r, c, k = map(int, stdin_list[0].split())\n    grid = [list(line) for line in stdin_list[1:-1]]\n    scores = list(map(int, stdin_list[-1].split()))\n\n    max_score = get_max_score(r, c, k, grid, scores)\n    return str(max_score)"
    },
    {
        "number": 3173,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.readline().split())\n\n    grid = [list(stdin.readline().rstrip()) for _ in range(R)]\n    scores = list(map(int, stdin.readline().split()))\n\n    # Your code goes here\n\n    # Set the conveyor belt in the first row to 'R' and the conveyor belt in the 4th row to 'L', then drop the ball from the 4th column\n\n    def drop_ball(row: int, col: int, direction: str) -> int:\n        if row == R - 1:\n            return scores[col]\n\n        if direction == 'R':\n            col += 1\n        else:\n            col -= 1\n\n        if 0 <= col < C:\n            if grid[row + 1][col] == 'X':\n                return 0\n            elif grid[row + 1][col] == '?':\n                if row + 1 == 2 * K - 1:\n                    return scores[col]\n                else:\n                    return drop_ball(row + 1, col, 'R') + drop_ball(row + 1, col, 'L')\n            else:\n                return drop_ball(row + 1, col, grid[row + 1][col])\n        else:\n            return 0\n\n    max_score = 0\n    for col in range(C):\n        if grid[0][col] in ('R', '?'):\n            max_score = max(max_score, drop_ball(0, col, 'R'))\n        if grid[0][col] in ('L', '?'):\n            max_score = max(max_score, drop_ball(0, col, 'L'))\n\n    return str(max_score)"
    },
    {
        "number": 3173,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_score(R, C, K, grid, scores):\n        max_score = float('-inf')\n        for col in range(C):\n            score = 0\n            ball_pos = [(0, col)]\n            while ball_pos:\n                new_ball_pos = []\n                for row, col in ball_pos:\n                    if row >= R * K:\n                        score += scores[col]\n                        continue\n                    cell = grid[row][col]\n                    if cell == 'X':\n                        break\n                    elif cell == 'R':\n                        new_ball_pos.append((row + 1, col))\n                    elif cell == 'L':\n                        new_ball_pos.append((row + 1, col - 1))\n                    elif cell == '?':\n                        new_ball_pos.append((row + 1, col - 1))\n                        new_ball_pos.append((row + 1, col + 1))\n                ball_pos = new_ball_pos\n            max_score = max(max_score, score + get_max_score(R, C, K - 1, grid[R:], scores))\n        return max_score\n\n    R, C, K = map(int, input().split())\n    grid = [list(input()) for _ in range(R)]\n    scores = list(map(int, input().split()))\n\n    return str(get_max_score(R, C, K, grid, scores))"
    },
    {
        "number": 3173,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.readline().split())\n    grid = []\n    for _ in range(R):\n        grid.append(stdin.readline().strip())\n    scores = list(map(int, stdin.readline().split()))\n\n    # Your code here\n    # Set the conveyor belts and set the initial position of the ball\n\n    return str(final_score)"
    },
    {
        "number": 3173,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    R, C, K = map(int, stdin.readline().split())\n    grid = []\n    for _ in range(R):\n        grid.append(list(stdin.readline().strip()))\n    scores = list(map(int, stdin.readline().split()))\n\n    # Set the initial state of the grid\n    ball_pos = (R - 1, 0)\n    conveyor_belt_directions = [None] * (R * C)\n\n    def move_ball(pos: tuple, direction: int) -> tuple:\n        row, col = pos\n        if direction == -1:\n            col -= 1\n        elif direction == 1:\n            col += 1\n        elif direction == 0:\n            row -= 1\n            col = 0\n        else:\n            raise ValueError(\"Invalid direction\")\n\n        if col < 0 or col >= C:\n            return None\n        if grid[row][col] == 'X':\n            return None\n        if grid[row][col] == 'L':\n            direction = -1\n        elif grid[row][col] == 'R':\n            direction = 1\n        elif grid[row][col] == '?':\n            if conveyor_belt_directions[row * C + col] is None:\n                direction = -1\n            else:\n                direction = conveyor_belt_directions[row * C + col]\n\n        if row == 0:\n            return (row, col), direction\n        if grid[row - 1][col] == '?':\n            conveyor_belt_directions[row * C + col] = -direction\n        return (row - 1, col), direction\n\n    def set_conveyor_belt(pos: tuple, direction: int) -> None:\n        conveyor_belt_directions[pos[0] * C + pos[1]] = direction\n\n    def simulate(pos: tuple, direction: int) -> int:\n        total_score = 0\n        num_cells = 0\n        while pos is not None:\n            if grid[pos[0]][pos[1]] == '?':\n                set_conveyor_belt(pos, direction)\n            elif grid[pos[0]][pos[1]] in 'RL?':\n                direction = -direction\n            pos, direction = move_ball(pos, direction)\n            if grid[pos[0]][pos[1]] in scores:\n                total_score += scores[pos[1]]\n            num_cells += 1\n            if num_cells >= 10 ** 20:\n                break\n        return total_score\n\n    max_score = float('-inf')\n    for i in range(C):\n        for direction in (-1, 1):\n            ball_pos = (R - 1, i)\n            conveyor_belt_directions = [None] * (R * C)\n            set_conveyor_belt((R - 1, i), direction)\n            max_score = max(max_score, simulate(ball_pos, direction))\n\n    return str(max_score)"
    },
    {
        "number": 3173,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        input_data = stdin.split('\\n')\n        R, C, K = map(int, input_data[0].split())\n        grid = [list(input_data[i]) for i in range(1, R + 1)]\n        scores = list(map(int, input_data[-1].split()))\n        return R, C, K, grid, scores\n\n    def set_conveyor_belt(grid):\n        conveyor_belt = []\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == '?':\n                    conveyor_belt.append((i, j))\n        return conveyor_belt\n\n    def drop_ball(grid, conveyor_belt, ball_position):\n        i, j = ball_position\n        while True:\n            if i == R - 1 and j < C and grid[i][j] != 'X':\n                return scores[j]\n            if i < R - 1 and grid[i][j] == 'L':\n                j -= 1\n            elif i < R - 1 and grid[i][j] == 'R':\n                j += 1\n            elif i < R - 1 and grid[i][j] == '?':\n                if (i, j) in conveyor_belt:\n                    conveyor_belt.remove((i, j))\n                    if len(conveyor_belt) == 0:\n                        return 0\n                    i, j = conveyor_belt[0]\n                else:\n                    return 0\n            i += 1\n\n    R, C, K, grid, scores = read_input()\n    conveyor_belt = set_conveyor_belt(grid)\n    max_score = 0\n\n    for j in range(C):\n        if grid[0][j] != 'X' and (0, j) not in conveyor_belt:\n            score = drop_ball(grid, conveyor_belt, (0, j))\n            max_score = max(max_score, score)\n\n    return str(max_score)"
    },
    {
        "number": 3173,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.readline().split())\n    grid = []\n    for i in range(R):\n        grid.append(list(stdin.readline().strip()))\n    points = list(map(int, stdin.readline().split()))\n\n    # Your code goes here\n\n    return str(final_score)"
    },
    {
        "number": 3174,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(city1, city2):\n        return ((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2) ** 0.5\n\n    def is_happy(county, k):\n        for i in range(len(county)):\n            for j in range(i + 1, len(county)):\n                if (county[i][2] + county[j][2]) % k == 0:\n                    return True\n        return False\n\n    def find_min_d(cities, k):\n        cities.sort(key=lambda x: x[2])\n        max_residents = max(cities, key=lambda x: x[2])[2]\n        min_d = float('inf')\n\n        for d in range(1, int(max_residents * 2) + 1):\n            counties = []\n            for city in cities:\n                county_index = -1\n                for i, county in enumerate(counties):\n                    if any(distance(city, c) <= d for c in county):\n                        county_index = i\n                        break\n                if county_index == -1:\n                    counties.append([city])\n                else:\n                    counties[county_index].append(city)\n\n            if any(is_happy(county, k) for county in counties):\n                min_d = min(min_d, d)\n\n        return min_d\n\n    lines = stdin.split('\\n')\n    n, k = map(int, lines[0].split())\n    cities = [list(map(int, line.split())) for line in lines[1:n + 1]]\n\n    return '{:.3f}'.format(find_min_d(cities, k))"
    },
    {
        "number": 3174,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def distance(city1, city2):\n        return ((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2) ** 0.5\n\n    def check_happiness(county_residents, K):\n        for i in range(len(county_residents)):\n            for j in range(i + 1, len(county_residents)):\n                if (county_residents[i] + county_residents[j]) % K == 0:\n                    return True\n        return False\n\n    input_data = list(map(lambda x: x.strip().split(), stdin.split('\\n')[1:]))\n    N, K = map(int, input_data[0])\n    cities = [(int(x[0]), int(x[1]), int(x[2])) for x in input_data[1:N + 1]]\n\n    cities.sort(key=lambda x: x[2], reverse=True)\n\n    counties = []\n    for city in cities:\n        if not counties:\n            counties.append([city])\n            continue\n        added = False\n        for county in counties:\n            if any(distance(city, c) <= D for c in county):\n                county.append(city)\n                added = True\n                break\n        if not added:\n            counties.append([city])\n\n    happiness = False\n    while not happiness:\n        D += 0.001\n        happiness = any(check_happiness([c[2] for c in county], K) for county in counties)\n\n    return f\"{D:.3f}\"\n"
    },
    {
        "number": 3174,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(city1, city2):\n        return ((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2) ** 0.5\n\n    def is_happy(county, k):\n        residents = [city[2] for city in county]\n        for i in range(len(residents)):\n            for j in range(i + 1, len(residents)):\n                if (residents[i] + residents[j]) % k == 0:\n                    return True\n        return False\n\n    def get_counties(cities, d):\n        counties = []\n        while cities:\n            county = [cities[0]]\n            cities.remove(cities[0])\n            while True:\n                to_remove = []\n                for city in cities:\n                    for c in county:\n                        if distance(city, c) <= d and city not in county:\n                            county.append(city)\n                            to_remove.append(city)\n                            break\n                for city in to_remove:\n                    cities.remove(city)\n                if not to_remove:\n                    break\n            counties.append(county)\n        return counties\n\n    input_data = [line.strip().split() for line in stdin.split(\"\\n\")]\n    n, k = map(int, input_data[0])\n    cities = [(int(x), int(y), int(residents)) for x, y, residents in input_data[1:n + 1]]\n\n    left, right = 0, 1e6\n    while right - left > 1e-3:\n        mid = (left + right) / 2\n        counties = get_counties(cities, mid)\n        happy = any(is_happy(county, k) for county in counties)\n        if happy:\n            right = mid\n        else:\n            left = mid\n\n    return f\"{right:.3f}\""
    },
    {
        "number": 3174,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def find_counties(cities, D):\n        counties = []\n        for i in range(len(cities)):\n            county = [i]\n            for j in range(len(cities)):\n                if i != j and distance(*cities[i], *cities[j]) <= D:\n                    county.append(j)\n            if county not in counties:\n                counties.append(county)\n        return counties\n\n    def is_happy(counties, K):\n        for county in counties:\n            residents = [residents_count[i] for i in county]\n            for i in range(len(residents)):\n                for j in range(i + 1, len(residents)):\n                    if (residents[i] + residents[j]) % K == 0:\n                        return True\n        return False\n\n    N, K = map(int, stdin.readline().split())\n    cities = [tuple(map(int, stdin.readline().split())) for _ in range(N)]\n    residents_count = [city[2] for city in cities]\n\n    left, right = 0, 100000000\n    while left < right:\n        mid = (left + right) / 2\n        counties = find_counties(cities, mid)\n        if is_happy(counties, K):\n            right = mid\n        else:\n            left = mid + 1e-3\n    return format(left, \".3f\")"
    },
    {
        "number": 3174,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from math import sqrt\n    \n    def distance(city1, city2):\n        return sqrt((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2)\n    \n    def is_happy(county, k):\n        for i in range(len(county)):\n            for j in range(i + 1, len(county)):\n                if (county[i][2] + county[j][2]) % k == 0:\n                    return True\n        return False\n    \n    input_data = list(map(lambda x: x.split(), stdin.split('\\n')))\n    n, k = map(int, input_data[0])\n    cities = [(int(x[0]), int(x[1]), int(x[2])) for x in input_data[1:n + 1]]\n    \n    max_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_distance = max(max_distance, distance(cities[i], cities[j]))\n    \n    left, right = 0, max_distance\n    while left < right:\n        mid = (left + right) / 2\n        counties = []\n        for city in cities:\n            if not counties or distance(city, counties[-1][0]) > mid:\n                counties.append([city])\n            else:\n                counties[-1].append(city)\n        \n        if any(is_happy(county, k) for county in counties):\n            right = mid\n        else:\n            left = mid + 1e-6\n    \n    return '{:.3f}'.format(right)"
    },
    {
        "number": 3174,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def distance(city1, city2):\n        return ((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2) ** 0.5\n\n    def is_happy(county, k):\n        for i in range(len(county)):\n            for j in range(i, len(county)):\n                if (county[i][2] + county[j][2]) % k == 0:\n                    return True\n        return False\n\n    def find_min_d(cities, k):\n        cities.sort(key=lambda x: x[2])\n        min_d = float('inf')\n\n        for i in range(len(cities)):\n            county = [cities[i]]\n            for j in range(i + 1, len(cities)):\n                if distance(cities[i], cities[j]) <= min_d and not is_happy(county, k):\n                    county.append(cities[j])\n            if is_happy(county, k):\n                for city1 in county:\n                    for city2 in county:\n                        if city1 != city2:\n                            min_d = min(min_d, distance(city1, city2))\n\n        return round(min_d, 3)\n\n    lines = stdin.strip().split('\\n')\n    n, k = map(int, lines[0].split())\n    cities = [list(map(int, line.split())) for line in lines[1:]]\n\n    return str(find_min_d(cities, k))"
    },
    {
        "number": 3174,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    cities = []\n    for _ in range(N):\n        x, y, k = map(int, stdin.readline().split())\n        cities.append((x, y, k))\n\n    def distance(city1, city2):\n        return ((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2) ** 0.5\n\n    def find_counties(max_distance):\n        counties = []\n        for city1 in cities:\n            county_found = False\n            for i, county in enumerate(counties):\n                for city2 in county:\n                    if distance(city1, city2) <= max_distance:\n                        counties[i].append(city1)\n                        county_found = True\n                        break\n                if county_found:\n                    break\n            if not county_found:\n                counties.append([city1])\n        return counties\n\n    def is_prime_minister_happy(counties):\n        for county in counties:\n            residents_sum = sum(city[2] for city in county)\n            if residents_sum % K == 0:\n                return True\n        return False\n\n    left, right = 0, 1e6\n    while abs(right - left) > 1e-3:\n        mid = (left + right) / 2\n        counties = find_counties(mid)\n        if is_prime_minister_happy(counties):\n            right = mid\n        else:\n            left = mid\n\n    return f\"{right:.3f}\""
    },
    {
        "number": 3174,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def is_happy(county, residents_sum):\n        return residents_sum % K == 0\n\n    def can_connect_cities(city1, city2, D):\n        return distance(city1, city2) <= D\n\n    def find_min_D(cities):\n        cities.sort(key=lambda x: x[2])\n        min_D = 0\n        for i in range(len(cities) - 1):\n            if not can_connect_cities(cities[i], cities[i + 1], min_D):\n                min_D = distance(cities[i], cities[i + 1])\n        return min_D\n\n    def is_prime_minister_happy(D):\n        counties = []\n        for city in cities:\n            added = False\n            for county in counties:\n                if any(can_connect_cities(city, county_city, D) for county_city in county):\n                    county.append(city)\n                    added = True\n                    break\n            if not added:\n                counties.append([city])\n\n        for county in counties:\n            residents_sum = sum(residents for x, y, residents in county)\n            if is_happy(county, residents_sum):\n                return True\n        return False\n\n    N, K = map(int, stdin.readline().strip().split())\n    cities = [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n\n    min_D = find_min_D(cities)\n    while not is_prime_minister_happy(min_D):\n        min_D += 0.001\n\n    return '{:.3f}'.format(min_D)"
    },
    {
        "number": 3174,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_happy(cities, k):\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                if (cities[i][2] + cities[j][2]) % k == 0:\n                    return True\n        return False\n\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    n, k = map(int, input_data[0].split())\n    cities = [list(map(int, city.split())) for city in input_data[1:]]\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_distance = max(max_distance, distance(cities[i], cities[j]))\n\n    lo, hi = 0, max_distance\n    while lo < hi:\n        mid = (lo + hi) / 2\n        if is_happy(cities, k) and all(distance(cities[i], cities[j]) <= mid for i in range(n) for j in range(i + 1, n)):\n            hi = mid\n        else:\n            lo = mid + 1e-9\n\n    return '{:.3f}'.format(lo)"
    },
    {
        "number": 3174,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_happy(county, k):\n        for i in range(len(county)):\n            for j in range(i + 1, len(county)):\n                if (county[i][2] + county[j][2]) % k == 0:\n                    return True\n        return False\n\n    def find_min_d(cities, k):\n        min_d = float('inf')\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                d = distance(cities[i], cities[j])\n                if d < min_d:\n                    min_d = d\n        return min_d\n\n    def can_build_roads(cities, min_d, k):\n        counties = []\n        for city in cities:\n            found = False\n            for county in counties:\n                if any(distance(city, c) <= min_d for c in county):\n                    county.append(city)\n                    found = True\n                    break\n            if not found:\n                counties.append([city])\n\n        for county in counties:\n            if is_happy(county, k):\n                return True\n        return False\n\n    lines = stdin.split('\\n')\n    n, k = map(int, lines[0].split())\n    cities = [list(map(int, line.split())) for line in lines[1:n + 1]]\n\n    min_d = find_min_d(cities, k)\n    while not can_build_roads(cities, min_d, k):\n        min_d += 0.001\n\n    return '{:.3f}'.format(min_d) "
    },
    {
        "number": 3175,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, segments = int(stdin[0]), list(map(int, stdin[2:].split()))\n    \n    if n < 3:\n        return \"0\"\n    \n    def polygon_area(sides):\n        perimeter = sum(sides)\n        return abs(perimeter / 2) ** 2 - sum(a ** 2 for a in sides) + sides[0] ** 2\n\n    def max_polygon_area(segments):\n        segments.sort(reverse=True)\n        max_area = 0\n\n        for i in range(1, n):\n            max_area = max(max_area, polygon_area(segments[:i]))\n\n        return max_area\n\n    return f\"{max_polygon_area(segments):.3f}\""
    },
    {
        "number": 3175,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.strip().split()\n    n = int(line[0])\n    lengths = list(map(int, line[1:]))\n    \n    if n < 3:\n        return \"0\"\n    \n    def polygon_area(sides):\n        perimeter = sum(sides)\n        return abs(perimeter / 2) ** 2 - sum(s ** 2 for s in sides) / 16\n    \n    max_area = 0\n    \n    for i in range(3, n + 1):\n        for combo in itertools.combinations(lengths, i):\n            max_area = max(max_area, polygon_area(combo))\n            \n    return f\"{max_area:.3f}\""
    },
    {
        "number": 3175,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, *segments = map(int, stdin.split())\n    segments.sort(reverse=True)\n    area = 0\n\n    def calculate_area(width, height):\n        return width * height\n\n    for i in range(n - 2):\n        if segments[i] + segments[i + 1] > segments[i + 2]:\n            area = max(area, calculate_area(segments[i], segments[i + 1]))\n        else:\n            area = max(area, calculate_area(segments[i], segments[i + 1]),\n                         calculate_area(segments[i + 1], segments[i + 2]),\n                         calculate_area(segments[i], segments[i + 2]))\n\n    return f\"{area:.3f}\""
    },
    {
        "number": 3175,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, *segments = list(map(int, stdin.split()))\n    area = 0.0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            width = segments[i] + segments[j]\n            height = max(segments[i], segments[j])\n            current_area = width * height\n            if current_area > area:\n                area = current_area\n                \n    return format(area, \".3f\")"
    },
    {
        "number": 3175,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def polygon_area(sides):\n        perimeter = sum(sides)\n        return abs(perimeter / 2) ** 2 - sum(map(lambda x: x ** 2, sides)) / 16\n\n    n, *segments = list(map(int, stdin.split()))\n    max_area = 0\n\n    for i in range(1, n + 1):\n        for combo in itertools.combinations(segments, i):\n            max_area = max(max_area, polygon_area(combo))\n\n    return f\"{max_area:.3f}\""
    },
    {
        "number": 3175,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    max_area = 0\n\n    def calculate_area(lengths):\n        if len(lengths) < 3:\n            return 0\n        a, b, c = sorted(lengths)[:3]\n        if a + b <= c:\n            return 0\n        else:\n            return 0.5 * (a + b) * c\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_area = max(max_area, calculate_area(lengths[i:j + 1]))\n\n    return f\"{max_area:.3f}\""
    },
    {
        "number": 3175,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    lengths = input_list[1:]\n    max_area = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            max_area = max(max_area, lengths[i] * lengths[j])\n\n    return format(max_area, \".3f\")"
    },
    {
        "number": 3175,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    n = input_list[0]\n    segments = input_list[1:]\n    max_area = 0\n\n    def calculate_area(lengths):\n        polygon_sides = len(lengths)\n        area = 0\n        for i in range(polygon_sides):\n            j = (i + 1) % polygon_sides\n            area += lengths[i] * lengths[j]\n        return abs(area) / 2\n\n    def backtrack(start, length_remaining, polygon):\n        nonlocal max_area\n        if length_remaining == 0:\n            area = calculate_area(polygon)\n            max_area = max(max_area, area)\n        else:\n            for i in range(start, n):\n                if length_remaining >= segments[i]:\n                    polygon.append(segments[i])\n                    backtrack(i, length_remaining - segments[i], polygon)\n                    polygon.pop()\n\n    backtrack(0, sum(segments), [])\n    return f\"{max_area:.3f}\""
    },
    {
        "number": 3175,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    fence_segments = sorted(input_data[1:])\n\n    def find_largest_area(fence_segments):\n        if len(fence_segments) < 3:\n            return 0\n        area = 0\n        for i in range(len(fence_segments) - 2):\n            for j in range(i + 1, len(fence_segments) - 1):\n                for k in range(j + 1, len(fence_segments)):\n                    a, b, c = fence_segments[i], fence_segments[j], fence_segments[k]\n                    if a + b > c and b + c > a and c + a > b:\n                        s = (a + b + c) / 2\n                        area = max(area, (s * (s - a) * (s - b) * (s - c)) ** (1 / 2))\n        return area\n\n    return str(round(find_largest_area(fence_segments), 3))"
    },
    {
        "number": 3175,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    line = list(map(int, stdin.split()))\n    n = line[0]\n    segments = line[1:]\n    max_area = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            area = segments[i] * segments[j]\n            if area > max_area:\n                max_area = area\n\n    return str(round(max_area, 3))"
    },
    {
        "number": 3176,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    data = [line.split() for line in stdin.split('\\n')]\n    N, K = map(int, data[0])\n    plants = [(int(X), int(Y), int(F)) for X, Y, F in data[1:N + 1]]\n\n    # Initialize variables\n    visited = [False] * N\n    jumps = []\n    curr_energy = 0\n    curr_pos = plants[0][:2]\n\n    # Greedy algorithm to find the sequence of jumps\n    while not all(visited):\n        best_pos = None\n        max_flies = 0\n        for i, (X, Y, F) in enumerate(plants):\n            if visited[i]:\n                continue\n            if (X > curr_pos[0] and X > best_pos[0] and Y == curr_pos[1]) or (Y > curr_pos[1] and Y > best_pos[1] and X == curr_pos[0]):\n                best_pos = (X, Y)\n                max_flies = F\n        if best_pos is None:\n            break\n        visited[plants.index((*best_pos, max_flies))] = True\n        curr_pos = best_pos\n        curr_energy += max_flies\n        if curr_energy >= K:\n            jumps.append(curr_pos)\n            curr_energy -= K\n\n    # Check if a sequence of jumps exists\n    if not jumps:\n        return \"No solution exists\"\n\n    # Output the final energy level and the sequence of jumps\n    output = [curr_energy] + [len(jumps) + 1] + jumps + [plants[-1][:2]]\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3176,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def can_jump(x1, y1, x2, y2):\n        return (x2 > x1 and y2 == y1) or (y2 > y1 and x2 == x1)\n\n    def dfs(x1, y1, flies, energy, visited, path):\n        if not flies:\n            return 0\n        if (x1, y1) not in visited:\n            visited.add((x1, y1))\n            path.append((x1, y1))\n\n        max_energy = 0\n        for i in range(len(plants)):\n            if can_jump(x1, y1, plants[i][0], plants[i][1]):\n                energy_needed = abs(plants[i][0] - x1) + abs(plants[i][1] - y1)\n                if energy >= energy_needed and flies[i] > 0:\n                    new_flies = [f - flies[i] for f in flies]\n                    new_energy = energy - energy_needed + flies[i]\n                    max_energy = max(max_energy, dfs(plants[i][0], plants[i][1], new_flies, new_energy, visited, path))\n\n        if not path or (x1, y1) == path[-1]:\n            path.pop()\n            visited.remove((x1, y1))\n        return max_energy\n\n    N, K = map(int, stdin.readline().split())\n    plants = []\n    flies = []\n    for _ in range(N):\n        x, y, f = map(int, stdin.readline().split())\n        plants.append((x, y))\n        flies.append(f)\n\n    max_energy = dfs(plants[0][0], plants[0][1], flies, 0, set(), [])\n    return f\"{max_energy}\\n{len(plants)}\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in plants)"
    },
    {
        "number": 3176,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x1, y1, energy):\n        for i in range(len(plants)):\n            x2, y2, flies = plants[i]\n            if (x2 > x1 and y2 == y1) or (y2 > y1 and x2 == x1):\n                if energy >= K:\n                    energy -= K\n                    energy += flies\n                    if i == len(plants) - 1:\n                        return energy\n                    else:\n                        return dfs(x2, y2, energy)\n        return None\n\n    N, K = map(int, stdin.readline().split())\n    plants = [list(map(int, stdin.readline().split())) for _ in range(N)]\n\n    max_energy = 0\n    max_path = []\n\n    for i in range(N):\n        energy = dfs(0, 0, 0)\n        if energy is not None and energy > max_energy:\n            max_energy = energy\n            max_path = [i]\n        elif energy == max_energy:\n            max_path.append(i)\n\n    return f\"{max_energy}\\n{len(max_path)}\\n\" + \"\\n\".join(f\"{x + 1} {y + 1}\" for x, y, _ in [plants[i] for i in max_path])"
    },
    {
        "number": 3176,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    plants = []\n\n    for _ in range(N):\n        X, Y, F = map(int, stdin.readline().split())\n        plants.append((X, Y, F))\n\n    plants.sort(key=lambda x: (x[0], x[1]))\n    energy = 0\n    sequence = []\n\n    for i in range(N):\n        x, y, flies = plants[i]\n        energy += flies\n\n        if energy >= K:\n            sequence.append(i + 1)\n            energy -= K\n\n    return f\"{energy}\\n{len(sequence)}\\n\" + \"\\n\".join(map(str, sequence))"
    },
    {
        "number": 3176,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from queue import PriorityQueue\n    \n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    def is_valid_move(p1, p2):\n        return p1[0] < p2[0] and p1[1] == p2[1] or p1[0] == p2[0] and p1[1] < p2[1]\n    \n    def get_next_moves(current_position, plants):\n        next_moves = []\n        for i, plant in enumerate(plants):\n            if is_valid_move(current_position, plant[0]):\n                next_moves.append((distance(current_position, plant[0]), i))\n        return next_moves\n    \n    def find_sequence(plants, target_plant, k):\n        pq = PriorityQueue()\n        visited = [False] * len(plants)\n        energy = [0] * len(plants)\n        \n        pq.put((0, 0, plants[0][0]))  # Distance, # of flies, position\n        energy[0] = plants[0][1]\n        \n        while not pq.empty():\n            dist, flies, pos = pq.get()\n            \n            if pos == target_plant:\n                break\n            \n            if visited[pos]:\n                continue\n            \n            visited[pos] = True\n            \n            for d, i in get_next_moves(plants[pos][0], plants):\n                new_pos = i\n                new_dist = dist + d\n                new_flies = flies + plants[new_pos][1]\n                \n                if not visited[new_pos] and new_flies >= k:\n                    pq.put((new_dist, new_flies - k, new_pos))\n                    energy[new_pos] = max(energy[new_pos], energy[pos] + k)\n                    \n        return energy\n    \n    data = list(map(lambda x: tuple(map(int, x.split())), stdin.split('\\n')[1:]))\n    N, K = map(int, stdin.split('\\n')[0].split())\n    \n    plants = [(p, f) for p, y, f in data]\n    sequence = find_sequence(plants, N - 1, K)\n    energy = max(sequence)\n    path = []\n    \n    for i, e in enumerate(sequence):\n        if e == energy:\n            path.append(i)\n    \n    output = f\"{energy}\\n{len(path)}\\n\" + '\\n'.join(map(lambda x: f\"{x + 1} {data[x][1]}\", path))\n    \n    return output"
    },
    {
        "number": 3176,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_jump(x1, y1, x2, y2):\n        if x2 > x1 and y2 == y1:\n            return True\n        if y2 > y1 and x2 == x1:\n            return True\n        return False\n\n    def find_next_jump(energy, current_plant, jumps, plants):\n        max_jump_energy = 0\n        next_jump = None\n        for i in range(current_plant + 1, len(plants)):\n            x1, y1, f1 = plants[current_plant]\n            x2, y2, f2 = plants[i]\n            if is_valid_jump(x1, y1, x2, y2):\n                if energy + f1 >= K:\n                    jump_energy = f2 + (energy + f1 - K)\n                    if jump_energy > max_jump_energy:\n                        max_jump_energy = jump_energy\n                        next_jump = i\n        return next_jump, max_jump_energy\n\n    def find_jump_sequence(plants):\n        jumps = []\n        current_plant = 0\n        energy = plants[0][2]\n        next_jump = 1\n        while next_jump is not None:\n            jumps.append((current_plant + 1, next_jump + 1))\n            current_plant = next_jump\n            energy = max(0, energy + plants[current_plant][2] - K)\n            next_jump, energy = find_next_jump(energy, current_plant, jumps, plants)\n        return jumps\n\n    def output_result(jumps):\n        energy = sum([plants[i - 1][2] for i, _ in jumps])\n        return f\"{energy}\\n{len(jumps)}\\n\" + \"\\n\".join(\n            \" \".join(map(str, j)) for j in jumps\n        )\n\n    N, K = map(int, stdin.split())\n    plants = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    jumps = find_jump_sequence(plants)\n    return output_result(jumps) + \"\\n\" "
    },
    {
        "number": 3176,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(x1, y1, x2, y2, k):\n        return (x2 > x1 and y2 == y1) or (y2 > y1 and x2 == x1)\n\n    def dfs(x, y, n, f, k, visited, energy, path):\n        if k < 0:\n            return\n        if n == N:\n            if energy > max_energy:\n                max_energy[0] = energy\n                sequence[0] = path.copy()\n            return\n        if visited[x][y]:\n            return\n        visited[x][y] = True\n        for i in range(len(plants)):\n            x2, y2, f2 = plants[i]\n            if is_valid_move(x, y, x2, y2, k):\n                dfs(x2, y2, n + 1, f2, k - K, visited, energy + f2, path + [(i + 1, x2, y2)])\n        visited[x][y] = False\n\n    N, K = map(int, stdin.readline().split())\n    plants = [list(map(int, stdin.readline().split())) for _ in range(N)]\n    max_energy = [0]\n    sequence = [[]]\n    visited = [[False for _ in range(N + 1)] for _ in range(N + 1)]\n    dfs(plants[0][0], plants[0][1], 1, plants[0][2], K, visited, plants[0][2], [(1, plants[0][0], plants[0][1])])\n    return f\"{max_energy[0]}\\n{len(sequence[0])}\\n\" + \"\\n\".join(f\"{p} {x} {y}\" for p, x, y in sequence[0])"
    },
    {
        "number": 3176,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x1, y1, f1, x2, y2, f2, energy, path):\n        if (x2, y2) in visited:\n            return\n        visited.add((x2, y2))\n        path.append((x2, y2))\n        if x2 == N:\n            return\n        for i in range(N):\n            if i not in visited and (Y[i] == y2 or X[i] == x2) and F[i] * K <= energy:\n                dfs(x2, y2, f2, X[i], Y[i], F[i], energy - F[i] * K, path)\n\n    N, K = map(int, stdin.readline().strip().split())\n    X, Y, F = [], [], []\n    for _ in range(N):\n        x, y, f = map(int, stdin.readline().strip().split())\n        X.append(x)\n        Y.append(y)\n        F.append(f)\n\n    visited = set()\n    path = [(1, 1)]\n    dfs(1, 1, F[0], 1, 2, F[1], K * F[0], path)\n\n    return f\"{K * F[0]}\\n{len(path)}\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in path) + \"\\n\""
    },
    {
        "number": 3176,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x2 - x1) + abs(y2 - y1)\n\n    def dfs(x, y, F, visited, plants, energy, k):\n        nonlocal max_energy\n        nonlocal best_path\n        if x == plants[-1][0] and y == plants[-1][1]:\n            if energy > max_energy:\n                max_energy = energy\n                best_path = [str(p[2]) for p in plants]\n            return\n\n        for i in range(len(plants)):\n            if (i not in visited) and (distance(x, y, plants[i][0], plants[i][1]) == 1):\n                visited.append(i)\n                new_energy = energy + plants[i][2]\n                if new_energy >= k:\n                    dfs(plants[i][0], plants[i][1], F, visited.copy(), plants, new_energy - k, k)\n\n    N, K = map(int, stdin.readline().split())\n    plants = []\n    for _ in range(N):\n        x, y, f = map(int, stdin.readline().split())\n        plants.append((x, y, f))\n\n    max_energy = 0\n    best_path = []\n    dfs(plants[0][0], plants[0][1], plants[0][2], [0], plants, 0, K)\n\n    return f\"{max_energy}\\n{len(best_path)}\\n\" + \" \".join(best_path)"
    },
    {
        "number": 3176,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    plants = [list(map(int, stdin.readline().split())) for _ in range(N)]\n    dp = [[0] * N for _ in range(N)]\n\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            if (plants[i][0] < plants[j][0] and plants[i][1] == plants[j][1]) or (plants[i][1] < plants[j][1] and plants[i][0] == plants[j][0]):\n                dp[i][j] = plants[i][2] + plants[j][2]\n\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j])\n\n    energy = 0\n    for i in range(N):\n        energy = max(energy, dp[0][i] * K + plants[0][2])\n\n    result = [1]\n    for i in range(1, N):\n        if dp[0][i] * K + plants[0][2] == energy:\n            result.append(i + 1)\n\n    return f\"{energy}\\n{len(result)}\\n{' '.join(map(str, result))}\""
    },
    {
        "number": 3177,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    perm = list(map(int, lines[1].split()))\n    swaps = [list(map(int, lines[i].split())) for i in range(2, 2 + M)]\n\n    def count_inversions(perm):\n        inv_count = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if perm[i] > perm[j]:\n                    inv_count += 1\n        return inv_count\n\n    def is_sorted(perm):\n        for i in range(N - 1):\n            if perm[i] > perm[i + 1]:\n                return False\n        return True\n\n    def arrange(perm, swaps):\n        count = 0\n        while not is_sorted(perm):\n            inv_count = count_inversions(perm)\n            if inv_count % 2 == 0:\n                for swap in swaps:\n                    if perm[swap[0] - 1] > perm[swap[1] - 1]:\n                        perm[swap[0] - 1], perm[swap[1] - 1] = perm[swap[1] - 1], perm[swap[0] - 1]\n                        count += 1\n                        break\n            else:\n                for i in range(N - 1):\n                    if perm[i] > perm[i + 1]:\n                        for swap in swaps:\n                            if (i == swap[0] - 1) or (i == swap[1] - 1) or (i + 1 == swap[0] - 1) or (i + 1 == swap[1] - 1):\n                                perm[swap[0] - 1], perm[swap[1] - 1] = perm[swap[1] - 1], perm[swap[0] - 1]\n                                count += 1\n                                break\n                        break\n        return count\n\n    return str(arrange(perm, swaps))"
    },
    {
        "number": 3177,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_inversions(arr):\n        return sum(arr[i] > arr[j] for i in range(len(arr)) for j in range(i + 1, len(arr)))\n\n    def arrange(n, allowed_swaps):\n        swaps = 0\n        while count_inversions(permutation) > 0:\n            for i in range(n - 1):\n                for j in range(i + 1, n):\n                    if (i + 1, j + 1) in allowed_swaps:\n                        if permutation[i] > permutation[j]:\n                            permutation[i], permutation[j] = permutation[j], permutation[i]\n                            swaps += 1\n                            break\n            if count_inversions(permutation) == 0:\n                return swaps\n        return swaps\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    permutation = list(map(int, lines[1].split()))\n    allowed_swaps = set(tuple(map(int, line.split())) for line in lines[2:])\n\n    result = arrange(n, allowed_swaps)\n    return str(result) "
    },
    {
        "number": 3177,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_swaps(permutation, swaps):\n        n = len(permutation)\n        visited = [False] * n\n        visited[0] = True\n        stack = [permutation[0]]\n        total_swaps = 0\n\n        while stack:\n            curr = stack.pop()\n            if curr != n:\n                visited[curr] = True\n                next_element = permutation[curr]\n                if not visited[next_element]:\n                    stack.append(curr)\n                    stack.append(next_element)\n            else:\n                total_swaps += 1\n                curr_index = stack.pop()\n                while curr_index != 0:\n                    prev_index = swaps[curr_index]\n                    curr_index = prev_index\n                    total_swaps += 1\n\n        return total_swaps\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    permutation = list(map(int, lines[1].split()))\n    swaps = []\n    for i in range(M):\n        swaps.append(list(map(int, lines[i + 2].split())))\n\n    return str(get_min_swaps(permutation, swaps))"
    },
    {
        "number": 3177,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_sorted(arr):\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                return False\n        return True\n\n    def find_cycle_length(start, visited, arr):\n        cycle_length = 0\n        while start not in visited:\n            visited.add(start)\n            start = arr[start]\n            cycle_length += 1\n        return cycle_length\n\n    def min_swaps(arr):\n        visited = set()\n        total_swaps = 0\n        for i in range(len(arr)):\n            if i not in visited:\n                cycle_length = find_cycle_length(i, visited, arr)\n                total_swaps += (cycle_length - 1)\n        return total_swaps\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    permutation = list(map(int, lines[1].split()))\n    allowed_swaps = []\n    for i in range(M):\n        A, B = map(int, lines[i + 2].split())\n        allowed_swaps.append((A - 1, B - 1))\n\n    # Reverse permutation\n    for i in range(N):\n        permutation[permutation[i] - 1] = N - i\n\n    # Perform allowed swaps\n    for A, B in allowed_swaps:\n        permutation[A], permutation[B] = permutation[B], permutation[A]\n\n    # Count swaps to reverse permutation\n    return str(min_swaps(permutation))"
    },
    {
        "number": 3177,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_inversions(arr):\n        if len(arr) <= 1:\n            return 0\n        mid = len(arr) // 2\n        left_inv = count_inversions(arr[:mid])\n        right_inv = count_inversions(arr[mid:])\n        split_inv = count_split_inversions(arr, mid)\n        return left_inv + right_inv + split_inv\n\n    def count_split_inversions(arr, mid):\n        left, right = arr[:mid], arr[mid:]\n        i, j, split_inv = 0, 0, 0\n        left.append(float('inf'))\n        right.append(float('inf'))\n\n        for k in range(len(arr)):\n            if left[i] < right[j]:\n                i += 1\n            else:\n                j += 1\n            split_inv += len(left) - i\n\n        return split_inv\n\n    def find_min_swaps(arr, swaps):\n        n = len(arr)\n        adj_list = {i: [] for i in range(1, n + 1)}\n\n        for i, j in swaps:\n            adj_list[i].append(j)\n            adj_list[j].append(i)\n\n        visited = [False] * (n + 1)\n        q = []\n\n        def bfs(src):\n            visited[src] = True\n            q.append(src)\n\n            while q:\n                node = q.pop(0)\n                for neighbor in adj_list[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        q.append(neighbor)\n\n        for i in range(1, n + 1):\n            if not visited[i]:\n                bfs(i)\n\n        return n - sum(visited[1:])\n\n    lines = stdin.strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    arr = list(map(int, lines[1].split()))\n    swaps = [list(map(int, line.split())) for line in lines[2:]]\n\n    return str(find_min_swaps(arr, swaps))"
    },
    {
        "number": 3177,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_inversions(arr):\n        return sum(arr[i] > arr[j] for i, j in combinations(range(len(arr)), 2))\n\n    def arrange(perm, swaps):\n        for swap in swaps:\n            perm[swap[0] - 1], perm[swap[1] - 1] = perm[swap[1] - 1], perm[swap[0] - 1]\n\n    N, M = map(int, stdin.readline().split())\n    perm = list(map(int, stdin.readline().split()))\n    swaps = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    initial_inversions = count_inversions(perm)\n    arrange(perm, swaps)\n    final_inversions = count_inversions(perm)\n\n    return str(initial_inversions - final_inversions)"
    },
    {
        "number": 3177,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input into lines\n    lines = stdin.split('\\n')\n    \n    # Parse the first line to get N and M\n    N, M = map(int, lines[0].split())\n    \n    # Parse the second line to get the permutation\n    permutation = list(map(int, lines[1].split()))\n    \n    # Parse the allowed swaps\n    allowed_swaps = []\n    for i in range(2, 2 + M):\n        A, B = map(int, lines[i].split())\n        allowed_swaps.append((A, B))\n    \n    # Initialize the graph\n    graph = {i: [] for i in range(1, N + 1)}\n    for A, B in allowed_swaps:\n        graph[A].append(B)\n        graph[B].append(A)\n    \n    # Initialize the visited set and the queue\n    visited = set()\n    queue = [(1, 0)]  # (current_number, swap_count)\n    \n    # Perform BFS to find the minimum number of swaps\n    while queue:\n        current_number, swap_count = queue.pop(0)\n        \n        if current_number not in visited:\n            visited.add(current_number)\n            \n            if current_number == N:\n                return str(swap_count)\n            \n            for neighbor in graph[current_number]:\n                queue.append((neighbor, swap_count + 1))\n    \n    # If there is no solution, return -1\n    return \"-1\""
    },
    {
        "number": 3177,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_inversions(arr):\n        n = len(arr)\n        if n <= 1:\n            return 0\n        mid = n // 2\n        left = count_inversions(arr[:mid])\n        right = count_inversions(arr[mid:])\n        split = 0\n        i, j = 0, mid\n        left_sorted = arr[:mid]\n        right_sorted = arr[mid:]\n        while i < mid and j < n:\n            if left_sorted[i] <= right_sorted[j]:\n                arr[i + j] = left_sorted[i]\n                i += 1\n            else:\n                arr[i + j] = right_sorted[j]\n                j += 1\n                split += mid - i\n        return left + right + split\n\n    def arrange(N, swaps):\n        arr = [i for i in range(1, N + 1)]\n        for a, b in swaps:\n            arr[a - 1], arr[b - 1] = arr[b - 1], arr[a - 1]\n        return count_inversions(arr)\n\n    params = [int(x) for x in stdin.split()]\n    N, M = params[0], params[1]\n    sequence = [int(x) for x in input().split()]\n    swaps = []\n    for _ in range(M):\n        swap = [int(x) for x in input().split()]\n        swaps.append(swap)\n\n    min_swaps = arrange(N, swaps)\n    return str(min_swaps) "
    },
    {
        "number": 3177,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_inversions(arr):\n        return sum([1 for i in range(len(arr)) if arr[i] != i + 1])\n\n    def bfs(start, end, swaps):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, swaps_count = queue.pop(0)\n            if current == end:\n                return swaps_count\n            if current not in visited:\n                visited.add(current)\n                for swap in swaps:\n                    if swap[0] in current or swap[1] in current:\n                        next_permutation = list(current)\n                        next_permutation[next_permutation.index(swap[0])] = swap[1]\n                        next_permutation[next_permutation.index(swap[1])] = swap[0]\n                        next_permutation = ''.join(next_permutation)\n                        queue.append((next_permutation, swaps_count + 1))\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    initial_permutation = lines[1]\n    allowed_swaps = [tuple(map(int, line.split())) for line in lines[2:]]\n\n    start = ''.join([str(i + 1) for i in range(N)])\n    end = ''.join([str(i + 1) for i in sorted(range(N), key=lambda x: initial_permutation[x])])\n\n    if count_inversions(initial_permutation) % 2 == 0:\n        return str(bfs(initial_permutation, end, allowed_swaps))\n    else:\n        return 'No solution exists.' "
    },
    {
        "number": 3177,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        N, M = map(int, stdin.readline().strip().split())\n        initial_sequence = list(map(int, stdin.readline().strip().split()))\n        allowed_swaps = []\n        for _ in range(M):\n            A, B = map(int, stdin.readline().strip().split())\n            allowed_swaps.append((A - 1, B - 1))\n        return N, initial_sequence, allowed_swaps\n\n    def find_min_swaps(N: int, initial_sequence: list, allowed_swaps: list) -> int:\n        # create a list of tuples containing the index and the value of each element in the initial sequence\n        indexed_sequence = [(i, initial_sequence[i]) for i in range(N)]\n\n        # sort the indexed sequence by the value of the elements\n        indexed_sequence.sort(key=lambda x: x[1])\n\n        # create a dictionary to store the final position of each element\n        final_positions = {initial_sequence[i]: i for i in range(N)}\n\n        # initialize a list to store the swaps made\n        swaps = []\n\n        # loop through the indexed sequence\n        for i in range(N):\n            # if the element is not in its final position, find the correct position for it\n            if indexed_sequence[i][1] != final_positions[indexed_sequence[i][1]]:\n                # loop through the allowed swaps\n                for swap in allowed_swaps:\n                    # if the swap involves the current element and the target position is free\n                    if (indexed_sequence[i][0], swap[1]) in swaps or (swap[1], indexed_sequence[i][0]) in swaps:\n                        # add the swap to the list\n                        swaps.append((indexed_sequence[i][0], swap[0]))\n                        # update the final position of the swapped elements\n                        final_positions[indexed_sequence[swap[0]][1]], final_positions[indexed_sequence[swap[1]][1]] = final_positions[indexed_sequence[swap[1]][1]], final_positions[indexed_sequence[swap[0]][1]]\n                        # break the loop\n                        break\n\n        return len(swaps)\n\n    N, initial_sequence, allowed_swaps = read_input()\n    min_swaps = find_min_swaps(N, initial_sequence, allowed_swaps)\n    return str(min_swaps)"
    },
    {
        "number": 3178,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(a, b, c):\n        return (a + b) % 3 != 1\n\n    def dfs(start, visited, cycle):\n        visited[start] = True\n        cycle.append(start)\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, cycle)\n        return cycle\n\n    def find_cycle(start, visited, cycle):\n        visited[start] = True\n        cycle.append(start)\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                find_cycle(neighbor, visited, cycle)\n        return cycle\n\n    def has_cycle(start, visited, cycle):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                find_cycle(neighbor, visited, cycle)\n        return cycle\n\n    def min_cost_decoration(n, m, roads):\n        cost = 0\n        for i in range(1, n + 1):\n            graph[i] = []\n\n        for a, b in roads:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        visited = [False] * (n + 1)\n        cycle = []\n        for i in range(1, n + 1):\n            if not visited[i]:\n                cycle = find_cycle(i, visited, cycle)\n\n        if len(cycle) == n:\n            for i in range(len(cycle)):\n                a = cycle[i]\n                b = cycle[(i + 1) % len(cycle)]\n                if not is_valid(decorations[a], decorations[b], cost):\n                    return -1\n                cost += decorations[a] + decorations[b]\n            return cost\n        else:\n            return -1\n\n    n, m = map(int, stdin.readline().split())\n    roads = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    decorations = [0] * (n + 1)\n    for i in range(1, n + 1):\n        visited = [False] * (n + 1)\n        cycle = []\n        if not has_cycle(i, visited, cycle):\n            for a, b in cycle:\n                decorations[a] = 1\n                decorations[b] = 1\n\n    return str(min_cost_decoration(n, m, roads))"
    },
    {
        "number": 3178,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, visited, start, current, cycle, visited_cycle):\n        visited[current] = True\n        visited_cycle[current] = True\n        cycle.append(current)\n\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, start, neighbor, cycle, visited_cycle):\n                    return True\n            elif neighbor == start and len(cycle) > 2:\n                return True\n\n        cycle.pop()\n        visited_cycle[current] = False\n        return False\n\n    def is_valid(graph, decorations):\n        for area, neighbors in graph.items():\n            for neighbor in neighbors:\n                if decorations[area] + decorations[neighbor] % 3 == 1:\n                    return False\n        return True\n\n    def decorate(graph, n, m, decorations):\n        min_cost = float('inf')\n        for i in range(3):\n            for j in range(3):\n                for k in range(3):\n                    if i + j + k == n - 1:\n                        decorations = [i, j, k] * (n // 3)\n                        if n % 3 != 0:\n                            for _ in range(n % 3):\n                                decorations.append(i)\n                                i = (i + 1) % 3\n\n                        if is_valid(graph, decorations):\n                            min_cost = min(min_cost, sum(decorations))\n\n        return min_cost if min_cost != float('inf') else -1\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    graph = {i: set() for i in range(1, n + 1)}\n\n    for i in range(m):\n        a, b = map(int, lines[i + 1].split())\n        graph[a].add(b)\n        graph[b].add(a)\n\n    return decorate(graph, n, m, [0] * n)"
    },
    {
        "number": 3178,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, visited, start, current, cycle):\n        visited[current] = True\n        cycle.append(current)\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, start, neighbor, cycle):\n                    return True\n            elif neighbor != start:\n                return True\n        cycle.pop()\n        return False\n\n    def is_valid_decoration(graph, decorations):\n        for area, neighbors in graph.items():\n            a, b = decorations[area], decorations[neighbors[0]]\n            if (a + b) % 3 == 1:\n                return False\n        return True\n\n    def min_cost_decoration(graph, n, m, decorations):\n        min_cost = float('inf')\n        for i in range(3):\n            if i not in decorations:\n                decorations[i] = [0] * m\n                cost = min_cost_decoration(graph, n, m, decorations)\n                if cost != -1:\n                    min_cost = min(min_cost, cost)\n                decorations.pop(i)\n        return min_cost\n\n    def peters_favorite_season(stdin: str) -> str:\n        n, m = map(int, stdin.split()[:2])\n        graph = {i: set() for i in range(1, n + 1)}\n        for i in range(m):\n            a, b = map(int, stdin.split()[2 + 2 * i:4 + 2 * i])\n            graph[a].add(b)\n            graph[b].add(a)\n\n        visited = [False] * (n + 1)\n        cycle = []\n        for area in range(1, n + 1):\n            if not visited[area]:\n                find_cycle(graph, visited, area, area, cycle)\n\n        if len(cycle) % 2 == 0:\n            return -1\n\n        decorations = {}\n        cost = min_cost_decoration(graph, n, m, decorations)\n        return str(cost)\n\n    return peters_favorite_season(stdin) "
    },
    {
        "number": 3178,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(costs):\n        for i in range(len(costs)):\n            for j in range(i + 1, len(costs)):\n                if (costs[i] + costs[j]) % 3 == 1:\n                    return False\n        return True\n\n    def dfs(start, visited, graph, costs):\n        total = 0\n        for neighbor, cost in graph[start]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                total += dfs(neighbor, visited, graph, costs)\n        return costs[start] + total\n\n    def find_cycle(start, visited, graph, costs):\n        cycle = set()\n        for neighbor, cost in graph[start]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                cycle |= find_cycle(neighbor, visited, graph, costs)\n        if costs[start] % 3 == 1:\n            cycle.add(start)\n        return cycle\n\n    def min_cost(n, m, roads):\n        graph = [[] for _ in range(n)]\n        for a, b in roads:\n            graph[a - 1].append((b - 1, 0))\n            graph[b - 1].append((a - 1, 0))\n\n        costs = [0] * n\n        for i in range(1, n):\n            if not graph[i]:\n                return -1\n\n        for i in range(n):\n            if len(graph[i]) == 1:\n                a, b = i, graph[i][0][0]\n                costs[a] = 2\n                costs[b] = 1\n                graph[a].pop()\n                graph[b].pop()\n\n        for i in range(n):\n            if costs[i] == 0:\n                costs[i] = 1\n\n        if not is_valid(costs):\n            return -1\n\n        total = sum(costs)\n        if total % 2 == 0:\n            return total\n\n        for i in range(n):\n            if costs[i] == 1:\n                costs[i] = 2\n                break\n\n        return min(min_cost(n, m, roads) for roads in permutations(costs))\n\n    stdin = list(map(int, stdin.split()))\n    n, m = stdin[0], stdin[1]\n    roads = [stdin[i:i + 2] for i in range(2, len(stdin), 2)]\n\n    return str(min_cost(n, m, roads))"
    },
    {
        "number": 3178,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n + 1)]\n    for a, b in roads:\n        adj[a].append(b)\n        adj[b].append(a)\n\n    # Perform DFS to check if it is possible to get from every area to every other area\n    def dfs(node, visited, areas):\n        if node not in visited:\n            visited.add(node)\n            areas.add(node)\n            for neighbor in adj[node]:\n                dfs(neighbor, visited, areas)\n\n    visited = set()\n    areas = set()\n    dfs(1, visited, areas)\n\n    if len(areas) != n:\n        return -1\n\n    # Calculate the sum of costs for all possible cycles\n    def cycle_cost(cycle):\n        total = 0\n        for i in range(len(cycle)):\n            a = cycle[i]\n            b = cycle[(i + 1) % len(cycle)]\n            for road in roads:\n                if a in road and b in road:\n                    total += (road.index(a) + road.index(b)) % 3\n                    break\n        return total\n\n    # Check if it is possible to meet Peter's properties for each cycle\n    def is_valid_cycle(cycle):\n        for i in range(len(cycle)):\n            a = cycle[i]\n            b = cycle[(i + 1) % len(cycle)]\n            for road in roads:\n                if a in road and b in road:\n                    if (road.index(a) + road.index(b)) % 3 == 1:\n                        return False\n                    break\n        return cycle_cost(cycle) % 2 == 1\n\n    # Find all valid cycles\n    def find_cycles(node, visited, cycle, cycles):\n        if node not in visited:\n            visited.add(node)\n            cycle.append(node)\n            for neighbor in adj[node]:\n                if neighbor != node:\n                    find_cycles(neighbor, visited, cycle, cycles)\n            if len(cycle) > 2:\n                if is_valid_cycle(cycle):\n                    cycles.append(tuple(cycle))\n            cycle.pop()\n            visited.remove(node)\n\n    visited = set()\n    cycle = []\n    cycles = []\n    find_cycles(1, visited, cycle, cycles)\n\n    # Calculate the minimum cost of decorating the city\n    min_cost = float('inf')\n    for cycle in cycles:\n        min_cost = min(min_cost, sum(road.index(cycle[i]) + road.index(cycle[i + 1]) for i in range(len(cycle) - 1)) % 3))\n\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
        "number": 3178,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(costs):\n        for a, b in roads:\n            if (costs[a - 1] + costs[b - 1]) % 3 == 1:\n                return False\n        return True\n\n    def dfs(start, visited, cycle_cost):\n        if visited[start]:\n            return cycle_cost % 2 == 1\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if not dfs(neighbor, visited, cycle_cost + costs[neighbor]):\n                    return False\n        visited[start] = False\n        return True\n\n    n, m = map(int, stdin.split())\n    roads = [list(map(int, input().split())) for _ in range(m)]\n    costs = [0] * n\n    graph = [[] for _ in range(n)]\n\n    for a, b in roads:\n        a -= 1\n        b -= 1\n        graph[a].append(b)\n        graph[b].append(a)\n\n    for i in range(n):\n        if len(graph[i]) == 0:\n            costs[i] = 0\n        elif len(graph[i]) == 1:\n            costs[i] = 1\n        else:\n            costs[i] = 2\n\n    while True:\n        if is_valid(costs):\n            visited = [False] * n\n            cycle_cost = 0\n            if all(dfs(i, visited, cycle_cost) for i in range(n)):\n                return sum(costs)\n        else:\n            for i in range(n):\n                if costs[i] == 0:\n                    costs[i] = 1\n                elif costs[i] == 1:\n                    costs[i] = 2\n                else:\n                    costs[i] = 0\n                    break\n            else:\n                return -1\n\n\ndef"
    },
    {
        "number": 3178,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(adjacency_list, visited, current_node, cost):\n        if (current_node, cost) in visited:\n            return False\n        visited.add((current_node, cost))\n        for neighbor, neighbor_cost in adjacency_list[current_node]:\n            if (neighbor_cost + cost) % 3 == 1:\n                continue\n            if not is_valid(adjacency_list, visited, neighbor, (cost + neighbor_cost) % 3):\n                return False\n        return True\n\n    def find_cycle(adjacency_list, visited, current_node, cost, cycle=None):\n        if (current_node, cost) in visited:\n            index = visited.index((current_node, cost))\n            return cycle[index:] + [(current_node, cost)]\n        visited.add((current_node, cost))\n        for neighbor, neighbor_cost in adjacency_list[current_node]:\n            if (neighbor_cost + cost) % 3 == 1:\n                continue\n            found_cycle = find_cycle(adjacency_list, visited, neighbor, (cost + neighbor_cost) % 3, cycle + [(current_node, cost)])\n            if found_cycle:\n                return found_cycle\n        return None\n\n    n, m = map(int, stdin.readline().split())\n    adjacency_list = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        adjacency_list[a-1].append((b-1, 0))\n        adjacency_list[b-1].append((a-1, 0))\n\n    for i in range(3):\n        if is_valid(adjacency_list, set(), 0, i):\n            cycle = find_cycle(adjacency_list, [], 0, i)\n            if cycle and sum(cost for node, cost in cycle) % 2 == 1:\n                return i\n\n    return -1"
    },
    {
        "number": 3178,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_cycle(cycle: List[int], costs: List[int]) -> bool:\n        for i in range(len(cycle)):\n            a = cycle[i]\n            b = cycle[(i + 1) % len(cycle)]\n            if (costs[a - 1] + costs[b - 1]) % 3 == 1:\n                return False\n        return True\n\n    def dfs(start: int, visited: Set[int], costs: List[int]) -> int:\n        if start in visited:\n            return 0\n        visited.add(start)\n        total = costs[start - 1]\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                total += dfs(neighbor, visited, costs)\n        return total\n\n    n, m = map(int, stdin.readline().strip().split())\n    graph = [[] for _ in range(n)]\n    costs = [0] * n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().strip().split())\n        graph[a - 1].append(b)\n        graph[b - 1].append(a)\n\n    for i in range(n):\n        cycle_found = False\n        for cycle in combinations(graph[i], 2):\n            if cycle_found:\n                break\n            if len(cycle[0]) == len(cycle[1]):\n                continue\n            for j in range(len(cycle[0])):\n                a = cycle[0][j]\n                b = cycle[1][j]\n                if (costs[a - 1] + costs[b - 1]) % 3 == 1:\n                    costs[a - 1] = (costs[a - 1] + 1) % 3\n                    costs[b - 1] = (costs[b - 1] + 1) % 3\n                    cycle_found = True\n                    break\n        if cycle_found:\n            continue\n        for cycle in combinations(graph[i], 3):\n            if is_valid_cycle(cycle, costs):\n                continue\n            for j in range(len(cycle[0])):\n                a = cycle[0][j]\n                b = cycle[1][j]\n                if (costs[a - 1] + costs[b - 1]) % 3 == 1:\n                    costs[a - 1] = (costs[a - 1] + 1) % 3\n                    costs[b - 1] = (costs[b - 1] + 1) % 3\n                    break\n\n    total = 0\n    visited = set()\n    for i in range(n):\n        if i in visited:\n            continue\n        total += dfs(i, visited, costs)\n        if total % 2 == 0:\n            return -1\n\n    return sum(costs)"
    },
    {
        "number": 3178,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(start, visited, graph):\n        cycle = [start]\n        while True:\n            visited[start] = True\n            cycle.append(start)\n            new_start = -1\n            for neighbor in graph[start]:\n                if not visited[neighbor]:\n                    new_start = neighbor\n                    break\n            if new_start == -1:\n                return []\n            if new_start == start:\n                return cycle\n            start = new_start\n\n    def is_valid_cycle(cycle, graph):\n        for i in range(1, len(cycle)):\n            a, b = sorted([cycle[i - 1], cycle[i]])\n            if (sum(graph[a][b]) + sum(graph[b][a])) % 3 == 1:\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    graph = [[[] for _ in range(n)] for _ in range(n)]\n    for i in range(m):\n        a, b = map(int, lines[i + 1].split())\n        a -= 1\n        b -= 1\n        graph[a][b].append(i)\n        graph[b][a].append(i)\n\n    visited = [False] * n\n    min_cost = float('inf')\n    for start in range(n):\n        if not visited[start]:\n            cycle = find_cycle(start, visited, graph)\n            if cycle:\n                if len(cycle) % 2 == 1 and is_valid_cycle(cycle, graph):\n                    min_cost = min(min_cost, sum(1 for neighbor in graph[cycle[0]][cycle[-1]] if len(neighbor) == 0))\n\n    return str(min_cost) if min_cost < float('inf') else '-1'"
    },
    {
        "number": 3178,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n\n    roads = []\n    for i in range(1, m + 1):\n        a, b = map(int, lines[i].split())\n        roads.append((a, b))\n\n    decorations = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                count = 0\n                for road in roads:\n                    if i in road and j in road:\n                        count += 1\n                if count % 2 == 1:\n                    if (decorations[i] + decorations[j]) % 3 == 1:\n                        return -1\n                    decorations[j] += 1\n\n    return sum(decorations)"
    },
    {
        "number": 3179,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def perimeter(vertices):\n        return sum(distance(vertices[i], vertices[(i + 1) % len(vertices)]) for i in range(len(vertices)))\n\n    def area(vertices):\n        return abs(sum(vertices[i][0] * vertices[(i + 1) % len(vertices)][1] - vertices[(i + 1) % len(vertices)][0] * vertices[i][1] for i in range(len(vertices)))) / 2\n\n    def find_side_length(peri, area):\n        return (peri / 4) / (area / area_canyon)\n\n    n, k = map(int, stdin.readline().split())\n    vertices = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    area_canyon = area(vertices)\n    peri_canyon = perimeter(vertices)\n\n    side_length = find_side_length(peri_canyon, area_canyon)\n\n    return f\"{side_length:.2f}\""
    },
    {
        "number": 3179,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def distance(point1, point2):\n        return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) ** 0.5\n\n    def area_of_polygon(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            area += points[i][0] * points[j][1]\n            area -= points[j][0] * points[i][1]\n        return abs(area) / 2\n\n    def is_inside(point, edges):\n        x, y = point\n        count = 0\n        for edge in edges:\n            x1, y1, x2, y2 = edge\n            if ((y1 <= y and y < y2) or (y2 <= y and y < y1)) and (x < (x2 - x1) * (y - y1) / (y2 - y1) + x1):\n                count += 1\n        return count % 2 == 1\n\n    def get_edges(points):\n        n = len(points)\n        edges = []\n        for i in range(n):\n            j = (i + 1) % n\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            edges.append((x1, y1, x2, y2))\n        return edges\n\n    def get_side_length(points, area, k):\n        n = len(points)\n        total_area = area_of_polygon(points)\n        per_map_area = total_area / k\n        side_length = 2 * (per_map_area / (n - 2)) ** 0.5\n        return side_length\n\n    n, k = map(int, stdin.readline().strip().split())\n    points = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    edges = get_edges(points)\n\n    min_side_length = float('inf')\n    for i in range(k):\n        side_length = get_side_length(points, area_of_polygon(points), k)\n        while True:\n            all_inside = True\n            for point in points:\n                if not is_inside(point, edges):\n                    all_inside = False\n                    break\n            if all_inside:\n                min_side_length = min(min_side_length, side_length)\n                break\n            side_length += 1\n\n    return f\"{min_side_length:.2f}\""
    },
    {
        "number": 3179,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    polygon = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        polygon.append((x, y))\n\n    min_x, min_y, max_x, max_y = float('inf'), float('inf'), float('-inf'), float('-inf')\n\n    for x, y in polygon:\n        min_x = min(min_x, x)\n        min_y = min(min_y, y)\n        max_x = max(max_x, x)\n        max_y = max(max_y, y)\n\n    canyon_width = max_x - min_x\n    canyon_height = max_y - min_y\n\n    map_side_length = (canyon_width * canyon_height / k) ** 0.5\n\n    return '{:.2f}'.format(map_side_length)"
    },
    {
        "number": 3179,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def area_of_polygon(points):\n        n = len(points)\n        area = 0.0\n        for i in range(n):\n            j = (i + 1) % n\n            area += points[i][0] * points[j][1]\n            area -= points[j][0] * points[i][1]\n        return abs(area) / 2\n\n    def is_inside(p, polygon):\n        n = len(polygon)\n        for i in range(n):\n            a = polygon[i]\n            b = polygon[(i + 1) % n]\n            if (p[0] > a[0] and p[0] < b[0]) or (p[0] > b[0] and p[0] < a[0]):\n                y = (p[1] - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0]\n                if abs(y - p[0]) < 1e-6:\n                    return True\n        return False\n\n    def find_min_side_length(polygon, k):\n        n = len(polygon)\n        min_area = float('inf')\n        max_area = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for u in range(j + 1, n):\n                    for v in range(u + 1, n):\n                        points = [polygon[i], polygon[j], polygon[u], polygon[v]]\n                        area = area_of_polygon(points)\n                        min_area = min(min_area, area)\n                        max_area = max(max_area, area)\n\n        side_length = (max_area / k) ** 0.5\n        return side_length\n\n    n, k = map(int, stdin.split()[0:2])\n    polygon = [tuple(map(int, stdin.split()[2 * i + 2:2 * i + 4])) for i in range(n)]\n    min_side_length = find_min_side_length(polygon, k)\n    return '{:.2f}'.format(min_side_length)"
    },
    {
        "number": 3179,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    polygon = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        polygon.append((x, y))\n\n    # Sort the polygon points by their x-coordinate\n    polygon.sort(key=lambda x: x[0])\n\n    # Find the minimum bounding rectangle for the polygon\n    min_x, min_y, max_x, max_y = polygon[0][0], polygon[0][1], polygon[0][0], polygon[0][1]\n    for x, y in polygon[1:]:\n        min_x = min(min_x, x)\n        min_y = min(min_y, y)\n        max_x = max(max_x, x)\n        max_y = max(max_y, y)\n\n    # Calculate the width and height of the minimum bounding rectangle\n    width, height = max_x - min_x, max_y - min_y\n\n    # Calculate the side length of each square map\n    map_side_length = (k * (width * height)) ** (1 / 2)\n\n    # Round the side length to two decimal places\n    map_side_length = round(map_side_length, 2)\n\n    return str(map_side_length)"
    },
    {
        "number": 3179,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    polygon = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    \n    # Calculate the area of the polygon\n    area = abs(sum(x * y for x, y in zip(polygon, polygon[1:] + polygon[:1]))) / 2\n    \n    # Calculate the side length of each map\n    side_length = (area / k) ** 0.5\n    \n    # Round the side length to two decimal places\n    side_length = round(side_length, 2)\n    \n    return f\"{side_length:.2f}\""
    },
    {
        "number": 3179,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    polygon = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        polygon.append((x, y))\n\n    min_x, max_x = min(x for x, _ in polygon), max(x for x, _ in polygon)\n    min_y, max_y = min(y for _, y in polygon), max(y for _, y in polygon)\n\n    width = max_x - min_x\n    height = max_y - min_y\n\n    total_area = width * height\n    area_per_map = total_area / k\n\n    side_length = (area_per_map ** 0.5)\n    return '{:.2f}'.format(side_length)"
    },
    {
        "number": 3179,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    polygon = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n\n    for x, y in polygon:\n        x_min = min(x_min, x)\n        x_max = max(x_max, x)\n        y_min = min(y_min, y)\n        y_max = max(y_max, y)\n\n    width = x_max - x_min\n    height = y_max - y_min\n\n    min_side_length = min(width / k, height)\n\n    return f'{min_side_length:.2f}'"
    },
    {
        "number": 3179,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    polygon = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    \n    min_area = float('inf')\n    max_area = float('-inf')\n    \n    for i in range(len(polygon)):\n        area = abs(polygon[i-1][0]*polygon[i][1] - polygon[i][0]*polygon[i-1][1])\n        min_area = min(min_area, area)\n        max_area = max(max_area, area)\n        \n    area_per_map = max_area / k\n    \n    side_length = int((area_per_map / min_area) ** 0.5) + 1\n    \n    return '{:.2f}'.format(side_length)"
    },
    {
        "number": 3179,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def polygon_area(points):\n        area = 0\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % len(points)]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area) / 2\n\n    def find_coeffs(p1, p2):\n        a = (p1[1] - p2[1]) / (p1[0] - p2[0])\n        b = p1[1] - a * p1[0]\n        return a, b\n\n    def find_intersection(p1, p2, p3, p4):\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        x4, y4 = p4\n\n        d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if d == 0:\n            return None\n\n        a1 = (x1 * y2 - y1 * x2)\n        a2 = (x3 * y4 - y3 * x4)\n\n        x = (a1 * (x3 - x4) - (x1 - x2) * a2) / d\n        y = (a1 * (y3 - y4) - (y1 - y2) * a2) / d\n\n        if min(x1, x2) <= x <= max(x1, x2) and min(x3, x4) <= x <= max(x3, x4) and \\\n                min(y1, y2) <= y <= max(y1, y2) and min(y3, y4) <= y <= max(y3, y4):\n            return x, y\n        else:\n            return None\n\n    def is_inside(point, vertices):\n        x, y = point\n        n = len(vertices)\n        inside = False\n        j = n - 1\n        for i in range(n):\n            if ((vertices[i][1] <= y < vertices[j][1]) or (vertices[j][1] <= y < vertices[i][1])) and \\\n                    (x < (vertices[j][0] - vertices[i][0]) * (y - vertices[i][1]) / (vertices[j][1] - vertices[i][1]) + vertices[i][0]):\n                inside = not inside\n            j = i\n        return inside\n\n    def find_max_side_length(points, k):\n        area = polygon_area(points)\n        side_length = 2 * (area / k) ** 0.5\n        return side_length\n\n    def find_min_side_length(points, k):\n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        for x, y in points:\n            x_min, y_min, x_max, y_max = min(x_min, x), min(y_min, y), max(x_max, x), max(y_max, y)\n\n        side_length = max(x_max - x_min, y_max - y_min) / k ** (1 / 2)\n        while True:\n            maps = []\n            for i in range(k):\n                maps.append([(x_min + i * side_length, y_min), (x_min + (i + 1) * side_length, y_min),\n                               (x_min + (i + 1) * side_length, y_min + side_length), (x_min + i * side_length, y_min + side_length)])\n\n            complete = True\n            for point in points:\n                if not any(is_inside(point, map) for map in maps):\n                    complete = False\n                    break\n\n            if complete:\n                return side_length\n            else:\n                side_length += 0.0001\n                if k == 1:\n                    return side_length\n\n    n, k = map(int, stdin.read"
    },
    {
        "number": 3180,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, K, M = map(int, stdin.split('\\n')[0].split())\n    commands = stdin.split('\\n')[1:]\n\n    # Initialize canvas\n    canvas = [[1] * N for _ in range(N)]\n\n    # Implement PAINT, SAVE, and LOAD commands\n    saves = []\n    for command in commands:\n        if command.startswith('PAINT'):\n            c, x1, y1, x2, y2 = map(int, command.split()[1:])\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    canvas[i][j] = c\n        elif command.startswith('SAVE'):\n            saves.append(canvas.copy())\n        elif command.startswith('LOAD'):\n            canvas = saves[int(command.split()[1]) - 1]\n\n    # Generate output\n    output = '\\n'.join([' '.join(map(str, row)) for row in canvas])\n\n    return output"
    },
    {
        "number": 3180,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, K, M = map(int, stdin.split()[0:3])\n    commands = [line.split() for line in stdin.split('\\n')[1:]]\n\n    # Initialize the canvas\n    canvas = [[1] * N for _ in range(N)]\n\n    # Process commands\n    saves = []\n    for command in commands:\n        if command[0] == 'PAINT':\n            color, x1, y1, x2, y2 = map(int, command[1:])\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    canvas[i][j] = color\n        elif command[0] == 'SAVE':\n            saves.append([[row.copy() for row in canvas], len(saves) + 1])\n        elif command[0] == 'LOAD':\n            load_index = int(command[1]) - 1\n            canvas, save_index = saves[load_index]\n            print(f'LOADED SAVE #{save_index}')\n\n    # Format output\n    output = '\\n'.join([' '.join(map(str, row)) for row in canvas])\n    return output"
    },
    {
        "number": 3180,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    commands = []\n    for _ in range(M):\n        command, *args = input().split()\n        if command == \"PAINT\":\n            c, x1, y1, x2, y2 = map(int, args)\n            commands.append((\"PAINT\", c, x1, y1, x2, y2))\n        elif command == \"SAVE\":\n            commands.append((\"SAVE\",))\n        elif command == \"LOAD\":\n            x = int(args[0])\n            commands.append((\"LOAD\", x))\n    \n    canvas = [[1] * N for _ in range(N)]\n    saved = []\n    \n    for command in commands:\n        if command[0] == \"PAINT\":\n            c, x1, y1, x2, y2 = command\n            for x in range(x1, x2 + 1):\n                for y in range(y1, y2 + 1):\n                    canvas[x][y] = c if (x + y) % 2 == 0 else 1\n        elif command[0] == \"SAVE\":\n            saved.append([[row[:] for row in canvas]])\n        elif command[0] == \"LOAD\":\n            x = command[1]\n            canvas = [row[:] for row in saved[x - 1]]\n    \n    return \"\\n\".join(\" \".join(map(str, row)) for row in canvas)"
    },
    {
        "number": 3180,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, K, M = map(int, stdin.readline().strip().split())\n    commands = []\n    for _ in range(M):\n        command, *args = stdin.readline().strip().split()\n        commands.append((command, list(map(int, args))))\n\n    # Initialize the canvas\n    canvas = [[1] * N for _ in range(N)]\n\n    # Execute commands\n    save_stack = []\n    for command, args in commands:\n        if command == \"PAINT\":\n            c, x1, y1, x2, y2 = args\n            for x in range(x1, x2 + 1):\n                for y in range(y1, y2 + 1):\n                    canvas[y][x] = c\n        elif command == \"SAVE\":\n            save_stack.append([[row.copy() for row in canvas]])\n        elif command == \"LOAD\":\n            save_index = args[0] - 1\n            if save_index < len(save_stack):\n                canvas = save_stack[save_index]\n\n    # Print the final canvas\n    return \"\\n\".join(\" \".join(map(str, row)) for row in canvas)"
    },
    {
        "number": 3180,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, K, M = map(int, stdin.readline().split())\n    canvas = [[1] * N for _ in range(N)]\n    saved_states = []\n\n    for _ in range(M):\n        command, *args = stdin.readline().split()\n\n        if command == \"PAINT\":\n            colour, x1, y1, x2, y2 = map(int, args)\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    canvas[i][j] = colour\n\n        elif command == \"SAVE\":\n            saved_states.append(canvas.copy())\n\n        elif command == \"LOAD\":\n            state_idx = int(args[0]) - 1\n            canvas = saved_states[state_idx]\n\n    # Format output\n    output = \"\"\n    for row in canvas:\n        output += \" \".join(map(str, row)) + \"\\n\"\n\n    return output"
    },
    {
        "number": 3180,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, K, M = map(int, stdin.split()[0:3])\n    commands = stdin.split('\\n')[1:]\n\n    # Initialize canvas with white cells\n    canvas = [[1] * N for _ in range(N)]\n\n    # Save function\n    def save(canvas):\n        return [row.copy() for row in canvas]\n\n    # Load function\n    def load(canvas, saved_canvas):\n        for i in range(N):\n            for j in range(N):\n                canvas[i][j] = saved_canvas[i][j]\n\n    # Execute commands\n    saved_canvases = []\n    current_save_id = 0\n    for command in commands:\n        if command.startswith('PAINT'):\n            _, color, x1, y1, x2, y2 = map(int, command.split())\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    canvas[i][j] = color\n        elif command == 'SAVE':\n            saved_canvases.append((current_save_id, save(canvas)))\n            current_save_id += 1\n        elif command.startswith('LOAD'):\n            load_id = int(command.split()[1])\n            for saved_id, saved_canvas in saved_canvases:\n                if saved_id == load_id:\n                    load(canvas, saved_canvas)\n\n    # Format output\n    output = '\\n'.join([' '.join(map(str, row)) for row in canvas])\n\n    return output"
    },
    {
        "number": 3180,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[0:3])\n    canvas = [[1] * N for _ in range(N)]\n    saved_paintings = []\n\n    for i in range(3, M + 3):\n        command, *args = stdin.split()[i].split()\n\n        if command == \"PAINT\":\n            c, x1, y1, x2, y2 = map(int, args)\n            for y in range(y1, y2 + 1):\n                for x in range(x1, x2 + 1):\n                    canvas[y][x] = c\n\n        elif command == \"SAVE\":\n            saved_paintings.append(canvas)\n\n        elif command == \"LOAD\":\n            x = int(args[0])\n            canvas = saved_paintings[x - 1]\n\n    return \"\\n\".join(\" \".join(str(cell) for cell in row) for row in canvas)"
    },
    {
        "number": 3180,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def save_painting(canvas):\n        saved_paintings.append(deepcopy(canvas))\n\n    def load_painting(canvas, index):\n        if 0 < index <= len(saved_paintings):\n            for i in range(N):\n                for j in range(N):\n                    canvas[i][j] = saved_paintings[index - 1][i][j]\n        else:\n            return \"Invalid save index.\"\n\n    def paint_rectangle(canvas, colour, x1, y1, x2, y2):\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if (i + j) % 2 == 0:\n                    canvas[i][j] = colour\n                else:\n                    canvas[i][j] = 1\n\n    def print_canvas(canvas):\n        for row in canvas:\n            print(\" \".join(str(cell) for cell in row))\n\n    # Read input\n    N, K, M = map(int, stdin.readline().split())\n    commands = [line.strip().split() for line in stdin]\n\n    # Initialize canvas and saved_paintings\n    canvas = [[1] * N for _ in range(N)]\n    saved_paintings = []\n\n    # Process commands\n    for command in commands:\n        if command[0] == \"SAVE\":\n            save_painting(canvas)\n        elif command[0] == \"LOAD\":\n            load_painting(canvas, int(command[1]))\n        elif command[0] == \"PAINT\":\n            colour, x1, y1, x2, y2 = map(int, command[1:])\n            paint_rectangle(canvas, colour, x1, y1, x2, y2)\n\n    # Print canvas\n    print_canvas(canvas)\n\n    return \"\""
    },
    {
        "number": 3180,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.readline().split())\n    canvas = [[1] * N for _ in range(N)]\n    log = [input().split() for _ in range(M)]\n\n    for line in log:\n        if line[0] == \"PAINT\":\n            c, x1, y1, x2, y2 = map(int, line[1:])\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    if (i + j) % 2 == 0:\n                        canvas[i][j] = c\n        elif line[0] == \"SAVE\":\n            saved_canvas = [row.copy() for row in canvas]\n        elif line[0] == \"LOAD\":\n            canvas = [row.copy() for row in saved_canvas]\n\n    return \"\\n\".join(\" \".join(map(str, row)) for row in canvas)"
    },
    {
        "number": 3180,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[0].split())\n    canvas = [[1] * N for _ in range(N)]\n    saved_states = []\n\n    for _ in range(M):\n        command, *args = stdin.split()[1].split()\n        if command == \"PAINT\":\n            c, x1, y1, x2, y2 = map(int, args)\n            for i in range(x1, x2):\n                for j in range(y1, y2):\n                    if (i + j) % 2 == 0:\n                        canvas[i][j] = c\n        elif command == \"SAVE\":\n            saved_states.append(canvas.copy())\n        elif command == \"LOAD\":\n            state_index = int(args[0]) - 1\n            canvas = saved_states[state_index].copy()\n\n    return \"\\n\".join([\" \".join(map(str, row)) for row in canvas])"
    },
    {
        "number": 3181,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1:\n        return \" \".join(map(str, range(1, N + 1)))\n    elif K == N:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, list(range(1, K + 1)) + list(range(K + 1, N + 1))))"
    },
    {
        "number": 3181,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n\n    if K == N:\n        return \" \".join(map(str, range(1, N + 1)))\n\n    if K == 1:\n        return \" \".join(map(str, range(1, N + 1)))\n\n    if K > N:\n        return \"-1\"\n\n    sequence = []\n\n    for i in range(N):\n        if len(sequence) < K:\n            sequence.append(i + 1)\n        else:\n            if i - sequence[-1] == N - K:\n                return \" \".join(map(str, sequence))\n            elif i - sequence[0] == N - K:\n                return \" \".join(map(str, sequence))\n\n    return \"-1\"\n"
    },
    {
        "number": 3181,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1:\n        return \" \".join([str(i) for i in range(1, N + 1)])\n    if K == N:\n        return \" \".join([str(i) for i in range(1, N + 1)])\n    if K > N:\n        return \"-1\"\n    if N % 2 == 0:\n        seq = [i for i in range(1, K + 1)] + [i for i in range(N - K + 1, N + 1)]\n    else:\n        seq = [i for i in range(1, K + 1)] + [i for i in range(N - K + 2, N + 1)]\n    return \" \".join([str(i) for i in seq])"
    },
    {
        "number": 3181,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1:\n        return ' '.join(map(str, range(1, N + 1)))\n    elif K == 2 and N % 2 == 0:\n        return ' '.join(map(str, range(1, N + 1, 2)))\n    else:\n        return '-1'"
    },
    {
        "number": 3181,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n\n    if K == 1:\n        return \" \".join(map(str, range(1, N + 1)))\n\n    if N % 2 == 0 and K == N // 2:\n        return \" \".join(map(str, range(1, N + 1)))\n\n    if N % 2 == 1 and K == (N // 2) + 1:\n        return \" \".join(map(str, range(1, N + 1)))\n\n    return \"-1\"\n"
    },
    {
        "number": 3181,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1:\n        return -1\n    if K == 2 and N % 2 == 1:\n        return -1\n    sequence = []\n    for i in range(1, N + 1):\n        if i not in sequence:\n            sequence.append(i)\n    return \" \".join(map(str, sequence))\n\n\ndef"
    },
    {
        "number": 3181,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n\n    if K == 1:\n        return -1\n\n    if N % 2 != 0 and K % 2 != 0:\n        return -1\n\n    if N % 2 == 0 and K % 2 == 0 and K % 4 == 0:\n        return -1\n\n    if N % 2 == 0 and K % 2 == 1:\n        return -1\n\n    sequence = []\n    for i in range(1, N + 1):\n        sequence.append(i)\n\n    for i in range(1, K + 1):\n        if i % 2 == 1:\n            sequence[i - 1] = N - i + 1\n\n    return \" \".join(map(str, sequence))"
    },
    {
        "number": 3181,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if N < K:\n        return \"-1\"\n    if N == K:\n        return \" \".join(map(str, range(1, N + 1)))\n    if K == 1:\n        return \" \".join(map(str, range(1, N + 1)))\n    if N % 2 == 0:\n        return \" \".join(map(str, range(1, N // 2 + 1)) + map(str, range(N // 2 + 2, N + 1)) + map(str, range(N // 2, 1, -1))))\n    else:\n        return \" \".join(map(str, range(1, N // 2 + 2)) + map(str, range(N // 2, 1, -1)) + map(str, range(N // 2 + 2, N + 1))))"
    },
    {
        "number": 3181,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1:\n        return \" \".join(str(i) for i in range(1, N + 1))\n    if K == N:\n        return \" \".join(str(i) for i in range(1, N + 1))[::-1]\n    if K >= N - K + 1:\n        return \" \".join(str(i) for i in range(1, N + 1))[::-1][:K]\n    return \"-1\""
    },
    {
        "number": 3181,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    \n    def is_valid(arr: list) -> bool:\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                return False\n        return True\n    \n    if K == N:\n        return \" \".join(map(str, range(1, N + 1)))\n    elif K == 1:\n        if N % 2 == 0:\n            return \" \".join(map(str, range(1, N + 1)))\n        else:\n            return \"-1\"\n    else:\n        for i in range(N - K + 1):\n            arr = [i + 1]\n            j = 0\n            while len(arr) < N:\n                if j % 2 == 0:\n                    if arr[-1] + j + 1 <= N:\n                        arr.append(arr[-1] + j + 1)\n                    else:\n                        break\n                else:\n                    if arr[0] - j - 1 > 0:\n                        arr.insert(0, arr[0] - j - 1)\n                    else:\n                        break\n                j += 1\n            if is_valid(arr):\n                return \" \".join(map(str, arr))\n        return \"-1\""
    },
    {
        "number": 3182,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_right_triangle(a, b, c):\n        return a ** 2 + b ** 2 == c ** 2\n\n    def count_right_triangles(points):\n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    a, b, c = sorted([distance(points[i], points[j]),\n                                   distance(points[j], points[k]),\n                                   distance(points[k], points[i])])\n                    if is_right_triangle(a, b, c):\n                        count += 1\n        return count\n\n    N = int(stdin.readline().strip())\n    points = [tuple(map(int, stdin.readline().strip().split())) for _ in range(N)]\n    result = count_right_triangles(points)\n    return str(result) "
    },
    {
        "number": 3182,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for line in stdin.split(\"\\n\")[1:]:\n        x, y = map(int, line.split())\n        points.append((x, y))\n\n    count = 0\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            for k in range(j + 1, len(points)):\n                if is_right_triangle(points[i], points[j], points[k]):\n                    count += 1\n\n    return str(count)\n\ndef"
    },
    {
        "number": 3182,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    points = [tuple(map(int, line.strip().split())) for line in stdin]\n    \n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                a, b, c = sorted([points[i], points[j], points[k]], key=lambda x: x[0])\n                \n                if a[0] ** 2 + (b[1] - a[1]) ** 2 == c[0] ** 2 + (c[1] - a[1]) ** 2:\n                    count += 1\n    \n    return str(count)"
    },
    {
        "number": 3182,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_right_triangle(a, b, c):\n        return a ** 2 + b ** 2 == c ** 2\n\n    def count_right_triangles(points):\n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    if is_right_triangle(distance(points[i], points[j]),\n                                             distance(points[i], points[k]),\n                                             distance(points[j], points[k])):\n                        count += 1\n        return count\n\n    N = int(stdin.readline())\n    points = [tuple(map(int, stdin.readline().split())) for _ in range(N)]\n    return str(count_right_triangles(points))"
    },
    {
        "number": 3182,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    n = int(stdin.readline())\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if is_right_triangle(points[i], points[j], points[k]):\n                    count += 1\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3182,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    points = []\n\n    for i in range(1, n + 1):\n        x, y = map(int, lines[i].split())\n        points.append((x, y))\n\n    def is_right_triangle(a, b, c):\n        x1, y1 = a\n        x2, y2 = b\n        x3, y3 = c\n\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) == ((x1 - x3) ** 2 + (y1 - y3) ** 2) + ((x2 - x3) ** 2 + (y2 - y3) ** 2)\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if is_right_triangle(points[i], points[j], points[k]):\n                    count += 1\n\n    return str(count // 6)"
    },
    {
        "number": 3182,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_right_triangle(a, b, c):\n        x1, y1 = a\n        x2, y2 = b\n        x3, y3 = c\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5 == ((x1 - x3) ** 2 + (y1 - y3) ** 2) ** 0.5 + ((x2 - x3) ** 2 + (y2 - y3) ** 2) ** 0.5\n\n    def count_right_triangles(points):\n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    if is_right_triangle(points[i], points[j], points[k]):\n                        count += 1\n        return count\n\n    stdin = stdin.split('\\n')\n    N = int(stdin[0])\n    points = [tuple(map(int, line.split())) for line in stdin[1:N + 1]]\n\n    result = count_right_triangles(points)\n    return str(result)"
    },
    {
        "number": 3182,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    points = [(int(x), int(y)) for x, y in [line.split() for line in stdin.split('\\n')[1:]]]\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if (points[i], points[j], points[k]) == sorted((points[i], points[j], points[k])):\n                    if points[i][0] - points[j][0] != 0:\n                        slope1 = (points[i][1] - points[j][1]) / (points[i][0] - points[j][0])\n                    else:\n                        slope1 = float('inf')\n                    if points[i][0] - points[k][0] != 0:\n                        slope2 = (points[i][1] - points[k][1]) / (points[i][0] - points[k][0])\n                    else:\n                        slope2 = float('inf')\n                    if slope1 != slope2:\n                        count += 1\n\n    return str(count)"
    },
    {
        "number": 3182,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_right_triangle(a: tuple, b: tuple, c: tuple) -> bool:\n        x1, y1 = a\n        x2, y2 = b\n        x3, y3 = c\n\n        if x1 == x2 == x3 or y1 == y2 == y3:\n            return False\n\n        a = (x1 - x2) ** 2 + (y1 - y2) ** 2\n        b = (x2 - x3) ** 2 + (y2 - y3) ** 2\n        c = (x1 - x3) ** 2 + (y1 - y3) ** 2\n\n        sides = sorted([a, b, c])\n\n        if sides[0] + sides[1] == sides[2]:\n            return True\n        else:\n            return False\n\n    def count_right_triangles(points: list) -> int:\n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    if is_right_triangle(points[i], points[j], points[k]):\n                        count += 1\n        return count\n\n    N = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    return str(count_right_triangles(points))"
    },
    {
        "number": 3182,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_right_triangle(a, b, c):\n        return a ** 2 + b ** 2 == c ** 2\n\n    points = []\n    for line in stdin.split(\"\\n\")[1:]:\n        x, y = map(int, line.split())\n        points.append((x, y))\n\n    count = 0\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            for k in range(j + 1, len(points)):\n                if is_right_triangle(distance(points[i], points[j]), distance(points[i], points[k]), distance(points[j], points[k])):\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 3183,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_cost_flow(graph, start, end, flow):\n        path_flow, path_cost = 0, 0\n        residual_graph = [{v: c for u, v, c in edges if u == i} for i in range(len(graph))]\n        for _ in range(flow):\n            path_flow, path_cost, visited = 0, 0, [False] * len(graph)\n            if dfs(start, end, residual_graph, visited, path_flow, path_cost):\n                path_cost = -path_cost\n                for u in visited:\n                    for v, c in residual_graph[u].items():\n                        residual_graph[u][v] -= path_flow\n                        residual_graph[v][u] += path_flow\n            else:\n                break\n        return path_flow * path_cost\n\n    def dfs(current, end, residual_graph, visited, path_flow, path_cost):\n        if current == end:\n            return True\n        if visited[current]:\n            return False\n        visited[current] = True\n        for v, c in residual_graph[current].items():\n            if c > 0 and not visited[v]:\n                if dfs(v, end, residual_graph, visited, path_flow, path_cost):\n                    residual_graph[current][v] -= path_flow\n                    residual_graph[v][current] += path_flow\n                    path_flow += 1\n                    path_cost -= min(c, path_flow)\n                    return True\n        return False\n\n    lines = stdin.split('\\n')\n    n, m, s, t = map(int, lines[0].split())\n    graph = [[] for _ in range(n)]\n    for i in range(1, m + 1):\n        u, v, c, w = map(int, lines[i].split())\n        graph[u].append((v, c, w))\n\n    max_flow = 0\n    while True:\n        flow = min_cost_flow(graph, s, t, 1)\n        if flow == 0:\n            break\n        max_flow += flow\n\n    return f\"{max_flow} {max_flow * min_cost_flow(graph, s, t, max_flow)}\" "
    },
    {
        "number": 3183,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def edmonds_karp(graph, source, sink):\n        residual_graph = [{v: c for u, v, c in edges if u == i} for i in range(len(graph))]\n        path = [source]\n        while path[-1] != sink:\n            if not residual_graph[path[-1]]:\n                path.pop()\n            else:\n                next_node = min(residual_graph[path[-1]], key=residual_graph[path[-1]].get)\n                path.append(next_node)\n                if next_node not in residual_graph[path[-2]]:\n                    path.pop()\n                    continue\n                residual_graph[path[-2]][next_node] = min(residual_graph[path[-2]][next_node], residual_graph[next_node][path[-2]])\n                residual_graph[next_node][path[-2]] = residual_graph[path[-2]][next_node]\n        max_flow = 0\n        min_cost = 0\n        for i in range(len(path) - 1):\n            max_flow += residual_graph[path[i]][path[i + 1]]\n            min_cost += residual_graph[path[i]][path[i + 1]] * graph[path[i]][path[i + 1]][2]\n        return max_flow, min_cost\n\n    data = list(map(str.strip, stdin.split('\\n')))\n    params = list(map(int, data[0].split()))\n    n, m, source, sink = params\n    graph = [[[] for _ in range(n)] for _ in range(n)]\n    for i in range(1, m + 1):\n        edge = list(map(int, data[i].split()))\n        u, v, c, w = edge\n        graph[u].append((v, c, w))\n        graph[v].append((u, c, w))\n    max_flow, min_cost = edmonds_karp(graph, source, sink)\n    return f\"{max_flow} {min_cost}\""
    },
    {
        "number": 3183,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from edmonds_karp import edmonds_karp\n\n    input_data = list(map(int, stdin.split()))\n    n, m, s, t = input_data[0], input_data[1], input_data[2], input_data[3]\n    graph = {}\n\n    for i in range(m):\n        u, v, c, w = input_data[4 + i * 4], input_data[5 + i * 4], input_data[6 + i * 4], input_data[7 + i * 4]\n        if u not in graph:\n            graph[u] = []\n        if v not in graph:\n            graph[v] = []\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n\n    flow, cost = edmonds_karp(graph, s, t)\n    return f\"{flow} {cost}\""
    },
    {
        "number": 3183,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_data = list(map(int, stdin.split()))\n    n, m, s, t = input_data[0], input_data[1], input_data[2], input_data[3]\n    graph = [{} for _ in range(n)]\n    for i in range(m):\n        u, v, c, w = input_data[4 + i * 4], input_data[5 + i * 4], input_data[6 + i * 4], input_data[7 + i * 4]\n        graph[u][v] = c\n        graph[v][u] = 0\n    \n    # Define the maximum flow function\n    def max_flow(graph, source, sink):\n        total_flow = 0\n        residual_graph = [{v: c for v, c in list(edges.items()) if c > 0} for edges in graph]\n        while True:\n            augmenting_path, flow = find_augmenting_path(residual_graph, source, sink)\n            if flow == 0:\n                break\n            total_flow += flow\n            update_residual_graph(residual_graph, augmenting_path, flow)\n        return total_flow\n    \n    # Find the augmenting path using BFS\n    def find_augmenting_path(residual_graph, source, sink):\n        visited = [False] * len(residual_graph)\n        queue = [(source, float('inf'))]\n        while queue:\n            node, min_capacity = queue.pop(0)\n            if node == sink:\n                return [], min_capacity\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, capacity in residual_graph[node].items():\n                    if not visited[neighbor] and capacity > 0:\n                        queue.append((neighbor, min(min_capacity, capacity)))\n        return None, 0\n    \n    # Update the residual graph\n    def update_residual_graph(residual_graph, augmenting_path, flow):\n        for u, v in zip(augmenting_path, augmenting_path[1:]):\n            if u in residual_graph[v]:\n                residual_graph[u][v] -= flow\n                residual_graph[v][u] += flow\n            else:\n                residual_graph[u][v] = flow\n                residual_graph[v][u] = 0\n    \n    # Calculate the maximum flow and minimum cost\n    max_flow_value = max_flow(graph, s, t)\n    min_cost = sum(c * w for u, edges in enumerate(graph) for v, c in edges.items() for w in [input_data[6 + i * 4] for i in range(m) if (u, v) == (input_data[4 + i * 4], input_data[5 + i * 4])]) - max_flow_value * sum(w for u, edges in enumerate(graph) for v, c in edges.items() for w in [input_data[6 + i * 4] for i in range(m) if (u, v) == (input_data[4 + i * 4], input_data[5 + i * 4])]) / 2\n    \n    return str(max_flow_value) + \" \" + str(min_cost)"
    },
    {
        "number": 3183,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def min_cost_flow(graph, s, t, F):\n        flow, cost = 0, 0\n        while flow < F:\n            flow, cost = 0, 0\n            visited, queue, prev, dist, pre_edge, edges = [False] * len(graph), [], [-1] * len(graph), [0] * len(graph), [-1] * len(graph), [{} for _ in range(len(graph))]\n            queue.append(s)\n            visited[s] = True\n            while queue:\n                cur = queue.pop(0)\n                for nxt, value in graph[cur].items():\n                    if not visited[nxt] and value[\"capacity\"] > 0:\n                        queue.append(nxt)\n                        visited[nxt] = True\n                        dist[nxt] = dist[cur] + 1\n                        prev[nxt] = cur\n                        edges[nxt] = {(cur, cur_edge) for cur_edge in graph[cur].keys() if graph[cur][cur_edge][\"capacity\"]}\n            if prev[t] == -1:\n                break\n            cur = t\n            path_flow, path_cost = float('inf'), 0\n            while cur != s:\n                path_flow = min(path_flow, graph[prev[cur]][cur][\"capacity\"])\n                path_cost = max(path_cost, graph[prev[cur]][cur][\"cost\"])\n                cur = prev[cur]\n            flow += path_flow\n            cost += path_flow * path_cost\n            cur = t\n            while cur != s:\n                u, v = prev[cur], cur\n                graph[u][v][\"capacity\"] -= path_flow\n                graph[v][u][\"capacity\"] += path_flow\n                for edge in edges[cur]:\n                    if graph[edge[0]][edge[1]][\"capacity\"]:\n                        graph[edge[0]][edge[1]][\"capacity\"] += path_flow\n                        graph[edge[1]][edge[0]][\"capacity\"] -= path_flow\n                cur = prev[cur]\n        return flow, cost\n\n    n, m, s, t = map(int, stdin.readline().split())\n    graph = [{} for _ in range(n)]\n    for i in range(m):\n        u, v, c, w = map(int, stdin.readline().split())\n        graph[u][v] = {\"capacity\": c, \"cost\": w}\n        graph[v][u] = {\"capacity\": 0, \"cost\": 0}\n\n    F = min_cost_flow(graph, s, t, float('inf'))[0]\n    cost = min_cost_flow(graph, s, t, F)[1]\n    return f\"{F} {cost}\\n\""
    },
    {
        "number": 3183,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def max_flow(graph, source, sink, parent):\n        if source == sink:\n            return float('inf')\n\n        for i in range(len(graph[source])):\n            if graph[source][i] > 0 and parent[i] == -1:\n                parent[i] = source\n                flow = min(max_flow(graph, i, sink, parent), graph[source][i])\n                if flow > 0:\n                    graph[source][i] -= flow\n                    graph[i][source] += flow\n                    return flow\n        return 0\n\n    def min_cost_flow(graph, source, sink, flow):\n        total_cost = 0\n        cost = [0] * len(graph)\n        parent = [-1] * len(graph)\n        residual_graph = [row[:] for row in graph]\n\n        while flow > 0:\n            max_flow(residual_graph, source, sink, parent)\n            if parent[sink] == -1:\n                break\n\n            cur = sink\n            path_flow = float('inf')\n            while cur != source:\n                path_flow = min(path_flow, residual_graph[parent[cur]][cur])\n                cur = parent[cur]\n\n            flow -= path_flow\n            total_cost += path_flow * cost[sink]\n            cur = sink\n\n            while cur != source:\n                residual_graph[parent[cur]][cur] -= path_flow\n                residual_graph[cur][parent[cur]] += path_flow\n                cur = parent[cur]\n\n            cost[sink] += 1\n\n        return total_cost\n\n    lines = stdin.split('\\n')\n    line1 = list(map(int, lines[0].split()))\n    n, m, source, sink = line1\n    graph = [[0] * n for _ in range(n)]\n\n    for i in range(1, m + 1):\n        line = list(map(int, lines[i].split()))\n        u, v, c, w = line\n        graph[u][v] = c\n\n    flow = max_flow(graph, source, sink, [-1] * n)\n    cost = min_cost_flow(graph, source, sink, flow)\n\n    return f\"{flow} {cost}\""
    },
    {
        "number": 3183,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    def max_flow_min_cost(graph, start, end):\n        flow, cost = 0, 0\n        while True:\n            prev, visit = {}, {start: 0}\n            queue = [start]\n            while queue:\n                node = queue.pop(0)\n                for neighbor, capacity in graph[node].items():\n                    if capacity and neighbor not in visit:\n                        visit[neighbor] = visit[node] + 1\n                        prev[neighbor] = node\n                        queue.append(neighbor)\n            if end not in visit:\n                break\n            path_flow, path_cost = float('inf'), 0\n            curr = end\n            while curr != start:\n                path_flow = min(path_flow, graph[prev[curr]][curr])\n                path_cost += graph[prev[curr]][curr] * graph[curr][prev[curr]]\n                curr = prev[curr]\n            flow += path_flow\n            cost += path_cost * path_flow\n            curr = end\n            while curr != start:\n                neighbor = prev[curr]\n                graph[neighbor][curr] -= path_flow\n                graph[curr][neighbor] += path_flow\n                curr = neighbor\n        return flow, cost\n\n    def parse_input(stdin: str):\n        lines = stdin.split('\\n')\n        params = list(map(int, lines[0].split()))\n        graph = defaultdict(lambda: defaultdict(int))\n        for line in lines[1:]:\n            u, v, c, w = map(int, line.split())\n            graph[u][v] = c\n            graph[v][u] = w\n        return params, graph\n\n    params, graph = parse_input(stdin)\n    n, m, s, t = params\n    flow, cost = max_flow_min_cost(graph, s, t)\n    return f\"{flow} {cost}\""
    },
    {
        "number": 3183,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n, m, s, t = map(int, stdin.readline().split())\n    graph = [{} for _ in range(n)]\n    for _ in range(m):\n        u, v, c, w = map(int, stdin.readline().split())\n        graph[u][v] = c, w\n    \n    # Calculate max flow and min cost\n    F, total_cost = 0, 0\n    while True:\n        _, visit, _ = bfs(graph, s, t)\n        if not visit[t]:\n            break\n        F_flow, F_cost = 0, 0\n        u, flow, cost = t, float('inf'), 0\n        while u != s:\n            v, c, w = next(iter(graph[u].items()))\n            flow, c = min(flow, c), c\n            cost += w * c\n            F_cost += w * flow\n            F_flow += flow\n            graph[u][v] = c - flow, w\n            graph[v][u] = flow, -w\n            u = v\n        total_cost += F_cost\n        F += F_flow\n    \n    return f\"{F} {total_cost}\"\n\ndef"
    },
    {
        "number": 3183,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from edmonds_karp import edmonds_karp\n\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        n, m, s, t = map(int, lines[0].split())\n        graph = defaultdict(set)\n        for i in range(1, m + 1):\n            u, v, c, w = map(int, lines[i].split())\n            graph[u].add((v, c, w))\n            graph[v].add((u, 0, -w))\n        return n, m, s, t, graph\n\n    n, m, s, t, graph = parse_input(stdin)\n    max_flow, min_cost = edmonds_karp(graph, s, t)\n\n    return f\"{max_flow} {min_cost}\""
    },
    {
        "number": 3183,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from edmonds_karp import edmonds_karp\n\n    lines = stdin.split(\"\\n\")\n    params = list(map(int, lines[0].split()))\n    n, m, s, t = params\n    graph = []\n    for line in lines[1:]:\n        u, v, c, w = list(map(int, line.split()))\n        graph.append([u, v, c, w])\n\n    max_flow, min_cost = edmonds_karp(n, graph, s, t)\n    return f\"{max_flow} {min_cost}\""
    },
    {
        "number": 3184,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, k = map(int, lines[0].split())\n    ranges = []\n    for i in range(k):\n        a, b = map(int, lines[i + 1].split())\n        ranges.append((a, b))\n\n    cameras = 0\n    covered_walls = set()\n    for i in range(n):\n        if i not in covered_walls:\n            cameras += 1\n            covered_walls.add(i)\n            for a, b in ranges:\n                if a <= b:\n                    for j in range(a, b + 1):\n                        if j not in covered_walls:\n                            covered_walls.add(j)\n                else:\n                    for j in range(a, n + 1) + range(1, b + 1):\n                        if j not in covered_walls:\n                            covered_walls.add(j)\n\n    if len(covered_walls) == n:\n        return str(cameras)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3184,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_covered(camera_range, wall):\n        return camera_range[0] <= wall <= camera_range[1]\n\n    def cover_walls(camera_ranges, walls_to_cover):\n        walls_covered = 0\n        cameras_used = 0\n\n        while walls_to_cover:\n            if not camera_ranges:\n                return \"impossible\"\n\n            camera_range = camera_ranges.pop(0)\n            cameras_used += 1\n\n            for wall in range(1, n + 1):\n                if is_covered(camera_range, wall):\n                    if wall in walls_to_cover:\n                        walls_covered += 1\n                        walls_to_cover.remove(wall)\n\n        return cameras_used\n\n    stdin_list = stdin.split(\"\\n\")\n    n, k = map(int, stdin_list[0].split())\n    camera_ranges = []\n\n    for i in range(1, k + 1):\n        a, b = map(int, stdin_list[i].split())\n        camera_ranges.append((a, b))\n\n    walls_to_cover = set(range(1, n + 1))\n    result = cover_walls(camera_ranges, walls_to_cover)\n\n    return str(result)"
    },
    {
        "number": 3184,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    ranges = []\n    for i in range(k):\n        a, b = map(int, stdin.split()[2:])\n        ranges.append((a, b))\n\n    covered = [False] * n\n    for a, b in ranges:\n        if a > b:\n            covered = [True] * n\n            break\n        for i in range(a - 1, b):\n            covered[i] = True\n\n    if not all(covered):\n        return \"impossible\"\n\n    return str(sum(1 for c in covered if c))"
    },
    {
        "number": 3184,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    walls = [0] * n\n    for _ in range(k):\n        a, b = map(int, stdin.readline().split())\n        if a > b:\n            walls = [1] * n\n            break\n        for i in range(a - 1, b):\n            walls[i] = 1\n\n    if all(walls) and n % 2 == 0:\n        return \"impossible\"\n    return f\"{walls.count(0) // 2 + 1}\"\n"
    },
    {
        "number": 3184,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_covered(start, end, ranges):\n        for i in range(start, end + 1):\n            if i not in ranges:\n                return False\n        return True\n\n    def helper(start, end, k, cameras, covered):\n        if k == 0:\n            if not is_covered(start, end, covered):\n                return float('inf')\n            return 0\n\n        if start > end:\n            return float('inf')\n\n        if (start, end, k) in memo:\n            return memo[(start, end, k)]\n\n        result = float('inf')\n        for i in range(start, end + 1):\n            if i not in covered:\n                new_covered = covered.copy()\n                for j in range(i, end + 1):\n                    new_covered.add(j)\n                new_cameras = cameras.copy()\n                new_cameras.add(i)\n                result = min(result, 1 + helper(i + 1, end, k - 1, new_cameras, new_covered))\n\n        memo[(start, end, k)] = result\n        return result\n\n    lines = stdin.split('\\n')\n    n, k = map(int, lines[0].split())\n    walls = set(range(1, n + 1))\n    ranges = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    memo = {}\n    result = helper(1, n, k, set(), set())\n    if result == float('inf'):\n        return \"impossible\"\n    return str(result)"
    },
    {
        "number": 3184,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def cover_walls(walls, cameras):\n        covered = [False] * len(walls)\n        for camera in cameras:\n            for i in range(camera[0] - 1, camera[1]):\n                covered[i % len(walls)] = True\n        return covered\n\n    def min_cameras(walls, k):\n        left, right = 0, len(walls)\n        while left <= right:\n            mid = (left + right) // 2\n            cameras = []\n            for i in range(k):\n                cameras.append([(i * mid) % len(walls) + 1, ((i * mid) % len(walls) + mid) % len(walls) + 1])\n            covered = cover_walls(walls, cameras)\n            if all(covered):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    n, k, *points = list(map(int, stdin.split()))\n    walls = [(i + 1, (i + 2) % n + 1) for i in range(n)]\n    result = min_cameras(walls, k)\n    return \"impossible\" if result > k else str(result)"
    },
    {
        "number": 3184,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_covered(walls_covered, n):\n        covered = [False] * n\n        for start, end in walls_covered:\n            for i in range(start - 1, end):\n                covered[i % n] = True\n        return all(covered)\n\n    n, k = map(int, stdin.split())\n    walls_covered = [tuple(map(int, input().split())) for _ in range(k)]\n\n    for i in range(1, k):\n        if is_covered(walls_covered[:i] + walls_covered[i + 1:], n):\n            return str(i)\n\n    return \"impossible\""
    },
    {
        "number": 3184,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    walls = [0] * (n + 1)\n    for i in range(k):\n        a, b = map(int, stdin.readline().split())\n        if a > b:\n            walls[1:b + 1] = [1] * (b - 1 + 1)\n            walls[a:n + 1] = [1] * (n - a + 1)\n            walls[b:a + 1] = [1] * (a - b + 1)\n        else:\n            walls[a:b + 1] = [1] * (b - a + 1)\n\n    if all(walls[1:-1]):\n        return str(sum(walls[1:-1]))\n    else:\n        return \"impossible\""
    },
    {
        "number": 3184,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_covered(walls, cameras):\n        covered_walls = [0] * len(walls)\n        for camera in cameras:\n            for wall in walls:\n                if camera[0] <= wall <= camera[1]:\n                    covered_walls[wall - 1] = 1\n        return sum(covered_walls) == len(walls)\n\n    def helper(walls, cameras, start, end, count, result):\n        if count >= result[0]:\n            return\n        if is_covered(walls, cameras):\n            result[0] = min(result[0], count)\n            return\n        for i in range(start, end):\n            for j in range(i, end):\n                if i == j:\n                    continue\n                new_cameras = cameras + [[i, j]]\n                helper(walls, new_cameras, j, end, count + 1, result)\n\n    n, k, walls = 0, 0, []\n    stdin_list = stdin.strip().split('\\n')\n    n, k = map(int, stdin_list[0].split())\n    walls = list(range(1, n + 1))\n    cameras = [list(map(int, line.split())) for line in stdin_list[1:]]\n    result = [float('inf')]\n    helper(walls, [], 0, k, 0, result)\n    if result[0] == float('inf'):\n        return 'impossible'\n    else:\n        return result[0]"
    },
    {
        "number": 3184,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_covered(walls, cameras):\n        for wall in walls:\n            if not any(a <= wall <= b for a, b in cameras):\n                return False\n        return True\n\n    def helper(walls, cameras, current_wall, camera_idx, covered_walls):\n        if covered_walls == walls:\n            return camera_idx\n        if camera_idx == len(cameras):\n            return float('inf')\n\n        if current_wall > walls:\n            current_wall = 1\n\n        if current_wall not in covered_walls:\n            covered = set(covered_walls)\n            for i in range(cameras[camera_idx][0], cameras[camera_idx][1] + 1):\n                covered.add(i)\n            return min(helper(walls, cameras, current_wall + 1, camera_idx + 1, covered),\n                       helper(walls, cameras, current_wall + 1, camera_idx, covered_walls))\n        else:\n            return helper(walls, cameras, current_wall + 1, camera_idx, covered_walls)\n\n    n, k = map(int, stdin.split())\n    walls = set(range(1, n + 1))\n    cameras = [tuple(map(int, input().split())) for _ in range(k)]\n\n    if not is_covered(walls, cameras):\n        return \"impossible\"\n\n    min_cameras = helper(n, cameras, 1, 0, set())\n    return min_cameras"
    },
    {
        "number": 3185,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = 0\n    factorial = int(stdin)\n    while factorial > 1:\n        n += 1\n        factorial //= n\n    return str(n)"
    },
    {
        "number": 3185,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n_fact = int(stdin)\n    n = 1\n    fact = 1\n\n    while fact < n_fact:\n        n += 1\n        fact *= n\n\n    return str(n)"
    },
    {
        "number": 3185,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    i = 2\n    while n > 1:\n        while n % i == 0:\n            n //= i\n        i += 1\n    return str(i - 1)"
    },
    {
        "number": 3185,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = 0\n    for i in range(1, 10**6):\n        n += 1\n        if factorial(n) >= int(stdin):\n            break\n    return str(n)\n\ndef"
    },
    {
        "number": 3185,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    factorial = int(stdin.strip())\n    n = 1\n    while factorial > 1:\n        factorial //= n\n        n += 1\n    return str(n - 1)"
    },
    {
        "number": 3185,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = 1\n    factorial = int(stdin)\n    while factorial > 1:\n        factorial //= n\n        n += 1\n    return str(n - 1)"
    },
    {
        "number": 3185,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n_factorial = int(stdin.strip())\n    n = 0\n    while n_factorial > 1:\n        n += 1\n        n_factorial //= n\n    return str(n)"
    },
    {
        "number": 3185,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    factorial = int(stdin)\n    n = 1\n    while factorial > 1:\n        factorial //= n\n        n += 1\n    return str(n - 1)"
    },
    {
        "number": 3185,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    factorial = int(stdin)\n    n = 0\n    result = 1\n    while result <= factorial:\n        n += 1\n        result *= n\n    return str(n - 1)"
    },
    {
        "number": 3185,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    factorial = int(stdin)\n    n = 1\n    while True:\n        n_factorial = 1\n        for i in range(1, n + 1):\n            n_factorial *= i\n        if n_factorial > factorial:\n            return str(n - 1)\n        n += 1"
    },
    {
        "number": 3186,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    mod = 10**6 + 7\n    result = 1\n\n    for i in range(K):\n        result = (result * (N - i)) % mod\n        result = (result * pow(M, mod - 2, mod)) % mod\n\n    return str(result)"
    },
    {
        "number": 3186,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    mod = 10**6 + 7\n    result = 1\n\n    for i in range(1, n + 1):\n        result *= k + m - 1\n        result %= mod\n        k -= 1\n        if k < 0:\n            return 0\n\n    return str(result)"
    },
    {
        "number": 3186,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    mod = 10**6 + 7\n\n    # nCk = n! / (k! * (n-k)!)\n    # nCk mod m = (n! * (k!)^-1 * ((n-k)!)^-1) mod m\n\n    # Using fermat's little theorem to find the modular multiplicative inverse of k! and (n-k)!\n    # modular_inverse(x) = x^(m-2) % m\n\n    def modular_inverse(x: int) -> int:\n        return pow(x, m - 2, m)\n\n    def factorial(x: int) -> int:\n        fact = 1\n        for i in range(1, x + 1):\n            fact = (fact * i) % m\n        return fact\n\n    n_fact = factorial(n)\n    k_fact = factorial(k)\n    n_k_fact = factorial(n - k)\n\n    n_choose_k = (n_fact * modular_inverse(k_fact) * modular_inverse(n_k_fact)) % m\n\n    return str(n_choose_k)"
    },
    {
        "number": 3186,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    mod = 10**6 + 7\n    result = 1\n\n    for i in range(k):\n        result *= (n - i) * m\n        result %= mod\n\n    return str(result // m)"
    },
    {
        "number": 3186,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    mod = 10**6 + 7\n    if k > m * n:\n        return 0\n    else:\n        return ((factorial(m, mod) * factorial(k, mod) * factorial(m * n - k, mod)) % mod) // (factorial(m, mod) * factorial(m * n - k, mod))\n    \ndef"
    },
    {
        "number": 3186,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    mod = 10**6 + 7\n\n    # If there are fewer than K objects, return 0\n    if K > N * M:\n        return str(0)\n\n    # If there are the same number of objects and copies, return K!\n    if N == 1 and M == 1:\n        result = 1\n        for i in range(1, K + 1):\n            result *= i\n            result %= mod\n        return str(result)\n\n    # If there are fewer than K copies of each object, return 0\n    if K > N:\n        return str(0)\n\n    # If there are more than K objects and K copies of each object, return 1\n    if N == K and M == K:\n        return str(1)\n\n    # Use the principle of inclusion-exclusion to calculate the number of ways\n    num_ways = 0\n    for i in range(K + 1):\n        if i % 2 == 0:\n            num_ways += pow(M, i, mod) * pow(N, K - i, mod)\n            num_ways %= mod\n        else:\n            num_ways -= pow(M, i, mod) * pow(N, K - i, mod)\n            num_ways %= mod\n\n    return str(num_ways)"
    },
    {
        "number": 3186,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = list(map(int, stdin.split()))\n    result = 1\n    mod = 10**6 + 7\n\n    for i in range(K):\n        result = (result * (N - i)) % mod\n        result = (result * pow(M, mod - 2, mod)) % mod\n\n    return str(result)"
    },
    {
        "number": 3186,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    MOD = 10**6 + 7\n\n    if k > n * m:\n        return \"0\"\n\n    numerator = []\n    denominator = []\n\n    for i in range(n):\n        numerator.append(m + i)\n        denominator.append(i + 1)\n\n    for i in range(k - 1):\n        numerator.append(m + n + i)\n        denominator.append(i + 1)\n\n    numerator.sort(reverse=True)\n    denominator.sort(reverse=True)\n\n    for i in range(len(numerator)):\n        numerator[i] %= MOD\n        denominator[i] %= MOD\n\n    result = 1\n    for i in range(len(numerator)):\n        result *= numerator[i]\n        result %= MOD\n\n        for j in range(i + 1, len(numerator)):\n            result *= pow(denominator[j], MOD - 2, MOD)\n            result %= MOD\n\n    return str(result) "
    },
    {
        "number": 3186,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    result = 1\n    for i in range(1, k + 1):\n        result = (result * (n - i + 1) * (m - 1)) % (10**6 + 7)\n    return str(result)"
    },
    {
        "number": 3186,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    mod = 10**6 + 7\n    return str(((m**k) * (mf(m - 1, k - 1) * nf(n - k)) % mod) % mod)\n\ndef"
    },
    {
        "number": 3187,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def min_distance(points, d):\n        min_x = min(x for x, y in points)\n        max_x = max(x for x, y in points)\n        min_y = min(y for x, y in points)\n        max_y = max(y for x, y in points)\n\n        min_dist = float('inf')\n        min_point = None\n\n        for x in range(min_x, max_x + 1):\n            for y in range(min_y, max_y + 1):\n                dist = sum(distance(x, y, px, py) for px, py in points)\n                if dist <= d and dist < min_dist:\n                    min_dist = dist\n                    min_point = (x, y)\n\n        return min_point, min_dist\n\n    data = [line.split() for line in stdin.split('\\n') if line]\n    n = int(data[0][0])\n    points = [(int(x), int(y)) for x, y in data[1:n+1]]\n    d = int(data[n+1][0])\n\n    min_point, min_dist = min_distance(points, d)\n\n    if min_point:\n        return str(min_dist)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3187,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    citizens = [list(map(int, line.split())) for line in lines[1:n+1]]\n    d = int(lines[n+1])\n\n    min_distance = float('inf')\n    for x in range(200001):\n        for y in range(200001):\n            total_distance = 0\n            for citizen in citizens:\n                total_distance += abs(x - citizen[0]) + abs(y - citizen[1])\n            if total_distance <= d * n and total_distance < min_distance:\n                min_distance = total_distance\n\n    return min_distance if min_distance != float('inf') else \"impossible\""
    },
    {
        "number": 3187,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, *coordinates, d = list(map(int, stdin.split()))\n    x_coordinates, y_coordinates = zip(*coordinates)\n    x_range = max(x_coordinates) - min(x_coordinates)\n    y_range = max(y_coordinates) - min(y_coordinates)\n\n    if d < max(x_range, y_range):\n        return \"impossible\"\n\n    x_center = (max(x_coordinates) + min(x_coordinates)) // 2\n    y_center = (max(y_coordinates) + min(y_coordinates)) // 2\n\n    total_distance = sum([abs(x - x_center) + abs(y - y_center) for x, y in coordinates])\n\n    return total_distance"
    },
    {
        "number": 3187,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, *coordinates, d = list(map(int, stdin.split()))\n    x_coordinates = [coord[0] for coord in coordinates]\n    y_coordinates = [coord[1] for coord in coordinates]\n    \n    x_coordinates.sort()\n    y_coordinates.sort()\n    \n    total_distance = float('inf')\n    \n    for i in range(len(x_coordinates)):\n        for j in range(len(y_coordinates)):\n            x_sum = 0\n            y_sum = 0\n            \n            for k in range(len(x_coordinates)):\n                x_sum += abs(x_coordinates[k] - x_coordinates[i])\n                \n            for k in range(len(y_coordinates)):\n                y_sum += abs(y_coordinates[k] - y_coordinates[j])\n            \n            if max(x_sum, y_sum) > d:\n                continue\n            \n            total_distance = min(total_distance, x_sum + y_sum)\n    \n    return str(total_distance) if total_distance != float('inf') else 'impossible'"
    },
    {
        "number": 3187,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_valid(x, y, max_distance):\n        return all(distance(x, y, xi, yi) <= max_distance for xi, yi in coordinates)\n\n    def find_best_intersection(max_distance):\n        best_distance = float('inf')\n        best_x, best_y = None, None\n        for x in range(max_x + 1):\n            for y in range(max_y + 1):\n                if is_valid(x, y, max_distance):\n                    total_distance = sum(distance(x, y, xi, yi) for xi, yi in coordinates)\n                    if total_distance < best_distance:\n                        best_distance = total_distance\n                        best_x, best_y = x, y\n        return best_x, best_y, best_distance\n\n    n, coordinates, max_distance = stdin.split('\\n')\n    n = int(n)\n    coordinates = [list(map(int, coordinate.split())) for coordinate in coordinates]\n    max_distance = int(max_distance)\n\n    max_x = max(x for x, y in coordinates)\n    max_y = max(y for x, y in coordinates)\n\n    best_x, best_y, best_distance = find_best_intersection(max_distance)\n\n    if best_x is None:\n        return \"impossible\"\n    else:\n        return best_distance "
    },
    {
        "number": 3187,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split('\\n')[0].split())\n    citizens = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n    x_min, x_max = min(x for x, y in citizens), max(x for x, y in citizens)\n    y_min, y_max = min(y for x, y in citizens), max(y for x, y in citizens)\n\n    possible_intersections = []\n    for x in range(x_min, x_max + 1):\n        for y in range(y_min, y_max + 1):\n            if all(abs(x - cx) + abs(y - cy) <= d for cx, cy in citizens):\n                possible_intersections.append((x, y))\n\n    if not possible_intersections:\n        return \"impossible\"\n\n    total_distance = sum(abs(x - cx) + abs(y - cy) for cx, cy in citizens for x, y in possible_intersections)\n    return total_distance"
    },
    {
        "number": 3187,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split('\\n')[:2])\n    citizen_coords = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:n+2]]\n    \n    if not citizen_coords:\n        return 'impossible'\n    \n    x_min = min(x for x, _ in citizen_coords)\n    y_min = min(y for _, y in citizen_coords)\n    x_max = max(x for x, _ in citizen_coords)\n    y_max = max(y for _, y in citizen_coords)\n    \n    min_distance = float('inf')\n    min_x, min_y = None, None\n    \n    for x in range(x_min, x_max + 1):\n        for y in range(y_min, y_max + 1):\n            total_distance = sum(abs(x - cx) + abs(y - cy) for cx, cy in citizen_coords)\n            if total_distance <= d and total_distance < min_distance:\n                min_distance = total_distance\n                min_x, min_y = x, y\n                \n    if min_x is None or min_y is None:\n        return 'impossible'\n    \n    return str(min_distance)"
    },
    {
        "number": 3187,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split('\\n')[0].split())\n    citizens = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n + 1]]\n\n    min_distance = float('inf')\n    for x in range(200001):\n        for y in range(200001):\n            total_distance = 0\n            for citizen in citizens:\n                total_distance += abs(x - citizen[0]) + abs(y - citizen[1])\n            if total_distance <= d * n:\n                min_distance = min(min_distance, total_distance)\n\n    return min_distance if min_distance != float('inf') else \"impossible\""
    },
    {
        "number": 3187,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_distance(x, y, d):\n        min_distance = float(\"inf\")\n        min_x, min_y = None, None\n        for i in range(len(x)):\n            for j in range(i + 1, len(x)):\n                distance = abs(x[i] - x[j]) + abs(y[i] - y[j])\n                if distance <= d:\n                    if distance < min_distance:\n                        min_distance = distance\n                        min_x, min_y = (x[i] + x[j]) // 2, (y[i] + y[j]) // 2\n        return min_distance, min_x, min_y\n\n    data = list(map(str.strip, stdin.split('\\n')))\n    n = int(data[0])\n    x, y = [], []\n    for i in range(1, n + 1):\n        temp_x, temp_y = map(int, data[i].split())\n        x.append(temp_x)\n        y.append(temp_y)\n    d = int(data[n + 1])\n\n    min_distance, min_x, min_y = find_min_distance(x, y, d)\n\n    if min_x is None and min_y is None:\n        return \"impossible\"\n\n    total_distance = sum(abs(x_i - min_x) + abs(y_i - min_y) for x_i, y_i in zip(x, y))\n    return total_distance"
    },
    {
        "number": 3187,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x, y, x1, y1):\n        return abs(x - x1) + abs(y - y1)\n\n    def find_intersection(d, citizens, x, y):\n        total_distance = 0\n        for citizen in citizens:\n            total_distance += distance(x, y, citizen[0], citizen[1])\n        return total_distance <= d\n\n    def binary_search(d, citizens, x_min, x_max, y_min, y_max):\n        x_mid = (x_min + x_max) // 2\n        y_mid = (y_min + y_max) // 2\n\n        if find_intersection(d, citizens, x_mid, y_mid):\n            if x_mid == x_min and y_mid == y_min:\n                return distance(x_mid, y_mid, x_max, y_max)\n            return binary_search(d, citizens, x_mid, x_max, y_mid, y_max)\n        else:\n            return binary_search(d, citizens, x_min, x_mid, y_min, y_mid)\n\n    stdin_list = stdin.split(\"\\n\")\n    n = int(stdin_list[0])\n    citizens = [(int(line.split()[0]), int(line.split()[1])) for line in stdin_list[1:n + 1]]\n    d = int(stdin_list[n + 1])\n\n    x_min, x_max = min(citizens, key=lambda x: x[0])[0], max(citizens, key=lambda x: x[0])[0]\n    y_min, y_max = min(citizens, key=lambda x: x[1])[1], max(citizens, key=lambda x: x[1])[1]\n\n    result = binary_search(d, citizens, x_min, x_max, y_min, y_max)\n    return str(result) if result != float('inf') else \"impossible\""
    },
    {
        "number": 3188,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_tunnel_cost(a, b):\n        return min(abs(a[0] - b[0]), abs(a[1] - b[1]), abs(a[2] - b[2]))\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    planets = [list(map(int, lines[i].split())) for i in range(1, N + 1)]\n\n    total_cost = 0\n    for i in range(N - 1):\n        min_cost = float('inf')\n        for j in range(i + 1, N):\n            min_cost = min(min_cost, min_tunnel_cost(planets[i], planets[j]))\n        total_cost += min_cost\n\n    return str(total_cost)"
    },
    {
        "number": 3188,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def min_tunnel_cost(a: list, b: list) -> int:\n        return min(abs(a[0] - b[0]), abs(a[1] - b[1]), abs(a[2] - b[2]))\n\n    def mst(planets: list) -> int:\n        n = len(planets)\n        parent = [i for i in range(n)]\n        rank = [0] * n\n        edges = []\n\n        def find(node):\n            if parent[node] != node:\n                parent[node] = find(parent[node])\n            return parent[node]\n\n        def union(node1, node2):\n            root1, root2 = find(node1), find(node2)\n            if root1 == root2:\n                return False\n            if rank[root1] > rank[root2]:\n                parent[root2] = root1\n            else:\n                parent[root1] = root2\n                if rank[root1] == rank[root2]:\n                    rank[root2] += 1\n            return True\n\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                cost = min_tunnel_cost(planets[i], planets[j])\n                edges.append((cost, i, j))\n        edges.sort()\n\n        min_cost = 0\n        for edge in edges:\n            cost, node1, node2 = edge\n            if union(node1, node2):\n                min_cost += cost\n\n        return min_cost\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    planets = [list(map(int, line.split())) for line in lines[1:]]\n\n    return str(mst(planets))"
    },
    {
        "number": 3188,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def min_tunnel_cost(A, B):\n        return min(abs(A[0] - B[0]), abs(A[1] - B[1]), abs(A[2] - B[2]))\n\n    N = int(stdin.readline().strip())\n    planets = [tuple(map(int, stdin.readline().strip().split())) for _ in range(N)]\n\n    total_cost = 0\n    visited = set()\n    while len(visited) < N:\n        current_planet = visited.pop() if visited else planets[0]\n        visited.add(current_planet)\n        min_cost = float('inf')\n        min_cost_planet = None\n        for planet in planets:\n            if planet not in visited:\n                cost = min_tunnel_cost(current_planet, planet)\n                if cost < min_cost:\n                    min_cost = cost\n                    min_cost_planet = planet\n        total_cost += min_cost\n        visited.add(min_cost_planet)\n\n    return str(total_cost)"
    },
    {
        "number": 3188,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def min_tunnel_cost(x1, y1, z1, x2, y2, z2):\n        return min(abs(x1 - x2), abs(y1 - y2), abs(z1 - z2))\n\n    lines = stdin.strip().split('\\n')\n    N = int(lines[0])\n\n    planets = []\n    for i in range(1, N + 1):\n        x, y, z = map(int, lines[i].strip().split())\n        planets.append((x, y, z))\n\n    total_cost = 0\n    for i in range(N - 1):\n        cost_min = float('inf')\n        for j in range(i + 1, N):\n            cost = min_tunnel_cost(*planets[i], *planets[j])\n            cost_min = min(cost_min, cost)\n        total_cost += cost_min\n\n    return str(total_cost)"
    },
    {
        "number": 3188,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def min_tunnel_cost(A, B):\n        return min(abs(A[0] - B[0]), abs(A[1] - B[1]), abs(A[2] - B[2]))\n\n    def mst(N, planets):\n        total_cost = 0\n        edges = []\n        visited = set()\n\n        visited.add(0)\n        for i in range(1, N):\n            edges.append((i, min_tunnel_cost(planets[0], planets[i])))\n\n        edges.sort(key=lambda x: x[1])\n\n        while len(visited) < N:\n            u, w = edges.pop(0)\n            if u not in visited:\n                visited.add(u)\n                total_cost += w\n                for i in range(N):\n                    if i not in visited:\n                        edges.append((i, min_tunnel_cost(planets[u], planets[i])))\n\n                edges.sort(key=lambda x: x[1])\n\n        return total_cost\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    planets = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    return str(mst(N, planets))"
    },
    {
        "number": 3188,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    planets = []\n    for i in range(1, N+1):\n        x, y, z = map(int, lines[i].split())\n        planets.append((x, y, z))\n\n    # Find the minimal cost of forming the network of tunnels\n    total_cost = 0\n    for i in range(N-1):\n        # Sort the remaining planets by their distance from the first planet\n        remaining_planets = sorted(planets[i+1:], key=lambda planet: abs(planet[0]-planets[i][0]) + abs(planet[1]-planets[i][1]) + abs(planet[2]-planets[i][2]))\n\n        # Connect the first planet to the closest remaining planet\n        closest_planet = remaining_planets[0]\n        cost = abs(closest_planet[0]-planets[i][0]) + abs(closest_planet[1]-planets[i][1]) + abs(closest_planet[2]-planets[i][2])\n        total_cost += cost\n\n        # Remove the connected planet from the list\n        planets.remove(closest_planet)\n\n    return str(total_cost)"
    },
    {
        "number": 3188,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def min_tunnel_cost(x1, y1, z1, x2, y2, z2):\n        return min(abs(x1 - x2), abs(y1 - y2), abs(z1 - z2))\n\n    def total_tunnel_cost(planets):\n        total_cost = 0\n        for i in range(len(planets) - 1):\n            x1, y1, z1 = planets[i]\n            x2, y2, z2 = planets[i + 1]\n            total_cost += min_tunnel_cost(x1, y1, z1, x2, y2, z2)\n        return total_cost\n\n    N = int(stdin.readline().strip())\n    planets = [tuple(map(int, stdin.readline().strip().split())) for _ in range(N)]\n    return str(total_tunnel_cost(planets))"
    },
    {
        "number": 3188,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # read the input\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    planets = []\n    for i in range(1, N+1):\n        x, y, z = map(int, lines[i].split())\n        planets.append((x, y, z))\n    \n    # sort the planets by their coordinates\n    planets.sort()\n    \n    # calculate the cost of forming a transconduit tunnel between each pair of planets\n    min_cost = float('inf')\n    for i in range(N-1):\n        A = planets[i]\n        B = planets[i+1]\n        cost = min(abs(A[0]-B[0]), abs(A[1]-B[1]), abs(A[2]-B[2]))\n        min_cost = min(min_cost, cost)\n    \n    return str(min_cost)"
    },
    {
        "number": 3188,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    planets = []\n    for i in range(n):\n        x, y, z = map(int, stdin.readline().strip().split())\n        planets.append((x, y, z))\n\n    planets.sort()\n\n    total_cost = 0\n    for i in range(1, n):\n        prev_x, prev_y, prev_z = planets[i - 1]\n        curr_x, curr_y, curr_z = planets[i]\n        total_cost += min(abs(prev_x - curr_x), abs(prev_y - curr_y), abs(prev_z - curr_z))\n\n    return str(total_cost)"
    },
    {
        "number": 3188,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def min_dist(a, b):\n        return min(abs(a[0] - b[0]), abs(a[1] - b[1]), abs(a[2] - b[2]))\n\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    planets = []\n    for i in range(1, N + 1):\n        x, y, z = map(int, lines[i].split())\n        planets.append((x, y, z))\n\n    cost = 0\n    while len(planets) > 1:\n        min_idx = 0\n        min_dist = float('inf')\n        for i in range(1, len(planets)):\n            dist = min_dist(planets[0], planets[i])\n            if dist < min_dist:\n                min_dist = dist\n                min_idx = i\n        cost += min_dist\n        planets.pop(min_idx)\n\n    return str(cost) "
    },
    {
        "number": 3189,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    photos = []\n    for _ in range(m):\n        switches, lights = stdin.readline().strip(), stdin.readline().strip()\n        photos.append((switches, lights))\n\n    count = 0\n    for i in range(2**n):\n        config = bin(i)[2:].zfill(n)\n        valid = True\n        for switches, lights in photos:\n            if any(config[i] != switches[i] and config[i] != lights[i] for i in range(n)):\n                valid = False\n                break\n        if valid:\n            count += 1\n\n    return count % 1000003"
    },
    {
        "number": 3189,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    photos = []\n    for _ in range(m):\n        switches, lights = stdin.readline().strip(), stdin.readline().strip()\n        photos.append((switches, lights))\n\n    def count_consistent_wirings(switches: str, lights: str) -> int:\n        consistent_wirings = 1\n        for i in range(n):\n            consistent_wirings *= 2\n            consistent_wirings %= 1000003\n            if switches[i] == lights[i]:\n                consistent_wirings -= 1\n                consistent_wirings %= 1000003\n        return consistent_wirings\n\n    total_consistent_wirings = 0\n    for switches, lights in photos:\n        total_consistent_wirings += count_consistent_wirings(switches, lights)\n        total_consistent_wirings %= 1000003\n\n    return str(total_consistent_wirings)"
    },
    {
        "number": 3189,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    photos = []\n    for _ in range(m):\n        switches, lights = stdin.readline().strip(), stdin.readline().strip()\n        photos.append((switches, lights))\n\n    total_wirings = 2 ** (n * (n - 1) // 2)\n    for photo in photos:\n        possible_wirings = set()\n        for permutation in itertools.permutations(range(n)):\n            if photo[0][permutation.index(0)] == '1':\n                if photo[1][permutation[-1]] == '1':\n                    possible_wirings.add(permutation)\n            elif photo[0][permutation.index(0)] == '0':\n                if photo[1][permutation[0]] == '0':\n                    possible_wirings.add(permutation)\n        total_wirings = total_wirings * len(possible_wirings) // n\n    return str(total_wirings % 1000003)"
    },
    {
        "number": 3189,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    stdin = stdin.strip().split('\\n')[1:]\n    photos = []\n    for i in range(m):\n        switches, lights = stdin[i*2], stdin[i*2+1]\n        photos.append((switches, lights))\n\n    combinations = []\n    for switches, lights in photos:\n        switches, lights = list(map(int, switches)), list(map(int, lights))\n        for i in range(n):\n            for j in range(n):\n                if switches[i] == 1 and lights[j] == 1 and i != j:\n                    if (i, j) not in combinations:\n                        combinations.append((i, j))\n\n    count = 1\n    for _ in range(n):\n        count *= 2\n\n    for i in range(len(combinations)):\n        for j in range(i+1, len(combinations)):\n            if combinations[i][1] == combinations[j][0] and combinations[i][0] == combinations[j][1]:\n                count -= 1\n\n    return str(count % 1000003)"
    },
    {
        "number": 3189,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    photos = [stdin.readline().strip() for _ in range(2 * m)]\n    combinations = 1\n    for i in range(n):\n        on_switches = sum(int(photos[j][i]) for j in range(0, 2 * m, 2))\n        on_lights = sum(int(photos[j][i]) for j in range(1, 2 * m, 2))\n        if on_switches != on_lights:\n            return \"0\"\n        combinations *= 2\n    return str(combinations % 1000003)"
    },
    {
        "number": 3189,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import product\n    from functools import reduce\n    \n    n, m = map(int, stdin.readline().split())\n    \n    photos = []\n    for _ in range(m):\n        switches, lights = stdin.readline().strip(), stdin.readline().strip()\n        photos.append((switches, lights))\n    \n    def check_valid(wiring):\n        for switches, lights in photos:\n            if not all(wiring[int(switches[i])] == int(lights[i]) for i in range(n)):\n                return False\n        return True\n    \n    valid_wirings = []\n    for wiring in product([0, 1], repeat=n):\n        if check_valid(wiring):\n            valid_wirings.append(wiring)\n    \n    return str(len(valid_wirings) % 1000003)"
    },
    {
        "number": 3189,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import permutations\n    \n    n, m = map(int, stdin.readline().split())\n    photos = []\n    \n    for i in range(m):\n        switches, lights = stdin.readline().strip(), stdin.readline().strip()\n        photos.append((switches, lights))\n    \n    count = 0\n    for p in permutations(range(n)):\n        valid = True\n        for switches, lights in photos:\n            new_switches = ''.join(str(int(switches[i] == '1')) for i in p)\n            new_lights = ''.join(str(int(lights[i] == '1')) for i in p)\n            \n            if new_switches != switches or new_lights != lights:\n                valid = False\n                break\n        \n        if valid:\n            count += 1\n    \n    return str(count % 1000003)"
    },
    {
        "number": 3189,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n\n    if m == 0:\n        return str(2 ** n)\n\n    photos = []\n    for i in range(1, m * 2, 2):\n        switches, lights = lines[i], lines[i + 1]\n        photos.append((switches, lights))\n\n    combinations = set()\n    for switches, lights in photos:\n        for i in range(2 ** n):\n            binary = bin(i)[2:].zfill(n)\n            if all(switches[i] == lights[i] for i in range(n)):\n                combinations.add(binary)\n\n    return str(len(combinations) % 1000003)"
    },
    {
        "number": 3189,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    photos = []\n    for _ in range(m):\n        switches, lights = stdin.readline().strip(), stdin.readline().strip()\n        photos.append((switches, lights))\n\n    combinations = 2 ** n\n    for photo in photos:\n        switches, lights = photo\n        valid_combinations = set()\n        for i in range(combinations):\n            binary = bin(i)[2:].zfill(n)\n            if switches == \"\".join([str(int(b) & int(s)) for b, s in zip(binary, switches)]):\n                if lights == \"\".join([str(int(b) & int(s)) for b, s in zip(binary, lights)]):\n                    valid_combinations.add(i)\n        combinations = len(valid_combinations)\n        if combinations == 0:\n            break\n\n    return str(combinations % 1000003)"
    },
    {
        "number": 3189,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().strip().split())\n    photos = []\n    for _ in range(m):\n        switches, lights = stdin.readline().strip(), stdin.readline().strip()\n        photos.append((switches, lights))\n\n    modulo = 1000003\n    possible_configs = [True] * (2 ** n)\n    for switches, lights in photos:\n        switches_on = [i for i in range(n) if switches[i] == '1']\n        lights_on = [i for i in range(n) if lights[i] == '1']\n        possible_configs = [\n            bool(config & (1 << switches_on[i]) & (1 << lights_on[i]))\n            for i in range(len(switches_on))\n            for config in range(2 ** n)\n            if possible_configs[config]\n        ]\n        if not any(possible_configs):\n            return '0'\n\n    return str(sum(possible_configs))"
    },
    {
        "number": 3190,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, prices, P = map(int, stdin.split('\\n'))\n    prices = list(map(int, prices.split()))\n\n    subsequences = 0\n    for i in range(N):\n        for j in range(i, N):\n            subseq_prices = prices[i:j + 1]\n            if len(subseq_prices) == 1:\n                continue\n            avg_price = sum(subseq_prices) / len(subseq_prices)\n            if avg_price >= P:\n                subsequences += 1\n\n    return str(subsequences)\n"
    },
    {
        "number": 3190,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, prices, P = map(int, stdin.split())\n    prices = list(map(int, input().split()))\n\n    count = 0\n    for i in range(N):\n        for j in range(i, N):\n            subsequence = prices[i:j + 1]\n            if sum(subsequence) / len(subsequence) >= P:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3190,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, prices, p = [int(x) for x in stdin.strip().split('\\n')]\n    prices = [int(x) for x in prices.strip().split()]\n    p = int(p)\n\n    def calculate_avg(start, end):\n        return sum(prices[start:end + 1]) // (end - start + 1)\n\n    def find_subsequences(start, end, p):\n        count = 0\n        for i in range(start, end + 1):\n            for j in range(i, end + 1):\n                if calculate_avg(i, j) >= p:\n                    count += 1\n        return count\n\n    result = find_subsequences(0, n - 1, p)\n    return str(result)"
    },
    {
        "number": 3190,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, prices, p = map(int, stdin.split('\\n'))\n    prices = list(map(int, prices.split()))\n    count = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            avg = sum(prices[i:j+1]) // (j - i + 1)\n            if avg >= p:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3190,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, a, P = map(int, stdin.split(\"\\n\"))\n    a = list(map(int, a.split()))\n    count = 0\n\n    for i in range(N):\n        avg = sum(a[i:]) / len(a[i:])\n        if avg >= P:\n            count += 1\n\n    for i in range(1, N):\n        avg = sum(a[:i]) / i\n        if avg >= P:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3190,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_subsequences(prices, p, start, end, count, result):\n        if start > end:\n            return count\n        if sum(prices[start:end + 1]) / (end - start + 1) >= p:\n            count += 1\n            if end + 1 <= len(prices):\n                count = find_subsequences(prices, p, start, end + 1, count, result)\n            if start - 1 >= 0:\n                count = find_subsequences(prices, p, start - 1, end, count, result)\n        else:\n            if end + 1 <= len(prices):\n                count = find_subsequences(prices, p, start, end + 1, count, result)\n            if start - 1 >= 0:\n                count = find_subsequences(prices, p, start - 1, end, count, result)\n        return count\n\n    data = list(map(int, stdin.split()))\n    n = data[0]\n    prices = data[1:n + 1]\n    p = data[n + 1]\n    result = find_subsequences(prices, p, 0, 0, 0, [])\n    return str(result)"
    },
    {
        "number": 3190,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, prices, P = map(int, stdin.split('\\n'))\n    prices = list(map(int, prices))\n    total_sum = 0\n    count = 0\n\n    for i in range(N):\n        total_sum += prices[i]\n\n    if total_sum / N >= P:\n        count += 1\n\n    for i in range(1, N):\n        total_sum = total_sum - prices[i - 1] + prices[i + N - 1]\n        if total_sum / N >= P:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3190,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, prices, P = map(int, stdin.split('\\n'))\n    subsequences = []\n\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            subsequence = prices[i:j + 1]\n            if sum(subsequence) / len(subsequence) >= P:\n                subsequences.append(subsequence)\n\n    return str(len(subsequences))"
    },
    {
        "number": 3190,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_subsequences(start, end, threshold, prices, P):\n        if end - start < P:\n            return 0\n\n        count = 0\n        for i in range(start, end - P + 1):\n            subseq_sum = sum(prices[i:i + P])\n            if subseq_sum / P >= threshold:\n                count += 1\n\n        return count\n\n    lines = stdin.strip().split('\\n')\n    N, P = map(int, lines[0].split())\n    prices = list(map(int, lines[1].split()))\n\n    total_subsequences = 0\n    for i in range(N):\n        for j in range(i, N):\n            subseq_sum = sum(prices[i:j + 1])\n            subseq_avg = subseq_sum / (j - i + 1)\n            if subseq_avg >= P:\n                total_subsequences += find_subsequences(i, j + 1, subseq_avg, prices, P)\n\n    return str(total_subsequences)"
    },
    {
        "number": 3190,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, prices, P = map(int, stdin.split('\\n'))\n    prices = list(map(int, prices.split()))\n    subsequences = []\n\n    for i in range(N):\n        for j in range(i, N):\n            subseq = prices[i:j+1]\n            avg = sum(subseq) / len(subseq)\n            if avg >= P:\n                subsequences.append(subseq)\n\n    return str(len(subsequences))"
    },
    {
        "number": 3191,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n\n    # If there is only one line of code, it must be the crashing line\n    if n == 1:\n        return 0\n\n    # If there are two lines of code, the second one must be the crashing line\n    if n == 2:\n        return p\n\n    # If the program takes longer to run than adding a single line, the crash must be on the last line\n    if r > p:\n        return (n - 1) * p + r\n\n    # If the program takes the same amount of time to run as adding a single line, the crash can be on any line\n    if r == p:\n        return (n - 1) * p + r / 2\n\n    # If the program takes less time to run than adding a single line, the crash must be on the first line\n    return p\n\n    # Note: In the problem statement, it is mentioned that \"running the program may take a lot of time\",\n    # but in the examples, the program takes a constant amount of time. Therefore, we assume that the program takes a constant amount of time.\n    # If the program takes a non-constant amount of time, we cannot optimize the search for the crashing line."
    },
    {
        "number": 3191,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n\n    # Calculate the minimum worst-case time to find the crashing line\n    time = 0\n    while n > 1:\n        n //= 2\n        time += p + r\n\n    # Add the time to place the last printf statement\n    time += p\n\n    return str(time)"
    },
    {
        "number": 3191,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    else:\n        middle = n // 2\n        left_half = middle\n        right_half = n - left_half\n        left_time = left_half * p + r\n        right_time = right_half * p + r\n        return str(min(left_time, right_time))"
    },
    {
        "number": 3191,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    elif n == 2:\n        return str(max(r, p))\n    else:\n        return str(max(r, 2 * p + r))"
    },
    {
        "number": 3191,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n\n    # If there is only one line of code, it must be the crashing line\n    if n == 1:\n        return 0\n\n    # Compute the maximum number of printf statements we can add\n    max_num_printf = (r - p) // p\n\n    # If we can't add any printf statements, the worst case time is the time to compile and run the program\n    if max_num_printf == 0:\n        return r\n\n    # Compute the number of code lines we can search in each iteration\n    num_lines_per_iter = 2 ** (max_num_printf - 1)\n\n    # Compute the worst-case time to find the crashing line\n    worst_case_time = r + (n // num_lines_per_iter) * p\n\n    return str(worst_case_time)"
    },
    {
        "number": 3191,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n\n    def worst_case_time(n: int, r: int, p: int) -> int:\n        if n == 1:\n            return r + p\n\n        half = n // 2\n        left_time = worst_case_time(half, r, p)\n        right_time = worst_case_time(n - half, r, p)\n\n        return min(left_time + right_time, r + p + (n - 1) * p)\n\n    return str(worst_case_time(n, r, p))"
    },
    {
        "number": 3191,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    else:\n        k = 1\n        time = r\n        while time > p:\n            k *= 2\n            time = r + (n - k) * p\n        return str(time)"
    },
    {
        "number": 3191,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n\n    # Optimal strategy: place printf statements every sqrt(n) lines\n    # to maximize the probability of finding the crashing line\n    # within the first half of the remaining lines\n    printf_every = int(n**0.5)\n    num_printf_statements = n // printf_every\n\n    time_to_find_crash_line = r + num_printf_statements * p\n\n    return str(time_to_find_crash_line)"
    },
    {
        "number": 3191,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    time = 0\n    while n > 1:\n        time += r + p\n        n //= 2\n    time += r\n    return str(time)"
    },
    {
        "number": 3191,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    if n == 1:\n        return 0\n    time_to_find_crash_line = r + p * n\n    return str(time_to_find_crash_line)"
    },
    {
        "number": 3192,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    file_names = stdin.split('\\n')[1].split()\n    file_contents = {}\n    for i in range(n):\n        file_name = stdin.split('\\n')[2 + i * 2].split()[0]\n        k = int(stdin.split('\\n')[2 + i * 2].split()[1])\n        imports = stdin.split('\\n')[3 + i * 2].split(\", \")\n        file_contents[file_name] = (k, imports)\n\n    def dfs(file_name, visited, cycle_detected):\n        if cycle_detected:\n            return []\n        if file_name in visited:\n            return [file_name]\n        visited.add(file_name)\n        for import_file in file_contents[file_name][1]:\n            cycle = dfs(import_file, visited, cycle_detected)\n            if file_name in cycle:\n                cycle_detected[0] = True\n                return cycle + [file_name]\n            if cycle:\n                return cycle\n        visited.remove(file_name)\n        return []\n\n    for file_name in file_names:\n        visited = set()\n        cycle_detected = [False]\n        cycle = dfs(file_name, visited, cycle_detected)\n        if cycle_detected[0]:\n            return ' '.join(cycle)\n\n    return \"SHIP IT\""
    },
    {
        "number": 3192,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, visited, rec_stack, start_node):\n        visited[start_node] = True\n        rec_stack[start_node] = True\n\n        for neighbor in graph[start_node]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, rec_stack, neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[start_node] = False\n        return False\n\n    def find_shortest_cycle(graph, visited, rec_stack, start_node):\n        shortest_cycle = []\n        visited[start_node] = True\n        rec_stack[start_node] = True\n\n        for neighbor in graph[start_node]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, rec_stack, neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                shortest_cycle.append(neighbor)\n\n        rec_stack[start_node] = False\n        return shortest_cycle\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    file_names = lines[1].split()\n    files = {}\n    for i in range(n):\n        file_name, k = lines[2 + i].split()\n        k = int(k)\n        imports = []\n        for j in range(k):\n            imports.append(lines[2 + i + j + 1].split(', '))\n        files[file_name] = imports\n\n    graph = {}\n    for file_name, imports in files.items():\n        graph[file_name] = []\n        for import_list in imports:\n            for imp in import_list:\n                if imp not in graph[file_name]:\n                    graph[file_name].append(imp)\n\n    visited = {name: False for name in file_names}\n    rec_stack = {name: False for name in file_names}\n\n    for file_name in file_names:\n        if not visited[file_name]:\n            if find_cycle(graph, visited, rec_stack, file_name):\n                cycle = find_shortest_cycle(graph, visited, rec_stack, file_name)\n                if cycle:\n                    return '\\n'.join(cycle)\n\n    return \"SHIP IT\""
    },
    {
        "number": 3192,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(node, visited, recursion_stack):\n        visited[node] = True\n        recursion_stack[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if find_cycle(neighbor, visited, recursion_stack):\n                    return True\n            elif recursion_stack[neighbor]:\n                return True\n        recursion_stack[node] = False\n        return False\n\n    def find_shortest_cycle():\n        visited = {file: False for file in files}\n        recursion_stack = {file: False for file in files}\n        shortest_cycle = None\n        for file in files:\n            if not visited[file]:\n                if find_cycle(file, visited, recursion_stack):\n                    cycle = []\n                    index = 0\n                    while recursion_stack[files[index]]:\n                        cycle.append(files[index])\n                        index = (index + 1) % len(files)\n                    if not shortest_cycle or len(cycle) < len(shortest_cycle):\n                        shortest_cycle = cycle\n        return shortest_cycle\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    files = lines[1].split()\n    graph = {file: set() for file in files}\n\n    for i in range(n):\n        file_name, k = lines[2 + i].split()\n        k = int(k)\n        for j in range(k):\n            dependencies = lines[2 + i + j + 1].split(\"import\")[1].strip().split(\", \")\n            for dependency in dependencies:\n                graph[file_name].add(dependency)\n\n    if find_shortest_cycle():\n        return \"SHIP IT\"\n    else:\n        return \",\".join(find_shortest_cycle())"
    },
    {
        "number": 3192,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    file_names = stdin.split('\\n')[1].split()\n    file_dict = {}\n    for i in range(n):\n        file_name = stdin.split('\\n')[i*2+2].split()[0]\n        file_dict[file_name] = stdin.split('\\n')[i*2+3:]\n\n    def dfs(file_name, visited, cycle_detected):\n        if file_name in visited:\n            return visited, cycle_detected\n        visited.add(file_name)\n        for import_file in file_dict[file_name]:\n            if import_file[0] == 'import':\n                for f in import_file.split()[1:]:\n                    visited, cycle_detected = dfs(f, visited, cycle_detected)\n                    if cycle_detected:\n                        return visited, cycle_detected\n        visited.remove(file_name)\n        return visited, cycle_detected\n\n    def find_cycle(file_name):\n        visited, cycle_detected = dfs(file_name, set(), False)\n        return visited, cycle_detected\n\n    shortest_cycle = None\n    for file_name in file_names:\n        visited, cycle_detected = find_cycle(file_name)\n        if cycle_detected:\n            visited = list(visited)\n            visited.append(file_name)\n            if not shortest_cycle or len(visited) < len(shortest_cycle):\n                shortest_cycle = visited\n\n    if shortest_cycle:\n        return \"SHIP IT\"\n    else:\n        return ' '.join(shortest_cycle)"
    },
    {
        "number": 3192,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, visited, rec_stack, start_node):\n        visited[start_node] = True\n        rec_stack[start_node] = True\n\n        for neighbor in graph[start_node]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, rec_stack, neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[start_node] = False\n        return False\n\n    def shortest_cycle(graph):\n        visited = [False] * len(graph)\n        rec_stack = [False] * len(graph)\n\n        shortest_cycle_nodes = None\n        for node in range(len(graph)):\n            if not visited[node]:\n                if find_cycle(graph, visited, rec_stack, node):\n                    return shortest_cycle_nodes\n        return \"SHIP IT\"\n\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        file_names = lines[1].split()\n        files = {name: [] for name in file_names}\n        for i in range(2, len(lines), 2):\n            file_name, k = lines[i].split()\n            k = int(k)\n            for j in range(k):\n                import_list = lines[i + j + 1].split(\", \")\n                files[file_name].extend(import_list)\n        return file_names, files\n\n    file_names, files = read_input(stdin)\n    graph = {file_name: files[file_name] for file_name in file_names}\n    result = shortest_cycle(graph)\n    if result == \"SHIP IT\":\n        return result\n    else:\n        return \" \".join(result)"
    },
    {
        "number": 3192,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, visited, start, path):\n        visited[start] = True\n        path.append(start)\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, neighbor, path):\n                    return True\n            elif neighbor in path:\n                return True\n        path.pop()\n        visited[start] = False\n        return False\n\n    def build_graph(files, imports):\n        graph = {file: [] for file in files}\n        for file, dependencies in imports.items():\n            for dependency in dependencies:\n                graph[file].append(dependency)\n        return graph\n\n    def find_shortest_cycle(graph, files):\n        visited = {file: False for file in files}\n        path = []\n        for file in files:\n            if not visited[file]:\n                path = []\n                if find_cycle(graph, visited, file, path):\n                    return path\n        return []\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    files = lines[1].split()\n    imports = {file: [] for file in files}\n    for i in range(n):\n        file, k = lines[2 + i].split()\n        k = int(k)\n        for j in range(k):\n            dependencies = lines[2 + i + j + 1].split(', ')\n            imports[file].extend(dependencies)\n\n    graph = build_graph(files, imports)\n    shortest_cycle = find_shortest_cycle(graph, files)\n\n    if shortest_cycle:\n        return ' '.join(shortest_cycle)\n    else:\n        return 'SHIP IT'"
    },
    {
        "number": 3192,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    from collections import defaultdict\n    sys.setrecursionlimit(10**6)\n    def dfs(node, visited, graph, path=[]):\n        if node not in visited:\n            visited.add(node)\n            path.append(node)\n            for neighbor in graph[node]:\n                if neighbor in visited:\n                    if neighbor == node:\n                        return path + [neighbor]\n                else:\n                    cycle = dfs(neighbor, visited, graph, path)\n                    if cycle:\n                        return cycle\n            path.pop()\n            visited.remove(node)\n        return None\n\n    n = int(stdin.readline().strip())\n    files = stdin.readline().strip().split()\n    dependencies = defaultdict(list)\n    for file in files:\n        line = stdin.readline().strip().split()\n        num_deps = int(line[1])\n        for i in range(num_deps):\n            deps = line[2+i].strip().split(\", \")\n            dependencies[file].extend(deps)\n\n    for file, deps in dependencies.items():\n        if file in deps:\n            return file\n\n    for file in files:\n        if file not in dependencies:\n            return \"SHIP IT\"\n\n    visited = set()\n    for file in files:\n        if file not in visited:\n            cycle = dfs(file, visited, dependencies)\n            if cycle:\n                return \" \".join(cycle)\n\n    return \"SHIP IT\""
    },
    {
        "number": 3192,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, node, visited, rec_stack):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if find_cycle(graph, neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    def find_shortest_cycle(graph, n):\n        visited = [False] * n\n        rec_stack = [False] * n\n        min_cycle = []\n        for i in range(n):\n            if not visited[i]:\n                if find_cycle(graph, i, visited, rec_stack):\n                    cycle = []\n                    j = i\n                    while True:\n                        cycle.append(j)\n                        j = graph[j].index(1) if 1 in graph[j] else graph[j][0]\n                        if j == i:\n                            break\n                    min_cycle = cycle if len(cycle) < len(min_cycle) else min_cycle\n        return min_cycle\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    file_names = lines[1].split()\n    graph = {i: set() for i in range(n)}\n\n    for i in range(n):\n        file_name, k = lines[2 + i].split()\n        k = int(k)\n        for j in range(k):\n            imports = lines[3 + i + j].split()[1:]\n            for imp in imports:\n                graph[file_names.index(file_name)].add(file_names.index(imp))\n\n    min_cycle = find_shortest_cycle(graph, n)\n    if min_cycle:\n        cycle_files = [file_names[i] for i in min_cycle]\n        return ' '.join(cycle_files)\n    else:\n        return \"SHIP IT\""
    },
    {
        "number": 3192,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(node, visited, rec_stack):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if find_cycle(neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    def topo_sort(node, visited, stack):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                topo_sort(neighbor, visited, stack)\n        stack.insert(0, node)\n\n    n = int(stdin.readline())\n    file_names = stdin.readline().strip().split()\n    graph = {name: set() for name in file_names}\n\n    for name in file_names:\n        file_info = stdin.readline().strip().split()\n        num_deps = int(file_info[1])\n        for i in range(num_deps):\n            deps = file_info[i + 2].split(', ')\n            for dep in deps:\n                graph[name].add(dep)\n\n    visited = {name: False for name in file_names}\n    rec_stack = {name: False for name in file_names}\n\n    for node in file_names:\n        if not visited[node]:\n            if find_cycle(node, visited, rec_stack):\n                stack = []\n                topo_sort(node, visited, stack)\n                cycle = []\n                for i in range(len(stack)):\n                    if not visited[stack[i]]:\n                        visited[stack[i]] = True\n                        cycle.append(stack[i])\n                        if len(cycle) == len(graph):\n                            break\n                return \" \".join(cycle)\n    return \"SHIP IT\"\n\ndef"
    },
    {
        "number": 3192,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    from collections import defaultdict\n    from typing import List, Tuple\n\n    def find_cycle(graph: List[List[int]], visited: List[bool], rec_stack: List[bool], start: int) -> Tuple[bool, List[int]]:\n        visited[start] = True\n        rec_stack[start] = True\n        cycle = []\n\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                found, path = find_cycle(graph, visited, rec_stack, neighbor)\n                if found:\n                    cycle += path\n            elif rec_stack[neighbor]:\n                cycle.append(neighbor)\n\n        rec_stack[start] = False\n        if cycle:\n            return True, cycle\n        else:\n            return False, []\n\n    def find_shortest_cycle(graph: List[List[int]]) -> List[str]:\n        visited = [False] * len(graph)\n        rec_stack = [False] * len(graph)\n        shortest_cycle = []\n\n        for i in range(len(graph)):\n            if not visited[i]:\n                found, cycle = find_cycle(graph, visited, rec_stack, i)\n                if found:\n                    cycle.append(cycle[0])\n                    if not shortest_cycle or len(cycle) < len(shortest_cycle):\n                        shortest_cycle = cycle\n\n        return shortest_cycle\n\n    def get_import_graph(files: List[str], file_data: List[str]) -> List[List[int]]:\n        import_graph = [[] for _ in range(len(files))]\n\n        for file_idx, data in enumerate(file_data):\n            for line in data:\n                for import_file in line[1:]:\n                    import_graph[files.index(line[0])].append(files.index(import_file))\n\n        return import_graph\n\n    def main(stdin: str) -> str:\n        n, files, file_data = parse_input(stdin)\n        import_graph = get_import_graph(files, file_data)\n        shortest_cycle = find_shortest_cycle(import_graph)\n\n        if shortest_cycle:\n            return \" \".join(files[i] for i in shortest_cycle)\n        else:\n            return \"SHIP IT\"\n\n    def parse_input(stdin: str) -> Tuple[int, List[str], List[List[str]]]:\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        files = lines[1].split()\n        file_data = [line.split(\", \") for line in lines[2:]]\n\n        return n, files, file_data\n\n    return main(stdin)"
    },
    {
        "number": 3193,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    expression, P, M = stdin.split()\n    P, M = int(P), int(M)\n\n    # Find all possible values for x\n    x_values = set()\n    for i in range(M):\n        if i % M == P:\n            x_values.add(i)\n\n    # Evaluate expression for each x value\n    min_x = float('inf')\n    for x in x_values:\n        stack = []\n        expression = expression.replace('x', str(x))\n        for char in expression:\n            if char.isdigit():\n                if not stack or stack[-1] == '(':\n                    stack.append(int(char))\n                else:\n                    op = stack.pop()\n                    num = int(char)\n                    if op == '+':\n                        stack[-1] += num\n                    elif op == '-':\n                        stack[-1] -= num\n                    elif op == '*':\n                        stack[-1] *= num\n            elif char in '+-*(':\n                stack.append(char)\n            elif char == ')':\n                op = stack.pop()\n                if op == '+':\n                    stack[-1] += num\n                elif op == '-':\n                    stack[-1] -= num\n                elif op == '*':\n                    stack[-1] *= num\n        result = stack[0]\n\n        # Check if remainder is P\n        if result % M == P:\n            min_x = min(min_x, x)\n\n    return str(min_x)"
    },
    {
        "number": 3193,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = stdin.split()\n    P = int(P)\n    M = int(M)\n    \n    def find_min_x(A, P, M):\n        if A.isdigit():\n            return (M - int(A) % M) % M\n        if 'x' not in A:\n            return 0\n        if A.startswith('x'):\n            return (M - int(A.replace('x', '')) % M) % M\n        if A.endswith('x'):\n            return (M - int(A.replace('x', '')) % M) % M\n        for i in range(M):\n            if (i + eval(A.replace('x', 'i')) % M) == P:\n                return i\n        return -1\n    \n    return str(find_min_x(A, P, M))"
    },
    {
        "number": 3193,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = stdin.split()\n    P, M = int(P), int(M)\n    x = 0\n    while True:\n        A_val = eval(A)\n        if A_val % M == P:\n            return str(x)\n        x += 1"
    },
    {
        "number": 3193,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    expression = lines[0]\n    P, M = map(int, lines[1].split())\n\n    def evaluate(expression, x_value):\n        stack = []\n        i = 0\n        while i < len(expression):\n            if expression[i] == \"x\":\n                stack.append(x_value)\n            elif expression[i] == \"(\":\n                j = i + 1\n                while expression[j] != \")\":\n                    j += 1\n                sub_expression = expression[i + 1:j]\n                i = j\n                stack.append(evaluate(sub_expression, x_value))\n            else:\n                num = \"\"\n                while i < len(expression) and expression[i].isdigit():\n                    num += expression[i]\n                    i += 1\n                stack.append(int(num))\n                i -= 1\n            i += 1\n\n        result = 0\n        while stack:\n            op = stack.pop()\n            if op == \"+\":\n                result += stack.pop()\n            elif op == \"-\":\n                result = stack.pop() - result\n            elif op == \"*\":\n                result *= stack.pop()\n        return result\n\n    def find_min_x(expression, P, M):\n        min_x = float(\"inf\")\n        for x in range(M):\n            if evaluate(expression, x) % M == P:\n                min_x = min(min_x, x)\n        return min_x\n\n    return str(find_min_x(expression, P, M))"
    },
    {
        "number": 3193,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    expression = input_list[0]\n    P, M = map(int, input_list[1].split())\n\n    # Remove all the operators and parentheses from the expression\n    expression_without_operators = expression\n    for operator in [\"+\", \"-\", \"*\"]:\n        expression_without_operators = expression_without_operators.replace(operator, \"\")\n    expression_without_operators = expression_without_operators.replace(\"(\", \"\").replace(\")\", \"\")\n\n    # Calculate the coefficients of the expression\n    coefficients = expression_without_operators.split(\"x\")\n    if coefficients[0] == \"\":\n        coefficients[0] = \"1\"\n    if len(coefficients) == 1:\n        coefficients.append(\"0\")\n    a, b = map(int, coefficients)\n\n    # Calculate the minimal non-negative value of x\n    x = (P - a) % M\n    if x < 0:\n        x += M\n\n    return str(x)"
    },
    {
        "number": 3193,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input into expression and numbers\n    expression, p, m = stdin.split()\n    p, m = int(p), int(m)\n\n    # Function to evaluate the expression for a given value of x\n    def evaluate_expression(x_value):\n        # Replace 'x' in the expression with the given x_value\n        expr = expression.replace('x', str(x_value))\n\n        # Evaluate the expression using Python's eval function\n        result = eval(expr)\n\n        return result\n\n    # Initialize the minimum value of x as None\n    min_x = None\n\n    # Loop through all possible values of x starting from 0\n    for x_value in range(m):\n        # Evaluate the expression for the current value of x\n        result = evaluate_expression(x_value)\n\n        # Check if the remainder when dividing the result by m is equal to p\n        if result % m == p:\n            # If it is, update the minimum value of x\n            min_x = x_value\n            break\n\n    # If a valid value of x is found, return it as the output\n    if min_x is not None:\n        return str(min_x)\n    # If no valid value of x is found, return -1 as the output\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3193,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = stdin.split()\n    P = int(P)\n    M = int(M)\n\n    def find_minimal_x(expression, p, m):\n        if 'x' not in expression:\n            return (p - eval(expression)) % m\n        if expression.startswith('x'):\n            x_pos = expression.index('x')\n            if x_pos == 0:\n                return find_minimal_x(expression[1:], p, m)\n            else:\n                return find_minimal_x(expression[x_pos:], p, m)\n        else:\n            x_pos = expression.index('x')\n            if x_pos > 0:\n                left_part = expression[:x_pos]\n                if 'x' in left_part:\n                    return None\n                left_value = eval(left_part)\n                if left_value < 0:\n                    return None\n                right_part = expression[x_pos + 1:]\n                return find_minimal_x(right_part, p - left_value, m)\n            else:\n                return None\n\n    return str(find_minimal_x(A, P, M))"
    },
    {
        "number": 3193,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    expression, *args = stdin.split('\\n')\n    P, M = map(int, args)\n\n    def validate_expression(exp: str) -> bool:\n        if exp[0] == '(' and exp[-1] == ')':\n            return validate_expression(exp[1:-1])\n\n        if exp[0] == 'x':\n            return len(exp) == 1\n\n        for i, c in enumerate(exp):\n            if c in '+-*':\n                if i == 0 or not validate_expression(exp[:i]):\n                    return False\n                if i == len(exp) - 1 or not validate_expression(exp[i + 1:]):\n                    return False\n                return True\n\n        return exp.isdigit()\n\n    if not validate_expression(expression):\n        raise ValueError(\"Invalid expression\")\n\n    def evaluate(exp: str, x: int) -> int:\n        if exp[0] == '(' and exp[-1] == ')':\n            return evaluate(exp[1:-1], x)\n\n        if exp[0] == 'x':\n            return x\n\n        for i, c in enumerate(exp):\n            if c in '+-*':\n                left, right = exp[:i], exp[i + 1:]\n                if c == '+':\n                    return evaluate(left, x) + evaluate(right, x)\n                elif c == '-':\n                    return evaluate(left, x) - evaluate(right, x)\n                else:\n                    return evaluate(left, x) * evaluate(right, x)\n\n        return int(exp)\n\n    def find_minimum_x(p: int, m: int) -> int:\n        x = 0\n        while True:\n            if evaluate(expression, x) % m == p:\n                return x\n            x += 1\n\n    return str(find_minimum_x(P, M)) "
    },
    {
        "number": 3193,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = stdin.split()\n    P = int(P)\n    M = int(M)\n    x = -1\n    while True:\n        x += 1\n        if (eval(A) % M) == P:\n            return x"
    },
    {
        "number": 3193,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    expression, P, M = stdin.split()\n    P, M = int(P), int(M)\n\n    def evaluate(expr, x_value):\n        stack = []\n        i = 0\n        while i < len(expr):\n            if expr[i] == \"(\":\n                stack.append(\"(\")\n            elif expr[i] == \")\":\n                sub_expr = []\n                while stack[-1] != \"(\":\n                    sub_expr.append(stack.pop())\n                stack.pop()\n                sub_expr = sub_expr[::-1]\n                stack.append(str(evaluate(sub_expr, x_value)))\n            else:\n                if len(stack) > 0 and stack[-1].isdigit():\n                    stack[-1] += expr[i]\n                else:\n                    stack.append(expr[i])\n            i += 1\n        result = 0\n        operator = \"+\"\n        for token in stack:\n            if token.isdigit():\n                if operator == \"+\":\n                    result += int(token)\n                elif operator == \"-\":\n                    result -= int(token)\n                elif operator == \"*\":\n                    result *= int(token)\n            elif token == \"+\":\n                operator = \"+\"\n            elif token == \"-\":\n                operator = \"-\"\n            elif token == \"*\":\n                operator = \"*\"\n        return result\n\n    def find_min_x(expr, P, M, x_value=0):\n        if evaluate(expr, x_value) % M == P:\n            return x_value\n        elif evaluate(expr, x_value) % M < P:\n            return find_min_x(expr, P, M, x_value + 1)\n        else:\n            return None\n\n    min_x = find_min_x(expression, P, M)\n    if min_x is None:\n        return \"No solution found\"\n    else:\n        return str(min_x)"
    },
    {
        "number": 3194,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n    def is_possible(a, b, time_slots):\n        for i in range(len(time_slots)):\n            if a <= time_slots[i] <= b:\n                return True\n        return False\n\n    n, t = map(int, stdin.readline().strip().split())\n    time_slots = []\n\n    for _ in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        time_slots.append((a, b))\n\n    time_slots.sort()\n\n    for i in range(n):\n        a, b = time_slots[i]\n        if not is_possible(a, b, time_slots):\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3194,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_overlap(a1, b1, a2, b2):\n        return not (b1 <= a2 or b2 <= a1)\n\n    def is_compatible(photos):\n        for i in range(len(photos) - 1):\n            if is_overlap(photos[i][0], photos[i][1] + t, photos[i + 1][0], photos[i + 1][1]):\n                return False\n        return True\n\n    n, t = map(int, stdin.readline().split())\n    photos = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    if is_compatible(photos):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3194,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def check_time_overlap(photos, new_photo):\n        for photo in photos:\n            if (photo[0] < new_photo[1] and new_photo[0] < photo[1]) or (photo[0] < new_photo[0] < photo[1]) or (new_photo[0] < photo[0] < new_photo[1]):\n                return True\n        return False\n\n    def can_take_photos(n, t, photos):\n        photos.sort()\n        for i in range(n):\n            if i == 0:\n                continue\n            if photos[i][0] < photos[i - 1][1] + t:\n                return False\n        return True\n\n    n, t = map(int, stdin.readline().strip().split())\n    photos = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    for photo in photos:\n        if not check_time_overlap(photos, photo):\n            if can_take_photos(n, t, photos):\n                return \"yes\"\n    return \"no\""
    },
    {
        "number": 3194,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(a: int, b: int, t: int, start: int, end: int) -> bool:\n        return (start <= a <= end) and (start <= b - t <= end)\n\n    input_data = list(map(int, stdin.split()))\n    n, t = input_data[0], input_data[1]\n    time_periods = input_data[2:]\n\n    start, end = 0, 10**9\n    for a, b in zip(time_periods[::2], time_periods[1::2]):\n        if not is_valid(a, b, t, start, end):\n            return \"no\"\n\n    return \"yes\"\n"
    },
    {
        "number": 3194,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(a, b, t):\n        return a + t <= b\n\n    def merge_intervals(intervals):\n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n\n        for interval in intervals[1:]:\n            if interval[0] <= merged[-1][1]:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n            else:\n                merged.append(interval)\n\n        return merged\n\n    n, t = map(int, stdin.readline().split())\n    intervals = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    for interval in intervals:\n        if not is_possible(interval[0], interval[1], t):\n            return \"no\"\n\n    merged = merge_intervals(intervals)\n\n    for interval in merged:\n        if interval[1] - interval[0] > 2 * t:\n            return \"no\"\n\n    return \"yes\" "
    },
    {
        "number": 3194,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def can_take_all_photos(tasks, time_per_task):\n        tasks.sort()\n        n = len(tasks)\n        for i in range(n):\n            if tasks[i][0] + time_per_task > tasks[i][1]:\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    n, t = map(int, lines[0].split())\n    tasks = []\n    for i in range(1, n + 1):\n        a, b = map(int, lines[i].split())\n        tasks.append((a, b))\n\n    if can_take_all_photos(tasks, t):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3194,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_overlap(a1, b1, a2, b2):\n        if a1 <= a2 <= b1:\n            return True\n        if a1 <= b2 <= b1:\n            return True\n        if a2 <= a1 <= b2:\n            return True\n        if a2 <= b1 <= b2:\n            return True\n        return False\n\n    n, t = map(int, stdin.readline().split())\n    times = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().split())\n        times.append((a, b))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_overlap(times[i][0], times[i][1], times[j][0], times[j][1]):\n                if times[i][0] <= times[j][0]:\n                    times[i] = (times[j][0] + t, times[i][1])\n                else:\n                    times[j] = (times[i][0] + t, times[j][1])\n\n    for i in range(n):\n        if times[i][0] > times[i][1]:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3194,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_overlap(start1, end1, start2, end2):\n        return not (end1 < start2 or start1 > end2)\n\n    def is_compatible(tasks, t):\n        for i in range(len(tasks)):\n            task = tasks[i]\n            start_time = task[0]\n            end_time = task[1]\n            if start_time + t > end_time:\n                return False\n            for j in range(len(tasks)):\n                if i != j:\n                    if is_overlap(start_time, start_time + t, tasks[j][0], tasks[j][1]):\n                        return False\n        return True\n\n    input_list = stdin.strip().split(\"\\n\")\n    n, t = map(int, input_list[0].split())\n    tasks = []\n    for i in range(1, n + 1):\n        a, b = map(int, input_list[i].split())\n        tasks.append((a, b))\n\n    if is_compatible(tasks, t):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3194,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_overlap(a1, b1, a2, b2):\n        if a1 <= a2 <= b1:\n            return True\n        if a1 <= b2 <= b1:\n            return True\n        if a2 <= a1 <= b2:\n            return True\n        if a2 <= b1 <= b2:\n            return True\n        return False\n\n    n, t = map(int, stdin.readline().strip().split())\n    events = []\n\n    for _ in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        events.append((a, 'start'))\n        events.append((b, 'end'))\n\n    events.sort()\n    current_events = []\n\n    for event in events:\n        if event[1] == 'start':\n            current_events.append(event)\n        else:\n            current_events.remove(event)\n\n        for other_event in current_events:\n            if is_overlap(event[0], other_event[0] + t, other_event[0], other_event[0] + t):\n                return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3194,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.readline().split())\n    time_periods = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    time_periods.sort(key=lambda x: x[1])\n\n    last_completion_time = 0\n    for a, b in time_periods:\n        if a < last_completion_time:\n            a = last_completion_time\n        if a + t > b:\n            return \"no\"\n        last_completion_time = a + t\n\n    return \"yes\""
    },
    {
        "number": 3195,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r, n = map(int, stdin.readline().split())\n    observations = []\n    for _ in range(n):\n        t, c = stdin.readline().split()\n        observations.append((int(t), c))\n    t_q, c_q = stdin.readline().split()\n    t_q, c_q = int(t_q), c_q\n\n    # Calculate all possible values of T\n    possible_T = []\n    for i in range(len(observations) - 1):\n        t1, c1 = observations[i]\n        t2, c2 = observations[i + 1]\n        if c1 == c2:\n            continue\n        if c1 == \"green\" and c2 == \"yellow\":\n            possible_T.append(t1 - T_g)\n        elif c1 == \"yellow\" and c2 == \"red\":\n            possible_T.append(t1 - T_g - T_y)\n        elif c1 == \"red\" and c2 == \"green\":\n            possible_T.append(t1 - T_g - T_y - T_r)\n\n    # Calculate the probabilities for each possible T\n    probabilities = []\n    for T in possible_T:\n        green_time = (T + T_g) % (T_g + T_y + T_r)\n        yellow_time = (T + T_g + T_y) % (T_g + T_y + T_r)\n        red_time = (T + T_g + T_y + T_r) % (T_g + T_y + T_r)\n        probability = 0\n        if c_q == \"green\":\n            probability = green_time / (T_g + T_y + T_r)\n        elif c_q == \"yellow\":\n            probability = yellow_time / (T_g + T_y + T_r)\n        elif c_q == \"red\":\n            probability = red_time / (T_g + T_y + T_r)\n        probabilities.append(probability)\n\n    # Calculate the final probability\n    probability_sum = sum(probabilities)\n    if probability_sum == 0:\n        return 0.0\n    probability_avg = probability_sum / len(probabilities)\n\n    return f\"{probability_avg:.8f}\""
    },
    {
        "number": 3195,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n    observations = []\n    for _ in range(n):\n        time, color = stdin.readline().split()\n        observations.append((int(time), color))\n    t_q, c_q = stdin.readline().split()\n    t_q, c_q = int(t_q), c_q\n\n    probabilities = []\n    for T in range(max(t for t, c in observations)):\n        times = [T + T_g * i for i in range(2)] + [T + T_g + T_y * i for i in range(2)] + [T + T_g + T_y + T_r * i for i in range(2)]\n        colors = [\"green\", \"yellow\", \"red\"] * 2\n\n        green_times = [t for t, c in observations if c == \"green\"]\n        yellow_times = [t for t, c in observations if c == \"yellow\"]\n        red_times = [t for t, c in observations if c == \"red\"]\n\n        valid_green_times = [t for t in green_times if t in times]\n        valid_yellow_times = [t for t in yellow_times if t in times]\n        valid_red_times = [t for t in red_times if t in times]\n\n        if all(t in valid_green_times for t in green_times) and all(t in valid_yellow_times for t in yellow_times) and all(t in valid_red_times for t in red_times):\n            probabilities.append(sum(1 for t in valid_green_times if t <= t_q and c_q == \"green\") / len(valid_green_times))\n\n    return sum(probabilities) / len(probabilities)"
    },
    {
        "number": 3195,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r, n, *observations = map(int, stdin.split())\n    t_q, c_q = observations.pop()\n    observations = [(t, c) for t, c in zip(observations[::2], observations[1::2])]\n\n    def possible_T(t):\n        for i, (t_i, c_i) in enumerate(observations):\n            if t_i < t <= t_i + T_g + T_y + T_r:\n                if c_i == 'green':\n                    return t_i <= t < t_i + T_g\n                elif c_i == 'yellow':\n                    return t_i + T_g <= t < t_i + T_g + T_y\n                elif c_i == 'red':\n                    return t_i + T_g + T_y <= t < t_i + T_g + T_y + T_r\n        return False\n\n    possible_Ts = [(t_i, t_i + T_g + T_y + T_r) for t_i, c_i in observations]\n    possible_Ts = [range(start, end) for start, end in possible_Ts]\n    possible_Ts = set(t for r in possible_Ts for t in r)\n    possible_Ts = [t for t in possible_Ts if possible_T(t)]\n\n    count = sum(1 for t in possible_Ts if t <= t_q < t + T_g + T_y + T_r)\n    total = len(possible_Ts)\n    p = count / total if total > 0 else 0\n\n    return f\"{p:.8f}\""
    },
    {
        "number": 3195,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    T_g, T_y, T_r = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n    observations = []\n    for _ in range(n):\n        t, c = stdin.readline().split()\n        t, c = int(t), str(c)\n        observations.append((t, c))\n    t_q, c_q = stdin.readline().split()\n    t_q, c_q = int(t_q), str(c_q)\n\n    # Calculate possible values of T\n    T_values = set()\n    for i in range(n):\n        if observations[i][1] == 'green':\n            T_values.add(observations[i][0] - T_g)\n        elif observations[i][1] == 'yellow':\n            T_values.add(observations[i][0] - T_g - T_y)\n        elif observations[i][1] == 'red':\n            T_values.add(observations[i][0] - T_g - T_y - T_r)\n\n    # Calculate probability\n    p = 0\n    for T in T_values:\n        if (t_q >= T) and (t_q < T + T_g):\n            if c_q == 'green':\n                p += 1 / len(T_values)\n        elif (t_q >= T + T_g) and (t_q < T + T_g + T_y):\n            if c_q == 'yellow':\n                p += 1 / len(T_values)\n        elif (t_q >= T + T_g + T_y) and (t_q < T + T_g + T_y + T_r):\n            if c_q == 'red':\n                p += 1 / len(T_values)\n\n    return f\"{p:.6f}\""
    },
    {
        "number": 3195,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    T_g, T_y, T_r = map(int, lines[0].split())\n    n = int(lines[1])\n    observations = []\n    for i in range(2, n + 2):\n        t, color = lines[i].split()\n        t = int(t)\n        observations.append((t, color))\n    t_q, c_q = lines[-1].split()\n    t_q = int(t_q)\n\n    # Probability that the light will be green at time t_q\n    p = 0\n\n    # Iterate through all possible values of T\n    for T in range(0, t_q + T_g + T_y + T_r, T_g + T_y + T_r):\n        is_possible = True\n\n        # Check if the observations are consistent with this value of T\n        for t, color in observations:\n            if (t - T) % (T_g + T_y + T_r) >= T_g + T_y:\n                is_possible = False\n                break\n            elif (t - T) % (T_g + T_y + T_r) == T_g + T_y and color != \"red\":\n                is_possible = False\n                break\n            elif (t - T) % (T_g + T_y + T_r) == 0 and color != \"green\":\n                is_possible = False\n                break\n\n        # If the observations are consistent, add the probability of this value of T to p\n        if is_possible:\n            p += 1 / (T_g + T_y + T_r)\n\n    return f\"{p:.6f}\""
    },
    {
        "number": 3195,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r, n = map(int, stdin.readline().split())\n    observations = []\n    for _ in range(n):\n        t, c = stdin.readline().split()\n        observations.append((int(t), c))\n\n    t_q, c_q = stdin.readline().split()\n    t_q, c_q = int(t_q), c_q\n\n    total_duration = T_g + T_y + T_r\n    num_cycles = (observations[-1][0] - observations[0][0]) // total_duration\n\n    consistent_T = set()\n    for i in range(num_cycles + 1):\n        T = observations[0][0] - i * total_duration\n        if T >= 0:\n            consistent_T.add(T)\n\n    for i in range(1, n):\n        consistent_T = {t for t in consistent_T if (observations[i][0] - t) % total_duration == 0}\n\n    if not consistent_T:\n        return 0\n\n    prob = 1 / len(consistent_T)\n    for T in consistent_T:\n        if (t_q - T) % total_duration in {0: T_g, T_g + T_y: T_r}[c_q]:\n            return prob\n\n    return 0"
    },
    {
        "number": 3195,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n    observations = []\n    for _ in range(n):\n        t, c = stdin.readline().split()\n        observations.append((int(t), c))\n    t_q, c_q = stdin.readline().split()\n    t_q, c_q = int(t_q), c_q\n\n    possible_T_values = []\n    for t, c in observations:\n        if c == c_q:\n            possible_T_values.append(t % (T_g + T_y + T_r))\n\n    # Find all possible values of T that are consistent with the observations\n    possible_T_values = set(possible_T_values)\n    consistent_T_values = []\n    for T in possible_T_values:\n        green_times = [T, T + T_g, T + T_g + T_y, T + T_g + T_y + T_r]\n        green_times = [t % (T_g + T_y + T_r) for t in green_times]\n        if all(t in possible_T_values for t in green_times):\n            consistent_T_values.append(T)\n\n    # Calculate the probability of the lights being green at time t_q\n    total_T_values = len(consistent_T_values)\n    if total_T_values == 0:\n        return 0\n\n    prob = 0\n    for T in consistent_T_values:\n        if T <= t_q < T + T_g:\n            prob += 1 / total_T_values\n\n    return prob"
    },
    {
        "number": 3195,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r, n = map(int, stdin.readline().split())\n    observations = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    t_q, c_q = stdin.readline().split()\n    t_q, c_q = int(t_q), c_q\n\n    def is_valid_T(T: int) -> bool:\n        for t, c in observations:\n            if c == \"green\":\n                if t < T or t >= T + T_g:\n                    return False\n            elif c == \"yellow\":\n                if t < T + T_g or t >= T + T_g + T_y:\n                    return False\n            else:\n                if t < T + T_g + T_y or t >= T + T_g + T_y + T_r:\n                    return False\n        return True\n\n    valid_T_count = sum(is_valid_T(T) for T in range(0, t_q + 1))\n    total_T_count = t_q + 1\n\n    if c_q == \"green\":\n        p = valid_T_count / total_T_count\n    else:\n        p = (total_T_count - valid_T_count) / total_T_count\n\n    return f\"{p:.6f}\""
    },
    {
        "number": 3195,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_possible_T(T_g, T_y, T_r, observations):\n        possible_T = []\n        for t, color in observations:\n            if color == \"green\":\n                possible_T.append(t % (T_g + T_y + T_r))\n            elif color == \"yellow\":\n                possible_T.append(t % (T_g + T_y + T_r) - T_g)\n            else:\n                possible_T.append(t % (T_g + T_y + T_r) - T_g - T_y)\n        return possible_T\n\n    def find_probability(T_g, T_y, T_r, possible_T, t_q, c_q):\n        count = 0\n        for T in possible_T:\n            if c_q == \"green\":\n                if T_g - T_g * 10 ** -3 <= t_q % (T_g + T_y + T_r) - T <= T_g + T_g * 10 ** -3:\n                    count += 1\n            elif c_q == \"yellow\":\n                if T_y - T_y * 10 ** -3 <= t_q % (T_g + T_y + T_r) - T - T_g <= T_y + T_y * 10 ** -3:\n                    count += 1\n            else:\n                if T_r - T_r * 10 ** -3 <= t_q % (T_g + T_y + T_r) - T - T_g - T_y <= T_r + T_r * 10 ** -3:\n                    count += 1\n        return count / len(possible_T)\n\n    lines = stdin.strip().split(\"\\n\")\n    T_g, T_y, T_r = map(int, lines[0].strip().split())\n    n = int(lines[1].strip())\n    observations = [tuple(map(lambda x: x.strip(), line.strip().split())) for line in lines[2:n+2]]\n    t_q, c_q = tuple(map(lambda x: x.strip(), lines[-1].strip().split()))\n    t_q = int(t_q)\n\n    possible_T = find_possible_T(T_g, T_y, T_r, observations)\n    probability = find_probability(T_g, T_y, T_r, possible_T, t_q, c_q)\n    return \"{:.3f}\".format(probability)"
    },
    {
        "number": 3195,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n    observations = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    t_q, c_q = stdin.readline().split()\n    t_q, c_q = int(t_q), c_q\n\n    # Calculate the possible values of T\n    T_values = set()\n    for i in range(len(observations) - 1):\n        t1, c1 = observations[i]\n        t2, c2 = observations[i + 1]\n        if c1 != c2:\n            if c1 == 'green':\n                T_values.add(t1 - T_g)\n            elif c1 == 'yellow':\n                T_values.add(t1 - T_g - T_y)\n            elif c1 == 'red':\n                T_values.add(t1 - T_g - T_y - T_r)\n\n    # Calculate the probability of the lights being color c_q at time t_q\n    probability = 0\n    for T in T_values:\n        if T <= t_q < T + T_g:\n            if c_q == 'green':\n                probability += 1 / len(T_values)\n        elif T + T_g <= t_q < T + T_g + T_y:\n            if c_q == 'yellow':\n                probability += 1 / len(T_values)\n        elif T + T_g + T_y <= t_q < T + T_g + T_y + T_r:\n            if c_q == 'red':\n                probability += 1 / len(T_values)\n\n    return f\"{probability:.6f}\""
    },
    {
        "number": 3196,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n\n    roads = [set() for _ in range(N + 1)]\n    for i in range(M):\n        A, B = map(int, lines[i + 1].split())\n        roads[A].add(B)\n\n    dp = [0] * (N + 1)\n    dp[1] = 1\n\n    for i in range(1, N + 1):\n        for j in roads[i]:\n            dp[j] += dp[i]\n\n    if dp[2] > 999999999:\n        return \"inf\"\n    else:\n        return str(dp[2])"
    },
    {
        "number": 3196,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split('\\n')[0].split())\n    roads = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # Create an adjacency list\n    adjacency = [[] for _ in range(N + 1)]\n    for A, B in roads:\n        adjacency[A].append(B)\n\n    # Perform DFS to count the number of distinct routes\n    visited = [False] * (N + 1)\n    distinct_routes = [0]\n\n    def dfs(node):\n        if node == 2:\n            distinct_routes[0] += 1\n            return\n        visited[node] = True\n        for neighbor in adjacency[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        visited[node] = False\n\n    dfs(1)\n\n    # Check if the number of distinct routes is too large\n    if distinct_routes[0] >= 1000000000:\n        return \"inf\"\n    else:\n        return str(distinct_routes[0])[-9:]"
    },
    {
        "number": 3196,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n + 1)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        adj_list[a].append(b)\n\n    visited = [False] * (n + 1)\n    route_count = [0] * (n + 1)\n    route_count[2] = 1\n\n    def dfs(current):\n        visited[current] = True\n        for neighbor in adj_list[current]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n                route_count[current] += route_count[neighbor]\n\n    dfs(1)\n\n    if route_count[1] > 999999999:\n        return \"inf\"\n    else:\n        return str(route_count[1] % 1000000000)[-9:]"
    },
    {
        "number": 3196,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split('\\n')[0].split())\n    roads = [set() for _ in range(N + 1)]\n\n    for i in range(M):\n        A, B = map(int, stdin.split('\\n')[i + 1].split())\n        roads[A].add(B)\n\n    visited = [False] * (N + 1)\n    visited[1] = True\n    stack = [1]\n\n    count = 0\n\n    while stack:\n        current = stack[-1]\n\n        if current == 2:\n            count += 1\n            if count % 1000000000 == 0:\n                return \"inf\"\n            stack.pop()\n            continue\n\n        found = False\n        for neighbor in roads[current]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n                visited[neighbor] = True\n                found = True\n                break\n\n        if not found:\n            stack.pop()\n            visited[current] = False\n\n    return str(count % 1000000000)"
    },
    {
        "number": 3196,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    graph = [[] for _ in range(N+1)]\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    visited = [False] * (N+1)\n    def dfs(node):\n        if visited[node]:\n            return 0\n        visited[node] = True\n        count = 1\n        for neighbor in graph[node]:\n            count *= dfs(neighbor) + 1\n        return count\n    \n    result = dfs(1)\n    return str(result)[-9:] if result < 10**9 else \"inf\""
    },
    {
        "number": 3196,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n\n    dp = [0] * (N + 1)\n    dp[1] = 1\n\n    for i in range(1, N + 1):\n        for j in range(len(graph[i])):\n            dp[graph[i][j]] += dp[i]\n\n    return str(dp[2])[-9:] if dp[2] != 0 else \"inf\""
    },
    {
        "number": 3196,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, M = map(int, input_list[0].split())\n    graph = [[] for _ in range(N + 1)]\n    for i in range(M):\n        a, b = map(int, input_list[i + 1].split())\n        graph[a].append(b)\n    dp = [0] * (N + 1)\n    for i in range(N - 1, -1, -1):\n        for j in graph[i]:\n            dp[i] += dp[j]\n        dp[i] += 1\n    if dp[1] >= 1000000000:\n        return \"inf\"\n    else:\n        return str(dp[1])[-9:]"
    },
    {
        "number": 3196,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    N, M = input_data[0], input_data[1]\n    roads = input_data[2:]\n    graph = [[] for _ in range(N + 1)]\n\n    for i in range(M):\n        a, b = roads[i * 2], roads[i * 2 + 1]\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (N + 1)\n    paths = [0] * (N + 1)\n    paths[1] = 1\n\n    def dfs(node: int) -> None:\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n                paths[node] += paths[neighbor]\n\n    dfs(1)\n    result = paths[2]\n\n    if result > 10**9:\n        return \"inf\"\n    else:\n        return str(result % 10**9)"
    },
    {
        "number": 3196,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    graph = [[] for _ in range(N + 1)]\n    for i in range(1, M + 1):\n        A, B = map(int, lines[i].split())\n        graph[A].append(B)\n        graph[B].append(A)\n\n    visited = [False] * (N + 1)\n    count = 0\n\n    def dfs(node):\n        nonlocal count\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        count += 1\n\n    dfs(1)\n    return str(count % 1000000000)"
    },
    {
        "number": 3196,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n\n    visited = [False] * (N + 1)\n    mod = 10**9 + 7\n    result = 0\n\n    def dfs(node):\n        nonlocal result, mod\n        if not graph[node]:\n            return 1\n        visited[node] = True\n        sub_results = []\n        for next_node in graph[node]:\n            if not visited[next_node]:\n                sub_results.append(dfs(next_node))\n        visited[node] = False\n\n        if not sub_results:\n            return 1\n\n        sub_result_sum = sum(sub_results)\n        result += sub_result_sum\n        result %= mod\n        return sub_result_sum - 1\n\n    dfs(1)\n\n    return str(result) if result < mod else \"inf\""
    },
    {
        "number": 3197,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    preferences = list(map(int, stdin.split('\\n')[1].split()))\n\n    def get_max_participants(n: int, k: int, preferences: list) -> int:\n        participants = set()\n        for i in range(1, n + 1):\n            if i not in participants and preferences.count(i) <= k - len(participants):\n                participants.add(i)\n        return len(participants)\n\n    return str(get_max_participants(n, k, preferences))"
    },
    {
        "number": 3197,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    preferences = list(map(int, input().split()))\n\n    def dfs(start, count):\n        if count == k:\n            return True\n        if start >= n:\n            return False\n        for i in range(start + 1, n):\n            if preferences[start] == i + 1 and dfs(i, count + 1):\n                return True\n        return dfs(n, count)\n\n    for i in range(n):\n        if dfs(i, 1):\n            return str(i + 1)\n    return \"0\""
    },
    {
        "number": 3197,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited, group, limit):\n        if len(group) == limit:\n            return group\n        for i in range(start, n):\n            if not visited[i] and (x[i] == i + 1 or visited[x[i] - 1]):\n                visited[i] = True\n                group.append(i + 1)\n                if dfs(i + 1, visited, group, limit) is not None:\n                    return group\n                group.pop()\n                visited[i] = False\n        return None\n\n    n, k = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    visited = [False] * n\n    max_group = []\n\n    for limit in range(1, k + 1):\n        group = dfs(0, visited, [], limit)\n        if group is not None and len(group) > len(max_group):\n            max_group = group\n\n    return str(len(max_group))"
    },
    {
        "number": 3197,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    preferences = [int(x) for x in stdin.readline().split()]\n\n    # Create a dictionary to store the preferences\n    pref_dict = {}\n    for i in range(1, n + 1):\n        pref_dict[i] = preferences[i - 1]\n\n    # Create a dictionary to store the number of participants that can join\n    can_join = {}\n    for i in range(1, n + 1):\n        if i not in can_join:\n            can_join[i] = 1\n        if pref_dict[i] not in can_join:\n            can_join[pref_dict[i]] = 1\n        else:\n            can_join[pref_dict[i]] += 1\n\n    # Find the maximum number of participants that can join\n    max_participants = 0\n    for i in range(1, n + 1):\n        if i in can_join and can_join[i] <= k:\n            max_participants += 1\n            k -= 1\n\n    return str(max_participants)"
    },
    {
        "number": 3197,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    preferences = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid_group(group: set) -> bool:\n        for participant in group:\n            if preferences[participant - 1] not in group:\n                return False\n        return True\n\n    def find_max_group(idx: int, group: set, max_group: set) -> set:\n        if idx == n:\n            return max_group\n\n        if len(group) + 1 > k:\n            return max_group\n\n        if idx not in group and is_valid_group(group | {idx}):\n            max_group = max(max_group, find_max_group(idx + 1, group | {idx}, max_group))\n\n        return find_max_group(idx + 1, group, max_group)\n\n    return str(len(find_max_group(0, set(), set())))"
    },
    {
        "number": 3197,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    preferences = list(map(int, stdin.split()))\n\n    def find_max_participants(preferences, k):\n        n = len(preferences)\n        graph = [[] for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n            graph[i].append(preferences[i - 1])\n            graph[preferences[i - 1]].append(i)\n\n        visited = [False] * (n + 1)\n        stack = []\n        result = 0\n\n        for i in range(1, n + 1):\n            if not visited[i]:\n                stack.append(i)\n                visited[i] = True\n\n                while stack:\n                    curr = stack.pop()\n                    result += 1\n\n                    for neighbor in graph[curr]:\n                        if not visited[neighbor]:\n                            stack.append(neighbor)\n                            visited[neighbor] = True\n\n                            if result == k:\n                                return k\n\n        return result\n\n    max_participants = find_max_participants(preferences, k)\n\n    return str(max_participants)"
    },
    {
        "number": 3197,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    preferences = list(map(int, stdin.readline().split()))\n\n    graph = [[] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        graph[preferences[i - 1]].append(i)\n\n    visited = [False] * (n + 1)\n    stack = []\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        stack.append(node)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i)\n\n    result = 0\n    bus = []\n    while stack:\n        node = stack.pop()\n        if len(bus) + 1 <= k:\n            bus.append(node)\n            result += 1\n        else:\n            break\n\n    return str(result)"
    },
    {
        "number": 3197,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    preferences = [int(x) for x in stdin.readline().split()]\n\n    def dfs(start, count):\n        if count == k:\n            return True\n        if start >= n:\n            return False\n\n        for i in range(start, n):\n            if preferences[i] == i + 1:\n                preferences[i] = -1\n                if dfs(i + 1, count + 1):\n                    return True\n                preferences[i] = i + 1\n        return False\n\n    if dfs(0, 0):\n        return k\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3197,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    preferences = list(map(int, stdin.split()))\n\n    def is_valid(candidates: set, preference: int) -> bool:\n        return preference in candidates or len(candidates) < n - k\n\n    def dfs(start: int, candidates: set) -> int:\n        if len(candidates) == k:\n            return k\n        if start >= n:\n            return 0\n\n        if not is_valid(candidates, preferences[start]):\n            return dfs(start + 1, candidates)\n\n        candidates.add(start)\n        count = dfs(start + 1, candidates)\n        if count == 0:\n            candidates.remove(start)\n            count = dfs(start + 1, candidates)\n\n        return max(count, dfs(start + 1, candidates))\n\n    return str(dfs(0, set()))"
    },
    {
        "number": 3197,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    preferences = list(map(int, stdin.split()))\n\n    def dfs(i, path):\n        if i > n:\n            return len(path)\n        if len(path) == k:\n            return k\n        for j in range(1, n + 1):\n            if j not in path and (preferences[i - 1] == j or preferences[j - 1] == i):\n                path.append(j)\n                result = dfs(i + 1, path)\n                if result == k:\n                    return k\n                path.pop()\n        return len(path)\n\n    return str(dfs(1, []))"
    },
    {
        "number": 3198,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_typo(word: str, dictionary: set) -> bool:\n        for i in range(len(word)):\n            if word[:i] + word[i + 1:] in dictionary:\n                return True\n        return False\n\n    n = int(stdin.readline())\n    dictionary = set()\n    typos = []\n\n    for i in range(n):\n        word = stdin.readline().strip()\n        dictionary.add(word)\n\n    for word in dictionary:\n        if is_typo(word, dictionary):\n            typos.append(word)\n\n    if not typos:\n        return \"NO TYPOS\"\n    else:\n        return \"\\n\".join(typos)"
    },
    {
        "number": 3198,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_typo(word: str, dictionary: set) -> bool:\n        for i in range(len(word)):\n            candidate = word[:i] + word[i+1:]\n            if candidate in dictionary:\n                return True\n        return False\n\n    def main(stdin: str) -> list:\n        n = int(stdin.readline())\n        dictionary = set()\n        for _ in range(n):\n            word = stdin.readline().strip()\n            dictionary.add(word)\n\n        typos = []\n        for word in dictionary:\n            if is_typo(word, dictionary):\n                typos.append(word)\n\n        return typos\n\n    typos = main(stdin)\n    if typos:\n        return \"\\n\".join(typos) + \"\\n\"\n    else:\n        return \"NO TYPOS\\n\""
    },
    {
        "number": 3198,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    words = []\n    for i in range(n):\n        words.append(stdin.readline().strip())\n\n    typos = []\n    for word in words:\n        for i in range(len(word)):\n            candidate = word[:i] + word[i+1:]\n            if candidate in words and candidate != word:\n                typos.append(word)\n                break\n\n    if not typos:\n        return \"NO TYPOS\"\n    else:\n        return \"\\n\".join(sorted(set(typos), key=words.index))"
    },
    {
        "number": 3198,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    dictionary = [stdin.readline().strip() for _ in range(n)]\n    typos = []\n\n    for i, word in enumerate(dictionary):\n        is_typo = False\n        for j in range(len(word)):\n            if word[j + 1:] + word[:j] in dictionary:\n                is_typo = True\n                break\n\n        if is_typo and word not in typos:\n            typos.append(word)\n\n    if typos:\n        return \"\\n\".join(typos)\n    else:\n        return \"NO TYPOS\""
    },
    {
        "number": 3198,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    words = sorted(stdin.split('\\n')[1:n+1])\n    typos = []\n\n    for i in range(n):\n        for j in range(len(words[i])):\n            candidate = words[i][:j] + words[i][j+1:]\n            if candidate in words and words[i] != candidate:\n                typos.append(words[i])\n                break\n\n    if len(typos) == 0:\n        return \"NO TYPOS\"\n    else:\n        return \"\\n\".join(sorted(list(set(typos)), key=words.index))"
    },
    {
        "number": 3198,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    words = [stdin.readline().strip() for _ in range(n)]\n    \n    typos = []\n    for i, word in enumerate(words):\n        for j in range(len(word)):\n            if word[j] == ' ':\n                continue\n            new_word = word[:j] + word[j+1:]\n            if new_word in words and new_word != word:\n                typos.append(word)\n                break\n                \n    if not typos:\n        return 'NO TYPOS'\n    else:\n        return '\\n'.join(typos)"
    },
    {
        "number": 3198,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    n = int(stdin.readline())\n    words = [stdin.readline().strip() for _ in range(n)]\n    \n    # Initialize the output list\n    typos = []\n    \n    # Iterate through the words\n    for i, word in enumerate(words):\n        # Iterate through the characters in the word\n        for j in range(len(word)):\n            # Delete the j-th character from the word\n            candidate = word[:j] + word[j+1:]\n            \n            # Check if the candidate is in the dictionary\n            if candidate in words and candidate != word:\n                typos.append(word)\n                break\n    \n    # Remove duplicates from the typos list\n    typos = list(set(typos))\n    \n    # Sort the typos list by their order of appearance in the input\n    typos = sorted(typos, key=lambda x: words.index(x))\n    \n    # Check if there are any typos\n    if len(typos) == 0:\n        return \"NO TYPOS\"\n    \n    # Display the typos\n    return \"\\n\".join(typos)"
    },
    {
        "number": 3198,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    words = set(stdin.split('\\n')[1:])\n    typos = set()\n\n    for word in words:\n        for i in range(len(word)):\n            if word[i+1:] in words or word[:i] in words:\n                typos.add(word)\n                break\n\n    if len(typos) == 0:\n        return \"NO TYPOS\"\n    else:\n        return \"\\n\".join(sorted(list(typos), key=lambda x: stdin.index(x)))"
    },
    {
        "number": 3198,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_typo(word, word_set):\n        for i in range(len(word)):\n            candidate = word[:i] + word[i+1:]\n            if candidate in word_set:\n                return True\n        return False\n\n    n = int(stdin.readline().strip())\n    dictionary = set()\n    typos = []\n\n    for _ in range(n):\n        word = stdin.readline().strip()\n        dictionary.add(word)\n\n    for word in dictionary:\n        if is_typo(word, dictionary):\n            typos.append(word)\n\n    if typos:\n        return \"\\n\".join(typos)\n    else:\n        return \"NO TYPOS\" "
    },
    {
        "number": 3198,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    dictionary = stdin.readlines()\n    dictionary = [word.strip() for word in dictionary]\n    typos = []\n\n    for i, word in enumerate(dictionary):\n        for j in range(len(word)):\n            candidate = word[:j] + word[j + 1:]\n            if candidate in dictionary and candidate != word:\n                typos.append(word)\n                break\n\n    if not typos:\n        return \"NO TYPOS\"\n    else:\n        return \"\\n\".join(typos)"
    },
    {
        "number": 3199,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure = secure = super_secure = 0\n\n    for x in range(1, L + 1):\n        for y in range(-A, B + 1):\n            if y == 0:\n                insecure += 1\n            elif y < 0:\n                if not (-y <= x <= B):\n                    secure += 1\n                else:\n                    super_secure += 1\n            else:\n                if not (-A <= x <= y):\n                    secure += 1\n                else:\n                    super_secure += 1\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3199,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure = 0\n    secure = 0\n    super_secure = 0\n\n    for x in range(1, L + 1):\n        for y in range(-A, B + 1):\n            if y < -A:\n                if x == 1:\n                    insecure += 1\n                else:\n                    secure += 1\n            elif y >= -A and y <= B:\n                if x == 1 or x == L:\n                    super_secure += 1\n                else:\n                    secure += 1\n            else:\n                insecure += 1\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3199,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    vaults = L * (A + 1 + B)\n    insecure = 0\n    secure = 0\n    super_secure = 0\n\n    for x in range(1, L + 1):\n        for y in range(-A, B + 1):\n            if not (-A <= y <= B) and not (-A <= -y <= B):\n                insecure += 1\n            elif (-A <= y <= B) != (-A <= -y <= B):\n                secure += 1\n            else:\n                super_secure += 1\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\\n\""
    },
    {
        "number": 3199,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure_count = 0\n    secure_count = 0\n    super_secure_count = 0\n\n    for i in range(1, L + 1):\n        for j in range(-A, B + 1):\n            if (i, j) == (0, -A) or (i, j) == (0, B):\n                continue\n            is_insecure = True\n            is_secure = False\n            is_super_secure = False\n\n            for k in range(1, i):\n                if (k, j) in [(0, -A), (0, B)]:\n                    continue\n                if (i, j) != (k, j):\n                    is_insecure = False\n                    if is_secure:\n                        is_super_secure = True\n                        break\n                else:\n                    is_secure = True\n                    if is_insecure:\n                        is_super_secure = True\n                        break\n\n            if is_insecure:\n                insecure_count += 1\n            elif is_secure:\n                secure_count += 1\n            elif is_super_secure:\n                super_secure_count += 1\n\n    return f\"{insecure_count}\\n{secure_count}\\n{super_secure_count}\""
    },
    {
        "number": 3199,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure = 0\n    secure = 0\n    super_secure = 0\n\n    for x in range(1, L + 1):\n        for y in range(-A, B + 1):\n            if y <= -A or y >= B:\n                insecure += 1\n            elif x == 1 or x == L or y == -A or y == B:\n                secure += 1\n            else:\n                super_secure += 1\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3199,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    total_vaults = L * (A + 1 + B)\n\n    # Find number of insecure vaults\n    insecure_vaults = 0\n    for x in range(1, L + 1):\n        for y in range(-A, B + 1):\n            if (x, y) != (0, -A) and (x, y) != (0, B):\n                insecure_vaults += 1\n\n    # Find number of secure vaults\n    secure_vaults = total_vaults - insecure_vaults\n\n    # Find number of super-secure vaults\n    super_secure_vaults = 0\n    for x in range(1, L + 1):\n        for y in range(-A, B + 1):\n            if (x, y) != (0, -A) and (x, y) != (0, B):\n                if ((0, -A) in [(x, y - i) for i in range(1, A + 1)] or \n                    (0, B) in [(x, y + i) for i in range(1, B + 1)]):\n                    super_secure_vaults += 1\n\n    # Return the output\n    return f\"{insecure_vaults}\\n{secure_vaults}\\n{super_secure_vaults}\""
    },
    {
        "number": 3199,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure = 0\n    secure = 0\n    super_secure = 0\n\n    for x in range(1, L + 1):\n        for y in range(-A, B + 1):\n            if (x, y) == (0, -A) or (x, y) == (0, B):\n                continue\n            if y < 0:\n                insecure += 1\n            elif y > 0:\n                secure += 1\n            else:\n                if x != L:\n                    secure += 1\n                else:\n                    insecure += 1\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3199,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n\n    insecure = secure = super_secure = 0\n\n    for x in range(1, L + 1):\n        for y in range(-A, B + 1):\n            if (x, y) == (0, -A) or (x, y) == (0, B):\n                continue\n            if (x, y) == (1, -A) or (x, y) == (1, B):\n                insecure += 1\n                continue\n\n            is_insecure = False\n            for n in range(1, x):\n                if (n, y) in [(0, -A), (0, B)]:\n                    continue\n                if (x - n, y) == (1, -A) or (x - n, y) == (1, B):\n                    is_insecure = True\n                    break\n\n            if is_insecure:\n                insecure += 1\n            elif (x, y) == (1, 0):\n                secure += 1\n            else:\n                super_secure += 1\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3199,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure = 0\n    secure = 0\n    super_secure = 0\n\n    for x in range(1, L + 1):\n        for y in range(-A, B + 1):\n            if y <= -A or y >= B:\n                continue\n            if x == 1 or x == L:\n                if y == -A or y == B:\n                    continue\n            if (x, y) == (1, -A) or (x, y) == (1, B) or (x, y) == (L, -A) or (x, y) == (L, B):\n                continue\n            if ((x, y) in [(1, -A), (1, B), (L, -A), (L, B)] and y not in [-A, B]) or (y == -A and x not in [1, L]) or (y == B and x not in [1, L]):\n                secure += 1\n            elif y == -A or y == B:\n                super_secure += 1\n            else:\n                insecure += 1\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3199,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure = secure = super_secure = 0\n\n    for x in range(1, L + 1):\n        for y in range(-A, B + 1):\n            if not (1 <= x <= L and -A <= y <= B):\n                continue\n\n            is_secure = False\n            if (0 <= y <= B) or (y < -A and (x - 1, y) in [(0, -A), (0, B)]) or (y > B and (x - 1, y) in [(0, B)]):\n                is_secure = True\n                secure += 1\n\n            if (0 <= y <= B) and ((x - 1, y) in [(0, -A), (0, B)]):\n                super_secure += 1\n\n            if not is_secure:\n                insecure += 1\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3200,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    times = []\n    for i in range(1, n):\n        times.append(list(map(int, stdin.split('\\n')[i].split())))\n\n    t_start = 0\n    t_end = 0\n    for i in range(n - 1):\n        if times[i][0] > times[i][1] + times[i][2]:\n            t_start += times[i][0] - times[i][1] - times[i][2]\n        else:\n            t_start += times[i][1]\n        t_end += times[i][1]\n\n    t_start += 1  # time to start the car\n    t_end += 1  # time to stop the car\n\n    t_min = max(t_start, t_end)\n    for i in range(n - 1):\n        if times[i][0] <= times[i][1] + times[i][2]:\n            t_min = max(t_min, t_start + times[i][0] + 1)\n            t_start += times[i][0] + times[i][1] + 1\n        else:\n            t_start += times[i][1] + times[i][2] + 1\n        t_end += times[i][1] + 1\n    return format(t_min, \".15f\")"
    },
    {
        "number": 3200,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, times = int(stdin.split('\\n')[0]), stdin.split('\\n')[1:]\n    total_time = 0.0\n    \n    for i in range(n - 1):\n        t, g, r = map(int, times[i].split())\n        total_time += t * 1000\n        \n        if t >= r:\n            total_time += g * 1000\n        else:\n            total_time += (t - r) * 1000\n            total_time += (g - (t - r)) * 1000\n            \n    total_time /= 1000\n    return f\"{total_time:.6f}\""
    },
    {
        "number": 3200,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def time_to_pass_light(green_time, red_time):\n        if green_time > red_time:\n            return 0\n        return green_time + red_time\n\n    n, *lights = list(map(int, stdin.split()))\n\n    total_time = 0\n    for i in range(n - 1):\n        t_i, g_i, r_i = lights[i]\n        total_time += time_to_pass_light(g_i, r_i)\n\n    return f\"{total_time:.6f}\""
    },
    {
        "number": 3200,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    lights = []\n    for _ in range(n - 1):\n        t, g, r = map(int, stdin.readline().strip().split())\n        if t > r:\n            t -= r\n            g, r = r, g\n        lights.append((t, g, r))\n\n    time = 0\n    distance = 0\n    for t, g, r in lights:\n        time += t - distance\n        distance = t + g\n        time += g / (1 * 1000 / 3600)\n\n    time += (n - 1 - distance) / (1 * 1000 / 3600)\n\n    return f\"{time:.10f}\""
    },
    {
        "number": 3200,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, times = int(stdin.readline().strip()), []\n    for i in range(n - 1):\n        t_i, g_i, r_i = map(int, stdin.readline().strip().split())\n        times.append((t_i, g_i, r_i))\n    \n    total_time = 0\n    current_position = 0\n    for i in range(n - 1):\n        t_i, g_i, r_i = times[i]\n        distance = 1000 * (i + 1) - current_position\n        time_to_pass_light = g_i + r_i - t_i if t_i < g_i + r_i else 0\n        total_time += (distance // 1000) * 2 + time_to_pass_light / 1000\n        current_position += distance\n    \n    return f\"{total_time:.12f}\""
    },
    {
        "number": 3200,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(lambda x: x.split(), stdin.split('\\n')[1:]))\n    n = int(stdin.split('\\n')[0])\n    time_to_green = [int(line[0]) for line in input_data]\n    green_duration = [int(line[1]) for line in input_data]\n    red_duration = [int(line[2]) for line in input_data]\n\n    def time_to_pass_light(green_duration: int, red_duration: int) -> int:\n        return green_duration + red_duration\n\n    total_time = 0\n    distance = 0\n    while distance < n:\n        time_to_next_light = (n - distance) * 1000\n        distance += 1\n\n        green_lights = [t for t in time_to_green if t <= time_to_next_light]\n        for i, t in enumerate(green_lights):\n            total_time += t\n            total_time += time_to_pass_light(green_duration[i], red_duration[i])\n            time_to_green.remove(t)\n            green_duration.pop(i)\n            red_duration.pop(i)\n\n        total_time += time_to_next_light - max(green_lights)\n\n    total_time += n * 1000\n\n    return f\"{total_time / 1000:.12f}\""
    },
    {
        "number": 3200,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    times = []\n    for i in range(n - 1):\n        t_i, g_i, r_i = map(int, stdin.readline().split())\n        if t_i <= r_i:\n            times.append(t_i)\n        else:\n            times.append(t_i - r_i)\n\n    total_time = 0\n    prev_time = 0\n    speed = 1\n    for i in range(len(times)):\n        distance = times[i] - prev_time\n        prev_time = times[i]\n        total_time += distance / speed\n        speed = 1\n\n    distance = n - prev_time\n    total_time += distance / speed\n\n    return total_time\n"
    },
    {
        "number": 3200,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *schedules = list(map(lambda x: list(map(int, x.split())), stdin.split('\\n')[1:]))\n\n    def time_to_pass_light(light_schedule):\n        t, g, r = light_schedule\n        if t < g + r:\n            return (g + r - t) * 1.0\n        else:\n            return t * 1.0\n\n    time_to_pass_lights = list(map(time_to_pass_light, schedules))\n    total_time = sum(time_to_pass_lights) + (n - 1) * 44.72135955\n\n    return f\"{total_time:.6f}\""
    },
    {
        "number": 3200,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, *schedule = list(map(int, stdin.split()))\n    time = 0\n    dist = 0\n    while dist < n:\n        min_green = min(g for t, g, r in schedule if t <= time)\n        time += min_green\n        dist += (time // 60) + 1\n        schedule = [(t, g, r) for t, g, r in schedule if t > time]\n    return f\"{time / 60:.10f}\""
    },
    {
        "number": 3200,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, *lights = map(lambda x: list(map(int, x.split())), stdin.split('\\n'))\n    total_time = 0\n    prev_red_light_time = 0\n    for i in range(n-1):\n        t, g, r = lights[i]\n        if t > r:\n            total_time += t - prev_red_light_time\n            prev_red_light_time = r + g\n        else:\n            green_light_time = t + g\n            total_time += green_light_time - prev_red_light_time\n            prev_red_light_time = green_light_time + r\n    total_time += n * 1000\n    return f\"{total_time:.6f}\""
    },
    {
        "number": 3201,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = map(int, stdin.readline().split())\n    arr = list(map(int, stdin.readline().split()))\n\n    def hash_func(subseq: List[int]) -> int:\n        p = len(subseq)\n        return sum(v * (B ** (p - i - 1)) for i, v in enumerate(subseq)) % M\n\n    def generate_subseq(start: int, end: int) -> List[int]:\n        return [arr[i] for i in range(start, end)]\n\n    subsequences = []\n    for i in range(1, 2 ** N):\n        bin_i = format(i, f'0{N}b')\n        subseq = generate_subseq(0, N)\n        for j in range(N):\n            if bin_i[j] == '0':\n                subseq = subseq[:j] + subseq[j + 1:]\n        subsequences.append(subseq)\n\n    subsequences.sort()\n    result = [hash_func(subseq) for subseq in subsequences[:K]]\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3201,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def generate_subsequences(arr):\n        return [[]] + [[arr[i]] + subseq for i in range(len(arr)) for subseq in generate_subsequences(arr[i + 1:])]\n\n    def hash_function(arr, B, M):\n        p = len(arr)\n        result = 0\n        for i in range(p):\n            result += arr[i] * B**(p - 1 - i)\n        return result % M\n\n    N, K, B, M = map(int, stdin.readline().split())\n    arr = list(map(int, stdin.readline().split()))\n\n    subsequences = sorted(generate_subsequences(arr))\n    result = []\n\n    for i in range(K):\n        result.append(hash_function(subsequences[i], B, M))\n\n    return \"\\n\".join(str(x) for x in result)"
    },
    {
        "number": 3201,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M, a = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    def get_subsequences(sequence):\n        return [[]] + [[sequence[i]] + subseq for i in range(len(sequence)) for subseq in get_subsequences(sequence[i + 1:])]\n\n    def hash_function(arr):\n        p = len(arr)\n        result = 0\n        for i, v in enumerate(arr):\n            result += v * (B ** (p - i - 1))\n        return result % M\n\n    subsequences = sorted(get_subsequences(a))\n    result = [hash_function(subseq) for subseq in subsequences[:K]]\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3201,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    s = sorted(set(a))\n\n    def hash_func(subseq: list) -> int:\n        p = len(subseq)\n        return sum(v * pow(B, p - i - 1, M) for i, v in enumerate(subseq)) % M\n\n    h_vals = [hash_func(s[:i]) * hash_func(s[i:]) for i in range(1, K + 1)]\n\n    return '\\n'.join(map(str, h_vals))"
    },
    {
        "number": 3201,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def hash_function(arr: List[int]) -> int:\n        p = len(arr)\n        value = 0\n        for i, v in enumerate(arr):\n            value += v * (B ** (p - i - 1))\n        return value % M\n\n    def generate_subsequences(arr: List[int], index: int, current_subsequence: List[int], subsequences: List[List[int]]):\n        if index == len(arr):\n            subsequences.append(current_subsequence.copy())\n            return\n        generate_subsequences(arr, index + 1, current_subsequence, subsequences)\n        current_subsequence.append(arr[index])\n        generate_subsequences(arr, index + 1, current_subsequence, subsequences)\n        current_subsequence.pop()\n\n    N, K, B, M = map(int, stdin.readline().strip().split())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    subsequences = []\n    generate_subsequences(a, 0, [], subsequences)\n    subsequences.sort()\n\n    results = []\n    for subsequence in subsequences:\n        results.append(hash_function(subsequence))\n\n    output = \"\"\n    for i in range(1, K + 1):\n        output += str(results[i]) + \"\\n\"\n\n    return output"
    },
    {
        "number": 3201,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def hash_function(values: List[int]) -> int:\n        p = len(values)\n        result = 0\n        for i, v in enumerate(values):\n            result += v * (B ** (p - 1 - i))\n        return result % M\n\n    def generate_subsequences(arr: List[int]) -> List[List[int]]:\n        result = []\n        for i in range(2 ** N):\n            subsequence = []\n            for j in range(N):\n                if i & (1 << j):\n                    subsequence.append(arr[j])\n            result.append(subsequence)\n        return result\n\n    def sort_subsequences(subsequences: List[List[int]]) -> List[List[int]]:\n        return sorted(subsequences)\n\n    N, K, B, M = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    subsequences = generate_subsequences(a)\n    sorted_subsequences = sort_subsequences(subsequences)\n\n    result = []\n    for k in range(K):\n        result.append(hash_function(sorted_subsequences[k]))\n\n    return \"\\n\".join(str(x) for x in result)"
    },
    {
        "number": 3201,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def hash_function(s, B, M):\n        p = len(s)\n        result = 0\n        for i in range(p):\n            result += s[i] * B ** (p - 1 - i)\n        return result % M\n\n    N, K, B, M = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    s = [[]]\n    for i in range(N):\n        for j in range(len(s)):\n            s.append(s[j] + [a[i]])\n        s.sort()\n\n    result = []\n    for k in range(K):\n        result.append(hash_function(s[k], B, M))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3201,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = map(int, stdin.split('\\n')[0].split())\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    \n    def generate_subsequences(arr: List[int], prefix: List[int], index: int) -> List[List[int]]:\n        if index == len(arr):\n            return [prefix]\n        include = generate_subsequences(arr, prefix + [arr[index]], index + 1)\n        exclude = generate_subsequences(arr, prefix, index + 1)\n        return include + exclude\n    \n    subsequences = generate_subsequences(arr, [], 0)\n    subsequences = sorted(subsequences)\n    \n    def hash_subsequence(subsequence: List[int]) -> int:\n        p = len(subsequence)\n        h = 0\n        for i in range(p):\n            h += subsequence[i] * (B ** (p - 1 - i))\n            h %= M\n        return h\n    \n    result = [hash_subsequence(subsequences[i]) for i in range(K)]\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3201,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    def generate_subsequences(a):\n        result = []\n        for mask in range(1, 2 ** N):\n            subsequence = []\n            for i in range(N):\n                if mask & (1 << i):\n                    subsequence.append(a[i])\n            result.append(subsequence)\n        return result\n\n    def hash_subsequence(s, B, M):\n        p = len(s)\n        h = 0\n        for i, v in enumerate(s, 1):\n            h = (h * B + v) % M\n        return h\n\n    subsequences = generate_subsequences(a)\n    subsequences.sort()\n\n    for subsequence in subsequences[:K]:\n        print(hash_subsequence(subsequence, B, M))"
    },
    {
        "number": 3201,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    def generate_subsequences(a, start, prefix):\n        if start == len(a):\n            yield prefix\n        else:\n            yield from generate_subsequences(a, start + 1, prefix)\n            yield from generate_subsequences(a, start + 1, prefix + [a[start]])\n\n    subsequences = sorted(list(generate_subsequences(a, 0, [])))\n\n    def hash_function(s):\n        p = len(s)\n        result = 0\n        for i, v in enumerate(s):\n            result += v * (B ** (p - i - 1))\n        return result % M\n\n    hashes = [hash_function(subsequences[i]) for i in range(K)]\n\n    return \"\\n\".join(str(h) for h in hashes)"
    },
    {
        "number": 3202,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    colors = list(map(int, stdin.readline().split()))\n\n    count = 0\n    for i in range(n):\n        if i == n - 1 or colors[i] != colors[i + 1]:\n            if i - count + 1 < k:\n                count += k - (i - count + 1)\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3202,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N, K = map(int, lines[0].split())\n    colors = list(map(int, lines[1].split()))\n\n    def can_vanish(marbles: List[int]) -> bool:\n        for i in range(len(marbles) - K + 1):\n            if len(set(marbles[i:i + K])) == 1:\n                return True\n        return False\n\n    def find_min_insertions(marbles: List[int]) -> int:\n        min_insertions = float('inf')\n        for i in range(len(marbles)):\n            for j in range(1, 101):\n                new_marbles = marbles[:i] + [j] + marbles[i:]\n                if can_vanish(new_marbles):\n                    min_insertions = min(min_insertions, j)\n        return min_insertions\n\n    return str(find_min_insertions(colors))"
    },
    {
        "number": 3202,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    marbles = list(map(int, stdin.split()[1].split()))\n    total_marbles = len(marbles)\n    max_consecutive = 0\n    current_consecutive = 1\n    \n    for i in range(1, total_marbles):\n        if marbles[i] == marbles[i - 1]:\n            current_consecutive += 1\n        else:\n            current_consecutive = 1\n            \n        if current_consecutive >= k:\n            max_consecutive = max(max_consecutive, current_consecutive)\n    \n    if max_consecutive >= k:\n        return 0\n    \n    min_marbles_to_insert = k - max_consecutive\n    \n    for i in range(total_marbles - 1):\n        if marbles[i] != marbles[i + 1]:\n            min_marbles_to_insert -= 1\n            if min_marbles_to_insert <= 0:\n                return 0\n    \n    return min_marbles_to_insert"
    },
    {
        "number": 3202,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    colors = list(map(int, stdin.split('\\n')[1].split()))\n    count_colors = [0] * 101\n    count_consecutive = [0] * (n + 1)\n\n    for i in range(n):\n        count_colors[colors[i]] += 1\n        count_consecutive[i + 1] = count_consecutive[i] + 1 if colors[i] == colors[i - 1] else count_consecutive[i]\n\n    if n < k:\n        return str(k - n)\n\n    max_color = max(count_colors)\n    max_color_count = count_colors.index(max_color)\n\n    if max_color <= k:\n        return str(0)\n\n    insertions = 0\n    for i in range(n):\n        if colors[i] == max_color_count:\n            if count_consecutive[i] >= k - 1:\n                insertions += k - count_consecutive[i]\n                colors[i] = -1\n            elif i + k - count_consecutive[i] <= n:\n                insertions += k - count_consecutive[i] - (count_consecutive[i + k - count_consecutive[i]] if i + k - count_consecutive[i] < n else 0)\n                colors[i] = -1\n\n    return str(insertions)"
    },
    {
        "number": 3202,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    marbles = list(map(int, stdin.split()[2:]))\n\n    def check_vanish(marbles, K):\n        for i in range(len(marbles) - K + 1):\n            if all(marbles[i] == marbles[j] for j in range(i, i + K)):\n                return True\n        return False\n\n    if check_vanish(marbles, K):\n        return \"0\"\n\n    for i in range(1, N + 1):\n        for color in range(1, 101):\n            if not check_vanish(marbles[:i] + [color] + marbles[i:], K):\n                return str(i)\n\n    return \"IMPOSSIBLE\" "
    },
    {
        "number": 3202,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    marbles = list(map(int, stdin.split()[2:]))\n    num_marbles = 0\n\n    for i in range(N):\n        left = i - K + 1\n        right = i\n        if left < 0:\n            left = 0\n        if right > N:\n            right = N\n        if len(set(marbles[left:right+1])) == 1:\n            num_marbles += 1\n\n    return str(num_marbles)"
    },
    {
        "number": 3202,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def can_vanish(seq: List[int], k: int) -> bool:\n        for i in range(len(seq) - k + 1):\n            if seq[i:i + k].count(seq[i]) == k:\n                return True\n        return False\n\n    def helper(seq: List[int], k: int, inserted: int) -> int:\n        if inserted >= len(seq) + 1:\n            return inserted\n        if can_vanish(seq, k):\n            return inserted\n        return helper(seq, k, inserted + 1)\n\n    N, K = map(int, stdin.split())\n    marbles = list(map(int, input().split()))\n    return str(helper(marbles, K, 0))"
    },
    {
        "number": 3202,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, K = map(int, lines[0].split())\n    colors = list(map(int, lines[1].split()))\n\n    def count_consecutive_same_colors(colors: List[int], i: int, j: int) -> int:\n        count = 0\n        while i >= 0 and j < N and colors[i] == colors[j]:\n            count += 1\n            i -= 1\n            j += 1\n        return count\n\n    count = float('inf')\n    for i in range(N):\n        for j in range(i, N):\n            count = min(count, max(0, K - count_consecutive_same_colors(colors, i, j)))\n\n    return str(count)"
    },
    {
        "number": 3202,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split('\\n')[0].split())\n    colors = list(map(int, stdin.split('\\n')[1].split()))\n    \n    max_count = 0\n    current_count = 1\n    \n    for i in range(1, N):\n        if colors[i] == colors[i - 1]:\n            current_count += 1\n        else:\n            max_count = max(max_count, current_count)\n            current_count = 1\n    \n    max_count = max(max_count, current_count)\n    \n    if max_count + 1 < K:\n        return 0\n    else:\n        return K - 1 "
    },
    {
        "number": 3202,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n\n    max_same_color = 1\n    current_color = colors[0]\n    current_count = 1\n\n    for i in range(1, N):\n        if colors[i] == current_color:\n            current_count += 1\n        else:\n            max_same_color = max(max_same_color, current_count)\n            current_color = colors[i]\n            current_count = 1\n\n    max_same_color = max(max_same_color, current_count)\n\n    if max_same_color < K:\n        return 0\n\n    min_marbles_to_insert = max(0, K - max_same_color)\n\n    for i in range(N - 1):\n        if colors[i] == colors[i + 1]:\n            min_marbles_to_insert = min(min_marbles_to_insert, K - (max_same_color - 1))\n\n    return str(min_marbles_to_insert)"
    },
    {
        "number": 3203,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    num_bonds = int(lines[0])\n    probabilities = [list(map(int, line.split())) for line in lines[1:]]\n\n    max_probability = 1\n    for permutation in itertools.permutations(range(num_bonds)):\n        probability = 1\n        for i, bond in enumerate(permutation):\n            probability *= probabilities[bond][i] / 100\n        max_probability = max(max_probability, probability)\n\n    return str(round(max_probability * 100))"
    },
    {
        "number": 3203,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    missions = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    max_prob = 0\n\n    for i in range(N):\n        current_prob = 1\n        for j in range(N):\n            current_prob *= missions[j][(i - j) % N] / 100\n        max_prob = max(max_prob, current_prob)\n\n    return str(round(max_prob * 100, 6))"
    },
    {
        "number": 3203,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    bonds = []\n    for _ in range(N):\n        bonds.append(list(map(int, stdin.readline().strip().split())))\n\n    max_probability = 1.0\n    for i in range(N):\n        min_probability = min(bonds[i])\n        max_probability *= min_probability / 100\n\n    return f\"{max_probability * 100:.6f}%\""
    },
    {
        "number": 3203,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    missions = []\n    bonds = []\n\n    for _ in range(N):\n        line = stdin.readline().strip().split()\n        missions.append([float(x) / 100 for x in line])\n\n    for _ in range(N):\n        line = stdin.readline().strip().split()\n        bonds.append([float(x) / 100 for x in line])\n\n    max_probability = 0\n\n    for i in range(N):\n        probability = 1\n        for j in range(N):\n            probability *= missions[j][i] * bonds[i][j]\n        max_probability = max(max_probability, probability)\n\n    return str(round(max_probability * 100, 6))"
    },
    {
        "number": 3203,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    missions = []\n    for _ in range(n):\n        missions.append([float(x) / 100 for x in stdin.readline().split()])\n\n    max_probability = 0\n    for arrangement in permutations(range(n)):\n        probability = 1\n        for i, j in enumerate(arrangement):\n            probability *= missions[i][j]\n        max_probability = max(max_probability, probability)\n\n    return f\"{max_probability * 100:.6f}\"\n\nfrom itertools import permutations"
    },
    {
        "number": 3203,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    jimmy_bonds = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    max_prob = 0\n    for permutation in itertools.permutations(range(n)):\n        prob = 1\n        for i in range(n):\n            prob *= jimmy_bonds[i][permutation[i]] / 100\n        max_prob = max(max_prob, prob)\n\n    return str(round(max_prob * 100))"
    },
    {
        "number": 3203,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    N = input_data[0]\n    missions = input_data[1:]\n\n    max_probability = 0\n    for arrangement in itertools.permutations(missions):\n        probability = 1\n        for i in range(N):\n            probability *= arrangement[i] / 100\n        max_probability = max(max_probability, probability)\n\n    return str(round(max_probability * 100))"
    },
    {
        "number": 3203,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    num_bonds = int(input_data[0])\n    missions = [list(map(int, line.split())) for line in input_data[1:]]\n\n    # Calculate probabilities\n    max_prob = 0\n    for arrangement in permutations(range(num_bonds)):\n        prob = 1\n        for i, bond_index in enumerate(arrangement):\n            prob *= missions[bond_index][i] / 100\n        max_prob = max(max_prob, prob)\n\n    # Convert probability to percentage\n    max_prob_percent = round(max_prob * 100, 6)\n\n    return f\"{max_prob_percent}\""
    },
    {
        "number": 3203,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def prob(a, b):\n        return a * b\n\n    def max_prob(N, missions):\n        max_p = 0\n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    p = prob(missions[i][i], missions[j][i])\n                    if p > max_p:\n                        max_p = p\n        return max_p\n\n    N = int(stdin.readline().strip())\n    missions = []\n    for i in range(N):\n        line = list(map(int, stdin.readline().strip().split()))\n        missions.append(line)\n\n    max_p = max_prob(N, missions)\n    return f\"{max_p:.6f}\""
    },
    {
        "number": 3203,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    missions = []\n    for i in range(1, N + 1):\n        mission = [float(x) / 100 for x in stdin.split('\\n')[i].split(' ')]\n        missions.append(mission)\n\n    max_probability = 0\n    for i in range(N):\n        probability = 1\n        for j in range(N):\n            probability *= missions[j][(i + j) % N]\n        max_probability = max(max_probability, probability)\n\n    return round(max_probability * 100, 6)"
    },
    {
        "number": 3204,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, times = int(stdin.split('\\n')[0]), sorted(list(map(int, stdin.split('\\n')[1:])))\n    time_total = 0\n    start_time = 0\n    queue = []\n\n    for i in range(N):\n        if start_time <= times[i]:\n            queue.append(times[i])\n            start_time = times[i] + 60\n        else:\n            time_to_wait = start_time - times[i]\n            time_total += time_to_wait\n            start_time = times[i] + 60\n\n        while len(queue) > 0 and queue[0] <= start_time - 20:\n            queue.pop(0)\n\n        if len(queue) > 0 and start_time < queue[-1] + 60:\n            start_time = queue[-1] + 60\n\n    return str(time_total)"
    },
    {
        "number": 3204,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def process_boat(boat_time):\n        nonlocal waiting_boats\n        nonlocal bridge_opened_time\n        nonlocal bridge_closed_time\n\n        waiting_boats.append(boat_time)\n        if not bridge_opened_time:\n            bridge_opened_time = boat_time\n        else:\n            return\n\n        while waiting_boats:\n            if waiting_boats[0] <= boat_time + 30 * 60:\n                bridge_closed_time = max(bridge_closed_time, waiting_boats.pop(0) + 20)\n            else:\n                break\n\n    def get_total_time():\n        nonlocal bridge_closed_time\n        nonlocal bridge_opened_time\n        nonlocal waiting_boats\n\n        if waiting_boats:\n            bridge_closed_time = waiting_boats[-1] + 20\n\n        return max(bridge_closed_time - bridge_opened_time, 0)\n\n    waiting_boats = []\n    bridge_opened_time = 0\n    bridge_closed_time = 0\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    for i in range(1, N + 1):\n        process_boat(int(lines[i]))\n\n    return str(get_total_time())"
    },
    {
        "number": 3204,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    input_data = list(map(int, stdin.split()))\n    N = input_data[0]\n    boat_arrival_times = sorted(input_data[1:])\n\n    # Initialize the variables\n    total_time = 0\n    current_time = 0\n    boats_in_queue = []\n\n    # Loop through the boats\n    for i in range(N):\n        # Check if the boat can pass through without waiting\n        if current_time + 20 <= boat_arrival_times[i]:\n            current_time += 20\n        # If the boat needs to wait, add it to the queue\n        else:\n            boats_in_queue.append(boat_arrival_times[i])\n            # Raise the bridge if it's not already raised\n            if current_time == 0:\n                total_time += 60\n                current_time += 60\n        # If there are boats waiting, pass them through one by one\n        while boats_in_queue:\n            current_boat = boats_in_queue[0]\n            # Check if the current boat can pass through without waiting\n            if current_time + 20 <= current_boat + 60:\n                current_time += 20\n                boats_in_queue.pop(0)\n            # If the current boat needs to wait, break the loop\n            else:\n                break\n        # Lower the bridge if no more boats are waiting\n        if not boats_in_queue:\n            total_time += current_time\n            current_time = 0\n\n    # Return the total time\n    return str(total_time)"
    },
    {
        "number": 3204,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    T = [int(line.strip()) for line in stdin.readlines()]\n    \n    T = [t for t in T if t >= 60 and t <= 1000000]\n    T.sort()\n    \n    time_waiting = 0\n    current_time = 60\n    for i in range(len(T)):\n        if T[i] - current_time > 30 * 60:\n            time_waiting += 30 * 60\n            current_time += 30 * 60\n        else:\n            time_waiting += T[i] - current_time\n            current_time = T[i] + 60\n    \n    return str(time_waiting)"
    },
    {
        "number": 3204,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def bridge_operation(arrival_times):\n        total_time = 0\n        last_raise = 0\n        last_lower = 0\n        for i in range(len(arrival_times)):\n            if arrival_times[i] - last_lower <= 60:\n                last_raise = arrival_times[i]\n                last_lower = arrival_times[i] + 60\n            else:\n                total_time += arrival_times[i] - last_lower + 60\n                last_raise = arrival_times[i]\n                last_lower = arrival_times[i] + 60\n        return total_time + last_lower - last_raise\n\n    input_list = list(map(int, stdin.split()))\n    N = input_list[0]\n    arrival_times = input_list[1:]\n    arrival_times.sort()\n    return str(bridge_operation(arrival_times))"
    },
    {
        "number": 3204,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_next_event(events, current_time):\n        for event in events:\n            if event[0] > current_time:\n                return event\n        return None\n\n    def bridge_operation(boats, waiting_boats, current_time):\n        if not waiting_boats and find_next_event(boats, current_time) is None:\n            return current_time\n\n        if not waiting_boats:\n            next_boat = find_next_event(boats, current_time)\n            waiting_boats.append((next_boat[0], [next_boat[1]]))\n            boats.remove(next_boat)\n\n        current_event = waiting_boats[0]\n        current_time = current_event[0]\n\n        if len(current_event[1]) == 1:\n            waiting_boats.pop(0)\n        else:\n            current_event[1].pop(0)\n\n        return current_time + 60\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    boats = [(int(line), i) for i, line in enumerate(lines[1:N+1])]\n    boats.sort()\n\n    waiting_boats = []\n    current_time = 0\n    total_wait_time = 0\n\n    while waiting_boats or find_next_event(boats, current_time) is not None:\n        current_time = bridge_operation(boats, waiting_boats, current_time)\n        if waiting_boats:\n            total_wait_time += current_time - waiting_boats[0][0]\n\n    return str(total_wait_time + N * 60)"
    },
    {
        "number": 3204,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    T = [int(line) for line in lines[1:]]\n    \n    T.sort()\n    total_time = 0\n    for i in range(N):\n        if i == 0:\n            total_time += T[i]\n        else:\n            total_time += max(0, T[i] - T[i - 1] - 60)\n    return str(total_time)"
    },
    {
        "number": 3204,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def check_arrival(arrival_times, start_time, end_time):\n        for t in arrival_times:\n            if start_time <= t <= end_time:\n                return True\n        return False\n\n    def operate_bridge(arrival_times, start_time, end_time):\n        if not arrival_times:\n            return 0\n\n        if start_time > arrival_times[0]:\n            start_time = arrival_times[0]\n\n        time_taken = 0\n        while arrival_times:\n            time_needed = end_time - start_time\n            if time_needed > 60:\n                time_needed = 60\n\n            time_taken += time_needed\n            start_time += time_needed\n\n            while arrival_times and arrival_times[0] <= start_time:\n                arrival_times.pop(0)\n\n            if not arrival_times:\n                break\n\n            time_needed = 20\n            if time_needed > end_time - start_time:\n                time_needed = end_time - start_time\n\n            time_taken += time_needed\n            start_time += time_needed\n\n        return time_taken\n\n    N = int(stdin.readline().strip())\n    arrival_times = [int(stdin.readline().strip()) for _ in range(N)]\n\n    start_time = 0\n    end_time = 30 * 60\n\n    while end_time - start_time <= 30 * 60:\n        if not check_arrival(arrival_times, start_time, end_time):\n            return operate_bridge(arrival_times, start_time, end_time)\n        start_time += 20\n        end_time += 20\n\n    return operate_bridge(arrival_times, start_time, end_time)"
    },
    {
        "number": 3204,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def operate_bridge(arrival_times):\n        total_time = 0\n        for i, time in enumerate(arrival_times):\n            if i == 0:\n                total_time += max(0, 60 - (time % 60))\n            else:\n                total_time += max(0, 60 - ((time - arrival_times[i - 1]) % 60))\n            if time % 60 <= 20:\n                total_time += 60\n        return total_time\n\n    N = int(stdin.readline().strip())\n    arrival_times = [int(stdin.readline().strip()) for _ in range(N)]\n    total_time = operate_bridge(arrival_times)\n    return str(total_time)"
    },
    {
        "number": 3204,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def operate_bridge(boats: List[int]) -> int:\n        total_time = 0\n        boats_waiting = []\n        while boats or boats_waiting:\n            if not boats:\n                if total_time % 60 != 0:\n                    total_time += 60 - (total_time % 60)\n                total_time += 60 * len(boats_waiting)\n                break\n\n            boat = boats.pop(0)\n            if boat < total_time:\n                boats_waiting.append(boat)\n            else:\n                total_time = boat\n                if boats_waiting:\n                    total_time += 60\n                    total_time += 20 * len(boats_waiting)\n                else:\n                    total_time += 60 + 20\n\n        return total_time\n\n    input_data = [int(line.strip()) for line in stdin.split('\\n') if line.strip()]\n    num_boats = input_data[0]\n    boats = input_data[1:]\n\n    return str(operate_bridge(boats))"
    },
    {
        "number": 3205,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    M, N = map(int, lines[0].split())\n    balances = [0] * M\n\n    for i in range(1, N + 1):\n        a, b, p = map(int, lines[i].split())\n        balances[a] -= p\n        balances[b] += p\n\n    transactions = 0\n    for i in range(M):\n        if balances[i] != 0:\n            transactions += 1\n\n    return str(transactions)"
    },
    {
        "number": 3205,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    M, N = map(int, lines[0].split())\n\n    balance = [0] * M\n\n    for i in range(1, N + 1):\n        a, b, p = map(int, lines[i].split())\n        balance[a] -= p\n        balance[b] += p\n\n    total_balance = sum(balance)\n\n    if total_balance == 0:\n        return \"0\"\n    else:\n        return str(min(total_balance, M - total_balance))"
    },
    {
        "number": 3205,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.readline().split())\n    balance = [0] * M\n    transactions = []\n\n    for _ in range(N):\n        a, b, p = map(int, stdin.readline().split())\n        balance[a] -= p\n        balance[b] += p\n\n    for i in range(M):\n        for j in range(i + 1, M):\n            if balance[i] == -balance[j]:\n                transactions.append((i, j, abs(balance[i])))\n                balance[i] = balance[j] = 0\n            elif balance[i] != 0 and balance[j] % balance[i] == 0:\n                transactions.append((j, i, balance[j] // balance[i]))\n                balance[i], balance[j] = balance[j], balance[i]\n            elif balance[j] != 0 and balance[i] % balance[j] == 0:\n                transactions.append((i, j, balance[i] // balance[j]))\n                balance[i], balance[j] = balance[j], balance[i]\n\n    return str(len(transactions))"
    },
    {
        "number": 3205,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    M, N = map(int, lines[0].split())\n    debts = {}\n    for i in range(N):\n        a, b, p = map(int, lines[i + 1].split())\n        if a not in debts:\n            debts[a] = {}\n        if b not in debts[a]:\n            debts[a][b] = 0\n        debts[a][b] += p\n        if b not in debts:\n            debts[b] = {}\n        if a not in debts[b]:\n            debts[b][a] = 0\n        debts[b][a] -= p\n\n    def find_cycle(graph, visited, rec_stack, start):\n        visited[start] = True\n        rec_stack[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, rec_stack, neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n        rec_stack[start] = False\n        return False\n\n    def is_cyclic(graph):\n        visited = [False] * M\n        rec_stack = [False] * M\n        for node in range(M):\n            if not visited[node]:\n                if find_cycle(graph, visited, rec_stack, node):\n                    return True\n        return False\n\n    if is_cyclic(debts):\n        return '0'\n\n    def dfs(graph, visited, current, path):\n        visited[current] = True\n        path.append(current)\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                dfs(graph, visited, neighbor, path)\n        path.append(current)\n\n    def get_euler_path(graph):\n        visited = [False] * M\n        path = []\n        for node in range(M):\n            if not visited[node]:\n                dfs(graph, visited, node, path)\n        return path\n\n    path = get_euler_path(debts)\n    transactions = 0\n    for i in range(1, len(path), 2):\n        a, b = path[i - 1], path[i]\n        if a in debts[b]:\n            transactions += 1\n\n    return str(transactions)"
    },
    {
        "number": 3205,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    lines = stdin.split('\\n')\n    M, N = map(int, lines[0].split())\n    people = [0] * M\n    for i in range(1, N + 1):\n        a, b, p = map(int, lines[i].split())\n        people[a] -= p\n        people[b] += p\n\n    # Find the minimum number of transactions\n    transactions = 0\n    for i in range(M):\n        if people[i] != 0:\n            transactions += 1\n            people[i] = 0\n\n    for i in range(M):\n        for j in range(i + 1, M):\n            if people[i] != 0 and people[j] != 0 and people[i] == -people[j]:\n                transactions -= 1\n                people[i] = 0\n                people[j] = 0\n\n    return str(transactions)"
    },
    {
        "number": 3205,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_lines = stdin.split('\\n')\n    M, N = map(int, input_lines[0].split())\n\n    # Initialize balance matrix\n    balance = [[0] * M for _ in range(M)]\n\n    # Process transactions\n    for i in range(N):\n        a, b, p = map(int, input_lines[i + 1].split())\n        balance[a][b] += p\n        balance[b][a] -= p\n\n    # Calculate minimum number of transactions\n    transactions = 0\n    for i in range(M):\n        for j in range(i + 1, M):\n            if balance[i][j] != -balance[j][i]:\n                transactions += 1\n\n    return str(transactions)"
    },
    {
        "number": 3205,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    M, N = map(int, lines[0].split())\n    balances = [0] * M\n    transactions = 0\n\n    for i in range(1, N + 1):\n        a, b, p = map(int, lines[i].split())\n        balances[a] -= p\n        balances[b] += p\n\n    for i in range(M):\n        if balances[i] != 0:\n            transactions += 1\n\n    return str(transactions)"
    },
    {
        "number": 3205,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    M, N = map(int, lines[0].split())\n    graph = [[0] * M for _ in range(M)]\n\n    for i in range(N):\n        a, b, p = map(int, lines[i + 1].split())\n        graph[a][b] += p\n\n    for i in range(M):\n        for j in range(M):\n            if i != j:\n                graph[i][i] -= graph[i][j]\n\n    return str(sum(max(graph[i]) for i in range(M)) // 2)"
    },
    {
        "number": 3205,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, current, target, amount, people):\n        if amount == 0:\n            return 1\n        if current == target:\n            return 0\n        if visited[current] == people:\n            return 0\n        visited[current] += 1\n        for neighbor, cost in graph[current]:\n            if neighbor != target and visited[neighbor] < people:\n                new_amount = amount - cost\n                if new_amount >= 0:\n                    if dfs(graph, visited, neighbor, target, new_amount, people):\n                        return 1\n        return 0\n\n    lines = stdin.splitlines()\n    M, N = map(int, lines[0].split())\n    graph = [[] for _ in range(M)]\n    for i in range(1, N + 1):\n        a, b, p = map(int, lines[i].split())\n        graph[a].append((b, p))\n        graph[b].append((a, p))\n\n    people = M\n    total = sum(p for _ in range(M) for _, p in graph[_])\n    if total % people == 0:\n        return str(people - 1)\n    else:\n        for i in range(1, M):\n            visited = [0] * M\n            if dfs(graph, visited, 0, i, total // people, i):\n                return str(i)"
    },
    {
        "number": 3205,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(M)]\n\n    for _ in range(N):\n        a, b, p = map(int, stdin.readline().split())\n        adj_list[a].append((b, p))\n\n    def dfs(u: int, visited: set, balances: list) -> int:\n        visited.add(u)\n        for v, p in adj_list[u]:\n            if v not in visited:\n                balances[v] -= p\n                dfs(v, visited, balances)\n        return 1 if u == 0 and all(x == 0 for x in balances) else 0\n\n    balances = [0] * M\n    for a, b, p in adj_list[0]:\n        balances[b] += p\n\n    return str(dfs(0, set(), balances))"
    },
    {
        "number": 3206,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_combination(blocks, target):\n        for i in range(len(blocks)):\n            if blocks[i] == target:\n                return [i + 1]\n            elif blocks[i] > target:\n                continue\n            else:\n                for j in range(i + 1, len(blocks)):\n                    if blocks[i] + blocks[j] == target:\n                        return [i + 1, j + 1]\n                    elif blocks[i] + blocks[j] > target:\n                        break\n        return None\n\n    blocks_count, buildings_count = map(int, stdin.readline().split())\n    blocks = list(map(int, stdin.readline().split()))\n    buildings = list(map(int, stdin.readline().split()))\n\n    for i in range(buildings_count):\n        combination = find_combination(blocks, buildings[i])\n        if combination is not None:\n            print(f\"{' '.join(map(str, combination))}\")\n        else:\n            print(-1)\n\n    return \"\""
    },
    {
        "number": 3206,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.readline().split())\n    blocks = sorted(map(int, stdin.readline().split()), reverse=True)\n    buildings = list(map(int, stdin.readline().split()))\n\n    result = []\n    for b in buildings:\n        if b == 0:\n            result.append(f\"0\")\n            continue\n        used_blocks = []\n        for i, h in enumerate(blocks):\n            if h <= b:\n                b -= h\n                used_blocks.append(i + 1)\n            if b == 0:\n                result.append(f\"{len(used_blocks)} {' '.join(map(str, used_blocks))}\")\n                break\n        else:\n            result.append(\"-1\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3206,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.readline().split())\n    blocks = list(map(int, stdin.readline().split()))\n    skyline = list(map(int, stdin.readline().split()))\n\n    def can_build(target, available_blocks):\n        if sum(available_blocks) < target:\n            return False\n\n        available_blocks.sort(reverse=True)\n        target_stack = []\n\n        for block in available_blocks:\n            if sum(target_stack) + block <= target:\n                target_stack.append(block)\n            if sum(target_stack) == target:\n                return True\n\n        return False\n\n    for target in skyline:\n        if not can_build(target, blocks.copy()):\n            return \"-1\"\n\n    output = []\n    for target in skyline:\n        used_blocks = []\n        for i, block in enumerate(blocks):\n            if block <= target:\n                target -= block\n                used_blocks.append(i + 1)\n            if target == 0:\n                break\n        output.append(\" \".join(map(str, [len(used_blocks)] + used_blocks)))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3206,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.readline().split())\n    blocks = list(map(int, stdin.readline().split()))\n    buildings = list(map(int, stdin.readline().split()))\n\n    def dfs(index, target, curr_sum, used):\n        if curr_sum == target:\n            return used\n        if index == N or curr_sum > target:\n            return None\n\n        result = dfs(index + 1, target, curr_sum + blocks[index], used + [index + 1])\n        if result:\n            return result\n\n        return dfs(index + 1, target, curr_sum, used)\n\n    output = []\n    for b in buildings:\n        result = dfs(0, b, 0, [])\n        if result:\n            output.append(f\"{' '.join(map(str, result))}\")\n        else:\n            output.append(\"-1\")\n            break\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3206,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(n, target, used, cur_sum):\n        if cur_sum == target:\n            result.append(used)\n            return\n        if cur_sum > target or n < 0:\n            return\n        dfs(n - 1, target, used, cur_sum + h[n])\n        dfs(n - 1, target, used + [n + 1], cur_sum)\n\n    N, S = map(int, stdin.readline().split())\n    h = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    h.sort(reverse=True)\n\n    result = []\n    for target in b:\n        dfs(N - 1, target, [], 0)\n\n    if not result:\n        return \"-1\\n\"\n\n    output = \"\"\n    for used in result:\n        output += \" \".join(map(str, used)) + \"\\n\"\n\n    return output"
    },
    {
        "number": 3206,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, target):\n        if target == 0:\n            return [[]]\n        if start >= len(blocks):\n            return []\n        result = []\n        for i in range(start, len(blocks)):\n            if blocks[i] <= target:\n                for sub_result in dfs(i, target - blocks[i]):\n                    result.append([i + 1] + sub_result))\n        return result\n\n    stdin_list = list(map(int, stdin.split()))\n    N, S = stdin_list[0], stdin_list[1]\n    blocks = stdin_list[2:N + 2]\n    buildings = stdin_list[N + 2:]\n\n    for b in buildings:\n        result = dfs(0, b)\n        if not result:\n            print(-1)\n            return\n        print(len(result[0]), *result[0])"
    },
    {
        "number": 3206,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, target):\n        if target == 0:\n            return [[]]\n        if start == N:\n            return []\n        heights = [dfs(i + 1, target - h) for i, h in enumerate(blocks[start:]) if h <= target]\n        return [[start + i] + h for i, hs in enumerate(heights) for h in hs]\n\n    N, S = map(int, stdin.readline().split())\n    blocks = list(map(int, stdin.readline().split()))\n    targets = list(map(int, stdin.readline().split()))\n\n    for target in targets:\n        results = dfs(0, target)\n        if not results:\n            print(-1)\n            continue\n        result = min(results, key=len)\n        print(len(result), *result)\n"
    },
    {
        "number": 3206,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.readline().split())\n    blocks = sorted(map(int, stdin.readline().split()))\n    skylines = list(map(int, stdin.readline().split()))\n\n    def backtrack(index, target, used_blocks):\n        if target == 0:\n            return []\n        if index == N:\n            return -1\n        if blocks[index] > target:\n            return backtrack(index + 1, target, used_blocks)\n        curr_block = blocks[index]\n        include = backtrack(index, target - curr_block, used_blocks + [index])\n        if include != -1:\n            include.append(index + 1)\n            return include\n        return backtrack(index + 1, target, used_blocks)\n\n    result = []\n    for skyline in skylines:\n        used_blocks = backtrack(0, skyline, [])\n        if used_blocks == -1:\n            result.append(\"-1\")\n        else:\n            result.append(f\"{' '.join(map(str, used_blocks))}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3206,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(target_sum, start_index, visited, remaining_blocks):\n        if target_sum == 0:\n            return True\n        if target_sum < 0:\n            return False\n        if start_index == len(blocks) and target_sum != 0:\n            return False\n        for i in range(start_index, len(blocks)):\n            if i > 0 and blocks[i] == blocks[i - 1] and i - 1 not in visited:\n                continue\n            if blocks[i] <= target_sum:\n                remaining_blocks.append(blocks[i])\n                visited.add(i)\n                if dfs(target_sum - blocks[i], i, visited, remaining_blocks):\n                    return True\n                remaining_blocks.pop()\n                visited.remove(i)\n        return False\n\n    stdin_list = stdin.split('\\n')\n    N, S = map(int, stdin_list[0].split())\n    blocks = list(map(int, stdin_list[1].split()))\n    targets = list(map(int, stdin_list[2].split()))\n\n    result = []\n    for i in range(S):\n        visited = set()\n        remaining_blocks = []\n        if dfs(targets[i], 0, visited, remaining_blocks):\n            result.append(' '.join(map(str, [len(remaining_blocks)] + remaining_blocks)))\n        else:\n            result.append('-1')\n\n    return '\\n'.join(result) "
    },
    {
        "number": 3206,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_stack(b, blocks):\n        if not b:\n            return []\n        if not blocks:\n            return None\n        if b[0] == blocks[0]:\n            return [blocks[0]] + find_stack(b[1:], blocks[1:])\n        stack = find_stack(b, blocks[1:])\n        if stack:\n            return [blocks[0]] + stack\n        return find_stack(b[1:], blocks)\n\n    N, S = map(int, stdin.split('\\n')[0].split())\n    blocks = list(map(int, stdin.split('\\n')[1].split()))\n    buildings = list(map(int, stdin.split('\\n')[2].split()))\n\n    output = []\n    for b in buildings:\n        stack = find_stack(b, blocks)\n        if stack:\n            output.append(' '.join(map(str, [len(stack)] + stack)))\n        else:\n            output.append('-1')\n            break\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3207,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def chameleon_collide(a, b, K):\n        return (a + b) % K\n\n    N, K, L = map(int, stdin.split('\\n')[0].split())\n    chameleons = [list(map(int, line.split()[0::2])) + list(line.split()[1::2]) for line in stdin.split('\\n')[1:N + 1]]\n    collisions = [[] for _ in range(K)]\n    positions = [[] for _ in range(K)]\n\n    for i, chameleon in enumerate(chameleons):\n        d, b, direction = chameleon\n        positions[b].append((d, i))\n\n    for color in range(K):\n        positions[color].sort()\n\n        while positions[color]:\n            d, i = positions[color].pop(0)\n            chameleon = chameleons[i]\n            direction = chameleon[2]\n            new_color = (color + 1) % K\n\n            if direction == 'L':\n                chameleon[1] = new_color\n                if chameleon[0] == L:\n                    collisions[new_color].append(chameleon[3])\n                else:\n                    positions[new_color].append((chameleon[0] + 1, i))\n            else:\n                chameleon[1] = new_color\n                if chameleon[0] == 0:\n                    collisions[new_color].append(chameleon[3])\n                else:\n                    positions[new_color].append((chameleon[0] - 1, i))\n\n        for collision in collisions[color]:\n            chameleon = chameleons[collision]\n            direction = chameleon[2]\n            new_color = chameleon_collide(color, chameleon[1], K)\n            chameleon[1] = new_color\n\n            if direction == 'L':\n                if chameleon[0] == L:\n                    collisions[new_color].append(collision)\n                else:\n                    positions[new_color].append((chameleon[0] + 1, collision))\n            else:\n                if chameleon[0] == 0:\n                    collisions[new_color].append(collision)\n                else:\n                    positions[new_color].append((chameleon[0] - 1, collision))\n\n        for color_positions in positions:\n            for i in range(len(color_positions)):\n                d, index = color_positions[i]\n                chameleon = chameleons[index]\n                if chameleon[2] == 'L':\n                    chameleon[3] += d / 10\n                else:\n                    chameleon[3] -= d / 10\n\n    return '\\n'.join(['{:.1f}'.format(chameleon[3]) for chameleon in chameleons if chameleon[1] == color] for color in range(K))"
    },
    {
        "number": 3207,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Split input into lines\n    lines = stdin.split(\"\\n\")\n    \n    # Parse first line\n    N, K, L = map(int, lines[0].split())\n    \n    # Parse subsequent lines\n    chameleons = []\n    for i in range(1, N + 1):\n        distance, color, direction = lines[i].split()\n        chameleons.append({\n            \"distance\": int(distance),\n            \"color\": int(color),\n            \"direction\": direction\n        })\n    \n    # Initialize color counts\n    color_counts = [0] * K\n    \n    # Iterate through chameleons\n    for i in range(N):\n        # Get chameleon information\n        chameleon = chameleons[i]\n        distance = chameleon[\"distance\"]\n        color = chameleon[\"color\"]\n        direction = chameleon[\"direction\"]\n        \n        # Get distance traveled\n        if direction == \"D\":\n            distance_traveled = L - distance\n        else:\n            distance_traveled = distance\n        \n        # Update color count\n        color_counts[color] += distance_traveled\n        \n        # Check for collisions\n        for j in range(i + 1, N):\n            # Get other chameleon information\n            other_chameleon = chameleons[j]\n            other_distance = other_chameleon[\"distance\"]\n            other_color = other_chameleon[\"color\"]\n            other_direction = other_chameleon[\"direction\"]\n            \n            # Check if collision occurs\n            if chameleon[\"distance\"] == other_distance:\n                # Update chameleon and other chameleon colors\n                chameleon[\"color\"] = (chameleon[\"color\"] + other_chameleon[\"color\"]) % K\n                other_chameleon[\"color\"] = chameleon[\"color\"]\n                \n                # Update chameleon and other chameleon directions\n                chameleon[\"direction\"] = \"D\" if chameleon[\"direction\"] == \"L\" else \"L\"\n                other_chameleon[\"direction\"] = \"D\" if other_chameleon[\"direction\"] == \"L\" else \"L\"\n                \n                # Update chameleon and other chameleon distances\n                if chameleon[\"direction\"] == \"D\":\n                    chameleon[\"distance\"] = L\n                    other_chameleon[\"distance\"] = distance\n                else:\n                    chameleon[\"distance\"] = distance\n                    other_chameleon[\"distance\"] = 0\n                \n                # Update color counts\n                color_counts[chameleon[\"color\"]] += distance_traveled\n                color_counts[other_color] += other_distance_traveled\n                \n                break\n    \n    # Calculate output\n    output = []\n    for i in range(K):\n        output.append(str(color_counts[i]))\n    \n    return \"\\n\".join(output)"
    },
    {
        "number": 3207,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_colors(a, b, K):\n        return (a + b) % K\n\n    def get_output(chameleons, L, K):\n        trips = [0] * K\n        collisions = {}\n\n        for chameleon in chameleons:\n            color, direction, speed, position = chameleon\n            trip = 0\n\n            while position < L:\n                position += speed\n                trip += speed\n\n                if position >= L:\n                    break\n\n                collisions.setdefault((position, color, direction), []).append((trip, chameleon))\n\n            trips[color] += trip\n\n        for (position, color_a, direction_a), collisions_list in collisions.items():\n            if direction_a == 'D':\n                continue\n\n            for trip_a, chameleon_a in collisions_list:\n                for trip_b, chameleon_b in collisions_list:\n                    if trip_a < trip_b:\n                        color_b, direction_b, speed_b, position_b = chameleon_b\n                        trips[color_b] += trip_b - trip_a\n                        trips[color_a] += trip_a - trip_b\n\n                        new_color = rotate_colors(color_a, color_b, K)\n                        chameleon_b[1] = new_color\n                        chameleon_a[1] = new_color\n\n        return trips\n\n    def read_input(stdin):\n        N, K, L = map(int, stdin.readline().split())\n        chameleons = []\n\n        for _ in range(N):\n            distance, color, direction = stdin.readline().split()\n            chameleons.append([int(color), direction, 1, int(distance)])\n\n        return chameleons, L, K\n\n    chameleons, L, K = read_input(stdin)\n    trips = get_output(chameleons, L, K)\n\n    return '\\n'.join(map(str, trips)) + '\\n'"
    },
    {
        "number": 3207,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def collision(a, b):\n        return (a + b) % K\n\n    N, K, L = map(int, stdin.split('\\n')[0].split())\n    chameleons = [list(map(int, line.split()[:2])) + [line.split()[2]] for line in stdin.split('\\n')[1:]]\n    chameleons.sort(key=lambda x: x[0])\n\n    trip_lengths = [0] * K\n    for i in range(N):\n        if i < N - 1:\n            if chameleons[i][2] == 'L' and chameleons[i + 1][2] == 'R' and chameleons[i][1] == chameleons[i + 1][1]:\n                chameleons[i][2] = 'R'\n                chameleons[i + 1][2] = collision(chameleons[i][1], chameleons[i + 1][1])\n                continue\n            elif chameleons[i][2] == 'R' and chameleons[i + 1][2] == 'L' and chameleons[i][1] == chameleons[i + 1][1]:\n                chameleons[i][2] = 'L'\n                chameleons[i + 1][2] = collision(chameleons[i][1], chameleons[i + 1][1])\n                continue\n\n        if chameleons[i][2] == 'L':\n            trip_lengths[chameleons[i][1]] += 1\n        elif chameleons[i][2] == 'R':\n            trip_lengths[chameleons[i][1]] += L - chameleons[i][0]\n\n    return '\\n'.join(map(str, trip_lengths))"
    },
    {
        "number": 3207,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    N, K, L = map(int, stdin.split()[0:3])\n    chameleons = []\n    for i in range(N):\n        d, b, direction = stdin.split()[3 + i].split()\n        d, b = int(d), int(b)\n        chameleons.append({'distance': d, 'color': b, 'direction': direction})\n    \n    # Initialize the trips for each color\n    trips = [0.0] * K\n    \n    # Simulate the chameleons' movements\n    for i in range(N):\n        # Get the current chameleon and its attributes\n        chameleon = chameleons[i]\n        distance, color, direction = chameleon['distance'], chameleon['color'], chameleon['direction']\n        \n        # Calculate the trip for this color\n        trip = (L - distance) / 2 if direction == 'D' else (distance + 1) / 2\n        trips[color] += trip\n        \n        # Update the colors and directions of the chameleons\n        for j in range(i + 1, N):\n            # Get the chameleon to check for collision\n            chameleon_to_check = chameleons[j]\n            distance_to_check, color_to_check, direction_to_check = chameleon_to_check['distance'], chameleon_to_check['color'], chameleon_to_check['direction']\n            \n            # Check for collision\n            if distance == distance_to_check:\n                # Update the colors and directions\n                chameleon['color'] = color_to_check\n                chameleon_to_check['color'] = (color + color_to_check) % K\n                chameleon['direction'] = 'D' if direction == 'L' else 'L'\n                chameleon_to_check['direction'] = 'D' if direction_to_check == 'L' else 'L'\n                \n                # Update the trip for the new colors\n                trips[color] -= trip\n                trips[chameleon['color']] += trip\n                trips[color_to_check] -= trip\n                trips[(color + color_to_check) % K] += trip\n                \n                # Break the loop\n                break\n    \n    # Format the output\n    output = '\\n'.join([f'{trip:.1f}' for trip in trips])\n    \n    return output"
    },
    {
        "number": 3207,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def chameleon_collide(a, b, K):\n        return (a + b) % K\n\n    def chameleon_change_direction(d, L, direction):\n        if direction == \"L\":\n            return L - d\n        else:\n            return d - 1\n\n    def simulate_chameleons(N, K, L, d, b, directions):\n        chameleon_trips = [0] * K\n        current_positions = d.copy()\n        current_colors = b.copy()\n\n        while any(current_positions):\n            for i in range(N):\n                if current_positions[i] == -1:\n                    continue\n\n                if current_positions[i] == L:\n                    current_positions[i] = -1\n                else:\n                    if directions[i] == \"L\":\n                        current_positions[i] += 1\n                    else:\n                        current_positions[i] -= 1\n\n                    for j in range(N):\n                        if i == j or current_positions[j] == -1:\n                            continue\n\n                        if current_positions[i] == current_positions[j]:\n                            if directions[i] == directions[j]:\n                                continue\n                            else:\n                                current_colors[i] = chameleon_collide(current_colors[i], current_colors[j], K)\n                                current_colors[j] = chameleon_collide(current_colors[i], current_colors[j], K)\n\n                                directions[i] = \"R\"\n                                directions[j] = \"L\"\n\n                                current_positions[i] = chameleon_change_direction(current_positions[i], L, directions[i])\n                                current_positions[j] = chameleon_change_direction(current_positions[j], L, directions[j])\n                            break\n\n            for i in range(N):\n                if current_positions[i] == -1:\n                    continue\n\n                chameleon_trips[current_colors[i]] += 1\n\n        return chameleon_trips\n\n    input_data = list(map(str.strip, stdin.split(\"\\n\")))\n    N, K, L = list(map(int, input_data[0].split()))\n    d = []\n    b = []\n    directions = []\n\n    for i in range(1, N + 1):\n        d_i, b_i, direction = input_data[i].split()\n        d.append(int(d_i))\n        b.append(int(b_i))\n        directions.append(direction)\n\n    chameleon_trips = simulate_chameleons(N, K, L, d, b, directions)\n    output = \"\\n\".join(f\"{trip:.1f}\" for trip in chameleon_trips)\n\n    return output + \"\\n\" "
    },
    {
        "number": 3207,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def mod(a, b):\n        return a % b\n\n    def merge_colors(a, b, k):\n        return (a + b) % k\n\n    def opposite_direction(direction):\n        if direction == 'L':\n            return 'D'\n        return 'L'\n\n    def update_chameleons(chameleons, collision):\n        a_color, a_direction, a_position = chameleons[collision.a]\n        b_color, b_direction, b_position = chameleons[collision.b]\n\n        if a_direction == 'L' and b_direction == 'D':\n            chameleons[collision.a] = (b_color, 'D', b_position)\n            chameleons[collision.b] = (a_color, 'L', a_position)\n        elif a_direction == 'D' and b_direction == 'L':\n            chameleons[collision.a] = (a_color, 'D', b_position)\n            chameleons[collision.b] = (b_color, 'L', a_position)\n\n    def find_collisions(chameleons):\n        collisions = []\n        for i in range(len(chameleons) - 1):\n            color_a, direction_a, position_a = chameleons[i]\n            color_b, direction_b, position_b = chameleons[i + 1]\n\n            if position_a == position_b:\n                collisions.append((i, i + 1))\n\n        return collisions\n\n    def simulate(chameleons, k):\n        time = 0\n        color_counts = [0] * k\n        previous_position = -1\n\n        while chameleons:\n            current_position = chameleons[0][2]\n\n            if previous_position != current_position:\n                color_counts[chameleons[0][0]] += current_position - previous_position\n\n            collisions = find_collisions(chameleons)\n            for collision in collisions:\n                update_chameleons(chameleons, collision)\n\n            chameleons = [chameleon for chameleon in chameleons if chameleon[2] < L]\n            chameleons = sorted(chameleons, key=lambda x: x[2])\n\n            time += 1\n            previous_position = current_position\n\n        return color_counts\n\n    lines = stdin.split('\\n')\n    N, K, L = map(int, lines[0].split())\n    chameleons = []\n\n    for i in range(1, N + 1):\n        distance, color, direction = lines[i].split()\n        chameleons.append((int(color), direction, int(distance)))\n\n    color_counts = simulate(chameleons, K)\n    result = [str(count) for count in color_counts]\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3207,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def process_chameleons(chameleons):\n        left_chameleons = []\n        right_chameleons = []\n\n        for chameleon in chameleons:\n            if chameleon[2] == 'L':\n                left_chameleons.append(chameleon)\n            else:\n                right_chameleons.append(chameleon)\n\n        left_chameleons.sort(key=lambda x: x[1])\n        right_chameleons.sort(key=lambda x: x[1])\n\n        return left_chameleons, right_chameleons\n\n    def update_chameleons(left_chameleons, right_chameleons, K):\n        updated_chameleons = []\n\n        for i in range(len(left_chameleons)):\n            chameleon = left_chameleons[i]\n            new_color = (left_chameleons[i][3] + right_chameleons[i][3]) % K\n            updated_chameleons.append((chameleon[0], chameleon[1], right_chameleons[i][3], chameleon[4]))\n            updated_chameleons.append((right_chameleons[i][0], right_chameleons[i][1], new_color, right_chameleons[i][4]))\n\n        return updated_chameleons\n\n    def calculate_trip_length(chameleons, K, L):\n        trip_length = [0] * K\n\n        for chameleon in chameleons:\n            color = chameleon[3]\n            trip_length[color] += chameleon[4]\n\n        for i in range(K):\n            trip_length[i] = trip_length[i] / (L * 2)\n\n        return trip_length\n\n    lines = stdin.split('\\n')\n    N, K, L = map(int, lines[0].split())\n    chameleons = [(int(line.split()[0]), int(line.split()[1]), line.split()[2], int(line.split()[2]), 1) for line in lines[1:]]\n\n    left_chameleons, right_chameleons = process_chameleons(chameleons)\n    updated_chameleons = update_chameleons(left_chameleons, right_chameleons, K)\n    trip_length = calculate_trip_length(updated_chameleons, K, L)\n\n    return '\\n'.join(map(str, trip_length))"
    },
    {
        "number": 3207,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def distance_traveled(initial_position, direction, color, N, K, L):\n        distance = 0\n        trips = 0\n        while initial_position < L:\n            if direction == 'D':\n                initial_position += 1\n            else:\n                initial_position -= 1\n            distance += 1\n            if initial_position == L:\n                break\n            elif initial_position in positions and positions[initial_position] == color:\n                direction = 'D' if direction == 'L' else 'L'\n                if direction == 'D':\n                    color = (color + colors[initial_position]) % K\n                else:\n                    color = colors[initial_position]\n                trips += distance\n                distance = 0\n        return trips\n\n    lines = stdin.split('\\n')\n    N, K, L = map(int, lines[0].split())\n    colors = {}\n    positions = {}\n    directions = {}\n\n    for i in range(1, N + 1):\n        line = lines[i].split()\n        position = int(line[0])\n        color = int(line[1])\n        direction = line[2]\n        colors[color] = color\n        positions[position] = color\n        directions[position] = direction\n\n    total_trips = [0] * K\n    for color in colors:\n        for position in positions:\n            if positions[position] == color:\n                direction = directions[position]\n                trip = distance_traveled(position, direction, color, N, K, L)\n                total_trips[color] += trip\n                break\n\n    return '\\n'.join(map(str, total_trips))"
    },
    {
        "number": 3207,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_trip(chameleons, N, K, L):\n        trip = [0] * K\n        for i in range(N):\n            d, b, direction = chameleons[i]\n            while d <= L:\n                trip[b] += 1\n                if direction == 'D':\n                    d += 1\n                else:\n                    d -= 1\n                if d > 0 and d < L:\n                    for j in range(i):\n                        if chameleons[j][0] == d:\n                            if chameleons[j][1] == b and chameleons[j][2] == 'D':\n                                chameleons[i][1] = chameleons[j][1]\n                                chameleons[j][1] = (chameleons[i][1] + chameleons[j][1]) % K\n                            elif chameleons[i][1] == chameleons[j][1] and chameleons[i][2] == 'D':\n                                chameleons[i][1] = chameleons[j][1]\n                            elif chameleons[i][1] == chameleons[j][1] and chameleons[j][2] == 'D':\n                                chameleons[j][1] = chameleons[i][1]\n                            direction = 'L' if direction == 'D' else 'D'\n                            break\n        return trip\n\n    input_data = [line.strip() for line in stdin.split('\\n') if line.strip()]\n    N, K, L = map(int, input_data[0].split())\n    chameleons = [(int(distance), int(color), direction) for distance, color, direction in [line.split() for line in input_data[1:]]]\n    trip = calculate_trip(chameleons, N, K, L)\n    return '\\n'.join(map(str, trip))"
    },
    {
        "number": 3208,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.strip()\n    encrypted_text_words = encrypted_text.split(' ')\n    \n    # Known words and their lengths\n    known_words = [\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"]\n    known_words_lengths = [len(word) for word in known_words]\n    \n    # Check if the encrypted text contains known words\n    def contains_known_words(encrypted_text_words):\n        for word in encrypted_text_words:\n            if len(word) in known_words_lengths:\n                return True\n        return False\n    \n    if not contains_known_words(encrypted_text_words):\n        return \"Impossible\"\n    \n    # Decrypt the encrypted text\n    def decrypt_text(encrypted_text, mapping):\n        decrypted_text = \"\"\n        for char in encrypted_text:\n            if char in mapping:\n                decrypted_text += mapping[char]\n            else:\n                decrypted_text += char\n        return decrypted_text\n    \n    # Generate all possible mappings\n    def generate_mappings(known_words, encrypted_text):\n        mappings = []\n        for word in known_words:\n            for char in encrypted_text:\n                if char in word:\n                    for encrypted_char in word:\n                        if encrypted_char != char:\n                            mapping = {}\n                            mapping[char] = encrypted_char\n                            if encrypted_char not in mapping.values():\n                                mapping[encrypted_char] = char\n                                mappings.append(mapping)\n        return mappings\n    \n    mappings = generate_mappings(known_words, encrypted_text)\n    \n    # Check if the mapping is valid\n    def is_valid_mapping(mapping, encrypted_text_words):\n        for word in encrypted_text_words:\n            decrypted_word = decrypt_text(word, mapping)\n            if decrypted_word not in known_words:\n                return False\n        return True\n    \n    # Find the valid mapping\n    for mapping in mappings:\n        if is_valid_mapping(mapping, encrypted_text_words):\n            return decrypt_text(encrypted_text, mapping)\n    \n    return \"Impossible\""
    },
    {
        "number": 3208,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.strip()\n    encrypted_words = encrypted_text.split(' ')\n    decryption_map = {}\n\n    # Known words\n    known_words = [\n        \"be\",\n        \"our\",\n        \"rum\",\n        \"will\",\n        \"dead\",\n        \"hook\",\n        \"ship\",\n        \"blood\",\n        \"sable\",\n        \"avenge\",\n        \"parrot\",\n        \"captain\"\n    ]\n\n    def is_decryptable(decryption_map):\n        for word in known_words:\n            decrypted_word = ''.join([decryption_map.get(char, char) for char in word])\n            if decrypted_word not in encrypted_words:\n                return False\n        return True\n\n    def find_next_word(start_index):\n        for i in range(start_index, len(encrypted_words)):\n            word = encrypted_words[i]\n            for known_word in known_words:\n                if len(known_word) == len(word):\n                    return i, known_word\n        return None, None\n\n    def decrypt_with_map(decryption_map):\n        decrypted_text = []\n        for char in encrypted_text:\n            if char in decryption_map:\n                decrypted_text.append(decryption_map[char])\n            else:\n                decrypted_text.append(char)\n        return ''.join(decrypted_text)\n\n    # Initialize the decryption map\n    for encrypted_char in encrypted_text:\n        if encrypted_char not in decryption_map:\n            decryption_map[encrypted_char] = ' '\n\n    # Start decryption\n    i, known_word = find_next_word(0)\n    while i is not None:\n        encrypted_word = encrypted_words[i]\n        decrypted_word = ''.join([decryption_map.get(char, char) for char in encrypted_word])\n        for j in range(len(known_word)):\n            if known_word[j] not in decryption_map:\n                decryption_map[known_word[j]] = encrypted_word[j]\n        for j in range(i + 1, len(encrypted_words)):\n            encrypted_next_word = encrypted_words[j]\n            if len(encrypted_next_word) == len(encrypted_word):\n                decrypted_next_word = ''.join([decryption_map.get(char, char) for char in encrypted_next_word])\n                if sorted(decrypted_word) == sorted(decrypted_next_word):\n                    return \"Impossible\"\n        i, known_word = find_next_word(i + 1)\n\n    # Check if the decryption is valid\n    if not is_decryptable(decryption_map):\n        return \"Impossible\"\n\n    # Decrypt the text\n    return decrypt_with_map(decryption_map)"
    },
    {
        "number": 3208,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.strip()\n    encrypted_words = encrypted_text.split()\n\n    if len(encrypted_words) < 2:\n        return \"Impossible\"\n\n    decrypted_text = decrypt(encrypted_words[0], encrypted_words[1])\n    if decrypted_text is None:\n        return \"Impossible\"\n\n    for word in encrypted_words[2:]:\n        decrypted_word = decrypt(word, decrypted_text)\n        if decrypted_word is None:\n            return \"Impossible\"\n        decrypted_text = decrypted_word\n\n    return decrypted_text\n\n\ndef"
    },
    {
        "number": 3208,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.strip().split(\" \")\n    substitution_mapping = {}\n    known_words = [\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"]\n    for word in known_words:\n        for letter in word:\n            if letter not in substitution_mapping:\n                substitution_mapping[letter] = set()\n            substitution_mapping[letter].add(word)\n    \n    for encrypted_letter in set(encrypted_text):\n        if encrypted_letter not in substitution_mapping:\n            return \"Impossible\"\n    \n    for encrypted_word in encrypted_text:\n        decrypted_word = \"\"\n        for encrypted_letter in encrypted_word:\n            for word in substitution_mapping[encrypted_letter]:\n                if word not in known_words:\n                    known_words.append(word)\n                decrypted_word += word[encrypted_word.index(encrypted_letter)]\n        print(decrypted_word)\n\n    return \" \".join(decrypted_word)"
    },
    {
        "number": 3208,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.strip().split()\n    substitution_mapping = {}\n\n    def count_different_letters(words):\n        letters = set()\n        for word in words:\n            for letter in word:\n                letters.add(letter)\n        return len(letters)\n\n    known_words = [\n        \"be\",\n        \"our\",\n        \"rum\",\n        \"will\",\n        \"dead\",\n        \"hook\",\n        \"ship\",\n        \"blood\",\n        \"sable\",\n        \"avenge\",\n        \"parrot\",\n        \"captain\"\n    ]\n\n    for encrypted_word in encrypted_text:\n        for known_word in known_words:\n            if encrypted_word.startswith(known_word):\n                for i, letter in enumerate(known_word):\n                    substitution_mapping[encrypted_word[i]] = letter\n                break\n\n    if len(substitution_mapping) != count_different_letters(known_words):\n        return \"Impossible\"\n\n    plain_text = []\n    for encrypted_letter in stdin:\n        if encrypted_letter in substitution_mapping:\n            plain_text.append(substitution_mapping[encrypted_letter])\n        else:\n            plain_text.append(encrypted_letter)\n\n    return \"\".join(plain_text)"
    },
    {
        "number": 3208,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.strip()\n    encrypted_words = encrypted_text.split(' ')\n    known_words = [\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"]\n\n    def is_encrypted_word_valid(word: str, substitution_map: dict) -> bool:\n        for char in word:\n            if char not in substitution_map:\n                return False\n        return True\n\n    def find_unique_substitution_map(encrypted_words: list, known_words: list) -> dict:\n        for known_word in known_words:\n            for encrypted_word in encrypted_words:\n                if len(known_word) == len(encrypted_word):\n                    substitution_map = {}\n                    for i in range(len(known_word)):\n                        substitution_map[encrypted_word[i]] = known_word[i]\n                    if all(is_encrypted_word_valid(word, substitution_map) for word in encrypted_words):\n                        return substitution_map\n        return None\n\n    def decrypt_text(encrypted_text: str, substitution_map: dict) -> str:\n        decrypted_text = \"\"\n        for char in encrypted_text:\n            if char in substitution_map:\n                decrypted_text += substitution_map[char]\n            else:\n                decrypted_text += char\n        return decrypted_text\n\n    unique_substitution_map = find_unique_substitution_map(encrypted_words, known_words)\n\n    if unique_substitution_map:\n        decrypted_text = decrypt_text(encrypted_text, unique_substitution_map)\n        return decrypted_text\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3208,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.strip()\n    encrypted_words = encrypted_text.split(\" \")\n\n    # Create a dictionary to store the known words and their corresponding encrypted versions\n    known_words = {\n        \"be\": \"\",\n        \"our\": \"\",\n        \"rum\": \"\",\n        \"will\": \"\",\n        \"dead\": \"\",\n        \"hook\": \"\",\n        \"ship\": \"\",\n        \"blood\": \"\",\n        \"sable\": \"\",\n        \"avenge\": \"\",\n        \"parrot\": \"\",\n        \"captain\": \"\"\n    }\n\n    # Populate the known_words dictionary with the encrypted versions of the known words\n    for word in known_words:\n        encrypted_word = \"\"\n        for char in word:\n            encrypted_char = char\n            for encrypted_word in encrypted_words:\n                if char in encrypted_word:\n                    encrypted_char = encrypted_word[encrypted_word.index(char)]\n                    break\n            encrypted_word += encrypted_char\n        known_words[word] = encrypted_word\n\n    # Check if it is possible to uniquely decrypt the encrypted text\n    decodable = True\n    for encrypted_word in encrypted_words:\n        unique_chars = set(encrypted_word)\n        if len(unique_chars) > 12:\n            decodable = False\n            break\n\n    # If it is possible to uniquely decrypt the encrypted text, create the decryption mapping\n    if decodable:\n        decryption_mapping = {}\n        for encrypted_word in encrypted_words:\n            decryption_mapping[known_words[encrypted_word]] = encrypted_word\n\n        # Decrypt the encrypted text using the decryption mapping\n        decrypted_text = \"\"\n        for encrypted_word in encrypted_words:\n            for char in encrypted_word:\n                decrypted_text += decryption_mapping[char]\n            decrypted_text += \" \"\n\n        return decrypted_text.strip()\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3208,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.strip().split()\n    encrypted_set = set(encrypted_text)\n    words = [\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"]\n\n    if not encrypted_set.issubset(set(words)):\n        return \"Impossible\"\n\n    for word in words:\n        if word in encrypted_set:\n            encrypted_set.remove(word)\n\n    if len(encrypted_set) != 8:\n        return \"Impossible\"\n\n    decryption_map = {}\n    decryption_map[\"a\"] = \"be\"\n    decryption_map[\"b\"] = \"our\"\n    decryption_map[\"c\"] = \"rum\"\n    decryption_map[\"d\"] = \"will\"\n    decryption_map[\"e\"] = \"dead\"\n    decryption_map[\"f\"] = \"hook\"\n    decryption_map[\"g\"] = \"ship\"\n    decryption_map[\"h\"] = \"blood\"\n    decryption_map[\"i\"] = \"sable\"\n    decryption_map[\"j\"] = \"avenge\"\n    decryption_map[\"k\"] = \"parrot\"\n    decryption_map[\"l\"] = \"captain\"\n\n    decrypted_text = []\n    for letter in encrypted_text:\n        decrypted_text.append(decryption_map[letter])\n\n    return \" \".join(decrypted_text)"
    },
    {
        "number": 3208,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.strip()\n    encrypted_words = encrypted_text.split()\n    known_words = [\n        \"be\",\n        \"our\",\n        \"rum\",\n        \"will\",\n        \"dead\",\n        \"hook\",\n        \"ship\",\n        \"blood\",\n        \"sable\",\n        \"avenge\",\n        \"parrot\",\n        \"captain\"\n    ]\n\n    def find_mapping(encrypted_word, known_word):\n        mapping = {}\n        for encrypted_letter, known_letter in zip(encrypted_word, known_word):\n            if encrypted_letter in mapping and mapping[encrypted_letter] != known_letter:\n                return None\n            mapping[encrypted_letter] = known_letter\n        return mapping\n\n    def decrypt(encrypted_text, mapping):\n        decrypted_text = \"\"\n        for encrypted_letter in encrypted_text:\n            decrypted_letter = mapping.get(encrypted_letter, encrypted_letter)\n            decrypted_text += decrypted_letter\n        return decrypted_text\n\n    def is_decryptable(encrypted_text, known_words):\n        encrypted_words = encrypted_text.split()\n        encrypted_word_set = set(encrypted_words)\n        known_word_set = set(known_words)\n        shared_words = encrypted_word_set.intersection(known_word_set)\n        if len(shared_words) < 3:\n            return False\n\n        unique_letters = set()\n        for word in shared_words:\n            unique_letters.update(set(word))\n\n        if len(unique_letters) != len(encrypted_text.replace(\" \", \"\")):\n            return False\n\n        return True\n\n    if not is_decryptable(encrypted_text, known_words):\n        return \"Impossible\"\n\n    mapping = {}\n    for encrypted_word, known_word in zip(encrypted_words, known_words):\n        word_mapping = find_mapping(encrypted_word, known_word)\n        if word_mapping is None:\n            return \"Impossible\"\n        mapping.update(word_mapping)\n\n    return decrypt(encrypted_text, mapping)"
    },
    {
        "number": 3208,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.strip().split()\n    encrypted_letters = set()\n    for word in encrypted_text:\n        encrypted_letters.update(set(word))\n\n    known_words = {\n        \"be\": \"our\",\n        \"our\": \"be\",\n        \"rum\": \"will\",\n        \"will\": \"rum\",\n        \"dead\": \"hook\",\n        \"hook\": \"dead\",\n        \"ship\": \"blood\",\n        \"blood\": \"ship\",\n        \"sable\": \"avenge\",\n        \"avenge\": \"sable\",\n        \"parrot\": \"parrot\",\n        \"captain\": \"captain\"\n    }\n\n    decoded_letters = {}\n    for word in known_words:\n        if word in encrypted_text:\n            decoded_letters[known_words[word]] = word\n\n    if len(decoded_letters) != len(encrypted_letters):\n        return \"Impossible\"\n\n    decoded_text = \"\"\n    for word in encrypted_text:\n        for letter in word:\n            if letter in decoded_letters:\n                decoded_text += decoded_letters[letter]\n            else:\n                decoded_text += letter\n        decoded_text += \" \"\n\n    return decoded_text.strip()"
    },
    {
        "number": 3209,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_duration(origin, dest, connections, adj_list):\n        if origin == dest:\n            return 0\n        for connection in connections:\n            if connection[0] == origin and connection[1] != dest:\n                adj_list[origin].append(connection[1])\n        if not adj_list[origin]:\n            return \"IMPOSSIBLE\"\n        min_duration = float(\"inf\")\n        for vertex in adj_list[origin]:\n            if vertex not in adj_list:\n                adj_list[vertex] = []\n            duration = find_min_duration(vertex, dest, connections, adj_list)\n            if duration != \"IMPOSSIBLE\":\n                min_duration = min(min_duration, connection_duration(vertex, dest) + duration)\n        return min_duration\n\n    def connection_duration(origin, dest, connections):\n        for connection in connections:\n            if connection[0] == origin and connection[1] == dest:\n                return connection[3]\n        return \"IMPOSSIBLE\"\n\n    def adjacency_list(connections):\n        adj_list = {}\n        for connection in connections:\n            if connection[0] not in adj_list:\n                adj_list[connection[0]] = [connection[1]]\n            else:\n                adj_list[connection[0]].append(connection[1])\n        return adj_list\n\n    lines = stdin.split(\"\\n\")\n    origin, dest = lines[0].split()\n    n = int(lines[1])\n    connections = [line.split() for line in lines[2:n+2]]\n    connections = [[c[0], c[1], int(c[2]), int(c[3]), int(c[4]), int(c[5])] for c in connections]\n    adj_list = adjacency_list(connections)\n\n    min_duration = find_min_duration(origin, dest, connections, adj_list)\n    if min_duration == \"IMPOSSIBLE\":\n        return \"IMPOSSIBLE\"\n    else:\n        return f\"{min_duration:.6f}\""
    },
    {
        "number": 3209,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_reachable(graph, origin, destination, visited=None):\n        if visited is None:\n            visited = set()\n        if origin == destination:\n            return True\n        visited.add(origin)\n        for neighbor, weight in graph[origin]:\n            if neighbor not in visited:\n                if is_reachable(graph, neighbor, destination, visited):\n                    return True\n        return False\n\n    def parse_input(stdin: str):\n        lines = stdin.split('\\n')\n        origin, destination = lines[0].split()\n        n = int(lines[1])\n        train_connections = []\n        for i in range(n):\n            line = lines[2 + i]\n            place1, place2, hour, time, delay_percentage, max_delay = line.split()\n            train_connections.append(((place1, place2, int(hour) * 60 + int(time), int(delay_percentage), int(max_delay))))\n        return origin, destination, train_connections\n\n    def build_graph(train_connections):\n        graph = defaultdict(list)\n        for place1, place2, departure_time, delay_percentage, max_delay in train_connections:\n            weight = departure_time + (delay_percentage * max_delay // 100)\n            graph[place1].append((place2, weight))\n        return graph\n\n    origin, destination, train_connections = parse_input(stdin)\n    graph = build_graph(train_connections)\n\n    if not is_reachable(graph, origin, destination):\n        return \"IMPOSSIBLE\"\n\n    # Dijkstra's algorithm to find the shortest path\n    distances = {place: float('inf') for place in graph}\n    distances[origin] = 0\n    visited = set()\n\n    while visited != set(graph):\n        unvisited = {place: distance for place, distance in distances.items() if place not in visited}\n        current_place, current_distance = min(unvisited.items(), key=lambda x: x[1])\n        visited.add(current_place)\n\n        for neighbor, weight in graph[current_place]:\n            if neighbor not in visited:\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n\n    return f\"{float(distances[destination]):.6f}\""
    },
    {
        "number": 3209,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(start, end, connections, probabilities, delays, destinations):\n        distances = {place: float('inf') for place in destinations}\n        distances[start] = 0\n        visited = set()\n        while distances:\n            current_place = min(distances, key=distances.get)\n            visited.add(current_place)\n            if current_place == end:\n                return distances[end]\n            for i, (origin, destination, departure, journey_time, probability, max_delay) in enumerate(connections):\n                if current_place == origin and destination not in visited:\n                    time = departure + journey_time\n                    if time < distances[destination]:\n                        delay_probability = (probability / 100) * (max_delay / 60)\n                        expected_delay = sum(range(1, max_delay + 1)) / 60 / 2\n                        distances[destination] = time + (1 - delay_probability) * expected_delay\n                        probabilities[destination] = delay_probability\n                        delays[destination] = max_delay\n            distances.pop(current_place)\n        return 'IMPOSSIBLE'\n\n    input_data = stdin.split('\\n')\n    origin, destination = input_data[0].split()\n    n = int(input_data[1])\n    connections = [tuple(line.split()) for line in input_data[2:n + 2]]\n    connections = [(origin, destination, int(departure) * 60, int(journey_time), int(probability), int(max_delay)) for origin, destination, departure, journey_time, probability, max_delay in connections]\n    probabilities = {origin: 0, destination: 0}\n    delays = {origin: 0, destination: 0}\n    destinations = set(place for _, place, *_ in connections) | {origin, destination}\n    return f\"{dijkstra(origin, destination, connections, probabilities, delays, destinations):.6f}\""
    },
    {
        "number": 3209,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        queue = []\n        for node in graph:\n            node[\"distance\"] = float(\"inf\")\n            node[\"visited\"] = False\n        start[\"distance\"] = 0\n        heapq.heappush(queue, (0, start))\n        while queue:\n            current_distance, current_node = heapq.heappop(queue)\n            if current_node[\"name\"] == end[\"name\"]:\n                return current_distance\n            if current_node[\"visited\"]:\n                continue\n            current_node[\"visited\"] = True\n            for neighbor in current_node[\"connections\"]:\n                distance = current_distance + neighbor[\"weight\"]\n                if distance < neighbor[\"node\"][\"distance\"]:\n                    neighbor[\"node\"][\"distance\"] = distance\n                    neighbor[\"node\"][\"previous\"] = current_node\n                    heapq.heappush(queue, (distance, neighbor[\"node\"]))\n        return None\n\n    def calculate_expected_duration(graph, start, end):\n        graph_with_weights = []\n        for node in graph:\n            connections = []\n            for connection in node[\"connections\"]:\n                delay_probability = connection[\"delay_probability\"] / 100\n                expected_delay = sum([delay_probability * i for i in range(1, connection[\"max_delay\"] + 1)])\n                connections.append({\"node\": connection[\"destination\"], \"weight\": connection[\"duration\"] + expected_delay})\n            graph_with_weights.append({\"name\": node[\"name\"], \"connections\": connections})\n        return dijkstra(graph_with_weights, start, end)\n\n    def read_input(stdin):\n        origin, destination = stdin.readline().strip().split()\n        n = int(stdin.readline())\n        train_connections = []\n        for _ in range(n):\n            origin, destination, departure_time, duration, delay_probability, max_delay = stdin.readline().strip().split()\n            departure_time = int(departure_time)\n            duration = int(duration)\n            delay_probability = int(delay_probability)\n            max_delay = int(max_delay)\n            train_connections.append({\"origin\": origin, \"destination\": destination, \"departure_time\": departure_time, \"duration\": duration, \"delay_probability\": delay_probability, \"max_delay\": max_delay})\n        return origin, destination, train_connections\n\n    def main(stdin):\n        origin, destination, train_connections = read_input(stdin)\n        graph = []\n        for connection in train_connections:\n            origin_node = None\n            destination_node = None\n            for node in graph:\n                if node[\"name\"] == connection[\"origin\"]:\n                    origin_node = node\n                if node[\"name\"] == connection[\"destination\"]:\n                    destination_node = node\n            if not origin_node:\n                origin_node = {\"name\": connection[\"origin\"], \"connections\": []}\n                graph.append(origin_node)\n            if not destination_node:\n                destination_node = {\"name\": connection[\"destination\"], \"connections\": []}\n                graph.append(destination_node)\n            origin_node[\"connections\"].append({\"destination\": destination_node, \"weight\": connection[\"duration\"]})\n        expected_duration = calculate_expected_duration(graph, {\"name\": origin}, {\"name\": destination})\n        if expected_duration:\n            return f\"{expected_duration:.6f}\"\n        else:\n            return \"IMPOSSIBLE\"\n\n    return main(stdin) "
    },
    {
        "number": 3209,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    origin, destination = stdin.split()[:2]\n    n = int(stdin.split()[2])\n    train_connections = stdin.split('\\n')[1:]\n\n    def get_delay_duration(p, d):\n        return p * d / 100\n\n    def find_min_duration(connections, current_place, current_time, current_delay):\n        if current_place == destination:\n            return current_time + current_delay\n        min_duration = float('inf')\n        for connection in connections:\n            place1, place2, departure_time, journey_time, probability, delay_range = connection.split()\n            departure_time = int(departure_time)\n            journey_time = int(journey_time)\n            probability = int(probability)\n            delay_range = int(delay_range)\n            if place1 == current_place:\n                new_time = current_time + departure_time\n                delay_duration = get_delay_duration(probability, delay_range)\n                new_delay = current_delay + delay_duration\n                connections.remove(connection)\n                min_duration = min(min_duration, find_min_duration(connections, place2, new_time, new_delay))\n        return min_duration\n\n    min_duration = find_min_duration(train_connections, origin, 0, 0)\n    if min_duration == float('inf'):\n        return 'IMPOSSIBLE'\n    return str(round(min_duration, 6))"
    },
    {
        "number": 3209,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    origin, destination, n = stdin.split('\\n')[0].split()\n    n = int(n)\n    connections = []\n    for i in range(n):\n        origin, destination, departure_time, duration, delay_probability, max_delay = stdin.split('\\n')[i + 1].split()\n        departure_time = int(departure_time)\n        duration = int(duration)\n        delay_probability = int(delay_probability) / 100\n        max_delay = int(max_delay)\n        connections.append((origin, destination, departure_time, duration, delay_probability, max_delay))\n\n    # sort connections by departure time\n    connections.sort(key=lambda x: x[2])\n\n    # initialize dynamic programming table\n    dp = {(origin, destination): (0, 1)}\n\n    # iterate through connections\n    for i in range(n):\n        origin, destination, departure_time, duration, delay_probability, max_delay = connections[i]\n\n        # update table with new arrival times\n        new_dp = {}\n        for (origin2, destination2), (duration2, probability2) in dp.items():\n            if origin2 == origin:\n                arrival_time = departure_time + duration2 + duration\n                delay_time = arrival_time + max_delay\n                new_dp[(destination2, destination)] = (arrival_time, probability2)\n                new_dp[(destination2, destination), 'delay'] = (delay_time, probability2 * delay_probability)\n\n        dp.update(new_dp)\n\n    # find minimum expected duration\n    min_duration = float('inf')\n    for (_, destination2), (duration2, probability2) in dp.items():\n        if destination2 == destination:\n            min_duration = min(min_duration, duration2 * probability2)\n\n    # check if destination is reachable\n    if min_duration == float('inf'):\n        return 'IMPOSSIBLE'\n\n    # round to 6 decimal places\n    min_duration = round(min_duration, 6)\n\n    return str(min_duration)"
    },
    {
        "number": 3209,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end, weights=False):\n        if start not in graph or end not in graph:\n            return None\n        distances = {vertex: float('inf') for vertex in graph}\n        distances[start] = 0\n        pq = [(0, start)]\n        visited = set()\n\n        while pq:\n            current_distance, current_vertex = heapq.heappop(pq)\n            if current_vertex in visited:\n                continue\n            visited.add(current_vertex)\n            if current_vertex == end:\n                return distances[end]\n\n            for neighbor, weight in graph[current_vertex].items():\n                if weights:\n                    distance = current_distance + weight\n                else:\n                    distance = current_distance + weight[0]\n\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n\n        return distances[end] if end in distances else None\n\n    def parse_input(stdin):\n        lines = stdin.split('\\n')\n        origin, destination = lines[0].split()\n        connections = []\n        for line in lines[1:]:\n            line = line.split()\n            connections.append((line[0], line[1], int(line[2]), int(line[3]), int(line[4]) * int(line[5]) / 100))\n        return origin, destination, connections\n\n    def build_graph(connections):\n        graph = defaultdict(dict)\n        for c in connections:\n            origin, destination, departure_time, duration, delay = c\n            graph[origin][destination] = (duration, delay)\n            graph[destination][origin] = (duration, 0)\n        return graph\n\n    def find_min_duration(origin, destination, connections):\n        graph = build_graph(connections)\n        duration = dijkstra(graph, origin, destination, weights=True)\n        return duration if duration is not None else \"IMPOSSIBLE\"\n\n    origin, destination, connections = parse_input(stdin)\n    result = find_min_duration(origin, destination, connections)\n    return f\"{result:.6f}\" if result != \"IMPOSSIBLE\" else \"IMPOSSIBLE\" "
    },
    {
        "number": 3209,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        vis = [False] * n\n        q = [(0, start)]\n        while q:\n            d, u = q.pop(0)\n            if u == end:\n                return d\n            if vis[u]:\n                continue\n            vis[u] = True\n            for v, w, p in graph[u]:\n                if not vis[v]:\n                    q.append((d + w, v))\n                    dist[v] = d + w\n                    dist[v] = min(dist[v], (d + w) * (1 + p / 100))\n        return dist[end]\n\n    origin, destination, *data = stdin.split('\\n')\n    n = int(data[0])\n    connections = data[1:]\n\n    graph = [[] for _ in range(n + 1)]\n\n    for i, connection in enumerate(connections):\n        a, b, m, t, p, d = connection.split()\n        m = int(m)\n        t = int(t)\n        p = int(p)\n        d = int(d)\n        graph[i].append((i + 1, t, p / 100))\n        graph[i + 1].append((i, t, p / 100))\n\n    dist = dijkstra(graph, 0, n)\n    return f\"{dist:.6f}\" if dist != float('inf') else \"IMPOSSIBLE\""
    },
    {
        "number": 3209,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin: str):\n        lines = stdin.split('\\n')\n        origin, destination = lines[0].split()\n        n = int(lines[1])\n        connections = []\n        for i in range(2, 2 + n):\n            line = lines[i]\n            connection_origin, connection_destination, departure_time, journey_time, delay_probability, delay_max = line.split()\n            departure_time = int(departure_time)\n            journey_time = int(journey_time)\n            delay_probability = int(delay_probability) / 100\n            delay_max = int(delay_max)\n            connections.append((connection_origin, connection_destination, departure_time, journey_time, delay_probability, delay_max))\n        return origin, destination, connections\n\n    def travel_time(origin, destination, connections):\n        if origin == destination:\n            return 0\n        expected_travel_time = float('inf')\n        for connection in connections:\n            connection_origin, connection_destination, departure_time, journey_time, delay_probability, delay_max = connection\n            if connection_origin != origin:\n                continue\n            total_travel_time = journey_time + delay_probability * delay_max\n            next_destination = connection_destination\n            while next_destination != destination:\n                for conn in connections:\n                    if conn[0] == next_destination:\n                        total_travel_time += conn[3]\n                        next_destination = conn[1]\n                        break\n                else:\n                    total_travel_time = float('inf')\n                    break\n            expected_travel_time = min(expected_travel_time, total_travel_time)\n        return expected_travel_time\n\n    origin, destination, connections = parse_input(stdin)\n    expected_travel_time = travel_time(origin, destination, connections)\n    return f\"{expected_travel_time:.6f}\" if expected_travel_time != float('inf') else \"IMPOSSIBLE\""
    },
    {
        "number": 3209,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    origin, destination, n = stdin.split(\"\\n\", 3)\n    n = int(n)\n    train_connections = []\n    for i in range(n):\n        line = stdin.split(\"\\n\", 3 + i)[3 + i].split()\n        departure_place, arrival_place, departure_time, journey_time, delay_prob, max_delay = line[0], line[1], int(line[2]), int(line[3]), int(line[4]), int(line[5])\n        train_connections.append((departure_place, arrival_place, departure_time, journey_time, delay_prob, max_delay))\n\n    def dijkstra(connections, origin, destination):\n        graph = {}\n        for connection in connections:\n            if connection[0] not in graph:\n                graph[connection[0]] = {}\n            graph[connection[0]][connection[1]] = connection[2:]\n\n        queue = [(0, origin, [])]\n        visited = set()\n        min_durations = {}\n\n        while queue:\n            total_duration, current_place, path = queue.pop(0)\n            if current_place in visited:\n                continue\n            visited.add(current_place)\n            path = path + [current_place]\n            min_durations[current_place] = total_duration\n\n            for neighbor, connection in graph[current_place].items():\n                journey_time, delay_prob, max_delay = connection\n                expected_delay = delay_prob * max_delay / 100\n                new_total_duration = total_duration + journey_time + expected_delay\n                queue.append((new_total_duration, neighbor, path))\n\n            queue.sort(key=lambda x: x[0])\n\n        return min_durations\n\n    min_durations = dijkstra(train_connections, origin, destination)\n\n    if destination not in min_durations:\n        return \"IMPOSSIBLE\"\n    else:\n        return \"{:.6f}\".format(min_durations[destination])"
    },
    {
        "number": 3210,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *board = stdin.split('\\n')\n    N = int(N)\n    board = [list(row) for row in board]\n    \n    def dfs(board, i, j, visited):\n        if not (0 <= i < 2 * N - 1 and 0 <= j < 2 * N - 1) or (i, j) in visited or board[i][j] != '.':\n            return 0\n        \n        visited.add((i, j))\n        return 1 + dfs(board, i - 1, j, visited) + dfs(board, i + 1, j, visited) + dfs(board, i, j - 1, visited) + dfs(board, i, j + 1, visited)\n    \n    max_moves = 0\n    for i in range(2 * N - 1):\n        for j in range(2 * N - 1):\n            if board[i][j] == '.':\n                visited = set()\n                moves = dfs(board, i, j, visited)\n                max_moves = max(max_moves, moves)\n                \n    return str(max_moves)"
    },
    {
        "number": 3210,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_moves(board, n):\n        moves = 0\n        for i in range(n):\n            for j in range(n):\n                if board[2 * i][2 * j] == '*' and board[2 * i][2 * j + 1] == '.':\n                    moves += 1\n                if board[2 * i + 1][2 * j] == '*' and board[2 * i + 1][2 * j + 1] == '.':\n                    moves += 1\n        return moves\n\n    def get_board(stdin):\n        n = int(stdin.readline().strip())\n        board = []\n        for _ in range(2 * n - 1):\n            board.append(list(stdin.readline().strip()))\n        return board, n\n\n    board, n = get_board(stdin)\n    moves = get_moves(board, n)\n    return str(moves)"
    },
    {
        "number": 3210,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, *grid = stdin.split('\\n')\n    N = int(N)\n    grid = [list(row) for row in grid]\n\n    def is_unit_square(i, j, direction):\n        if direction == '|' and grid[i][j] == '-' and grid[i + 1][j] == '-':\n            return True\n        if direction == '-' and grid[i][j] == '|' and grid[i][j + 1] == '|':\n            return True\n        return False\n\n    def count_moves(i, j, direction):\n        count = 0\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if 0 <= i + di < N and 0 <= j + dj < N and grid[i + di][j + dj] == '.':\n                count += 1\n        return count\n\n    def is_blocked(i, j, direction):\n        if direction == '|':\n            return grid[i][j + 1] == '*' or grid[i + 1][j + 1] == '*'\n        if direction == '-':\n            return grid[i + 1][j] == '*' or grid[i + 1][j + 1] == '*'\n\n    total_moves = 0\n    for i in range(N - 1):\n        for j in range(N - 1):\n            if grid[i][j] == '*':\n                for direction in '|-':\n                    if not is_blocked(i, j, direction) and not is_unit_square(i, j, direction):\n                        total_moves += count_moves(i, j, direction)\n\n    return str(total_moves)"
    },
    {
        "number": 3210,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_empty_cells(board):\n        empty_cells = []\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                if board[i][j] == '.':\n                    empty_cells.append((i, j))\n        return empty_cells\n\n    def is_valid(board, x, y):\n        if x < 0 or y < 0 or x >= len(board) or y >= len(board[0]):\n            return False\n        if board[x][y] != '.':\n            return False\n        return True\n\n    def get_neighbors(board, x, y):\n        neighbors = []\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if is_valid(board, x + dx, y + dy):\n                neighbors.append((x + dx, y + dy))\n        return neighbors\n\n    def is_unit_square_formed(board, x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if board[x + dx][y + dy] == '.':\n                return False\n        return True\n\n    def simulate_move(board, x, y):\n        new_board = [row.copy() for row in board]\n        new_board[x][y] = '.'\n        if x % 2 == 0:\n            new_board[x][y - 1] = '-'\n        else:\n            new_board[x][y + 1] = '-'\n        if y % 2 == 0:\n            new_board[x - 1][y] = '|'\n        else:\n            new_board[x + 1][y] = '|'\n        return new_board\n\n    def count_moves(board):\n        moves = 0\n        empty_cells = get_empty_cells(board)\n        for x, y in empty_cells:\n            if not is_unit_square_formed(board, x, y):\n                moves += 1\n        return moves\n\n    lines = stdin.strip().split('\\n')\n    N = int(lines[0])\n    board = [list(line) for line in lines[1:]]\n\n    max_moves = 0\n    for x, y in get_empty_cells(board):\n        if not is_unit_square_formed(board, x, y):\n            new_board = simulate_move(board, x, y)\n            max_moves = max(max_moves, count_moves(new_board))\n\n    return str(max_moves) "
    },
    {
        "number": 3210,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    board = lines[1:]\n    dots = 0\n    for i in range(N):\n        for j in range(N):\n            if board[2*i][2*j] == '*':\n                dots += 1\n    empty_spaces = 0\n    for i in range(1, 2*N-1):\n        for j in range(1, 2*N-1):\n            if board[i][j] == '.':\n                empty_spaces += 1\n    moves_left = min(empty_spaces, 2*dots - empty_spaces)\n    return str(moves_left)"
    },
    {
        "number": 3210,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    board = [list(line) for line in lines[1:]]\n\n    def is_valid_move(i, j, direction):\n        if direction == 'h':\n            if j == 0 or board[i][j - 1] == '.':\n                return False\n            if board[i][j] == '|':\n                return False\n            return True\n        else:\n            if i == 0 or board[i - 1][j] == '.':\n                return False\n            if board[i][j] == '-':\n                return False\n            return True\n\n    def make_move(i, j, direction):\n        if direction == 'h':\n            board[i][j] = '-'\n        else:\n            board[i][j] = '|'\n\n    def count_moves():\n        moves = 0\n        for i in range(2 * N - 1):\n            for j in range(2 * N - 1):\n                if board[i][j] == '.':\n                    if is_valid_move(i, j, 'h') or is_valid_move(i, j, 'v'):\n                        moves += 1\n        return moves\n\n    return str(count_moves())"
    },
    {
        "number": 3210,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, *board = stdin.splitlines()\n    N = int(N)\n\n    def is_valid(x, y):\n        if 0 <= x < 2 * N - 1 and 0 <= y < 2 * N - 1:\n            return True\n        return False\n\n    def is_empty(x, y):\n        if is_valid(x, y) and board[x][y] == '.':\n            return True\n        return False\n\n    def is_unconnected(x, y):\n        if is_valid(x, y) and board[x][y] == '-':\n            return True\n        return False\n\n    def is_undrawn(x, y):\n        if is_valid(x, y) and board[x][y] == '|':\n            return True\n        return False\n\n    def has_square(x, y):\n        if is_valid(x, y):\n            if is_valid(x - 1, y - 1) and board[x - 1][y - 1] == '*':\n                if is_valid(x - 1, y + 1) and board[x - 1][y + 1] == '*':\n                    if is_valid(x + 1, y - 1) and board[x + 1][y - 1] == '*':\n                        if is_valid(x + 1, y + 1) and board[x + 1][y + 1] == '*':\n                            return True\n        return False\n\n    def count_moves():\n        count = 0\n        for i in range(2 * N - 1):\n            for j in range(2 * N - 1):\n                if (is_empty(i, j) or is_undrawn(i, j) or is_unconnected(i, j)) and not has_square(i, j):\n                    count += 1\n        return count\n\n    return str(count_moves())"
    },
    {
        "number": 3210,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def check_square(board, i, j, k):\n        return (\n            board[i][j] == \"|\"\n            and board[i][k] == \"|\"\n            and board[j][i] == \"-\"\n            and board[k][i] == \"-\"\n        )\n\n    def generate_moves(board, moves):\n        for i in range(1, len(board) - 1, 2):\n            for j in range(1, len(board) - 1, 2):\n                if board[i][j] == \".\":\n                    if i > 1 and board[i - 2][j] == \"|\":\n                        moves.add((i, j, i - 2, j))\n                    if j > 1 and board[i][j - 2] == \"-\":\n                        moves.add((i, j, i, j - 2))\n        return moves\n\n    def simulate_move(board, move):\n        i, j, k, l = move\n        board[i][j] = board[k][l] = \"*\"\n        if i > 1 and board[i - 2][j] == \"|\" and board[i - 1][j] == \".\":\n            board[i - 1][j] = \"|\"\n        if j > 1 and board[i][j - 2] == \"-\" and board[i][j - 1] == \".\":\n            board[i][j - 1] = \"-\"\n        if i < len(board) - 2 and board[i + 2][j] == \"|\" and board[i + 1][j] == \".\":\n            board[i + 1][j] = \"|\"\n        if j < len(board) - 2 and board[i][j + 2] == \"-\" and board[i][j + 1] == \".\":\n            board[i][j + 1] = \"-\"\n\n    def count_squares(board):\n        count = 0\n        for i in range(1, len(board) - 1, 2):\n            for j in range(1, len(board) - 1, 2):\n                if (\n                    check_square(board, i, j, i + 1)\n                    or check_square(board, i, j, i - 1)\n                    or check_square(board, i, j, j + 1)\n                    or check_square(board, i, j, j - 1)\n                ):\n                    count += 1\n        return count\n\n    lines = stdin.strip().split(\"\\n\")\n    N = int(lines[0])\n    board = [list(line) for line in lines[1:]]\n\n    squares = count_squares(board)\n    moves = set()\n    generate_moves(board, moves)\n\n    while not squares and moves:\n        simulate_move(board, moves.pop())\n        squares = count_squares(board)\n\n    return str(len(moves) + squares)"
    },
    {
        "number": 3210,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_dot(matrix):\n        for i in range(len(matrix)):\n            for j in range(len(matrix)):\n                if matrix[i][j] == '*':\n                    return i, j\n\n    def is_unit_square_formed(matrix, i, j):\n        if i < 0 or i >= len(matrix) or j < 0 or j >= len(matrix):\n            return False\n        if matrix[i][j] == '*':\n            return True\n        return False\n\n    def get_adjacent_dots(matrix, i, j):\n        adjacent_dots = []\n        if i > 0 and matrix[i - 1][j] == '*' and (is_unit_square_formed(matrix, i - 2, j) or is_unit_square_formed(matrix, i - 1, j - 1)):\n            adjacent_dots.append((i - 1, j))\n        if i < len(matrix) - 1 and matrix[i + 1][j] == '*' and (is_unit_square_formed(matrix, i, j) or is_unit_square_formed(matrix, i + 1, j - 1)):\n            adjacent_dots.append((i + 1, j))\n        if j > 0 and matrix[i][j - 1] == '*' and (is_unit_square_formed(matrix, i, j - 2) or is_unit_square_formed(matrix, i - 1, j - 1)):\n            adjacent_dots.append((i, j - 1))\n        if j < len(matrix[0]) - 1 and matrix[i][j + 1] == '*' and (is_unit_square_formed(matrix, i, j) or is_unit_square_formed(matrix, i - 1, j + 1)):\n            adjacent_dots.append((i, j + 1))\n        return adjacent_dots\n\n    def find_moves(matrix, i, j, visited):\n        if (i, j) in visited:\n            return 0\n        visited.add((i, j))\n\n        adjacent_dots = get_adjacent_dots(matrix, i, j)\n        moves = 0\n        for dot in adjacent_dots:\n            if dot not in visited:\n                moves += 1\n                moves += find_moves(matrix, dot[0], dot[1], visited)\n        return moves\n\n    N = int(stdin.readline().strip())\n    matrix = [list(stdin.readline().strip()) for _ in range(2 * N - 1)]\n\n    i, j = find_dot(matrix)\n    visited = set()\n    return str(find_moves(matrix, i, j, visited))"
    },
    {
        "number": 3210,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(i, j):\n        return 0 <= i < N and 0 <= j < N\n\n    def dfs(i, j, visited):\n        if (i, j) in visited:\n            return 0\n        visited.add((i, j))\n\n        count = 0\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_i, new_j = i + di, j + dj\n            if is_valid(new_i, new_j) and (new_i, new_j) not in visited and board[new_i][new_j] == '.':\n                count = max(count, dfs(new_i, new_j, visited))\n        return count + 1\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    board = [list(lines[i + 1]) for i in range(N)]\n\n    max_count = 0\n    visited = set()\n\n    for i in range(N):\n        for j in range(N):\n            if (i, j) not in visited and board[i][j] == '.':\n                max_count = max(max_count, dfs(i, j, visited))\n\n    return str(max_count)"
    },
    {
        "number": 3211,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split(\"\\n\")\n    n = int(n)\n    s = list(s)\n    tellers = []\n    voters = []\n\n    for i in range(n):\n        if s[i] == '0':\n            tellers.append(i)\n        else:\n            voters.append(s[i])\n\n    if len(set(voters)) == 1:\n        return \"impossible\"\n\n    def count_points(voters):\n        points = [0, 0]\n        for i in range(len(voters) - 1):\n            if voters[i] != voters[i + 1]:\n                points[int(voters[i]) - 1] += 1\n        return points\n\n    def min_swaps(tellers, voters):\n        min_swaps = float('inf')\n        for i in range(len(tellers)):\n            for j in range(i, len(tellers)):\n                if abs(i - j) % 2 == 1:\n                    continue\n                new_tellers = tellers[:i] + [tellers[j]] + tellers[i:j] + [tellers[i]] + tellers[j + 1:]\n                new_voters = voters[:tellers[i]] + [voters[tellers[j]]] + voters[tellers[i]:tellers[j]] + [voters[tellers[i]]] + voters[tellers[j] + 1:]\n                points = count_points(new_voters)\n                if points[0] > points[1]:\n                    min_swaps = min(min_swaps, len(new_tellers))\n                else:\n                    min_swaps = min(min_swaps, len(new_tellers) + 1)\n        return min_swaps\n\n    return min_swaps(tellers, voters)"
    },
    {
        "number": 3211,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split(\"\\n\")\n    n = int(n)\n    s = list(s)\n    swaps = 0\n\n    for i in range(n - 1):\n        if s[i] == \"0\" and s[i + 1] == \"0\":\n            continue\n        if s[i] == \"0\" and s[i + 1] == \"1\":\n            s[i], s[i + 1] = s[i + 1], s[i]\n            swaps += 1\n            if i > 0 and s[i - 1] == \"2\":\n                s[i - 1], s[i + 1] = s[i + 1], s[i - 1]\n                swaps += 1\n        if s[i] == \"0\" and s[i + 1] == \"2\":\n            s[i], s[i + 1] = s[i + 1], s[i]\n            swaps += 1\n            if i > 0 and s[i - 1] == \"1\":\n                s[i - 1], s[i + 1] = s[i + 1], s[i - 1]\n                swaps += 1\n\n    if s.count(\"1\") > s.count(\"2\"):\n        return str(swaps)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3211,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n\n    votes_1 = s.count('1')\n    votes_2 = s.count('2')\n\n    if votes_1 > votes_2:\n        return '0'\n    elif votes_2 > votes_1:\n        return 'impossible'\n    else:\n        # Check if adjacent swaps can change the result\n        for i in range(n - 1):\n            if (s[i] == '1' and s[i + 1] == '2') or (s[i] == '2' and s[i + 1] == '1'):\n                s = list(s)\n                s[i], s[i + 1] = s[i + 1], s[i]\n                if (s.count('1') > s.count('2')) or (s.count('2') > s.count('1')):\n                    return '1'\n                else:\n                    s[i], s[i + 1] = s[i + 1], s[i]\n        return 'impossible'"
    },
    {
        "number": 3211,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_points(votes: list) -> tuple:\n        party_1 = sum(1 for vote in votes if vote == \"1\")\n        party_2 = sum(1 for vote in votes if vote == \"2\")\n        if party_1 > party_2:\n            return (1, 0)\n        elif party_1 < party_2:\n            return (0, 1)\n        else:\n            return (0, 0)\n\n    def swap_adjacent_tellers(arrivals: str) -> str:\n        swaps = 0\n        arrivals = list(arrivals)\n        for i in range(len(arrivals) - 1):\n            if arrivals[i] == \"0\" and arrivals[i + 1] == \"0\":\n                arrivals[i], arrivals[i + 1] = arrivals[i + 1], arrivals[i]\n                swaps += 1\n        return \"\".join(arrivals), swaps\n\n    n, arrivals = stdin.strip().split(\"\\n\")\n    n = int(n)\n    arrivals, swaps = swap_adjacent_tellers(arrivals)\n\n    votes = []\n    points = [0, 0]\n    for i, vote in enumerate(arrivals):\n        if vote in [\"1\", \"2\"]:\n            votes.append(vote)\n            points = count_points(votes)\n            if points[0] > points[1]:\n                break\n\n    if points[0] > points[1]:\n        return swaps\n    else:\n        return \"impossible\" "
    },
    {
        "number": 3211,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n    s = list(s)\n    voters = [i for i in range(n) if s[i] != '0']\n    tellers = [i for i in range(n) if s[i] == '0']\n\n    def count_points(votes):\n        points = [0, 0]\n        for i in range(len(votes) - 1):\n            if votes[i] != votes[i + 1]:\n                points[votes[i + 1] == 1] += 1\n        return points\n\n    def find_teller_index(index):\n        for i, teller in enumerate(tellers):\n            if teller >= index:\n                return i\n\n    def simulate(votes, swaps):\n        for swap in swaps:\n            index = swap[0]\n            direction = swap[1]\n            if s[index] == '0':\n                teller_index = find_teller_index(index)\n                if direction == 1:\n                    if teller_index > 0:\n                        tellers[teller_index] -= 1\n                        tellers[teller_index - 1] += 1\n                else:\n                    if teller_index < len(tellers) - 1:\n                        tellers[teller_index] += 1\n                        tellers[teller_index + 1] -= 1\n\n        points = count_points(votes)\n        return points\n\n    def backtrack(votes, swaps, start):\n        if start >= len(swaps):\n            return simulate(votes, swaps)\n\n        points = simulate(votes, swaps[:start] + swaps[start + 1:])\n        if points[1] > points[0]:\n            return points\n\n        swap_right = (swaps[start][0], 1)\n        swap_left = (swaps[start][0] - 1, -1)\n\n        points_right = simulate(votes, swaps[:start] + [swap_right] + swaps[start + 1:])\n        points_left = simulate(votes, swaps[:start] + [swap_left] + swaps[start + 1:])\n\n        if points_right[1] > points_right[0] and points_right[1] > points[1]:\n            return points_right\n        elif points_left[1] > points_left[0] and points_left[1] > points[1]:\n            return points_left\n        else:\n            return backtrack(votes, swaps, start + 1)\n\n    swaps = [(voters[i], 1) for i in range(len(voters) - 1) if voters[i] + 1 != voters[i + 1]]\n    swaps += [(voters[i], -1) for i in range(len(voters) - 1) if voters[i] - 1 != voters[i + 1]]\n\n    points = backtrack(s, swaps, 0)\n\n    if points[1] > points[0]:\n        return str(len(swaps))\n    else:\n        return 'impossible' "
    },
    {
        "number": 3211,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_points(votes: list) -> tuple:\n        ones = votes.count(1)\n        twos = votes.count(2)\n        points_1 = 0\n        points_2 = 0\n        for i in range(len(votes) - 1):\n            if votes[i] != votes[i + 1]:\n                if votes[i] == 1:\n                    points_1 += ones\n                else:\n                    points_2 += twos\n        if votes[-1] == 1:\n            points_1 += ones\n        else:\n            points_2 += twos\n        return points_1, points_2\n\n    def min_swaps(n: int, s: str) -> int:\n        votes = [0 if c == '0' else int(c) for c in s]\n        points_1, points_2 = count_points(votes)\n        swaps = 0\n        i = 0\n        while i < n - 1 and points_1 <= points_2:\n            if votes[i] == votes[i + 1]:\n                i += 1\n                continue\n            votes[i], votes[i + 1] = votes[i + 1], votes[i]\n            swaps += 1\n            points_1, points_2 = count_points(votes)\n        return swaps if points_1 > points_2 else \"impossible\"\n\n    n, s = stdin.split('\\n')\n    return str(min_swaps(int(n), s)) "
    },
    {
        "number": 3211,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def count_points(votes: List[int], tellers: Set[int]) -> int:\n        points = [0, 0]\n        for i, vote in enumerate(votes):\n            if i not in tellers:\n                points[vote - 1] += 1\n        if points[0] > points[1]:\n            return 1\n        elif points[0] < points[1]:\n            return 2\n        else:\n            return 0\n\n    def find_min_swaps(arrivals: str, n: int) -> int:\n        votes = [int(c) for c in arrivals]\n        tellers = {i for i in range(n) if votes[i] == 0}\n        points = count_points(votes, tellers)\n\n        if points == 0:\n            return \"impossible\"\n        elif points == 1:\n            return 0\n        else:\n            swaps = 0\n            for i in range(n - 1):\n                if votes[i] != 0 and votes[i + 1] != 0:\n                    votes[i], votes[i + 1] = votes[i + 1], votes[i]\n                    swaps += 1\n                    points_new = count_points(votes, tellers)\n                    if points_new == 1:\n                        return swaps\n            return \"impossible\"\n\n    n, arrivals = stdin.split('\\n')\n    n = int(n)\n    return find_min_swaps(arrivals, n) "
    },
    {
        "number": 3211,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n\n    votes_1 = s.count('1')\n    votes_2 = s.count('2')\n\n    if votes_1 == votes_2:\n        return \"impossible\"\n\n    max_points = max(votes_1, votes_2)\n\n    tellers = [i for i in range(n) if s[i] == '0']\n\n    swaps = 0\n\n    for i in range(len(tellers) - 1):\n        if s[tellers[i] + 1] != '0':\n            swaps += 1\n            s = list(s)\n            s[tellers[i]], s[tellers[i] + 1] = s[tellers[i] + 1], s[tellers[i]]\n            s = ''.join(s)\n\n        new_votes_1 = s.count('1', 0, tellers[i] + 1)\n        new_votes_2 = s.count('2', 0, tellers[i] + 1)\n\n        if new_votes_1 > new_votes_2 and new_votes_1 - new_votes_2 > max_points - new_votes_1:\n            max_points = new_votes_1\n        elif new_votes_2 > new_votes_1 and new_votes_2 - new_votes_1 > max_points - new_votes_2:\n            max_points = new_votes_2\n\n    return swaps"
    },
    {
        "number": 3211,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split(\"\\n\")\n    n = int(n)\n\n    def count_points(votes):\n        points = [0, 0]\n        for i in range(n):\n            if votes[i] != 0:\n                continue\n            if i == 0 or i == n - 1:\n                continue\n            if votes[i - 1] == votes[i + 1]:\n                continue\n            points[votes[i - 1]] += 1\n            points[votes[i + 1]] -= 1\n        return points\n\n    def find_swap(votes):\n        points = count_points(votes)\n        if points[0] > points[1]:\n            return \"impossible\"\n        if points[0] == points[1]:\n            for i in range(n):\n                if votes[i] == 0:\n                    continue\n                if i == 0 or i == n - 1:\n                    continue\n                if votes[i - 1] == votes[i + 1]:\n                    continue\n                if votes[i] == 1 and votes[i - 1] == 2:\n                    return i\n                if votes[i] == 2 and votes[i - 1] == 1:\n                    return i\n            return \"impossible\"\n        else:\n            for i in range(n):\n                if votes[i] == 0:\n                    continue\n                if i == 0 or i == n - 1:\n                    continue\n                if votes[i - 1] == votes[i + 1]:\n                    continue\n                if votes[i] == 1 and votes[i - 1] == 2:\n                    return i\n                if votes[i] == 2 and votes[i - 1] == 1:\n                    return i\n            return \"impossible\"\n\n    votes = [0] * n\n    for i in range(n):\n        votes[i] = int(s[i])\n\n    swap_count = 0\n    swap = find_swap(votes)\n    while swap != \"impossible\":\n        if swap == 0:\n            votes[1], votes[2] = votes[2], votes[1]\n        elif swap == n - 1:\n            votes[n - 2], votes[n - 1] = votes[n - 1], votes[n - 2]\n        else:\n            votes[swap], votes[swap + 1] = votes[swap + 1], votes[swap]\n        swap_count += 1\n        swap = find_swap(votes)\n\n    if count_points(votes)[0] > count_points(votes)[1]:\n        return swap_count\n    else:\n        return \"impossible\""
    },
    {
        "number": 3211,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def count_points(votes: list) -> tuple:\n        party1, party2 = 0, 0\n        for vote in votes:\n            if vote == 1:\n                party1 += 1\n            elif vote == 2:\n                party2 += 1\n        return party1, party2\n\n    def check_winner(points: tuple) -> bool:\n        party1, party2 = points\n        return party1 > party2\n\n    def min_swaps(votes: list, swaps: int) -> int:\n        n = len(votes)\n        min_swaps = n\n        for i in range(n - 1):\n            if votes[i] == 0 and votes[i + 1] == 0:\n                continue\n            if votes[i] == 0 or votes[i + 1] == 0:\n                votes[i], votes[i + 1] = votes[i + 1], votes[i]\n                points = count_points(votes)\n                if check_winner(points):\n                    min_swaps = min(min_swaps, swaps + 1)\n                swaps += 1\n                points = count_points(votes)\n                if check_winner(points):\n                    min_swaps = min(min_swaps, swaps + 1)\n                swaps -= 1\n                votes[i], votes[i + 1] = votes[i + 1], votes[i]\n        return min_swaps\n\n    n = int(stdin.readline().strip())\n    votes = [int(vote) for vote in stdin.readline().strip()]\n\n    if votes.count(0) == n or votes.count(1) == n or votes.count(2) == n:\n        return \"impossible\"\n\n    return str(min_swaps(votes, 0))"
    },
    {
        "number": 3212,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_position(x, y):\n        return 0 <= x <= 1000 and 0 <= y <= 1000\n\n    def is_safe_distance(snake_x, snake_y, distance, enter_x, enter_y, leave_x, leave_y):\n        return ((snake_x - enter_x) ** 2 + (snake_y - enter_y) ** 2 >= distance ** 2) and ((snake_x - leave_x) ** 2 + (snake_y - leave_y) ** 2 >= distance ** 2)\n\n    def find_safe_positions(snakes):\n        safe_positions = []\n        for enter_x in range(0, 1001):\n            for enter_y in range(1000, -1, -1):\n                for leave_x in range(1000, -1, -1):\n                    for leave_y in range(0, 1001):\n                        is_safe = True\n                        for snake in snakes:\n                            snake_x, snake_y, distance = snake\n                            if not is_safe_distance(snake_x, snake_y, distance, enter_x, enter_y, leave_x, leave_y):\n                                is_safe = False\n                                break\n                        if is_safe:\n                            safe_positions.append((enter_x, enter_y, leave_x, leave_y))\n        return safe_positions\n\n    lines = stdin.strip().split('\\n')\n    num_snakes = int(lines[0])\n    snakes = []\n    for i in range(1, num_snakes + 1):\n        snake_x, snake_y, distance = map(int, lines[i].split())\n        snakes.append((snake_x, snake_y, distance))\n\n    safe_positions = find_safe_positions(snakes)\n\n    if not safe_positions:\n        return \"Bill will be bitten.\"\n\n    most_northerly_position = max(safe_positions, key=lambda x: x[1])\n    enter_x, enter_y, leave_x, leave_y = most_northerly_position\n\n    return f\"Bill enters at ({enter_x:.2f}, {enter_y:.2f}) and leaves at ({leave_x:.2f}, {leave_y:.2f}).\" "
    },
    {
        "number": 3212,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_position(x, y, d):\n        return x >= d and x <= 1000 - d and y >= d and y <= 1000 - d\n\n    def find_safe_positions(n, snakes):\n        safe_positions = []\n        for snake in snakes:\n            x, y, d = snake\n            if is_valid_position(x, y, d):\n                safe_positions.append((x, y, d))\n        return safe_positions\n\n    def find_entrance_and_exit(n, safe_positions):\n        for snake1 in safe_positions:\n            for snake2 in safe_positions:\n                if snake1 != snake2:\n                    x1, y1, d1 = snake1\n                    x2, y2, d2 = snake2\n                    distance = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n                    if distance > d1 + d2:\n                        entrance_x = min(x1, x2)\n                        entrance_y = max(y1, y2)\n                        exit_x = max(x1, x2)\n                        exit_y = min(y1, y2)\n                        return (entrance_x, entrance_y), (exit_x, exit_y)\n        return None\n\n    n = int(stdin.readline())\n    snakes = [tuple(map(int, line.split())) for line in stdin]\n\n    safe_positions = find_safe_positions(n, snakes)\n    entrance_and_exit = find_entrance_and_exit(n, safe_positions)\n\n    if entrance_and_exit:\n        entrance, exit = entrance_and_exit\n        return f\"Bill enters at ({entrance[0]:.2f}, {entrance[1]:.2f}) and leaves at ({exit[0]:.2f}, {exit[1]:.2f}).\"\n    else:\n        return \"Bill will be bitten.\""
    },
    {
        "number": 3212,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(x1, y1, x2, y2):\n        for x, y, d in snakes:\n            if (x - x1) ** 2 + (y - y1) ** 2 < d ** 2:\n                return False\n            if (x - x2) ** 2 + (y - y2) ** 2 < d ** 2:\n                return False\n        return True\n\n    n, *snakes = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    snakes = snakes[1:]\n\n    for x1 in range(1000):\n        for y1 in range(1000):\n            for x2 in range(1000):\n                for y2 in range(1000):\n                    if is_safe(x1, y1, x2, y2):\n                        return f\"Bill enters at ({x1:.2f}, {y1:.2f}) and leaves at ({x2:.2f}, {y2:.2f}).\"\n\n    return \"Bill will be bitten.\""
    },
    {
        "number": 3212,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(x1, y1, x2, y2, snakes):\n        for snake in snakes:\n            if (snake[0] - x1) ** 2 + (snake[1] - y1) ** 2 <= snake[2] ** 2 and \\\n                    (snake[0] - x2) ** 2 + (snake[1] - y2) ** 2 <= snake[2] ** 2:\n                return False\n        return True\n\n    def dfs(x1, y1, x2, y2, snakes, visited):\n        if (x1, y1, x2, y2) in visited:\n            return visited[(x1, y1, x2, y2)]\n\n        if not is_safe(x1, y1, x2, y2, snakes):\n            visited[(x1, y1, x2, y2)] = False\n            return False\n\n        if x1 == 0 and y1 == 1000 and x2 == 1000 and y2 == 0:\n            return True\n\n        for i in range(x1 + 1, 1001):\n            for j in range(y1 - 1, -1, -1):\n                if is_safe(x1, y1, i, j, snakes) and dfs(i, j, x2, y2, snakes, visited):\n                    return True\n\n        for i in range(x1 - 1, -1, -1):\n            for j in range(y1 + 1, 1001):\n                if is_safe(x1, y1, i, j, snakes) and dfs(i, j, x2, y2, snakes, visited):\n                    return True\n\n        for i in range(x1 + 1, 1001):\n            for j in range(y1 + 1, 1001):\n                if is_safe(x1, y1, i, j, snakes) and dfs(i, j, x2, y2, snakes, visited):\n                    return True\n\n        for i in range(x1 - 1, -1, -1):\n            for j in range(y1 - 1, -1, -1):\n                if is_safe(x1, y1, i, j, snakes) and dfs(i, j, x2, y2, snakes, visited):\n                    return True\n\n        visited[(x1, y1, x2, y2)] = False\n        return False\n\n    n = int(stdin.readline().strip())\n    snakes = []\n    for _ in range(n):\n        x, y, d = map(int, stdin.readline().strip().split())\n        snakes.append((x, y, d))\n\n    for i in range(1001):\n        for j in range(1001):\n            if dfs(0, 1000, i, j, snakes, {}):\n                return f\"Bill enters at ({0.00:.2f}, {1000.00:.2f}) and leaves at ({i:.2f}, {j:.2f}).\"\n\n    return \"Bill will be bitten.\"\n"
    },
    {
        "number": 3212,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    input_data = [line.split() for line in stdin.split('\\n') if line]\n    n = int(input_data[0][0])\n    snakes = [(int(x), int(y), int(d)) for x, y, d in input_data[1:]]\n\n    min_y = 1001\n    max_y = -1\n\n    for x, y, d in snakes:\n        if x - d <= 0 and y - d <= 0:\n            min_y = min(min_y, y + d)\n            max_y = max(max_y, y - d)\n        elif x + d >= 1000 and y - d <= 0:\n            min_y = min(min_y, y + d)\n            max_y = max(max_y, y - d)\n        elif x - d <= 0 and y + d >= 1000:\n            min_y = min(min_y, y - d)\n            max_y = max(max_y, y + d)\n        elif x + d >= 1000 and y + d >= 1000:\n            min_y = min(min_y, y - d)\n            max_y = max(max_y, y + d)\n\n    if min_y > max_y:\n        return \"Bill will be bitten.\"\n\n    min_y = round(min_y, 2)\n    max_y = round(max_y, 2)\n\n    return f\"Bill enters at (0.00, {min_y}) and leaves at (1000.00, {max_y}).\" "
    },
    {
        "number": 3212,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_bitten(x1, y1, x2, y2, snakes):\n        for snake in snakes:\n            if (snake[2] ** 2) < ((snake[0] - x1) ** 2) + ((snake[1] - y1) ** 2):\n                return True\n            if (snake[2] ** 2) < ((snake[0] - x2) ** 2) + ((snake[1] - y2) ** 2):\n                return True\n        return False\n\n    def find_path(snakes):\n        for y in range(1000, -1, -1):\n            for x in range(0, 1001):\n                if not is_bitten(x, y, 1000 - x, 1000 - y, snakes):\n                    return x, y\n        return None, None\n\n    input_list = [line.strip().split() for line in stdin.split('\\n') if line.strip()]\n    n = int(input_list[0][0])\n    snakes = [(int(x), int(y), int(d)) for x, y, d in input_list[1:]]\n\n    enter_x, enter_y = find_path(snakes)\n    leave_x, leave_y = 1000 - enter_x, 1000 - enter_y\n\n    if enter_x is not None and leave_x is not None:\n        return f\"Bill enters at ({enter_x:.2f}, {enter_y:.2f}) and leaves at ({leave_x:.2f}, {leave_y:.2f}).\"\n    else:\n        return \"Bill will be bitten.\""
    },
    {
        "number": 3212,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_bitten(x, y, snakes):\n        for snake in snakes:\n            if distance(snake[0], snake[1], x, y) <= snake[2]:\n                return True\n        return False\n\n    n, lines = stdin.split(\"\\n\", 1)\n    n = int(n)\n    snakes = [list(map(int, line.split())) for line in lines.split(\"\\n\")[:n]]\n\n    for i in range(1000, -1, -1):\n        for j in range(1001):\n            if not is_bitten(j, i, snakes):\n                enter = f\"{j:.2f}\"\n                exit = f\"{i:.2f}\"\n                return f\"Bill enters at ({enter}, {1000 - enter}) and leaves at ({exit}, {1000 - exit}).\"\n    return \"Bill will be bitten.\""
    },
    {
        "number": 3212,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(x1, y1, x2, y2, snakes):\n        for x, y, d in snakes:\n            if ((x1 - x) ** 2 + (y1 - y) ** 2) ** 0.5 <= d:\n                return False\n            if ((x2 - x) ** 2 + (y2 - y) ** 2) ** 0.5 <= d:\n                return False\n        return True\n\n    def dfs(snakes, x1, y1, x2, y2):\n        if x1 > x2 or y1 > y2:\n            return False\n        if x1 == x2 and y1 == y2:\n            return True\n        for i in range(x1 + 1, x2 + 1):\n            for j in range(y1 + 1, y2 + 1):\n                if is_safe(i, j, x2, y2, snakes):\n                    if dfs(snakes, i, j, x2, y2):\n                        return True\n        return False\n\n    input_data = list(map(int, stdin.split()))\n    n = input_data[0]\n    snakes = [(input_data[i + 1], input_data[i + 2], input_data[i + 3]) for i in range(1, n + 1, 3)]\n\n    for y in range(1000, -1, -1):\n        for x in range(1001):\n            if is_safe(x, y, 1000, 0, snakes):\n                if dfs(snakes, x, y, 1000, 0):\n                    return f\"Bill enters at ({x:.2f}, {y:.2f}) and leaves at (1000.00, 0.00).\"\n    return \"Bill will be bitten.\""
    },
    {
        "number": 3212,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    snake_list = []\n    for i in range(1, n+1):\n        x, y, d = map(int, input_list[i].split())\n        snake_list.append((x, y, d))\n    \n    # Find the most northerly entrance and exit positions\n    entrance_x, entrance_y, exit_x, exit_y = 0, 1000, 1000, 0\n    for snake in snake_list:\n        x, y, d = snake\n        if x < entrance_x:\n            entrance_x = x - d\n        if x > exit_x:\n            exit_x = x + d\n        if y < entrance_y:\n            entrance_y = y - d\n        if y > exit_y:\n            exit_y = y + d\n    \n    # Check if Bill can complete the trip\n    for snake in snake_list:\n        x, y, d = snake\n        if (x - entrance_x) ** 2 + (y - entrance_y) ** 2 <= d ** 2:\n            return \"Bill will be bitten.\"\n        if (x - exit_x) ** 2 + (y - exit_y) ** 2 <= d ** 2:\n            return \"Bill will be bitten.\"\n    \n    # Return the entrance and exit coordinates\n    return f\"Bill enters at ({entrance_x:.2f}, {entrance_y:.2f}) and leaves at ({exit_x:.2f}, {exit_y:.2f}).\""
    },
    {
        "number": 3212,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(x1, y1, x2, y2, snakes):\n        for snake in snakes:\n            sx, sy, distance = snake\n            if abs(sx - x1) + abs(sy - y1) <= distance:\n                return False\n            if abs(sx - x2) + abs(sy - y2) <= distance:\n                return False\n        return True\n\n    def find_path(snakes):\n        for y in range(1000, -1, -1):\n            for x in range(0, 1001, 1):\n                if is_safe(x, y, 1000 - x, 1000 - y, snakes):\n                    return f\"Bill enters at ({x:.2f}, {y:.2f}) and leaves at ({1000 - x:.2f}, {1000 - y:.2f}).\"\n        return \"Bill will be bitten.\"\n\n    data = [list(map(int, line.split())) for line in stdin.split('\\n') if line]\n    n = data[0][0]\n    snakes = data[1:]\n    return find_path(snakes) "
    },
    {
        "number": 3213,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.readline().split())\n    spell = stdin.readline().strip()\n\n    max_power = 0\n    max_power_spell = \"\"\n\n    for i in range(2 ** M):\n        current_spell = \"\"\n        current_power = 1\n\n        for j in range(M):\n            if (i >> j) & 1 == 0:\n                if spell[j] == \"+\":\n                    current_power += 1\n                else:\n                    current_power *= 2\n            else:\n                current_spell += \"o\"\n\n        current_power %= 2 ** S\n        if current_power > max_power:\n            max_power = current_power\n            max_power_spell = current_spell\n\n    return max_power_spell"
    },
    {
        "number": 3213,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.readline().split())\n    spell = stdin.readline()\n\n    def power(p):\n        return p % (2 ** S)\n\n    def dp(spell, index, current_power, memo):\n        if index == len(spell):\n            return current_power, memo\n\n        if (index, current_power) in memo:\n            return memo[(index, current_power)]\n\n        if spell[index] == '+':\n            new_power = power(current_power + 1)\n            result, memo = dp(spell, index + 1, new_power, memo)\n        else:\n            new_power = power(current_power * 2)\n            without_op, memo = dp(spell, index + 1, new_power, memo)\n            with_op, memo = dp(spell + 'o', index + 1, current_power, memo)\n            result = max(without_op, with_op)\n\n        memo[(index, current_power)] = result\n        return result, memo\n\n    _, memo = dp(spell, 0, 1, {})\n    result = [c for c in spell]\n\n    for i in range(len(spell)):\n        if (i, 1) in memo and memo[(i, 1)][0] == memo[(i + 1, 1)][0]:\n            result[i] = 'o'\n\n    return ''.join(result)"
    },
    {
        "number": 3213,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.readline().split())\n    spell = stdin.readline().strip()\n    \n    def calculate_power(power, steps):\n        for step in steps:\n            if step == '+':\n                power += 1\n            elif step == 'x':\n                power *= 2\n            else:\n                continue\n            power %= (2 ** S)\n        return power\n    \n    no_ops = M - calculate_power(1, spell)\n    if no_ops < 0:\n        no_ops = 0\n    \n    for i in range(no_ops + 1):\n        for j in range(i + 1, no_ops + 1):\n            new_spell = list(spell)\n            for k in range(i):\n                new_spell[k] = 'o'\n            for k in range(i, j):\n                new_spell[k] = 'o'\n            for k in range(j, no_ops):\n                new_spell[k] = 'o'\n            \n            new_power = calculate_power(1, ''.join(new_spell))\n            if new_power > calculate_power(1, spell):\n                spell = new_spell\n    \n    return ''.join(spell)"
    },
    {
        "number": 3213,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.readline().strip().split())\n    steps = stdin.readline().strip()\n\n    # If there are no x's, we can't remove any steps\n    if 'x' not in steps:\n        return steps\n\n    # If there are no +'s, we can remove all steps\n    if '+' not in steps:\n        return 'o' * M\n\n    # Calculate the total power for each step\n    total_power = [1]\n    for step in steps:\n        if step == '+':\n            total_power.append(total_power[-1] + 1)\n        else:\n            total_power.append(total_power[-1] * 2)\n\n    # Calculate the maximum power that can be discharged at each step\n    max_power = [power // (2 ** S) for power in total_power]\n\n    # Calculate the maximum total power that can be obtained by removing some steps\n    max_total_power = max_power[-1]\n    for i in range(M - 1, -1, -1):\n        if steps[i] == '+':\n            max_total_power = max(max_total_power, max_power[i - 1] + max_power[i + 1])\n\n    # Calculate the minimum total power that can be obtained by removing some steps\n    min_total_power = 0\n    for i in range(M - 1, -1, -1):\n        if steps[i] == '+':\n            min_total_power = max(min_total_power, max_power[i - 1] + max_power[i + 1])\n        elif steps[i] == 'x':\n            min_total_power = max(min_total_power, max_power[i - 1] * 2)\n\n    # Find the optimal number of steps to remove\n    optimal_num_steps = 0\n    for i in range(M):\n        if steps[i] == '+':\n            if max_power[i] >= max_total_power or max_power[i] + max_power[i + 1] <= min_total_power:\n                optimal_num_steps += 1\n        elif steps[i] == 'x':\n            if max_power[i] * 2 <= min_total_power:\n                optimal_num_steps += 1\n\n    # Replace the optimal number of steps with o's\n    result = list(steps)\n    for i in range(M - 1, -1, -1):\n        if steps[i] == '+' and optimal_num_steps > 0:\n            result[i] = 'o'\n            optimal_num_steps -= 1\n        elif steps[i] == 'x' and optimal_num_steps > 0:\n            result[i] = 'o'\n            optimal_num_steps -= 1\n\n    return ''.join(result) "
    },
    {
        "number": 3213,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.readline().strip().split())\n    steps = stdin.readline().strip()\n\n    def power_discharged(steps: str) -> int:\n        power = 1\n        for step in steps:\n            if step == '+':\n                power += 1\n            else:\n                power *= 2\n            power %= 2 ** S\n        return power\n\n    no_ops = [0] * M\n    for i in range(M):\n        if steps[i] == '+':\n            no_ops[i] = 1\n        else:\n            break\n\n    max_power = power_discharged(steps)\n    max_steps = ''.join(['+' if no_op else steps[i] for i, no_op in enumerate(no_ops)])\n\n    for i in range(M - 1, -1, -1):\n        if steps[i] == '+':\n            no_ops[i] = 1\n        else:\n            break\n\n        new_steps = ''.join(['+' if no_op else steps[i] for i, no_op in enumerate(no_ops)])\n        new_power = power_discharged(new_steps)\n\n        if new_power > max_power:\n            max_power = new_power\n            max_steps = new_steps\n\n    return max_steps"
    },
    {
        "number": 3213,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.readline().split())\n    spell = stdin.readline().strip()\n    stack = []\n    for i in range(M):\n        if spell[i] == '+':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(i)\n        else:\n            stack.append(i)\n    no_ops = [spell[i] for i in stack]\n    return ''.join(no_ops)"
    },
    {
        "number": 3213,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split())\n    steps = input()\n\n    def calculate_power(step, power):\n        if step == '+':\n            return power + 1\n        else:\n            return power * 2\n\n    def calculate_discharge(power):\n        return power - (power // (2 ** S))\n\n    max_discharge = 0\n    max_discharge_steps = []\n    for i in range(2 ** M):\n        binary = format(i, '0{}b'.format(M))\n        power = 1\n        no_ops = 0\n        for j in range(M):\n            if binary[j] == '1':\n                power = calculate_power(steps[j], power)\n            else:\n                no_ops += 1\n        discharge = calculate_discharge(power)\n        if discharge > max_discharge:\n            max_discharge = discharge\n            max_discharge_steps = binary\n\n    result = ''\n    for i in range(M):\n        if max_discharge_steps[i] == '1':\n            result += steps[i]\n        else:\n            result += 'o'\n\n    return result"
    },
    {
        "number": 3213,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.readline().split())\n    spell = stdin.readline().strip()\n    power = 1\n    max_power = 0\n    result = []\n    \n    for step in spell:\n        if step == '+':\n            power += 1\n        elif step == 'x':\n            power *= 2\n        \n        discharged_power = power % (2 ** S)\n        if discharged_power > max_power:\n            max_power = discharged_power\n            result.append(step)\n        else:\n            result.append('o')\n    \n    return ''.join(result)"
    },
    {
        "number": 3213,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.readline().strip().split())\n    steps = stdin.readline().strip()\n    \n    # Initialize variables\n    power = 1\n    max_power = 0\n    max_step = -1\n    max_power_with_o = 0\n    max_step_with_o = -1\n    \n    # Iterate through steps\n    for i in range(M):\n        if steps[i] == '+':\n            power += 1\n        elif steps[i] == 'x':\n            power *= 2\n        \n        # Check if current step is a potential maximum\n        if power > max_power:\n            max_power = power\n            max_step = i\n        \n        # Check if current step is a potential maximum with no-op\n        power_with_o = max(power // 2, power - 2**S)\n        if power_with_o > max_power_with_o:\n            max_power_with_o = power_with_o\n            max_step_with_o = i\n    \n    # Replace the step with the highest power with no-op\n    if max_power_with_o > max_power:\n        steps = steps[:max_step_with_o] + 'o' + steps[max_step_with_o + 1:]\n    else:\n        steps = steps[:max_step] + 'o' + steps[max_step + 1:]\n    \n    return steps "
    },
    {
        "number": 3213,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.readline().split())\n    spell = stdin.readline().strip()\n    \n    def power_discharge(p):\n        return p // (2 ** S)\n\n    def solve(steps):\n        power = 1\n        max_power = 0\n        for step in steps:\n            if step == '+':\n                power += 1\n            elif step == 'x':\n                power *= 2\n            max_power = max(max_power, power_discharge(power))\n        return max_power\n\n    max_power = solve(spell)\n\n    for i in range(len(spell)):\n        if spell[i] == '+':\n            new_spell = spell[:i] + 'o' + spell[i+1:]\n            new_max_power = solve(new_spell)\n            if new_max_power >= max_power:\n                max_power = new_max_power\n                spell = new_spell\n\n        elif spell[i] == 'x':\n            new_spell = spell[:i] + 'o' + spell[i+1:]\n            new_max_power = solve(new_spell)\n            if new_max_power >= max_power:\n                max_power = new_max_power\n                spell = new_spell\n\n    return spell"
    },
    {
        "number": 3214,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = {}\n    lines = stdin.split('\\n')\n    for line in lines:\n        if line == \"***\":\n            break\n        for word in line.split():\n            core = ''.join(sorted(filter(str.isalpha, word.lower())))\n            if core in words:\n                words[core].add(word)\n            else:\n                words[core] = {word}\n    \n    result = []\n    for core in sorted(words.keys()):\n        similar_words = set()\n        for word in words[core]:\n            for i in range(len(word)):\n                if i > 0 and word[i-1].isalpha() and word[i].isalpha() and word[i].lower() != word[i-1].lower():\n                    similar_words.add(word[:i] + word[i+1:])\n                    similar_words.add(word[:i] + word[i].lower() + word[i+1:])\n                    similar_words.add(word[:i] + word[i].upper() + word[i+1:])\n                if i < len(word) - 1 and word[i+1].isalpha() and word[i].isalpha() and word[i].lower() != word[i+1].lower():\n                    similar_words.add(word[:i] + word[i+1] + word[i] + word[i+2:])\n            for j in range(len(word) - 1):\n                if word[j].isalpha() and word[j+1].isalpha() and word[j].lower() != word[j+1].lower():\n                    similar_words.add(word[:j] + word[j+1] + word[j] + word[j+2:])\n        if similar_words:\n            result.append(f\"{core}: {' '.join(sorted(similar_words))}\")\n    \n    if result:\n        return '\\n'.join(result) + '\\n'\n    else:\n        return \"***\\n\""
    },
    {
        "number": 3214,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    end_marker = \"***\"\n    text = []\n    for line in lines:\n        if line == end_marker:\n            break\n        text.append(line)\n\n    words = {}\n    for line in text:\n        line = line.lower()\n        for word in line.split():\n            core = \"\".join(filter(str.isalpha, word))\n            if core not in words:\n                words[core] = set()\n            for i in range(len(core)):\n                for j in range(i, len(core) + 1):\n                    if i > 0:\n                        words[core].add(core[:i] + core[i + 1:])  # Delete\n                    if j < len(core):\n                        for c in \"abcdefghijklmnopqrstuvwxyz\":\n                            if c != core[j]:\n                                words[core].add(core[:j] + c + core[j + 1:])  # Insert\n                            if j > 0:\n                                words[core].add(core[:j] + core[j + 1:] + c)  # Replace\n                    if j - i > 1:\n                        words[core].add(core[:i] + core[j:i:-1] + core[j + 1:])  # Transpose\n\n    output = []\n    for core, similars in sorted(words.items()):\n        output.append(core + \": \" + \" \".join(sorted(similars)))\n\n    if not output:\n        return \"***\"\n    return \"\\n\".join(output)"
    },
    {
        "number": 3214,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    words = {}\n    for line in stdin.split('\\n'):\n        if line == \"***\":\n            break\n        for word in line.split():\n            core = ''.join(sorted(c for c in word if c.isalpha())).lower()\n            if core not in words:\n                words[core] = set()\n            words[core].update(set(filter(lambda c: c != core, [\n                core[:i] + core[i+1:] for i in range(len(core))\n            ] + [\n                core[:i] + chr(ord(core[i]) + 1) + core[i+1:] for i in range(len(core)) if core[i].isalpha()\n            ] + [\n                core[:i] + core[i+1:] + core[i] for i in range(len(core))\n            ])))\n\n    output = []\n    for core in sorted(words.keys()):\n        similar_words = sorted(words[core])\n        if similar_words:\n            output.append(f\"{core}: {' '.join(similar_words)}\")\n    if not output:\n        output.append(\"***\")\n    return \"\\n\".join(output)"
    },
    {
        "number": 3214,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_similar(word1: str, word2: str) -> bool:\n        if abs(len(word1) - len(word2)) > 1:\n            return False\n\n        if len(word1) == len(word2):\n            diff_count = 0\n            for i in range(len(word1)):\n                if word1[i] != word2[i]:\n                    diff_count += 1\n                    if diff_count > 1:\n                        return False\n            return True\n\n        if len(word1) < len(word2):\n            word1, word2 = word2, word1\n\n        for i in range(len(word2)):\n            if word1[i] != word2[i]:\n                if i == 0 or i == len(word1) - 1:\n                    word1 = word1[:i] + word1[i + 1:]\n                else:\n                    word1 = word1[:i] + word1[i + 1:] + word1[i]\n                if word1 == word2:\n                    return True\n        return False\n\n    def core(word: str) -> str:\n        return ''.join(c for c in word if c.isalpha()).lower()\n\n    words = {}\n    for line in stdin.split('\\n'):\n        if line == \"***\":\n            break\n        for word in line.split():\n            core_word = core(word)\n            if core_word not in words:\n                words[core_word] = set()\n            words[core_word].add(word)\n\n    output = []\n    for core_word in sorted(words):\n        for word in sorted(words[core_word]):\n            core_word_similar = set()\n            for word_similar in words:\n                if core_word != word_similar and is_similar(core_word, word_similar):\n                    core_word_similar.add(word_similar)\n            if core_word_similar:\n                output.append(f\"{core_word}: {' '.join(sorted(core_word_similar))}\")\n\n    if not output:\n        output.append(\"***\")\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3214,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_similar(word1: str, word2: str) -> bool:\n        if abs(len(word1) - len(word2)) > 1:\n            return False\n\n        edits = 0\n        i, j = 0, 0\n\n        while i < len(word1) and j < len(word2):\n            if word1[i] != word2[j]:\n                edits += 1\n                if edits > 1:\n                    return False\n\n                if i < len(word1) - 1 and word1[i + 1] == word2[j]:\n                    i += 1\n                elif j < len(word2) - 1 and word1[i] == word2[j + 1]:\n                    j += 1\n\n            i += 1\n            j += 1\n\n        return True\n\n    def core(word: str) -> str:\n        return ''.join(filter(str.isalpha, word)).lower()\n\n    words = {}\n\n    for line in stdin.split('\\n'):\n        if line == '***':\n            break\n\n        for word in line.split():\n            core_word = core(word)\n            words.setdefault(core_word, set())\n            for w in words[core_word]:\n                if is_similar(core_word, core(w)):\n                    words[core_word].add(w)\n                    words[core(w)].add(core_word)\n\n            words[core_word].add(core_word)\n\n    return '\\n'.join(sorted(f'{core_word}: {\" \".join(sorted(set(similar_word for similar_word in similar_words if core_word != similar_word)))}'\n                             for core_word, similar_words in words.items() if len(similar_words) > 1)) or '***'"
    },
    {
        "number": 3214,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_core(word):\n        core = \"\"\n        for char in word:\n            if char.isalpha():\n                core += char.lower()\n        return core\n\n    def is_similar(word1, word2):\n        if abs(len(word1) - len(word2)) > 1:\n            return False\n\n        for i in range(min(len(word1), len(word2))):\n            if word1[i] != word2[i]:\n                if i == 0 or i == len(word1) - 1:\n                    return word1[i+1:] == word2[i:] or word1 == word2[i+1:]\n                elif word1[i+1:] == word2[i+1:]:\n                    return True\n                else:\n                    return False\n\n        return True\n\n    def process_paragraph(paragraph):\n        words = paragraph.split()\n        cores = {}\n\n        for word in words:\n            core = get_core(word)\n            if core not in cores:\n                cores[core] = []\n\n            for existing_core in cores[core]:\n                if is_similar(core, existing_core):\n                    cores[core].append(existing_core)\n                    cores[existing_core].append(core)\n\n        for core in sorted(cores):\n            for similar_core in sorted(set(cores[core])):\n                if similar_core != core:\n                    print(f\"{core}: {similar_core}\")\n\n    paragraphs = stdin.split(\"\\n\")\n    paragraphs = [paragraph.strip() for paragraph in paragraphs if paragraph.strip() != \"***\"]\n\n    for paragraph in paragraphs:\n        process_paragraph(paragraph)\n"
    },
    {
        "number": 3214,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_similar(word1: str, word2: str) -> bool:\n        if abs(len(word1) - len(word2)) > 1:\n            return False\n\n        edits = 0\n        i, j = 0, 0\n\n        while i < len(word1) and j < len(word2):\n            if word1[i] != word2[j]:\n                edits += 1\n                if edits > 1:\n                    return False\n\n                if i != j:\n                    if word1[i] == word2[i - 1] and word1[i - 1] == word2[i]:\n                        i += 1\n                        j += 1\n                    else:\n                        return False\n                elif word1[i] in word2 or word2[j] in word1:\n                    i += 1\n                    j += 1\n                else:\n                    return False\n            else:\n                i += 1\n                j += 1\n\n        return True\n\n    def core(word: str) -> str:\n        return \"\".join(c for c in word if c.isalpha()).lower()\n\n    lines = stdin.split(\"\\n\")\n    words = set()\n    similar_words = {}\n\n    for line in lines:\n        if line == \"***\":\n            break\n\n        for word in line.split():\n            core_word = core(word)\n            words.add(core_word)\n\n            for w in words:\n                if w != core_word and is_similar(core_word, w):\n                    if core_word not in similar_words:\n                        similar_words[core_word] = set()\n                    similar_words[core_word].add(w)\n\n    output = []\n    for core_word in sorted(similar_words):\n        output.append(f\"{core_word}: {' '.join(sorted(similar_words[core_word]))}\")\n\n    if not output:\n        output.append(\"***\")\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3214,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_core(word: str) -> str:\n        core = \"\"\n        for c in word:\n            if c.isalpha():\n                core += c.lower()\n        return core\n\n    def are_similar(word1: str, word2: str) -> bool:\n        if abs(len(word1) - len(word2)) > 1:\n            return False\n\n        if len(word1) == len(word2):\n            diff_count = 0\n            for i in range(len(word1)):\n                if word1[i] != word2[i]:\n                    diff_count += 1\n                    if diff_count > 1:\n                        return False\n            return True\n\n        if len(word1) < len(word2):\n            word1, word2 = word2, word1\n\n        if word1[:len(word2)] == word2 and word1[len(word2):] in \"abcdefghijklmnopqrstuvwxyz\":\n            return True\n\n        if word1[1:] == word2 and word1[0] in \"abcdefghijklmnopqrstuvwxyz\":\n            return True\n\n        for i in range(len(word1) - 1):\n            if word1[i:i+2] == word2[i+1:i+3] and word1[i+2:] == word2[i+3:] and word1[i] in \"abcdefghijklmnopqrstuvwxyz\" and word1[i+1] in \"abcdefghijklmnopqrstuvwxyz\":\n                return True\n\n        return False\n\n    def process_paragraph(paragraph: str) -> dict:\n        words = paragraph.split()\n        core_to_words = {}\n\n        for word in words:\n            core = get_core(word)\n            if core not in core_to_words:\n                core_to_words[core] = set()\n            core_to_words[core].add(word)\n\n        return core_to_words\n\n    def find_similar_words(core_to_words: dict) -> str:\n        output = []\n        for core, words in sorted(core_to_words.items()):\n            similar_cores = set()\n            for word in words:\n                for other_core, other_words in core_to_words.items():\n                    if core != other_core and any(are_similar(word, other_word) for other_word in other_words):\n                        similar_cores.add(other_core)\n            if similar_cores:\n                output.append(f\"{core}: \" + \" \".join(sorted(similar_cores)))\n\n        return \"\\n\".join(output) if output else \"***\"\n\n    paragraphs = []\n    paragraph = \"\"\n    for line in stdin.split(\"\\n\"):\n        if line.strip() == \"***\":\n            break\n        if line.strip():\n            paragraph += line\n        else:\n            paragraphs.append(paragraph)\n            paragraph = \"\"\n    if paragraph:\n        paragraphs.append(paragraph)\n\n    output = []\n    for paragraph in paragraphs:\n        core_to_words = process_paragraph(paragraph)\n        result = find_similar_words(core_to_words)\n        if result != \"***\":\n            output.append(result)\n\n    return \"\\n\".join(output) if output else \"***\" "
    },
    {
        "number": 3214,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_similar(word1, word2):\n        if len(word1) != len(word2):\n            return False\n        diff_count = 0\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                diff_count += 1\n                if diff_count > 1:\n                    return False\n        return diff_count == 1\n\n    def get_core(word):\n        return ''.join(c.lower() for c in word if c.isalpha())\n\n    def get_similar_cores(words):\n        cores = {}\n        for word in words:\n            core = get_core(word)\n            if core not in cores:\n                cores[core] = set()\n            cores[core].add(word)\n        return cores\n\n    lines = stdin.strip().split('\\n')\n    words = []\n    for line in lines:\n        words.extend(line.split())\n\n    similar_cores = get_similar_cores(words)\n\n    result = []\n    for core, similar_words in similar_cores.items():\n        if len(similar_words) > 1:\n            result.append(core + ': ' + ' '.join(sorted(get_core(w) for w in similar_words if get_core(w) != core)))\n\n    result.sort()\n    return '\\n'.join(result) if result else '***'"
    },
    {
        "number": 3214,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    text = \" \".join(lines)\n    words = text.split(\" \")\n    word_cores = []\n    for word in words:\n        core = ''.join(sorted(filter(str.isalpha, word.lower())))\n        if core not in word_cores:\n            word_cores.append(core)\n\n    typo_dict = {}\n    for core in word_cores:\n        typo_dict[core] = []\n        for other_core in word_cores:\n            if core == other_core:\n                continue\n            if len(core) != len(other_core):\n                continue\n            if abs(sum(1 for a, b in zip(core, other_core) if a != b)) <= 1:\n                typo_dict[core].append(other_core)\n\n    typo_dict = {k: sorted(set(v)) for k, v in typo_dict.items()}\n    typo_dict = {k: v for k, v in typo_dict.items() if v}\n    typo_list = sorted(typo_dict.items())\n\n    output = []\n    for core, typos in typo_list:\n        output.append(f\"{core}: {' '.join(typos)}\")\n\n    if not output:\n        return \"***\"\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3215,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    deck = list(map(int, stdin.split('\\n')[1].split()))\n    count = 0\n\n    for i in range(1, n + 1):\n        if deck[i - 1] != i:\n            count += 1\n            index = deck.index(i)\n            deck[i - 1], deck[index] = deck[index], deck[i - 1]\n\n    return str(count)"
    },
    {
        "number": 3215,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    deck = list(map(int, stdin.readline().strip().split()))\n\n    def find_cycle_len(start):\n        visited = [False] * n\n        cycle_len = 0\n        i = start\n        while not visited[i]:\n            visited[i] = True\n            i = deck[i] - 1\n            cycle_len += 1\n        return cycle_len\n\n    min_shuffle = n\n    for i in range(n):\n        if not deck[i] == i + 1:\n            cycle_len = find_cycle_len(i)\n            min_shuffle = min(min_shuffle, cycle_len)\n\n    return str(min_shuffle)"
    },
    {
        "number": 3215,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = [int(i) for i in stdin.split('\\n')[1].split()]\n    count = 0\n    sorted_cards = sorted(cards)\n    while cards != sorted_cards:\n        for i in range(1, n):\n            if cards[i] < cards[i - 1]:\n                cards[i], cards[i - 1] = cards[i - 1], cards[i]\n        count += 1\n    return str(count)"
    },
    {
        "number": 3215,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cards = [int(x) for x in stdin.readline().strip().split()]\n    min_shuffles = 0\n    for i in range(n):\n        if cards[i] != i + 1:\n            min_shuffles += 1\n    return str(min_shuffles)"
    },
    {
        "number": 3215,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    order = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_interleaved(order):\n        for i in range(n - 1):\n            if order[i] > order[i + 1]:\n                return False\n        return True\n\n    def count_shuffles(order):\n        shuffles = 0\n        while not is_interleaved(order):\n            order = [order[i] for i in range(0, n, 2)] + [order[i] for i in range(1, n, 2)]\n            shuffles += 1\n        return shuffles\n\n    return str(count_shuffles(order))"
    },
    {
        "number": 3215,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    deck = sorted(list(map(int, stdin.split(\"\\n\")[1].split())))\n    shuffles = 0\n\n    for i in range(n):\n        if deck[i] != i + 1:\n            shuffles += 1\n            break\n\n    if shuffles == 0:\n        return str(shuffles)\n\n    while shuffles < 2 * n - 1:\n        shuffled_deck = []\n        mid = n // 2\n        for i in range(mid):\n            shuffled_deck.append(deck[i])\n            shuffled_deck.append(deck[i + mid])\n        if n % 2 != 0:\n            shuffled_deck.append(deck[n - 1])\n\n        if shuffled_deck == deck:\n            shuffles += 1\n        else:\n            deck = shuffled_deck\n            shuffles += 2\n\n    return str(shuffles)"
    },
    {
        "number": 3215,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return True\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False\n\n    n, cards = map(int, stdin.split())\n    cards = list(map(int, cards))\n\n    if cards == sorted(cards):\n        return \"0\"\n\n    min_shuffles = float(\"inf\")\n    for i in range(1, n):\n        left, right = cards[:i], cards[i:]\n        if left == sorted(left) and right == sorted(right):\n            min_shuffles = min(min_shuffles, 1)\n        else:\n            sorted_cards = sorted(cards)\n            for j in range(i + 1, n):\n                if left == sorted(left) and right == sorted(right) and binary_search(sorted_cards, cards[j]):\n                    min_shuffles = min(min_shuffles, 2)\n                    break\n\n    return str(min_shuffles) if min_shuffles != float(\"inf\") else \"-1\""
    },
    {
        "number": 3215,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = list(map(int, stdin.split('\\n')[1].split()))\n    shuffles = 0\n\n    for i in range(n - 1):\n        if cards[i] == i + 1:\n            continue\n        else:\n            shuffles += 1\n            j = cards.index(i + 1)\n            cards[i], cards[j] = cards[j], cards[i]\n\n    return str(shuffles)"
    },
    {
        "number": 3215,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, ordering = stdin.split('\\n')\n    n = int(n)\n    ordering = list(map(int, ordering.split(' ')))\n    count = 0\n\n    def is_sorted(arr):\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i - 1]:\n                return False\n        return True\n\n    while not is_sorted(ordering):\n        mid = n // 2\n        left = ordering[:mid]\n        right = ordering[mid:]\n        new_ordering = []\n        for i in range(mid):\n            new_ordering.append(left[i])\n            new_ordering.append(right[i])\n        if len(left) > len(right):\n            new_ordering.append(left[-1])\n        elif len(left) < len(right):\n            new_ordering.append(right[-1])\n        ordering = new_ordering\n        count += 1\n\n    return str(count)"
    },
    {
        "number": 3215,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    cards = list(map(int, stdin.split(\"\\n\")[1].split(\" \")))\n\n    shuffles = 0\n    for i in range(n - 1):\n        if cards[i] != i + 1:\n            shuffles += 1\n            j = i + 1\n            while j < n and cards[j] != j + shuffles:\n                j += 1\n            cards[i], cards[j] = cards[j], cards[i]\n\n    return str(shuffles)\n"
    },
    {
        "number": 3216,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    decimal_part = input_list[0]\n    repeating_digits = int(input_list[1])\n    \n    decimal_digits = decimal_part.split('.')[1]\n    non_repeating_digits = decimal_digits[:-repeating_digits]\n    repeating_digits_str = decimal_digits[-repeating_digits:]\n    \n    numerator = int(non_repeating_digits + repeating_digits_str)\n    denominator = 10 ** len(repeating_digits_str) - 1\n    \n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    gcd_value = gcd(numerator, denominator)\n    reduced_numerator = numerator // gcd_value\n    reduced_denominator = denominator // gcd_value\n    \n    return f\"{reduced_numerator}/{reduced_denominator}\""
    },
    {
        "number": 3216,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split(\" \")\n    decimal_part = input_list[0]\n    repeating_length = int(input_list[1])\n\n    decimal_digits = len(decimal_part.split(\".\")[1])\n    repeating_part = decimal_part.split(\".\")[1][-repeating_length:]\n\n    numerator = int(repeating_part + \"0\" * decimal_digits)\n    denominator = 10 ** decimal_digits - (10 ** (decimal_digits - repeating_length))\n\n    gcd_value = gcd(numerator, denominator)\n    reduced_numerator = numerator // gcd_value\n    reduced_denominator = denominator // gcd_value\n\n    return f\"{reduced_numerator}/{reduced_denominator}\"\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    decimal_part = input_list[0]\n    repeat_count = int(input_list[1])\n\n    decimal_digits = decimal_part.split('.')[1]\n    repeating_digits = decimal_digits[-repeat_count:]\n\n    numerator = int(repeating_digits + decimal_digits.replace('.' + repeating_digits, ''))\n    denominator = 10 ** (len(decimal_digits) - repeat_count)\n\n    gcd_value = gcd(numerator, denominator)\n    reduced_numerator = numerator // gcd_value\n    reduced_denominator = denominator // gcd_value\n\n    return f\"{reduced_numerator}/{reduced_denominator}\"\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_str, repeating_digits = stdin.split()\n    repeating_digits = int(repeating_digits)\n    \n    numerator = int(input_str.replace(\".\", \"\"))\n    denominator = 10 ** len(input_str.split(\".\")[1])\n    \n    while repeating_digits > 0:\n        numerator *= 10\n        repeating_digits -= 1\n    \n    numerator += denominator\n    \n    gcd = find_gcd(numerator, denominator)\n    numerator //= gcd\n    denominator //= gcd\n    \n    return f\"{numerator}/{denominator}\"\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_str, repeat_count = stdin.split()\n    repeat_count = int(repeat_count)\n    decimal_part = input_str.split('.')[1]\n\n    # Calculate the repeating part\n    repeating_part = decimal_part[-repeat_count:]\n    repeating_length = len(repeating_part)\n\n    # Calculate the non-repeating part\n    non_repeating_part = decimal_part[:-repeating_length]\n\n    # Calculate the integer parts\n    integer_part_1 = int(input_str.split('.')[0]) * 10 ** repeating_length\n    integer_part_2 = int(non_repeating_part + repeating_part)\n\n    # Calculate the fraction\n    numerator = integer_part_1 + integer_part_2\n    denominator = 10 ** repeating_length - 1\n\n    # Simplify the fraction\n    gcd_value = gcd(numerator, denominator)\n    numerator //= gcd_value\n    denominator //= gcd_value\n\n    return f\"{numerator}/{denominator}\"\n\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_str, repeat_count = map(str, stdin.split())\n    integer_part = int(input_str.split('.')[0]) if '.' in input_str else 0\n    fractional_part = input_str.split('.')[1]\n    repeating_part = fractional_part[-repeat_count:]\n    non_repeating_part = fractional_part[:-repeat_count]\n\n    numerator = integer_part * (10 ** repeat_count) + int(repeating_part)\n    denominator = 10 ** repeat_count - (10 ** repeat_count - int(repeating_part))\n\n    if non_repeating_part:\n        numerator += int(non_repeating_part) * (denominator // int(repeating_part))\n\n    numerator, denominator = reduce_fraction(numerator, denominator)\n\n    return f\"{numerator}/{denominator}\"\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_str, repeat_count = stdin.split()\n    decimal_part, repeat_part = input_str.split(\".\")\n    decimal_part = int(decimal_part) if decimal_part else 0\n    repeat_part = int(repeat_part)\n    non_repeat_part = int(str(repeat_part)[:-repeat_count])\n    numerator = (decimal_part * (10 ** repeat_count)) + repeat_part + non_repeat_part\n    denominator = 10 ** len(str(repeat_part))\n    gcd_val = gcd(numerator, denominator)\n    numerator //= gcd_val\n    denominator //= gcd_val\n    return f\"{numerator}/{denominator}\"\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str, repeat_count = stdin.split()\n    decimal_part = input_str.split('.')[1]\n    integer_part = int(input_str.split('.')[0])\n    repeating_part = decimal_part[-repeat_count:]\n    non_repeating_part = decimal_part[:-repeat_count]\n    \n    numerator = int(repeating_part)\n    denominator = 10 ** len(repeating_part)\n    \n    for digit in reversed(non_repeating_part):\n        numerator = numerator * 10 + int(digit)\n        denominator *= 10\n    \n    if integer_part != 0:\n        numerator = numerator * 10 + integer_part\n        denominator *= 10\n        \n    gcd = math.gcd(numerator, denominator)\n    numerator //= gcd\n    denominator //= gcd\n    \n    return f\"{numerator}/{denominator}\""
    },
    {
        "number": 3216,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_str, repeat_count = stdin.split()\n    repeat_count = int(repeat_count)\n    integer_part, decimal_part = input_str.split('.')\n    repeating_part = decimal_part[:repeat_count]\n    nonrepeating_part = decimal_part[repeat_count:]\n\n    numerator = int(repeating_part)\n    denominator = 10 ** len(repeating_part) - int(nonrepeating_part)\n    gcd = find_gcd(numerator, denominator)\n    reduced_numerator = numerator // gcd\n    reduced_denominator = denominator // gcd\n\n    if reduced_denominator == 1:\n        return f\"{reduced_numerator}\"\n    else:\n        return f\"{reduced_numerator}/{reduced_denominator}\"\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_str, repeat_count = stdin.split(\" \")\n    input_str = input_str.replace(\".\", \"\")\n    non_repeating_part = input_str[:-repeat_count]\n    repeating_part = input_str[-repeat_count:]\n    repeating_digits = len(repeating_part)\n    non_repeating_digits = len(non_repeating_part)\n\n    if non_repeating_digits == 0:\n        non_repeating_part = \"1\"\n\n    non_repeating_part = int(non_repeating_part)\n    repeating_part = int(repeating_part)\n\n    denominator = (10 ** repeating_digits) - (10 ** (repeating_digits - repeating_digits)) + (repeating_part - repeating_part // 10 ** (repeating_digits - 1) * 10 ** (repeating_digits - 1))\n    numerator = (non_repeating_part * (10 ** repeating_digits)) + repeating_part - repeating_part // 10 ** (repeating_digits - 1) * 10 ** (repeating_digits - 1)\n\n    gcd = math.gcd(numerator, denominator)\n    numerator //= gcd\n    denominator //= gcd\n\n    return f\"{numerator}/{denominator}\""
    },
    {
        "number": 3217,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    defective_cells = set()\n    for _ in range(n):\n        x, y, z = map(int, stdin.readline().split())\n        defective_cells.add((x, y, z))\n\n    min_panels = 0\n    for x in range(10):\n        for y in range(10):\n            for z in range(10):\n                if any((x+i, y+j, z+k) in defective_cells for i in range(2) for j in range(2) for k in range(2)):\n                    min_panels += 1\n\n    return str(min_panels)"
    },
    {
        "number": 3217,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x: int, y: int, z: int) -> bool:\n        return 0 <= x <= 9 and 0 <= y <= 9 and 0 <= z <= 9\n\n    n = int(stdin.readline())\n    defective_cells = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def bfs(start_x: int, start_y: int, start_z: int) -> int:\n        queue = [(start_x, start_y, start_z)]\n        visited = set()\n\n        while queue:\n            x, y, z = queue.pop(0)\n            if (x, y, z) in visited:\n                continue\n            visited.add((x, y, z))\n\n            for dx, dy, dz in [(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1)]:\n                new_x, new_y, new_z = x + dx, y + dy, z + dz\n                if is_valid(new_x, new_y, new_z) and (new_x, new_y, new_z) not in visited:\n                    queue.append((new_x, new_y, new_z))\n\n        return len(visited)\n\n    min_panels = float(\"inf\")\n    for cell in defective_cells:\n        min_panels = min(min_panels, bfs(*cell))\n\n    return str(min_panels)"
    },
    {
        "number": 3217,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_coord(coord: tuple) -> bool:\n        return 0 <= coord[0] <= 9 and 0 <= coord[1] <= 9 and 0 <= coord[2] <= 9\n\n    def get_panel_count(defective_cells: set) -> int:\n        panel_count = 0\n        for defective_cell in defective_cells:\n            for dx, dy, dz in [(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1)]:\n                neighbor_coord = (defective_cell[0] + dx, defective_cell[1] + dy, defective_cell[2] + dz)\n                if is_valid_coord(neighbor_coord) and neighbor_coord not in defective_cells:\n                    panel_count += 1\n        return panel_count\n\n    n = int(stdin.readline().strip())\n    defective_cells = set()\n    for _ in range(n):\n        x, y, z = map(int, stdin.readline().strip().split())\n        defective_cells.add((x, y, z))\n\n    return str(get_panel_count(defective_cells))"
    },
    {
        "number": 3217,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num_defective_cells = int(stdin.readline().strip())\n    defective_cells = []\n    for _ in range(num_defective_cells):\n        defective_cells.append(tuple(map(int, stdin.readline().strip().split())))\n\n    # Find the boundaries of the enclosure\n    min_x = min(cell[0] for cell in defective_cells)\n    max_x = max(cell[0] for cell in defective_cells)\n    min_y = min(cell[1] for cell in defective_cells)\n    max_y = max(cell[1] for cell in defective_cells)\n    min_z = min(cell[2] for cell in defective_cells)\n    max_z = max(cell[2] for cell in defective_cells)\n\n    # Calculate the number of panels required\n    num_panels = 0\n    for x in range(min_x, max_x + 1):\n        for y in range(min_y, max_y + 1):\n            for z in range(min_z, max_z + 1):\n                if (x, y, z) in defective_cells or x in (min_x, max_x) or y in (min_y, max_y) or z in (min_z, max_z):\n                    num_panels += 1\n\n    return str(num_panels)"
    },
    {
        "number": 3217,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    defective_cells = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    min_panels = 0\n    for x, y, z in defective_cells:\n        min_panels += 6 - (x != 0) - (x != 9) - (y != 0) - (y != 9) - (z != 0) - (z != 9)\n\n    return str(min_panels) "
    },
    {
        "number": 3217,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    defective_cells = list(map(lambda x: tuple(map(int, x.split(' '))), stdin.split('\\n')[1:]))\n    unique_defective_cells = list(set(defective_cells))\n    \n    min_panels = 0\n    \n    for cell in unique_defective_cells:\n        x, y, z = cell\n        min_panels += 6\n        \n        if x == 0:\n            min_panels += 2\n        if x == 9:\n            min_panels += 2\n        if y == 0:\n            min_panels += 2\n        if y == 9:\n            min_panels += 2\n        if z == 0:\n            min_panels += 2\n        if z == 9:\n            min_panels += 2\n            \n    return str(min_panels) "
    },
    {
        "number": 3217,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    defective_cells = []\n    for _ in range(n):\n        defective_cells.append(tuple(map(int, stdin.readline().strip().split())))\n\n    # Calculate the number of panels required\n    max_x, max_y, max_z = 0, 0, 0\n    for cell in defective_cells:\n        max_x = max(max_x, cell[0])\n        max_y = max(max_y, cell[1])\n        max_z = max(max_z, cell[2])\n\n    # Add panels on the edges\n    num_panels = 2 * (max_x + max_y + max_z)\n\n    # Add panels for the interior\n    for cell in defective_cells:\n        num_panels += 6\n\n    return str(num_panels)"
    },
    {
        "number": 3217,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_neighbor(x, y, z):\n        return 0 <= x <= 9 and 0 <= y <= 9 and 0 <= z <= 9\n\n    def get_neighbors(x, y, z):\n        neighbors = []\n        for dx, dy, dz in [(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1)]:\n            new_x, new_y, new_z = x + dx, y + dy, z + dz\n            if is_valid_neighbor(new_x, new_y, new_z):\n                neighbors.append((new_x, new_y, new_z))\n        return neighbors\n\n    def bfs(start_x, start_y, start_z):\n        queue = [(start_x, start_y, start_z)]\n        visited = set()\n        while queue:\n            x, y, z = queue.pop(0)\n            if (x, y, z) not in visited:\n                visited.add((x, y, z))\n                for neighbor in get_neighbors(x, y, z):\n                    queue.append(neighbor)\n        return visited\n\n    n = int(stdin.readline().strip())\n    defective_cells = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    enclosures = set()\n    for cell in defective_cells:\n        enclosures.update(bfs(*cell))\n\n    return str(len(enclosures))"
    },
    {
        "number": 3217,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    defective_cells = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_inside(x: int, y: int, z: int) -> bool:\n        return 0 <= x <= 9 and 0 <= y <= 9 and 0 <= z <= 9\n\n    def count_panels(x: int, y: int, z: int) -> int:\n        panels = 0\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                for dz in range(-1, 2):\n                    if is_inside(x + dx, y + dy, z + dz):\n                        panels += 1\n        return panels\n\n    min_panels = float('inf')\n    for cell in defective_cells:\n        min_panels = min(min_panels, count_panels(*cell))\n\n    return str(min_panels)"
    },
    {
        "number": 3217,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    defective_cells = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_defective(x, y, z):\n        return (x, y, z) in defective_cells\n\n    def is_contained(x, y, z):\n        if x < 9 and is_defective(x + 1, y, z):\n            return True\n        if y < 9 and is_defective(x, y + 1, z):\n            return True\n        if z < 9 and is_defective(x, y, z + 1):\n            return True\n        return False\n\n    count = 0\n    for x in range(10):\n        for y in range(10):\n            for z in range(10):\n                if is_defective(x, y, z) or is_contained(x, y, z):\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 3218,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = [list(map(int, line.strip().split())) for line in stdin]\n    \n    def is_valid(coloring):\n        loops = []\n        for i in range(n):\n            for j in range(n + i % 2):\n                if a[i][j] != -1 and coloring[i][j] != a[i][j]:\n                    return False\n                if a[i][j] != -1 and coloring[i][j] == a[i][j]:\n                    if i % 2 == 1:\n                        loops.append([(i, j), (i, j + 1)])\n                    else:\n                        loops.append([(i, j), (i, j + 1), (i + 1, j)])\n                        loops.append([(i, j), (i + 1, j), (i + 1, j + 1)])\n        for i in range(1, n):\n            for j in range(n + i % 2):\n                if a[i][j] != -1 and coloring[i][j] != a[i][j]:\n                    return False\n                if a[i][j] != -1 and coloring[i][j] == a[i][j]:\n                    if i % 2 == 1:\n                        loops.append([(i, j), (i, j + 1)])\n                    else:\n                        loops.append([(i, j), (i, j + 1), (i + 1, j)])\n                        loops.append([(i, j), (i + 1, j), (i + 1, j + 1)])\n        for i in range(n):\n            for j in range(n + i % 2):\n                if a[i][j] != -1 and coloring[i][j] != a[i][j]:\n                    return False\n                if a[i][j] != -1 and coloring[i][j] == a[i][j]:\n                    if i % 2 == 1:\n                        loops.append([(i, j), (i, j + 1)])\n                    else:\n                        loops.append([(i, j), (i, j + 1), (i + 1, j)])\n                        loops.append([(i, j), (i + 1, j), (i + 1, j + 1)])\n        for loop in loops:\n            for i in range(len(loop) - 1):\n                for j in range(i + 1, len(loop)):\n                    if loop[i][0] == loop[j][0] and loop[i][1] == loop[j][1]:\n                        return False\n        return True\n    \n    def backtrack(coloring, k):\n        if k == n * (n + 1) // 2:\n            if is_valid(coloring):\n                return 1\n            else:\n                return 0\n        i, j = divmod(k, n + n % 2)\n        for color in range(1, 7):\n            if a[i][j] == -1 or a[i][j] == color:\n                coloring[i][j] = color\n                if i % 2 == 1:\n                    coloring[i][j + 1] = color\n                else:\n                    if j + 1 < n + i % 2:\n                        coloring[i][j + 1] = color\n                    if j + 2 < n + i % 2:\n                        coloring[i + 1][j + 1] = color\n                    if j + 2 < n + i % 2:\n                        coloring[i + 1][j + 2] = color\n                count = backtrack(coloring, k + 1)\n                if count == 0:\n                    coloring[i][j] = -1\n                    if i % 2 == 1:\n                        coloring[i][j + 1] = -1\n                    else:\n                        if j + 1 < n + i % 2:\n                            coloring[i][j + 1] = -1"
    },
    {
        "number": 3218,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_valid(a):\n        for i in range(n):\n            for j in range(n - i % 2):\n                if a[i][j] != -1 and a[i][j] != sum(1 for dx, dy in [(-1, 0), (1, 0), (-1, -1), (1, 1), (-1, 1), (1, -1)] if 0 <= i + dx < n and 0 <= j + dy < n - i % 2 and a[i + dx][j + dy] == -1):\n                    return False\n        return True\n\n    def dfs(i, j, color):\n        if not (0 <= i < n and 0 <= j < n - i % 2):\n            return 0\n        if a[i][j] == -1 or a[i][j] == color:\n            return dfs(i + 1, j, color) + dfs(i - 1, j, color) + dfs(i, j + 1, color) + dfs(i, j - 1, color)\n        result = 0\n        for c in range(1, 7):\n            if c != a[i][j]:\n                a[i][j] = c\n                result += dfs(i + 1, j, color + 1) + dfs(i - 1, j, color + 1) + dfs(i, j + 1, color + 1) + dfs(i, j - 1, color + 1)\n                a[i][j] = -1\n        return result\n\n    if is_valid(a):\n        return dfs(0, 0, 0)\n    else:\n        return 0"
    },
    {
        "number": 3218,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = [[int(x) for x in line.strip().split()] for line in stdin]\n\n    def is_valid(coloring):\n        for i in range(n):\n            for j in range(n + i % 2):\n                if a[i][j] != -1 and a[i][j] != coloring[i][j]:\n                    return False\n        return True\n\n    def has_valid_loops(coloring):\n        def dfs(i, j, visited):\n            if (i, j) in visited or coloring[i][j] == 0:\n                return False\n            visited.add((i, j))\n            if i % 2 == 0:\n                if j > 0 and dfs(i, j - 1, visited):\n                    return True\n                if j < n - 1 and dfs(i, j + 1, visited):\n                    return True\n                if i > 0 and dfs(i - 1, j, visited):\n                    return True\n                if i < n - 1 and dfs(i + 1, j, visited):\n                    return True\n            else:\n                if j > 0 and dfs(i, j - 1, visited):\n                    return True\n                if j < n - 1 and dfs(i, j + 1, visited):\n                    return True\n                if i > 0 and dfs(i - 1, j, visited):\n                    return True\n                if i < n - 1 and dfs(i + 1, j, visited):\n                    return True\n                if i > 0 and j > 0 and dfs(i - 1, j - 1, visited):\n                    return True\n                if i > 0 and j < n - 1 and dfs(i - 1, j + 1, visited):\n                    return True\n            visited.remove((i, j))\n            return False\n\n        for i in range(n):\n            for j in range(n + i % 2):\n                if coloring[i][j] > 0 and not dfs(i, j, set()):\n                    return False\n        return True\n\n    def count_colorings(coloring, remaining_colors, i, j):\n        if i == n and j == 0:\n            return int(is_valid(coloring) and has_valid_loops(coloring))\n\n        if i >= n or j >= n + i % 2:\n            return 0\n\n        count = 0\n        if remaining_colors > 0:\n            coloring[i][j] = remaining_colors\n            count += count_colorings(coloring, remaining_colors - 1, i + (j + 1) // n, j + (j + 1) % n)\n            coloring[i][j] = -1\n\n        count += count_colorings(coloring, remaining_colors, i, j + 1)\n        return count\n\n    coloring = [[-1] * (n + i % 2) for i in range(n)]\n    return str(count_colorings(coloring, 6, 0, 0))\n"
    },
    {
        "number": 3218,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n', 1)[0])\n    a = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_valid(a, loops):\n        for loop in loops:\n            if len(loop) < 3:\n                return False\n        for i in range(n):\n            for j in range(n if i % 2 == 0 else n - 1):\n                if a[i][j] != -1 and a[i][j] != len(a[i][j]):\n                    return False\n        return True\n\n    def dfs(i, j, color, visited, a, loops):\n        if (i, j) in visited:\n            return\n        visited.add((i, j))\n        if color < a[i][j]:\n            dfs(i, j, color + 1, visited, a, loops)\n        if color == a[i][j]:\n            loops[-1].append((i, j))\n            dfs(i, j, color + 1, visited, a, loops)\n        if color > a[i][j]:\n            loops.append([(i, j)])\n            dfs(i, j, 1, visited, a, loops)\n\n    def count_colorings(n, a):\n        colorings = 0\n        for color in range(1, 7):\n            for i in range(n):\n                for j in range(n if i % 2 == 0 else n - 1):\n                    if a[i][j] == color:\n                        loops = []\n                        visited = set()\n                        dfs(i, j, 1, visited, a, loops)\n                        if is_valid(a, loops):\n                            colorings += 1\n        return colorings\n\n    return str(count_colorings(n, a))"
    },
    {
        "number": 3218,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_valid_coloring(a: List[List[int]]) -> bool:\n        for i in range(n):\n            for j in range(n - i % 2):\n                if a[i][j] != -1 and a[i][j] != sum(1 for e in hex_neighbors(i, j) if a[e[0]][e[1]] == -1):\n                    return False\n        return True\n\n    def hex_neighbors(i: int, j: int) -> List[Tuple[int, int]]:\n        neighbors = []\n        if i % 2 == 1:\n            if j > 0:\n                neighbors.append((i, j - 1))\n            if j < n - 1:\n                neighbors.append((i, j + 1))\n            if i > 0:\n                neighbors.append((i - 1, j))\n                if j > 0:\n                    neighbors.append((i - 1, j - 1))\n                if j < n - 1:\n                    neighbors.append((i - 1, j + 1))\n            if i < n - 1:\n                neighbors.append((i + 1, j))\n                if j > 0:\n                    neighbors.append((i + 1, j - 1))\n                if j < n - 1:\n                    neighbors.append((i + 1, j + 1))\n        else:\n            if i > 0:\n                neighbors.append((i - 1, j))\n            if i < n - 1:\n                neighbors.append((i + 1, j))\n            if j > 0:\n                neighbors.append((i, j - 1))\n                if i > 0:\n                    neighbors.append((i - 1, j - 1))\n                if i < n - 1:\n                    neighbors.append((i + 1, j - 1))\n            if j < n - 1:\n                neighbors.append((i, j + 1))\n                if i > 0:\n                    neighbors.append((i - 1, j + 1))\n                if i < n - 1:\n                    neighbors.append((i + 1, j + 1))\n        return neighbors\n\n    def count_valid_colorings(a: List[List[int]]) -> int:\n        if not is_valid_coloring(a):\n            return 0\n        if n == 1:\n            return 1\n        if n == 3:\n            return 2\n        if n % 2 == 1 and a[n // 2][(n - 1) // 2] != -1 or n % 2 == 0 and a[n // 2][n // 2] != -1:\n            return 0\n        return 1\n\n    return str(count_valid_colorings(a))"
    },
    {
        "number": 3218,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_coloring(a, n):\n        def is_valid_color(i, j):\n            if a[i][j] == -1:\n                return True\n            count = 0\n            if j > 0 and a[i][j - 1] != -1:\n                count += 1\n            if j < n and a[i][j + 1] != -1:\n                count += 1\n            if i % 2 == 0 and i > 0 and a[i - 1][j] != -1:\n                count += 1\n            if i % 2 == 1 and i < n - 1 and a[i + 1][j] != -1:\n                count += 1\n            if i % 2 == 0 and j > 0 and i > 0 and a[i - 1][j - 1] != -1:\n                count += 1\n            if i % 2 == 1 and j < n - 1 and i < n - 1 and a[i + 1][j + 1] != -1:\n                count += 1\n            if i % 2 == 0 and j < n - 1 and i > 0 and a[i - 1][j + 1] != -1:\n                count += 1\n            if i % 2 == 1 and j > 0 and i < n - 1 and a[i + 1][j - 1] != -1:\n                count += 1\n            return count == a[i][j]\n\n        for i in range(n):\n            for j in range(n if i % 2 == 1 else n - 1):\n                if not is_valid_color(i, j):\n                    return False\n        return True\n\n    n, a = int(stdin.readline().strip()), []\n    for i in range(n):\n        a.append(list(map(int, stdin.readline().strip().split())))\n\n    count = 0\n    for i in range(6 ** (n * (n if n % 2 == 1 else n - 1))):\n        b = [[-1] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n if i % 2 == 1 else n - 1):\n                b[i][j] = a[i][j]\n        base = n * (n if n % 2 == 1 else n - 1)\n        for k in range(base):\n            i, j = k // (n if n % 2 == 1 else n - 1), k % (n if n % 2 == 1 else n - 1)\n            if i % 2 == 0:\n                j = n - 1 - j if j < n - 1 else -1\n            if b[i][j] == -1:\n                for color in range(6):\n                    b[i][j] = color\n                    if is_valid_coloring(b, n):\n                        count += 1\n                    b[i][j] = -1\n                break\n    return str(count)"
    },
    {
        "number": 3218,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_coloring(a, n):\n        for i in range(n):\n            for j in range(n - i % 2):\n                if a[i][j] != -1 and a[i][j] != sum(\n                    [\n                        a[i + di][j + dj] == -1\n                        for di, dj in [(-1, -1), (-1, 1), (1, -1), (1, 1)]\n                    ]\n                ):\n                    return False\n        return True\n\n    n = int(stdin.readline())\n    a = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    valid_colorings = 0\n    for color in range(7):\n        for i in range(n):\n            for j in range(n - i % 2):\n                if a[i][j] == -1:\n                    a[i][j] = color\n                    if is_valid_coloring(a, n):\n                        valid_colorings += 1\n                    a[i][j] = -1\n\n    return str(valid_colorings)"
    },
    {
        "number": 3218,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_coloring(coloring: dict) -> bool:\n        for (i, j), color_count in coloring.items():\n            if color_count != -1 and color_count != 0 and color_count != 2:\n                return False\n        return True\n\n    def count_valid_colorings(coloring: dict, i: int, j: int, color: int) -> int:\n        if color == 3:\n            return 1 if is_valid_coloring(coloring) else 0\n\n        count = 0\n        if i < n and j < n:\n            coloring[i, j] = color\n            count += count_valid_colorings(coloring, i + 1, j, color + 1)\n            count += count_valid_colorings(coloring, i, j + 1, color + 1)\n            coloring.pop((i, j))\n\n        return count\n\n    n = int(stdin.readline())\n    a = {}\n    for i in range(1, n + 1):\n        line = stdin.readline().strip()\n        for j, num in enumerate(line.split()):\n            a[i, j + 1] = int(num)\n\n    total_count = 0\n    for i in range(1, n + 1, 2):\n        for j in range(1, n + 1):\n            if a[i, j] != -1:\n                coloring = {(i, j): a[i, j]}\n                total_count += count_valid_colorings(coloring, i + 1, j, 1)\n\n    return str(total_count)"
    },
    {
        "number": 3218,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_coloring(a):\n        def count_colored_edges(i, j):\n            if a[i][j] == -1:\n                return 0\n            return sum(a[i][j] == x for x in range(1, 7))\n\n        def is_colored(i, j, visited, direction):\n            if (i, j) in visited and visited[(i, j)] == direction:\n                return True\n            if a[i][j] != -1 and count_colored_edges(i, j) != a[i][j]:\n                return False\n            if (i, j) in visited:\n                return False\n            visited[(i, j)] = direction\n            if i % 2 == 0 and j == 0:\n                if not is_colored(i, j + 1, visited, direction):\n                    return False\n            if i % 2 == 0 and j == n - 1:\n                if not is_colored(i, j - 1, visited, direction):\n                    return False\n            if i % 2 == 1 and j == 0:\n                if not is_colored(i - 1, j, visited, direction):\n                    return False\n            if i % 2 == 1 and j == n - 1:\n                if not is_colored(i + 1, j, visited, direction):\n                    return False\n            if i % 2 == 1:\n                if not is_colored(i - 1, j + 1, visited, direction):\n                    return False\n                if not is_colored(i + 1, j + 1, visited, direction):\n                    return False\n            else:\n                if not is_colored(i - 1, j - 1, visited, direction):\n                    return False\n                if not is_colored(i + 1, j - 1, visited, direction):\n                    return False\n            return True\n\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != -1 and count_colored_edges(i, j) != a[i][j]:\n                    return False\n        visited = {}\n        if not is_colored(0, 0, visited, 1):\n            return False\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != -1 and (i, j) not in visited:\n                    return False\n        return True\n\n    def dfs(a, i, j, color, direction):\n        if i < 0 or i >= n or j < 0 or j >= n:\n            return 0\n        if a[i][j] != -1 and color != -1 and color != a[i][j]:\n            return 0\n        if (i, j) in visited:\n            return 1 if visited[(i, j)] == direction else 0\n        visited[(i, j)] = direction\n        if i % 2 == 0 and j == 0:\n            res = dfs(a, i, j + 1, color, direction)\n        elif i % 2 == 0 and j == n - 1:\n            res = dfs(a, i, j - 1, color, direction)\n        elif i % 2 == 1 and j == 0:\n            res = dfs(a, i - 1, j, color, direction)\n        elif i % 2 == 1 and j == n - 1:\n            res = dfs(a, i + 1, j, color, direction)\n        else:\n            res = dfs(a, i - 1, j + 1, color, direction) + dfs(a, i + 1, j + 1, color, direction)\n        if res == 0:\n            visited.pop((i, j))\n        return res\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    a = [list(map(int, line.split())) for line in lines[1:]]\n\n    if not is_valid_coloring(a):\n        return '0'\n\n    visited = {}\n    res = dfs(a, 0, 0, -1, 1"
    },
    {
        "number": 3218,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, stdin.readline().strip().split())))\n\n    def is_valid_coloring(a: List[List[int]]) -> bool:\n        def count_colored_edges(i: int, j: int) -> int:\n            count = 0\n            if j > 0 and a[i][j - 1] != -1:\n                count += 1\n            if j < len(a[i]) - 1 and a[i][j + 1] != -1:\n                count += 1\n            if i % 2 == 0 and i > 0 and j < len(a[i]) and a[i - 1][j] != -1:\n                count += 1\n            if i % 2 == 0 and i < n - 1 and j < len(a[i]) and a[i + 1][j] != -1:\n                count += 1\n            if i % 2 == 1 and i > 1 and j < len(a[i]) and a[i - 1][j] != -1:\n                count += 1\n            if i % 2 == 1 and i < n - 2 and j < len(a[i]) and a[i + 2][j] != -1:\n                count += 1\n            return count\n\n        for i in range(n):\n            for j in range(len(a[i])):\n                if a[i][j] != -1 and a[i][j] != count_colored_edges(i, j):\n                    return False\n        return True\n\n    def count_valid_colorings(a: List[List[int]]) -> int:\n        if not is_valid_coloring(a):\n            return 0\n\n        def has_valid_coloring(a: List[List[int]], i: int, j: int, color: int) -> bool:\n            if a[i][j] != -1 and color == a[i][j]:\n                return False\n            if color == 0:\n                return True\n\n            a[i][j] = color\n            if i % 2 == 0 and i > 0 and j < len(a[i]) and a[i - 1][j] != -1:\n                if not has_valid_coloring(a, i - 1, j, color - 1):\n                    return False\n            if i % 2 == 0 and i < n - 1 and j < len(a[i]) and a[i + 1][j] != -1:\n                if not has_valid_coloring(a, i + 1, j, color - 1):\n                    return False\n            if i % 2 == 1 and i > 1 and j < len(a[i]) and a[i - 1][j] != -1:\n                if not has_valid_coloring(a, i - 1, j, color - 1):\n                    return False\n            if i % 2 == 1 and i < n - 2 and j < len(a[i]) and a[i + 2][j] != -1:\n                if not has_valid_coloring(a, i + 2, j, color - 1):\n                    return False\n\n            if j > 0 and a[i][j - 1] != -1:\n                if not has_valid_coloring(a, i, j - 1, color):\n                    return False\n            if j < len(a[i]) - 1 and a[i][j + 1] != -1:\n                if not has_valid_coloring(a, i, j + 1, color):\n                    return False\n\n            a[i][j] = -1\n            return True\n\n        count = 0\n        for i in range(n):\n            for j in range(len(a[i])):\n                if a[i][j] == -1:\n                    for color in range(1, 7):\n                        if has_valid_coloring(a, i, j, color):\n                            count += 1\n        return count\n\n    return str(count_valid"
    },
    {
        "number": 3219,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    mod = 1000000009\n    n = int(stdin, 2)\n    num_representations = 0\n\n    # Convert to base 3\n    while n > 0:\n        num_representations += 1\n        n //= 3\n\n    # Add representations with digit 2\n    n = int(stdin, 2)\n    while n > 0:\n        digit = n % 10\n        if digit == 2:\n            num_representations += 1\n        n //= 10\n\n    return str(num_representations % mod)"
    },
    {
        "number": 3219,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    mod = 1000000009\n    binary = int(stdin, 2)\n    result = 1\n    \n    # If the binary representation contains the digit 2, subtract 1 from the result\n    if '2' in stdin:\n        result -= 1\n    \n    # If the binary representation ends with a 0, add 1 to the result\n    if stdin.endswith('0'):\n        result += 1\n    \n    return result % mod"
    },
    {
        "number": 3219,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    mod = 1000000009\n\n    def count_representations(num):\n        if num == 0:\n            return 1\n        if num % 2 == 1:\n            return 0\n        num //= 2\n        return (count_representations(num - 1) + count_representations(num)) % mod\n\n    return str(count_representations(n))"
    },
    {
        "number": 3219,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    modulo = 1000000009\n    memo = [0] * (n + 1)\n    memo[0] = 1\n    memo[1] = 1\n    memo[2] = 1\n    for i in range(3, n + 1):\n        memo[i] = (memo[i - 1] + memo[i - 2] + memo[i - 3]) % modulo\n    return str(memo[n])\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 3219,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_representations(n: int) -> int:\n        if n == 0:\n            return 1\n        if n % 2 == 0:\n            return count_representations(n // 2) + 1\n        else:\n            return count_representations(n // 2)\n\n    n = int(stdin, 2)\n    return str(count_representations(n) % 1000000009)"
    },
    {
        "number": 3219,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin, 2)\n    mod = 1000000009\n    # Initialize memoization table\n    memo = [[0] * 10 for _ in range(len(stdin) + 1)]\n    # Base case: There is only one way to represent 0 using the digits 0 and 2\n    memo[0][0] = 1\n    # Iterate through all possible lengths of binary strings\n    for i in range(1, len(stdin) + 1):\n        # Iterate through all possible digits (0, 2)\n        for j in range(10):\n            # Calculate the current digit and the next digit\n            cur_digit = j % 3\n            next_digit = (j // 3) % 3\n            # Calculate the number of ways to represent the remaining bits\n            remaining_bits = i - 1\n            remaining_ways = memo[remaining_bits][next_digit]\n            # Update the memoization table\n            memo[i][cur_digit] = (memo[i][cur_digit] + remaining_ways) % mod\n            # Handle the case where the current digit is 2\n            if cur_digit == 2:\n                # Calculate the number of ways to represent the remaining bits with 0 or 2\n                remaining_ways_0_or_2 = memo[remaining_bits][0] + memo[remaining_bits][2]\n                # Update the memoization table\n                memo[i][cur_digit] = (memo[i][cur_digit] + remaining_ways_0_or_2) % mod\n    # Calculate the number of representations using the digits 0 and 2\n    num_representations = memo[len(stdin)][0] + memo[len(stdin)][2]\n    return str(num_representations % mod)"
    },
    {
        "number": 3219,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 1000000009\n    n = int(stdin, 2)\n    count = 1\n\n    for i in range(1, len(stdin)):\n        if stdin[i] == \"0\":\n            count = (count * 2) % MOD\n        elif stdin[i] == \"2\":\n            count = (count * 3) % MOD\n        else:\n            count = (count * 2) % MOD\n\n    return str(count)"
    },
    {
        "number": 3219,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    count = 1\n    for i in range(len(stdin)):\n        bit = int(stdin[i])\n        if bit == 0:\n            count = (count * 2) % 1000000009\n        elif bit == 1:\n            count = (count * 3) % 1000000009\n    return str(count)"
    },
    {
        "number": 3219,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    n = int(stdin, 2)\n\n    # Initialize the number of representations\n    num_representations = 0\n\n    # Iterate through all possible binary strings with the same length as the input\n    for i in range(2 ** len(stdin)):\n        # Convert the current number to a binary string\n        binary_str = format(i, f'0{len(stdin)}b')\n\n        # Check if the binary string has a 2 in it\n        if '2' in binary_str:\n            # Convert the binary string to the new representation\n            new_representation = ''.join([str(int(bit) + 1) if bit in '01' else bit for bit in binary_str])\n\n            # Convert the new representation to an integer\n            new_num = int(new_representation, 3)\n\n            # Check if the new number is equal to the original number\n            if new_num == n:\n                # Increment the number of representations\n                num_representations += 1\n\n    # Return the number of representations modulo 1000000009\n    return str(num_representations % 1000000009)"
    },
    {
        "number": 3219,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    mod = 1000000009\n    num_representations = 0\n    n = int(stdin, 2)\n    for i in range(n + 1):\n        binary_representation = bin(i)[2:]\n        if \"1\" in binary_representation:\n            binary_representation_with_2 = binary_representation.replace(\"1\", \"2\")\n            num_representations += 1\n            if int(binary_representation_with_2, 3) == n:\n                num_representations += 1\n    return str(num_representations % mod)"
    },
    {
        "number": 3220,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_solution(positions, moves, start_positions):\n        solution = []\n        for i in range(N):\n            pos = (positions[i] + moves[i]) % N\n            while pos in positions:\n                if moves[i] < 0:\n                    moves[i] += 1\n                else:\n                    moves[i] -= 1\n                pos = (positions[i] + moves[i]) % N\n            positions[i] = pos\n        for i in range(N):\n            if positions[i] == start_positions[i]:\n                if moves[i] > 0:\n                    solution.append('L')\n                else:\n                    solution.append('R')\n            else:\n                return None\n        return ''.join(solution)\n\n    N = int(stdin.readline().strip())\n    moves = list(map(int, stdin.readline().strip().split()))\n    positions = list(range(N))\n    start_positions = list(range(N))\n    result = find_solution(positions, moves, start_positions)\n    if result is not None:\n        return result\n    for i in range(N):\n        moves[i] *= -1\n    result = find_solution(positions, moves, start_positions)\n    if result is not None:\n        return result\n    return \"no dance\""
    },
    {
        "number": 3220,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_solution(position_list, index, result, solution_list):\n        if index == len(position_list):\n            solution_list.append(result)\n            return\n\n        find_solution(position_list, index + 1, result + \"L\", solution_list)\n        find_solution(position_list, index + 1, result + \"R\", solution_list)\n\n    def is_valid_solution(position_list, solution):\n        for i in range(len(position_list)):\n            new_position = (position_list[i] + (-1 if solution[i] == 'L' else 1) * position_list[i]) % N\n            if new_position in position_list:\n                return False\n        return True\n\n    N = int(stdin.readline().strip())\n    position_list = list(map(int, stdin.readline().strip().split()))\n    solution_list = []\n\n    find_solution(position_list, 0, \"\", solution_list)\n\n    for solution in solution_list:\n        if is_valid_solution(position_list, solution):\n            return solution\n\n    return \"no dance\"\n"
    },
    {
        "number": 3220,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(moves: str) -> bool:\n        wizards = [0] * n\n        for move in moves:\n            for i in range(n):\n                if move == 'L':\n                    wizards[i] = (wizards[i] - p[i]) % n\n                else:\n                    wizards[i] = (wizards[i] + p[i]) % n\n            if len(set(wizards)) != n:\n                return False\n        return True\n\n    n, p = map(int, stdin.split())\n    p = list(map(int, p.split()))\n\n    for moves in sorted(product('LR', repeat=n)):\n        if is_valid(''.join(moves)):\n            return ''.join(moves)\n\n    return \"no dance\""
    },
    {
        "number": 3220,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, p = map(int, stdin.split())\n    d = [0] * N\n    for i in range(N):\n        d[i - p[i]] += 1\n    if any(x > 1 for x in d):\n        return \"no dance\"\n    return \"\".join(\"LR\"[i - p[i] < 0] for i in range(N))"
    },
    {
        "number": 3220,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, p = map(int, stdin.split())\n    p = list(map(int, p.split()))\n    \n    if sum(p) % N != 0:\n        return \"no dance\"\n    \n    move = sum(p) // N\n    result = []\n    \n    for i in p:\n        if i >= move:\n            result.append(\"L\")\n        else:\n            result.append(\"R\")\n            \n    return \"\".join(result)"
    },
    {
        "number": 3220,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, p = map(int, stdin.split())\n    p = [int(x) for x in p.split()]\n\n    def is_valid(p: List[int]) -> bool:\n        seen = set()\n        for x in p:\n            if x in seen:\n                return False\n            seen.add(x)\n        return True\n\n    def lexicographically_smallest(p: List[int]) -> str:\n        ans = []\n        for x in p:\n            if x < N // 2:\n                ans.append('L')\n            else:\n                ans.append('R')\n        return ''.join(ans)\n\n    if is_valid(p):\n        return lexicographically_smallest(p)\n    else:\n        return \"no dance\""
    },
    {
        "number": 3220,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    N = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    \n    # Initialize the movement directions\n    moves = ['L'] * N\n    \n    # Check for each wizard if he should move clockwise or counterclockwise\n    for i in range(N):\n        for j in range(i+1, N):\n            if p[i] == p[j]:\n                moves[i] = 'L' if p[i] > 0 else 'R'\n                moves[j] = 'R' if p[j] > 0 else 'L'\n                p[i], p[j] = abs(p[i]), abs(p[j])\n    \n    # Check if there is a valid solution\n    for i in range(N):\n        if p[i] != 0:\n            return \"no dance\"\n    \n    # Return the movement directions\n    return \"\".join(moves)"
    },
    {
        "number": 3220,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, *p = map(int, stdin.split())\n    d = {(i - j) % N: i for i, j in enumerate(p, 1)}\n    if len(d) == N:\n        return ''.join('L' if i == d[(i - p[i - 1]) % N] else 'R' for i in range(1, N + 1))\n    else:\n        return \"no dance\""
    },
    {
        "number": 3220,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, p = map(int, stdin.split())\n    res = []\n\n    for i in range(N):\n        if p[i] == 0:\n            res.append('L')\n        else:\n            res.append('R')\n\n    # Check if there is a collision\n    for i in range(N):\n        count = res.count('L') + res.count('R')\n        if count != N:\n            return \"no dance\"\n\n    return \"\".join(res)\n"
    },
    {
        "number": 3220,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    p_str = stdin.readline().strip()\n    p = list(map(int, p_str.split()))\n\n    def is_valid(moves: str) -> bool:\n        positions = [i for i in range(N)]\n        for i in range(N):\n            position = positions[i]\n            move = moves[i]\n            p_i = p[i]\n            if move == 'L':\n                positions[i] = (position - p_i) % N\n            else:\n                positions[i] = (position + p_i) % N\n        return len(set(positions)) == N\n\n    valid_moves = []\n    for moves in itertools.product('LR', repeat=N):\n        moves = ''.join(moves)\n        if is_valid(moves):\n            valid_moves.append(moves)\n\n    if not valid_moves:\n        return \"no dance\"\n\n    return min(valid_moves)"
    },
    {
        "number": 3221,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited, cnt):\n        if visited[start]:\n            return cnt\n        visited[start] = True\n        for i in graph[start]:\n            if not visited[i]:\n                cnt = dfs(i, visited, cnt)\n        return cnt\n\n    def bfs(start, visited, cnt):\n        queue = [start]\n        visited[start] = True\n        while queue:\n            curr = queue.pop(0)\n            for i in graph[curr]:\n                if not visited[i]:\n                    cnt = dfs(i, visited, cnt)\n                    queue.append(i)\n                    visited[i] = True\n        return cnt\n\n    N, M, alpha = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N + 1)]\n    max_candies = 0\n\n    for i in range(M):\n        u, v, c = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n        max_candies = max(max_candies, c)\n\n    visited = [False] * (N + 1)\n    ans = float('inf')\n\n    for i in range(1, N + 1):\n        cnt = 0\n        cnt = bfs(i, visited, cnt)\n        cnt -= 1\n        ans = min(ans, max_candies ** 2 + alpha * cnt)\n\n    return str(ans) if ans != float('inf') else \"Poor girl\""
    },
    {
        "number": 3221,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u, cnt):\n        if visited[u]:\n            return False\n        visited[u] = True\n        for v, w in graph[u]:\n            if not dfs(v, cnt + 1):\n                return False\n            if cnt + 1 == N - 1:\n                return True\n        return False\n\n    def solve(u, cnt):\n        if visited[u]:\n            return 0\n        visited[u] = True\n        ret = 0\n        for v, w in graph[u]:\n            ret = max(ret, solve(v, cnt + 1) + w)\n            if cnt + 1 == N - 1:\n                return ret\n        return ret\n\n    N, M, alpha = map(int, stdin.split())\n    graph = [[] for _ in range(N + 1)]\n    for i in range(M):\n        u, v, c = map(int, input().split())\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n\n    for cnt in range(1, N + 1):\n        visited = [False] * (N + 1)\n        if dfs(1, 0):\n            visited = [False] * (N + 1)\n            ans = solve(1, 0)\n            if ans <= 10**6 * (cnt ** 2) + alpha * cnt:\n                return ans\n    return \"Poor girl\""
    },
    {
        "number": 3221,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(current, visited, energy, cnt):\n        if cnt == M:\n            if current == start:\n                return energy\n            else:\n                return \"Poor girl\"\n\n        for i in range(M):\n            if i not in visited and roads[i][0] == current:\n                visited.add(i)\n                new_energy = energy + roads[i][2] ** 2 + alpha * cnt\n                result = dfs(roads[i][1], visited, new_energy, cnt + 1)\n                if result != \"Poor girl\":\n                    return result\n                visited.remove(i)\n\n        return \"Poor girl\"\n\n    lines = stdin.split('\\n')\n    N, M, alpha = map(int, lines[0].split())\n    roads = [list(map(int, line.split())) for line in lines[1:]]\n    roads.sort(key=lambda x: x[2], reverse=True)\n\n    start = 1\n    energy = 0\n    visited = set()\n    result = dfs(start, visited, energy, 0)\n\n    return str(result)"
    },
    {
        "number": 3221,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = map(int, stdin.readline().split())\n    roads = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    def dfs(node, visited, energy):\n        if visited[node]:\n            return float('inf')\n        visited[node] = True\n        min_energy = energy\n        for u, v, c in roads:\n            if node == u:\n                next_node = v\n            elif node == v:\n                next_node = u\n            else:\n                continue\n            min_energy = min(min_energy, dfs(next_node, visited, energy + c ** 2 + alpha))\n        visited[node] = False\n        return min_energy\n\n    min_energy = float('inf')\n    for start in range(1, N + 1):\n        min_energy = min(min_energy, dfs(start, [False] * (N + 1), 0))\n\n    return min_energy if min_energy != float('inf') else \"Poor girl\"\n"
    },
    {
        "number": 3221,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    N, M, alpha = map(int, stdin.readline().split())\n    roads = defaultdict(list)\n    for _ in range(M):\n        u, v, c = map(int, stdin.readline().split())\n        roads[u].append((v, c))\n        roads[v].append((u, c))\n\n    def dfs(current, visited, energy):\n        if current == start:\n            return energy\n        for neighbor, c in roads[current]:\n            if neighbor not in visited:\n                new_energy = energy + c ** 2 + alpha\n                if new_energy < minimum:\n                    minimum[neighbor] = new_energy\n                    if dfs(neighbor, visited | {neighbor}, new_energy):\n                        return True\n        return False\n\n    start = 1\n    minimum = {start: 0}\n    visited = {start}\n    while dfs(start, visited, 0) is not None:\n        if all(c in minimum for c in range(1, N + 1)):\n            break\n\n    if all(c in minimum for c in range(1, N + 1)):\n        return min(minimum.values())\n    else:\n        return \"Poor girl\" "
    },
    {
        "number": 3221,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(N + 1)]\n    candy_list = []\n\n    for _ in range(M):\n        u, v, c = map(int, stdin.readline().split())\n        adj_list[u].append((v, c))\n        adj_list[v].append((u, c))\n        candy_list.append(c)\n\n    def dfs(node, visited, candy_count, energy):\n        if visited[node]:\n            return float('inf')\n        visited[node] = True\n        min_energy = energy\n        for neighbor, candy in adj_list[node]:\n            if not visited[neighbor]:\n                candy_count[0] += candy\n                min_energy = min(min_energy, dfs(neighbor, visited, candy_count, energy + candy ** 2 + alpha * candy_count[0]))\n                candy_count[0] -= candy\n        visited[node] = False\n        return min_energy\n\n    answer = dfs(1, [False] * (N + 1), [0], 0)\n\n    if answer != float('inf'):\n        return str(answer)\n    else:\n        return \"Poor girl\""
    },
    {
        "number": 3221,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = map(int, stdin.readline().split())\n    road_info = [list(map(int, stdin.readline().split())) for _ in range(M)]\n    L = 0\n    K = 0\n    visited_roads = set()\n    junction_visits = [0] * (N + 1)\n    start_junction = None\n    end_junction = None\n\n    for road in road_info:\n        u, v, c = road\n        if u not in visited_roads and v not in visited_roads:\n            visited_roads.add(u)\n            visited_roads.add(v)\n            junction_visits[u] += 1\n            junction_visits[v] += 1\n            K += 1\n            L = max(L, c)\n        if start_junction is None and junction_visits[u] == 1:\n            start_junction = u\n        if end_junction is None and junction_visits[v] == 1:\n            end_junction = v\n\n    if start_junction != end_junction or L == 0 or K == 0:\n        return \"Poor girl\"\n\n    energy = L ** 2 + alpha * K\n    return energy\n"
    },
    {
        "number": 3221,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(start, end, visited_roads, road_count):\n        if start == end:\n            return True\n        for road in graph[start]:\n            if road not in visited_roads:\n                visited_roads.add(road)\n                if is_valid(graph[start][road], end, visited_roads, road_count + 1):\n                    return True\n                visited_roads.remove(road)\n        return False\n\n    def min_energy(start, end, visited_roads, road_count, energy):\n        if start == end:\n            return energy\n        min_energy = float('inf')\n        for road in graph[start]:\n            if road not in visited_roads:\n                visited_roads.add(road)\n                new_energy = min_energy(graph[start][road], end, visited_roads, road_count + 1, energy + road_cost[start][road])\n                if new_energy < min_energy:\n                    min_energy = new_energy\n                visited_roads.remove(road)\n        return min_energy\n\n    N, M, alpha = map(int, stdin.readline().strip().split())\n    graph = {i: {} for i in range(1, N + 1)}\n    road_cost = {i: {} for i in range(1, N + 1)}\n\n    for i in range(M):\n        u, v, c = map(int, stdin.readline().strip().split())\n        graph[u][v] = v\n        graph[v][u] = u\n        road_cost[u][v] = c\n        road_cost[v][u] = c\n\n    start_junction = 1\n    visited_roads = set()\n    energy = 0\n\n    if not is_valid(start_junction, start_junction, visited_roads, 0):\n        return \"Poor girl\"\n\n    min_energy = float('inf')\n    for end_junction in graph[start_junction]:\n        visited_roads = {end_junction}\n        new_energy = min_energy(graph[start_junction][end_junction], start_junction, visited_roads, 1, energy + road_cost[start_junction][end_junction])\n        if new_energy < min_energy:\n            min_energy = new_energy\n\n    return min_energy ** 2 + alpha * M"
    },
    {
        "number": 3221,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u, energy, visited):\n        nonlocal ans\n        if u == start:\n            ans = min(ans, energy)\n            return\n        for v, c in graph[u]:\n            if v not in visited:\n                dfs(v, energy + c * c + alpha, visited | {v})\n\n    N, M, alpha = map(int, stdin.split())\n    graph = [[] for _ in range(N)]\n    start = None\n    for i in range(M):\n        u, v, c = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n        if i == 0:\n            start = u\n        ans = float('inf')\n        dfs(start, 0, {start})\n        if ans == float('inf'):\n            return 'Poor girl'\n        else:\n            return str(ans)"
    },
    {
        "number": 3221,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N + 1)]\n    candies = []\n\n    for i in range(M):\n        u, v, c = map(int, stdin.readline().split())\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n        candies.append(c)\n\n    L = max(candies)\n    K = M\n\n    return str(L ** 2 + alpha * K)"
    },
    {
        "number": 3222,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, visited, graph):\n        visited[v] = True\n        for i in graph[v]:\n            if not visited[i]:\n                dfs(i, visited, graph)\n\n    def find_islands(graph):\n        visited = [False] * len(graph)\n        islands = []\n        for v in range(len(graph)):\n            if not visited[v]:\n                islands.append([])\n                dfs(v, visited, graph)\n                for i, vis in enumerate(visited):\n                    if vis:\n                        islands[-1].append(i)\n        return islands\n\n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        f, t = map(int, stdin.readline().split())\n        graph[f].append(t)\n        graph[t].append(f)\n\n    islands = find_islands(graph)\n    if len(islands) > 1:\n        return \"Yeah!\"\n\n    output = [len(islands[0])]\n    for place in islands[0]:\n        output.append(place)\n\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3222,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited, to_visit):\n        if not to_visit:\n            return [visited + [start]]\n        \n        paths = []\n        for i, next_visit in enumerate(to_visit):\n            if start in graph[next_visit]:\n                new_visited = visited + [start]\n                new_to_visit = to_visit[:i] + to_visit[i+1:]\n                paths.extend(dfs(next_visit, new_visited, new_to_visit))\n        \n        return paths\n    \n    def is_connected(graph):\n        visited = set()\n        def dfs(node):\n            if node in visited:\n                return\n            visited.add(node)\n            for neighbor in graph[node]:\n                dfs(neighbor)\n        \n        dfs(0)\n        return len(visited) == len(graph)\n    \n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N)]\n    \n    for _ in range(M):\n        f, t = map(int, stdin.readline().split())\n        graph[f].append(t)\n    \n    if not is_connected(graph):\n        return \"Yeah!\"\n    \n    all_places = set(range(N))\n    result = []\n    \n    for start in range(N):\n        visited = [start]\n        to_visit = list(all_places - set(visited))\n        paths = dfs(start, visited, to_visit)\n        \n        for path in paths:\n            result.append(path)\n            all_places -= set(path)\n            if not all_places:\n                break\n        if not all_places:\n            break\n    \n    return f\"{len(result)}\\n\" + \"\\n\".join(f\"{len(path)}\\n\" + \"\\n\".join(map(str, path)) for path in result)"
    },
    {
        "number": 3222,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    streets = {i: [] for i in range(N)}\n    for _ in range(M):\n        f, t = map(int, stdin.readline().split())\n        streets[f].append(t)\n\n    visited = [False] * N\n    result = []\n\n    def dfs(current_place, trip):\n        visited[current_place] = True\n        trip.append(current_place)\n\n        for next_place in streets[current_place]:\n            if not visited[next_place]:\n                dfs(next_place, trip)\n\n        trip.append(current_place)\n\n    def is_possible():\n        for start in range(N):\n            if not visited[start]:\n                dfs(start, [])\n                result.append(trip)\n                if any(not v for v in visited):\n                    return False\n        return True\n\n    for start in range(N):\n        dfs(start, [])\n        result.append(trip)\n\n    if not is_possible():\n        return \"Yeah!\"\n\n    print(len(result))\n    for trip in result:\n        print(len(trip))\n        for place in trip:\n            print(place, end=\" \")\n        print()\n\n    return \"\"\n"
    },
    {
        "number": 3222,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited):\n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n                visited.add(start)\n                return visited\n        visited.add(start)\n        return visited\n\n    def check_validity(trips):\n        visited = set()\n        for trip in trips:\n            for place in trip:\n                visited.add(place)\n        return len(visited) == N\n\n    def construct_trips(visited_places):\n        trips = []\n        while visited_places:\n            trip = []\n            start = visited_places.pop()\n            trip.append(start)\n            while visited_places:\n                if graph[start]:\n                    next_place = graph[start].pop()\n                    trip.append(next_place)\n                    start = next_place\n                else:\n                    visited_places.discard(start)\n                    break\n            trips.append(trip)\n        return trips\n\n    def is_dag(graph):\n        visited = set()\n        for i in range(N):\n            if i not in visited:\n                if not dfs(i, visited):\n                    return False\n        return True\n\n    N, M = map(int, stdin.readline().strip().split())\n    graph = {i: set() for i in range(N)}\n    for _ in range(M):\n        f, t = map(int, stdin.readline().strip().split())\n        graph[f].add(t)\n\n    if not is_dag(graph):\n        return \"Yeah!\"\n\n    visited = set()\n    for i in range(N):\n        if i not in visited:\n            visited = dfs(i, visited)\n\n    trips = construct_trips(visited)\n\n    if check_validity(trips):\n        result = [len(trip) for trip in trips]\n        result.append(sum(result))\n        result.append(\"\\n\".join(str(place) for trip in trips for place in trip))\n        return \"\\n\".join(map(str, result))\n    else:\n        return \"Yeah!\" "
    },
    {
        "number": 3222,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited):\n        if visited[start]:\n            return []\n        visited[start] = True\n        result = [[start]]\n        for i in range(len(graph[start])):\n            if not visited[graph[start][i]]:\n                paths = dfs(graph[start][i], visited)\n                for path in paths:\n                    result.append([start] + path)\n        return result\n\n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        f, t = map(int, stdin.readline().split())\n        graph[f].append(t)\n\n    visited = [False] * N\n    result = []\n    for i in range(N):\n        if not visited[i]:\n            paths = dfs(i, visited)\n            for path in paths:\n                result.append(path)\n\n    if not result:\n        return \"Yeah!\"\n\n    output = [str(len(result))] + [\"\\n\".join(str(x) for x in trip) for trip in result]\n    return \"\\n\".join(output) + \"\\n\""
    },
    {
        "number": 3222,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        f, t = map(int, stdin.readline().split())\n        graph[f].append(t)\n\n    visited = [False] * N\n    path = []\n\n    def dfs(v):\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                dfs(u)\n        path.append(v)\n\n    trips = []\n    for i in range(N):\n        if not visited[i]:\n            dfs(i)\n            trips.append(path[::-1])\n            path.clear()\n\n    if len(trips) == 1:\n        return \"Yeah!\"\n\n    output = [str(len(trips))]\n    for trip in trips:\n        output.append(str(len(trip)))\n        output.extend(map(str, trip))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3222,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited, graph, path):\n        visited[start] = True\n        path.append(start)\n        for v in graph[start]:\n            if not visited[v]:\n                dfs(v, visited, graph, path)\n        return path\n\n    def construct_graph(N, M, roads):\n        graph = {i: [] for i in range(N)}\n        for road in roads:\n            graph[road[0]].append(road[1])\n            graph[road[1]].append(road[0])\n        return graph\n\n    def is_possible(trips):\n        visited = [False] * N\n        for trip in trips:\n            for place in trip:\n                visited[place] = True\n        return all(visited)\n\n    def find_trips(N, M, roads):\n        graph = construct_graph(N, M, roads)\n        trips = []\n        visited = [False] * N\n\n        for start in range(N):\n            if not visited[start]:\n                path = dfs(start, visited, graph, [])\n                trips.append(path)\n\n        return trips\n\n    N, M = map(int, stdin.readline().strip().split())\n    roads = [list(map(int, stdin.readline().strip().split())) for _ in range(M)]\n\n    trips = find_trips(N, M, roads)\n\n    if is_possible(trips):\n        return f\"{len(trips)}\\n\" + \"\\n\".join([\" \".join(map(str, [len(trip)] + trip)) for trip in trips])\n    else:\n        return \"Yeah!\"\n\nstdin = '''\n4 4\n0 1\n1 0\n2 3\n3 2\n'''\n\nprint(solution(stdin)) "
    },
    {
        "number": 3222,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                dfs(v)\n\n    N, M = map(int, stdin.readline().split())\n    adj = [[] for _ in range(N)]\n    for _ in range(M):\n        f, t = map(int, stdin.readline().split())\n        adj[f].append(t)\n        adj[t].append(f)\n\n    visited = [False] * N\n    trips = []\n    for i in range(N):\n        if not visited[i]:\n            dfs(i)\n            trip = []\n            for j in range(N):\n                if visited[j]:\n                    trip.append(j)\n            trips.append(trip)\n\n    if len(trips) == 1:\n        return \"Yeah!\"\n\n    output = [str(len(trips))]\n    for trip in trips:\n        output.append(str(len(trip)))\n        output.extend(map(str, trip))\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3222,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, visited, path):\n        visited[v] = True\n        path.append(v)\n        for u in adj[v]:\n            if not visited[u]:\n                dfs(u, visited, path)\n\n    N, M = map(int, stdin.readline().split())\n    adj = [[] for _ in range(N)]\n    for _ in range(M):\n        f, t = map(int, stdin.readline().split())\n        adj[f].append(t)\n\n    visited = [False] * N\n    paths = []\n    for i in range(N):\n        if not visited[i]:\n            path = []\n            dfs(i, visited, path)\n            paths.append(path)\n\n    if len(paths) > 1:\n        return \"Yeah!\"\n\n    result = [str(len(paths[0]))]\n    for i in paths[0]:\n        result.append(str(i))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3222,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, visited):\n        visited.add(v)\n        for u in graph[v]:\n            if u not in visited:\n                dfs(u, visited)\n\n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        f, t = map(int, stdin.readline().split())\n        graph[f].append(t)\n        graph[t].append(f)\n\n    visited = set()\n    trips = []\n    for i in range(N):\n        if i not in visited:\n            trip = []\n            dfs(i, visited)\n            trip.append(len(visited))\n            trip.extend(visited)\n            trips.append(trip)\n\n    if len(trips) == N:\n        output = [str(len(trips))] + [\"\\n\".join(str(x) for x in trip) for trip in trips]\n        return \"\\n\".join(output) + \"\\n\"\n    else:\n        return \"Yeah!\""
    },
    {
        "number": 3223,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def construct_forest(degrees):\n        forest = []\n        for i in range(len(degrees)):\n            if degrees[i] == 0:\n                forest.append([])\n            elif degrees[i] % 2 == 1:\n                return None\n            else:\n                tree = []\n                for j in range(degrees[i]):\n                    if j == 0:\n                        tree.append((i, degrees[i] // 2 + 1))\n                    elif j % 2 == 0:\n                        tree.append((i, degrees[i] // 2 + 1 - j // 2))\n                    else:\n                        tree.append((i, degrees[i] // 2 + 1 - j // 2 - 1))\n                forest.append(tree)\n        return forest\n\n    lines = stdin.split('\\n')\n    V = int(lines[0])\n    degrees = [int(x) for x in lines[1].split()]\n\n    forest = construct_forest(degrees)\n    if forest is None:\n        return \"IMPOSSIBLE\"\n    else:\n        result = [\"POSSIBLE\"]\n        for tree in forest:\n            for edge in tree:\n                result.append(f\"{edge[0] + 1} {edge[1] + 1}\")\n        return \"\\n\".join(result)"
    },
    {
        "number": 3223,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def construct_forest(V, degrees):\n        forest = []\n        for i in range(V):\n            forest.append([])\n        for i in range(V):\n            for j in range(i + 1, V):\n                if degrees[i] > 0 and degrees[j] > 0:\n                    forest[i].append(j)\n                    forest[j].append(i)\n                    degrees[i] -= 1\n                    degrees[j] -= 1\n        return forest\n\n    def check_forest(forest):\n        visited = [False] * len(forest)\n\n        def dfs(node, parent):\n            if visited[node]:\n                return False\n            visited[node] = True\n            for neighbor in forest[node]:\n                if neighbor != parent:\n                    if not dfs(neighbor, node):\n                        return False\n            return True\n\n        for i in range(len(forest)):\n            if not visited[i]:\n                if not dfs(i, -1):\n                    return False\n        return True\n\n    lines = stdin.split('\\n')\n    V = int(lines[0])\n    degrees = [int(d) for d in lines[1].split()]\n\n    forest = construct_forest(V, degrees)\n    if check_forest(forest):\n        output = \"POSSIBLE\\n\"\n        for i in range(len(forest)):\n            for j in forest[i]:\n                output += f\"{i + 1} {j + 1}\\n\"\n        return output\n    else:\n        return \"IMPOSSIBLE\" "
    },
    {
        "number": 3223,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_vertex_with_degree(degree):\n        for i, d in enumerate(degrees):\n            if d == degree:\n                return i + 1\n        return None\n\n    def add_edge(u, v):\n        if u not in edges:\n            edges[u] = [v]\n        elif v not in edges[u]:\n            edges[u].append(v)\n\n        if v not in edges:\n            edges[v] = [u]\n        elif u not in edges[v]:\n            edges[v].append(u)\n\n    def dfs(vertex, parent):\n        for neighbor in edges[vertex]:\n            if neighbor == parent:\n                continue\n            dfs(neighbor, vertex)\n            degrees[vertex - 1] -= degrees[neighbor - 1]\n\n    lines = stdin.split('\\n')\n    V = int(lines[0])\n    degrees = [int(d) for d in lines[1].split()]\n\n    if sum(degrees) % 2 != 0:\n        return \"IMPOSSIBLE\"\n\n    edges = {}\n    for i in range(1, V + 1):\n        if degrees[i - 1] > 0:\n            neighbor = find_vertex_with_degree(degrees[i - 1])\n            if neighbor:\n                add_edge(i, neighbor)\n                degrees[i - 1] -= degrees[neighbor - 1]\n\n    if any(d > 0 for d in degrees):\n        return \"IMPOSSIBLE\"\n\n    dfs(1, None)\n\n    if any(d > 0 for d in degrees):\n        return \"IMPOSSIBLE\"\n\n    output = [\"POSSIBLE\"]\n    for u in edges:\n        for v in edges[u]:\n            output.append(f\"{u} {v}\")\n    return \"\\n\".join(output)"
    },
    {
        "number": 3223,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def construct_forest(degrees):\n        forest = []\n        for i, degree in enumerate(degrees):\n            if degree > len(forest):\n                return False\n            if degree > 0:\n                forest[degree - 1].append(i + 1)\n            else:\n                forest.append([i + 1])\n        return forest\n\n    input_data = list(map(int, stdin.split()))\n    vertices = input_data[0]\n    degrees = input_data[1:]\n\n    forest = construct_forest(degrees)\n\n    if forest:\n        output = [\"POSSIBLE\"]\n        for tree in forest:\n            for i in range(1, len(tree)):\n                output.append(f\"{tree[i - 1]} {tree[i]}\")\n    else:\n        output = [\"IMPOSSIBLE\"]\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3223,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def construct_forest(vertices: int, degrees: list) -> str:\n        forest = []\n        for i in range(vertices):\n            if degrees[i] <= len(forest):\n                tree = []\n                for j in range(degrees[i]):\n                    if not tree or len(tree[-1]) < 2:\n                        tree.append([i + 1, j + 1 + len(forest)])\n                    else:\n                        return \"IMPOSSIBLE\"\n                forest.append(tree)\n            else:\n                return \"IMPOSSIBLE\"\n        return \"POSSIBLE\\n\" + \"\\n\".join([\" \".join(str(x) for x in edge) for tree in forest for edge in tree])\n\n    input_data = list(map(int, stdin.strip().split()))\n    vertices = input_data[0]\n    degrees = input_data[1:]\n\n    return construct_forest(vertices, degrees)"
    },
    {
        "number": 3223,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def construct_forest(degree_list):\n        graph = {}\n        for i in range(len(degree_list)):\n            graph[i + 1] = []\n            for j in range(degree_list[i]):\n                if i + 1 in graph[j + 1]:\n                    return None\n                graph[i + 1].append(j + 1)\n        return graph\n\n    def bfs(graph, start_node):\n        visited, queue = set(), [start_node]\n        while queue:\n            node = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                queue.extend(graph[node] - visited)\n        return visited\n\n    def is_forest(graph):\n        return all(len(bfs(graph, node)) == len(graph) for node in graph)\n\n    def find_edges(graph):\n        edges = []\n        for node in graph:\n            for neighbor in graph[node]:\n                edges.append((node, neighbor))\n        return edges\n\n    input_data = list(map(int, stdin.strip().split()))\n    num_vertices = input_data[0]\n    degree_list = input_data[1:]\n\n    if sum(degree_list) % 2 != 0:\n        return \"IMPOSSIBLE\"\n\n    forest = construct_forest(degree_list)\n\n    if forest is None:\n        return \"IMPOSSIBLE\"\n\n    if is_forest(forest):\n        edges = find_edges(forest)\n        output = [\"POSSIBLE\"]\n        for edge in edges:\n            output.append(\" \".join(map(str, edge)))\n        return \"\\n\".join(output)\n    else:\n        return \"IMPOSSIBLE\" "
    },
    {
        "number": 3223,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_tree(degree_list):\n        tree = []\n        for i, deg in enumerate(degree_list):\n            if deg == 0:\n                continue\n            elif deg == 1:\n                tree.append([i + 1])\n            else:\n                return None\n        return tree\n\n    def construct_tree(tree, degree_list, used_vertices):\n        result = []\n        for edge in tree:\n            if used_vertices[edge[0] - 1]:\n                continue\n            result.append([edge[0], edge[-1]])\n            used_vertices[edge[0] - 1] = True\n            used_vertices[edge[-1] - 1] = True\n            degree_list[edge[0] - 1] -= 1\n            degree_list[edge[-1] - 1] -= 1\n        return result\n\n    lines = stdin.strip().split('\\n')\n    V = int(lines[0])\n    degree_list = list(map(int, lines[1].strip().split()))\n\n    if sum(degree_list) % 2 != 0:\n        return 'IMPOSSIBLE'\n\n    tree = find_tree(degree_list)\n    if tree is None:\n        return 'IMPOSSIBLE'\n\n    used_vertices = [False] * V\n    result = construct_tree(tree, degree_list, used_vertices)\n\n    if any(deg > 0 for deg in degree_list):\n        return 'IMPOSSIBLE'\n\n    output = ['POSSIBLE']\n    for edge in result:\n        output.append(' '.join(map(str, edge)))\n    return '\\n'.join(output) "
    },
    {
        "number": 3223,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_edges(vertex, degree):\n        if degree == 1:\n            return [(vertex, V[index + 1]) for index, V in enumerate(vertices) if V[1] == degree][0]\n        else:\n            for index, V in enumerate(vertices):\n                if V[1] == degree:\n                    return [(vertex, V[index + 1]) for index, V in enumerate(vertices) if V[1] == degree and V[0] != vertex][0]\n\n    def construct_forest(vertices):\n        forest = []\n        for vertex, degree in vertices:\n            if degree > 0:\n                edge = find_edges(vertex, degree)\n                if edge:\n                    forest.append(edge)\n                else:\n                    return False\n        return forest\n\n    def print_forest(forest):\n        for edge in forest:\n            print(f\"{edge[0]} {edge[1]}\")\n\n    lines = stdin.split(\"\\n\")\n    V = int(lines[0])\n    degrees = list(map(int, lines[1].split()))\n    vertices = [(i + 1, degrees[i]) for i in range(V)]\n\n    forest = construct_forest(vertices)\n    if forest:\n        print(\"POSSIBLE\")\n        print_forest(forest)\n    else:\n        print(\"IMPOSSIBLE\")\n\n    return \"\" "
    },
    {
        "number": 3223,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def construct_tree(degree_list: List[int]) -> List[List[int]]:\n        tree = []\n        for i in range(len(degree_list)):\n            if degree_list[i] > 0:\n                tree.append([i + 1] * degree_list[i])\n        return tree\n\n    def flatten_tree(tree: List[List[int]]) -> List[Tuple[int, int]]:\n        flattened_tree = []\n        for subtree in tree:\n            for edge in subtree:\n                flattened_tree.append(edge)\n        return flattened_tree\n\n    def is_tree(tree: List[List[int]]) -> bool:\n        visited = [False] * (len(tree) + 1)\n        stack = []\n\n        def dfs(node: int) -> bool:\n            if visited[node]:\n                return False\n            visited[node] = True\n            for neighbor in tree[node - 1]:\n                if not visited[neighbor]:\n                    if not dfs(neighbor):\n                        return False\n            stack.append(node)\n            return True\n\n        for i in range(1, len(tree) + 1):\n            if not visited[i]:\n                if not dfs(i):\n                    return False\n\n        for i in range(len(stack) - 1, 0, -1):\n            node = stack[i]\n            for neighbor in tree[node - 1]:\n                if neighbor in stack and stack.index(neighbor) > i:\n                    return False\n\n        return True\n\n    lines = stdin.split('\\n')\n    V = int(lines[0])\n    degree_list = [int(x) for x in lines[1].split()]\n\n    tree = construct_tree(degree_list)\n    flattened_tree = flatten_tree(tree)\n\n    if is_tree(tree):\n        output = 'POSSIBLE\\n'\n        for edge in flattened_tree:\n            output += f'{edge[0]} {edge[1]}\\n'\n    else:\n        output = 'IMPOSSIBLE\\n'\n\n    return output[:-1] "
    },
    {
        "number": 3223,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def construct_forest(degree_list):\n        forest = []\n        for vertex, degree in enumerate(degree_list, start=1):\n            if degree > len(forest):\n                return None\n            for i in range(degree):\n                if vertex not in forest[i]:\n                    forest[i].append(vertex)\n        return forest\n\n    lines = stdin.split('\\n')\n    V = int(lines[0])\n    degree_list = list(map(int, lines[1].split()))\n\n    forest = construct_forest(degree_list)\n    if forest is None:\n        return \"IMPOSSIBLE\"\n    else:\n        output = [\"POSSIBLE\"]\n        for tree in forest:\n            for edge in tree:\n                output.append(str(edge))\n        return '\\n'.join(output)\n"
    },
    {
        "number": 3224,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(4):\n        x, y, z = map(int, stdin.split())\n        points.append((x, y, z))\n\n    # Find the plane formed by three points\n    x1, y1, z1 = points[0]\n    x2, y2, z2 = points[1]\n    x3, y3, z3 = points[2]\n\n    a = (y1 * (z2 - z3)) + (y2 * (z3 - z1)) + (y3 * (z1 - z2))\n    b = (z1 * (x2 - x3)) + (z2 * (x3 - x1)) + (z3 * (x1 - x2))\n    c = (x1 * (y2 - y3)) + (x2 * (y3 - y1)) + (x3 * (y1 - y2))\n    d = (0 - (a * x1)) - (b * y1) - (c * z1)\n\n    # Find the centre of the sphere\n    A = ((a**2) + (b**2) + (c**2))\n    B = (-2 * (a**2) * x1) - (2 * b * y1 * c * z1) - (2 * c * z1 * a * x1) - (2 * d * c) + (2 * a * x1 * y1)\n    C = (a**2) * (x1**2) + (b**2) * (y1**2) + (c**2) * (z1**2) + (d**2) - (2 * a * x1 * y1 * z1) - (2 * b * y1 * z1)\n\n    x_c = (B + ((B**2) - (4 * A * C))**0.5) / (2 * A)\n    y_c = ((B - ((B**2) - (4 * A * C))**0.5) / (2 * A)) * (b / a) + (d / A)\n    z_c = ((B - ((B**2) - (4 * A * C))**0.5) / (2 * A)) * (c / a) + (d / A)\n\n    return f\"{x_c} {y_c} {z_c}\""
    },
    {
        "number": 3224,
        "checkpoint": "34B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(4):\n        x, y, z = map(int, stdin.split())\n        points.append([x, y, z])\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def center(p1, p2, p3):\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        x3, y3, z3 = p3\n\n        A = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)\n        B = (x1 ** 2 + y1 ** 2 + z1 ** 2) * (y2 - y3) + \\\n            (x2 ** 2 + y2 ** 2 + z2 ** 2) * (y3 - y1) + \\\n            (x3 ** 2 + y3 ** 2 + z3 ** 2) * (y1 - y2)\n        C = (x1 * x1 + y1 * y1 + z1 * z1) * (x2 * y3 - x3 * y2) + \\\n            (x2 * x2 + y2 * y2 + z2 * z2) * (x3 * y1 - x1 * y3) + \\\n            (x3 * x3 + y3 * y3 + z3 * z3) * (x1 * y2 - x2 * y1)\n\n        if A == 0:\n            return None\n        else:\n            x = B / (2 * A)\n            y = (B ** 2 - 4 * A * C) / (4 * A ** 2)\n            z = (-x1 * y - x2 * y - x3 * y - x) / y\n\n        return [x, y, z]\n\n    def solve():\n        p1, p2, p3, p4 = points\n        c1 = center(p1, p2, p3)\n        c2 = center(p1, p3, p4)\n        c3 = center(p1, p4, p2)\n        c4 = center(p2, p3, p4)\n\n        if c1 is None or c2 is None or c3 is None or c4 is None:\n            return None\n\n        sphere_center = [(c1[i] + c2[i] + c3[i] + c4[i]) / 4 for i in range(3)]\n        return sphere_center\n\n    sphere_center = solve()\n\n    return '{0:.4f} {1:.4f} {2:.4f}'.format(sphere_center[0], sphere_center[1], sphere_center[2])"
    },
    {
        "number": 3224,
        "checkpoint": "34B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for _ in range(4):\n        x, y, z = map(int, stdin.readline().strip().split())\n        points.append((x, y, z))\n\n    x1, y1, z1 = points[0]\n    x2, y2, z2 = points[1]\n    x3, y3, z3 = points[2]\n    x4, y4, z4 = points[3]\n\n    # Calculate the equations of the planes containing the points\n    a1 = (y2 - y1) * (z3 - z1) - (y3 - y1) * (z2 - z1)\n    b1 = (z2 - z1) * (x3 - x1) - (z3 - z1) * (x2 - x1)\n    c1 = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)\n    d1 = -(a1 * x1 + b1 * y1 + c1 * z1)\n\n    a2 = (y2 - y1) * (z4 - z1) - (y4 - y1) * (z2 - z1)\n    b2 = (z2 - z1) * (x4 - x1) - (z4 - z1) * (x2 - x1)\n    c2 = (x2 - x1) * (y4 - y1) - (x4 - x1) * (y2 - y1)\n    d2 = -(a2 * x1 + b2 * y1 + c2 * z1)\n\n    a3 = (y3 - y1) * (z4 - z1) - (y4 - y1) * (z3 - z1)\n    b3 = (z3 - z1) * (x4 - x1) - (z4 - z1) * (x3 - x1)\n    c3 = (x3 - x1) * (y4 - y1) - (x4 - x1) * (y3 - y1)\n    d3 = -(a3 * x1 + b3 * y1 + c3 * z1)\n\n    # Calculate the determinant of the matrix\n    det = a1 * (b2 * c3 - b3 * c2) - a2 * (b1 * c3 - b3 * c1) + a3 * (b1 * c2 - b2 * c1)\n\n    # Calculate the coordinates of the centre of the sphere\n    x_c = (b1 * (c2 - c3) * d3 - b2 * (c1 - c3) * d3 + b3 * (c1 - c2) * d3) / (2 * det)\n    y_c = (c1 * (a3 - a2) * d2 - c2 * (a1 - a3) * d2 + c3 * (a1 - a2) * d2) / (2 * det)\n    z_c = (d1 * (a2 - a3) * b3 - d2 * (a3 - a1) * b1 + d3 * (a1 - a2) * b2) / (2 * det)\n\n    return f\"{x_c:.4f} {y_c:.4f} {z_c:.4f}\""
    },
    {
        "number": 3224,
        "checkpoint": "34B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(4):\n        x, y, z = map(int, stdin.split())\n        points.append((x, y, z))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def center(p1, p2, p3):\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        x3, y3, z3 = p3\n        A = x2 * y1 - x1 * y2 + x3 * (y2 - y1) + x2 * (y1 - y3)\n        B = x1 * z2 - x2 * z1 + x3 * (z2 - z1) + x2 * (z1 - z3)\n        C = x2 * y1 - x1 * y2 + x3 * (y2 - y1) + x1 * (y3 - y2)\n        D = -x1 * (y2 * z3 - y3 * z2) + x2 * (y3 * z1 - y1 * z3) + x3 * (y1 * z2 - y2 * z1)\n        return A / D, B / D, C / D\n\n    p1, p2, p3, p4 = points\n    c1 = center(p1, p2, p3)\n    c2 = center(p1, p3, p4)\n    c3 = center(p1, p4, p2)\n    c4 = center(p2, p3, p4)\n\n    return f\"{c1[0]:.4f} {c1[1]:.4f} {c1[2]:.4f}\""
    },
    {
        "number": 3224,
        "checkpoint": "34B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(4):\n        x, y, z = map(int, stdin.split()[i].split())\n        points.append((x, y, z))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** 0.5\n\n    def center(p1, p2, p3):\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        x3, y3, z3 = p3\n\n        a = x2 - x1\n        b = y2 - y1\n        c = z2 - z1\n\n        d = x3 - x1\n        e = y3 - y1\n        f = z3 - z1\n\n        g = a * (x1 + x2) + b * (y1 + y2) + c * (z1 + z2)\n        h = d * (x1 + x3) + e * (y1 + y3) + f * (z1 + z3)\n        k = (a * (y1 - y2) + b * (x2 - x1)) * (x3 - x1) + (c * (x2 - x1) + a * (z1 - z2)) * (z3 - z1) + (b * (z1 - z2) + c * (y2 - y1)) * (y3 - y1)\n\n        x = (f * g - h * k) / (2 * ((a * (y1 - y2) + b * (x2 - x1)) * (c * (y3 - y1) + a * (z1 - z3)) - (b * (z1 - z2) + c * (y2 - y1)) * (c * (y3 - y1) + a * (z3 - z1)) + (a * (x1 - x2) + c * (z2 - z1)) * (c * (y3 - y1) + a * (z1 - z3))))\n        y = (e * g - h * k) / (2 * ((a * (y1 - y2) + b * (x2 - x1)) * (c * (y3 - y1) + a * (z1 - z3)) - (b * (z1 - z2) + c * (y2 - y1)) * (c * (y3 - y1) + a * (z3 - z1)) + (a * (x1 - x2) + c * (z2 - z1)) * (c * (y3 - y1) + a * (z1 - z3))))\n        z = (d * g - h * k) / (2 * ((a * (y1 - y2) + b * (x2 - x1)) * (c * (y3 - y1) + a * (z1 - z3)) - (b * (z1 - z2) + c * (y2 - y1)) * (c * (y3 - y1) + a * (z3 - z1)) + (a * (x1 - x2) + c * (z2 - z1)) * (c * (y3 - y1) + a * (z1 - z3))))\n\n        return (x, y, z)\n\n    def touching_points(p1, p2, p3, p4, c):\n        return distance(c, p1) == distance(c, p2) and distance(c, p2) == distance(c, p3) and distance(c, p3) == distance(c, p4)\n\n    def find_center(p1, p2, p3, p4):\n        c1 = center(p1, p2, p3)\n        if touching_points(p1, p2, p3, p4, c1):\n            return c1\n        c2 = center(p1, p2, p4)\n        if touching_points(p1, p2, p3, p4, c2):\n            return c2\n        c3 = center(p1, p3, p4)\n        if touching_points(p1, p2,"
    },
    {
        "number": 3224,
        "checkpoint": "34B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(4):\n        line = stdin.split('\\n')[i]\n        x, y, z = map(int, line.split())\n        points.append((x, y, z))\n\n    # Calculate the matrix of pairwise distances\n    distances = [[0] * 4 for _ in range(4)]\n    for i in range(4):\n        for j in range(i + 1, 4):\n            distance = (points[i][0] - points[j][0]) ** 2 \\\n                     + (points[i][1] - points[j][1]) ** 2 \\\n                     + (points[i][2] - points[j][2]) ** 2\n            distances[i][j] = distance\n            distances[j][i] = distance\n\n    # Calculate the minor matrices and the volume\n    volume = 0\n    for i in range(4):\n        minor_matrix = distances.copy()\n        for j in range(4):\n            if j == i:\n                continue\n            minor_matrix.pop(j)\n            for k in range(3):\n                minor_matrix[k] = minor_matrix[k][:i] + minor_matrix[k][i+1:]\n\n        volume += ((-1) ** i) * det(minor_matrix)\n\n    volume /= 6\n\n    # Calculate the radius and the centre of the sphere\n    radius = abs(volume) ** (1/3)\n    centre = []\n    for i in range(3):\n        coordinate = sum(points[j][i] for j in range(4)) / 4\n        centre.append(coordinate)\n\n    return ' '.join(map(str, centre))\n\ndef"
    },
    {
        "number": 3224,
        "checkpoint": "34B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(4):\n        x, y, z = map(int, stdin.split())\n        points.append((x, y, z))\n\n    # Calculate the centre of the sphere\n    x_c = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4\n    y_c = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4\n    z_c = (points[0][2] + points[1][2] + points[2][2] + points[3][2]) / 4\n\n    # Calculate the radius of the sphere\n    r = ((x_c - points[0][0]) ** 2 + (y_c - points[0][1]) ** 2 + (z_c - points[0][2]) ** 2) ** 0.5\n\n    # Return the coordinates of the centre\n    return f\"{x_c} {y_c} {z_c}\""
    },
    {
        "number": 3224,
        "checkpoint": "34B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(4):\n        x, y, z = map(int, stdin.split())\n        points.append((x, y, z))\n    \n    # Find the plane formed by the first three points\n    p1, p2, p3 = points[:3]\n    n = tuple(np.cross(np.subtract(p2, p1), np.subtract(p3, p1)))\n    \n    # Calculate the distance of the fourth point from the plane\n    d = abs(np.dot(n, np.subtract(points[3], p1))) / np.linalg.norm(n)\n    \n    # Calculate the centre of the sphere\n    x_c = (np.dot(np.add(points[0], points[1]), np.add(points[2], points[3])) - d * n[0]) / 4\n    y_c = (np.dot(np.add(points[0], points[1]), np.add(points[2], points[3])) - d * n[1]) / 4\n    z_c = (np.dot(np.add(points[0], points[1]), np.add(points[2], points[3])) - d * n[2]) / 4\n    \n    # Round the coordinates to 4 decimal places\n    x_c = round(x_c, 4)\n    y_c = round(y_c, 4)\n    z_c = round(z_c, 4)\n    \n    return f\"{x_c} {y_c} {z_c}\\n\""
    },
    {
        "number": 3224,
        "checkpoint": "34B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(4):\n        x, y, z = map(int, stdin.readline().split())\n        points.append((x, y, z))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def center(p1, p2, p3):\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        x3, y3, z3 = p3\n        A = x2 * (y1 - y3) + x1 * (y3 - y2) + x3 * (y2 - y1)\n        B = (x2 ** 2 + y2 ** 2 + z2 ** 2) * (y1 - y3) + \\\n            (x1 ** 2 + y1 ** 2 + z1 ** 2) * (y3 - y2) + \\\n            (x3 ** 2 + y3 ** 2 + z3 ** 2) * (y2 - y1)\n        C = (x2 * z1 + x1 * z3 + x3 * z2) * (y1 - y3) + \\\n            (x1 * z2 + x2 * z3 + x3 * z1) * (y3 - y2) + \\\n            (x2 * z3 + x3 * z1 + x1 * z2) * (y2 - y1)\n        D = (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) ** 2 + \\\n            (y1 * (z2 - z3) + y2 * (z3 - z1) + y3 * (z1 - z2)) ** 2 + \\\n            (z1 * (x2 - x3) + z2 * (x3 - x1) + z3 * (x1 - x2)) ** 2\n        return (-B / (2 * A), -C / (2 * A), -D / (2 * A))\n\n    def sphere_center(p1, p2, p3, p4):\n        c1 = center(p1, p2, p3)\n        c2 = center(p1, p3, p4)\n        c3 = center(p1, p2, p4)\n        c4 = center(p2, p3, p4)\n        return center(c1, c2, c3, c4)\n\n    return \"{:.4f} {:.4f} {:.4f}\".format(*sphere_center(*points))"
    },
    {
        "number": 3224,
        "checkpoint": "34B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for _ in range(4):\n        x, y, z = map(int, stdin.readline().split())\n        points.append((x, y, z))\n    \n    p1, p2, p3, p4 = points\n    p1p2 = (p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2])\n    p1p3 = (p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2])\n    p1p4 = (p4[0] - p1[0], p4[1] - p1[1], p4[2] - p1[2])\n    \n    n1 = (p1p2[1] * p1p3[2] - p1p2[2] * p1p3[1],\n          p1p2[2] * p1p3[0] - p1p2[0] * p1p3[2],\n          p1p2[0] * p1p3[1] - p1p2[1] * p1p3[0])\n    \n    n2 = (p1p3[1] * p1p4[2] - p1p3[2] * p1p4[1],\n          p1p3[2] * p1p4[0] - p1p3[0] * p1p4[2],\n          p1p3[0] * p1p4[1] - p1p3[1] * p1p4[0])\n    \n    n3 = (p1p4[1] * p1p2[2] - p1p4[2] * p1p2[1],\n          p1p4[2] * p1p2[0] - p1p4[0] * p1p2[2],\n          p1p4[0] * p1p2[1] - p1p4[1] * p1p2[0])\n    \n    x_c = (n1[1] * (p1p4[2] * p1p3[0] - p1p4[0] * p1p3[2]) -\n           n1[2] * (p1p4[1] * p1p3[0] - p1p4[0] * p1p3[1]) +\n           n1[0] * (p1p4[1] * p1p3[2] - p1p4[2] * p1p3[1])) / ((p1p2[1] * p1p3[2] - p1p2[2] * p1p3[1])**2 + (p1p2[2] * p1p3[0] - p1p2[0] * p1p3[2])**2 + (p1p2[0] * p1p3[1] - p1p2[1] * p1p3[0])**2)\n    \n    y_c = (n2[1] * (p1p4[2] * p1p3[0] - p1p4[0] * p1p3[2]) -\n           n2[2] * (p1p4[1] * p1p3[0] - p1p4[0] * p1p3[1]) +\n           n2[0] * (p1p4[1] * p1p3[2] - p1p4[2] * p1p3[1])) / ((p1p3[1] * p1p4[2] - p1p3[2] * p1p4[1])**2 + (p1p3[2] * p1p4[0] - p1p3[0] * p1p4[2])**2 + (p1p3[0] * p1p4[1] - p1p3[1] * p1p4[0])**2)\n    \n    z_c = (n3[1] * (p1p4[2] * p1p3[0] - p1p4[0] * p1p3[2]) -\n           n3["
    }
]