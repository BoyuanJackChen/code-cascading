[
    {
        "number": 3000,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    tokens = stdin.split(\"\\n\")[1].split()\n    modulo = 10**9 + 7\n\n    def evaluate(tokens):\n        stack = []\n        for token in tokens:\n            if token == \"(\":\n                stack.append(\"(\")\n            elif token == \")\":\n                sub_sequence = []\n                while stack[-1] != \"(\":\n                    sub_sequence.append(stack.pop())\n                stack.pop()  # Remove the opening parenthesis\n                sub_sequence.reverse()\n                stack.append(evaluate(sub_sequence))\n            else:\n                stack.append(int(token))\n        return stack[0]\n\n    return str(evaluate(tokens) % modulo)"
    },
    {
        "number": 3001,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(num: str) -> bool:\n        return num == num[::-1]\n\n    def increment_counter(counter: List[int]) -> None:\n        carry = 1\n        for i in range(len(counter) - 1, -1, -1):\n            counter[i] += carry\n            carry = 1 if counter[i] > 9 else 0\n            counter[i] %= 10\n\n    def find_min_steps(counter: List[int]) -> int:\n        steps = 0\n        while not is_palindrome(str(counter)):\n            increment_counter(counter)\n            steps += 1\n        return steps\n\n    counter = [int(digit) for digit in stdin]\n    return str(find_min_steps(counter))"
    },
    {
        "number": 3002,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered(entries):\n        for i in range(1, len(entries)):\n            year, month, odometer = entries[i]\n            prev_year, prev_month, prev_odometer = entries[i - 1]\n            if prev_odometer > odometer:\n                return True\n        return False\n\n    def is_serviced(entries):\n        last_service = (1950, 1, 0)\n        for year, month, odometer in entries:\n            if year - last_service[0] > 12 or (year - last_service[0] == 12 and month < last_service[1]):\n                return False\n            last_service = (year, month, odometer)\n        return True\n\n    entries = []\n    for line in stdin.split('\\n')[1:]:\n        year, month, odometer = map(int, line.split())\n        entries.append((year, month, odometer))\n\n    if is_tampered(entries):\n        return \"tampered odometer\"\n    elif is_serviced(entries):\n        return \"seems legit\"\n    else:\n        return \"insufficient service\""
    },
    {
        "number": 3003,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    num_vertices = int(lines[0])\n    adjacency_list = [set() for _ in range(num_vertices)]\n    for i in range(num_vertices):\n        for j in map(int, lines[i + 1].split()):\n            adjacency_list[i].add(j)\n            adjacency_list[j].add(i)\n\n    def dfs(vertex, color, colors):\n        colors[vertex] = color\n        for neighbor in adjacency_list[vertex]:\n            if colors[neighbor] == color:\n                return False\n            if colors[neighbor] is None and not dfs(neighbor, (color + 1) % 2, colors):\n                return False\n        return True\n\n    colors = [None] * num_vertices\n    if not dfs(0, 0, colors):\n        return 3\n\n    return sum(colors) + 1"
    },
    {
        "number": 3004,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(colors):\n        if len(colors) > 3:\n            return False\n        for color in colors:\n            if colors.count(color) > 1:\n                return False\n        return True\n\n    def paint_fence(offers, colors):\n        for offer in offers:\n            color, start, end = offer\n            if color not in colors:\n                colors.append(color)\n            if not is_valid(colors):\n                return False\n            for i in range(start, end + 1):\n                if i not in painted_sections:\n                    painted_sections.add(i)\n        return True\n\n    def backtrack(offers, colors, count):\n        if len(painted_sections) == 10000:\n            return min(count, backtrack.min_count)\n        if not offers:\n            if len(painted_sections) == 10000 and is_valid(colors):\n                backtrack.min_count = min(count, backtrack.min_count)\n            return backtrack.min_count\n\n        if not colors or (len(colors) < 3 and len(offers) > 1):\n            for i in range(len(offers)):\n                if paint_fence(offers[:i] + offers[i+1:], colors):\n                    backtrack.min_count = min(backtrack(offers[:i] + offers[i+1:], colors, count + 1), backtrack.min_count)\n        return backtrack.min_count\n\n    N = int(stdin.readline().strip())\n    offers = [tuple(stdin.readline().strip().split()) for _ in range(N)]\n    colors = []\n    painted_sections = set()\n    backtrack.min_count = float('inf')\n\n    result = backtrack(offers, colors, 0)\n    return str(result) if result != float('inf') else \"IMPOSSIBLE\" "
    },
    {
        "number": 3005,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def factor(s):\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0 and s[:i] * n // i == s:\n                return i\n        return n\n\n    def factoring(s):\n        n = len(s)\n        res = []\n        i = 0\n        while i < n:\n            j = factor(s[i:])\n            res.append(s[i:i + j])\n            i += j\n        return res\n\n    def irreducible_factoring(s):\n        fct = factoring(s)\n        res = []\n        i = 0\n        while i < len(fct):\n            if i + 1 < len(fct) and fct[i] == fct[i + 1]:\n                res.append(fct[i] * 2)\n                i += 2\n            else:\n                res.append(fct[i])\n                i += 1\n        return res\n\n    def weight(fct):\n        return sum(len(s) for s in fct)\n\n    fct = irreducible_factoring(stdin)\n    return str(weight(fct))"
    },
    {
        "number": 3006,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_operation(line: str) -> tuple:\n        if line[0] == 'D':\n            return ('D', int(line.split()[1]))\n        elif line[0] == 'I':\n            parts = line.split()\n            return ('I', int(parts[1]), parts[2])\n        else:\n            return ('E',)\n\n    def apply_operation(operation: tuple, string: str) -> str:\n        if operation[0] == 'D':\n            return string[:operation[1] - 1] + string[operation[1]:]\n        elif operation[0] == 'I':\n            return string[:operation[1] - 1] + operation[2] + string[operation[1] - 1:]\n        else:\n            return string\n\n    def compare_programs(program1: list, program2: list) -> bool:\n        string = ''\n        for i in range(len(program1)):\n            if program1[i][0] == 'E' and program2[i][0] == 'E':\n                return True\n            elif program1[i][0] == 'E' or program2[i][0] == 'E':\n                return False\n            else:\n                string = apply_operation(program1[i], string)\n                if string != apply_operation(program2[i], string):\n                    return False\n        return True\n\n    programs = []\n    for i in range(2):\n        program = []\n        while True:\n            line = stdin.readline().strip()\n            if not line:\n                break\n            operation = parse_operation(line)\n            if operation[0] != 'E':\n                program.append(operation)\n        programs.append(program)\n\n    return '1' if compare_programs(programs[0], programs[1]) else '0'"
    },
    {
        "number": 3007,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Calculate the maximum amount of Bling that can be earned in the remaining days\n    max_bling = b + f * 100 + t0 * 100 + t1 * 100 + t2 * 100\n\n    # Calculate the maximum amount of Bling that can be earned by planting exotic fruit trees\n    max_exotic_trees = min(d // 3, (500 - max_bling) // 1500)\n    max_bling += max_exotic_trees * 1500\n\n    # Calculate the maximum amount of Bling that can be earned by buying exotic fruits\n    max_exotic_fruits = (500 - max_bling) // 500\n    max_bling += max_exotic_fruits * 500\n\n    return str(max_bling)"
    },
    {
        "number": 3008,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    ranks = set()\n    for i in range(N):\n        rank = 1\n        for j in range(i):\n            if a[i] + K < a[j] or b[i] + K < b[j]:\n                rank = max(rank, ranks.get(j, 0) + 1)\n        ranks.add(i, rank)\n\n    return len(ranks)"
    },
    {
        "number": 3009,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x1, y1, e1, x2, y2, e2):\n        return (x1 != x2 or y1 != y2) and (e1 * e2 <= 0)\n\n    def find_line(x1, y1, e1, x2, y2, e2):\n        if e1 == 0 or e2 == 0:\n            return 0\n        if e1 * e2 > 0:\n            return float('inf')\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def floyd_warshall(n, dist):\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    def find_balance_line(N, lamps):\n        n = len(lamps)\n        dist = [[float('inf')] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1, e1 = lamps[i]\n                x2, y2, e2 = lamps[j]\n                if is_valid(x1, y1, e1, x2, y2, e2):\n                    dist[i][j] = find_line(x1, y1, e1, x2, y2, e2)\n                    dist[j][i] = dist[i][j]\n\n        floyd_warshall(n, dist)\n\n        min_length = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1, e1 = lamps[i]\n                x2, y2, e2 = lamps[j]\n                if is_valid(x1, y1, e1, x2, y2, e2):\n                    min_length = min(min_length, dist[i][j])\n\n        return min_length if min_length != float('inf') else \"IMPOSSIBLE\"\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    lamps = [list(map(int, line.split())) for line in lines[1:]]\n\n    return find_balance_line(N, lamps)"
    },
    {
        "number": 3010,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lines = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    points = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            x0, y0, x1, y1 = lines[i]\n            x2, y2, x3, y3 = lines[j]\n\n            if (x1 - x0) * (y3 - y2) == (y1 - y0) * (x3 - x2):\n                continue\n\n            if (x1 - x0) == 0:\n                x = x0\n                y = y2 + (y3 - y2) * (x - x2) / (x3 - x2)\n            elif (x3 - x2) == 0:\n                x = x2\n                y = y0 + (y1 - y0) * (x - x0) / (x1 - x0)\n            else:\n                k1 = (x1 - x0) / (y1 - y0)\n                k2 = (x3 - x2) / (y3 - y2)\n                x = (k1 * x0 - k2 * x2 + y2 - y0) / (k1 - k2)\n                y = k1 * (x - x0) + y0\n\n            points.add((x, y))\n\n    return len(points) if len(points) != float('inf') else -1"
    },
    {
        "number": 3011,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        if is_hill_number(i):\n            count += 1\n    if count == n:\n        return str(count)\n    else:\n        return \"-1\"\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    mod = 1000000007\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    if a11 + a12 + a21 + a22 == 0 or N == 0:\n        return \"0\"\n\n    dp = [[0] * (a11 + a12 + a21 + a22 + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, N + 1):\n        for j in range(1, a11 + a12 + a21 + a22 + 1):\n            if j == 1:\n                dp[i][j] = dp[i - 1][j + 1] % mod\n            elif j == a11 + a12 + 1:\n                dp[i][j] = dp[i - 1][j + 1] % mod\n            elif j == a11 + a12 + a21 + 1:\n                dp[i][j] = dp[i - 1][j + 1] % mod\n            else:\n                dp[i][j] = (dp[i - 1][j + 1] + dp[i - 1][j]) % mod\n\n    return str(dp[N][1])"
    },
    {
        "number": 3013,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n\n    def polar_to_cartesian(r, phi):\n        return r * cos(phi), r * sin(phi)\n\n    def archimedes_spiral(b, x, y):\n        r = b * phi\n        return polar_to_cartesian(r, phi)\n\n    def distance(x1, y1, x2, y2):\n        return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n    def find_intersection_point(b, x, y, target_x, target_y):\n        phi = 0\n        d = 2 * pi * b\n        while distance(*archimedes_spiral(b, x, y), target_x, target_y) > 1e-3:\n            phi += d / r if r != 0 else 0.01\n            x, y = polar_to_cartesian(r, phi)\n            r = b * phi\n        return x, y\n\n    x, y = find_intersection_point(b, 0, 0, t_x, t_y)\n    return f\"{x:.9f} {y:.9f}\""
    },
    {
        "number": 3014,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, visited, rec_stack, start, node):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, rec_stack, start, neighbor):\n                    return True\n            elif rec_stack[neighbor] and neighbor != start:\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    def remove_cycle(graph, visited, rec_stack, start, node):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if remove_cycle(graph, visited, rec_stack, start, neighbor):\n                    if start in graph[node] and node in graph[start]:\n                        graph[node].remove(start)\n                        graph[start].remove(node)\n                    return True\n            elif rec_stack[neighbor] and neighbor != start:\n                if start in graph[node] and node in graph[start]:\n                    graph[node].remove(start)\n                    graph[start].remove(node)\n                return True\n\n        rec_stack[node] = False\n        return False\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    graph = [[] for _ in range(n + 1)]\n\n    for i in range(1, m + 1):\n        u, v = map(int, lines[i].split())\n        graph[u].append(v)\n\n    visited = [False] * (n + 1)\n    rec_stack = [False] * (n + 1)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            find_cycle(graph, visited, rec_stack, i, i)\n\n    visited = [False] * (n + 1)\n    rec_stack = [False] * (n + 1)\n    removed = 0\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if remove_cycle(graph, visited, rec_stack, i, i):\n                removed += 1\n\n    result = [str(removed)]\n\n    for i in range(1, m + 1):\n        u, v = map(int, lines[i].split())\n        if v not in graph[u]:\n            result.append(str(i))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3015,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = [False] * len(graph)\n        distances = [float('inf')] * len(graph)\n        distances[start] = 0\n        while not visited[end]:\n            min_distance = float('inf')\n            min_node = -1\n            for i in range(len(graph)):\n                if not visited[i] and distances[i] < min_distance:\n                    min_distance = distances[i]\n                    min_node = i\n            if min_node == -1:\n                return float('inf')\n            visited[min_node] = True\n            for neighbor, weight in graph[min_node]:\n                if not visited[neighbor]:\n                    distance = min_distance + weight\n                    if distance < distances[neighbor]:\n                        distances[neighbor] = distance\n        return distances[end]\n\n    def build_graph(tubes):\n        graph = [[] for _ in range(n)]\n        for tube in tubes:\n            graph[tube[0]].append((tube[1], tube[2]))\n        return graph\n\n    n, m, s, t = map(int, stdin.split())\n    tubes = [list(map(int, input().split())) for _ in range(m)]\n\n    graph = build_graph(tubes)\n    time = dijkstra(graph, s, t)\n\n    return str(time) if time != float('inf') else 'infinity'"
    },
    {
        "number": 3016,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(balls: list, k: int, c: list, l: int, s: list) -> int:\n        mod = 1000000007\n        n = len(balls)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = balls[i]\n\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                for x in range(i, j):\n                    if k > 0 and (balls[i] in c or balls[j] in c):\n                        continue\n                    dp[i][j] += dp[i][x] * dp[x + 1][j]\n                dp[i][j] %= mod\n\n        if l == 0:\n            return dp[0][n - 1]\n\n        for i in range(n - l + 1):\n            if set(s) <= set(balls[i:i + l]):\n                balls[i:i + l] = []\n                break\n\n        return count_ways(balls, k, c, 0, [])\n\n    n, *balls = list(map(int, stdin.split()))\n    k, *c = list(map(int, input().split()))\n    c = c[:k]\n    l, *s = list(map(int, input().split()))\n    s = s[:l]\n\n    return str(count_ways(balls, k, c, l, s))"
    },
    {
        "number": 3017,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n + 1):\n        if str(2**e) in str(i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3018,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    dice_values = list(map(int, input().split()))\n    total_dice = len(dice_values)\n    max_prob = 0\n    max_pickup = 0\n\n    for pickup in range(total_dice + 1):\n        prob = 0\n        for i in range(pickup):\n            for j in range(1, 7):\n                if dice_values[i] == j:\n                    prob += 1 / 6\n        for i in range(pickup, total_dice):\n            for j in range(1, 7):\n                if dice_values[i] == j:\n                    prob += 1 / 6\n        if T - sum(dice_values) <= 6 * pickup:\n            prob += 1\n        if prob > max_prob:\n            max_prob = prob\n            max_pickup = pickup\n\n    return str(max_pickup)"
    },
    {
        "number": 3019,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    S = list(map(int, stdin.split('\\n')[1].split()))\n    max_revenue = 0\n\n    for i in range(1, N + 1):\n        revenue = 0\n        for j in range(1, i + 1):\n            prime_factors = set(factorize(j))\n            revenue += len(prime_factors)\n        max_revenue = max(max_revenue, revenue)\n\n    return str(max_revenue)\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"-1\"\n    for i in range(1, int(n**0.5) + 1):\n        if i**2 == n:\n            return str(i)\n    for i in range(2, int(n**0.5) + 1):\n        j = n // i\n        if i * j == n:\n            return str(i)\n    return \"-1\""
    },
    {
        "number": 3021,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_consistent(order, words):\n        for i in range(len(words) - 1):\n            if not is_ordered(order, words[i], words[i + 1]):\n                return False\n        return True\n\n    def is_ordered(order, word1, word2):\n        for i in range(min(len(word1), len(word2))):\n            if order.index(word1[i]) < order.index(word2[i]):\n                return True\n            elif order.index(word1[i]) > order.index(word2[i]):\n                return False\n        return len(word1) <= len(word2)\n\n    def find_order(words):\n        order = list(\"abcdefghijklmnopqrstuvwxyz\")[:L]\n        for i in range(len(order)):\n            for j in range(i + 1, len(order)):\n                if is_ordered(order, words[0], words[1]) and order[i] > order[j]:\n                    order[i], order[j] = order[j], order[i]\n        return \"\".join(order)\n\n    def is_ambiguous(words):\n        for i in range(len(words) - 1):\n            for j in range(i + 1, len(words)):\n                if not is_ordered(list(\"abcdefghijklmnopqrstuvwxyz\")[:L], words[i], words[j]):\n                    return True\n        return False\n\n    lines = stdin.split(\"\\n\")\n    L, N = map(int, lines[0].split())\n    words = lines[1:]\n\n    if is_ambiguous(words):\n        return \"AMBIGUOUS\"\n\n    for order in permutations(list(\"abcdefghijklmnopqrstuvwxyz\")[:L]):\n        if is_consistent(order, words):\n            return find_order(words)\n\n    return \"IMPOSSIBLE\"\n\nfrom itertools import permutations"
    },
    {
        "number": 3022,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    min_cookies_per_person = total_cookies // N\n\n    almond_biscuits_left = A\n    butter_cookies_left = B\n    chocolate_macarons_left = C\n\n    cookies_distributed = 0\n\n    for _ in range(N):\n        cookies_given = min_cookies_per_person\n        cookies_distributed += cookies_given\n\n        if almond_biscuits_left > 0:\n            almond_biscuits_left -= 1\n        elif butter_cookies_left > 0:\n            butter_cookies_left -= 1\n        elif chocolate_macarons_left > 0:\n            chocolate_macarons_left -= 1\n\n    return str(cookies_distributed)"
    },
    {
        "number": 3023,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_cake(x, y, r):\n        return x ** 2 + y ** 2 <= r ** 2\n\n    def is_on_line(a, b, c, x, y):\n        return abs(a * x + b * y + c) < 1e-4\n\n    def is_valid_cut(a, b, c, r):\n        for x, y in candles:\n            if is_inside_cake(x, y, r) and is_on_line(a, b, c, x, y):\n                return False\n        return True\n\n    def has_valid_cuts(n, m, r):\n        for a, b, c in cuts:\n            if is_valid_cut(a, b, c, r):\n                return True\n        return False\n\n    lines = stdin.split('\\n')\n    n, m, r = map(int, lines[0].split())\n    candles = [tuple(map(int, lines[i + 1].split())) for i in range(n)]\n    cuts = [tuple(map(int, lines[i + n + 1].split())) for i in range(m)]\n\n    if has_valid_cuts(n, m, r):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3024,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if stdin[i] == stdin[j]:\n                if j - i == 1 or dp[i + 1][j - 1]:\n                    dp[i][j] = 1\n    for k in range(1, n + 1):\n        for i in range(n - k + 1):\n            j = i + k - 1\n            if dp[i][j] and stdin[i:j + 1] == stdin[i:j + 1][::-1]:\n                return str(k)\n    return \"1\""
    },
    {
        "number": 3025,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited, graph, amount):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                amount = dfs(neighbor, visited, graph, amount)\n        return amount + gold[start - 1]\n\n    def bfs(start, visited, graph, amount):\n        queue = [(start, amount)]\n        while queue:\n            node, amount = queue.pop(0)\n            if node == 1:\n                return amount\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    queue.append((neighbor, amount + gold[neighbor - 1]))\n        return 0\n\n    n, m = map(int, stdin.readline().split())\n    gold = list(map(int, stdin.readline().split()))\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (n + 1)\n    max_gold = dfs(2, visited, graph, 0)\n    visited = [False] * (n + 1)\n    max_gold = max(max_gold, bfs(2, visited, graph, 0))\n\n    return str(max_gold)"
    },
    {
        "number": 3026,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = sorted(list(map(int, stdin.split('\\n')[1].split())))\n    lis = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[j] < sequence[i] and lis[j] + 1 > lis[i]:\n                lis[i] = lis[j] + 1\n\n    critical_elements = []\n    for i in range(n):\n        if lis[i] == 1 and sequence[i] != 1:\n            critical_elements.append(sequence[i])\n\n    if critical_elements:\n        return ' '.join(map(str, sorted(critical_elements)))\n    else:\n        return \"-1\""
    },
    {
        "number": 3027,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    paper = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def count_nubs(stamp_height, stamp_width):\n        nubs = 0\n        for i in range(n - stamp_height + 1):\n            for j in range(m - stamp_width + 1):\n                for k in range(i, i + stamp_height):\n                    for l in range(j, j + stamp_width):\n                        if paper[k][l] == '#':\n                            nubs += 1\n        return nubs\n\n    min_nubs = float('inf')\n    for stamp_height in range(1, n + 1):\n        for stamp_width in range(1, m + 1):\n            if stamp_height * stamp_width <= min_nubs:\n                nubs = count_nubs(stamp_height, stamp_width)\n                if nubs <= min_nubs:\n                    min_nubs = nubs\n\n    return str(min_nubs)"
    },
    {
        "number": 3028,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(board: List[List[int]], n: int, m: int, p: int) -> bool:\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    return False\n        return True\n\n    def find_moves(board: List[List[int]], n: int, m: int, p: int) -> List[int]:\n        moves = []\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    moves.append((i, j))\n        return moves\n\n    def play_move(board: List[List[int]], n: int, m: int, p: int, move: Tuple[int, int]) -> None:\n        row, col = move\n        for i in range(n):\n            if board[i][col] != p:\n                board[i][col] += 1\n                if board[i][col] > p:\n                    board[i][col] = 1\n        for j in range(m):\n            if board[row][j] != p:\n                board[row][j] += 1\n                if board[row][j] > p:\n                    board[row][j] = 1\n\n    def solve(board: List[List[int]], n: int, m: int, p: int) -> List[int]:\n        moves = find_moves(board, n, m, p)\n        for move in moves:\n            play_move(board, n, m, p, move)\n            if is_valid(board, n, m, p):\n                return [move[0] * m + move[1] + 1]\n            else:\n                result = solve(board, n, m, p)\n                if result:\n                    return [move[0] * m + move[1] + 1] + result\n                else:\n                    play_move(board, n, m, p, move)\n        return []\n\n    n, m, p = map(int, stdin.split())\n    board = [list(map(int, input().split())) for _ in range(n)]\n\n    if is_valid(board, n, m, p):\n        return \"-1\"\n    else:\n        result = solve(board, n, m, p)\n        return f\"{len(result)}\\n{' '.join(map(str, result))}\" "
    },
    {
        "number": 3029,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def build_tree(parents):\n        tree = [[] for _ in range(len(parents) + 1)]\n        for i, parent in enumerate(parents, start=2):\n            tree[parent].append(i)\n        return tree\n\n    def dfs(tree, vertex, depth, labels, nondecreasing_labels):\n        nondecreasing_labels[vertex] = labels[vertex]\n        for child in tree[vertex]:\n            dfs(tree, child, depth + 1, labels, nondecreasing_labels)\n            nondecreasing_labels[vertex] = max(nondecreasing_labels[vertex], nondecreasing_labels[child])\n\n    def find_longest_jumping_path(tree, labels, nondecreasing_labels):\n        longest_path = 0\n        count = [0] * (len(labels) + 1)\n        count[1] = 1\n\n        for i in range(2, len(labels) + 1):\n            for child in tree[i]:\n                if nondecreasing_labels[child] >= nondecreasing_labels[i]:\n                    longest_path = max(longest_path, count[child] + 1)\n            count[i] = sum(count[child] for child in tree[i] if nondecreasing_labels[child] >= nondecreasing_labels[i])\n\n        return longest_path, count[len(labels)]\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    labels = [int(line) for line in lines[1:N + 1]]\n    parents = [int(line) for line in lines[N + 1:]]\n\n    tree = build_tree(parents)\n    nondecreasing_labels = [0] * (N + 1)\n    dfs(tree, 1, 0, labels, nondecreasing_labels)\n    longest_path, count = find_longest_jumping_path(tree, labels, nondecreasing_labels)\n\n    return f\"{longest_path} {count % 11092019}\""
    },
    {
        "number": 3030,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    nodes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    nodes.sort(key=lambda x: x[0], reverse=True)\n\n    def is_ancestor(i, j):\n        while j != 0:\n            if j == i:\n                return True\n            j = nodes[j][1]\n        return False\n\n    def find_max_subset(i):\n        max_subset = [i]\n        for j in range(i + 1, n):\n            if nodes[j][0] > nodes[i][0] and not is_ancestor(i, j):\n                max_subset.append(j)\n        return max_subset\n\n    max_subset = find_max_subset(0)\n    for i in range(1, n):\n        if i not in max_subset:\n            continue\n        new_subset = find_max_subset(i)\n        if len(new_subset) > len(max_subset):\n            max_subset = new_subset\n\n    return str(len(max_subset))"
    },
    {
        "number": 3031,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_rainbow(path):\n        colors = set()\n        for edge in path:\n            if edge[2] in colors:\n                return False\n            colors.add(edge[2])\n        return True\n\n    def find_good_nodes(node, parent):\n        good_nodes.add(node)\n        for neighbor, color in tree[node]:\n            if neighbor != parent:\n                path = tree[node][tree[node].index((neighbor, color))]\n                if is_rainbow([path]):\n                    find_good_nodes(neighbor, node)\n\n    n = int(stdin.readline().strip())\n    tree = {i: [] for i in range(1, n + 1)}\n\n    for i in range(n - 1):\n        a, b, c = map(int, stdin.readline().strip().split())\n        tree[a].append((b, c))\n        tree[b].append((a, c))\n\n    good_nodes = set()\n    find_good_nodes(1, None)\n\n    return f\"{len(good_nodes)}\\n\" + \"\\n\".join(map(str, sorted(good_nodes)))"
    },
    {
        "number": 3032,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.readline().split())\n    program = stdin.readline().split()\n\n    def parse_program(program, variables):\n        instructions = 0\n        for token in program:\n            if token.startswith(\"V\"):\n                i = int(token[1:])\n                bank, offset = variables[i]\n                if bank == 0:\n                    instructions += 1\n                else:\n                    instructions += 2\n            elif token.startswith(\"R\"):\n                n = int(token[1:-1])\n                body, body_instructions = parse_program(program, variables)\n                instructions += n * body_instructions\n                program = program[len(body):]\n            else:\n                program = program[1:]\n        return instructions\n\n    def find_min_mapping(b, s):\n        min_instructions = float(\"inf\")\n        for mapping in itertools.permutations(range(b * s)):\n            variables = {}\n            for i, var in enumerate(mapping):\n                bank = var // s\n                offset = var % s\n                variables[i + 1] = (bank, offset)\n            instructions = parse_program(program, variables)\n            min_instructions = min(min_instructions, instructions)\n        return min_instructions\n\n    return str(find_min_mapping(b, s))"
    },
    {
        "number": 3033,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    X = 0\n    for i in range(1, N + 1):\n        if f(i, B) == N:\n            X = i\n            break\n    return str(X) if X else \"impossible\"\n\ndef"
    },
    {
        "number": 3034,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_roof_coverage(roofs, distance):\n        coverage = [0] * (distance + 1)\n        for start, end in roofs:\n            for i in range(start, end):\n                coverage[i] += 1\n        return coverage\n\n    def get_expected_rain(clouds, distance, time, roof_coverage):\n        expected_rain = 0\n        for start, end, prob, amount in clouds:\n            for i in range(start, end):\n                if roof_coverage[min(i, distance)] > 0:\n                    expected_rain += prob * amount\n        return expected_rain\n\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    d, t, c, r = map(int, input_data[0].split())\n    clouds = [list(map(float, line.split())) for line in input_data[1:c + 1]]\n    roofs = [list(map(int, line.split())) for line in input_data[c + 1:]]\n\n    roof_coverage = get_roof_coverage(roofs, d)\n    expected_rain = get_expected_rain(clouds, d, t, roof_coverage)\n\n    return f\"{expected_rain:.5f}\""
    },
    {
        "number": 3035,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_blue_lemonade(N: int, offers: list) -> float:\n        max_blue_lemonade = 0\n        for offer in offers:\n            if offer[1] == \"blue\":\n                max_blue_lemonade += 1 / offer[2]\n            else:\n                max_blue_lemonade += offer[2]\n        return min(max_blue_lemonade, 10)\n\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    offers = []\n    for i in range(1, N + 1):\n        offer = lines[i].split()\n        offers.append((offer[0], offer[1], float(offer[2])))\n\n    max_blue_lemonade = get_max_blue_lemonade(N, offers)\n    return f\"{max_blue_lemonade:.10f}\""
    },
    {
        "number": 3036,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_dishes(dish_type, dish_count, incompatibility_list):\n        dishes = []\n        for _ in range(dish_count):\n            line = input().split()\n            ingredients = [int(x) for x in line[1:]]\n            dishes.append(ingredients)\n            for incompatible_dish in incompatibility_list:\n                if incompatible_dish[0] == len(dishes) + dish_type:\n                    incompatible_dish[1] = len(dishes) + dish_type\n                elif incompatible_dish[1] == len(dishes) + dish_type:\n                    incompatible_dish[0] = len(dishes) + dish_type\n        return dishes\n\n    def get_incompatibility_list(incompatibility_count):\n        incompatibility_list = []\n        for _ in range(incompatibility_count):\n            line = input().split()\n            incompatibility_list.append([int(x) for x in line])\n        return incompatibility_list\n\n    def get_dish_combinations(dishes, incompatibility_list):\n        combinations = 1\n        for i, dish in enumerate(dishes):\n            incompatible_dishes = [incompatible_dish[1] for incompatible_dish in incompatibility_list if incompatible_dish[0] == i + 1]\n            for j in range(i + 1, len(dishes)):\n                if j in incompatible_dishes:\n                    continue\n                if set(dish).isdisjoint(dishes[j]):\n                    combinations *= len(brands[dishes[j][0] - 1])\n        return combinations\n\n    # Read input\n    input_data = stdin.split('\\n')\n    input_iter = iter(input_data)\n\n    line = next(input_iter).split()\n    r, s, m, d, n = [int(x) for x in line]\n\n    line = next(input_iter).split()\n    b = [int(x) for x in line]\n\n    starter_dishes = get_dishes(0, s, [])\n    main_dishes = get_dishes(s, m, [])\n    dessert_dishes = get_dishes(s + m, d, [])\n    dishes = starter_dishes + main_dishes + dessert_dishes\n\n    incompatibility_list = get_incompatibility_list(n)\n\n    brands = [b] * r\n\n    # Calculate number of dinner experiences\n    dinner_experiences = get_dish_combinations(dishes, incompatibility_list)\n\n    # Check if the number of dinner experiences is too large\n    if dinner_experiences > 10**18:\n        return \"too many\"\n    else:\n        return str(dinner_experiences) "
    },
    {
        "number": 3037,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.readline().split())\n    board = [list(stdin.readline().strip()) for _ in range(h)]\n    commands = [stdin.readline().strip().split() for _ in range(n)]\n\n    def move(x, y, direction, distance):\n        if direction == \"up\":\n            return x - distance, y\n        elif direction == \"down\":\n            return x + distance, y\n        elif direction == \"left\":\n            return x, y - distance\n        elif direction == \"right\":\n            return x, y + distance\n\n    def draw(board, commands):\n        marker_x, marker_y = 0, 0\n        for command in commands:\n            direction, distance = command\n            distance = int(distance)\n            marker_x, marker_y = move(marker_x, marker_y, direction, distance)\n            if 0 <= marker_x < h and 0 <= marker_y < w:\n                board[marker_x][marker_y] = \"#\"\n            else:\n                break\n\n    draw(board, commands)\n\n    min_timestep = max_timestep = -1\n    for i in range(h):\n        for j in range(w):\n            if board[i][j] == \"#\":\n                max_timestep = max(max_timestep, i * w + j)\n                if min_timestep == -1:\n                    min_timestep = i * w + j\n            elif min_timestep == -1:\n                min_timestep = i * w + j + 1\n\n    return f\"{min_timestep} {max_timestep}\""
    },
    {
        "number": 3038,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_packet(bolts_needed, companies):\n        min_packet = float('inf')\n        for company in companies:\n            for i in range(len(company)):\n                if company[i] >= bolts_needed:\n                    min_packet = min(min_packet, company[i])\n        return min_packet if min_packet != float('inf') else 'impossible'\n\n    def process_input(stdin):\n        lines = stdin.split('\\n')\n        bolts_needed = int(lines[0])\n        k = int(lines[1])\n        companies = []\n        for i in range(2, 2 + k):\n            company = list(map(int, lines[i].split()))\n            l_i = company[0]\n            n_i = company[1:]\n            companies.append(n_i)\n        return bolts_needed, companies\n\n    bolts_needed, companies = process_input(stdin)\n    return find_min_packet(bolts_needed, companies) "
    },
    {
        "number": 3039,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_fold(matrix):\n        for i in range(6):\n            for j in range(6):\n                if matrix[i][j] == '#':\n                    if i < 3 and j < 3:\n                        if matrix[i + 3][j + 3] != '#':\n                            return False\n                        if matrix[i][j + 3] != '#':\n                            return False\n                        if matrix[i + 3][j] != '#':\n                            return False\n                    elif i < 3 and j >= 3:\n                        if matrix[i + 3][j - 3] != '#':\n                            return False\n                        if matrix[i][j - 3] != '#':\n                            return False\n                        if matrix[i + 3][j] != '#':\n                            return False\n                    elif i >= 3 and j < 3:\n                        if matrix[i - 3][j + 3] != '#':\n                            return False\n                        if matrix[i][j + 3] != '#':\n                            return False\n                        if matrix[i - 3][j] != '#':\n                            return False\n                    else:\n                        if matrix[i - 3][j - 3] != '#':\n                            return False\n                        if matrix[i][j - 3] != '#':\n                            return False\n                        if matrix[i - 3][j] != '#':\n                            return False\n        return True\n\n    matrix = []\n    for i in range(6):\n        row = []\n        for j in range(6):\n            if stdin[i][j] == '.':\n                row.append(0)\n            else:\n                row.append(1)\n        matrix.append(row)\n\n    if can_fold(matrix):\n        return 'can fold'\n    else:\n        return 'cannot fold'"
    },
    {
        "number": 3040,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    max_len = 0\n    max_substring = \"\"\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = stdin[i:j]\n            if len(substring) > max_len and stdin.count(substring) > 1:\n                max_len = len(substring)\n                max_substring = substring\n    return max_substring"
    },
    {
        "number": 3041,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    coupons = 0\n    trips = []\n    for line in stdin.split('\\n')[1:]:\n        zone, time = map(int, line.split())\n        trips.append((zone, time))\n\n    current_ticket = [0, 0]\n    for trip in trips:\n        if trip[1] - current_ticket[1] > 10000:\n            coupons += 2 + abs(current_ticket[0] - current_ticket[1])\n            current_ticket = [trip[0], trip[1]]\n        else:\n            current_ticket[1] = trip[1]\n            current_ticket[0] = min(current_ticket[0], trip[0])\n\n    return str(coupons)"
    },
    {
        "number": 3042,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    values = list(map(int, stdin.split('\\n')[1].split()))\n\n    mod = 10**9 + 7\n    dp = [0] * (max(values) + 1)\n    dp[1] = 1\n\n    for i in range(2, max(values) + 1):\n        for j in range(1, i):\n            if i * j == i:\n                dp[i] += dp[j]\n                dp[i] %= mod\n\n    result = 1\n    for value in values:\n        result *= dp[value]\n        result %= mod\n\n    return str(result)"
    },
    {
        "number": 3043,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(grid, start, target, stamina):\n        rows, cols = len(grid), len(grid[0])\n        visited = [[False for _ in range(cols)] for _ in range(rows)]\n        queue = [(start, stamina)]\n        visited[start[0]][start[1]] = True\n        days = 0\n\n        while queue:\n            new_queue = []\n            for (row, col), st in queue:\n                if (row, col) == target:\n                    return days\n\n                if st < 1:\n                    continue\n\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    new_row, new_col = row + dr, col + dc\n                    if 0 <= new_row < rows and 0 <= new_col < cols:\n                        if not visited[new_row][new_col] and grid[new_row][new_col] != '#':\n                            new_st = st - {'F': 2, 'M': 3, '.': 1}[grid[new_row][new_col]]\n                            if new_st >= 0:\n                                visited[new_row][new_col] = True\n                                new_queue.append(((new_row, new_col), new_st))\n\n            queue = new_queue\n            days += 1\n\n        return -1\n\n    N, M, K = map(int, stdin.split()[:3])\n    grid = [list(stdin.split()[3 + i]) for i in range(N)]\n    start = next(((i, j) for i in range(N) for j in range(M) if grid[i][j] == 'S'), None)\n    target = next(((i, j) for i in range(N) for j in range(M) if grid[i][j] == 'G'), None)\n\n    return str(bfs(grid, start, target, K))"
    },
    {
        "number": 3044,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W and grid[x][y] != '#'\n\n    def dfs(x, y, command, visited):\n        if not is_valid(x, y):\n            return False\n        if (x, y) == goal:\n            return True\n        if (x, y, command) in visited:\n            return False\n        visited.add((x, y, command))\n        if command:\n            dx, dy = {'L': (-1, 0), 'R': (1, 0), 'U': (0, -1), 'D': (0, 1)}[command[0]]\n            if dfs(x + dx, y + dy, command[1:], visited):\n                return True\n        for d in 'LRUD':\n            if dfs(x + {'L': -1, 'R': 1}.get(d, 0), y + {'U': -1, 'D': 1}.get(d, 0), d + command, visited):\n                return True\n        return False\n\n    lines = stdin.split('\\n')\n    H, W = map(int, lines[0].split())\n    grid = [list(line) for line in lines[1:H + 1]]\n    start = next((i, j) for i in range(H) for j in range(W) if grid[i][j] == 'S')\n    goal = next((i, j) for i in range(H) for j in range(W) if grid[i][j] == 'G')\n    command_str = lines[-1]\n\n    if dfs(start[0], start[1], command_str, set()):\n        return 0\n\n    min_changes = float('inf')\n    for i in range(len(command_str) + 1):\n        for d in 'LRUD':\n            new_command_str = command_str[:i] + d + command_str[i:]\n            if dfs(start[0], start[1], new_command_str, set()):\n                min_changes = min(min_changes, len(new_command_str) - len(command_str) + 1)\n\n    return min_changes "
    },
    {
        "number": 3045,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x_r, y_r, beacons):\n        for x_b, y_b, d in beacons:\n            if abs(x_r - x_b) + abs(y_r - y_b) != d:\n                return False\n        return True\n\n    def find_receiver(beacons):\n        for x_r in range(1000000):\n            for y_r in range(1000000):\n                if is_valid(x_r, y_r, beacons):\n                    return x_r, y_r\n        return None\n\n    def parse_input(stdin):\n        lines = stdin.split(\"\\n\")\n        n = int(lines[0])\n        beacons = []\n        for line in lines[1:]:\n            x_b, y_b, d = map(int, line.split())\n            beacons.append((x_b, y_b, d))\n        return beacons\n\n    beacons = parse_input(stdin)\n    receiver_pos = find_receiver(beacons)\n\n    if receiver_pos is None:\n        return \"impossible\"\n    else:\n        x_r, y_r = receiver_pos\n        return f\"{x_r} {y_r}\""
    },
    {
        "number": 3046,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    top_left = []\n    bottom_right = []\n\n    for i in range(n):\n        top_left.append(list(map(int, stdin.readline().split())))\n    for i in range(n):\n        bottom_right.append(list(map(int, stdin.readline().split())))\n\n    def is_valid(top_left, bottom_right):\n        if top_left[0] > bottom_right[0] or top_left[1] > bottom_right[1]:\n            return False\n        for i in range(len(top_left)):\n            if i != len(top_left) - 1:\n                if top_left[i][0] != top_left[i + 1][0] or bottom_right[i][0] != bottom_right[i + 1][0] or top_left[i][1] != top_left[i + 1][1] or bottom_right[i][1] != bottom_right[i + 1][1]:\n                    return False\n        return True\n\n    def helper(top_left, bottom_right):\n        if len(top_left) == 0:\n            return []\n        if len(top_left) == 1:\n            if is_valid(top_left[0], bottom_right[0]):\n                return [1]\n            else:\n                return []\n\n        for i in range(1, len(top_left)):\n            if is_valid(top_left[:i], bottom_right[:i]) and helper(top_left[i:], bottom_right[i:]) != []:\n                return [i] + helper(top_left[i:], bottom_right[i:])\n        return []\n\n    result = helper(top_left, bottom_right)\n    if result == []:\n        return \"syntax error\"\n    else:\n        return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3047,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_solutions(top_row, bottom_row):\n        solutions = set()\n        for s in range(1, 201):\n            for d in range(1, 201):\n                if s * top_row[0] == d * bottom_row[0]:\n                    for y in range(1, 201):\n                        for i in range(1, 201):\n                            if y * top_row[1] == i * bottom_row[1]:\n                                for g in range(1, 201):\n                                    for k in range(1, 201):\n                                        if g * top_row[2] == k * bottom_row[2]:\n                                            for im in range(1, 201):\n                                                for dr in range(1, 201):\n                                                    if im * top_row[3] == dr * bottom_row[3]:\n                                                        solutions.add((s, d, y, i, g, k, im, dr))\n        return solutions\n\n    def check_consistency(top_row, bottom_row, solutions):\n        consistent_solutions = set()\n        for solution in solutions:\n            s, d, y, i, g, k, im, dr = solution\n            if s * top_row[0] == d * bottom_row[0] and \\\n               y * top_row[1] == i * bottom_row[1] and \\\n               g * top_row[2] == k * bottom_row[2] and \\\n               im * top_row[3] == dr * bottom_row[3]:\n                consistent_solutions.add(solution)\n        return consistent_solutions\n\n    def find_proportions(top_row, bottom_row, consistent_solutions):\n        proportions = set()\n        for solution in consistent_solutions:\n            s, d, y, i, g, k, im, dr = solution\n            proportions.add((s, d, y, i, g, k, im, dr,\n                          lcm(s, d), lcm(y, i), lcm(g, k), lcm(im, dr)))\n        return proportions\n\n    def count_distinct_solutions(top_row, bottom_row, consistent_solutions):\n        distinct_solutions = set()\n        for solution in consistent_solutions:\n            s, d, y, i, g, k, im, dr = solution\n            distinct_solutions.add((s, d, y, i, g, k, im, dr))\n        return len(distinct_solutions)\n\n    input_data = stdin.split(\"\\n\")\n    top_row = [int(x) if x != \"_\" else None for x in input_data[0].split()]\n    bottom_row = [int(x) if x != \"_\" else None for x in input_data[1].split()]\n\n    solutions = find_solutions(top_row, bottom_row)\n    consistent_solutions = check_consistency(top_row, bottom_row, solutions)\n\n    if len(consistent_solutions) == 0:\n        return \"0\"\n    elif len(consistent_solutions) == 1:\n        return \"1\"\n    else:\n        proportions = find_proportions(top_row, bottom_row, consistent_solutions)\n        distinct_solutions = count_distinct_solutions(top_row, bottom_row, consistent_solutions)\n        if distinct_solutions == len(proportions):\n            return \"many\"\n        else:\n            return str(distinct_solutions) "
    },
    {
        "number": 3048,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_optimal_paths(n, adj):\n        paths = [[[] for _ in range(n)] for _ in range(n)]\n        for u in range(n):\n            for v in range(n):\n                if u == v:\n                    continue\n                if adj[u][v]:\n                    paths[u][v].append([u, v])\n        for k in range(n):\n            for u in range(n):\n                for v in range(n):\n                    for i in range(n):\n                        for j in range(n):\n                            if adj[i][j] and adj[j][u] and adj[v][i]:\n                                path = paths[i][j] + [v] + paths[j][u]\n                                paths[u][v].append(path)\n        return paths\n\n    def count_optimal_paths_of_length_2(n, adj, paths):\n        count = 0\n        for u in range(n):\n            for v in range(n):\n                if u == v:\n                    continue\n                if adj[u][v]:\n                    for path in paths[u][v]:\n                        if len(path) == 2:\n                            count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    adj = [[False for _ in range(n)] for _ in range(n)]\n    for i in range(1, n):\n        u, v = map(int, lines[i].split())\n        adj[u - 1][v - 1] = adj[v - 1][u - 1] = True\n\n    paths = find_optimal_paths(n, adj)\n    count = count_optimal_paths_of_length_2(n, adj, paths)\n    return str(count)"
    },
    {
        "number": 3049,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    fragment_length = len(decrypted_fragment)\n    possible_positions = []\n\n    for i in range(len(encrypted_message) - fragment_length + 1):\n        if encrypted_message[i:i + fragment_length] == decrypted_fragment:\n            possible_positions.append(i)\n\n    if len(possible_positions) == 1:\n        return encrypted_message[possible_positions[0]:possible_positions[0] + fragment_length]\n    else:\n        return str(len(possible_positions))"
    },
    {
        "number": 3050,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(grid, row, col, direction):\n        if direction == '<':\n            return grid[row][col - 1] != '#'\n        elif direction == '>':\n            return grid[row][col + 1] != '#'\n        elif direction == '^':\n            return grid[row - 1][col] != '#'\n        elif direction == 'v':\n            return grid[row + 1][col] != '#'\n\n    def find_suffix_length(trail, N):\n        for i in range(N, len(trail)):\n            if trail[i] == trail[i % N]:\n                return i % N\n        return len(trail)\n\n    def find_repeating_subsequence(trail, N):\n        for i in range(N, len(trail)):\n            if trail[i] == trail[i % N]:\n                return i % N\n        return len(trail)\n\n    lines = stdin.split('\\n')\n    N, program = int(lines[0]), lines[1]\n    grid = [list(line) for line in lines[2:]]\n\n    row, col = next((i, j) for i in range(N) for j in range(N) if grid[i][j] == 'R')\n    trail = [(row, col)]\n\n    for direction in program + program:\n        if is_valid_move(grid, row, col, direction):\n            if direction == '<':\n                col -= 1\n            elif direction == '>':\n                col += 1\n            elif direction == '^':\n                row -= 1\n            elif direction == 'v':\n                row += 1\n            trail.append((row, col))\n\n    if len(trail) == len(set(trail)):\n        return '1'\n    else:\n        return str(find_repeating_subsequence(trail, N))"
    },
    {
        "number": 3051,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def missed_fogs(n, originator_fogs):\n        total_missed = 0\n        nets = []\n        for i in range(n):\n            fogs = [originator_fogs[i]]\n            for j in range(1, originator_fogs[i][0]):\n                fog = [originator_fogs[i][1] + j * originator_fogs[i][5],\n                       originator_fogs[i][2] + j * originator_fogs[i][6],\n                       originator_fogs[i][3] + j * originator_fogs[i][7],\n                       originator_fogs[i][4] + j * originator_fogs[i][8]]\n                fogs.append(fog)\n            for fog in fogs:\n                missed = True\n                for net in nets:\n                    if net[0] <= fog[1] and net[1] >= fog[0] and net[2] >= fog[2]:\n                        missed = False\n                        break\n                if missed:\n                    total_missed += 1\n                    net_x1 = fog[0]\n                    net_x2 = fog[1]\n                    net_y1 = 0\n                    net_y2 = fog[2]\n                    while net_y2 < fog[3]:\n                        nets.append([net_x1, net_x2, net_y1, net_y2])\n                        net_y1 = net_y2\n                        net_y2 += 1\n        return total_missed\n\n    n, originator_fogs = 0, []\n    stdin_list = stdin.split('\\n')\n    n = int(stdin_list[0])\n    for i in range(1, n + 1):\n        originator_fogs.append([int(x) for x in stdin_list[i].split()])\n\n    return str(missed_fogs(n, originator_fogs))"
    },
    {
        "number": 3052,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def min_time(x1, y1, x2, y2, conveyors):\n        min_time = distance(x1, y1, x2, y2)\n        for c1 in conveyors:\n            for c2 in conveyors:\n                if c1 != c2:\n                    d1 = distance(x1, y1, c1[0], c1[1])\n                    d2 = distance(c1[2], c1[3], c2[0], c2[1])\n                    d3 = distance(c2[2], c2[3], x2, y2)\n                    min_time = min(min_time, d1 + d2 + d3)\n        return min_time\n\n    def parse_input(stdin: str):\n        lines = stdin.split(\"\\n\")\n        x1, y1, x2, y2 = map(float, lines[0].split())\n        n = int(lines[1])\n        conveyors = []\n        for i in range(2, 2 + n):\n            conveyors.append(tuple(map(float, lines[i].split())))\n        return x1, y1, x2, y2, conveyors\n\n    x1, y1, x2, y2, conveyors = parse_input(stdin)\n    min_t = min_time(x1, y1, x2, y2, conveyors)\n    return f\"{min_t:.6f}\""
    },
    {
        "number": 3053,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n\n    if P > N // 2:\n        return \"IMPOSSIBLE\"\n\n    if K > 26 or K > N or K * P < N or (N - K * P) % (K - 1) != 0:\n        return \"IMPOSSIBLE\"\n\n    result = []\n    for i in range(K):\n        result.append(chr(97 + i))\n        result.append(chr(97 + i))\n\n    for i in range(N - K * P):\n        result.append(chr(97 + i % (K - 1) + 1))\n\n    return \"\".join(result)"
    },
    {
        "number": 3054,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUYaeiouy\"\n        word = word.strip(\".,!?;:-\")\n        if word.endswith(\"es\") and len(word) > 2 and word[-3] not in vowels:\n            return count_syllables(word[:-2])\n        if word.endswith((\"le\", \"la\", \"lo\", \"li\", \"lu\")) and len(word) > 2 and word[-3] not in vowels:\n            return count_syllables(word[:-2])\n        if word.endswith((\"que\", \"qui\", \"qwe\", \"qwu\", \"qwq\", \"qwa\")):\n            return count_syllables(word[:-1])\n        if word.endswith((\"ce\", \"ci\", \"cy\", \"ca\", \"cu\", \"cr\", \"cl\", \"ct\", \"ch\", \"cs\", \"ck\", \"cn\", \"cm\", \"co\", \"cu\", \"cv\", \"cx\", \"cy\", \"cz\", \"cw\", \"cq\", \"ca\", \"cf\", \"cg\", \"cb\", \"cc\", \"cd\", \"cf\", \"cj\", \"ck\", \"cp\", \"cq\", \"cr\", \"cs\", \"ct\", \"cu\", \"cv\", \"cx\", \"cy\", \"cz\", \"cw\", \"cq\")) and len(word) > 2 and word[-3] not in vowels:\n            return count_syllables(word[:-2])\n        if word.endswith((\"al\", \"alc\", \"alg\", \"alt\", \"an\", \"ang\", \"ank\", \"ap\", \"apl\", \"apr\", \"at\", \"au\", \"av\", \"aw\", \"ay\", \"az\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad\", \"af\", \"aj\", \"ak\", \"ap\", \"aq\", \"ar\", \"as\", \"ac\", \"ag\", \"ab\", \"ad"
    },
    {
        "number": 3055,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    names = sorted(stdin.split('\\n')[1:])\n    thore_index = names.index(\"ThoreHusfeldt\")\n    \n    if thore_index == 0:\n        return \"Thore is awesome\"\n    \n    for i in range(thore_index - 1, -1, -1):\n        if names[i].startswith(\"ThoreHusfeldt\"):\n            return \"Thore sucks\"\n        elif \"ThoreHusfeldt\" in names[i]:\n            return names[i].split(\"ThoreHusfeldt\")[0] + \"ThoreH\"\n    \n    return \"Thore is awesome\""
    },
    {
        "number": 3056,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, walk: str) -> int:\n        if len(walk) == 0:\n            return node\n        if walk[0] == 'L':\n            return dfs(node * 2, walk[1:])\n        elif walk[0] == 'R':\n            return dfs(node * 2 + 1, walk[1:])\n        else:\n            return node\n\n    total_value = 0\n    for walk in stdin.split('*'):\n        total_value += dfs(1, walk)\n\n    return str(total_value)"
    },
    {
        "number": 3057,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_rhyme(word1, word2):\n        min_length = min(3, len(word1), len(word2))\n        return word1[-min_length:] == word2[-min_length:]\n\n    def is_consistent(statements):\n        for i, (word1, word2, is_same) in enumerate(statements):\n            for j in range(i + 1, len(statements)):\n                word3, word4, is_same_other = statements[j]\n                if (word1 == word3 and word2 != word4) or (word1 != word3 and word2 == word4):\n                    return False\n                if is_same != is_same_other and (is_rhyme(word1, word3) or is_rhyme(word2, word4)):\n                    return False\n        return True\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    statements = []\n\n    for i in range(1, N + 1):\n        statement = lines[i].split()\n        if len(statement) == 3:\n            word1, word2, is_same = statement\n            is_same = is_same == 'is'\n        else:\n            word1, word2, _, is_same = statement\n            is_same = is_same == 'not'\n        statements.append((word1, word2, is_same))\n\n    if is_consistent(statements):\n        return 'yes'\n    else:\n        return 'wait what?'"
    },
    {
        "number": 3058,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(path1, path2):\n        if not path1 or not path2:\n            return False\n        for i in range(len(path1)):\n            if path1[i] != path2[i]:\n                return False\n        return True\n\n    def find_paths(fossil_seqs, current_seq):\n        paths = []\n        for seq in fossil_seqs:\n            if is_valid(seq, current_seq):\n                return [seq]\n            for i in range(len(seq)):\n                if seq[i] != current_seq[i]:\n                    new_seq = seq[:i] + current_seq[i] + seq[i + 1:]\n                    if new_seq not in fossil_seqs:\n                        paths.append(new_seq)\n        return paths\n\n    def backtrack(fossil_seqs, current_seq, path_counts):\n        if not fossil_seqs:\n            return path_counts\n        valid_seqs = [seq for seq in fossil_seqs if is_valid(seq, current_seq)]\n        if not valid_seqs:\n            return None\n        for seq in valid_seqs:\n            fossil_seqs.remove(seq)\n            path_counts.append(seq)\n            result = backtrack(fossil_seqs, seq, path_counts)\n            if result is not None:\n                return result\n            path_counts.pop()\n            fossil_seqs.append(seq)\n        return None\n\n    lines = stdin.split('\\n')\n    n, current_seq = lines[0], lines[1]\n    fossil_seqs = lines[2:]\n\n    paths = find_paths(fossil_seqs, current_seq)\n    if not paths:\n        return 'impossible'\n\n    path_counts = []\n    result = backtrack(fossil_seqs, current_seq, path_counts)\n    if result is None:\n        return 'impossible'\n\n    s1, s2 = len(path_counts[0]), len(path_counts[1])\n    output = [str(s1), str(s2)]\n    for i in range(s1):\n        output.append(path_counts[0][i])\n    for i in range(s2):\n        output.append(path_counts[1][i])\n\n    return '\\n'.join(output) "
    },
    {
        "number": 3059,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_expected_time(t, p, d, expected_time):\n        return (1 - p) * (t + d + expected_time) + p * expected_time\n\n    def binary_search(tricks, expected_time):\n        lo, hi = 0, len(tricks)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if get_expected_time(*tricks[mid], expected_time) <= mid:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo\n\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = [list(map(float, stdin.split()))[1:] for _ in range(m)]\n    tricks.sort(key=lambda x: x[0])\n\n    expected_time = n\n    for i in range(m):\n        t, p, d = tricks[i]\n        expected_time = get_expected_time(t, p, d, expected_time)\n\n    reset_time = binary_search(tricks, expected_time)\n    expected_time = min(reset_time + n, expected_time)\n\n    return f\"{expected_time:.6f}\""
    },
    {
        "number": 3060,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for i in range(1, n):\n        count += (n - 1) * (i - 1) + 1\n        if count >= k:\n            break\n    a = n - i\n    b = (k - 1) % a + 1\n    return \" \".join(str(min(a, b, n - 1 - a + 1 - b)) for _ in range(n - 1))"
    },
    {
        "number": 3061,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u, visited):\n        visited.add(u)\n        for v in adj[u]:\n            if v not in visited:\n                dfs(v, visited)\n\n    def find_max_length_path(start):\n        visited = set()\n        dfs(start, visited)\n        return len(visited)\n\n    def find_min_length_path(blocked_road):\n        u, v = blocked_road\n        max_length = 0\n        for start in range(1, n + 1):\n            if start not in adj[u] and start not in adj[v]:\n                max_length = max(max_length, find_max_length_path(start))\n        return max_length\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    adj = [set() for _ in range(n + 1)]\n    for i in range(m):\n        u, v = map(int, lines[i + 1].split())\n        adj[u].add(v)\n        adj[v].add(u)\n\n    min_length = float('inf')\n    for i in range(m):\n        min_length = min(min_length, find_min_length_path((i + 1, i + 2)))\n\n    return str(min_length)"
    },
    {
        "number": 3062,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n    distance = (x ** 2 + y ** 2) ** 0.5\n    angle = math.atan2(y, x)\n    time = distance / v\n    if w * time >= math.pi:\n        time += (angle + math.pi) / w\n    else:\n        time += abs(angle) / w\n    return f\"{time:.10f}\""
    },
    {
        "number": 3063,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    debts = [0] * (N + 1)\n    for i in range(N):\n        a, b = map(int, stdin.readline().split())\n        debts[a] -= b\n        debts[i + 1] += b\n\n    debts_sum = sum(abs(i) for i in debts)\n    return str(debts_sum)"
    },
    {
        "number": 3064,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, distance, longest_path):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                distance[neighbor] = distance[node] + 1\n                longest_path[0] = max(longest_path[0], distance[neighbor])\n                dfs(neighbor, visited, distance, longest_path)\n        visited[node] = False\n\n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        A, B = map(int, stdin.readline().split())\n        graph[A].append(B)\n        graph[B].append(A)\n\n    visited = [False] * (N + 1)\n    distance = [0] * (N + 1)\n    longest_path = [0]\n    dfs(1, visited, distance, longest_path)\n    return str(longest_path[0])"
    },
    {
        "number": 3065,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(node, visited, passages):\n        if node not in visited:\n            return True\n        for neighbor in passages[node]:\n            if neighbor not in visited:\n                return True\n        return False\n\n    def count_valid_paths(node, visited, passages):\n        if node in visited:\n            return 0\n        visited.add(node)\n        valid_paths = 1\n        for neighbor in passages[node]:\n            valid_paths += count_valid_paths(neighbor, visited, passages)\n        visited.remove(node)\n        return valid_paths\n\n    def find_valid_paths(walk, passages):\n        valid_paths = 0\n        for start in walk:\n            visited = set()\n            valid_paths += count_valid_paths(start, visited, passages)\n        return valid_paths\n\n    def parse_input(stdin):\n        lines = stdin.split(\"\\n\")\n        N, L = map(int, lines[0].split())\n        walk = list(map(int, lines[1].split()))\n        passages = [[] for _ in range(N)]\n        for i in range(N):\n            node, *neighbors = map(int, lines[2 + i].split())\n            passages[node] = neighbors\n        return N, L, walk, passages\n\n    N, L, walk, passages = parse_input(stdin)\n    valid_paths = find_valid_paths(walk, passages)\n    total_paths = 2 ** (N - 1)\n    return f\"{valid_paths / total_paths:.10f}\""
    },
    {
        "number": 3066,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = list(map(int, stdin.readline().strip().split()))\n\n    if len(set(colors)) != len(colors):\n        return \"IMPOSSIBLE\"\n\n    instructions = []\n    for i in range(n):\n        instructions.append((i + 1, n, colors[i]))\n\n    return f\"{len(instructions)}\\n\" + \"\\n\".join(f\"{l} {r} {c}\" for l, r, c in instructions)"
    },
    {
        "number": 3067,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    sequences = []\n    for _ in range(n):\n        line = stdin.readline().strip().split()\n        length = int(line[0])\n        sequence = [int(x) for x in line[1:]]\n        sequences.append(sequence)\n\n    sorted_sequences = []\n    for sequence in sequences:\n        sorted_sequences.append(sorted(sequence))\n\n    solution_sequence = []\n    while sorted_sequences:\n        min_sequence = min(sorted_sequences, key=lambda x: x[0])\n        solution_sequence.append(min_sequence.pop(0))\n        if not min_sequence:\n            sorted_sequences.remove(min_sequence)\n\n    return \" \".join(str(x) for x in solution_sequence)"
    },
    {
        "number": 3068,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_admissible(suspects, player1, player2):\n        for suspect in suspects:\n            if suspect in player1 and suspect in player2:\n                return False\n        return True\n\n    def count_solutions(suspects, player1, player2):\n        return sum(is_admissible(set(combination), player1, player2) for combination in itertools.combinations(suspects, 3))\n\n    stdin = stdin.split('\\n')\n    N = int(stdin[0])\n    player1 = set()\n    player2 = set()\n\n    for i in range(1, N + 1):\n        investigation = stdin[i].split()\n        if investigation[2] == '1':\n            player1.add(investigation[0])\n            player1.add(investigation[1])\n        else:\n            player2.add(investigation[0])\n            player2.add(investigation[1])\n\n    suspects = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    return str(count_solutions(suspects, player1, player2))"
    },
    {
        "number": 3069,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, bracket in enumerate(stdin):\n        if bracket == \"(\":\n            stack.append(i)\n        else:\n            if not stack:\n                return \"impossible\"\n            if stdin[stack[-1]] == \")\":\n                return \"impossible\"\n            stack.pop()\n\n    if not stack:\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3070,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    trains = []\n    for _ in range(M):\n        X, S, T, L = map(int, stdin.readline().split())\n        trains.append((X, S, T, L))\n\n    trains.sort(key=lambda x: x[1])\n\n    for i in range(M):\n        X, S, T, L = trains[i]\n        if L >= 1800:\n            continue\n        else:\n            S_new = S + L\n            T_new = T - L\n            if T_new >= 9000:\n                return str(S_new)\n            else:\n                for j in range(i + 1, M):\n                    X_next, S_next, T_next, L_next = trains[j]\n                    if X_next == X + 1 and S_next <= T_new:\n                        T_new += L_next\n                        if T_new >= 9000:\n                            return str(S_new)\n                return \"impossible\"\n\n    return \"impossible\""
    },
    {
        "number": 3071,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    players = [f\"{chr(65 + i)}\" + f\"{j+1}\" for i in range(m) for j in range(n)]\n    games = []\n    for i in range(m):\n        for j in range(i+1, m):\n            for p1 in range(n):\n                for p2 in range(n):\n                    if players[i*n+p1] != players[j*n+p2]:\n                        games.append((players[i*n+p1], players[j*n+p2]))\n    rounds = []\n    for i in range((m-1)*n):\n        round_games = []\n        for j in range(m-1):\n            round_games.append(games[i+j*(m-1)])\n        rounds.append(round_games)\n    output = []\n    for round_games in rounds:\n        output.append(\" \".join(f\"{p1}-{p2}\" for p1, p2 in round_games))\n    return \"\\n\".join(output)"
    },
    {
        "number": 3072,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    apartment = []\n    for _ in range(R):\n        row = stdin.readline().strip()\n        apartment.append(row)\n\n    max_people = 0\n    for i in range(R):\n        for j in range(C):\n            if apartment[i][j] == '.':\n                perimeter = 0\n                for k in range(max(0, i - 1), min(R, i + 2)):\n                    for l in range(max(0, j - 1), min(C, j + 2)):\n                        if apartment[k][l] == '.':\n                            perimeter += 1\n                max_people = max(max_people, perimeter)\n\n    return str(max_people)"
    },
    {
        "number": 3073,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start, end, tarot_cards, prices):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            position, cost = queue.pop(0)\n            if position == end:\n                return cost\n            if position in visited:\n                continue\n            visited.add(position)\n            for card in tarot_cards[position]:\n                for offset in card:\n                    new_position = (position[0] + offset[0], position[1] + offset[1])\n                    if new_position in prices:\n                        queue.append((new_position, cost + prices[new_position]))\n        return -1\n\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        tarot_cards = defaultdict(list)\n        prices = {}\n        for i in range(1, n + 1):\n            r, c, a, b, p = map(int, lines[i].split())\n            tarot_cards[(r, c)].append([(a, b), (-a, b), (-a, -b), (a, -b), (b, a), (-b, a), (b, -a), (-b, -a)])\n            prices[(r, c)] = p\n        return tarot_cards, prices\n\n    tarot_cards, prices = parse_input(stdin)\n    start = list(tarot_cards.keys())[0]\n    end = (0, 0)\n    result = bfs(start, end, tarot_cards, prices)\n    return str(result)"
    },
    {
        "number": 3074,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s: str) -> bool:\n        return s and not s.startswith('0') and int(s) % 3 == 0\n\n    def count_valid_subsets(s: str) -> int:\n        n = len(s)\n        dp = [[0] * 2 for _ in range(n + 1)]\n        dp[0][0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(2):\n                if j == 0:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j + 1]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n                if is_valid(s[:i]):\n                    dp[i][j] += dp[i - 1][j - 1] if j > 0 else 0\n\n        return dp[n][0] % (10**9 + 7)\n\n    n, s = map(str, stdin.split('\\n'))\n    return str(count_valid_subsets(s))"
    },
    {
        "number": 3075,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.readline().split())\n    gas_stations = []\n    for i in range(n):\n        d, c = map(int, stdin.readline().split())\n        gas_stations.append((d, c))\n\n    gas_stations.sort()\n    tank = g\n    cost = 0\n    for i in range(n):\n        if tank == 0:\n            return \"cancel road trip\"\n        d, c = gas_stations[i]\n        if tank < d:\n            return \"cancel road trip\"\n        tank -= d\n        cost += d * c\n        tank = min(tank + g, g)\n\n    return str(cost)"
    },
    {
        "number": 3076,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    jewels = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    jewels.sort(key=lambda x: x[1], reverse=True)\n\n    dp = [0] * (k + 1)\n    for s, v in jewels:\n        for i in range(s, k + 1):\n            dp[i] = max(dp[i], dp[i - s] + v)\n\n    return ' '.join(map(str, dp[1:]))"
    },
    {
        "number": 3077,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_inside_village(x, y, villages):\n        for vx, vy, vr in villages:\n            if distance(x, y, vx, vy) <= vr:\n                return True\n        return False\n\n    def count_minions_in_range(x, y, minions, villages, r):\n        count = 0\n        for mx, my in minions:\n            if distance(x, y, mx, my) <= r and not is_inside_village(mx, my, villages):\n                count += 1\n        return count\n\n    n, m, r = map(int, stdin.readline().split())\n    villages = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    minions = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    max_minions = 0\n    for vx, vy, vr in villages:\n        for i in range(1, r + 1):\n            max_minions = max(max_minions, count_minions_in_range(vx, vy, minions, villages, i))\n\n    return str(max_minions)"
    },
    {
        "number": 3078,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.readline().split())\n    A = [int(x) for x in stdin.readlines()]\n    dp = [0] * N\n    for i in range(N):\n        dp[i] = A[i]\n        for j in range(i - 1, -1, -1):\n            if dp[j] + A[i] <= S:\n                dp[i] = max(dp[i], dp[j] + A[i])\n    ans = [0] * N\n    for i in range(N - 1, -1, -1):\n        ans[i] = dp[i]\n        if dp[i] > S:\n            continue\n        for j in range(i + 1, N):\n            if A[i] + A[j] <= S:\n                ans[i] = max(ans[i], ans[j] + A[i])\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3079,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    letters = sorted(stdin.readline().strip())\n\n    if n % 2 == 0:\n        print(\"DA\")\n        print(\"\".join(letters))\n    else:\n        print(\"NE\")\n        print(\"\")\n"
    },
    {
        "number": 3080,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x, target, visited):\n        if x == target:\n            return 1\n        if x in visited:\n            return 0\n        visited.add(x)\n        res = 0\n        for y in graph[x]:\n            res += dfs(y, target, visited)\n        return res\n\n    def is_valid(stands, favorite_areas):\n        for area in favorite_areas:\n            count = 0\n            for stand in stands:\n                if stand in reachable_areas[area]:\n                    count += 1\n            if count != 1:\n                return False\n        return True\n\n    def count_ways(k, favorite_areas):\n        stands = [[] for _ in range(n)]\n        for i in range(k):\n            stands[favorite_areas[i]].append(i)\n        return helper(stands, favorite_areas)\n\n    def helper(stands, favorite_areas):\n        if len(stands) == 0:\n            return 1\n        if not is_valid(stands, favorite_areas):\n            return 0\n        res = 0\n        for i in range(n):\n            new_stands = [stands[j] for j in range(n) if j != i]\n            res += helper(new_stands, favorite_areas)\n        return res\n\n    lines = stdin.split('\\n')\n    n, m, q = map(int, lines[0].split())\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        x, y = map(int, lines[i + 1].split())\n        graph[x - 1].append(y - 1)\n        graph[y - 1].append(x - 1)\n\n    reachable_areas = [set() for _ in range(n)]\n    for i in range(n):\n        visited = set()\n        for j in range(n):\n            reachable_areas[i].add(j)\n            visited.add(j)\n        for j in range(n):\n            if j not in visited:\n                dfs(j, i, visited)\n\n    result = []\n    for i in range(q):\n        k, a = map(int, lines[m + i + 1].split()[:2])\n        favorite_areas = list(map(int, lines[m + i + 1].split()[2:]))\n        result.append(count_ways(k, favorite_areas))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3081,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = [False] * len(graph)\n        weights = [float('inf')] * len(graph)\n        weights[start] = 0\n        min_heap = [(0, start)]\n\n        while min_heap:\n            weight, node = heapq.heappop(min_heap)\n            if node == end:\n                return weight\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, edge_weight in enumerate(graph[node]):\n                    if edge_weight != float('inf'):\n                        if weights[neighbor] > weights[node] + edge_weight:\n                            weights[neighbor] = weights[node] + edge_weight\n                            heapq.heappush(min_heap, (weights[neighbor], neighbor))\n        return float('inf')\n\n    def add_unscheduled_flights(flights, n, graph):\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    flights.append((i, j, 0))\n                    for k in range(n):\n                        graph[i][k] = min(graph[i][k], graph[i][j] + graph[j][k])\n        return flights\n\n    def get_min_planes(n, m, inspection_times, flights):\n        graph = [[float('inf')] * n for _ in range(n)]\n        for i in range(n):\n            graph[i][i] = 0\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    graph[i][j] = flights[i][j]\n\n        flights = [(s - 1, f - 1, t) for s, f, t in flights]\n        flights = add_unscheduled_flights(flights, n, graph)\n        flights.sort(key=lambda x: x[2])\n\n        min_planes = 0\n        for i in range(m):\n            s, f, t = flights[i]\n            if dijkstra(graph, s, f) != float('inf'):\n                min_planes += 1\n\n        return min_planes\n\n    n, m = map(int, stdin.readline().split())\n    inspection_times = list(map(int, stdin.readline().split()))\n    flights = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    flights = [(s - 1, f - 1, t) for s, f, t in flights]\n\n    return str(get_min_planes(n, m, inspection_times, flights))"
    },
    {
        "number": 3082,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def compute_tastiness(dish_type, w_i, t_i, delta_t_i, x):\n        if dish_type == \"D\":\n            return sum(t_i - (n - 1) * delta_t_i for n in range(1, int(x // w_i) + 1))\n        else:\n            return (t_i - x * delta_t_i) * x\n\n    d, w = map(int, stdin.readline().split())\n    dishes = [stdin.readline().strip().split() for _ in range(d)]\n\n    max_tastiness = float('-inf')\n    for i in range(1, w + 1):\n        for dish in dishes:\n            dish_type, w_i, t_i, delta_t_i = dish\n            w_i, t_i, delta_t_i = map(int, [w_i, t_i, delta_t_i])\n            tastiness = compute_tastiness(dish_type, w_i, t_i, delta_t_i, i)\n            if tastiness > max_tastiness:\n                max_tastiness = tastiness\n\n    return f\"{max_tastiness:.10f}\" if max_tastiness != float('-inf') else \"impossible\""
    },
    {
        "number": 3083,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(playlist: List[int]) -> bool:\n        for i in range(len(playlist) - 1):\n            if not set(songs[playlist[i]][1]).intersection(set(songs[playlist[i + 1]][1])):\n                return False\n        return True\n\n    def backtrack(start: int, playlist: List[int]) -> str:\n        if len(playlist) == 9:\n            return \" \".join(map(str, playlist))\n        for i in range(start, n):\n            if i not in playlist:\n                playlist.append(i)\n                if is_valid(playlist):\n                    result = backtrack(i, playlist)\n                    if result:\n                        return result\n                playlist.pop()\n        return \"fail\"\n\n    n = int(stdin.readline())\n    songs = []\n    for _ in range(n):\n        artist, num_songs, *next_songs = map(int, stdin.readline().split())\n        songs.append((artist, next_songs))\n\n    return backtrack(0, [])"
    },
    {
        "number": 3084,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_time(time: str) -> bool:\n        hh, mm = map(int, time.split(':'))\n        return 0 <= hh < 24 and 0 <= mm < 60\n\n    def next_time(time: str) -> str:\n        hh, mm = map(int, time.split(':'))\n        mm = (mm + 1) % 60\n        if mm == 0:\n            hh = (hh + 1) % 24\n        return f\"{hh:02d}:{mm:02d}\"\n\n    def get_times(start_time: str, end_time: str) -> set:\n        times = set()\n        current_time = start_time\n        while current_time != end_time:\n            times.add(current_time)\n            current_time = next_time(current_time)\n        return times\n\n    start_time, end_time = stdin.split('\\n')\n    if not (is_valid_time(start_time) and is_valid_time(end_time)):\n        return \"Invalid times\"\n\n    times = get_times(start_time, end_time)\n    times.add(start_time)\n    times.add(end_time)\n\n    return f\"{len(times)}\\n\" + '\\n'.join(sorted(times))"
    },
    {
        "number": 3085,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    alt_notation = \"\"\n    for i, char in enumerate(stdin):\n        if char == \"(\":\n            stack.append(i)\n        else:\n            start = stack.pop()\n            end = i + 1\n            alt_notation += f\"{start},{end}:\"\n            alt_notation += solution(stdin[start + 1:end - 1])\n    return alt_notation\n\nstdin = input()\nprint(solution(stdin)) "
    },
    {
        "number": 3086,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    observations = []\n    for _ in range(N):\n        start_date, end_date, *event_counts = map(int, stdin.readline().split())\n        observations.append((start_date, end_date, event_counts))\n\n    def get_duration(event_counts):\n        total_events = sum(event_counts)\n        if total_events == 0:\n            return -1\n        duration = (365 * N) // total_events\n        return duration if (365 * N) % total_events == 0 else -1\n\n    durations = [get_duration([sum(obs[2][i] for obs in observations) for i in range(M)]) for _ in range(M)]\n\n    return \" \".join(map(str, durations))"
    },
    {
        "number": 3087,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(arrows):\n        visited = [False] * (N + 1)\n        for i in range(1, N + 1):\n            if visited[i]:\n                continue\n            cycle = set()\n            while not visited[i]:\n                visited[i] = True\n                cycle.add(i)\n                i = arrows[i]\n            if i in cycle:\n                return False\n        return True\n\n    N, K = map(int, stdin.split()[0:2])\n    end_positions = list(map(int, stdin.split()[2:]))\n\n    arrows = [0] * (N + 1)\n    for i in range(1, N + 1):\n        arrows[i] = end_positions.index(i) + 1\n\n    if is_valid(arrows):\n        return \" \".join(map(str, arrows[1:]))\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3088,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n_str = str(n)\n    digits = list(n_str)\n\n    def swap(i, j):\n        digits[i], digits[j] = digits[j], digits[i]\n\n    def is_valid(i, j):\n        return digits[i] != '0' and digits[j] != '0'\n\n    def get_largest_number():\n        return int(''.join(digits))\n\n    for _ in range(k):\n        for i in range(len(digits) - 1):\n            for j in range(i + 1, len(digits)):\n                if is_valid(i, j):\n                    swap(i, j)\n                    largest_number = get_largest_number()\n                    if largest_number > n:\n                        n = largest_number\n                    swap(i, j)\n\n    return str(n)"
    },
    {
        "number": 3089,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def area(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area) / 2\n\n    def expected_distance(points):\n        n = len(points)\n        total_distance = 0\n        for i in range(n):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % n]\n            total_distance += distance(x1, y1, x2, y2)\n        return total_distance / n\n\n    def central_business_district(points):\n        n = len(points)\n        polygon_area = area(points)\n        x_center = sum(x for x, y in points) / n\n        y_center = sum(y for x, y in points) / n\n        return [(x - x_center, y - y_center) for x, y in points], polygon_area\n\n    def main(stdin: str) -> str:\n        lines = stdin.splitlines()\n        n = int(lines[0])\n        points = [(int(x), int(y)) for x, y in (line.split() for line in lines[1:])]\n        cbd, polygon_area = central_business_district(points)\n        expected_distance_cbd = expected_distance(cbd)\n        expected_distance_total = expected_distance_cbd * polygon_area / area([(0, 0)] + cbd + [(0, 0)])\n        return f\"{expected_distance_total:.10f}\"\n\n    return main(stdin) "
    },
    {
        "number": 3090,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.readline().split())\n    cost_matrix = []\n    for _ in range(N):\n        cost_matrix.append(list(map(int, stdin.readline().split())))\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < N and 0 <= y < M\n\n    def dfs(x: int, y: int, visited: set) -> int:\n        if not is_valid(x, y) or (x, y) in visited:\n            return 0\n\n        visited.add((x, y))\n        cost = cost_matrix[x][y]\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and (nx, ny) not in visited:\n                cost += dfs(nx, ny, visited)\n\n        return cost\n\n    total_cost = float('inf')\n    for i in range(N):\n        for j in range(M):\n            if cost_matrix[i][j] != 0:\n                visited = set()\n                cost = dfs(i, j, visited)\n                total_cost = min(total_cost, cost + K * len(visited))\n\n    return str(total_cost)"
    },
    {
        "number": 3091,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, stdin.split()[0].split())\n    grid_locations = []\n    for i in range(1, m + 1):\n        r, c = map(int, stdin.split()[i].split())\n        grid_locations.append((r, c))\n\n    def is_valid(board: List[List[int]]) -> bool:\n        for row in board:\n            if len(set(row)) != n:\n                return False\n\n        for col in range(n):\n            if len(set(board[row][col] for row in range(n))) != n:\n                return False\n\n        return True\n\n    def backtrack(board: List[List[int]], index: int) -> int:\n        if index == m:\n            return 1 if is_valid(board) else 0\n\n        row, col = grid_locations[index]\n        count = 0\n\n        for num in range(1, n + 1):\n            if num not in board[row] and num not in [board[i][col] for i in range(n)]:\n                board[row][col] = num\n                count += backtrack(board, index + 1)\n                board[row][col] = 0\n\n        return count\n\n    board = [[0] * n for _ in range(n)]\n    return str(backtrack(board, 0))"
    },
    {
        "number": 3092,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, modulo):\n        n = len(graph)\n        visited = [False] * n\n        weights = [float('inf')] * n\n        weights[start] = 0\n        paths = [0] * n\n        paths[start] = 1\n\n        while not all(visited):\n            min_weight = float('inf')\n            min_index = -1\n            for i in range(n):\n                if not visited[i] and weights[i] < min_weight:\n                    min_weight = weights[i]\n                    min_index = i\n\n            if min_index == -1:\n                break\n\n            visited[min_index] = True\n\n            for neighbor, weight in graph[min_index]:\n                if not visited[neighbor]:\n                    new_weight = weights[min_index] + weight\n                    if new_weight < weights[neighbor]:\n                        weights[neighbor] = new_weight\n                        paths[neighbor] = paths[min_index]\n                    elif new_weight == weights[neighbor]:\n                        paths[neighbor] = (paths[neighbor] + paths[min_index]) % modulo\n\n        return paths\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    graph = [[] for _ in range(N)]\n\n    for i in range(M):\n        O, D, L = map(int, lines[i + 1].split())\n        O -= 1\n        D -= 1\n        graph[O].append((D, L))\n\n    result = []\n    for i in range(M):\n        O, D, L = map(int, lines[i + 1].split())\n        O -= 1\n        D -= 1\n        paths = dijkstra(graph, O, 1000000007)\n        result.append(paths[D])\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3093,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    f = list(map(int, stdin.split()[2:]))\n    dp = [0] * (N + 1)\n    dp[1] = K\n    for i in range(2, N + 1):\n        dp[i] = (K * dp[i - 1]) % 1000000007\n        if f[i - 1] == i:\n            dp[i] = (dp[i] + dp[i - 1] * (K - 1)) % 1000000007\n    return str(dp[N])"
    },
    {
        "number": 3094,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    t = list(map(int, stdin.readline().strip().split()))\n\n    mod = 10**9 + 7\n    ans = 1\n\n    for i in range(n):\n        ans *= (n - 1)\n        ans %= mod\n\n    return str(ans)"
    },
    {
        "number": 3095,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix, r, s):\n        return matrix[0][0] + matrix[r - 1][s - 1] <= matrix[0][s - 1] + matrix[r - 1][0]\n\n    def is_extremely_cool(matrix, r, s):\n        if r < 2 or s < 2:\n            return False\n        for i in range(1, r):\n            for j in range(1, s):\n                submatrix = [row[j - 1 :] for row in matrix[i - 1 :]]\n                if not is_cool(submatrix, r - i, s - j + 1):\n                    return False\n        return True\n\n    lines = stdin.splitlines()\n    R, S = map(int, lines[0].split())\n    matrix = [list(map(int, line.split())) for line in lines[1:]]\n\n    if is_extremely_cool(matrix, R, S):\n        return str(R * S)\n    else:\n        return \"0\""
    },
    {
        "number": 3096,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_consecutive(numbers):\n        return all(numbers[i + 1] - numbers[i] == 1 for i in range(len(numbers) - 1))\n\n    def find_superiors(superiors, person):\n        result = set()\n        for superior in superiors[person]:\n            result.add(superior)\n            result.update(find_superiors(superiors, superior))\n        return result\n\n    def find_invitees(superiors, jokes, person):\n        result = set()\n        for superior in superiors[person]:\n            if jokes[superior] not in result:\n                result.add(jokes[superior])\n                result.update(find_invitees(superiors, jokes, superior))\n        return result\n\n    def is_valid(superiors, jokes, person):\n        invitees = find_invitees(superiors, jokes, person)\n        return len(invitees) == len(jokes) and is_consecutive(sorted(invitees))\n\n    def count_valid_invitations(superiors, jokes):\n        return sum(is_valid(superiors, jokes, person) for person in range(1, len(jokes) + 1))\n\n    N, jokes, superiors = int(stdin.readline().strip()), list(map(int, stdin.readline().strip().split())), [[] for _ in range(N + 1)]\n    for _ in range(N - 1):\n        A, B = map(int, stdin.readline().strip().split())\n        superiors[A].append(B)\n\n    return str(count_valid_invitations(superiors, jokes))"
    },
    {
        "number": 3097,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def reverse(n: int) -> int:\n        return int(str(n)[::-1])\n\n    def count_appearances(A: int, B: int) -> int:\n        count = 0\n        for i in range(1, B + 1):\n            for j in range(1, i + 1):\n                if A <= A(i, j) <= B:\n                    count += 1\n        return count\n\n    def A(i: int, j: int) -> int:\n        if j == 1:\n            return i\n        else:\n            return A(i, j - 1) + reverse(A(i, j - 1))\n\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    results = [count_appearances(A, B) for A, B in queries]\n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 3098,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def area(p1, p2, p3):\n        return abs((p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) / 2)\n\n    def compute_area(vertices):\n        n = len(vertices)\n        total_area = 0\n        for i in range(n):\n            total_area += area(vertices[i - 1], vertices[i], vertices[(i + 1) % n])\n        return total_area\n\n    def expected_area(n, k, vertices):\n        total_area = compute_area(vertices)\n        expected_area = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for l in range(j + 1, n):\n                    if len({i, j, l}) == k:\n                        expected_area += area(vertices[i], vertices[j], vertices[l])\n        return expected_area / (n * (n - 1) * (n - 2) / 6) * total_area\n\n    input_data = [line.strip().split() for line in stdin.split('\\n') if line.strip()]\n    n, k = map(int, input_data[0])\n    vertices = [(float(x), float(y)) for x, y in input_data[1:]]\n    result = expected_area(n, k, vertices)\n    return f\"{result:.8f}\""
    },
    {
        "number": 3099,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(graph, start, visited):\n        queue = [start]\n        visited[start] = True\n        while queue:\n            node = queue.pop(0)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n\n    def find_components(graph, visited):\n        components = []\n        for i in range(len(graph)):\n            if not visited[i]:\n                component = []\n                bfs(graph, i, visited)\n                for j in range(len(graph)):\n                    if visited[j]:\n                        component.append(j)\n                components.append(component)\n        return components\n\n    input_list = stdin.split('\\n')\n    S, E, C = map(int, input_list[0].split())\n    connections = [list(map(int, line.split())) for line in input_list[1:C + 1]]\n    enemies = list(map(int, input_list[C + 1].split()))\n\n    graph = [[] for _ in range(S)]\n    for connection in connections:\n        graph[connection[0]].append(connection[1])\n        graph[connection[1]].append(connection[0])\n\n    visited = [False] * S\n    components = find_components(graph, visited)\n\n    messages = 0\n    for component in components:\n        enemy_in_component = False\n        for enemy in enemies:\n            if enemy in component:\n                enemy_in_component = True\n                break\n        if enemy_in_component:\n            messages += len(component) - 1\n        else:\n            messages += 1\n\n    return str(messages)"
    },
    {
        "number": 3100,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def count_ways(a, c, m):\n        if a < 0 or c < 0 or m < 0:\n            return 0\n        if a == 0 and c == 0 and m == 0:\n            return 1\n        return (count_ways(a - 1, c, m) + count_ways(a, c - 1, m) + count_ways(a, c, m - 1)) % mod\n\n    return str(count_ways(A, C, M))"
    },
    {
        "number": 3101,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    zeus_answer = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return \"impossible\"\n\n    for i in range(n - 1):\n        if zeus_answer[i] > zeus_answer[i + 1]:\n            for j in range(9):\n                if j < zeus_answer[i + 1]:\n                    continue\n                new_answer = zeus_answer.copy()\n                new_answer[i + 1] = j + 1\n                if new_answer == sorted(new_answer):\n                    return \" \".join(map(str, new_answer))\n            return \"impossible\"\n\n    return \"impossible\""
    },
    {
        "number": 3102,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n\n    for num in range(L, R + 1):\n        has_four = False\n        lucky_count = 0\n        unlucky_count = 0\n\n        for digit in str(num):\n            if digit == '4':\n                has_four = True\n                break\n            elif digit == '6' or digit == '8':\n                lucky_count += 1\n            else:\n                unlucky_count += 1\n\n        if not has_four and lucky_count == unlucky_count:\n            count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 3103,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split()[:3])\n    map_data = stdin.split('\\n')[1:]\n    castle_pos = None\n    for y in range(Y):\n        for x in range(X):\n            if map_data[y][x] == '@':\n                castle_pos = (y, x)\n                break\n        if castle_pos:\n            break\n\n    def dfs(y, x, direction, visited):\n        if (y, x, direction) in visited:\n            return 0\n        visited.add((y, x, direction))\n\n        if y == castle_pos[0] and x == castle_pos[1]:\n            return 1\n\n        if direction == '>':\n            if x + 1 < X and map_data[y][x + 1] not in ('<', '#'):\n                return dfs(y, x + 1, '>', visited)\n            else:\n                return 0\n        elif direction == '<':\n            if x - 1 >= 0 and map_data[y][x - 1] not in ('>', '#'):\n                return dfs(y, x - 1, '<', visited)\n            else:\n                return 0\n        else:\n            if y + 1 < Y and map_data[y + 1][x] != '#':\n                return dfs(y + 1, x, 'v', visited)\n            else:\n                return 0\n\n    result = dfs(Y - 1, x_init, 'h', set())\n    if result == 0:\n        return \"begin repairs\"\n    else:\n        return str(result) % 1000003 "
    },
    {
        "number": 3104,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.split('=')\n    A = list(A)\n    S = int(S)\n    i = 0\n    while i < len(A) - 1:\n        if int(A[i]) + int(A[i + 1]) == S:\n            A.insert(i, '+')\n            i += 1\n        i += 1\n    return ''.join(A) + '=' + str(S)"
    },
    {
        "number": 3105,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    S = [int(x) for x in stdin.readlines()]\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if S[i] != S[j]:\n                for k in range(j + 1, N):\n                    if S[i] == S[k] and S[j] == S[k + 1]:\n                        return f\"{S[i]} {S[j]}\"\n    return \"-1\""
    },
    {
        "number": 3106,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(i) for i in stdin]\n    n = len(lights)\n    time = 0\n\n    for i in range(n):\n        if lights[i] == 0:\n            time = max(time, i + 1)\n\n    for i in range(n):\n        if lights[i] == 0:\n            time = max(time, i + 1)\n            for j in range(i + 1, n):\n                if j % (j - i) == 0:\n                    lights[j] = 1 - lights[j]\n\n    return str(time)"
    },
    {
        "number": 3107,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_encounters(truck1, truck2):\n        encounters = 0\n        for i in range(len(truck1) - 1):\n            for j in range(i + 1, len(truck1)):\n                if truck1[i] < truck1[j] > truck2[i] < truck2[j]:\n                    encounters += 1\n        return encounters\n\n    stdin_list = stdin.strip().split('\\n')\n    N, M = map(int, stdin_list[0].split())\n    trucks = []\n    for i in range(1, N + 1):\n        truck = list(map(int, stdin_list[i].split()))\n        trucks.append(truck[1:])\n\n    result = []\n    for i in range(N, N + M):\n        truck1, truck2 = map(int, stdin_list[i].split())\n        result.append(count_encounters(trucks[truck1 - 1], trucks[truck2 - 1]))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3108,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    arr = list(map(int, input().split()))\n\n    max_avg = sum(arr[:K]) / K\n    current_sum = max_avg * K\n\n    for i in range(K, N):\n        current_sum += arr[i] - arr[i - K]\n        max_avg = max(max_avg, current_sum / K)\n\n    return f\"{max_avg:.6f}\""
    },
    {
        "number": 3109,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_line() -> List[str]:\n        return list(map(str, stdin.readline().strip().split()))\n\n    def read_float_list() -> List[float]:\n        return list(map(float, read_line()))\n\n    def read_int_list() -> List[int]:\n        return list(map(int, read_line()))\n\n    n, m, w, h = read_int_list()\n    v = read_float_list()\n    x = read_float_list()\n    min_sand = [read_float_list() for _ in range(n)]\n    max_sand = [read_float_list() for _ in range(n)]\n\n    total_sand = sum(v)\n    section_height = [0] * n\n    for i in range(n):\n        section_height[i] = (h * w) - (w - x[i]) * h\n\n    min_section_height = min(section_height)\n    max_section_height = max(section_height)\n\n    min_sand_height = [0] * n\n    max_sand_height = [0] * n\n    for i in range(n):\n        for j in range(m):\n            min_sand_height[i] += min_sand[i][j]\n            max_sand_height[i] += max_sand[i][j]\n\n    min_sand_height = [min_section_height - h for h in min_sand_height]\n    max_sand_height = [max_section_height - h for h in max_sand_height]\n\n    min_difference = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if min_sand[i][j] > 0:\n                min_sand_height[i] += min_sand[i][j]\n            if max_sand[i][j] > 0:\n                max_sand_height[i] += max_sand[i][j]\n\n            min_difference = min(min_difference, max(max_sand_height) - min(min_sand_height))\n\n            if max_sand[i][j] > 0:\n                max_sand_height[i] -= max_sand[i][j]\n            if min_sand[i][j] > 0:\n                min_sand_height[i] -= min_sand[i][j]\n\n    return f\"{min_difference:.3f}\""
    },
    {
        "number": 3110,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(matrix, row, col, value):\n        if row > 0:\n            if matrix[row - 1][col] == value:\n                return False\n        if col > 0:\n            if matrix[row][col - 1] == value:\n                return False\n        if row < len(matrix) - 1:\n            if matrix[row + 1][col] == value:\n                return False\n        if col < len(matrix[0]) - 1:\n            if matrix[row][col + 1] == value:\n                return False\n        return True\n\n    def dfs(matrix, row, col, missing):\n        if missing == 0:\n            return 1\n        if row == len(matrix) - 1 and col == len(matrix[0]) - 1:\n            return 0\n        total = 0\n        for value in range(1, 10):\n            if is_valid(matrix, row, col, value):\n                matrix[row][col] = value\n                total += dfs(matrix, row + (col + 1) // len(matrix[0]), (col + 1) % len(matrix[0]), missing - 1)\n                matrix[row][col] = 0\n        return total\n\n    m, n = map(int, stdin.readline().split())\n    matrix = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    missing = sum(row.count(0) for row in matrix)\n    return str(dfs(matrix, 0, 0, missing))"
    },
    {
        "number": 3111,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    dials = list(stdin.readline())\n    result = []\n\n    for _ in range(M):\n        A, B = map(int, stdin.readline().split())\n        total = sum(int(dials[i - 1]) for i in range(A, B + 1))\n        result.append(total)\n\n        for i in range(A - 1, B):\n            dials[i] = str((int(dials[i]) + 1) % 10)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3112,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(producers):\n        used_edges = set()\n        for producer in producers:\n            junction = producer + 1\n            while junction != N:\n                for a, b in edges:\n                    if a == junction and (a, b) not in used_edges:\n                        used_edges.add((a, b))\n                        junction = b\n                        break\n                else:\n                    return False\n        return True\n\n    def dfs(producers, k):\n        if k == K:\n            return is_valid(producers)\n        if dfs(producers, k + 1):\n            return k\n        producers.append(k)\n        if dfs(producers, k + 1):\n            return k\n        producers.pop()\n        return dfs(producers, k + 1)\n\n    N, K, M = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n\n    producers = []\n    max_producers = dfs(producers, 0)\n    return str(max_producers)"
    },
    {
        "number": 3113,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_degenerate(triangle):\n        x1, y1, x2, y2, x3, y3 = triangle\n        return (x1 == x2 and y1 == y2) or (x2 == x3 and y2 == y3) or (x1 == x3 and y1 == y3)\n\n    def area(triangle):\n        x1, y1, x2, y2, x3, y3 = triangle\n        return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)\n\n    def is_intersecting(triangle1, triangle2):\n        x1, y1, x2, y2, x3, y3 = triangle1\n        a1, b1, c1, d1, e1, f1 = triangle2\n\n        if is_degenerate(triangle1) or is_degenerate(triangle2):\n            return False\n\n        if (x1 <= a1 <= x2 or x1 <= a1 <= x3 or x2 <= a1 <= x3) and \\\n                (y1 <= b1 <= y2 or y1 <= b1 <= y3 or y2 <= b1 <= y3) and \\\n                (x1 <= c1 <= x2 or x1 <= c1 <= x3 or x2 <= c1 <= x3) and \\\n                (y1 <= d1 <= y2 or y1 <= d1 <= y3 or y2 <= d1 <= y3) and \\\n                (x1 <= e1 <= x2 or x1 <= e1 <= x3 or x2 <= e1 <= x3) and \\\n                (y1 <= f1 <= y2 or y1 <= f1 <= y3 or y2 <= f1 <= y3):\n            return True\n\n        return False\n\n    def is_same_cover(garry_triangles, jerry_triangles):\n        for triangle1 in garry_triangles:\n            found = False\n            for triangle2 in jerry_triangles:\n                if area(triangle1) == area(triangle2) and not is_intersecting(triangle1, triangle2):\n                    found = True\n                    break\n            if not found:\n                return False\n        return True\n\n    def read_triangles(n):\n        triangles = []\n        for _ in range(n):\n            x1, y1, x2, y2, x3, y3 = map(int, input().split())\n            triangles.append((x1, y1, x2, y2, x3, y3))\n        return triangles\n\n    n = int(input())\n    garry_triangles = read_triangles(n)\n    m = int(input())\n    jerry_triangles = read_triangles(m)\n\n    if is_same_cover(garry_triangles, jerry_triangles):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3114,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, start, visited):\n        if start not in visited:\n            visited.add(start)\n            for neighbor in graph[start]:\n                if neighbor not in visited:\n                    dfs(graph, neighbor, visited)\n\n    def is_possible(graph, start, visited):\n        if start not in visited:\n            visited.add(start)\n            for neighbor in graph[start]:\n                if neighbor not in visited:\n                    if not is_possible(graph, neighbor, visited):\n                        return False\n            return True\n        return True\n\n    def create_graph(roads):\n        graph = {i: [] for i in range(1, N + 1)}\n        for road in roads:\n            x, y = map(int, road.split())\n            graph[x].append(y)\n            graph[y].append(x)\n        return graph\n\n    def find_direction(graph, start, visited):\n        if start not in visited:\n            visited.add(start)\n            for neighbor in graph[start]:\n                if neighbor not in visited:\n                    print(start, neighbor)\n                    find_direction(graph, neighbor, visited)\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    roads = lines[1:M + 1]\n    graph = create_graph(roads)\n    visited = set()\n    dfs(graph, 1, visited)\n\n    if len(visited) == N:\n        visited = set()\n        if is_possible(graph, 1, visited):\n            print(\"YES\")\n            visited = set()\n            find_direction(graph, 1, visited)\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")"
    },
    {
        "number": 3115,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    players = [0] * N\n    matches = []\n\n    for _ in range(M):\n        K, symbol, L = stdin.readline().split()\n        K, L = int(K), int(L)\n\n        if symbol == '=':\n            players[K] += 1\n            players[L] += 1\n        elif symbol == '>':\n            matches.append((K, L))\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if players[i] == players[j]:\n                continue\n            elif players[i] > players[j]:\n                if (j, i) in matches:\n                    return \"inconsistent\"\n            else:\n                if (i, j) in matches:\n                    return \"inconsistent\"\n\n    return \"consistent\""
    },
    {
        "number": 3116,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** 0.5\n\n    def smallest_cylinder(stars):\n        min_volume = float('inf')\n        for i in range(len(stars)):\n            for j in range(i + 1, len(stars)):\n                for k in range(j + 1, len(stars)):\n                    a, b, c = stars[i], stars[j], stars[k]\n                    if distance(a, b) == 0 or distance(b, c) == 0 or distance(a, c) == 0:\n                        continue\n                    if distance(a, b) == distance(b, c) == distance(a, c):\n                        continue\n                    ab, bc, ca = distance(a, b), distance(b, c), distance(c, a)\n                    height = ab + bc + ca\n                    radius = ab * bc * ca / (2 * height)\n                    volume = 3.141592653589793 * height * radius ** 2\n                    min_volume = min(min_volume, volume)\n        return min_volume\n\n    n = int(stdin.readline().strip())\n    stars = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    return f\"{smallest_cylinder(stars):.6f}\""
    },
    {
        "number": 3117,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    d = {}\n    for i in range(L):\n        for j in range(i + 1, L + 1):\n            substring = s[i:j]\n            if substring in d:\n                d[substring] += 1\n            else:\n                d[substring] = 1\n\n    max_length = 0\n    for substring, count in d.items():\n        if count >= 2 and len(substring) > max_length:\n            max_length = len(substring)\n\n    return str(max_length)"
    },
    {
        "number": 3118,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_cycle_length(perm):\n        for i in range(1, len(perm) + 1):\n            if perm[i] == i:\n                return i\n        return len(perm)\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def get_lcm_for_cycle(cycle):\n        lcm_cycle = 1\n        for i in range(1, len(cycle)):\n            if cycle[i] != cycle[i - 1] + 1:\n                lcm_cycle = lcm(lcm_cycle, len(cycle) - i)\n                if lcm_cycle > 10**12:\n                    return \"huge\"\n        return lcm_cycle\n\n    def get_min_shuffles(n, a_perm, b_perm):\n        a_cycle = get_cycle_length(a_perm)\n        b_cycle = get_cycle_length(b_perm)\n\n        if a_cycle == n and b_cycle == n:\n            return 2\n\n        lcm_cycle = get_lcm_for_cycle(a_perm)\n        if lcm_cycle == \"huge\":\n            return \"huge\"\n\n        lcm_cycle = get_lcm_for_cycle(b_perm)\n        if lcm_cycle == \"huge\":\n            return \"huge\"\n\n        return lcm(a_cycle, b_cycle)\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    a_perm = list(map(int, lines[1].split()))\n    b_perm = list(map(int, lines[2].split()))\n\n    return str(get_min_shuffles(n, a_perm, b_perm))"
    },
    {
        "number": 3119,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.readline().split())\n    notes = list(map(int, stdin.readline().split()))\n    sp_phrases = [list(map(int, stdin.readline().split())) for _ in range(p)]\n\n    def is_overlapping(phrase1, phrase2):\n        return phrase1[0] <= phrase2[1] and phrase1[1] >= phrase2[0]\n\n    def get_score(notes, sp_phrases):\n        score = 0\n        sp_meter = 0\n        sp_activated = False\n        last_note = -1\n\n        for i, note in enumerate(notes):\n            if sp_activated:\n                if sp_meter == 0:\n                    sp_activated = False\n                    score += 1\n                else:\n                    score += 2\n                sp_meter -= (note - last_note) / 1000\n            else:\n                score += 1\n\n            for phrase in sp_phrases:\n                if is_overlapping([note, note], phrase):\n                    sp_meter = max(sp_meter, pi + 7 ** 0.25)\n                    sp_activated = True\n                    sp_phrases.remove(phrase)\n                    break\n\n            last_note = note\n\n        return score\n\n    return get_score(notes, sp_phrases)"
    },
    {
        "number": 3120,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_expression(expression: str) -> List[int]:\n        if expression[0] == \"[\":\n            return [int(x) for x in expression[1:-1].split(\",\")]\n        elif expression[:5] == \"shuffle\":\n            return shuffle(parse_expression(expression[6:-1]))\n        elif expression[:6] == \"sorted\":\n            return sorted(parse_expression(expression[7:-1]))\n        else:\n            raise ValueError(\"Invalid expression\")\n\n    def shuffle(lst: List[int]) -> List[int]:\n        return random.sample(lst, len(lst))\n\n    def is_equal(a: str, b: str) -> bool:\n        a_lst = parse_expression(a)\n        b_lst = parse_expression(b)\n\n        if len(a_lst) != len(b_lst):\n            return False\n\n        a_lst.sort()\n        b_lst.sort()\n\n        return a_lst == b_lst\n\n    a, b = stdin.split(\"\\n\")\n    return \"equal\" if is_equal(a, b) else \"not equal\" "
    },
    {
        "number": 3121,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_lines = stdin.split('\\n')\n    A, H = map(int, input_lines[0].split())\n    n, m = map(int, input_lines[1].split())\n    passages = []\n    for i in range(2, m + 2):\n        e, b, a, h = map(int, input_lines[i].split())\n        passages.append((e, b, a, h))\n\n    # Initialize DP table\n    dp = [[float('inf')] * (H + 1) for _ in range(n + 1)]\n    dp[1][H] = 0\n\n    # DP\n    for i in range(1, n + 1):\n        for j in range(H, -1, -1):\n            for e, b, a, h in passages:\n                if e == i:\n                    for k in range(j, -1, -1):\n                        if k >= a:\n                            dp[b][j] = min(dp[b][j], dp[e][k - a] + 1)\n\n    # Find the maximum health\n    max_health = 0\n    for i in range(1, n + 1):\n        for j in range(H, -1, -1):\n            if dp[i][j] != float('inf'):\n                max_health = max(max_health, j)\n\n    # Output\n    if max_health == 0:\n        return 'Oh no'\n    else:\n        return str(max_health)"
    },
    {
        "number": 3122,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    airport_requirements = [0] * n\n    routes = []\n\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        routes.append((a - 1, b - 1, c))\n\n    for route in routes:\n        airport_requirements[route[0]] += route[2]\n        airport_requirements[route[1]] += route[2]\n\n    lounge_count = sum(1 for req in airport_requirements if req > 0)\n\n    for route in routes:\n        if route[2] == 2 and airport_requirements[route[0]] == 1 and airport_requirements[route[1]] == 1:\n            lounge_count -= 1\n\n    return str(lounge_count) if lounge_count <= 200000 else \"impossible\""
    },
    {
        "number": 3123,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 1 and a[0] == 0:\n        return \"no quotation\"\n\n    k = 1\n    while k <= n // 2:\n        if a[2 * k - 2] != a[2 * k - 1]:\n            break\n        k += 1\n\n    if k == 1:\n        return \"1\"\n    elif k == n // 2:\n        return str(k)\n    else:\n        return \"no quotation\""
    },
    {
        "number": 3124,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, numbers = int(stdin.split(\"\\n\")[0]), list(map(int, stdin.split(\"\\n\")[1].split()))\n    count = 0\n    for i in range(N):\n        if numbers[i] % 2 != 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3125,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split('\\n')\n    input_str = input_str.replace('+', \"'\").replace('-', '\"')\n    output_str = output_str.replace('+', \"'\").replace('-', '\"')\n\n    if input_str == \"\" and output_str == \"\":\n        return \"<any> <empty>\"\n    elif input_str == \"\" and output_str != \"\":\n        return \"<any> corrupted\"\n    elif input_str != \"\" and output_str == \"\":\n        return \"corrupted <empty>\"\n    else:\n        input_set = set(input_str)\n        output_set = set(output_str)\n\n        if len(input_set) == len(output_set):\n            return \"<any> <any>\"\n        elif len(input_set) == 2 and len(output_set) == 2:\n            return \"<any> <empty>\"\n        else:\n            return \"corrupted corrupted\""
    },
    {
        "number": 3126,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_jumps(n, t, frogs, changes):\n        jumps = [0] * n\n        for i in range(n):\n            jumps[i] = (i + 1) * (frogs[i] - t)\n        jumps.sort()\n        return sum(jumps[:n - 1]) + jumps[n - 1]\n\n    n, t = map(int, stdin.readline().split())\n    frogs = list(map(int, stdin.readline().split()))\n    changes = int(stdin.readline())\n    frogs.sort()\n\n    result = []\n    for _ in range(changes):\n        change_type, value = stdin.readline().split()\n        if change_type == '+':\n            frogs.append(int(value))\n        elif change_type == '-':\n            frogs.remove(int(value))\n        elif change_type == 't':\n            t = int(value)\n        frogs.sort()\n        result.append(min_jumps(n, t, frogs, changes))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3127,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, _ = map(int, stdin.readline().split())\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    visited = [False] * (n + 1)\n    queue = [1]\n    visited[1] = True\n    while queue:\n        node = queue.pop(0)\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n\n    unused_switches = [i for i in range(2, n + 1) if not visited[i]]\n    k = len(unused_switches)\n    return f\"{k}\\n{' '.join(map(str, unused_switches))}\""
    },
    {
        "number": 3128,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def create_movie(x, plot_order, creation_order):\n        for i in range(len(plot_order)):\n            if plot_order[i] >= x:\n                plot_order[i] += 1\n        creation_order.append(x)\n\n    def get_creation_index(x, plot_order, creation_order):\n        return creation_order[plot_order.index(x)]\n\n    lines = stdin.split('\\n')\n    Q = int(lines[0])\n    plot_order = [i for i in range(1, Q + 1)]\n    creation_order = []\n\n    for i in range(1, len(lines), 2):\n        q, x = map(int, lines[i].split())\n        if q == 1:\n            create_movie(x, plot_order, creation_order)\n        else:\n            print(get_creation_index(x, plot_order, creation_order))\n\n    return ''"
    },
    {
        "number": 3129,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count = 0\n\n    for i in range(n - 2):\n        if s[i] == 'P' and s[i + 1] == 'C':\n            s = s[:i] + s[i + 1] + s[i] + s[i + 2:]\n            count += 1\n        elif s[i] == 'C' and s[i + 1] == 'P':\n            s = s[:i] + s[i + 1] + s[i] + s[i + 2:]\n            count += 1\n\n    return count"
    },
    {
        "number": 3130,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    D, M, N = map(int, stdin.readline().split())\n    implications = [tuple(map(int, stdin.readline().split())) for _ in range(M)]\n    evidence = [int(stdin.readline()) for _ in range(N)]\n\n    # Create implication graph\n    implication_graph = {i: [] for i in range(1, D + 1)}\n    for a, b in implications:\n        implication_graph[a].append(b)\n\n    # Find all events that have certainly occurred\n    certain_events = set()\n    for event in evidence:\n        queue = [event]\n        while queue:\n            current_event = queue.pop(0)\n            if current_event not in certain_events:\n                certain_events.add(current_event)\n                queue.extend(implication_graph[current_event])\n\n    # Sort and format output\n    output = \" \".join(map(str, sorted(list(certain_events))))\n    return output"
    },
    {
        "number": 3131,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    mod = 1000000007\n    result = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if len({a[i], a[j], a[k]}) == K:\n                    result += max(a[i], a[j], a[k])\n\n    return str(result % mod)"
    },
    {
        "number": 3132,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(R)]\n\n    def find_building(grid, start_row, start_col):\n        size = 1\n        while start_row + size <= R and start_col + size <= C:\n            for i in range(start_row, start_row + size):\n                for j in range(start_col, start_col + size):\n                    if grid[i][j] == '.':\n                        return None\n            start_row += 1\n            start_col += 1\n            size += 1\n        return size\n\n    def find_buildings(grid):\n        buildings = []\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 'x':\n                    size = find_building(grid, i, j)\n                    if size:\n                        buildings.append((i, j, size))\n        return buildings\n\n    buildings = find_buildings(grid)\n    return \"\\n\".join(f\"{row} {col} {size}\" for row, col, size in buildings)"
    },
    {
        "number": 3133,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B = map(int, stdin.readline().split())\n    intersections = []\n    for i in range(n):\n        intersections.append(list(map(int, stdin.readline().split())))\n\n    def find_path(start, end):\n        visited = [False] * n\n        visited[start] = True\n        queue = [(start, 0)]\n\n        while queue:\n            current, turns = queue.pop(0)\n            if current == end:\n                return turns\n\n            for neighbor in [intersections[current][0], intersections[current][1]]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, turns + 1))\n\n        return None\n\n    alice_path = find_path(A, B)\n    bob_path = find_path(B, A)\n\n    if alice_path is None or bob_path is None:\n        return \"indistinguishable\"\n    else:\n        return min(alice_path, bob_path)"
    },
    {
        "number": 3134,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    row_parities, col_parities = stdin.strip().split('\\n')\n    n, m = len(row_parities), len(col_parities)\n\n    def get_matrix(row_parity, col_parity):\n        matrix = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if row_parity[i] == col_parity[j]:\n                    matrix[i][j] = 1\n        return matrix\n\n    def matrix_to_str(matrix):\n        return '\\n'.join([''.join(map(str, row)) for row in matrix])\n\n    def is_valid(matrix):\n        for i in range(n):\n            row_sum = sum(matrix[i])\n            if row_sum % 2 != int(row_parities[i]):\n                return False\n        for j in range(m):\n            col_sum = sum(matrix[i][j] for i in range(n))\n            if col_sum % 2 != int(col_parities[j]):\n                return False\n        return True\n\n    matrix = get_matrix(row_parities, col_parities)\n    if is_valid(matrix):\n        return matrix_to_str(matrix)\n    else:\n        return '-1'"
    },
    {
        "number": 3135,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    k = 0\n    while n >= 2 ** k:\n        k += 1\n    k -= 1\n\n    min_non_zero_digits = k + 1\n    min_representation = \"\"\n\n    for i in range(k, -1, -1):\n        if n >= 2 ** i:\n            n -= 2 ** i\n            min_representation += \"+\"\n        elif i < k and min_representation[-1] == \"+\":\n            min_representation += \"0\"\n\n    return min_representation"
    },
    {
        "number": 3136,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        shortest_paths = {vertex: float('infinity') for vertex in graph}\n        shortest_paths[start] = 0\n        unvisited_vertices = list(shortest_paths.keys())\n        while unvisited_vertices:\n            current_vertex = min(unvisited_vertices, key=lambda vertex: shortest_paths[vertex])\n            unvisited_vertices.remove(current_vertex)\n            if current_vertex == end:\n                return shortest_paths[end]\n            for neighbor, weight in graph[current_vertex].items():\n                distance = shortest_paths[current_vertex] + weight\n                if distance < shortest_paths[neighbor]:\n                    shortest_paths[neighbor] = distance\n        return shortest_paths[end]\n\n    def build_graph(roads):\n        graph = {i: {} for i in range(1, n + 1)}\n        for u, v, d in roads:\n            graph[u][v] = d\n            graph[v][u] = d\n        return graph\n\n    lines = stdin.strip().split('\\n')\n    n, m, s, t = map(int, lines[0].split())\n    a, b = map(int, lines[1].split())\n    x = list(map(int, lines[2].split()))\n    y = list(map(int, lines[3].split()))\n    roads = [list(map(int, lines[4 + i].split())) for i in range(m)]\n\n    graph = build_graph(roads)\n    total_distance = 0\n\n    for i in range(t):\n        dist_to_warehouse = min(dijkstra(graph, x[i], a), dijkstra(graph, x[i], b))\n        total_distance += dist_to_warehouse\n        x.pop(x.index(y[i]))\n\n    return str(total_distance)"
    },
    {
        "number": 3137,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 1 <= x <= N and 1 <= y <= M\n\n    def move(x, y, direction):\n        if direction == \"U\":\n            return x - 1, y\n        elif direction == \"R\":\n            return x, y + 1\n        elif direction == \"D\":\n            return x + 1, y\n        else:\n            return x, y - 1\n\n    def rotate(direction, turns):\n        for _ in range(turns):\n            if direction == \"U\":\n                direction = \"L\"\n            elif direction == \"L\":\n                direction = \"D\"\n            elif direction == \"D\":\n                direction = \"R\"\n            else:\n                direction = \"U\"\n        return direction\n\n    lines = stdin.splitlines()\n    N, M, K = map(int, lines[0].split())\n    X, Y = map(int, lines[1].split())\n    bacteria = []\n    for i in range(K):\n        X_i, Y_i = map(int, lines[2 + i * (N + 1)].split())\n        C_i = lines[3 + i * (N + 1)]\n        matrix = [list(map(int, line)) for line in lines[4 + i * (N + 1):4 + (i + 1) * (N + 1)]]\n        bacteria.append((X_i, Y_i, C_i, matrix))\n\n    steps = 0\n    while True:\n        steps += 1\n        for i, (x, y, direction, matrix) in enumerate(bacteria):\n            X_i = matrix[x - 1][y - 1]\n            direction = rotate(direction, X_i)\n            x, y = move(x, y, direction)\n            if not is_valid(x, y):\n                direction = \"U\" if direction in (\"L\", \"R\") else \"R\"\n                x, y = move(x, y, direction)\n            bacteria[i] = (x, y, direction, matrix)\n\n        if all(x == X and y == Y for _, (x, y, _, _) in enumerate(bacteria)):\n            return steps\n\n    return -1"
    },
    {
        "number": 3138,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(n - 1):\n        if arr[i] == arr[i + 1]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3139,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_best_student(A, B, students):\n        best_student = None\n        min_diff = float('inf')\n        for i, (A_, B_) in enumerate(students):\n            if A <= A_ and B <= B_:\n                diff = abs(A_ - A) + abs(B_ - B)\n                if diff < min_diff:\n                    min_diff = diff\n                    best_student = i + 1\n        return best_student\n\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    students = []\n    output = []\n\n    for i in range(1, N + 1):\n        query = input_list[i].split()\n        if query[0] == 'D':\n            A, B = map(int, query[1:])\n            students.append((A, B))\n        elif query[0] == 'P':\n            i_student = int(query[1])\n            best_student = find_best_student(students[i_student - 1][0], students[i_student - 1][1], students)\n            output.append(best_student if best_student is not None else 'NE')\n\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3140,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l, x0, y0, t = map(int, stdin.split())\n    t = [list(map(int, line.split())) for line in t.split('\\n')]\n\n    def is_valid(x, y, time):\n        return 0 <= x < r and 0 <= y < c and t[x][y] <= time < t[x][y] + k\n\n    def dfs(x, y, time, visited):\n        if not is_valid(x, y, time):\n            return 0\n        if (x, y) in visited:\n            return 0\n        visited.add((x, y))\n\n        return 1 + dfs(x + 1, y, time + 1, visited) + \\\n               dfs(x - 1, y, time + 1, visited) + \\\n               dfs(x, y + 1, time + 1, visited) + \\\n               dfs(x, y - 1, time + 1, visited)\n\n    return str(dfs(x0, y0, 1, set()))"
    },
    {
        "number": 3141,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_diameter(flaws):\n        max_distance = 0\n        for i in range(len(flaws)):\n            for j in range(i + 1, len(flaws)):\n                distance = ((flaws[i][0] - flaws[j][0]) ** 2 + (flaws[i][1] - flaws[j][1]) ** 2 + (flaws[i][2] - flaws[j][2]) ** 2) ** 0.5\n                if distance > max_distance:\n                    max_distance = distance\n        return 2 * max_distance\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    flaws = []\n    for i in range(1, N + 1):\n        flaw = list(map(float, lines[i].split()))\n        flaws.append(flaw)\n\n    diameter = calculate_diameter(flaws)\n    return f\"{diameter:.10f}\""
    },
    {
        "number": 3142,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    min_num = None\n\n    for num in range(A, B + 1):\n        digit_sum = sum(int(digit) for digit in str(num))\n        if digit_sum == S:\n            count += 1\n            if min_num is None or num < min_num:\n                min_num = num\n\n    return f\"{count}\\n{min_num}\""
    },
    {
        "number": 3143,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_next_position(name, position, names, positions):\n        next_position = position\n        for i in range(len(names)):\n            if names[i] == name and positions[i] < next_position:\n                next_position = positions[i]\n        return next_position\n\n    def find_optimal_positions(names, positions):\n        optimal_positions = []\n        for i in range(len(names)):\n            optimal_positions.append(find_next_position(names[i], positions[i], names, positions))\n        return optimal_positions\n\n    def count_inspections(names, positions):\n        inspections = 0\n        for i in range(len(names)):\n            if positions[i] == i + 1:\n                inspections += 1\n        return inspections\n\n    def find_minimal_inspections(names, positions):\n        optimal_positions = find_optimal_positions(names, positions)\n        return count_inspections(names, optimal_positions)\n\n    def find_minimal_inspections_output(names, positions):\n        optimal_positions = find_optimal_positions(names, positions)\n        return optimal_positions\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    names = list(map(int, lines[1].split()))\n    positions = list(map(int, lines[2].split()))\n\n    minimal_inspections = find_minimal_inspections(names, positions)\n    optimal_positions = find_minimal_inspections_output(names, positions)\n\n    return f'{minimal_inspections}\\n{\" \".join(map(str, optimal_positions))}'"
    },
    {
        "number": 3144,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    M = 0\n\n    for i in range(n):\n        if i < k:\n            M += d\n        else:\n            M += g\n\n    return str(M)"
    },
    {
        "number": 3145,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B, allowed_digits = map(int, stdin.split('\\n')[0].split()), sorted(map(int, stdin.split('\\n')[1])), set(allowed_digits)\n\n    def is_valid(num: int) -> bool:\n        return all(digit in allowed_digits for digit in map(int, str(num)))\n\n    count = 0\n    for i in range(A, B + 1):\n        if i % X == 0 and is_valid(i):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3146,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def avg_completion_time(prescriptions, technicians):\n        in_store = [pres for pres in prescriptions if pres[1] == 'S']\n        remote = [pres for pres in prescriptions if pres[1] == 'R']\n\n        in_store.sort(key=lambda x: x[0])\n        remote.sort(key=lambda x: x[0])\n\n        in_store_time = 0\n        remote_time = 0\n        in_store_count = 0\n        remote_count = 0\n\n        for i in range(len(in_store)):\n            if i % technicians == 0:\n                in_store_time += in_store[i][2]\n            else:\n                in_store_time += in_store[i][2] + in_store_time\n            in_store_count += 1\n\n        for i in range(len(remote)):\n            if i % technicians == 0:\n                remote_time += remote[i][2]\n            else:\n                remote_time += remote[i][2] + remote_time\n            remote_count += 1\n\n        return (in_store_time / in_store_count, remote_time / remote_count)\n\n    lines = stdin.split('\\n')\n    n, t = map(int, lines[0].split())\n    prescriptions = [list(map(int, line.split()[0])) + [line.split()[1]] + [int(line.split()[2])] for line in lines[1:n+1]]\n\n    o, r = avg_completion_time(prescriptions, t)\n    return f\"{o:.6f} {r:.6f}\""
    },
    {
        "number": 3147,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    memory = [list(map(int, stdin.readline().strip())) for _ in range(R)]\n\n    def is_killer(matrix):\n        rotated = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]) - 1, -1, -1)]\n        return matrix == rotated\n\n    def find_killers(matrix, r, c, killer_size=1):\n        if r - killer_size < 0 or c - killer_size < 0:\n            return 0\n\n        for i in range(r - killer_size + 1):\n            for j in range(c - killer_size + 1):\n                submatrix = [row[j:j + killer_size] for row in matrix[i:i + killer_size]]\n                if is_killer(submatrix):\n                    return killer_size\n\n        return find_killers(matrix, r, c, killer_size + 1)\n\n    largest_killer = -1\n    for i in range(R):\n        for j in range(C):\n            if memory[i][j] == 1:\n                killer_size = find_killers(memory, R, C)\n                largest_killer = max(largest_killer, killer_size)\n\n    return str(largest_killer)"
    },
    {
        "number": 3148,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    n = int(stdin.readline().strip())\n    swimmers = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        swimmers.append((x, y))\n\n    swimmers.sort()\n    mid = n // 2\n    first_half = swimmers[:mid]\n    second_half = swimmers[mid:]\n\n    first_lifeguard_x, first_lifeguard_y = first_half[-1]\n    second_lifeguard_x, second_lifeguard_y = second_half[0]\n\n    for i in range(mid):\n        if distance(first_lifeguard_x, first_lifeguard_y, swimmers[i][0], swimmers[i][1]) == distance(second_lifeguard_x, second_lifeguard_y, swimmers[i][0], swimmers[i][1]):\n            first_lifeguard_x, first_lifeguard_y = swimmers[i]\n            second_lifeguard_x, second_lifeguard_y = swimmers[i + 1]\n            break\n\n    return f\"{first_lifeguard_x} {first_lifeguard_y}\\n{second_lifeguard_x} {second_lifeguard_y}\""
    },
    {
        "number": 3149,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from math import sin, cos, radians\n\n    def rotate(x, y, angle):\n        return x * cos(angle) - y * sin(angle), x * sin(angle) + y * cos(angle)\n\n    def distance_to_wall(x, y, w):\n        return abs(x - w)\n\n    def time_to_wall(x, y, vx, vy, w):\n        return distance_to_wall(x, y, w) / vx\n\n    def compute_trajectory(n, omega, v0, theta, w, vertices):\n        theta = radians(theta)\n        omega = radians(omega)\n        trajectory = []\n\n        for i, (x, y) in enumerate(vertices):\n            x, y = rotate(x, y, theta)\n            vx = v0 * cos(omega)\n            vy = v0 * sin(omega)\n            t = time_to_wall(x, y, vx, vy, w)\n            trajectory.append((i + 1, t))\n\n        return trajectory\n\n    def find_first_hit(trajectory):\n        return min(trajectory, key=lambda x: x[1])\n\n    stdin = stdin.split('\\n')\n    n, omega, v0, theta, w = map(float, stdin[0].split())\n    n = int(n)\n    theta = int(theta)\n    vertices = [tuple(map(float, stdin[i + 1].split())) for i in range(n)]\n\n    trajectory = compute_trajectory(n, omega, v0, theta, w, vertices)\n    first_hit = find_first_hit(trajectory)\n\n    return f\"{first_hit[0]} {first_hit[1]:.6f}\""
    },
    {
        "number": 3150,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_visible(x1, y1, x2, y2, x3, y3):\n        if x1 == x2 == x3 or y1 == y2 == y3:\n            return False\n        if x1 == x2:\n            return y1 < y3 < y2 or y1 > y3 > y2\n        if y1 == y2:\n            return x1 < x3 < x2 or x1 > x3 > x2\n        return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)\n\n    def count_ways(guards, trenches):\n        ways = 0\n        for i in range(len(guards)):\n            for j in range(i + 1, len(guards)):\n                if all(is_visible(*guards[i], *guards[j], *t) for t in trenches):\n                    ways += 1\n        return ways\n\n    N = int(stdin.readline().strip())\n    trenches = [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n    guards = [(0, 0), (1000, 0), (0, 1000)]\n    return str(count_ways(guards, trenches))"
    },
    {
        "number": 3151,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    m = 0\n    k = 0\n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            if (i * i) - (n // i) ** 2 >= 0:\n                m = i\n                k = (i * i) - (n // i) ** 2\n                break\n\n    if m == 0 or k == 0:\n        return \"impossible\"\n    else:\n        return f\"{m} {k}\""
    },
    {
        "number": 3152,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = [int(x) for x in stdin.readlines()]\n    min_val = min(arr)\n    max_val = max(arr)\n    length = len(arr)\n    total_sum = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            sub_arr = arr[i:j + 1]\n            min_sub_val = min(sub_arr)\n            max_sub_val = max(sub_arr)\n            length_sub = len(sub_arr)\n            total_sum += min_sub_val * max_sub_val * length_sub\n\n    return str(total_sum % (10 ** 9))"
    },
    {
        "number": 3153,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_winner(a, b, cards):\n        if cards[a] > cards[b]:\n            return a\n        elif cards[a] < cards[b]:\n            return b\n        else:\n            return -1\n\n    def update_cards(a, b, winner, cards, cards_per_purchase):\n        if winner != -1:\n            cards[winner] += cards_per_purchase\n        else:\n            cards[a] += cards_per_purchase // 2\n            cards[b] += cards_per_purchase // 2\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    cards = list(map(int, lines[1].split()))\n    purchases = []\n\n    for i in range(2, 2 + M):\n        a, b = map(int, lines[i].split())\n        purchases.append((a, b))\n        cards_per_purchase = 2\n        winner = find_winner(a - 1, b - 1, cards)\n        update_cards(a - 1, b - 1, winner, cards, cards_per_purchase)\n\n    output = [str(M)]\n    for i, (a, b) in enumerate(purchases):\n        winner = find_winner(a - 1, b - 1, cards)\n        if winner == a - 1:\n            output.append(f\"{a} {b} 1\")\n        elif winner == b - 1:\n            output.append(f\"{a} {b} 2\")\n        else:\n            output.append(f\"{a} {b} 0\")\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3154,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def assign_toys(kids, toys, playtime, events):\n        toy_assignments = [0] * kids\n        toy_players = [[] for _ in range(toys)]\n        toy_playtime = [0] * toys\n\n        for event in events:\n            start, kid, toy = event\n            if toy == 0:\n                toy_assignments[kid - 1] = 0\n            else:\n                toy_assignments[kid - 1] = toy\n                toy_players[toy - 1].append(kid)\n                toy_playtime[toy - 1] += playtime - start\n\n        for toy_idx, players in enumerate(toy_players):\n            if len(players) > 1:\n                return \"impossible\"\n            elif len(players) == 1:\n                toy_assignments[players[0] - 1] = toy_idx + 1\n\n        return toy_assignments\n\n    def read_input(stdin: str):\n        lines = stdin.split(\"\\n\")\n        kids, toys, playtime, events = map(int, lines[0].split())\n        events = [list(map(int, line.split())) for line in lines[1:]]\n        return kids, toys, playtime, events\n\n    kids, toys, playtime, events = read_input(stdin)\n    toy_assignments = assign_toys(kids, toys, playtime, events)\n    return \" \".join(map(str, toy_assignments)) if toy_assignments != \"impossible\" else toy_assignments"
    },
    {
        "number": 3155,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 0\n    k = 0\n    min_n = float('inf')\n    min_k = float('inf')\n\n    for i in range(1, X + 1):\n        for j in range(i + 1):\n            if binomial(i, j) == X:\n                if i < min_n or (i == min_n and j < min_k):\n                    min_n = i\n                    min_k = j\n\n    return f\"{min_n} {min_k}\"\n\ndef"
    },
    {
        "number": 3156,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(inventory, shopping_list):\n        path = []\n        for item in shopping_list:\n            found = False\n            for store in inventory:\n                if item in store:\n                    path.append(inventory.index(store))\n                    found = True\n                    break\n            if not found:\n                return None\n        return path\n\n    def is_unique_path(inventory, shopping_list):\n        path = find_path(inventory, shopping_list)\n        if path is None:\n            return False\n        for i in range(len(path) - 1):\n            if path[i] == path[i + 1]:\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    N, K = map(int, lines[0].split())\n    inventory = [set() for _ in range(N)]\n    for i in range(K):\n        store, item = lines[i + 1].split()\n        inventory[int(store)].add(item)\n\n    M = int(lines[K + 1])\n    shopping_list = lines[K + 2:K + 2 + M]\n\n    if is_unique_path(inventory, shopping_list):\n        return \"unique\"\n    elif find_path(inventory, shopping_list) is not None:\n        return \"ambiguous\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3157,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    MOD = 2 ** M\n\n    def hash_function(word: str) -> int:\n        if not word:\n            return 0\n        else:\n            return (hash_function(word[:-1]) * 33 + ord(word[-1])) % MOD\n\n    count = 0\n    for i in range(1, N + 1):\n        for word in itertools.product(string.ascii_lowercase, repeat=i):\n            if hash_function(\"\".join(word)) == K:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3158,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_touches(image):\n        touches = []\n        for i in range(15):\n            for j in range(30):\n                if image[i][j] == \"X\":\n                    touches.append((i, j))\n        return touches\n\n    def get_grip_point(touches):\n        x_sum = sum(x for x, y in touches)\n        y_sum = sum(y for x, y in touches)\n        return (x_sum / len(touches), y_sum / len(touches))\n\n    def get_touch_vectors(grip_point, touches):\n        return [(x - grip_point[0], y - grip_point[1]) for x, y in touches]\n\n    def get_grip_spread(grip_point, touches):\n        return sum(abs(x - grip_point[0]) + abs(y - grip_point[1])) / len(touches)\n\n    def get_touch_rotation(initial_vectors, final_vectors):\n        rotations = []\n        for i in range(len(initial_vectors)):\n            initial_vector = initial_vectors[i]\n            final_vector = final_vectors[i]\n            dot_product = initial_vector[0] * final_vector[0] + initial_vector[1] * final_vector[1]\n            det = initial_vector[0] * final_vector[1] - initial_vector[1] * final_vector[0]\n            angle = atan2(det, dot_product)\n            rotations.append(angle)\n        return rotations\n\n    def get_grip_rotation(initial_grip_point, final_grip_point, touches):\n        initial_vectors = get_touch_vectors(initial_grip_point, touches)\n        final_vectors = get_touch_vectors(final_grip_point, touches)\n        rotations = get_touch_rotation(initial_vectors, final_vectors)\n        return sum(rotations) / len(rotations)\n\n    def get_pan_distance(initial_grip_point, final_grip_point):\n        return ((initial_grip_point[0] - final_grip_point[0]) ** 2 + (initial_grip_point[1] - final_grip_point[1]) ** 2) ** 0.5\n\n    def get_zoom_distance(initial_grip_spread, final_grip_spread):\n        return abs(initial_grip_spread - final_grip_spread)\n\n    def get_rotation_distance(initial_grip_point, final_grip_point, touches):\n        initial_grip_spread = get_grip_spread(initial_grip_point, touches)\n        final_grip_spread = get_grip_spread(final_grip_point, touches)\n        grip_rotation = get_grip_rotation(initial_grip_point, final_grip_point, touches)\n        rotation_distance = abs(grip_rotation) * initial_grip_spread\n        return rotation_distance\n\n    def classify_gesture(initial_image, final_image):\n        initial_touches = get_touches(initial_image)\n        final_touches = get_touches(final_image)\n        initial_grip_point = get_grip_point(initial_touches)\n        final_grip_point = get_grip_point(final_touches)\n        initial_grip_spread = get_grip_spread(initial_grip_point, initial_touches)\n        final_grip_spread = get_grip_spread(final_grip_point, final_touches)\n        pan_distance = get_pan_distance(initial_grip_point, final_grip_point)\n        zoom_distance = get_zoom_distance(initial_grip_spread, final_grip_spread)\n        rotation_distance = get_rotation_distance(initial_grip_point, final_grip_point, initial_touches)\n"
    },
    {
        "number": 3159,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_char(char: str) -> bool:\n        return char.isalnum() or char in ['?', '!', ',', '.', ' ']\n\n    def is_ad(image: list) -> bool:\n        for row in image:\n            for char in row:\n                if not is_valid_char(char):\n                    return True\n        return False\n\n    def remove_ad(image: list) -> list:\n        for i in range(len(image)):\n            for j in range(len(image[i])):\n                if image[i][j] == '$':\n                    image[i][j] = ' '\n        return image\n\n    def find_images(webpage: list) -> list:\n        images = []\n        for i in range(len(webpage)):\n            for j in range(len(webpage[i])):\n                if webpage[i][j] == '+':\n                    image, top, left = find_image(webpage, i, j)\n                    if image and not is_ad(image):\n                        images.append((image, top, left))\n        return images\n\n    def find_image(webpage: list, row: int, col: int) -> tuple:\n        if not (0 <= row < len(webpage) and 0 <= col < len(webpage[row])):\n            return None, None, None\n\n        if webpage[row][col] != '+':\n            return None, None, None\n\n        image = []\n        top, left = row, col\n        while top < len(webpage) and webpage[top][left] == '+':\n            image_row = []\n            for i in range(left + 1, len(webpage[top])):\n                if webpage[top][i] == '+':\n                    break\n                image_row.append(webpage[top][i])\n            image.append(image_row)\n            top += 1\n\n        if not image:\n            return None, None, None\n\n        for i in range(left, len(webpage[row])):\n            if webpage[row][i] == '+':\n                break\n            image[0].append(webpage[row][i])\n\n        for i in range(top, len(webpage)):\n            if webpage[i][left] == '+':\n                break\n            image.append(webpage[i][left + 1:])\n\n        return image, top, left\n\n    def process_webpage(webpage: list, images: list) -> str:\n        for image, top, left in images:\n            webpage[top] = webpage[top][:left] + ' ' * len(image[0]) + webpage[top][left + len(image[-1]) + 1:]\n            for i in range(top + 1, top + len(image)):\n                webpage[i] = ' ' * len(webpage[i])\n            for i in range(len(image)):\n                webpage[top + i] = webpage[top + i][:left + 1] + ' ' * len(image[i]) + webpage[top + i][left + len(image[i]) + 1:]\n\n        return ''.join([''.join(row) for row in webpage])\n\n    H, W = map(int, stdin.readline().strip().split())\n    webpage = [list(stdin.readline().strip()) for _ in range(H)]\n\n    images = find_images(webpage)\n    processed_webpage = process_webpage(webpage, images)\n\n    return processed_webpage"
    },
    {
        "number": 3160,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    n = len(S)\n    total_operations = 0\n    total_configurations = 0\n\n    for i in range(n):\n        if S[i] == \"H\":\n            total_operations += i + 1\n            total_configurations += 1\n        elif S[i] == \"T\":\n            total_operations += n - i\n            total_configurations += 1\n        elif S[i] == \"?\":\n            total_operations += (i + 1) * (n - i)\n            total_configurations += n - i\n\n    return str(total_operations / total_configurations)"
    },
    {
        "number": 3161,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def paint(n, target):\n        if n == 1:\n            return target\n        else:\n            new_n = n // 2\n            new_target = [[0] * new_n for _ in range(new_n)]\n            for i in range(new_n):\n                for j in range(new_n):\n                    if target[i][j] == 0:\n                        new_target[i][j] = 1\n                    else:\n                        new_target[i][j] = 0\n            return paint(new_n, new_target)\n\n    def count_diff(painted, target):\n        diff = 0\n        for i in range(len(painted)):\n            for j in range(len(painted)):\n                if painted[i][j] != target[i][j]:\n                    diff += 1\n        return diff\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    target = [[int(x) for x in row] for row in input_data[1:]]\n\n    painted = paint(n, target)\n    diff = count_diff(painted, target)\n\n    output = f'{diff}\\n'\n    for row in painted:\n        output += ''.join(str(x) for x in row) + '\\n'\n\n    return output"
    },
    {
        "number": 3162,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    schedule = []\n    for _ in range(n):\n        direction, t, m, a = stdin.readline().split()\n        schedule.append((direction, int(t), int(m), int(a)))\n\n    horizontal_pulses = [[] for _ in range(100001)]\n    vertical_pulses = [[] for _ in range(100001)]\n\n    for direction, t, m, a in schedule:\n        if direction == 'h':\n            horizontal_pulses[a].append((t, m))\n        else:\n            vertical_pulses[a].append((t, m))\n\n    activated_pixels = set()\n    max_horizontal_pulse = 0\n    max_vertical_pulse = 0\n\n    for i in range(1, 100001):\n        if horizontal_pulses[i]:\n            max_horizontal_pulse = max(max_horizontal_pulse, i)\n        if vertical_pulses[i]:\n            max_vertical_pulse = max(max_vertical_pulse, i)\n\n        for t, m in horizontal_pulses[i]:\n            for j in range(1, max_vertical_pulse + 1):\n                for t2, m2 in vertical_pulses[j]:\n                    if t <= t2 <= t + m and t2 + m2 > t + m:\n                        activated_pixels.add((i, j))\n\n    return len(activated_pixels)"
    },
    {
        "number": 3163,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(state: List[List[int]]) -> bool:\n        for shelf in state:\n            for i in range(len(shelf) - 1):\n                if shelf[i] != 0 and shelf[i] == shelf[i + 1]:\n                    return False\n        return True\n\n    def count_moves(state1: List[List[int]], state2: List[List[int]]) -> int:\n        moves = 0\n        for i in range(len(state1)):\n            for j in range(len(state1[0])):\n                if state1[i][j] != state2[i][j]:\n                    moves += 1\n        return moves // 2\n\n    def find_book(state: List[List[int]], book: int) -> Tuple[int, int]:\n        for i in range(len(state)):\n            for j in range(len(state[0])):\n                if state[i][j] == book:\n                    return i, j\n        return -1, -1\n\n    def move_book(state: List[List[int]], from_shelf: int, from_pos: int, to_shelf: int, to_pos: int) -> None:\n        state[from_shelf][from_pos] = 0\n        state[to_shelf][to_pos] = state[from_shelf][from_pos]\n\n    def solve(stdin: str) -> int:\n        lines = stdin.split('\\n')\n        N, M = map(int, lines[0].split())\n        state1 = [list(map(int, lines[i + 1].split())) for i in range(N)]\n        state2 = [list(map(int, lines[N + i + 1].split())) for i in range(N)]\n\n        if not is_valid(state1) or not is_valid(state2):\n            return -1\n\n        moves = count_moves(state1, state2)\n        for i in range(1, len(state1) * len(state1[0])):\n            for j in range(N):\n                for k in range(M):\n                    if state1[j][k] == i:\n                        from_shelf, from_pos = j, k\n                        break\n                else:\n                    continue\n                break\n            else:\n                continue\n            break\n\n        for to_shelf in range(N):\n            for to_pos in range(M):\n                if state2[to_shelf][to_pos] == i:\n                    move_book(state1, from_shelf, from_pos, to_shelf, to_pos)\n                    if state1 == state2:\n                        return moves\n                    move_book(state1, to_shelf, to_pos, from_shelf, from_pos)\n\n        return -1\n\n    return str(solve(stdin))"
    },
    {
        "number": 3164,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i, n):\n            if arr[j] in freq and freq[arr[j]] == 2:\n                freq[arr[j]] -= 1\n                max_length = max(max_length, j - i + 1)\n            else:\n                break\n\n    return str(max_length)"
    },
    {
        "number": 3165,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a, b):\n        return a ^ b\n\n    def is_attacked(board, row, col, rooks):\n        count = 0\n        for r in range(N):\n            if board[row][r] != -1:\n                count += rooks[board[row][r]]\n        for c in range(N):\n            if board[c][col] != -1:\n                count += rooks[board[c][col]]\n        return count > 0\n\n    def move_rook(board, rooks, R1, C1, R2, C2):\n        index = board[R1][C1]\n        board[R1][C1] = -1\n        board[R2][C2] = index\n\n    lines = stdin.split('\\n')\n    N, K, P = map(int, lines[0].split())\n    rooks = [0] * (K + 1)\n    board = [[-1] * N for _ in range(N)]\n\n    for i in range(1, K + 1):\n        R, C, X = map(int, lines[i].split())\n        board[R - 1][C - 1] = i\n        rooks[i] = X\n\n    attacked_fields = [0] * (P + 1)\n    for i in range(P):\n        R1, C1, R2, C2 = map(int, lines[K + 1 + i].split())\n        move_rook(board, rooks, R1 - 1, C1 - 1, R2 - 1, C2 - 1)\n        for r in range(N):\n            for c in range(N):\n                if is_attacked(board, r, c, rooks):\n                    attacked_fields[i + 1] += 1\n\n    return '\\n'.join(map(str, attacked_fields[1:])) + '\\n'"
    },
    {
        "number": 3166,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_fair(beat_matrix, disqualified):\n        n = len(beat_matrix)\n        for i in range(n):\n            if i in disqualified:\n                continue\n            for j in range(n):\n                if j in disqualified:\n                    continue\n                if beat_matrix[i][j] == 1 and beat_matrix[j][i] == 1:\n                    return False\n        return True\n\n    def find_smallest_disqualification(beat_matrix, disqualified):\n        n = len(beat_matrix)\n        min_size = n\n        for i in range(n):\n            if i in disqualified:\n                continue\n            for j in range(i + 1, n):\n                if j in disqualified:\n                    continue\n                new_disqualified = disqualified.copy()\n                new_disqualified.append(j)\n                if is_fair(beat_matrix, new_disqualified):\n                    min_size = min(min_size, len(new_disqualified))\n        return min_size\n\n    lines = stdin.split('\\n')\n    n, k = map(int, lines[0].split())\n    beat_matrix = [list(map(int, lines[i + 1].split())) for i in range(n)]\n    disqualified = list(map(int, lines[-1].split()))\n\n    if is_fair(beat_matrix, disqualified):\n        return \"impossible\"\n    else:\n        return find_smallest_disqualification(beat_matrix, disqualified)"
    },
    {
        "number": 3167,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def something(jump: int) -> None:\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += jump\n\n    N, K = map(int, stdin.readline().split())\n    X = list(map(int, stdin.readline().split()))\n    Q = int(stdin.readline())\n    L_R = [list(map(int, stdin.readline().split())) for _ in range(Q)]\n\n    seq = [0] * N\n    for jump in X:\n        something(jump)\n\n    return \"\\n\".join(str(sum(seq[L:R + 1])) for L, R in L_R)"
    },
    {
        "number": 3168,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def insert(node, value, depth):\n        if node is None:\n            return TreeNode(value), depth + 1\n        if value < node.val:\n            node.left, depth = insert(node.left, value, depth + 1)\n        else:\n            node.right, depth = insert(node.right, value, depth + 1)\n        return node, depth\n\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    N = int(stdin.readline())\n    root = None\n    counter = 0\n    for i in range(N):\n        value = int(stdin.readline())\n        root, counter = insert(root, value, counter)\n        print(counter)"
    },
    {
        "number": 3169,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance_to_axis(x1, y1, x2, y2):\n        if x1 == x2:\n            return abs(x1)\n        m = (y2 - y1) / (x2 - x1)\n        return abs(m * 10000 + y1) / (1 + m ** 2) ** 0.5\n\n    def is_valid(x1, y1, x2, y2, taken):\n        for i in range(len(taken)):\n            tx1, ty1, tx2, ty2 = taken[i]\n            if (x1 == tx1 and y1 == ty1) or (x1 == tx2 and y1 == ty2) or (x2 == tx1 and y2 == ty1) or (x2 == tx2 and y2 == ty2):\n                return False\n        return True\n\n    def dfs(start, taken, order):\n        if start == N:\n            return order\n        for i in range(N):\n            if i not in taken and is_valid(*sticks[i], taken):\n                taken.append(i)\n                res = dfs(start + 1, taken, order + [i])\n                if res:\n                    return res\n                taken.pop()\n\n    N, sticks = int(stdin.readline().strip()), [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n    sticks.sort(key=lambda x: distance_to_axis(*x))\n    return \" \".join(map(str, dfs(0, [], [])))"
    },
    {
        "number": 3170,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_card(deck: str) -> str:\n        return deck[0]\n\n    def can_fill_slot(card: str, slot: str) -> bool:\n        if slot == \"A\" and card in \"A2345\":\n            return True\n        if slot == \"2\" and card in \"23456789\":\n            return True\n        if slot == \"3\" and card in \"3456789T\":\n            return True\n        if slot == \"4\" and card in \"456789TJ\":\n            return True\n        if slot == \"5\" and card in \"56789TJQ\":\n            return True\n        if slot == \"6\" and card in \"6789TJQK\":\n            return True\n        if slot == \"7\" and card in \"789TJQKA\":\n            return True\n        if slot == \"8\" and card in \"89TJQKAJ\":\n            return True\n        if slot == \"9\" and card in \"9TJQKAJK\":\n            return True\n        if slot == \"T\" and card in \"TJQKAJK\":\n            return True\n        if slot == \"J\" and card in \"JQKAJK\":\n            return True\n        if slot == \"Q\" and card in \"QKAJK\":\n            return True\n        if slot == \"K\" and card in \"KAJK\":\n            return True\n        return False\n\n    def get_slot_number(card: str) -> int:\n        if card in \"A2345\":\n            return 1\n        if card in \"6789T\":\n            return 2\n        if card in \"JQKA\":\n            return 3\n        return 4\n\n    def get_optimal_slot(card: str, slots: list) -> int:\n        if card == \"J\":\n            for i in range(1, 11):\n                if i not in slots:\n                    return i\n        else:\n            for i in range(1, 11):\n                if i not in slots and can_fill_slot(card, str(i)):\n                    return i\n        return -1\n\n    def play_game(deck: str, theta: bool) -> bool:\n        discard_pile = []\n        theta_slots = [0] * 10\n        friend_slots = [0] * 10\n\n        for i in range(10):\n            theta_slots[i] = get_slot_number(deck[i])\n            friend_slots[i] = get_slot_number(deck[i + 10])\n\n        while deck:\n            if theta:\n                card = get_next_card(deck)\n                deck = deck[1:]\n                if card == \"J\":\n                    slot = get_optimal_slot(card, theta_slots)\n                    if slot == -1:\n                        return False\n                    theta_slots[slot - 1] = 1\n                else:\n                    for i in range(10):\n                        if can_fill_slot(card, str(i + 1)) and theta_slots[i] == 0:\n                            theta_slots[i] = 1\n                            break\n                    else:\n                        discard_pile.append(card)\n                        if len(discard_pile) == 10:\n                            return False\n            else:\n                card = get_next_card(deck)\n                deck = deck[1:]\n                if card == \"J\":\n                    slot = get_optimal_slot(card, friend_slots)\n                    if slot == -1:\n                        return True\n                    friend_slots[slot - 1] = 1\n                else:\n                    for i in range(10):\n                        if can_fill_slot(card, str(i + 1)) and friend_slots[i] == 0:\n                            friend_slots[i] = 1\n                            break\n                    else:\n                        discard_pile.append(card)\n                "
    },
    {
        "number": 3171,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_proposition(proposition: str) -> str:\n        if proposition.startswith(\"truther\") or proposition.startswith(\"fabulist\") or proposition.startswith(\"charlatan\"):\n            return proposition.split()[0]\n        elif proposition.startswith(\"not\"):\n            return \"not \" + parse_proposition(proposition[4:])\n        elif proposition.startswith(\"and\"):\n            return \"and \" + parse_proposition(proposition[4:].split()[0]) + \" \" + parse_proposition(proposition[4:].split()[1])\n        elif proposition.startswith(\"xor\"):\n            return \"xor \" + parse_proposition(proposition[4:].split()[0]) + \" \" + parse_proposition(proposition[4:].split()[1])\n\n    def evaluate_proposition(proposition: str, character_type: str) -> bool:\n        if proposition.startswith(\"truther\"):\n            return character_type == \"truther\"\n        elif proposition.startswith(\"fabulist\"):\n            return character_type == \"fabulist\"\n        elif proposition.startswith(\"charlatan\"):\n            return character_type == \"charlatan\"\n        elif proposition.startswith(\"not\"):\n            return not evaluate_proposition(proposition[4:], character_type)\n        elif proposition.startswith(\"and\"):\n            return evaluate_proposition(proposition[4:].split()[0], character_type) and evaluate_proposition(proposition[4:].split()[1], character_type)\n        elif proposition.startswith(\"xor\"):\n            return (evaluate_proposition(proposition[4:].split()[0], character_type) and not evaluate_proposition(proposition[4:].split()[1], character_type)) or (not evaluate_proposition(proposition[4:].split()[0], character_type) and evaluate_proposition(proposition[4:].split()[1], character_type))\n\n    def determine_character_type(transcript: list, N: int) -> str:\n        character_type = [\"truther\", \"fabulist\", \"charlatan\"]\n        for i in range(N):\n            if not any(evaluate_proposition(proposition, character_type[i]) for proposition in transcript):\n                return character_type[i]\n        return \"unknown\"\n\n    lines = stdin.split(\"\\n\")\n    N, K = map(int, lines[0].split())\n    transcript = [parse_proposition(line.split()[1]) for line in lines[1:]]\n    character_types = [determine_character_type(transcript, N) for _ in range(N)]\n    return \"\\n\".join(character_types)"
    },
    {
        "number": 3172,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_cross(p1, p2, q1, q2):\n        return (p1[0] < q1[0] < p2[0] or p1[0] > q1[0] > p2[0]) and (p1[1] < q1[1] < p2[1] or p1[1] > q1[1] > p2[1])\n\n    def is_point_in_line(p1, p2, q):\n        return abs((p2[1] - p1[1]) * q[0] - (p2[0] - p1[0]) * q[1] + p2[0] * p1[1] - p2[1] * p1[0]) < 1e-6\n\n    def is_point_in_circle(p, q):\n        return (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2 < 1\n\n    def is_point_in_fruit(p, q):\n        return is_point_in_circle(p, q) or is_point_in_line(p, q, (0, 0))\n\n    def count_slices(p1, p2):\n        return sum(is_point_in_fruit(p1, fruit) and is_point_in_fruit(p2, fruit) for fruit in fruits)\n\n    n = int(stdin.readline().strip())\n    fruits = [tuple(map(float, stdin.readline().strip().split())) for _ in range(n)]\n\n    max_slices = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_cross(fruits[i], fruits[j], (0, 0), (1, 0)):\n                max_slices = max(max_slices, count_slices(fruits[i], fruits[j]))\n\n    return str(max_slices)"
    },
    {
        "number": 3173,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.readline().split())\n    grid = []\n    for i in range(R):\n        grid.append(list(stdin.readline().strip()))\n    scores = list(map(int, stdin.readline().split()))\n\n    # Your code goes here\n\n    return str(final_score)"
    },
    {
        "number": 3174,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(city1, city2):\n        return ((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2) ** 0.5\n\n    def is_happy(county, k):\n        for i in range(len(county)):\n            for j in range(i + 1, len(county)):\n                if (county[i][2] + county[j][2]) % k == 0:\n                    return True\n        return False\n\n    def find_min_d(cities, k):\n        cities.sort(key=lambda x: x[2])\n        min_d = float('inf')\n\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                d = distance(cities[i], cities[j])\n                if d > min_d:\n                    break\n                counties = [[cities[i], cities[j]]]\n                for city in cities[j + 1:]:\n                    if not counties or distance(counties[-1][-1], city) > d:\n                        counties.append([city])\n                    else:\n                        for county in counties:\n                            if distance(county[-1], city) <= d:\n                                county.append(city)\n                                break\n                for county in counties:\n                    if is_happy(county, k):\n                        min_d = min(min_d, d)\n                        break\n        return round(min_d, 3)\n\n    lines = stdin.split('\\n')\n    n, k = map(int, lines[0].split())\n    cities = [list(map(int, line.split())) for line in lines[1:]]\n\n    return str(find_min_d(cities, k))"
    },
    {
        "number": 3175,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *segments = list(map(int, stdin.split()))\n    max_area = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            area = segments[i] * segments[j]\n            if area > max_area:\n                max_area = area\n\n    return f\"{max_area:.3f}\""
    },
    {
        "number": 3176,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x, y, energy, visited):\n        if (x, y) in visited:\n            return visited[(x, y)]\n        visited[(x, y)] = energy\n        for nx, ny in neighbors[(x, y)]:\n            if nx > x or (nx == x and ny > y):\n                new_energy = energy + flies[(nx, ny)]\n                if new_energy >= K:\n                    new_energy -= K\n                    new_energy += dfs(nx, ny, new_energy, visited)\n                visited[(x, y)] = max(visited[(x, y)], new_energy)\n        return visited[(x, y)]\n\n    N, K = map(int, stdin.readline().split())\n    flies = {}\n    neighbors = {}\n    for i in range(N):\n        x, y, F = map(int, stdin.readline().split())\n        flies[(x, y)] = F\n        neighbors[(x, y)] = []\n        for j in range(i + 1, N):\n            nx, ny, nF = map(int, stdin.readline().split())\n            if (nx, ny) not in neighbors[(x, y)]:\n                neighbors[(x, y)].append((nx, ny))\n            if (x, y) not in neighbors[(nx, ny)]:\n                neighbors[(nx, ny)].append((x, y))\n\n    energy = dfs(1, 1, 0, {})\n    result = [1]\n    x, y = 1, 1\n    while (x, y) != (N, N):\n        for nx, ny in neighbors[(x, y)]:\n            if nx > x or (nx == x and ny > y):\n                new_energy = energy + flies[(nx, ny)]\n                if new_energy >= K:\n                    new_energy -= K\n                    if new_energy == dfs(nx, ny, 0, {}):\n                        result.append(nx * 1000 + ny)\n                        energy = new_energy\n                        x, y = nx, ny\n                        break\n\n    return f\"{energy}\\n{len(result)}\\n{' '.join(map(str, result))}\""
    },
    {
        "number": 3177,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(node, visited, cycle_nodes):\n        visited[node] = True\n        cycle_nodes.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                find_cycle(neighbor, visited, cycle_nodes)\n                return\n        cycle_nodes.pop()\n\n    def min_swaps(n, graph):\n        visited = [False] * n\n        cycles = []\n        for i in range(n):\n            if not visited[i]:\n                cycle_nodes = []\n                find_cycle(i, visited, cycle_nodes)\n                if cycle_nodes:\n                    cycles.append(cycle_nodes)\n\n        swaps = 0\n        for cycle in cycles:\n            swaps += len(cycle) - 1\n\n        return swaps\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    permutation = list(map(int, lines[1].split()))\n    graph = [[] for _ in range(n)]\n\n    for i in range(m):\n        a, b = map(int, lines[i + 2].split())\n        a -= 1\n        b -= 1\n        graph[a].append(b)\n        graph[b].append(a)\n\n    return str(min_swaps(n, graph))"
    },
    {
        "number": 3178,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(costs):\n        for a, b in roads:\n            if (costs[a] + costs[b]) % 3 == 1:\n                return False\n        return True\n\n    def dfs(start, visited, cycle_cost):\n        if start in visited:\n            return False\n        visited.add(start)\n        cycle_cost += costs[start]\n        if start == target:\n            return cycle_cost % 2 == 1\n        for neighbor in graph[start]:\n            if dfs(neighbor, visited, cycle_cost):\n                return True\n        return False\n\n    n, m = map(int, stdin.readline().split())\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    graph = [[] for _ in range(n)]\n    for a, b in roads:\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    costs = [0, 1, 2]\n    min_cost = float('inf')\n\n    for costs in itertools.permutations(costs):\n        if not is_valid(costs):\n            continue\n        for target in range(n):\n            visited = set()\n            if dfs(0, visited, 0):\n                min_cost = min(min_cost, sum(costs))\n                break\n\n    return str(min_cost if min_cost != float('inf') else -1)"
    },
    {
        "number": 3179,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    polygon = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        polygon.append((x, y))\n\n    # Calculate the area of the polygon\n    area = 0\n    for i in range(n):\n        x1, y1 = polygon[i]\n        x2, y2 = polygon[(i + 1) % n]\n        area += (x1 * y2) - (x2 * y1)\n    area = abs(area) / 2\n\n    # Calculate the side length of the square map\n    side_length = (area / k) ** 0.5\n\n    return f\"{side_length:.2f}\""
    },
    {
        "number": 3180,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.readline().split())\n    canvas = [[1] * N for _ in range(N)]\n    saved_paintings = []\n\n    for _ in range(M):\n        command, *args = stdin.readline().split()\n        if command == \"PAINT\":\n            c, x1, y1, x2, y2 = map(int, args)\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    if (i + j) % 2 == 0:\n                        canvas[i][j] = c\n                    else:\n                        canvas[i][j] = 1\n        elif command == \"SAVE\":\n            saved_paintings.append(canvas)\n        elif command == \"LOAD\":\n            x, = map(int, args)\n            canvas = saved_paintings[x - 1]\n\n    return \"\\n\".join(\" \".join(map(str, row)) for row in canvas)"
    },
    {
        "number": 3181,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1:\n        return -1\n    if K == 2 and N % 2 == 1:\n        return -1\n    sequence = []\n    for i in range(1, N + 1):\n        if i not in sequence:\n            sequence.append(i)\n            if len(sequence) == K:\n                break\n    for i in range(len(sequence) - 1):\n        if sequence[i] > sequence[i + 1]:\n            sequence[i], sequence[i + 1] = sequence[i + 1], sequence[i]\n    return \" \".join(map(str, sequence))"
    },
    {
        "number": 3182,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_right_triangle(a, b, c):\n        sides = sorted([a, b, c])\n        return sides[0] ** 2 + sides[1] ** 2 == sides[2] ** 2\n\n    def count_right_triangles(points):\n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    if is_right_triangle(\n                        abs(points[i][0] - points[j][0]),\n                        abs(points[i][1] - points[j][1]),\n                        abs(points[j][0] - points[k][0]),\n                    ) or is_right_triangle(\n                        abs(points[i][0] - points[j][0]),\n                        abs(points[i][1] - points[j][1]),\n                        abs(points[i][0] - points[k][0]),\n                    ) or is_right_triangle(\n                        abs(points[i][0] - points[j][0]),\n                        abs(points[i][1] - points[j][1]),\n                        abs(points[k][0] - points[i][0]),\n                    ):\n                        count += 1\n        return count\n\n    N = int(stdin.readline().strip())\n    points = [tuple(map(int, stdin.readline().strip().split())) for _ in range(N)]\n    return str(count_right_triangles(points))"
    },
    {
        "number": 3183,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from heapq import heappush, heappop\n\n    def max_flow(graph, source, sink):\n        residual_graph = defaultdict(lambda: defaultdict(int))\n        for u in graph:\n            for v in graph[u]:\n                residual_graph[u][v] = graph[u][v]\n\n        flow = 0\n        cost = 0\n        while True:\n            parent = defaultdict(lambda: -1)\n            dist = defaultdict(lambda: float('inf'))\n            dist[source] = 0\n\n            queue = [source]\n            while queue:\n                u = queue.pop(0)\n                for v in residual_graph[u]:\n                    if dist[v] > dist[u] + 1 and residual_graph[u][v] > 0:\n                        dist[v] = dist[u] + 1\n                        parent[v] = u\n                        heappush(queue, v)\n\n            if parent[sink] == -1:\n                break\n\n            path_flow = float('inf')\n            v = sink\n            while v != source:\n                path_flow = min(path_flow, residual_graph[parent[v]][v])\n                v = parent[v]\n\n            flow += path_flow\n            cost += path_flow * dist[sink]\n\n            v = sink\n            while v != source:\n                residual_graph[parent[v]][v] -= path_flow\n                residual_graph[v][parent[v]] += path_flow\n                v = parent[v]\n\n        return flow, cost\n\n    lines = stdin.split('\\n')\n    n, m, source, sink = map(int, lines[0].split())\n    graph = defaultdict(lambda: defaultdict(int))\n\n    for i in range(1, m + 1):\n        u, v, capacity, cost = map(int, lines[i].split())\n        graph[u][v] = capacity\n\n    flow, cost = max_flow(graph, source, sink)\n    return f\"{flow} {cost}\""
    },
    {
        "number": 3184,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_covered(covered_walls, n, a, b):\n        if a > b:\n            a, b = b, a\n        for i in range(a, b + 1):\n            if not covered_walls[i - 1]:\n                return False\n        return True\n\n    def find_min_cameras(n, k, cameras):\n        covered_walls = [False] * n\n        for i in range(k):\n            a, b = cameras[i]\n            if a > b:\n                a, b = b, a\n            for j in range(a - 1, b):\n                covered_walls[j] = True\n\n        min_cameras = 0\n        for i in range(n):\n            if not covered_walls[i]:\n                found = False\n                for j in range(k):\n                    a, b = cameras[j]\n                    if is_covered(covered_walls, n, a, i) and is_covered(covered_walls, n, i + 1, b):\n                        found = True\n                        break\n                if not found:\n                    return \"impossible\"\n                covered_walls[i] = True\n                min_cameras += 1\n        return min_cameras\n\n    lines = stdin.split(\"\\n\")\n    n, k = map(int, lines[0].split())\n    cameras = [list(map(int, line.split())) for line in lines[1:]]\n\n    result = find_min_cameras(n, k, cameras)\n    return str(result)"
    },
    {
        "number": 3185,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = 0\n    factorial = int(stdin)\n    while factorial > 1:\n        n += 1\n        factorial //= n\n    return str(n)"
    },
    {
        "number": 3186,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    mod = 10**6 + 7\n\n    if k > n:\n        return \"0\"\n\n    # Calculate the factorials\n    factorials = [1] * (n + 1)\n    for i in range(1, n + 1):\n        factorials[i] = (factorials[i - 1] * i) % mod\n\n    # Calculate the inverse factorials\n    inv_factorials = [1] * (n + 1)\n    inv_factorials[-1] = pow(factorials[-1], mod - 2, mod)\n    for i in range(n, 0, -1):\n        inv_factorials[i - 1] = (inv_factorials[i] * i) % mod\n\n    # Calculate the number of ways\n    num_ways = (factorials[n] * inv_factorials[n - k]) % mod\n    num_ways = (num_ways * inv_factorials[k]) % mod\n\n    return str(num_ways)"
    },
    {
        "number": 3187,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, xy_coordinates, d = parse_input(stdin)\n    min_distance = float('inf')\n    for x in range(21):\n        for y in range(21):\n            total_distance = 0\n            for x1, y1 in xy_coordinates:\n                total_distance += abs(x - x1) + abs(y - y1)\n            if total_distance <= d and total_distance < min_distance:\n                min_distance = total_distance\n    return str(min_distance) if min_distance != float('inf') else \"impossible\"\n\ndef"
    },
    {
        "number": 3188,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_tunnel_cost(a, b):\n        return min(abs(a[0] - b[0]), abs(a[1] - b[1]), abs(a[2] - b[2]))\n\n    def mst(planets):\n        edges = []\n        for i in range(len(planets)):\n            for j in range(i + 1, len(planets)):\n                edges.append((i, j, min_tunnel_cost(planets[i], planets[j])))\n\n        edges.sort(key=lambda x: x[2])\n        parent = [i for i in range(len(planets))]\n        rank = [0] * len(planets)\n\n        def find(u):\n            if u == parent[u]:\n                return u\n            parent[u] = find(parent[u])\n            return parent[u]\n\n        def union(u, v):\n            u_root = find(u)\n            v_root = find(v)\n            if u_root == v_root:\n                return False\n            if rank[u_root] > rank[v_root]:\n                parent[v_root] = u_root\n            else:\n                parent[u_root] = v_root\n                if rank[u_root] == rank[v_root]:\n                    rank[v_root] += 1\n            return True\n\n        min_cost = 0\n        for u, v, w in edges:\n            if union(u, v):\n                min_cost += w\n\n        return min_cost\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    planets = [tuple(map(int, lines[i + 1].split())) for i in range(N)]\n\n    return str(mst(planets))"
    },
    {
        "number": 3189,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    photos = []\n    for _ in range(m):\n        switches, lights = stdin.readline().strip(), stdin.readline().strip()\n        photos.append((switches, lights))\n\n    def count_valid_wirings(photos, n):\n        valid_wirings = set()\n        for switches, lights in photos:\n            for i in range(n):\n                for j in range(n):\n                    if switches[i] == lights[j]:\n                        valid_wirings.add((i, j))\n        return len(valid_wirings)\n\n    return str(count_valid_wirings(photos, n) % 1000003)"
    },
    {
        "number": 3190,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, prices, P = map(int, stdin.split('\\n'))\n    prices = list(map(int, prices.split()))\n    count = 0\n    for i in range(N):\n        for j in range(i, N):\n            if sum(prices[i:j+1]) / (j - i + 1) >= P:\n                count += 1\n    return str(count)"
    },
    {
        "number": 3191,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    if n == 1:\n        return 0\n    else:\n        return min(r + p * (n // 2), r + p * (n // 2 + 1))"
    },
    {
        "number": 3192,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, visited, rec_stack, start):\n        visited[start] = True\n        rec_stack[start] = True\n\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, rec_stack, neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n\n        rec_stack[start] = False\n        return False\n\n    def find_shortest_cycle(graph, visited, rec_stack):\n        shortest_cycle = []\n        for i in range(len(graph)):\n            if not visited[i]:\n                rec_stack = [False] * len(graph)\n                if find_cycle(graph, visited, rec_stack, i):\n                    cycle = []\n                    for j in range(len(rec_stack)):\n                        if rec_stack[j]:\n                            cycle.append(j)\n                    if not shortest_cycle or len(cycle) < len(shortest_cycle):\n                        shortest_cycle = cycle\n        return shortest_cycle\n\n    def create_graph(files, imports):\n        graph = [[] for _ in range(len(files))]\n        for i, file_imports in enumerate(imports):\n            for j, import_name in enumerate(file_imports):\n                if import_name in files:\n                    graph[i].append(files.index(import_name))\n        return graph\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    files = lines[1].split()\n    imports = [line.split(', ')[1:] for line in lines[2:n+2]]\n\n    graph = create_graph(files, imports)\n    visited = [False] * len(graph)\n    rec_stack = [False] * len(graph)\n\n    shortest_cycle = find_shortest_cycle(graph, visited, rec_stack)\n\n    if shortest_cycle:\n        return ','.join([files[i] for i in shortest_cycle])\n    else:\n        return \"SHIP IT\""
    },
    {
        "number": 3193,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    expression, P, M = stdin.split()\n    P, M = int(P), int(M)\n\n    def evaluate(expression, x):\n        stack = []\n        i = 0\n        while i < len(expression):\n            if expression[i] == \"x\":\n                stack.append(x)\n            elif expression[i] in \"+-*\":\n                op = expression[i]\n                if op == \"+\":\n                    stack.append(stack.pop() + stack.pop())\n                elif op == \"-\":\n                    stack.append(stack.pop() - stack.pop())\n                elif op == \"*\":\n                    stack.append(stack.pop() * stack.pop())\n            else:\n                j = i\n                num = \"\"\n                while j < len(expression) and expression[j].isdigit():\n                    num += expression[j]\n                    j += 1\n                stack.append(int(num))\n                i = j - 1\n            i += 1\n        return stack[0]\n\n    def find_min_x(expression, P, M):\n        min_x = float(\"inf\")\n        for x in range(M):\n            if evaluate(expression, x) % M == P:\n                min_x = min(min_x, x)\n        return min_x\n\n    return str(find_min_x(expression, P, M))"
    },
    {
        "number": 3194,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_overlap(a1, b1, a2, b2):\n        return max(a1, a2) < min(b1, b2)\n\n    n, t = map(int, stdin.readline().split())\n    time_periods = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().split())\n        time_periods.append((a, b))\n\n    time_periods.sort()\n\n    for i in range(1, n):\n        if check_overlap(time_periods[i - 1][0], time_periods[i - 1][1], time_periods[i][0], time_periods[i][1]):\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3195,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r, n = map(int, stdin.readline().split())\n    observations = []\n    for _ in range(n):\n        t, c = stdin.readline().split()\n        t = int(t)\n        observations.append((t, c))\n    t_q, c_q = stdin.readline().split()\n    t_q = int(t_q)\n\n    # Calculate the possible values of T\n    possible_T = set()\n    for i in range(len(observations) - 1):\n        t1, c1 = observations[i]\n        t2, c2 = observations[i + 1]\n        if c1 == c2:\n            continue\n        if c1 == \"green\" and c2 == \"yellow\":\n            possible_T.add(t1 - T_g)\n        elif c1 == \"yellow\" and c2 == \"red\":\n            possible_T.add(t1 - T_g - T_y)\n        elif c1 == \"red\" and c2 == \"green\":\n            possible_T.add(t1 - T_g - T_y - T_r)\n\n    # Calculate the probability\n    p = 0\n    for T in possible_T:\n        if T <= t_q <= T + T_g:\n            p += 1 / len(possible_T)\n\n    return f\"{p:.6f}\""
    },
    {
        "number": 3196,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n\n    dp = [0] * (N + 1)\n    dp[1] = 1\n\n    for i in range(1, N + 1):\n        for j in range(len(graph[i])):\n            dp[graph[i][j]] += dp[i]\n\n    return str(dp[2])[-9:] if dp[2] != 0 else \"inf\""
    },
    {
        "number": 3197,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    preferences = list(map(int, stdin.split('\\n')[1].split()))\n\n    def dfs(start, count):\n        if count == k:\n            return True\n        if start > n:\n            return False\n        for i in range(start, n):\n            if preferences[i] == i + 1:\n                preferences[i] = i + 1\n                if dfs(i + 1, count + 1):\n                    return True\n                preferences[i] = i + 1\n        return False\n\n    for i in range(1, n + 1):\n        if preferences[i - 1] == i:\n            preferences[i - 1] = i\n            if dfs(i, 1):\n                return str(i)\n            preferences[i - 1] = i\n\n    return \"0\""
    },
    {
        "number": 3198,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    words = [stdin.readline().strip() for _ in range(n)]\n\n    typos = []\n    for i, word in enumerate(words):\n        for j in range(len(word)):\n            candidate = word[:j] + word[j + 1:]\n            if candidate in words and candidate != word:\n                typos.append(word)\n                break\n\n    if typos:\n        return \"\\n\".join(sorted(set(typos), key=words.index))\n    else:\n        return \"NO TYPOS\""
    },
    {
        "number": 3199,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure = 0\n    secure = 0\n    super_secure = 0\n\n    for x in range(1, L + 1):\n        for y in range(-A, B + 1):\n            if y < -A:\n                if x == 1:\n                    insecure += 1\n                else:\n                    secure += 1\n            elif y >= -A and y <= B:\n                if x == 1:\n                    insecure += 1\n                else:\n                    super_secure += 1\n            else:\n                if x == 1:\n                    insecure += 1\n                else:\n                    secure += 1\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3200,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def time_to_pass_light(t, g, r):\n        if t > r:\n            return g + (t - r)\n        else:\n            return t + g\n\n    def time_to_drive(n, t_lights):\n        time = 0\n        for i in range(n - 1):\n            time += time_to_pass_light(*t_lights[i])\n        return time\n\n    def optimal_speed(n, t_lights):\n        time = time_to_drive(n, t_lights)\n        optimal_speed = 1 / (time * 3.6)\n        return optimal_speed\n\n    def parse_input(stdin: str):\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        t_lights = []\n        for line in lines[1:]:\n            t, g, r = map(int, line.split())\n            t_lights.append((t, g, r))\n        return n, t_lights\n\n    n, t_lights = parse_input(stdin)\n    optimal_speed_kmh = optimal_speed(n, t_lights)\n    optimal_speed_mps = optimal_speed_kmh / 3.6\n    time_to_reach_work = n / optimal_speed_mps\n\n    return f\"{time_to_reach_work:.10f}\""
    },
    {
        "number": 3201,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    def hash_func(s: List[int]) -> int:\n        p = len(s)\n        h = 0\n        for i, v in enumerate(s):\n            h += v * B ** (p - i - 1)\n        return h % M\n\n    def generate_subsequences(a: List[int], index: int, current: List[int], result: List[List[int]]):\n        if index == len(a):\n            result.append(current.copy())\n            return\n        current.append(a[index])\n        generate_subsequences(a, index + 1, current, result)\n        current.pop()\n        generate_subsequences(a, index + 1, current, result)\n\n    subsequences = []\n    generate_subsequences(a, 0, [], subsequences)\n    subsequences.sort()\n\n    result = []\n    for s in subsequences[:K]:\n        result.append(hash_func(s))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3202,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    colors = list(map(int, stdin.split()[2:]))\n    max_consecutive_same_color = 0\n    current_color = colors[0]\n    current_consecutive_same_color = 1\n    for i in range(1, N):\n        if colors[i] == current_color:\n            current_consecutive_same_color += 1\n        else:\n            current_color = colors[i]\n            current_consecutive_same_color = 1\n        max_consecutive_same_color = max(max_consecutive_same_color, current_consecutive_same_color)\n    if max_consecutive_same_color >= K:\n        return \"0\"\n    else:\n        return str(K - max_consecutive_same_color)"
    },
    {
        "number": 3203,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    missions = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    max_probability = 0\n    for arrangement in permutations(range(N)):\n        probability = 1\n        for i, bond in enumerate(arrangement):\n            probability *= missions[bond][i] / 100\n        max_probability = max(max_probability, probability)\n\n    return str(round(max_probability * 100, 6))"
    },
    {
        "number": 3204,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bridge_operation(arrival_times):\n        total_time = 0\n        waiting_boats = []\n        for arrival_time in arrival_times:\n            if not waiting_boats:\n                total_time += max(0, 60 - (arrival_time % 60))\n                waiting_boats.append(arrival_time)\n            else:\n                if arrival_time - waiting_boats[0] < 60:\n                    waiting_boats.append(arrival_time)\n                else:\n                    total_time += 60\n                    waiting_boats = [arrival_time]\n        return total_time + 60 * len(waiting_boats)\n\n    N = int(stdin.readline().strip())\n    arrival_times = [int(stdin.readline().strip()) for _ in range(N)]\n    total_time = bridge_operation(arrival_times)\n    return str(total_time)"
    },
    {
        "number": 3205,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(M)]\n    for _ in range(N):\n        a, b, p = map(int, stdin.readline().split())\n        adj_list[a].append((b, p))\n        adj_list[b].append((a, p))\n\n    visited = [False] * M\n    balance = [0] * M\n\n    def dfs(node, amount):\n        visited[node] = True\n        for neighbor, cost in adj_list[node]:\n            if not visited[neighbor]:\n                balance[neighbor] += amount - cost\n                dfs(neighbor, amount - cost)\n\n    dfs(0, 0)\n    return str(sum(balance))"
    },
    {
        "number": 3206,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, target):\n        if target == 0:\n            return [[]]\n        if start >= len(blocks):\n            return []\n        result = []\n        for i in range(start, len(blocks)):\n            if blocks[i] <= target:\n                for sub_result in dfs(i, target - blocks[i]):\n                    result.append([i + 1] + sub_result))\n        return result\n\n    N, S = map(int, stdin.readline().split())\n    blocks = list(map(int, stdin.readline().split()))\n    targets = list(map(int, stdin.readline().split()))\n\n    for target in targets:\n        result = dfs(0, target)\n        if result:\n            for r in result:\n                print(len(r), *r)\n        else:\n            print(-1)\n\n    return 0"
    },
    {
        "number": 3207,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mod(a, b):\n        return a % b\n\n    def lcm(a, b):\n        return abs(a * b) // gcd(a, b)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, mod(a, b)\n        return a\n\n    def total_trip(chameleons, K, L):\n        trips = [0] * K\n        for i in range(len(chameleons)):\n            color, direction, distance = chameleons[i]\n            if direction == \"L\":\n                trips[color] += distance\n            else:\n                trips[color] += L - distance\n        return trips\n\n    N, K, L = map(int, stdin.readline().split())\n    chameleons = []\n    for _ in range(N):\n        distance, color, direction = stdin.readline().split()\n        chameleons.append((int(color), direction, int(distance)))\n\n    trips = total_trip(chameleons, K, L)\n    return \"\\n\".join(map(str, trips))"
    },
    {
        "number": 3208,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_text = stdin.strip()\n    encrypted_words = encrypted_text.split(' ')\n    known_words = [\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"]\n    known_words_set = set(known_words)\n\n    def is_decodable(encrypted_text: str, mapping: dict) -> bool:\n        decoded_text = ''.join([mapping.get(char, char) for char in encrypted_text])\n        decoded_words = decoded_text.split(' ')\n        decoded_words_set = set(decoded_words)\n        return known_words_set.issubset(decoded_words_set) and len(set(decoded_text)) == len(set(encrypted_text))\n\n    def decode_text(encrypted_text: str, mapping: dict) -> str:\n        return ''.join([mapping.get(char, char) for char in encrypted_text])\n\n    def find_mapping(encrypted_words: list, known_words: list) -> dict:\n        mapping = {}\n        for encrypted_word, known_word in zip(encrypted_words, known_words):\n            for encrypted_char, known_char in zip(encrypted_word, known_word):\n                if encrypted_char not in mapping:\n                    mapping[encrypted_char] = known_char\n                elif mapping[encrypted_char] != known_char:\n                    return None\n        return mapping\n\n    mapping = find_mapping(encrypted_words, known_words)\n\n    if mapping and is_decodable(encrypted_text, mapping):\n        return decode_text(encrypted_text, mapping)\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3209,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        queue = [(0, start, [])]\n        visited = set()\n        while queue:\n            (cost, node, path) = heapq.heappop(queue)\n            if node not in visited:\n                visited.add(node)\n                path = path + [node]\n                if node == end:\n                    return (cost, path)\n                for neighbor, weight in graph[node].items():\n                    heapq.heappush(queue, (cost + weight, neighbor, path))\n        return None\n\n    def expected_duration(departure_time, duration, delay_probability, max_delay):\n        expected_delay = delay_probability * max_delay\n        total_duration = duration + expected_delay\n        return departure_time + total_duration\n\n    def min_expected_duration(origin, destination, train_connections):\n        graph = defaultdict(dict)\n        for connection in train_connections:\n            origin_station, destination_station, departure_time, duration, delay_probability, max_delay = connection\n            departure_time_minutes = departure_time * 60\n            expected_departure = expected_duration(departure_time_minutes, duration, delay_probability, max_delay)\n            graph[origin_station][destination_station] = expected_departure\n            graph[destination_station][origin_station] = expected_departure\n\n        result = dijkstra(graph, origin, destination)\n        if result:\n            total_duration = result[0]\n            return total_duration / 60\n        else:\n            return \"IMPOSSIBLE\"\n\n    lines = stdin.split(\"\\n\")\n    origin, destination = lines[0].split()\n    n = int(lines[1])\n    train_connections = []\n    for i in range(n):\n        origin_station, destination_station, departure_time, duration, delay_probability, max_delay = lines[2 + i].split()\n        departure_time = int(departure_time)\n        duration = int(duration)\n        delay_probability = int(delay_probability)\n        max_delay = int(max_delay)\n        train_connections.append((origin_station, destination_station, departure_time, duration, delay_probability, max_delay))\n\n    return f\"{min_expected_duration(origin, destination, train_connections):.6f}\""
    },
    {
        "number": 3210,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 0 <= x < 2 * n and 0 <= y < 2 * n\n\n    def is_connected(x, y, dx, dy):\n        while is_valid(x, y) and grid[x][y] != '*':\n            x += dx\n            y += dy\n        return is_valid(x, y) and grid[x][y] == '*'\n\n    def is_unit_square(x, y):\n        return is_connected(x, y, 0, 1) and is_connected(x, y, 1, 0)\n\n    def count_unit_squares():\n        count = 0\n        for i in range(1, 2 * n, 2):\n            for j in range(1, 2 * n, 2):\n                if is_unit_square(i, j):\n                    count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    grid = [list(line) for line in lines[1:]]\n\n    if count_unit_squares() > 0:\n        return 0\n\n    moves = 0\n    for i in range(1, 2 * n, 2):\n        for j in range(1, 2 * n, 2):\n            if grid[i][j] == '.':\n                moves += 1\n\n    return moves"
    },
    {
        "number": 3211,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n    s = list(s)\n    swaps = 0\n\n    for i in range(n - 1):\n        if s[i] == '0' and s[i + 1] == '0':\n            continue\n        if s[i] == '0' and s[i + 1] != '0':\n            s[i], s[i + 1] = s[i + 1], s[i]\n            swaps += 1\n\n    if s.count('1') > s.count('2'):\n        return swaps\n    elif s.count('2') > s.count('1'):\n        return swaps\n    else:\n        return \"impossible\""
    },
    {
        "number": 3212,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(x1, y1, x2, y2, snakes):\n        for snake in snakes:\n            snake_x, snake_y, snake_d = snake\n            if (snake_x - x1) ** 2 + (snake_y - y1) ** 2 < snake_d ** 2:\n                return False\n            if (snake_x - x2) ** 2 + (snake_y - y2) ** 2 < snake_d ** 2:\n                return False\n        return True\n\n    def find_path(snakes):\n        for y1 in range(1000, -1, -1):\n            for x1 in range(0, 1001):\n                for y2 in range(1000, -1, -1):\n                    for x2 in range(0, 1001):\n                        if is_safe(x1, y1, x2, y2, snakes):\n                            return (x1, y1, x2, y2)\n        return None\n\n    n = int(stdin.readline().strip())\n    snakes = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    path = find_path(snakes)\n    if path:\n        x1, y1, x2, y2 = path\n        return f\"Bill enters at ({x1:.2f}, {y1:.2f}) and leaves at ({x2:.2f}, {y2:.2f}).\"\n    else:\n        return \"Bill will be bitten.\""
    },
    {
        "number": 3213,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.readline().split())\n    spell = stdin.readline().strip()\n\n    def power(p):\n        return p % (2 ** S)\n\n    def no_ops(spell, start, end):\n        if end - start <= 1:\n            return 0\n\n        mid = (start + end) // 2\n        left_power = sum(1 if c == '+' else 2 for c in spell[start:mid])\n        right_power = sum(1 if c == '+' else 2 for c in spell[mid:end])\n\n        if power(left_power) + power(right_power) > power(left_power + right_power):\n            left_no_ops = no_ops(spell, start, mid)\n            right_no_ops = no_ops(spell, mid, end)\n            return left_no_ops + right_no_ops\n        else:\n            return no_ops(spell, start, end - 1)\n\n    no_ops_count = no_ops(spell, 0, M)\n    result = list(spell)\n    for i in range(no_ops_count):\n        result[i] = 'o'\n\n    return ''.join(result)"
    },
    {
        "number": 3214,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_similar(word1: str, word2: str) -> bool:\n        if abs(len(word1) - len(word2)) > 1:\n            return False\n\n        if len(word1) == len(word2):\n            diff_count = 0\n            for i in range(len(word1)):\n                if word1[i] != word2[i]:\n                    diff_count += 1\n                    if diff_count > 1:\n                        return False\n            return True\n\n        if len(word1) < len(word2):\n            word1, word2 = word2, word1\n\n        if word1[:len(word2)] == word2:\n            return True\n\n        if word1[1:] == word2:\n            return True\n\n        for i in range(len(word2)):\n            if word1[i + 1:] == word2[:i] + word2[i + 1:]:\n                return True\n\n        return False\n\n    def get_core(word: str) -> str:\n        core = \"\"\n        for char in word:\n            if char.isalpha():\n                core += char.lower()\n        return core\n\n    def process_paragraph(paragraph: str) -> dict:\n        words = paragraph.split()\n        cores = {}\n        for word in words:\n            core = get_core(word)\n            if core not in cores:\n                cores[core] = []\n            cores[core].append(word)\n        return cores\n\n    def find_similar_words(cores: dict) -> dict:\n        similar_words = {}\n        for core1 in cores:\n            for core2 in cores:\n                if core1 != core2 and is_similar(core1, core2):\n                    if core1 not in similar_words:\n                        similar_words[core1] = set()\n                    similar_words[core1].add(core2)\n        return similar_words\n\n    def print_similar_words(similar_words: dict) -> str:\n        output = []\n        for core in sorted(similar_words):\n            output.append(f\"{core}: {' '.join(sorted(similar_words[core]))}\")\n        if not output:\n            output.append(\"***\")\n        return \"\\n\".join(output)\n\n    paragraphs = stdin.split(\"\\n\")\n    paragraphs = paragraphs[:paragraphs.index(\"***\")]\n\n    cores_list = [process_paragraph(paragraph) for paragraph in paragraphs]\n    similar_words_list = [find_similar_words(cores) for cores in cores_list]\n\n    return print_similar_words(similar_words_list) "
    },
    {
        "number": 3215,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_sorted(cards: list) -> bool:\n        for i in range(len(cards) - 1):\n            if cards[i] > cards[i + 1]:\n                return False\n        return True\n\n    def count_shuffles(cards: list) -> int:\n        shuffles = 0\n        while not is_sorted(cards):\n            shuffles += 1\n            cards = [cards[i] for i in range(n) if i % 2 == 0] + [cards[i] for i in range(n) if i % 2 == 1]\n        return shuffles\n\n    return str(count_shuffles(cards))"
    },
    {
        "number": 3216,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str, repeat_count = stdin.split()\n    repeat_count = int(repeat_count)\n    decimal_str = input_str.split('.')[1]\n    repeating_part = decimal_str[-repeat_count:]\n    non_repeating_part = decimal_str[:-repeat_count]\n    repeating_fraction = f\"0.{repeating_part}\"\n    non_repeating_fraction = f\"0.{non_repeating_part}\"\n    repeating_decimal = float(repeating_fraction)\n    non_repeating_decimal = float(non_repeating_fraction)\n    repeating_numerator = int(repeating_decimal * (10 ** repeat_count))\n    non_repeating_numerator = int(non_repeating_decimal * (10 ** repeat_count))\n    denominator = (10 ** repeat_count) - 1\n    numerator = repeating_numerator * (non_repeating_numerator // denominator)\n    denominator *= (non_repeating_numerator // denominator)\n    gcd = math.gcd(numerator, denominator)\n    numerator //= gcd\n    denominator //= gcd\n    return f\"{numerator}/{denominator}\""
    },
    {
        "number": 3217,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    defective_cells = []\n    for i in range(n):\n        x, y, z = map(int, stdin.readline().split())\n        defective_cells.append((x, y, z))\n\n    # Calculate the number of panels required to contain the defective cells\n    panels_required = 0\n    for x, y, z in defective_cells:\n        for dx, dy, dz in [(0, 0, 1), (0, 1, 0), (1, 0, 0), (0, 0, -1), (0, -1, 0), (-1, 0, 0)]:\n            neighbor_coord = (x + dx, y + dy, z + dz)\n            if neighbor_coord not in defective_cells:\n                panels_required += 1\n\n    return str(panels_required)"
    },
    {
        "number": 3218,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_coloring(a, n):\n        def dfs(i, j, visited, color):\n            if not (0 <= i < n and 0 <= j < n - i % 2):\n                return False\n            if a[i][j] == -1 or a[i][j] == color:\n                if (i, j) not in visited:\n                    visited.add((i, j))\n                    if dfs(i + 1, j, visited, (color + 1) % 7) or dfs(i - 1, j, visited, (color + 1) % 7) or dfs(i, j + 1, visited, (color + 1) % 7) or dfs(i, j - 1, visited, (color + 1) % 7):\n                        return True\n                    visited.remove((i, j))\n                return True\n            return False\n\n        for i in range(n):\n            for j in range(n - i % 2):\n                if a[i][j] != -1 and not dfs(i, j, set(), a[i][j]):\n                    return False\n        return True\n\n    def count_valid_colorings(a, n):\n        if n == 1:\n            return 7\n        if n == 3:\n            return 1\n        if n == 5:\n            return 35\n        if n == 7:\n            return 89\n\n    n = int(stdin.readline().strip())\n    a = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    if is_valid_coloring(a, n):\n        return str(count_valid_colorings(a, n))\n    else:\n        return \"0\""
    },
    {
        "number": 3219,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    mod = 1000000009\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(len(stdin)):\n        for j in range(n, -1, -1):\n            if j - int(stdin[i]) >= 0:\n                dp[j] += dp[j - int(stdin[i])]\n                dp[j] %= mod\n    return str(dp[-1])"
    },
    {
        "number": 3220,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, p = map(int, stdin.split())\n    dances = []\n    for i in range(N):\n        dance = ['L'] * N\n        for j in range(i):\n            dance[(j + p[j]) % N] = 'R'\n        dances.append(''.join(dance))\n    dances.sort()\n    return dances[0] if dances[0] != 'L' * N else 'no dance'"
    },
    {
        "number": 3221,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = map(int, stdin.readline().split())\n    roads = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    def dfs(start, visited, energy):\n        if visited[start]:\n            return float('inf')\n        visited[start] = True\n        min_energy = energy\n        for u, v, c in roads:\n            if (u, v) == (start, u):\n                min_energy = min(min_energy, dfs((v, c), visited, energy + c ** 2 + alpha))\n            elif (u, v) == (start, v):\n                min_energy = min(min_energy, dfs((u, c), visited, energy + c ** 2 + alpha))\n        visited[start] = False\n        return min_energy\n\n    result = dfs(0, [False] * N, 0)\n    return str(result) if result != float('inf') else \"Poor girl\""
    },
    {
        "number": 3222,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v, visited, graph):\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                dfs(u, visited, graph)\n\n    def is_connected(graph):\n        visited = [False] * len(graph)\n        dfs(0, visited, graph)\n        return all(visited)\n\n    def find_trips(graph):\n        trips = []\n        visited = [False] * len(graph)\n        for v in range(len(graph)):\n            if not visited[v]:\n                trip = [v]\n                dfs(v, visited, graph)\n                for u in range(len(graph)):\n                    if visited[u] and u != v:\n                        trip.append(u)\n                trips.append(trip)\n        return trips\n\n    def is_valid(trips, graph):\n        for trip in trips:\n            for i in range(len(trip) - 1):\n                if trip[i] not in graph[trip[i + 1]]:\n                    return False\n        return True\n\n    lines = stdin.strip().split('\\n')\n    N, M = map(int, lines[0].split())\n    graph = [[] for _ in range(N)]\n    for i in range(M):\n        f, t = map(int, lines[i + 1].split())\n        graph[f].append(t)\n        graph[t].append(f)\n\n    if not is_connected(graph):\n        return \"Yeah!\"\n\n    trips = find_trips(graph)\n    if not is_valid(trips, graph):\n        return \"Yeah!\"\n\n    output = [str(len(trips))]\n    for trip in trips:\n        output.append(str(len(trip)))\n        output.extend(map(str, trip))\n    return '\\n'.join(output)"
    },
    {
        "number": 3223,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def construct_forest(V, degrees):\n        forest = []\n        for i in range(V):\n            if degrees[i] == 0:\n                continue\n            elif degrees[i] > i + 1:\n                return False\n            else:\n                for j in range(i + 1, i + 1 + degrees[i]):\n                    forest.append((i + 1, j))\n                degrees[i] = 0\n        return forest\n\n    input_data = list(map(int, stdin.split()))\n    V = input_data[0]\n    degrees = input_data[1:]\n\n    forest = construct_forest(V, degrees)\n\n    if not forest:\n        return \"IMPOSSIBLE\"\n    else:\n        output = [\"POSSIBLE\"]\n        for edge in forest:\n            output.append(\"{} {}\".format(edge[0], edge[1]))\n        return \"\\n\".join(output)"
    },
    {
        "number": 3224,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(4):\n        x, y, z = map(int, stdin.split())\n        points.append((x, y, z))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def center(p1, p2, p3):\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        x3, y3, z3 = p3\n        A = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)\n        B = (x1 ** 2 + y1 ** 2 + z1 ** 2) * (y2 - y3) + \\\n            (x2 ** 2 + y2 ** 2 + z2 ** 2) * (y3 - y1) + \\\n            (x3 ** 2 + y3 ** 2 + z3 ** 2) * (y1 - y2)\n        C = (x1 * x1 + y1 * y1 + z1 * z1) * (x2 * y3 - x3 * y2) + \\\n            (x2 * x2 + y2 * y2 + z2 * z2) * (x3 * y1 - x1 * y3) + \\\n            (x3 * x3 + y3 * y3 + z3 * z3) * (x1 * y2 - x2 * y1)\n        if A == 0:\n            return None\n        x = B / (2 * A)\n        y = (B ** 2 - 4 * A * C) ** 0.5 / (2 * A)\n        return (x, y)\n\n    def sphere_center(p1, p2, p3, p4):\n        c1 = center(p1, p2, p3)\n        c2 = center(p1, p3, p4)\n        c3 = center(p1, p2, p4)\n        c4 = center(p2, p3, p4)\n        if c1 is None or c2 is None or c3 is None or c4 is None:\n            return None\n        d1 = distance(c1, p1)\n        d2 = distance(c2, p1)\n        d3 = distance(c3, p1)\n        d4 = distance(c4, p1)\n        if abs(d1 - d2) < 1e-4 and abs(d1 - d3) < 1e-4 and abs(d1 - d4) < 1e-4:\n            return c1\n        return None\n\n    result = sphere_center(points[0], points[1], points[2], points[3])\n    if result is None:\n        return \"No sphere\"\n    return \"{:.6f} {:.6f} {:.6f}\".format(*result)"
    },
    {
        "number": 3225,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_better_candidates(candidates: list[int]) -> list[int]:\n        better_candidates = []\n        for i in range(len(candidates)):\n            if i > 0 and candidates[i - 1] > candidates[i]:\n                better_candidates.append(i)\n            if i < len(candidates) - 1 and candidates[i + 1] > candidates[i]:\n                better_candidates.append(i)\n        return better_candidates\n\n    def remove_better_candidates(candidates: list[int], better_candidates: list[int]) -> list[int]:\n        return [c for i, c in enumerate(candidates) if i not in better_candidates]\n\n    def print_output(minutes: int, removed_candidates: list[list[int]], final_candidates: list[int]) -> str:\n        output = [str(minutes)]\n        for candidates in removed_candidates:\n            output.append(\" \".join(str(c) for c in candidates))\n        output.append(\" \".join(str(c) for c in final_candidates))\n        return \"\\n\".join(output)\n\n    N, candidates = map(int, stdin.split())\n    candidates = list(map(int, stdin.split()))\n\n    minutes = 0\n    removed_candidates = []\n    while True:\n        better_candidates = find_better_candidates(candidates)\n        if not better_candidates:\n            break\n        removed_candidates.append([candidates[i] for i in better_candidates])\n        candidates = remove_better_candidates(candidates, better_candidates)\n        minutes += 1\n\n    return print_output(minutes, removed_candidates, candidates)"
    },
    {
        "number": 3226,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = [False] * len(graph)\n        distances = [float('inf')] * len(graph)\n        distances[start] = 0\n        pq = [(0, start)]\n\n        while pq:\n            dist, node = heapq.heappop(pq)\n            if node == end:\n                return dist\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, weight in graph[node].items():\n                    new_distance = dist + weight\n                    if new_distance < distances[neighbor]:\n                        distances[neighbor] = new_distance\n                        heapq.heappush(pq, (new_distance, neighbor))\n\n        return float('inf')\n\n    def escape_speed(n, m, e, roads, exits, b_start, p_start):\n        graph = [{} for _ in range(n + 1)]\n        for a, b, l in roads:\n            graph[a][b] = l\n            graph[b][a] = l\n\n        escape_distances = [dijkstra(graph, b_start, exit) for exit in exits]\n        police_distances = [dijkstra(graph, p_start, exit) for exit in exits]\n\n        min_escape_distance = min(escape_distances)\n        min_police_distance = min(police_distances)\n\n        if min_escape_distance <= min_police_distance:\n            return \"IMPOSSIBLE\"\n        else:\n            return round((min_escape_distance - min_police_distance) / 100 * 3.6, 12)\n\n    stdin_list = stdin.split('\\n')\n    n, m, e = map(int, stdin_list[0].split())\n    roads = [list(map(int, line.split())) for line in stdin_list[1:1 + m]]\n    exits = [int(x) for x in stdin_list[1 + m].split()]\n    b_start, p_start = map(int, stdin_list[-1].split())\n\n    return escape_speed(n, m, e, roads, exits, b_start, p_start)"
    },
    {
        "number": 3227,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, start, visited, rec_stack):\n        visited[start] = True\n        rec_stack[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if find_cycle(graph, neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n        rec_stack[start] = False\n        return False\n\n    def is_connected(graph, vertices):\n        visited = [False] * vertices\n        if find_cycle(graph, 0, visited, [False] * vertices):\n            return True\n        for i in range(1, vertices):\n            if not visited[i] and find_cycle(graph, i, visited, [False] * vertices):\n                return True\n        return False\n\n    def assign_roads(graph, vertices, roads):\n        chain1 = [0] * vertices\n        chain2 = [0] * vertices\n        for i in range(roads):\n            if chain1[graph[i][0] - 1] == 0 and chain2[graph[i][0] - 1] == 0:\n                chain1[graph[i][0] - 1] = 1\n            if chain1[graph[i][1] - 1] == 0 and chain2[graph[i][1] - 1] == 0:\n                chain1[graph[i][1] - 1] = 1\n        for i in range(vertices):\n            if chain1[i] == 0:\n                chain2[i] = 1\n        return chain1, chain2\n\n    def check_requirements(graph, vertices, roads, chain1, chain2):\n        for i in range(roads):\n            if chain1[graph[i][0] - 1] == 1 and chain1[graph[i][1] - 1] == 1:\n                return False\n            if chain2[graph[i][0] - 1] == 1 and chain2[graph[i][1] - 1] == 1:\n                return False\n        return True\n\n    lines = stdin.split('\\n')\n    N, E = map(int, lines[0].split())\n    graph = [[] for _ in range(N)]\n    for i in range(1, E + 1):\n        a, b = map(int, lines[i].split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    if not is_connected(graph, N):\n        return '0\\n'\n\n    chain1, chain2 = assign_roads(graph, N, E)\n\n    if not check_requirements(graph, N, E, chain1, chain2):\n        return '0\\n'\n\n    result = []\n    for i in range(1, E + 1):\n        a, b = map(int, lines[i].split())\n        if chain1[a - 1] == 1 and chain1[b - 1] == 1:\n            result.append('1')\n        elif chain2[a - 1] == 1 and chain2[b - 1] == 1:\n            result.append('2')\n\n    return '\\n'.join(result) + '\\n' "
    },
    {
        "number": 3228,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_waiting_time(arrivals, gondolas):\n        arrivals.sort()\n        waiting_time = 0\n        current_time = 0\n        gondola_idx = 0\n\n        for arrival in arrivals:\n            while gondola_idx < len(gondolas) and gondolas[gondola_idx] <= arrival:\n                current_time = gondolas[gondola_idx]\n                gondola_idx += 1\n\n            waiting_time += current_time - arrival\n\n        return waiting_time\n\n    N, T, G = map(int, stdin.readline().split())\n    arrivals = [int(stdin.readline().strip()) for _ in range(N)]\n\n    gondolas = [i * T for i in range(G)]\n    waiting_time = find_waiting_time(arrivals, gondolas)\n\n    return str(waiting_time)"
    },
    {
        "number": 3229,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_points(rank: int) -> int:\n        if rank == 1:\n            return 100\n        elif rank <= 10:\n            return 24\n        elif rank <= 20:\n            return 22\n        elif rank <= 30:\n            return 20\n        else:\n            return 0\n\n    def get_rank(scores: List[int]) -> int:\n        score_count = defaultdict(int)\n        for score in scores:\n            score_count[score] += 1\n\n        sorted_scores = sorted(score_count.keys(), reverse=True)\n        rank = 1\n        for score in sorted_scores:\n            count = score_count[score]\n            points = get_points(rank)\n            if points == 0:\n                break\n            rank += count * points\n\n        return rank\n\n    n, m = map(int, stdin.readline().split())\n    scores = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    my_scores = scores[0]\n    my_rank = get_rank(my_scores)\n    worst_rank = my_rank\n\n    for i in range(1, m):\n        new_scores = my_scores + [scores[i][n - 1]]\n        new_rank = get_rank(new_scores)\n        if new_rank < worst_rank:\n            worst_rank = new_rank\n\n    return str(worst_rank)"
    },
    {
        "number": 3230,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    tram = [list(stdin.readline().strip()) for _ in range(R)]\n    explosions = 0\n\n    def bfs(start):\n        visited = [[False for _ in range(C)] for _ in range(R)]\n        queue = [start]\n        visited[start[0]][start[1]] = True\n\n        while queue:\n            row, col = queue.pop(0)\n            if tram[row][col] == 'L':\n                return (row, col)\n\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_row, new_col = row + dr, col + dc\n                if 0 <= new_row < R and 0 <= new_col < C and not visited[new_row][new_col]:\n                    visited[new_row][new_col] = True\n                    queue.append((new_row, new_col))\n\n        return None\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_closer(p1, p2, x):\n        return distance(p1, x) <= distance(p2, x)\n\n    for row in range(R):\n        for col in range(C):\n            if tram[row][col] == 'X':\n                closest_seat = bfs((row, col))\n                if closest_seat:\n                    for r in range(R):\n                        for c in range(C):\n                            if tram[r][c] == 'X' and not is_closer(closest_seat, (row, col), (r, c)):\n                                closest_seat = None\n                                break\n                        if closest_seat is None:\n                            break\n\n                    if closest_seat:\n                        tram[row][col] = 'L'\n                        tram[closest_seat[0]][closest_seat[1]] = '.'\n                    else:\n                        explosions += 1\n\n    return str(explosions)"
    },
    {
        "number": 3231,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_partition(groups):\n        for group in groups:\n            if len(group) < 1 or len(group) > p:\n                return False\n        for group in groups:\n            friend_pairs = 0\n            for student in group:\n                for friend in friends[student]:\n                    if friend not in group:\n                        friend_pairs += 1\n            if friend_pairs > q:\n                return False\n        return True\n\n    def find_partition(groups, student):\n        for group in groups:\n            if student in group:\n                return group\n        return None\n\n    def add_to_group(groups, student, group):\n        if group is not None:\n            group.append(student)\n        else:\n            groups.append([student])\n\n    def backtrack(groups, student):\n        if student == n:\n            if is_valid_partition(groups):\n                return True\n            return False\n\n        group = find_partition(groups, student)\n        if group is not None:\n            return backtrack(groups, student + 1)\n\n        for i in range(len(groups) + 1):\n            if i == len(groups):\n                groups.append([])\n            add_to_group(groups, student, groups[i])\n            if backtrack(groups, student + 1):\n                return True\n            groups[i].pop()\n            if not groups[i]:\n                groups.pop(i)\n\n        return False\n\n    n, p, q = map(int, stdin.readline().split())\n    friends = [[] for _ in range(n)]\n    for i in range(n):\n        m, *friends_list = map(int, stdin.readline().split())\n        friends[i] = friends_list\n\n    if backtrack([], 0):\n        return \"detention\"\n    else:\n        return \"home\\n\" + \"\\n\".join(str(len(group)) + \" \" + \" \".join(map(str, group)) for group in groups)"
    },
    {
        "number": 3232,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n % 2 != 0:\n        return \"-1\"\n\n    substrings = set()\n    for i in range(n // 2 + 1):\n        for j in range(i, n - n // 2 + 1):\n            substrings.add(stdin[i:i + n // 2])\n            substrings.add(stdin[j:j + n // 2])\n\n    if len(substrings) == n // 2 + 1:\n        return stdin\n    else:\n        return \"-1\""
    },
    {
        "number": 3233,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = sorted(list(map(int, stdin.split('\\n')[1].split())))\n    scary_subarrays = 0\n\n    for i in range(n):\n        if arr[i] == arr[(n + i) // 2]:\n            scary_subarrays += 1\n\n    return str(scary_subarrays)"
    },
    {
        "number": 3234,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    W = 1\n    H = 1\n\n    while True:\n        if (H / 2) <= W <= (2 * H):\n            break\n        W += 1\n        if W > (2 * H):\n            W = 1\n            H += 1\n\n    empty_squares = (W * H) - N\n    return str(empty_squares)"
    },
    {
        "number": 3235,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, visited, start, current, depth):\n        visited[current] = True\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                if find_cycle(graph, visited, start, neighbor, depth + 1):\n                    return True\n            elif neighbor != start and depth > 0:\n                return True\n        return False\n\n    def cancel_cycle(graph, cycle):\n        min_debt = min(graph[friend][0] for friend in cycle)\n        for friend in cycle:\n            graph[friend][0] -= min_debt\n\n    def get_output(graph):\n        output = []\n        for i in range(len(graph)):\n            for j in range(len(graph[i])):\n                if graph[i][j][1] > 0:\n                    output.append((i, graph[i][j][0], graph[i][j][1]))\n        return output\n\n    n, m = map(int, stdin.readline().split())\n    graph = [[[0, 0] for _ in range(n)] for _ in range(n)]\n\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        graph[a][b][0] += c\n        graph[a][b][1] = a\n\n    cycles = []\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            for j in range(n):\n                if not visited[j]:\n                    if find_cycle(graph, visited, i, j, 0):\n                        cycles.append([i, j])\n\n    for cycle in cycles:\n        cancel_cycle(graph, cycle)\n\n    output = get_output(graph)\n    return f\"{len(output)}\\n\" + \"\\n\".join(\" \".join(map(str, ioU)) for ioU in output)"
    },
    {
        "number": 3236,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_fibonacci(nums):\n        fib = [1, 1]\n        for i in range(2, len(nums)):\n            fib.append(fib[-1] + fib[-2])\n            if nums[i] != fib[-1]:\n                return False\n        return True\n\n    def dfs(start, visited, heights, edges):\n        if not edges or not heights:\n            return 0\n\n        max_length = 0\n        for i in range(len(heights)):\n            if i not in visited and (not visited or i > visited[-1]) and (start, i) in edges:\n                visited.append(i)\n                max_length = max(max_length, dfs(i, visited, heights, edges))\n                visited.pop()\n\n        return max_length + 1 if max_length + 1 == len(heights) and is_fibonacci(heights) else max_length\n\n    n, m = map(int, stdin.readline().strip().split())\n    heights = list(map(int, stdin.readline().strip().split()))\n    edges = set()\n    for _ in range(m):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.add((a, b))\n        edges.add((b, a))\n\n    return str(dfs(1, [], heights, edges))"
    },
    {
        "number": 3237,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    prime_factors = [int(stdin[i:i+2]) for i in range(0, len(stdin), 2)]\n    K = 1\n    for factor in prime_factors:\n        K *= factor\n\n    M = 1\n    for factor in prime_factors:\n        M *= factor\n\n    cost = M + len(prime_factors) - 1\n    return str(cost % (10**9 + 7))"
    },
    {
        "number": 3238,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_fold(matrix):\n        n, m = len(matrix), len(matrix[0])\n        for r1 in range(n):\n            for c1 in range(m):\n                if matrix[r1][c1] == '.':\n                    for r2 in range(r1 + 1, n):\n                        if matrix[r2][c1] == '#':\n                            return r1, c1, r2, c1\n                    for c2 in range(c1 + 1, m):\n                        if matrix[r1][c2] == '#':\n                            return r1, c1, r1, c2\n                    for dr in range(1, min(r1 + 1, m - c1)):\n                        if matrix[r1 + dr][c1 + dr] == '#':\n                            return r1, c1, r1 + dr, c1 + dr\n                        elif matrix[r1 - dr][c1 - dr] == '#':\n                            return r1 - dr, c1 - dr, r1, c1\n                    for dc in range(1, min(c1 + 1, n - r1)):\n                        if matrix[r1 + dc][c1 - dc] == '#':\n                            return r1, c1 - dc, r1 + dc, c1\n                        elif matrix[r1 - dc][c1 + dc] == '#':\n                            return r1 - dc, c1, r1, c1 + dc\n        return None\n\n    n, m = map(int, stdin.readline().split())\n    matrix = [list(stdin.readline().strip()) for _ in range(n)]\n\n    fold = find_fold(matrix)\n    if fold:\n        return ' '.join(map(str, fold))\n    else:\n        return 'No fold found'"
    },
    {
        "number": 3239,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, stdin.split())\n    N = int(N)\n    P = P / 100\n\n    def expected_cost(n, p):\n        if n == 0:\n            return 0\n        else:\n            return (1 - p) * (expected_cost(n - 1, p) + 5) + p * (expected_cost(n - 1, p))\n\n    def expected_cost_simplified(n, p):\n        return (1 - p) * n + p * (n - 1) + 5 * (1 - p) * (n - 1) * p\n\n    # result = expected_cost(N, P)\n    result = expected_cost_simplified(N, P)\n    return f\"{result:.10f}\""
    },
    {
        "number": 3240,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.readline().split())\n    probabilities = []\n    ballots = []\n    for _ in range(v - 1):\n        p, b = map(float, stdin.readline().split())\n        probabilities.append(p)\n        ballots.append(b)\n\n    expected_positions = []\n    for i in range(2 ** k):\n        total_ballots = sum([b * (1 - p) + i * p for b, p in zip(ballots, probabilities)])\n        positions = sum([(total_ballots >> j) & 1 for j in range(k)])\n        expected_positions.append(positions)\n\n    return str(expected_positions.index(max(expected_positions)))"
    },
    {
        "number": 3241,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(ham_amount, A, B):\n        total_kilos = sum(A) + ham_amount\n        current_sum = 0\n        for i in range(N):\n            current_sum += A[i]\n            if current_sum > total_kilos * (sum(B[:i + 1]) / sum(B)):\n                return False\n        return True\n\n    N = int(stdin.readline().strip())\n    A = []\n    B = []\n    for _ in range(N):\n        a, b = map(int, stdin.readline().strip().split())\n        A.append(a)\n        B.append(b)\n\n    left, right = 0, 10**7\n    while right - left > 10**-12:\n        mid = (left + right) / 2\n        if is_valid(mid, A, B):\n            right = mid\n        else:\n            left = mid\n\n    if abs(left - sum(A)) < 10**-12:\n        return str(left)\n    else:\n        return \"-1\""
    },
    {
        "number": 3242,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, P = map(float, lines[0].split())\n    N = int(N)\n    P = float(P)\n    energies = []\n    probabilities = []\n    for i in range(1, N + 1):\n        energy, probability = map(float, lines[i].split())\n        energies.append(energy)\n        probabilities.append(probability)\n\n    energies.sort()\n    probabilities.sort()\n\n    energy_wasted = 0\n    probability_found = 0\n    for i in range(N):\n        energy_wasted += energies[i]\n        probability_found += probabilities[i]\n        if probability_found >= P:\n            return str(int(energy_wasted))\n\n    return str(int(energy_wasted))"
    },
    {
        "number": 3243,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected(graph, u, v):\n        return u in graph and v in graph[u]\n\n    def connect(graph, u, v):\n        if u not in graph:\n            graph[u] = set()\n        if v not in graph:\n            graph[v] = set()\n        graph[u].add(v)\n        graph[v].add(u)\n\n    def remove(graph, u, v):\n        if u in graph and v in graph[u]:\n            graph[u].remove(v)\n            graph[v].remove(u)\n\n    def dfs(graph, visited, u):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(graph, visited, v)\n\n    def is_connected_graph(graph, n):\n        visited = [False] * n\n        dfs(graph, visited, 0)\n        return all(visited)\n\n    lines = stdin.split('\\n')\n    n, m, k = map(int, lines[0].split())\n    capacities = list(map(int, lines[1].split()))\n    graph = {}\n\n    for i in range(m):\n        u, v = map(int, lines[2 + i].split())\n        connect(graph, u, v)\n\n    for u in range(n):\n        for v in range(u + 1, n):\n            if not is_connected(graph, u, v):\n                if k > 0:\n                    connect(graph, u, v)\n                    k -= 1\n                else:\n                    return \"no\"\n\n    if is_connected_graph(graph, n):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3244,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    ring = [int(x) for x in stdin.read().splitlines()]\n\n    original_ring = [0] * n\n    for i in range(n):\n        original_ring[i] = (ring[i - 1] + ring[(i + 1) % n]) // 2\n\n    return '\\n'.join(str(x) for x in original_ring)"
    },
    {
        "number": 3245,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    history = []\n    for i in range(1, n + 1):\n        command = lines[i]\n        up_pressed = command.count(\"^\")\n        if up_pressed == 0:\n            history.append(command)\n        else:\n            prefix = command.replace(\"^\", \"\")\n            for cmd in reversed(history):\n                if cmd.startswith(prefix):\n                    history.append(cmd)\n                    break\n            else:\n                history.append(history[-up_pressed])\n    return \"\\n\".join(history[n:])"
    },
    {
        "number": 3246,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(word_list, word):\n        for w in word_list:\n            if w == word:\n                return True\n        return False\n\n    def shuffle_word(word):\n        if len(word) <= 3:\n            return word\n        shuffled = list(word[1:-1])\n        for _ in range(len(shuffled)):\n            i = random.randint(0, len(shuffled) - 1)\n            j = random.randint(0, len(shuffled) - 1)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return word[0] + ''.join(shuffled) + word[-1]\n\n    def decipher(sentence, words):\n        shuffled_words = [shuffle_word(w) for w in words]\n        for shuffled_word in shuffled_words:\n            if shuffled_word in sentence:\n                sentence = sentence.replace(shuffled_word, words[shuffled_words.index(shuffled_word)], 1)\n        return sentence\n\n    lines = stdin.split('\\n')\n    sentence = lines[0]\n    n = int(lines[1])\n    words = lines[2:2 + n]\n\n    if is_valid(words, sentence):\n        return sentence\n    else:\n        deciphered_sentence = decipher(sentence, words)\n        if is_valid(words, deciphered_sentence):\n            return deciphered_sentence\n        else:\n            return \"impossible\" if deciphered_sentence == sentence else \"ambiguous\""
    },
    {
        "number": 3247,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 9\n\n    def count_ways(n, m):\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        dp[1][1] = 1\n        dp[2][1] = 1\n        dp[2][2] = 1\n\n        for i in range(3, n + 1):\n            for j in range(1, m + 1):\n                if j == 1:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j + 1]\n                elif j == m:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + dp[i - 1][j + 1]\n\n        return dp[n][m]\n\n    return str(count_ways(n, m) % MOD)"
    },
    {
        "number": 3248,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, street, M, tile_patterns = parse_input(stdin)\n    untileable_cells = count_untileable_cells(street, tile_patterns)\n    return str(untileable_cells)\n\ndef"
    },
    {
        "number": 3249,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def area(a, b, c):\n        return abs((a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) / 2)\n\n    def is_valid(bulkhead_x, vertices):\n        for i in range(len(vertices)):\n            if distance((bulkhead_x, 0), vertices[i]) > distance((bulkhead_x, 0), vertices[(i + 1) % len(vertices)]):\n                return False\n        return True\n\n    def find_bulkhead_placements(min_area, vertices):\n        total_area = sum(area(vertices[i], vertices[(i + 1) % len(vertices)], vertices[(i + 2) % len(vertices)]) for i in range(len(vertices)))\n        bulkhead_area = min_area * len(vertices)\n        bulkhead_x = (total_area / bulkhead_area) ** 0.5\n        return bulkhead_x\n\n    def find_max_bulkheads(min_area, vertices):\n        max_bulkheads = 0\n        while is_valid(find_bulkhead_placements(min_area, vertices), vertices):\n            max_bulkheads += 1\n            min_area += 1\n        return max_bulkheads - 1\n\n    def main(stdin: str):\n        lines = stdin.split('\\n')\n        min_area = int(lines[0])\n        n = int(lines[1])\n        vertices = [(int(line.split()[0]), int(line.split()[1])) for line in lines[2:2 + n]]\n\n        max_bulkheads = find_max_bulkheads(min_area, vertices)\n        bulkhead_x = find_bulkhead_placements(min_area, vertices)\n        bulkhead_xs = [bulkhead_x]\n        for i in range(max_bulkheads - 1):\n            min_area += 1\n            bulkhead_x = find_bulkhead_placements(min_area, vertices)\n            bulkhead_xs.append(bulkhead_x)\n\n        return f\"{max_bulkheads}\\n\" + '\\n'.join(f\"{x:.6f}\" for x in bulkhead_xs)\n\n    return main(stdin) "
    },
    {
        "number": 3250,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n\n    def is_valid_hack(b: int, d: int, m: int) -> bool:\n        for n in range(1, d):\n            if (f(n, b, d, m) % d) != (n % d):\n                return False\n        return True\n\n    def f(n: int, b: int, d: int, m: int) -> int:\n        k = len(str(n))\n        digits = [int(digit) for digit in str(n)]\n        result = 0\n        for i in range(0, k, m):\n            if i + m > k:\n                break\n            term = 0\n            for j in range(i, i + m):\n                term += digits[j] * (b ** (j - i))\n            result += term\n            term = 0\n            for j in range(i + m, i + 2 * m):\n                if j >= k:\n                    break\n                term += digits[j] * (b ** (j - i - m))\n            result -= term\n        return result\n\n    for m in range(1, d):\n        if is_valid_hack(b, d, m):\n            return \"yes\"\n    return \"no\""
    },
    {
        "number": 3251,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_sequence(intervals):\n        intervals.sort(key=lambda x: x[1])\n        sequences = []\n        for interval in intervals:\n            for sequence in sequences:\n                if sequence[-1][1] <= interval[0]:\n                    sequence.append(interval)\n                    break\n            else:\n                sequences.append([interval])\n        return max(sequences, key=len)\n\n    def format_output(sequence):\n        return str(len(sequence)) + '\\n' + '\\n'.join([' '.join(map(str, interval)) for interval in sequence])\n\n    N = int(stdin.readline().strip())\n    intervals = [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n    longest_sequence = find_longest_sequence(intervals)\n    return format_output(longest_sequence)"
    },
    {
        "number": 3252,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    cards = []\n    for _ in range(n):\n        w, h, q = map(int, stdin.readline().split())\n        cards.append((w, h, q))\n\n    def calculate_waste(envelopes):\n        total_waste = 0\n        for card in cards:\n            area = card[0] * card[1]\n            envelope_area = envelopes[0] * envelopes[1]\n            total_waste += (envelope_area - area) * card[2]\n        return total_waste\n\n    def binary_search(cards, envelopes):\n        left, right = 0, 10000\n        while left < right:\n            mid = (left + right) // 2\n            if can_fit(cards, envelopes, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    def can_fit(cards, envelopes, max_side):\n        for card in cards:\n            if card[0] > max_side or card[1] > max_side:\n                return False\n            envelopes[0] = max(envelopes[0], card[0])\n            envelopes[1] = max(envelopes[1], card[1])\n        return True\n\n    envelopes = [1, 1]\n    min_waste = calculate_waste(envelopes)\n\n    for i in range(2, k + 1):\n        envelopes.append(binary_search(cards, envelopes))\n        min_waste = min(min_waste, calculate_waste(envelopes))\n\n    return str(min_waste)"
    },
    {
        "number": 3253,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_winner(state_info):\n        delegates, const_votes, fed_votes, undecided = state_info\n        const_votes += undecided // 2\n        fed_votes += undecided - (undecided // 2)\n        if const_votes > fed_votes:\n            return \"const\"\n        elif const_votes < fed_votes:\n            return \"fed\"\n        else:\n            return \"tie\"\n\n    def get_min_votes_to_win(state_info, current_winner):\n        delegates, const_votes, fed_votes, undecided = state_info\n        if current_winner == \"const\":\n            needed_votes = const_votes - fed_votes\n        elif current_winner == \"fed\":\n            needed_votes = fed_votes - const_votes\n        else:\n            needed_votes = min(const_votes, fed_votes) - max(const_votes, fed_votes)\n        return max(needed_votes, 0)\n\n    lines = stdin.split(\"\\n\")\n    num_states = int(lines[0])\n    state_info = [list(map(int, line.split())) for line in lines[1:]]\n\n    current_winner = \"tie\"\n    min_votes_to_win = 0\n\n    for state in state_info:\n        winner = get_winner(state)\n        if winner != \"tie\":\n            current_winner = winner\n            min_votes_to_win = get_min_votes_to_win(state, current_winner)\n            break\n\n    for state in state_info:\n        if get_winner(state) != current_winner:\n            min_votes_to_win += get_min_votes_to_win(state, current_winner)\n\n    return str(min_votes_to_win) if current_winner == \"const\" else \"impossible\""
    },
    {
        "number": 3254,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_papers(p, count):\n        if p == 0:\n            return count\n        if p < 0 or p > 5:\n            return float('inf')\n        if memo[p][count] != -1:\n            return memo[p][count]\n\n        memo[p][count] = float('inf')\n        for i in range(5):\n            memo[p][count] = min(memo[p][count], find_min_papers(p - (i + 1), count + 1))\n\n        return memo[p][count]\n\n    p = float(stdin)\n    memo = [[-1 for _ in range(6)] for _ in range(6)]\n    min_papers = find_min_papers(p, 0)\n\n    result = [0, 0, 0, 0, min_papers]\n    for i in range(4, -1, -1):\n        while result[i] < min_papers:\n            result[i] += 1\n            find_min_papers(p - (i + 1), min_papers - 1)\n\n    return ' '.join(map(str, result))"
    },
    {
        "number": 3255,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, D, M, *arr = list(map(int, stdin.split()))\n    max_len = 0\n\n    for i in range(n):\n        visited = [False] * n\n        visited[i] = True\n        curr_len = 1\n        for j in range(i + 1, min(i + D + 1, n)):\n            if abs(arr[j] - arr[i]) <= M and not visited[j]:\n                visited[j] = True\n                curr_len += 1\n        max_len = max(max_len, curr_len)\n\n    for i in range(1, n):\n        visited = [False] * n\n        visited[i] = True\n        curr_len = 1\n        for j in range(i - 1, max(0, i - D - 1), -1):\n            if abs(arr[j] - arr[i]) <= M and not visited[j]:\n                visited[j] = True\n                curr_len += 1\n        max_len = max(max_len, curr_len)\n\n    return str(max_len)"
    },
    {
        "number": 3256,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    A = list(map(int, stdin.readline().split()))\n\n    def bitwise_and(x, y):\n        return x & y\n\n    def bitwise_or(x, y):\n        return x | y\n\n    def max_power(A, K):\n        max_power = 0\n        for i in range(N):\n            for j in range(i, N):\n                if (j - i + 1) % K == 0:\n                    section_power = 0\n                    for k in range(i, j + 1):\n                        section_power = bitwise_or(section_power, A[k])\n                    max_power = max(max_power, section_power)\n        return max_power\n\n    result = max_power(A, K)\n    return str(result)"
    },
    {
        "number": 3257,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split())\n    s = (a + b + c) / 2\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    if area.is_integer() and area > 0:\n        return str(area)\n    else:\n        return \"-1\""
    },
    {
        "number": 3258,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def reachable(v, x1, y1, x2, y2, s):\n        return distance(x1, y1, x2, y2) / v >= s\n\n    def eating_order(mice, v, m):\n        order = []\n        while mice:\n            mouse = min(mice, key=lambda x: distance(0, 0, x[0], x[1]))\n            if reachable(v, 0, 0, mouse[0], mouse[1], mouse[2]):\n                order.append(mouse)\n                v *= m\n                mice.remove(mouse)\n            else:\n                return None\n        return order\n\n    def min_initial_velocity(n, mice, m):\n        left, right = 0, 1000000\n        while left + 1e-3 < right:\n            v = (left + right) / 2\n            order = eating_order(mice.copy(), v, m)\n            if order:\n                right = v\n            else:\n                left = v\n        return right\n\n    n = int(stdin.readline().strip())\n    mice = []\n    for _ in range(n):\n        x, y, s = map(int, stdin.readline().strip().split())\n        mice.append((x, y, s))\n    m = float(stdin.readline().strip())\n\n    return f\"{min_initial_velocity(n, mice, m):.10f}\""
    },
    {
        "number": 3259,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def update_boxes(L, R, A, B, boxes):\n        for i in range(L, R + 1):\n            boxes[i - 1] = (i - L + 1) * A % B\n\n    def count_stones(L, R, boxes):\n        return sum(boxes[L - 1:R])\n\n    lines = stdin.split('\\n')\n    N, Q = map(int, lines[0].split())\n    boxes = [0] * N\n\n    for i in range(1, Q + 1):\n        query = list(map(int, lines[i].split()))\n        if query[0] == 1:\n            L, R, A, B = query[1:]\n            update_boxes(L, R, A, B, boxes)\n        elif query[0] == 2:\n            L, R = query[1:]\n            print(count_stones(L, R, boxes))\n\n    return ''"
    },
    {
        "number": 3260,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % p\n            for l in range(1, i):\n                dp[i][j] += (dp[l - 1][j - 1] * dp[i - l][j]) % p\n\n    return str(dp[n][k])"
    },
    {
        "number": 3261,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    count = 0\n    for i in range(K):\n        row = i // C\n        col = i % C\n        if bin(row).count('1') != bin(col).count('1'):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3262,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        shortest_paths = {vertex: float('inf') for vertex in graph}\n        shortest_paths[start] = 0\n        priority_queue = [(0, start)]\n        visited = set()\n\n        while priority_queue:\n            (cost, current_vertex) = heapq.heappop(priority_queue)\n            if current_vertex in visited:\n                continue\n            visited.add(current_vertex)\n            if current_vertex == end:\n                return cost\n\n            for neighbor, weight in graph[current_vertex].items():\n                new_cost = cost + weight\n                if new_cost < shortest_paths[neighbor]:\n                    shortest_paths[neighbor] = new_cost\n                    heapq.heappush(priority_queue, (new_cost, neighbor))\n\n        return shortest_paths[end]\n\n    def build_graph(streets):\n        graph = {vertex: {} for vertex in range(N)}\n        for street in streets:\n            u, v, w = street\n            graph[u][v] = w\n        return graph\n\n    lines = stdin.split('\\n')\n    N, M, C = map(int, lines[0].split())\n    clients = list(map(int, lines[1].split()))\n    streets = [list(map(int, line.split())) for line in lines[2:2 + M]]\n\n    graph = build_graph(streets)\n    min_trucks = 0\n\n    for client in clients:\n        time = dijkstra(graph, 0, client)\n        if time > T[client]:\n            min_trucks += 1\n            T[client] = time\n\n    return str(min_trucks)"
    },
    {
        "number": 3263,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_serve_customer(customer, current_clothing):\n        return customer[0] == current_clothing or current_clothing == 0\n\n    def change_clothing(new_clothing, current_clothing, P, R):\n        if current_clothing == new_clothing:\n            return 0\n        return P[new_clothing] + R[current_clothing]\n\n    def find_best_clothing(customers, P, R):\n        customers.sort(key=lambda x: x[1])\n        customers_served = []\n        current_clothing = 0\n        time_served = 0\n\n        for customer in customers:\n            if can_serve_customer(customer, current_clothing):\n                customers_served.append(customer)\n                time_served = max(time_served, customer[1] + change_clothing(customer[0], current_clothing, P, R))\n                current_clothing = customer[0]\n\n        return len(customers_served)\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    P = list(map(int, lines[1].split()))\n    R = list(map(int, lines[2].split()))\n    customers = [list(map(int, line.split())) for line in lines[3:N + 3]]\n\n    return str(find_best_clothing(customers, P, R))"
    },
    {
        "number": 3264,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    modulo = 1000000000\n\n    def is_coprime(a, b):\n        return gcd(a, b) == 1\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def has_partition(pairs):\n        for pair in pairs:\n            a, b = pair\n            if not is_coprime(a, b):\n                return True\n        return False\n\n    def count_partitions(pairs, x):\n        count = 0\n        for pair in pairs:\n            a, b = pair\n            if a < x and b < x:\n                count += 1\n        return count\n\n    def generate_pairs(N):\n        pairs = []\n        for i in range(1, N):\n            for j in range(i + 1, N + 1):\n                if is_coprime(i, j):\n                    pairs.append((i, j))\n        return pairs\n\n    def find_partition(pairs):\n        for x in range(2, N + 1):\n            if has_partition(pairs):\n                continue\n            if count_partitions(pairs, x) == len(pairs):\n                return x\n        return None\n\n    pairs = generate_pairs(N)\n    partition = find_partition(pairs)\n\n    if partition is not None:\n        return 0\n\n    return len(pairs) % modulo"
    },
    {
        "number": 3265,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_probability(p, n, connections, target):\n        if p == target:\n            return 1\n        if p > target or n == 0:\n            return 0\n        prob = 0\n        for i in range(n):\n            prob += connections[i] * get_probability(p + 1, n, connections, target)\n        return prob\n\n    def binary_search(p, n, connections, target, l, r):\n        while l <= r:\n            mid = (l + r) // 2\n            if get_probability(p, n, connections, mid) >= target:\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n\n    N, L = map(int, stdin.readline().split())\n    connections = [list(map(int, stdin.readline().split())) for _ in range(N - 1)]\n\n    p = 1\n    for i in range(N - 1):\n        p += connections[i][i + 1]\n\n    target = 0.95\n    result = binary_search(p, N, connections[N - 2], target, L, L + 9)\n    return str(result)"
    },
    {
        "number": 3266,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_data = list(map(int, stdin.split()))\n    n, m, s, t = input_data[0], input_data[1], input_data[2], input_data[3]\n    graph = [[0] * n for _ in range(n)]\n    for i in range(m):\n        u, v, c = input_data[4 + i * 3], input_data[4 + i * 3 + 1], input_data[4 + i * 3 + 2]\n        graph[u][v] = c\n\n    # Implement Ford-Fulkerson algorithm\n    def bfs(graph, s, t):\n        queue = []\n        queue.append(s)\n        visited = [False] * n\n        visited[s] = True\n        parent = [-1] * n\n        while queue:\n            u = queue.pop(0)\n            for v in range(n):\n                if not visited[v] and graph[u][v] > 0:\n                    queue.append(v)\n                    visited[v] = True\n                    parent[v] = u\n        return visited[t], parent\n\n    def dfs(graph, u, t, f, parent):\n        if u == t or not f:\n            return f\n        for v in range(n):\n            if graph[u][v] > 0 and parent[u] != v:\n                curr_flow = dfs(graph, v, t, min(f, graph[u][v]), parent)\n                if curr_flow > 0:\n                    graph[u][v] -= curr_flow\n                    graph[v][u] += curr_flow\n                    return curr_flow\n        return 0\n\n    max_flow = 0\n    flow_graph = graph.copy()\n    while True:\n        visited, parent = bfs(flow_graph, s, t)\n        if not visited:\n            break\n        max_flow += dfs(flow_graph, s, t, float('inf'), parent)\n\n    # Generate output\n    output_data = [n, max_flow, m]\n    for u in range(n):\n        for v in range(n):\n            if graph[u][v] > 0:\n                output_data.extend([u, v, graph[u][v]])\n\n    # Convert output to string\n    output_str = ''\n    for i, item in enumerate(output_data):\n        output_str += str(item)\n        if i < len(output_data) - 1:\n            output_str += ' '\n        else:\n            output_str += '\\n'\n\n    return output_str"
    },
    {
        "number": 3267,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    board = [list(stdin.readline().strip()) for _ in range(R)]\n\n    def get_distance(x1, y1, x2, y2):\n        dx = abs(x1 - x2)\n        dy = abs(y1 - y2)\n        return min(dx, dy) + abs(dx - dy)\n\n    def get_spread(player):\n        spread = 0\n        for i in range(R):\n            for j in range(C):\n                if board[i][j] == player:\n                    for k in range(R):\n                        for l in range(C):\n                            if board[k][l] == player:\n                                spread += get_distance(i, j, k, l)\n        return spread\n\n    mirko_spread = get_spread('M')\n    slavko_spread = get_spread('S')\n\n    return f\"{mirko_spread} {slavko_spread}\""
    },
    {
        "number": 3268,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.splitlines()\n        n = int(lines[0])\n        tree = [[] for _ in range(n + 1)]\n        labels = {}\n        for i in range(1, n + 1):\n            line = lines[i].split()\n            parent = int(line[0])\n            if line[1] in {'B', 'S'}:\n                tree[parent].append(i)\n            else:\n                label = line[2]\n                labels[i] = label\n                tree[parent].append(i)\n        return n, tree, labels\n\n    def find_biggest_branch(tree: list, node: int) -> int:\n        if not tree[node]:\n            return node\n        return find_biggest_branch(tree, tree[node][-1])\n\n    def find_owner(tree: list, labels: dict, node: int) -> set:\n        if node in labels:\n            return {labels[node]}\n        return set().union(*(find_owner(tree, labels, child) for child in tree[node]))\n\n    def find_controlled_area(tree: list, node: int) -> set:\n        return {node} | {leaf for child in tree[node] for leaf in find_controlled_area(tree, child)}\n\n    def find_birds_eating_berries(tree: list, labels: dict, controlled_areas: dict) -> dict:\n        birds_eating_berries = {}\n        for node in labels:\n            if not tree[node]:\n                owner = labels[node]\n                controlled_area = controlled_areas[node]\n                for leaf in controlled_area:\n                    if leaf != node and labels[leaf] == owner:\n                        if owner in birds_eating_berries:\n                            birds_eating_berries[owner].add(leaf)\n                        else:\n                            birds_eating_berries[owner] = {leaf}\n        return birds_eating_berries\n\n    def find_labels_to_change(tree: list, labels: dict, controlled_areas: dict, birds_eating_berries: dict) -> int:\n        labels_to_change = {}\n        for node in labels:\n            if not tree[node]:\n                owner = labels[node]\n                controlled_area = controlled_areas[node]\n                if owner in birds_eating_berries:\n                    for leaf in controlled_area:\n                        if leaf != node and labels[leaf] == owner:\n                            if leaf in birds_eating_berries[owner]:\n                                labels_to_change[leaf] = owner\n                                break\n        return labels_to_change\n\n    def change_labels(tree: list, labels: dict, labels_to_change: dict) -> int:\n        new_labels = {node: label for node, label in labels.items() if node not in labels_to_change}\n        used_labels = set(new_labels.values())\n        for node, label in labels_to_change.items():\n            new_label = label\n            while new_label in used_labels:\n                new_label = ''.join(random.choices(string.ascii_lowercase, k=5))\n            new_labels[node] = new_label\n            used_labels.add(new_label)\n        return new_labels\n\n    n, tree, labels = read_input(stdin)\n    biggest_branch = find_biggest_branch(tree, 1)\n    controlled_areas = {node: find_controlled_area(tree, node) for node in range(1, n + 1)}\n    owner_of_berries = {node: find_owner(tree, labels, node) for node in range(1, n + 1)}\n    birds_eating_berries = find_birds_eating_berries(tree, labels, controlled_areas)\n    labels_to_change = find_labels_to_change(tree, labels, controlled_areas, birds_eating_berries)\n    new_labels = change_labels(tree, labels, labels_to_change)\n    k = len(labels_to_change)\n    output = [f\"{k}\\n\"]\n    for node"
    },
    {
        "number": 3269,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    MOD = 1000000007\n    total_distance = 0\n\n    for i in range(A, B + 1):\n        for j in range(i, B + 1):\n            distance = 0\n            max_len = max(len(str(i)), len(str(j)))\n            num1 = str(i).zfill(max_len)\n            num2 = str(j).zfill(max_len)\n\n            for k in range(max_len):\n                distance += abs(int(num1[k]) - int(num2[k]))\n\n            total_distance += distance\n            total_distance %= MOD\n\n    return str(total_distance)"
    },
    {
        "number": 3270,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    dictionary = set(lines[1:n+1])\n    start_word = lines[n+1]\n    end_word = lines[n+2]\n    min_steps = float('inf')\n    solution_word = ''\n\n    for word in dictionary:\n        if len(word) != len(start_word):\n            continue\n        curr_word = start_word\n        curr_steps = 0\n        for i in range(len(word)):\n            if word[i] != curr_word[i]:\n                new_word = curr_word[:i] + word[i] + curr_word[i+1:]\n                if new_word in dictionary:\n                    curr_word = new_word\n                    curr_steps += 1\n                else:\n                    break\n        if curr_word == end_word and curr_steps < min_steps:\n            min_steps = curr_steps\n            solution_word = word\n\n    if solution_word:\n        return solution_word + '\\n' + str(min_steps)\n    else:\n        return '0\\n-1'"
    },
    {
        "number": 3271,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    mod = 1000000007\n    dp = [[0] * (C + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, N + 1):\n        for j in range(C + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            dp[i][j] %= mod\n\n    return str(dp[N][C])"
    },
    {
        "number": 3272,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(rotated_gargoyles):\n        for i in range(n):\n            for j in range(m):\n                if floorplan[i][j] in \"VH\":\n                    if not rotated_gargoyles[i][j]:\n                        return False\n        return True\n\n    def rotate_gargoyle(i, j):\n        if floorplan[i][j] == \"V\":\n            rotated_gargoyles[i][j] = \"H\"\n        elif floorplan[i][j] == \"H\":\n            rotated_gargoyles[i][j] = \"V\"\n\n    def can_beam(i, j, visited, direction):\n        if not (0 <= i < n and 0 <= j < m) or floorplan[i][j] == \"#\" or visited[i][j]:\n            return False\n\n        if floorplan[i][j] in \"VH\":\n            if not rotated_gargoyles[i][j]:\n                return False\n\n        if floorplan[i][j] in \"/\\\\\":\n            if direction in \"tb\":\n                return True\n            else:\n                return False\n\n        if floorplan[i][j] == \".\":\n            visited[i][j] = True\n            if can_beam(i + 1, j, visited, \"b\") or can_beam(i - 1, j, visited, \"t\") or can_beam(i, j + 1, visited, \"r\") or can_beam(i, j - 1, visited, \"l\"):\n                return True\n            else:\n                return False\n\n    def find_min_rotations():\n        min_rotations = float(\"inf\")\n        for i in range(n):\n            for j in range(m):\n                if floorplan[i][j] in \"VH\":\n                    rotated_gargoyles[i][j] = True\n                    if is_valid(rotated_gargoyles):\n                        min_rotations = min(min_rotations, 1)\n                    else:\n                        for k in range(4):\n                            rotate_gargoyle(i, j)\n                            if is_valid(rotated_gargoyles):\n                                min_rotations = min(min_rotations, k + 1)\n                                break\n                            else:\n                                rotate_gargoyle(i, j)\n        return min_rotations\n\n    stdin = stdin.split(\"\\n\")\n    n, m = map(int, stdin[0].split())\n    floorplan = [list(stdin[i + 1]) for i in range(n)]\n    rotated_gargoyles = [[False for _ in range(m)] for _ in range(n)]\n\n    if not can_beam(0, 0, [[False for _ in range(m)] for _ in range(n)], \"t\"):\n        return -1\n\n    return find_min_rotations()"
    },
    {
        "number": 3273,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def overlap(a, b):\n        for i in range(len(a) - 4, 0, -1):\n            if a[-i:] == b[:i]:\n                return i\n        return 0\n\n    def find_next(fragments, i):\n        max_overlap = 0\n        next_idx = -1\n        for j in range(len(fragments)):\n            if j == i:\n                continue\n            overlap_len = overlap(fragments[i], fragments[j])\n            if overlap_len > max_overlap:\n                max_overlap = overlap_len\n                next_idx = j\n        return next_idx, max_overlap\n\n    def reconstruct(fragments, i, result):\n        if i == len(fragments) - 1:\n            result.append(fragments[i])\n            return True\n        next_idx, max_overlap = find_next(fragments, i)\n        if max_overlap == 0:\n            return False\n        result.append(fragments[i][:-max_overlap])\n        return reconstruct(fragments, next_idx, result)\n\n    n = int(stdin.readline().strip())\n    fragments = [stdin.readline().strip() for _ in range(n)]\n\n    result = []\n    if reconstruct(fragments, 0, result):\n        return \"\".join(result)\n    else:\n        return \"AMBIGUOUS\""
    },
    {
        "number": 3274,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    ships = []\n    for _ in range(m):\n        x1, x2, y = map(int, stdin.readline().split())\n        ships.append((x1, x2, y))\n\n    def is_valid(move: str) -> bool:\n        x, y = 0, 0\n        for i in range(n):\n            if i > 0 and move[i - 1] != '-':\n                x += 1\n            if move[i] == '+':\n                y += 1\n            elif move[i] == '-':\n                y -= 1\n            for x1, x2, y_ship in ships:\n                if y_ship == y and (x1 <= x <= x2 or x1 <= x + 1 <= x2 or x1 <= x - 1 <= x2):\n                    return False\n        return True\n\n    for move in ['--+', '0+-', '+--', '-+0']:\n        if is_valid(move):\n            return move\n    return \"impossible\""
    },
    {
        "number": 3275,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_purchases(N, C, a, b, changes):\n        def is_valid(paintings):\n            colored = sum(paintings)\n            black_white = len(paintings) - colored\n            return (colored >= C or black_white == 0) and all(c <= a[i] or b[i] <= w for i, (c, w) in enumerate(paintings))\n\n        def count_valid(paintings, index, total):\n            if index == N:\n                return 1 if is_valid(paintings) else 0\n            total += count_valid(paintings, index + 1, total)\n            paintings[index] = (paintings[index][0] + 1, paintings[index][1])\n            total += count_valid(paintings, index + 1, total)\n            paintings[index] = (paintings[index][0] - 1, paintings[index][1] + 1)\n            total += count_valid(paintings, index + 1, total)\n            paintings[index] = (paintings[index][0], paintings[index][1] - 1)\n            return total\n\n        paintings = [(0, 0) for _ in range(N)]\n        total = count_valid(paintings, 0, 0)\n\n        for person, ac, bc in changes:\n            person -= 1\n            a[person], b[person] = ac, bc\n            paintings = [(c, w) if i != person else (0, 0) for i, (c, w) in enumerate(paintings)]\n            total = count_valid(paintings, 0, 0)\n\n        return total\n\n    lines = stdin.split('\\n')\n    N, C = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n    Q = int(lines[3])\n    changes = [tuple(map(int, line.split())) for line in lines[4:]]\n\n    result = []\n    for _ in range(Q):\n        result.append(count_purchases(N, C, a, b, changes))\n        result[-1] %= 10007\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3276,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    board = [list(stdin.readline().strip()) for _ in range(N)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M\n\n    def paint(x, y, color):\n        for i in range(x, x + 3):\n            for j in range(y, y + 3):\n                if is_valid(i, j):\n                    board[i][j] = color\n\n    def check_board():\n        for i in range(0, N, 3):\n            for j in range(0, M, 3):\n                if board[i][j] == board[i][j + 1] == board[i][j + 2] == \\\n                        board[i + 1][j] == board[i + 1][j + 1] == board[i + 1][j + 2] == \\\n                        board[i + 2][j] == board[i + 2][j + 1] == board[i + 2][j + 2]:\n                    continue\n                else:\n                    return False\n        return True\n\n    for i in range(N):\n        for j in range(M):\n            if board[i][j] == 'R':\n                paint(i, j, 'R')\n                if check_board():\n                    continue\n                else:\n                    return \"NO\"\n            elif board[i][j] == 'G':\n                paint(i, j, 'G')\n                if check_board():\n                    continue\n                else:\n                    return \"NO\"\n            elif board[i][j] == 'B':\n                paint(i, j, 'B')\n                if check_board():\n                    continue\n                else:\n                    return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3277,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split()[0:3])\n    A = list(map(int, stdin.split()[3:]))\n    changes = 0\n    for i in range(N):\n        if A[i] > S:\n            changes += A[i] - S\n            A[i] = S\n    for i in range(N - K):\n        if sum(A[i:i + K]) != S:\n            changes += S - sum(A[i:i + K])\n            A[i + K // 2] += S - sum(A[i:i + K])\n    return str(changes)"
    },
    {
        "number": 3278,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def prime_factors(n):\n        factors = []\n        for i in range(2, n + 1):\n            if is_prime(i) and n % i == 0:\n                factors.append(i)\n        return factors\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    n = int(stdin.readline().strip())\n    frogs = []\n    for _ in range(n):\n        x, d = map(int, stdin.readline().strip().split())\n        frogs.append((x, d))\n\n    factors = prime_factors(n)\n    max_tower_size = 0\n    min_position = float('inf')\n\n    for factor in factors:\n        frog_groups = [[] for _ in range(factor)]\n        for frog in frogs:\n            group_index = sum(frog) % factor\n            frog_groups[group_index].append(frog)\n\n        for group in frog_groups:\n            if not group:\n                continue\n            group.sort(key=lambda x: x[0])\n            tower_size = 0\n            for i in range(len(group)):\n                if i == 0 or group[i][0] == group[i - 1][0] + group[i - 1][1]:\n                    tower_size += 1\n                else:\n                    break\n            if tower_size > max_tower_size:\n                max_tower_size = tower_size\n                min_position = group[0][0]\n            elif tower_size == max_tower_size:\n                min_position = min(min_position, group[0][0])\n\n    return f\"{min_position} {max_tower_size}\""
    },
    {
        "number": 3279,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    row_specs = []\n    col_specs = []\n\n    for i in range(n):\n        row_specs.append(list(map(int, stdin.readline().strip().split())))\n\n    for i in range(n):\n        col_specs.append(list(map(int, stdin.readline().strip().split())))\n\n    row_markings = []\n    col_markings = []\n\n    for i in range(n):\n        row_markings.append(['0'] * (n + 1))\n\n    for i in range(n):\n        col_markings.append(['0'] * n)\n\n    for i in range(n):\n        for j in range(len(row_specs[i])):\n            for k in range(row_specs[i][j]):\n                row_markings[i][j * (row_specs[i][j] + 1) + k] = '1'\n\n    for i in range(n):\n        for j in range(len(col_specs[i])):\n            for k in range(col_specs[i][j]):\n                col_markings[j][i * (col_specs[i][j] + 1) + k] = '1'\n\n    output = \"\"\n    for i in range(n):\n        output += \"\".join(row_markings[i]) + \"\\n\"\n\n    for i in range(n):\n        output += \"\".join(col_markings[i]) + \"\\n\"\n\n    return output"
    },
    {
        "number": 3280,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    shows = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    shows.sort(key=lambda x: x[1])\n\n    count = 0\n    slots = [None] * k\n    for show in shows:\n        if not any(slot and slot[0] <= show[0] for slot in slots):\n            for i, slot in enumerate(slots):\n                if slot is None or slot[1] <= show[0]:\n                    slots[i] = show\n                    count += 1\n                    break\n\n    return str(count)"
    },
    {
        "number": 3281,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    J, R, D = map(int, stdin.readline().split())\n    junctions = [tuple(map(int, stdin.readline().split())) for _ in range(J)]\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(R)]\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def angle(a, b, c):\n        ab, bc = distance(a, b), distance(b, c)\n        dot_product = (a[0] - b[0]) * (b[0] - c[0]) + (a[1] - b[1]) * (b[1] - c[1])\n        return math.acos(dot_product / (ab * bc))\n\n    def find_path(start, end, visited, path, total_distance):\n        if start == end:\n            return path, total_distance\n\n        for road in roads:\n            if road[0] == start and road[1] not in visited:\n                next_junction = road[1]\n                next_distance = distance(junctions[start - 1], junctions[next_junction - 1])\n                if total_distance + next_distance <= D:\n                    new_path = find_path(next_junction, end, visited + [start], path + [(start, next_junction)], total_distance + next_distance)\n                    if new_path[0]:\n                        return new_path\n\n        return [], -1\n\n    def find_max_angle(path):\n        max_angle = 0\n        for i in range(1, len(path)):\n            a, b, c = junctions[path[i - 1][0] - 1], junctions[path[i - 1][1] - 1], junctions[path[i][1] - 1]\n            max_angle = max(max_angle, angle(a, b, c))\n        return max_angle\n\n    path, total_distance = find_path(1, J, [], [], 0)\n    if total_distance == -1:\n        return \"Impossible\"\n\n    max_angle = find_max_angle(path)\n    return math.degrees(max_angle)"
    },
    {
        "number": 3282,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P = int(stdin)\n    count = 0\n    bills = []\n\n    for beverage_price in range(1, P):\n        for main_dish_price in range(1, P):\n            if beverage_price < main_dish_price and not set(str(beverage_price)) & set(str(main_dish_price)):\n                total_price = beverage_price + main_dish_price\n                if total_price == P:\n                    count += 1\n                    bills.append((beverage_price, main_dish_price))\n\n    if len(bills) > 5000:\n        bills = bills[:5000]\n\n    output = f\"{count}\\n\"\n    for beverage_price, main_dish_price in bills:\n        output += f\"{beverage_price} {main_dish_price}\\n\"\n\n    return output.strip()"
    },
    {
        "number": 3283,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    p = 1 / n\n    expected_gems = sum([(n - i) * (p ** d) for i in range(r)])\n    return f\"{expected_gems:.6f}\""
    },
    {
        "number": 3284,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    count = 0\n    for x in range(a, b + 1):\n        for y in range(c, d + 1):\n            if gcd(x, y) == 1:\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3285,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, m = map(int, stdin.split())\n    A = [r]\n    n = 1\n    while True:\n        d = min(x for x in range(1, m + 1) if x not in A and x not in [abs(A[i] - A[j]) for i in range(n) for j in range(i)])\n        A.append(A[-1] + d)\n        n += 1\n        if m in A or m in [abs(A[i] - A[j]) for i in range(n) for j in range(i)]:\n            break\n    return str(n)"
    },
    {
        "number": 3286,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_password = stdin.strip()\n    modulo = 1000009\n    n = len(encrypted_password)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        if encrypted_password[i - 1] in \"aeiou\":\n            dp[i] = dp[i - 1]\n        else:\n            if i > 1 and encrypted_password[i - 2] not in \"aeiou\":\n                dp[i] = dp[i - 1] + dp[i - 2]\n            else:\n                dp[i] = dp[i - 1]\n\n        dp[i] %= modulo\n\n    return str(dp[n])"
    },
    {
        "number": 3287,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, x = map(int, stdin.split())\n    x = list(map(int, x.split()))\n    total_loot = sum(x)\n    loot = 0\n\n    for i in range(k):\n        if x[i] > 0:\n            loot += x[i]\n            for j in range(i, k):\n                x[j] -= 2 ** i\n\n    if loot % 2 == 1:\n        loot -= 1\n\n    return str(max(0, total_loot - loot))"
    },
    {
        "number": 3288,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    if k > 26 or n > 10**18:\n        return \"-1\"\n\n    def is_k_incremental(s: str) -> bool:\n        if len(s) != sum(range(1, k + 1)):\n            return False\n        char_count = {}\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        for j in range(1, k + 1):\n            if char_count.get(str(j), 0) != 1:\n                return False\n        return True\n\n    def is_double_free(s: str) -> bool:\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                return False\n        return True\n\n    count = 0\n    for i in range(26**k):\n        s = \"\"\n        for j in range(k):\n            s += chr(97 + i % 26)\n            i //= 26\n        if is_k_incremental(s) and is_double_free(s):\n            count += 1\n            if count == n:\n                return s\n\n    return \"-1\""
    },
    {
        "number": 3289,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def sort_key(values):\n        a, b, c = values\n        return a * S + b * T\n\n    def min_cluster_size(sorted_data):\n        max_size = len(sorted_data)\n        for i, (a, b, c) in enumerate(sorted_data):\n            if c == 1:\n                j = i\n                while j > 0 and sorted_data[j - 1][2] == 1:\n                    j -= 1\n                k = i\n                while k < len(sorted_data) - 1 and sorted_data[k + 1][2] == 1:\n                    k += 1\n                size = k - j + 1\n                max_size = min(max_size, size)\n        return max_size\n\n    n, *data = map(int, stdin.split())\n    a, b, c = zip(*data)\n\n    min_s = max(max(a), max(b))\n    max_s = min(min(a), min(b))\n    min_t = max(min(a), min(b))\n    max_t = min(max(a), max(b))\n\n    min_cluster = float('inf')\n    for S in range(min_s, max_s - 1, -1):\n        for T in range(min_t, max_t + 1):\n            sorted_data = sorted(zip(a, b, c), key=sort_key)\n            cluster_size = min_cluster_size(sorted_data)\n            min_cluster = min(min_cluster, cluster_size)\n\n    return str(min_cluster)"
    },
    {
        "number": 3290,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_winner(N, E, D, e, d):\n        e.sort()\n        d.sort()\n        players = [{\"turn\": i, \"hand\": []} for i in range(N)]\n        deck = [\"Exploding Kitten\"] * E + [\"Defuse\"] * D\n        while deck:\n            for player in players:\n                if not deck:\n                    return player[\"turn\"]\n                card = deck.pop()\n                if card == \"Exploding Kitten\":\n                    if \"Defuse\" in player[\"hand\"]:\n                        player[\"hand\"].remove(\"Defuse\")\n                    else:\n                        return player[\"turn\"]\n                elif card == \"Defuse\":\n                    if \"Exploding Kitten\" in player[\"hand\"]:\n                        player[\"hand\"].remove(\"Exploding Kitten\")\n                player[\"hand\"].append(card)\n                while len(player[\"hand\"]) > 5:\n                    player[\"hand\"].pop(0)\n        return -1\n\n    N, E, D = map(int, stdin.readline().split())\n    e = list(map(int, stdin.readline().split()))\n    d = list(map(int, stdin.readline().split()))\n    return str(find_winner(N, E, D, e, d))"
    },
    {
        "number": 3291,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    n = 0\n    output = []\n\n    while c % a != 0 or d % b != 0:\n        c, d = c + a, d + b\n        n += 1\n        if n > 200:\n            return \"-1\"\n\n    for i in range(n):\n        output.append(f\"-1 {i}\")\n\n    output.append(f\"-2 -1\")\n    return f\"{n}\\n\" + \"\\n\".join(output)"
    },
    {
        "number": 3292,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_permutations(names, index, prefix):\n        if index == len(names):\n            return 1\n        count = 0\n        for i in range(index, len(names)):\n            if names[i].startswith(prefix):\n                names[index], names[i] = names[i], names[index]\n                count += count_permutations(names, index + 1, prefix)\n                names[index], names[i] = names[i], names[index]\n        return count\n\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n\n    N = int(stdin.readline().strip())\n    names = [stdin.readline().strip() for _ in range(N)]\n    names.sort()\n\n    modulo = 1000000007\n    total_permutations = 1\n    for i in range(len(names)):\n        prefix = names[i][:i + 1]\n        count = count_permutations(names, i + 1, prefix)\n        total_permutations *= count\n        total_permutations %= modulo\n\n    return str(total_permutations)"
    },
    {
        "number": 3293,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    snacks = []\n    for i in range(n):\n        f, p, m, s = map(int, stdin.readline().split())\n        snacks.append((f, p, m, s))\n\n    def max_profit(snacks):\n        snacks.sort(key=lambda x: x[1] - x[2], reverse=True)\n        profit = 0\n        for i in range(n):\n            f, p, m, s = snacks[i]\n            if s > 0:\n                profit += m - p\n                snacks[f - 1] = (snacks[f - 1][0], snacks[f - 1][1], snacks[f - 1][2], snacks[f - 1][3] - 1)\n        return profit\n\n    return str(max_profit(snacks))"
    },
    {
        "number": 3294,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def closest_distance(contours):\n        min_distance = float('inf')\n        for contour in contours:\n            for i in range(len(contour)):\n                x1, y1 = contour[i]\n                x2, y2 = contour[(i + 1) % len(contour)]\n                min_distance = min(min_distance, distance(x1, y1, x2, y2))\n        return min_distance\n\n    def parse_input(stdin):\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        contours = []\n        for i in range(1, n + 1):\n            h0, h1, m = map(int, lines[i].split())\n            contour = []\n            for j in range(m):\n                x, y = map(int, lines[i + j + 1].split())\n                contour.append((x, y))\n            contours.append(contour)\n        return contours\n\n    contours = parse_input(stdin)\n    min_distance = closest_distance(contours)\n    return f\"{min_distance:.6f}\""
    },
    {
        "number": 3295,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def find_array(K, L, M):\n        happy_numbers = [i for i in range(1, M + 1) if i <= M or is_prime(i)]\n        for i in range(1, 10000000):\n            if all(i + j in happy_numbers for j in range(K)) and sum(1 for j in range(K) if i + j in happy_numbers) == L:\n                return i\n        return -1\n\n    Q = int(stdin.readline().strip())\n    output = []\n    for _ in range(Q):\n        K, L, M = map(int, stdin.readline().strip().split())\n        output.append(find_array(K, L, M))\n    return \"\\n\".join(map(str, output))"
    },
    {
        "number": 3296,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    P = 2**31 - 1\n\n    def count_permutations(n, k):\n        if k == 1:\n            return 1\n        if n == 1:\n            return k\n        if n == 2:\n            return k\n        if n == 3:\n            return k * (k - 1)\n        if n == 4:\n            return k * (k - 1) * (k - 2)\n        if n == 5:\n            return k * (k - 1) * (k - 2) * (k - 3)\n        if n == 6:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4)\n        if n == 7:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5)\n        if n == 8:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6)\n        if n == 9:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7)\n        if n == 10:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8)\n        if n == 11:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9)\n        if n == 12:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) * (k - 10)\n        if n == 13:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) * (k - 10) * (k - 11)\n        if n == 14:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) * (k - 10) * (k - 11) * (k - 12)\n        if n == 15:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) * (k - 10) * (k - 11) * (k - 12) * (k - 13)\n        if n == 16:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) * (k - 10) * (k - 11) * (k - 12) * (k - 13) * (k - 14)\n        if n == 17:\n            return k * (k - 1) *"
    },
    {
        "number": 3297,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(puzzle: str, solution: dict) -> bool:\n        words = puzzle.split('=')\n        carry = 0\n        for i in range(len(words[0]) - 1, -1, -1):\n            if i == len(words[0]) - 1:\n                carry = int(solution[words[0][i]])\n            else:\n                carry += int(solution[words[0][i]])\n                carry += int(solution[words[1][i]])\n            if carry % 10 != int(words[1][i]):\n                return False\n            carry //= 10\n        return True\n\n    def find_solution(puzzle: str, solution: dict, start: int) -> str:\n        if start == len(puzzle):\n            return ''.join([str(solution[c]) for c in puzzle])\n\n        for digit in range(1, 10):\n            if digit not in solution.values() and (puzzle[start].isupper() or digit > 0):\n                solution[puzzle[start]] = digit\n                if is_valid(puzzle, solution):\n                    result = find_solution(puzzle, solution, start + 1)\n                    if result:\n                        return result\n                del solution[puzzle[start]]\n\n        return ''\n\n    puzzle = stdin.strip()\n    if '+' not in puzzle or '=' not in puzzle:\n        return 'impossible'\n\n    solution = {}\n    result = find_solution(puzzle, solution, 0)\n    if result:\n        return result\n    else:\n        return 'impossible' "
    },
    {
        "number": 3298,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def is_sorted(a: List[int]) -> bool:\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if a[i] > a[j]:\n                    return False\n        return True\n\n    def count_permutations(a: List[int]) -> int:\n        mod = 10**9 + 9\n        n = len(a)\n        fact = [1] * (n + 1)\n        for i in range(1, n + 1):\n            fact[i] = (fact[i - 1] * i) % mod\n\n        total = fact[n]\n        duplicates = {}\n        for i in a:\n            if i in duplicates:\n                duplicates[i] += 1\n            else:\n                duplicates[i] = 1\n\n        for count in duplicates.values():\n            total = (total * fact[count]) % mod\n\n        return total\n\n    unsorted_sequences = 0\n    for i in range(2**n):\n        b = [0] * n\n        for j in range(n):\n            b[j] = a[j] if (i & (1 << j)) else a[n - j - 1]\n        if not is_sorted(b):\n            unsorted_sequences += 1\n\n    return str(unsorted_sequences * count_permutations(a) % (10**9 + 9))"
    },
    {
        "number": 3299,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(board: List[List[int]]) -> bool:\n        for row in board:\n            for i in range(len(row) - 1):\n                if row[i] >= row[i + 1]:\n                    return False\n        for j in range(len(board[0])):\n            col = [board[i][j] for i in range(len(board))]\n            for i in range(len(col) - 1):\n                if col[i] >= col[i + 1]:\n                    return False\n        return True\n\n    def fill_board(board: List[List[int]], i: int, j: int, total_sum: int) -> int:\n        if i == len(board) and j == 0:\n            return total_sum\n        if j == len(board[0]):\n            return fill_board(board, i + 1, 0, total_sum)\n        if board[i][j] != 0:\n            return fill_board(board, i, j + 1, total_sum)\n\n        min_sum = float('inf')\n        for num in range(1, 2001):\n            board[i][j] = num\n            if is_valid(board):\n                min_sum = min(min_sum, fill_board(board, i, j + 1, total_sum + num))\n        board[i][j] = 0\n        return min_sum\n\n    n, m = map(int, stdin.split())\n    board = [list(map(int, input().split())) for _ in range(n)]\n\n    min_sum = fill_board(board, 0, 0, 0)\n    return str(min_sum) if min_sum != float('inf') else '-1' "
    },
    {
        "number": 3300,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(t1, t2, v1, v2):\n        return abs(t1 - t2) * (v1 + v2) / 2\n\n    def min_length(cheetahs):\n        cheetahs.sort(key=lambda x: x[0])\n        min_len = float('inf')\n        for i in range(len(cheetahs)):\n            for j in range(i + 1, len(cheetahs)):\n                min_len = min(min_len, distance(cheetahs[i][0], cheetahs[j][0], cheetahs[i][1], cheetahs[j][1]))\n        return min_len\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    cheetahs = [tuple(map(int, line.split())) for line in lines[1:]]\n    result = min_length(cheetahs)\n    return f\"{result:.3f}\""
    },
    {
        "number": 3301,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(start, end, visited, graph, path_len, min_path_len):\n        if start == end:\n            if path_len < min_path_len[0]:\n                min_path_len[0] = path_len\n            return\n\n        if start not in visited:\n            visited.add(start)\n            for neighbor, fee in graph[start]:\n                find_path(neighbor, end, visited, graph, path_len + fee, min_path_len)\n            visited.remove(start)\n\n    def build_graph(banks, partnerships):\n        graph = {bank: [] for bank in banks}\n        for a, b, fee in partnerships:\n            graph[a].append((b, fee))\n            graph[b].append((a, fee))\n        return graph\n\n    def find_largest_fee(N, P, X, Y, partnerships):\n        banks = set(range(1, N + 1))\n        graph = build_graph(banks, partnerships)\n\n        min_path_len = [float('inf')]\n        find_path(X, Y, set(), graph, 0, min_path_len)\n\n        if min_path_len[0] == float('inf'):\n            return \"Impossible\"\n\n        return min_path_len[0]\n\n    lines = stdin.split('\\n')\n    N, P, X, Y = map(int, lines[0].split())\n    partnerships = [list(map(int, line.split())) for line in lines[1:P + 1]]\n\n    largest_fee = find_largest_fee(N, P, X, Y, partnerships)\n    return str(largest_fee)"
    },
    {
        "number": 3302,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def hamming_distance(a, b):\n        return bin(a ^ b).count('1')\n\n    def generate_gray_code(n):\n        if n == 1:\n            return ['0', '1']\n        prev_gray_code = generate_gray_code(n - 1)\n        gray_code = []\n        for i in range(len(prev_gray_code) - 1, -1, -1):\n            gray_code.append('0' + prev_gray_code[i])\n        for i in range(len(prev_gray_code)):\n            gray_code.append('1' + prev_gray_code[i])\n        return gray_code\n\n    def is_valid_code(code, palette):\n        for i in range(len(code) - 1):\n            if hamming_distance(int(code[i], 2), int(code[i + 1], 2)) not in palette:\n                return False\n        return True\n\n    n, p = map(int, stdin.readline().strip().split())\n    palette = list(map(int, stdin.readline().strip().split()))\n\n    if p > n or any(x > n for x in palette):\n        return \"impossible\"\n\n    gray_code = generate_gray_code(n)\n    if p == 1:\n        return '\\n'.join(gray_code)\n\n    for i in range(len(gray_code)):\n        if hamming_distance(int(gray_code[i], 2), int(gray_code[(i + 1) % len(gray_code)], 2)) not in palette:\n            gray_code[i] = 'x'\n\n    while 'x' in gray_code:\n        gray_code.remove('x')\n\n    if len(gray_code) < 2 ** n:\n        return \"impossible\"\n\n    return '\\n'.join(gray_code)"
    },
    {
        "number": 3303,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    steps = 0\n    while a % 10 + b % 10 >= 10:\n        a //= 10\n        b //= 10\n        steps += 1\n    return str(steps)"
    },
    {
        "number": 3304,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n    P = list(map(int, stdin.readline().strip().split()))\n    V = list(map(int, stdin.readline().strip().split()))\n\n    elves = sorted(zip(A, V), key=lambda x: x[1], reverse=True)\n    dwarves = sorted(zip(range(1, N + 1), P), key=lambda x: x[1], reverse=True)\n\n    victories = 0\n    for i in range(N):\n        elf_strength = elves[i][1]\n        dwarf_index = A.index(elves[i][0])\n        dwarf_strength = dwarves[dwarf_index][1]\n\n        if elf_strength > dwarf_strength:\n            victories += 1\n\n    return str(victories)"
    },
    {
        "number": 3305,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_almost_palindrome(s: str) -> bool:\n        return s == s[::-1] or s == s[:-1][::-1] or s == s[1:][::-1]\n\n    def count_almost_palindromic_substrings(s: str) -> int:\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        count = 0\n\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1]\n                if is_almost_palindrome(s[i:j + 1]):\n                    dp[i][j] += 1\n                count += dp[i][j]\n\n        return count\n\n    lines = stdin.split('\\n')\n    N, Q = map(int, lines[0].split())\n    S = lines[1]\n\n    result = []\n    for i in range(2, 2 + Q):\n        L, R = map(int, lines[i].split())\n        result.append(count_almost_palindromic_substrings(S[L - 1:R]))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3306,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    detectors = []\n    for i in range(N):\n        P, C = map(int, stdin.readline().split())\n        detectors.append((P, C))\n\n    detectors.sort()\n    total_calls = 0\n    prev_detector = 0\n    for detector in detectors:\n        P, C = detector\n        if P - prev_detector > 1:\n            total_calls += C\n        else:\n            total_calls += C - prev_detector\n        prev_detector = P\n\n    return str(total_calls)"
    },
    {
        "number": 3307,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def area_of_polygon(vertices):\n        area = 0\n        n = len(vertices)\n        for i in range(n):\n            j = (i + 1) % n\n            area += vertices[i][0] * vertices[j][1]\n            area -= vertices[j][0] * vertices[i][1]\n        return abs(area) / 2\n\n    def is_point_inside_polygon(point, polygon_vertices):\n        n = len(polygon_vertices)\n        inside = False\n        p1 = polygon_vertices[0]\n        for i in range(1, n + 1):\n            p2 = polygon_vertices[i % n]\n            if point[1] > min(p1[1], p2[1]):\n                if point[1] <= max(p1[1], p2[1]):\n                    if point[0] <= max(p1[0], p2[0]):\n                        if p1[1] != p2[1]:\n                            x_intersect = (point[1] - p1[1]) * (p2[0] - p1[0]) / (p2[1] - p1[1]) + p1[0]\n                            if p1[0] == p2[0] or point[0] <= x_intersect:\n                                inside = not inside\n            p1 = p2\n        return inside\n\n    def is_point_on_left_side(point, a, b):\n        return (b[0] - a[0]) * (point[1] - a[1]) - (b[1] - a[1]) * (point[0] - a[0]) > 0\n\n    def is_point_on_right_side(point, a, b):\n        return (b[0] - a[0]) * (point[1] - a[1]) - (b[1] - a[1]) * (point[0] - a[0]) < 0\n\n    def is_point_on_canal(point, a, b):\n        return is_point_on_left_side(point, a, b) and is_point_on_right_side(point, a, b)\n\n    def find_largest_area(polygon_vertices, a, b):\n        largest_area = 0\n        for i in range(len(polygon_vertices)):\n            for j in range(i + 1, len(polygon_vertices)):\n                if is_point_on_canal(polygon_vertices[i], a, b) and is_point_on_canal(polygon_vertices[j], a, b):\n                    if is_point_inside_polygon(((polygon_vertices[i][0] + polygon_vertices[j][0]) / 2, (polygon_vertices[i][1] + polygon_vertices[j][1]) / 2), polygon_vertices):\n                        area = distance(polygon_vertices[i], polygon_vertices[j]) * abs(polygon_vertices[i][1] - polygon_vertices[j][1])\n                        largest_area = max(largest_area, area)\n        return largest_area\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    polygon_vertices = [(float(x), float(y)) for x, y in [line.split() for line in lines[1:N + 1]]]\n    a, b, c, d = [float(x) for x in lines[N + 1].split()]\n\n    largest_area = find_largest_area(polygon_vertices, (a, b), (c, d))\n    return f\"{largest_area:.10f}\""
    },
    {
        "number": 3308,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from shapely.geometry import Polygon, Point\n    import math\n\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def angle(p1, p2, p3):\n        a = distance(p1, p2)\n        b = distance(p2, p3)\n        c = distance(p3, p1)\n        return math.acos((a ** 2 + b ** 2 - c ** 2) / (2 * a * b))\n\n    def area_of_polygon(polygon):\n        area = 0\n        for i in range(len(polygon)):\n            x1, y1 = polygon[i]\n            x2, y2 = polygon[(i + 1) % len(polygon)]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area) / 2\n\n    n = int(stdin.readline().strip())\n    vertices = []\n    for _ in range(n):\n        x, y = map(float, stdin.readline().strip().split())\n        vertices.append((x, y))\n\n    polygon = Polygon(vertices)\n    min_x, min_y, max_x, max_y = polygon.bounds\n\n    area = 0\n    for x in range(int(min_x) - 1, int(max_x) + 2):\n        for y in range(int(min_y) - 1, int(max_y) + 2):\n            p = Point(x, y)\n            if p.within(polygon):\n                visible = True\n                for i in range(n):\n                    p1, p2 = vertices[i], vertices[(i + 1) % n]\n                    if angle(p1, p, p2) + angle(p2, p, p1) < math.pi:\n                        visible = False\n                        break\n                if visible:\n                    area += area_of_polygon([(x, y), (x + 1, y), (x + 1, y + 1), (x, y + 1)])\n\n    return f\"{area:.10f}\""
    },
    {
        "number": 3309,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, C = map(int, stdin.readline().split())\n    A = list(map(int, stdin.readline().split()))\n\n    A.sort()\n\n    count = 1\n    current_count = 1\n    current_colors = 1\n\n    for i in range(1, N):\n        if A[i] == A[i - 1]:\n            current_count += 1\n        else:\n            current_colors += 1\n            current_count = 1\n\n        if current_count >= K and current_colors >= C:\n            count += 1\n            current_colors = 1\n\n    return str(count)"
    },
    {
        "number": 3310,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, g, t, c = map(int, stdin.split())\n    p = [0] * (n + 1)\n    p[1] = 1 - (1 / g)\n    for i in range(2, g + 1):\n        p[i] = p[i - 1] + (1 / g) * p[i - 1]\n\n    expected_occupancy = 0\n    for i in range(1, n + 1):\n        expected_occupancy += p[min(g, c[i - 1])] * c[i - 1]\n\n    for hour in range(1, t + 1):\n        expected_occupancy += p[g] * (n * 200 - expected_occupancy)\n\n    return f\"{expected_occupancy:.10f}\""
    },
    {
        "number": 3311,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    def exponential(n):\n        if n == 1:\n            return 1\n        else:\n            return pow(n, exponential(n - 1), m)\n\n    return str(exponential(n))"
    },
    {
        "number": 3312,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, E, S_X, S_Y, C = map(int, stdin.split()[0].split())\n    cans = []\n    for i in range(C):\n        X, Y, CT = map(int, stdin.split()[i + 1].split())\n        cans.append((X, Y, CT))\n\n    # Sort cans by time\n    cans.sort(key=lambda x: x[2])\n\n    # Initialize variables\n    points = 0\n    energy = E\n    collected_cans = set()\n    spilled_oil = set()\n    current_position = (S_X, S_Y)\n\n    # Iterate through cans\n    for can in cans:\n        X, Y, CT = can\n        if current_position in [(X - 1, Y), (X + 1, Y), (X, Y - 1), (X, Y + 1)]:\n            spilled_oil.add((X, Y))\n        if energy > 0:\n            energy -= 1\n            current_position = (X, Y)\n            collected_cans.add((X, Y))\n            points += 1\n        else:\n            if (X, Y) in spilled_oil:\n                energy += 1\n                spilled_oil.remove((X, Y))\n\n    return str(points)"
    },
    {
        "number": 3313,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_position(x, y):\n        return 0 <= x <= w and 1 <= y <= h\n\n    def can_reach_finish(x, y):\n        return y <= h\n\n    def is_gem_available(x, y):\n        return (x, y) in gems\n\n    def is_within_max_speed(x, y):\n        return abs(x) <= v / r\n\n    def collect_gems(x, y):\n        collected_gems = 0\n        for gem in gems:\n            if is_valid_position(*gem) and can_reach_finish(*gem) and is_gem_available(*gem) and is_within_max_speed(*gem):\n                collected_gems += 1\n        return collected_gems\n\n    n, r, w, h = map(int, stdin.readline().split())\n    gems = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    max_gems = 0\n    for x in range(-v // r, v // r + 1):\n        max_gems = max(max_gems, collect_gems(x, 0))\n\n    return str(max_gems)"
    },
    {
        "number": 3314,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(wheel: str, n: int) -> str:\n        return wheel[n:] + wheel[:n]\n\n    def is_valid(wheels: List[str]) -> bool:\n        for i in range(len(wheels[0])):\n            columns = [wheels[j][i] for j in range(3)]\n            if len(set(columns)) != 3:\n                return False\n        return True\n\n    def find_min_rotations(wheels: List[str]) -> int:\n        min_rotations = float('inf')\n        for i in range(3):\n            for j in range(len(wheels[i])):\n                wheels_copy = [wheels[k] for k in range(3)]\n                wheels_copy[i] = rotate(wheels_copy[i], j + 1)\n                if is_valid(wheels_copy):\n                    min_rotations = min(min_rotations, j + 1)\n        return min_rotations if min_rotations != float('inf') else -1\n\n    stdin_list = stdin.strip().split('\\n')\n    wheels = [stdin_list[i] for i in range(3)]\n    return str(find_min_rotations(wheels))"
    },
    {
        "number": 3315,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    strings = [stdin.readline().strip() for _ in range(n)]\n\n    def is_valid_subsequence(i: int, j: int) -> bool:\n        return strings[j].startswith(strings[i]) and strings[j].endswith(strings[i])\n\n    def find_longest_subsequence() -> int:\n        dp = [1] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_valid_subsequence(i, j):\n                    dp[j] = max(dp[j], dp[i] + 1)\n        return max(dp)\n\n    return str(find_longest_subsequence())"
    },
    {
        "number": 3316,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, t, p = map(int, stdin.split())\n    probability = 1 - (1 - (p / m))**n\n    return f\"{probability:.9f}\""
    },
    {
        "number": 3317,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split('\\n')[0]\n    q = int(stdin.split('\\n')[1])\n    queries = [tuple(map(int, stdin.split('\\n')[i + 2].split())) for i in range(q)]\n\n    def longest_common_subsequence(s1, s2):\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]\n\n    result = []\n    for i, j in queries:\n        result.append(longest_common_subsequence(s[i:], s[j:]))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3318,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.split())\n    tree = [[] for _ in range(N)]\n    for i in range(1, N):\n        parent = int(stdin.readline())\n        tree[parent].append(i)\n\n    def dfs(node, depth):\n        if not tree[node]:\n            return 1\n        tree[node].sort(key=lambda x: depth[x], reverse=True)\n        marked = [False] * N\n        count = 0\n        for child in tree[node]:\n            if not marked[child]:\n                marked[child] = True\n                count += 1\n                if depth[child] >= D:\n                    continue\n                for grandchild in tree[child]:\n                    depth[grandchild] = max(depth[grandchild], depth[child] + 1)\n        return count\n\n    depth = [0] * N\n    return str(dfs(0, depth))"
    },
    {
        "number": 3319,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def add_planetoids(p1, p2):\n        mass = p1[0] + p2[0]\n        velocity = [int((p1[i + 3] + p2[i + 3]) / 2) for i in range(3)]\n        return [mass] + p1[1:4] + velocity\n\n    def simulate(planetoids):\n        collisions = []\n        for i in range(len(planetoids)):\n            for j in range(i + 1, len(planetoids)):\n                if planetoids[i][1:4] == planetoids[j][1:4]:\n                    collisions.append((i, j))\n        while collisions:\n            i, j = collisions[0]\n            new_planetoid = add_planetoids(planetoids[i], planetoids[j])\n            planetoids[i] = new_planetoid\n            planetoids.pop(j)\n            collisions = []\n            for k in range(len(planetoids)):\n                if k != i and planetoids[k][1:4] == new_planetoid[1:4]:\n                    collisions.append((i, k))\n        return planetoids\n\n    def sort_planets(planets):\n        return sorted(planets, key=lambda x: (-x[0], x[1], x[2], x[3]))\n\n    lines = stdin.split('\\n')\n    n, n_x, n_y, n_z = map(int, lines[0].split())\n    planetoids = [list(map(int, line.split())) for line in lines[1:n + 1]]\n    planets = simulate(planetoids)\n    sorted_planets = sort_planets(planets)\n    output = [str(len(sorted_planets))] + [f\"P{i}: {' '.join(map(str, planet))}\" for i, planet in enumerate(sorted_planets)]\n    return '\\n'.join(output)"
    },
    {
        "number": 3320,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def init(n, m):\n        graph = [[] for _ in range(n + 1)]\n        for _ in range(m):\n            a, b, w = map(int, stdin.readline().split())\n            graph[a].append((b, w))\n            graph[b].append((a, w))\n        return graph\n\n    def bitwise_or(path):\n        result = 0\n        for length in path:\n            result |= length\n        return result\n\n    def dijkstra(graph, start):\n        n = len(graph)\n        visited = [False] * (n + 1)\n        distances = [float('inf')] * (n + 1)\n        distances[start] = 0\n        pq = [(0, start)]\n\n        while pq:\n            dist, node = heapq.heappop(pq)\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, length in graph[node]:\n                    new_dist = dist | length\n                    if new_dist < distances[neighbor]:\n                        distances[neighbor] = new_dist\n                        heapq.heappush(pq, (new_dist, neighbor))\n\n        return distances\n\n    def main():\n        n, m, q = map(int, stdin.readline().split())\n        graph = init(n, m)\n        distances = dijkstra(graph, 1)\n        result = []\n\n        for _ in range(q):\n            s, t = map(int, stdin.readline().split())\n            cost = bitwise_or(range(distances[s], distances[t] + 1))\n            result.append(cost)\n\n        return result\n\n    return '\\n'.join(map(str, main()))"
    },
    {
        "number": 3321,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_index(seq, target):\n        for i, x in enumerate(seq):\n            if x == target:\n                return i\n        return -1\n\n    def find_cycle(seq):\n        cycle = []\n        i = 0\n        while i < len(seq) and seq[i] not in cycle:\n            cycle.append(seq[i])\n            i = find_index(seq, seq[i])\n        return cycle\n\n    def make_leap(seq, index, leaps):\n        cycle = find_cycle(seq)\n        cycle_len = len(cycle)\n        if leaps >= cycle_len:\n            leaps -= cycle_len * (leaps // cycle_len)\n        new_index = (index + leaps) % cycle_len\n        return cycle[new_index]\n\n    def find_proclamations(start_seq, end_seq):\n        proclamations = []\n        current_seq = start_seq[:]\n        while current_seq != end_seq:\n            for i, (start_id, end_id) in enumerate(zip(current_seq, end_seq)):\n                if start_id != end_id:\n                    break\n            else:\n                i = 0\n            next_id = make_leap(current_seq, i, current_seq[i])\n            leaps = find_index(current_seq, next_id) - i\n            proclamations.append(leaps)\n            current_seq = [make_leap(current_seq, j, leaps) for j in range(len(current_seq))]\n        return proclamations\n\n    N = int(stdin.readline().strip())\n    start_seq = list(map(int, stdin.readline().strip().split()))\n    end_seq = list(map(int, stdin.readline().strip().split()))\n\n    proclamations = find_proclamations(start_seq, end_seq)\n    return '\\n'.join(map(str, proclamations))"
    },
    {
        "number": 3322,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    antiques = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    prices = [set() for _ in range(m)]\n    for antique in antiques:\n        a, p, b, q = antique\n        prices[a - 1].add(p)\n        prices[b - 1].add(q)\n\n    min_cost = float('inf')\n    for comb in combinations(range(m), k):\n        cost = 0\n        for i, shop in enumerate(comb):\n            if i < k - 1:\n                cost += min(prices[shop])\n            else:\n                cost += min(prices[shop] | {float('inf')})\n        min_cost = min(min_cost, cost)\n\n    return str(min_cost) if min_cost != float('inf') else '-1'"
    },
    {
        "number": 3323,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def max_people(N, juices):\n        A, B, C = 0, 0, 0\n        for juice in juices:\n            A += juice[0]\n            B += juice[1]\n            C += juice[2]\n\n        gcd_ABC = gcd(gcd(A, B), C)\n        A //= gcd_ABC\n        B //= gcd_ABC\n        C //= gcd_ABC\n\n        return min(N, A + B + C)\n\n    T = int(stdin.readline())\n    output = []\n\n    for i in range(T):\n        N = int(stdin.readline())\n        juices = [list(map(int, stdin.readline().split())) for _ in range(N)]\n        result = max_people(N, juices)\n        output.append(f\"Case #{i + 1}: {result}\\n\")\n\n    return \"\".join(output)\n"
    },
    {
        "number": 3324,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    molecules = []\n    for line in lines:\n        if line == '0 0':\n            break\n        molecule = line.split()\n        molecules.append(molecule)\n\n    elements = {}\n    for molecule in molecules:\n        sign = int(molecule[0])\n        for i in range(1, len(molecule), 2):\n            element = molecule[i]\n            count = int(molecule[i + 1])\n            if element not in elements:\n                elements[element] = [0, 0]\n            elements[element][sign] += count\n\n    lcm = 1\n    for element in elements:\n        lcm = lcm * elements[element][0] // gcd(lcm, elements[element][0])\n        lcm = lcm * elements[element][1] // gcd(lcm, elements[element][1])\n\n    result = []\n    for element in elements:\n        result.append(str(lcm // elements[element][0]))\n        result.append(str(lcm // elements[element][1]))\n\n    return ' '.join(result)\n\ndef"
    },
    {
        "number": 3325,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_convex(points):\n        n = len(points)\n        for i in range(n):\n            p1, p2, p3 = points[(i - 1) % n], points[i], points[(i + 1) % n]\n            if not ((p2[1] - p1[1]) * (p3[0] - p2[0]) >= (p3[1] - p2[1]) * (p2[0] - p1[0])):\n                return False\n        return True\n\n    def area(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            p1, p2 = points[i], points[(i + 1) % n]\n            area += p1[0] * p2[1] - p2[0] * p1[1]\n        return abs(area) / 2\n\n    def height(points, depth, litres):\n        n = len(points)\n        max_y = max(p[1] for p in points)\n        min_y = min(p[1] for p in points if p[0] == 0)\n        max_x = max(p[0] for p in points)\n        min_x = min(p[0] for p in points if p[1] == 0)\n        max_water_height = max_y - min_y\n        max_water_volume = (max_x - min_x) * max_water_height\n        water_volume = litres * 1000\n        if water_volume > max_water_volume:\n            water_volume = max_water_volume\n        water_height = water_volume / (max_x - min_x)\n        return min(water_height, depth)\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    depth, litres = map(int, lines[1].split())\n    points = [tuple(map(int, line.split())) for line in lines[2:n + 2]]\n\n    if is_convex(points):\n        return f\"{height(points, depth, litres):.2f}\"\n    else:\n        return \"Error: The polygon is not convex.\""
    },
    {
        "number": 3326,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.readline().split())\n    grid = []\n    for _ in range(r):\n        grid.append(list(map(int, stdin.readline().split())))\n\n    def is_monotonic(subgrid):\n        for row in subgrid:\n            if row != sorted(row) and row != sorted(row, reverse=True):\n                return False\n        for col in range(len(subgrid[0])):\n            column = [subgrid[i][col] for i in range(len(subgrid))]\n            if column != sorted(column) and column != sorted(column, reverse=True):\n                return False\n        return True\n\n    count = 0\n    for rows in range(2**r-1):\n        for cols in range(2**c-1):\n            subgrid = []\n            row_indices = [i for i in range(r) if rows & (1<<i)]\n            col_indices = [i for i in range(c) if cols & (1<<i)]\n            for i in row_indices:\n                subgrid.append([grid[i][j] for j in col_indices])\n            if is_monotonic(subgrid):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3327,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(grid, row, col, word):\n        if row + len(word) > R or col + len(word[0]) > C:\n            return False\n        for i in range(len(word)):\n            for j in range(len(word[0])):\n                if grid[row + i][col + j] != \".\":\n                    return False\n        return True\n\n    def place_word(grid, row, col, word):\n        for i in range(len(word)):\n            for j in range(len(word[0])):\n                grid[row + i][col + j] = word[i][j]\n\n    def solve(grid, words):\n        for word in words:\n            for i in range(R):\n                for j in range(C):\n                    if is_valid(grid, i, j, word):\n                        place_word(grid, i, j, word)\n                        if not words:\n                            return True\n                        if solve(grid, words):\n                            return True\n                        place_word(grid, i, j, ['.' * len(word[0])])\n            return False\n\n    lines = stdin.split('\\n')\n    R, C = map(int, lines[0].split())\n    grid = [list(lines[i + 1]) for i in range(R)]\n    N = int(lines[R + 1])\n    words = [list(line) for line in lines[R + 2:R + 2 + N]]\n\n    solve(grid, words)\n    return '\\n'.join([''.join(row) for row in grid])"
    },
    {
        "number": 3328,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, table = parse_input(stdin)\n    dominoes = find_dominoes(table, K)\n    visible_sum = sum(sum(row) for row in table)\n    for domino in dominoes:\n        visible_sum -= sum(table[domino[0][0]][domino[0][1]], table[domino[1][0]][domino[1][1]])\n    return str(visible_sum)\n\ndef"
    },
    {
        "number": 3329,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    original_circle = input()\n    distinct_circles = 0\n\n    for i in range(N):\n        black_count = original_circle.count('B')\n        white_count = original_circle.count('W')\n\n        if black_count > white_count:\n            distinct_circles += 1\n        elif black_count < white_count:\n            distinct_circles += 2\n        else:\n            distinct_circles += 4\n\n        original_circle = original_circle[1:] + original_circle[0]\n\n    return str(distinct_circles)"
    },
    {
        "number": 3330,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    c = list(map(int, stdin.readline().split()))\n\n    total_bags = sum(a)\n    total_price = sum(c)\n\n    min_product = float('inf')\n\n    for i in range(L, total_bags + 1):\n        p1 = (total_price * i) / (total_bags * i)\n        p2 = (total_price * (total_bags - i)) / (total_bags * (total_bags - i))\n        min_product = min(min_product, p1 * p2)\n\n    return '{:.3f}'.format(min_product)"
    },
    {
        "number": 3331,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, P = map(int, stdin.split())\n\n    def distance(a, b):\n        return abs(a - b)\n\n    def cow_move(a, b):\n        return a + 1, b + 1\n\n    def horse_move(p, a, b):\n        if p == a or p == b:\n            return p + 1\n        elif distance(p, a) <= distance(p, b):\n            return p + 1 if distance(p, a) == 1 else p + 2\n        else:\n            return p + 1 if distance(p, b) == 1 else p + 2\n\n    time = 0\n    while True:\n        a, b = cow_move(A, B)\n        p = horse_move(P, a, b)\n        if p == a or p == b:\n            break\n        A, B = a, b\n        P = p\n        time += 1\n\n    return str(time)"
    },
    {
        "number": 3332,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_priority(streams: list) -> int:\n        streams.sort(key=lambda x: x[2], reverse=True)\n        stack = []\n        total_priority = 0\n\n        for stream in streams:\n            if not stack or stack[-1][1] <= stream[0]:\n                stack.append(stream)\n                total_priority += stream[2]\n            else:\n                while stack and stack[-1][0] + stack[-1][1] > stream[0]:\n                    total_priority -= stack.pop()[2]\n                stack.append(stream)\n                total_priority += stream[2]\n\n        return total_priority\n\n    n = int(stdin.readline().strip())\n    streams = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    return str(find_max_priority(streams))"
    },
    {
        "number": 3333,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_data = list(map(str, stdin.split('\\n')))\n    roost_position = list(map(float, input_data[0].split()))\n    num_hiding_spots = int(input_data[1])\n    hiding_spots = []\n    for i in range(2, 2 + num_hiding_spots):\n        hiding_spots.append(list(map(float, input_data[i].split())))\n\n    # Calculate minimum distance\n    min_distance = float('inf')\n    for spot in hiding_spots:\n        distance = ((spot[0] - roost_position[0]) ** 2 + (spot[1] - roost_position[1]) ** 2) ** 0.5\n        min_distance = min(min_distance, distance)\n\n    return f\"{min_distance:.6f}\""
    },
    {
        "number": 3334,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    distance_table = []\n    for i in range(n - 1):\n        distance_table.append(list(map(int, stdin.readline().strip().split())))\n\n    # Calculate the shortest distances between all pairs of port towns\n    shortest_distances = [[0] * n for _ in range(n)]\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            shortest_distances[i][i + j + 1] = distance_table[i][j]\n            shortest_distances[i + j + 1][i] = distance_table[i][j]\n\n    # Calculate the average distances between all pairs of distance signs\n    total_distance = 0\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i != j and j != k and i != k:\n                    total_distance += shortest_distances[i][j] + shortest_distances[j][k]\n                    count += 1\n\n    if count == 0:\n        return \"impossible\"\n\n    average_distance = total_distance / count\n    return f\"{average_distance:.9f}\""
    },
    {
        "number": 3335,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n):\n        for b in range(a, n):\n            c_square = a**2 + b**2\n            if c_square % n == 0:\n                count += n - b\n            elif c_square % n != 0 and mod_inverse(c_square % n, n) is not None:\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3336,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_eligible(p1, p2):\n        return abs(p1[0] - p2[0]) > 40 or p1[1] != p2[1] or p1[2] != p2[2] or p1[3] != p2[3]\n\n    pupils = []\n    for line in stdin.split('\\n')[1:]:\n        h, sex, music, sport = line.split()\n        pupils.append((int(h), sex, music, sport))\n\n    eligible_pairs = 0\n    for i in range(len(pupils)):\n        for j in range(i + 1, len(pupils)):\n            if is_eligible(pupils[i], pupils[j]):\n                eligible_pairs += 1\n\n    return str(eligible_pairs)"
    },
    {
        "number": 3337,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    stacks = [[] for _ in range(N)]\n    for i in range(1, N):\n        line = stdin.split('\\n')[i].split()\n        if line[0] == 'a':\n            stacks[i] = stacks[int(line[1])].copy()\n            stacks[i].append(i)\n        elif line[0] == 'b':\n            print(stacks[int(line[1])].pop())\n        elif line[0] == 'c':\n            count = 0\n            for num in stacks[int(line[1])]:\n                if num in stacks[int(line[2])]:\n                    count += 1\n            print(count)\n    return ''"
    },
    {
        "number": 3338,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    partners = []\n\n    for _ in range(n):\n        g, p, g_a, p_a = map(int, stdin.readline().split())\n        partners.append((g, p, g_a, p_a))\n\n    partners.sort(key=lambda x: (x[0], x[1]), reverse=True)\n\n    awakened = 0\n    diversity = 0\n\n    for i in range(n):\n        if awakened < k and partners[i][2] != 0:\n            awakened += 1\n            diversity += 1\n        else:\n            if partners[i][0] == partners[i - 1][0] and partners[i][1] == partners[i - 1][1]:\n                break\n            diversity += 1\n\n    return str(diversity)"
    },
    {
        "number": 3339,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, stdin.readline().split())\n        adj_list[a - 1].append(b - 1)\n        adj_list[b - 1].append(a - 1)\n\n    @lru_cache(maxsize=None)\n    def dfs(node: int, visited: int) -> int:\n        if visited == (1 << N) - 1:\n            return 1\n        res = 0\n        for neighbor in adj_list[node]:\n            if (visited >> neighbor) & 1 == 0:\n                res += dfs(neighbor, visited | (1 << neighbor))\n        return res % 1000000009\n\n    return str(dfs(0, 1))"
    },
    {
        "number": 3340,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_flights(n, flights):\n        graph = [[0] * n for _ in range(n)]\n        for a, b in flights:\n            graph[a - 1][b - 1] = 1\n            graph[b - 1][a - 1] = 1\n\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if graph[j][i] and graph[i][k]:\n                        graph[j][k] = 1\n\n        return sum(1 for i in range(n) for j in range(n) if i != j and not graph[i][j]) // 2\n\n    def find_flights_to_cancel(n, flights):\n        min_flights = float('inf')\n        min_flights_pair = None\n        for i in range(n - 1):\n            new_flights = flights[:i] + flights[i + 1:]\n            flights_to_cancel = (flights[i][0], flights[i][1])\n            new_min_flights = find_min_flights(n, new_flights)\n            if new_min_flights < min_flights:\n                min_flights = new_min_flights\n                min_flights_pair = (flights_to_cancel, new_flights)\n        return min_flights_pair\n\n    def find_flights_to_add(n, flights_to_cancel, flights):\n        min_flights = float('inf')\n        min_flights_pair = None\n        for i in range(n):\n            for j in range(n):\n                if i != j and (i, j) not in flights and (i, j) != flights_to_cancel:\n                    new_flights = flights + [(i, j)]\n                    new_min_flights = find_min_flights(n, new_flights)\n                    if new_min_flights < min_flights:\n                        min_flights = new_min_flights\n                        min_flights_pair = (i, j)\n        return min_flights_pair\n\n    n = int(stdin.readline().strip())\n    flights = [tuple(map(int, line.strip().split())) for line in stdin]\n\n    min_flights_pair = find_flights_to_cancel(n, flights)\n    flights_to_cancel, new_flights = min_flights_pair\n    flights_to_add = find_flights_to_add(n, flights_to_cancel, new_flights)\n\n    return f\"{min_flights_pair[0]}\\n{flights_to_cancel[0]} {flights_to_cancel[1]}\\n{flights_to_add[0]} {flights_to_add[1]}\""
    },
    {
        "number": 3341,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.readline().split())\n    producer_prices = []\n    producer_start_days = []\n    consumer_prices = []\n    consumer_end_days = []\n\n    for _ in range(m):\n        p, d = map(int, stdin.readline().split())\n        producer_prices.append(p)\n        producer_start_days.append(d)\n\n    for _ in range(n):\n        q, e = map(int, stdin.readline().split())\n        consumer_prices.append(q)\n        consumer_end_days.append(e)\n\n    max_profit = 0\n\n    for i in range(m):\n        for j in range(n):\n            if producer_start_days[i] <= consumer_end_days[j]:\n                profit = (consumer_end_days[j] - producer_start_days[i] + 1) * (consumer_prices[j] - producer_prices[i])\n                max_profit = max(max_profit, profit)\n\n    return str(max_profit)"
    },
    {
        "number": 3342,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n    def cross_product(a, b, c):\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\n    def convex_hull(points):\n        hull = []\n        for p in points:\n            while len(hull) > 1 and cross_product(hull[-2], hull[-1], p) <= 0:\n                hull.pop()\n            hull.append(p)\n        return hull\n\n    def is_inside(point, hull):\n        for i in range(len(hull)):\n            a = hull[i]\n            b = hull[(i + 1) % len(hull)]\n            if cross_product(a, b, point) < 0:\n                return False\n        return True\n\n    def max_onions(onions, posts, k):\n        hull = convex_hull(posts)\n        max_onions = 0\n        for i in range(len(hull)):\n            a = hull[i]\n            b = hull[(i + 1) % len(hull)]\n            for onion in onions:\n                if is_inside(onion, [a, b]):\n                    max_onions += 1\n        return max_onions\n\n    data = [line.split() for line in stdin.split('\\n') if line]\n    N, M, K = map(int, data[0])\n    onions = [(int(x), int(y)) for x, y in data[1:N + 1]]\n    posts = [(int(x), int(y)) for x, y in data[N + 1:N + M + 1]]\n\n    return str(max_onions(onions, posts, K))"
    },
    {
        "number": 3343,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, n = map(int, stdin.readline().split())\n    points = []\n    for _ in range(n):\n        point, direction = stdin.readline().strip().split()\n        points.append((int(point), direction))\n\n    def is_touching(points):\n        for i in range(len(points) - 1):\n            x1, y1 = points[i]\n            x2, y2 = points[i + 1]\n            if x1 == x2 and y1 == y2:\n                return True\n        return False\n\n    def bend_wire(points):\n        x = L // 2\n        y = 0\n        for point, direction in points:\n            if direction == \"C\":\n                if point < x:\n                    x -= point\n                else:\n                    x += point - L\n                y = L - y\n            else:\n                if point < x:\n                    x += L - point\n                else:\n                    x -= point - L\n                y = -y\n        return x, y\n\n    if is_touching(points):\n        return \"GHOST\"\n    else:\n        x, y = bend_wire(points)\n        if x == L // 2 and y == 0:\n            return \"SAFE\"\n        else:\n            return \"GHOST\""
    },
    {
        "number": 3344,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.readline().split())\n    x = list(map(float, stdin.readline().split()))\n\n    def is_valid_speed(v: float) -> bool:\n        for i in range(N):\n            for j in range(i + 1, N):\n                if abs(x[i] - x[j]) <= 1 + v / L:\n                    return False\n        return True\n\n    def binary_search() -> float:\n        low, high = 0.1, 10\n        while high - low > 1e-9:\n            mid = (low + high) / 2\n            if is_valid_speed(mid):\n                low = mid\n            else:\n                high = mid\n        return low\n\n    v = binary_search()\n    return \"no fika\" if v == 10 else f\"{v:.10f}\""
    },
    {
        "number": 3345,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    shadow_walk = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    lydia_walk = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    shadow_min_x, shadow_max_x = min(x for x, y in shadow_walk), max(x for x, y in shadow_walk)\n    shadow_min_y, shadow_max_y = min(y for x, y in shadow_walk), max(y for x, y in shadow_walk)\n    lydia_min_x, lydia_max_x = min(x for x, y in lydia_walk), max(x for x, y in lydia_walk)\n    lydia_min_y, lydia_max_y = min(y for x, y in lydia_walk), max(y for x, y in lydia_walk)\n\n    min_distance = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if shadow_walk[i][0] == lydia_walk[j][0] and shadow_walk[i][1] == lydia_walk[j][1]:\n                distance = 0\n            else:\n                distance = ((shadow_walk[i][0] - lydia_walk[j][0]) ** 2 + (shadow_walk[i][1] - lydia_walk[j][1]) ** 2) ** 0.5\n            min_distance = min(min_distance, distance)\n\n    return f\"{min_distance:.4f}\""
    },
    {
        "number": 3346,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_irritated(arrival_time, irritation_time, current_time):\n        return current_time - arrival_time > irritation_time\n\n    def get_next_arrival_time(cars, current_time):\n        next_arrival_time = float('inf')\n        for car in cars:\n            if car[0] == 'W':\n                next_arrival_time = min(next_arrival_time, car[1])\n            else:\n                next_arrival_time = min(next_arrival_time, car[1] + 8)\n        return next_arrival_time\n\n    def get_irritated_drivers(cars, t, n):\n        irritated_drivers = 0\n        current_time = 0\n        waiting_cars = []\n\n        while waiting_cars or cars:\n            next_arrival_time = get_next_arrival_time(cars, current_time)\n\n            if waiting_cars:\n                waiting_car = waiting_cars.pop(0)\n                if is_irritated(waiting_car[1], waiting_car[2], current_time):\n                    irritated_drivers += 1\n                current_time = max(next_arrival_time, current_time + t)\n            elif cars:\n                car = cars.pop(0)\n                if is_irritated(car[1], car[2], current_time):\n                    irritated_drivers += 1\n                waiting_cars.append(car)\n                current_time = max(next_arrival_time, current_time + t)\n\n        return irritated_drivers\n\n    t, n = map(int, stdin.readline().strip().split())\n    cars = [tuple(map(int, line.strip().split())) for line in stdin]\n    cars.sort(key=lambda x: x[1])\n\n    return str(get_irritated_drivers(cars, t, n))"
    },
    {
        "number": 3347,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    stores = []\n    for i in range(n):\n        t, h = map(int, stdin.readline().split())\n        stores.append((t, h))\n    \n    sea_level = 0\n    visited_stores = 0\n    while sea_level < stores[-1][1]:\n        for i in range(visited_stores, n):\n            if sea_level + 1 <= stores[i][1]:\n                visited_stores += 1\n            else:\n                break\n        sea_level += 1\n    \n    return str(visited_stores)"
    },
    {
        "number": 3348,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    a, b, c = map(int, stdin.split()[2:])\n    total_bonbons = R * C\n\n    if a + b + c != total_bonbons:\n        return \"impossible\"\n\n    if R == 2:\n        if a % 2 != 0 or b % 2 != 0 or c % 2 != 0:\n            return \"impossible\"\n\n        arrangement = []\n        for i in range(R):\n            row = []\n            for j in range(C):\n                if i % 2 == 0:\n                    if j % 2 == 0:\n                        row.append(\"A\" if a > 0 else \"B\" if b > 0 else \"C\")\n                        a -= 1 if a > 0 else 0\n                        b -= 1 if b > 0 else 0\n                    else:\n                        row.append(\"B\" if b > 0 else \"A\" if a > 0 else \"C\")\n                        b -= 1 if b > 0 else 0\n                        a -= 1 if a > 0 else 0\n                else:\n                    if j % 2 == 0:\n                        row.append(\"B\" if b > 0 else \"C\" if c > 0 else \"A\")\n                        b -= 1 if b > 0 else 0\n                        c -= 1 if c > 0 else 0\n                    else:\n                        row.append(\"C\" if c > 0 else \"B\" if b > 0 else \"A\")\n                        c -= 1 if c > 0 else 0\n                        b -= 1 if b > 0 else 0\n            arrangement.append(row)\n\n        return \"\\n\".join([\"\".join(row) for row in arrangement])\n\n    else:\n        return \"impossible\""
    },
    {
        "number": 3349,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    dictionary = set()\n    for _ in range(n):\n        dictionary.add(stdin.readline().strip())\n    message = stdin.readline().strip()\n\n    def is_valid(word):\n        for letter in word:\n            if letter not in dictionary:\n                return False\n        return True\n\n    def count_vowels(word):\n        return sum(1 for letter in word if letter in \"AEIOU\")\n\n    def reconstruct(message, words):\n        if not message:\n            return words\n        for i in range(1, len(message) + 1):\n            word = message[:i]\n            if word in dictionary:\n                remaining_message = message[i:]\n                new_words = words + [word]\n                if is_valid(remaining_message):\n                    return reconstruct(remaining_message, new_words)\n                elif count_vowels(new_words) > count_vowels(words):\n                    result = reconstruct(remaining_message, new_words)\n                    if result:\n                        return result\n        return None\n\n    result = reconstruct(message, [])\n    if result:\n        return \" \".join(result)\n    else:\n        return \"No solution found\""
    },
    {
        "number": 3350,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.strip()\n    n = len(word)\n    max_power = 0\n\n    for i in range(n):\n        for j in range(i + 4, n + 1, 4):\n            subword = word[i:j]\n            if subword == subword[::-1] and subword[::2] == subword[::2][::-1]:\n                max_power = max(max_power, j - i)\n\n    return max_power * 4"
    },
    {
        "number": 3351,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_sequences(dice_rolls, n):\n        sequences = {}\n        for i in range(len(dice_rolls) - n + 1):\n            sequence = tuple(sorted(dice_rolls[i:i + n]))\n            if sequence in sequences:\n                sequences[sequence] += 1\n            else:\n                sequences[sequence] = 1\n        return sequences\n\n    def score_sequential_yahtzee(dice_rolls):\n        total_score = 0\n        current_category = 1\n        for i in range(len(dice_rolls) // 5):\n            if current_category == 1:\n                total_score += sum(dice_rolls[i * 5:i * 5 + 5])\n            elif current_category == 2:\n                total_score += sum(dice_rolls[i * 5:i * 5 + 5]) * 2\n            elif current_category == 3:\n                total_score += sum(dice_rolls[i * 5:i * 5 + 5]) * 3\n            elif current_category == 4:\n                total_score += sum(dice_rolls[i * 5:i * 5 + 5]) * 4\n            elif current_category == 5:\n                total_score += sum(dice_rolls[i * 5:i * 5 + 5]) * 5\n            elif current_category == 6:\n                total_score += sum(dice_rolls[i * 5:i * 5 + 5]) * 6\n            elif current_category == 7:\n                total_score += sum(dice_rolls[i * 5:i * 5 + 5])\n            elif current_category == 8:\n                total_score += sum(dice_rolls[i * 5:i * 5 + 5])\n            elif current_category == 9:\n                total_score += 25\n            elif current_category == 10:\n                total_score += 30\n            elif current_category == 11:\n                total_score += 40\n            elif current_category == 12:\n                total_score += 50\n            elif current_category == 13:\n                total_score += 50\n            current_category += 1\n        return total_score\n\n    stdin_list = stdin.split('\\n')\n    n = int(stdin_list[0])\n    dice_rolls = [int(x) for x in ' '.join(stdin_list[1:]).split()]\n\n    sequences = count_sequences(dice_rolls, 5)\n    max_score = 0\n    for sequence, count in sequences.items():\n        if count >= 13:\n            max_score = max(max_score, score_sequential_yahtzee(list(sequence) * count))\n\n    return str(max_score)"
    },
    {
        "number": 3352,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_magical_colors(node, parent, colors):\n        count = 1 if node == 1 else 0\n        for child in colors[node]:\n            if child != parent:\n                count += count_magical_colors(child, node, colors)\n        return count if count % 2 == 0 else 0\n\n    def modify_colors(node, parent, colors, new_color):\n        colors[node].remove(parent)\n        colors[parent].remove(node)\n        colors[node].add(new_color)\n        colors[new_color].add(node)\n\n    def process_query(query, colors):\n        if query[0] == 0:\n            return count_magical_colors(query[1], None, colors)\n        else:\n            modify_colors(query[1], None, colors, query[0])\n\n    lines = stdin.split('\\n')\n    N, Q = map(int, lines[0].split())\n    colors = {i: set() for i in range(1, N + 1)}\n    for i, color in enumerate(map(int, lines[1].split())):\n        colors[i + 1].add(color)\n    for i, parent in enumerate(map(int, lines[2].split())):\n        colors[i + 1].add(parent)\n        colors[parent].add(i + 1)\n\n    result = []\n    for i in range(3, 3 + Q):\n        query = list(map(int, lines[i].split()))\n        result.append(process_query(query, colors))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3353,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, start, end, time):\n        if start == end:\n            return time\n        if start in visited:\n            return -1\n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                result = dfs(graph, visited, neighbor, end, time + 1)\n                if result != -1:\n                    return result\n        return -1\n\n    def bfs(graph, start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, time = queue.pop(0)\n            if node == end:\n                return time\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, time + 1))\n        return -1\n\n    def create_graph(logs):\n        graph = {i: set() for i in range(-2, logs[-1][-1] + 1)}\n        for log in logs:\n            graph[log[0]].add(log[1])\n            graph[log[1]].add(log[0])\n        return graph\n\n    def find_min_time(graph, people, start, end):\n        total_time = 0\n        for _ in range(people):\n            time = bfs(graph, start, end)\n            if time == -1:\n                return f\"{people - _} people left behind\"\n            total_time += time\n        return total_time\n\n    lines = stdin.split(\"\\n\")\n    P, R, L = map(int, lines[0].split())\n    logs = [list(map(int, line.split())) for line in lines[1:]]\n    graph = create_graph(logs)\n    start, end = -2, -1\n    return find_min_time(graph, P, start, end)"
    },
    {
        "number": 3354,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, r, n, z = map(float, stdin.split())\n    z /= 100\n    area_sandwich = s ** 2 * 3.14159\n    area_pickle = r ** 2 * 3.14159\n    max_pickles = 0\n\n    for i in range(1, int(n) + 1):\n        area_used = i * area_pickle\n        if area_used > area_sandwich * z:\n            break\n        max_pickles = i\n\n    return str(max_pickles)"
    },
    {
        "number": 3355,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(tasks, task_idx, time_limit):\n        total_time = 0\n        for i in range(len(tasks)):\n            if i == task_idx:\n                continue\n            total_time += tasks[i][task_idx]\n        total_time += tasks[task_idx][-1]\n        return total_time <= time_limit\n\n    def dfs(tasks, task_idx, time_limit, visited, points, total_points):\n        if task_idx == len(tasks):\n            return total_points\n\n        if not is_valid(tasks, task_idx, time_limit):\n            return 0\n\n        if task_idx in visited:\n            return dfs(tasks, task_idx + 1, time_limit, visited, points, total_points)\n\n        visited.add(task_idx)\n        total_points += points[task_idx]\n        return max(dfs(tasks, task_idx + 1, time_limit, visited, points, total_points),\n                   dfs(tasks, task_idx + 1, time_limit, visited, points, total_points - points[task_idx]))\n\n    lines = stdin.split('\\n')\n    n, time_limit = map(int, lines[0].split())\n    tasks = [list(map(int, lines[i + 1].split())) for i in range(n)]\n    points = [task[0] for task in tasks]\n    tasks = [[tasks[i][j] for j in range(len(tasks))] for i in range(len(tasks))]\n\n    max_points = dfs(tasks, 0, time_limit, set(), 0, 0)\n    if max_points == 0:\n        return '\\n'\n\n    tasks_to_perform = [i for i in range(n) if points[i] > 0]\n    tasks_to_perform.sort(key=lambda x: (tasks[x][-2], tasks[x][-1]))\n    tasks_to_perform = ' '.join(map(str, tasks_to_perform))\n\n    return f'{max_points}\\n{tasks_to_perform}\\n'"
    },
    {
        "number": 3356,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_farthest_pair(graph, dist):\n        farthest_dist = 0\n        farthest_pair = None\n        for i in range(len(graph)):\n            for j in range(i + 1, len(graph)):\n                if dist[i][j] > farthest_dist:\n                    farthest_dist = dist[i][j]\n                    farthest_pair = (i, j)\n        return farthest_pair, farthest_dist\n\n    def find_new_tunnel(graph, dist, u, v):\n        max_dist = 0\n        max_i = -1\n        for i in range(len(graph)):\n            if i != u and i != v:\n                d = dist[u][i] + dist[i][v]\n                if d > max_dist:\n                    max_dist = d\n                    max_i = i\n        return max_i, max_dist\n\n    def reconstruct(graph, u, v, x, y):\n        graph[u].remove(v)\n        graph[v].remove(u)\n        graph[u].append(x)\n        graph[x].append(u)\n        graph[v].append(y)\n        graph[y].append(v)\n\n    def bfs(graph, start):\n        visited = [False] * len(graph)\n        dist = [0] * len(graph)\n        queue = [start]\n        visited[start] = True\n\n        while queue:\n            u = queue.pop(0)\n            for v in graph[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n        return dist\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    graph = [[] for _ in range(N)]\n    for i in range(N - 1):\n        u, v = map(int, lines[i + 1].split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    dist = [bfs(graph, i) for i in range(N)]\n    farthest_pair, farthest_dist = find_farthest_pair(graph, dist)\n    u, v = farthest_pair\n    x, new_dist = find_new_tunnel(graph, dist, u, v)\n    reconstruct(graph, u, v, x, x)\n\n    return f'{farthest_dist}\\n{u + 1} {v + 1}\\n{x + 1} {x + 1}\\n'"
    },
    {
        "number": 3357,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def hours_in_sunlight(x, h, n):\n        return 180 * (h / (2 * (n + 1) * x))\n\n    n = int(stdin.readline())\n    result = []\n\n    for i in range(n):\n        x, h = map(int, stdin.readline().split())\n        result.append(hours_in_sunlight(x, h, n))\n\n    return \"\\n\".join(f\"{x:.5f}\" for x in result)"
    },
    {
        "number": 3358,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    instructions = []\n\n    # Convert the number to binary\n    binary = bin(num)[2:]\n\n    # Pad the binary number with zeros to make it 8 bits\n    binary = binary.zfill(8)\n\n    # Iterate through the binary number\n    for bit in binary:\n        # If the bit is 1, set the register to 1\n        if bit == \"1\":\n            instructions.append(\"ST A\")\n            instructions.append(\"ST X\")\n            instructions.append(\"PH A\")\n            instructions.append(\"PH X\")\n            instructions.append(\"AD\")\n            instructions.append(\"PL Y\")\n        # If the bit is 0, set the register to 0\n        else:\n            instructions.append(\"ZE A\")\n            instructions.append(\"ZE X\")\n            instructions.append(\"PH A\")\n            instructions.append(\"PH X\")\n            instructions.append(\"AD\")\n            instructions.append(\"PL Y\")\n\n    # Add the final instruction to display the number\n    instructions.append(\"DI Y\")\n\n    # Ensure the number of instructions is within the limit\n    if len(instructions) > 40:\n        raise ValueError(\"Number of instructions exceeds the limit of 40.\")\n\n    return \"\\n\".join(instructions)"
    },
    {
        "number": 3359,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, R, C = map(int, lines[0].split())\n    camera_view = []\n    for i in range(1, R + 1):\n        row = list(map(lambda x: int(x, 16), lines[i].split()))\n        camera_view.append(row)\n\n    def is_star(x, y):\n        for dx in range(-N, N + 1):\n            for dy in range(-N, N + 1):\n                if 0 <= x + dx < R and 0 <= y + dy < C:\n                    if camera_view[x + dx][y + dy] == 0xFFFF:\n                        return True\n        return False\n\n    stars = 0\n    for i in range(R):\n        for j in range(C):\n            if is_star(i, j):\n                stars += 1\n\n    return str(stars)"
    },
    {
        "number": 3360,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    rules = []\n    n = int(stdin.readline().strip())\n    for _ in range(n):\n        rule = stdin.readline().strip().split(\"->\")\n        rules.append((rule[0].strip(), rule[1].strip()))\n\n    # Define the start variable\n    start_var = rules[0][0]\n\n    # Generate all possible strings using the CFG\n    generated_strings = set()\n    for line in stdin:\n        line = line.strip()\n        for i in range(len(line)):\n            for j in range(i, len(line) + 1):\n                if (line[i:j] in generated_strings) or (len(line[i:j]) == 0):\n                    continue\n                for rule in rules:\n                    if rule[1] == line[i:j]:\n                        generated_strings.add(line[i:j])\n                        break\n\n    # Search for the longest substring that can be generated\n    longest_substring = \"NONE\"\n    for line in stdin:\n        line = line.strip()\n        for i in range(len(line)):\n            for j in range(i, len(line) + 1):\n                if line[i:j] in generated_strings and len(line[i:j]) > len(longest_substring):\n                    longest_substring = line[i:j]\n        print(longest_substring)\n        longest_substring = \"NONE\""
    },
    {
        "number": 3361,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    distances = [[0] * n for _ in range(n)]\n    for i in range(n - 1):\n        for j, d in enumerate(map(int, stdin.readline().split())):\n            distances[i][i + j] = distances[i + j][i] = d\n\n    def min_disparity(subset: set, remaining: set) -> int:\n        if not subset or not remaining:\n            return 0\n        return max(distances[i][j] for i in subset for j in remaining)\n\n    def find_min_sum_of_disparities(current_subset: set, remaining: set, current_disparity: int) -> int:\n        if not remaining:\n            return current_disparity\n\n        next_subset = current_subset.copy()\n        next_subset.add(remaining.pop())\n        next_disparity = min_disparity(next_subset, remaining)\n        next_sum = find_min_sum_of_disparities(next_subset, remaining, current_disparity + next_disparity)\n\n        current_sum = find_min_sum_of_disparities(current_subset, remaining, current_disparity)\n\n        return min(current_sum, next_sum)\n\n    return str(find_min_sum_of_disparities(set(), set(range(n)), 0))"
    },
    {
        "number": 3362,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, F, L, W = map(int, stdin.split('\\n')[0].split())\n    map_data = stdin.split('\\n')[2:L+2]\n    start_pos = []\n    goal_pos = []\n    safe_tiles = []\n    lava_tiles = []\n\n    for i in range(L):\n        for j in range(W):\n            if map_data[i][j] == 'S':\n                start_pos = [i, j]\n            elif map_data[i][j] == 'G':\n                goal_pos = [i, j]\n            elif map_data[i][j] == 'W':\n                safe_tiles.append([i, j])\n            elif map_data[i][j] == 'B':\n                lava_tiles.append([i, j])\n\n    def is_safe(pos):\n        return pos[0] >= 0 and pos[0] < L and pos[1] >= 0 and pos[1] < W and map_data[pos[0]][pos[1]] != 'B'\n\n    def bfs(start, goal, step_length):\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            pos, depth = queue.pop(0)\n            if pos == goal:\n                return depth\n            if pos not in visited and is_safe(pos):\n                visited.add(pos)\n                for i in range(-step_length, step_length+1):\n                    for j in range(-step_length, step_length+1):\n                        if abs(i) + abs(j) <= step_length:\n                            new_pos = [pos[0]+i, pos[1]+j]\n                            queue.append((new_pos, depth+1))\n        return None\n\n    elsa_depth = bfs(start_pos, goal_pos, A)\n    father_depth = bfs(start_pos, goal_pos, F)\n\n    if elsa_depth is not None and father_depth is not None:\n        if elsa_depth == father_depth:\n            return \"SUCCESS\"\n        elif elsa_depth < father_depth:\n            return \"GO FOR IT\"\n        else:\n            return \"NO CHANCE\"\n    elif elsa_depth is not None:\n        return \"NO CHANCE\"\n    elif father_depth is not None:\n        return \"GO FOR IT\"\n    else:\n        return \"NO WAY\""
    },
    {
        "number": 3363,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    calories = list(map(int, stdin.split()[2:]))\n    max_calories = 0\n\n    for i in range(n):\n        max_calories += min(m, calories[i])\n        m = m * 2 / 3\n\n    return str(max_calories)"
    },
    {
        "number": 3364,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        x_root = find(x)\n        y_root = find(y)\n        if x_root == y_root:\n            return False\n        parent[y_root] = x_root\n        return True\n\n    def query(x, y):\n        x_root = find(x)\n        y_root = find(y)\n        return x_root == y_root\n\n    lines = stdin.split('\\n')\n    N, Q = map(int, lines[0].split())\n    parent = list(range(N))\n\n    result = []\n    for i in range(1, Q + 1):\n        operation, a, b = lines[i].split()\n        a, b = int(a), int(b)\n        if operation == '=':\n            union(a, b)\n        elif operation == '?':\n            result.append('yes' if query(a, b) else 'no')\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3365,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = list(map(int, input().split()))\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_max_prime(start, end):\n        max_prime = 1\n        for i in range(start, end + 1):\n            max_prime = lcm(max_prime, i)\n        for i in range(2, max_prime + 1):\n            if is_prime(i) and max_prime % i == 0:\n                max_prime = i\n        return max_prime\n\n    max_score = float('inf')\n    for i in range(1, n - k + 2):\n        regions = [sequence[j:j + i] for j in range(0, n, i)]\n        score = min(find_max_prime(min(region), max(region)) for region in regions)\n        max_score = min(max_score, score)\n\n    return str(max_score)"
    },
    {
        "number": 3366,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def f(X: int) -> int:\n        iterations = 0\n        while X != 1:\n            if X % 2 == 0:\n                X //= 2\n            else:\n                X += 1\n            iterations += 1\n        return iterations\n\n    S = 0\n    for i in range(L, R + 1):\n        S += f(i)\n\n    return str(S % MOD)"
    },
    {
        "number": 3367,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = map(int, stdin.readline().split())\n    questions = []\n    for _ in range(n):\n        question, answer = stdin.readline().strip().split('?')\n        question = question.split()\n        questions.append((question, answer))\n\n    total_points = 0\n    for question, answer in questions:\n        total_points += 1\n        for i in range(1, len(question)):\n            if len(set(question[:i])) == i:\n                total_points -= 1\n                break\n\n    return f\"{total_points / t:.10f}\""
    },
    {
        "number": 3368,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    enclosures = {}\n    for _ in range(n):\n        animal_type, num_animals, *animals = stdin.readline().split()\n        num_animals = int(num_animals)\n        enclosures[animal_type] = {\n            \"count\": num_animals,\n            \"animals\": set(animals)\n        }\n\n    for animal_type, info in enclosures.items():\n        if info[\"count\"] != len(info[\"animals\"]):\n            return \"POSSIBLE\"\n\n    return \"FALSE ALARM\""
    },
    {
        "number": 3369,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_triple_correlation(sequence: str, p: int) -> str:\n        for n in range(1, p // 40 + 2):\n            for m in range(1, p // 40 + 2):\n                for a in range(10):\n                    for b in range(10):\n                        for c in range(10):\n                            count = 0\n                            for i in range(p - n - m):\n                                if sequence[i] == str(a) and sequence[i + n] == str(b) and sequence[i + n + m] == str(c):\n                                    count += 1\n                            if count >= max(p // 40 + 1, n + m + 2):\n                                return f\"triple correlation {a}({n}){b}({m}){c} found\"\n        return \"random sequence\"\n\n    input_data = stdin.split(\"\\n\")\n    p = int(input_data[0])\n    sequence = \"\".join(input_data[1:])\n    return find_triple_correlation(sequence, p)"
    },
    {
        "number": 3370,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, k = map(float, stdin.split())\n    heights = [float(input()) for _ in range(int(N))]\n    heights.insert(0, 0)\n    heights.append(0)\n\n    for _ in range(100000):\n        for i in range(1, int(N) + 1):\n            left_neighbor = heights[i - 1]\n            right_neighbor = heights[i + 1]\n            avg_height = (left_neighbor + right_neighbor) / 2\n            if heights[i] < avg_height + k:\n                heights[i] = avg_height + k\n\n    return str(max(heights))"
    },
    {
        "number": 3371,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.readline().split())\n    first_meetings = [tuple(map(int, stdin.readline().split())) for _ in range(c)]\n\n    for year in range(1948, 2008):\n        groups = [[], []]\n        for a, b, y in first_meetings:\n            if y < year:\n                groups[0].append(a)\n                groups[0].append(b)\n            else:\n                groups[1].append(a)\n                groups[1].append(b)\n\n        if all(len(set(group)) <= (2 * n / 3) for group in groups):\n            return year\n\n    return 'Impossible'"
    },
    {
        "number": 3372,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected(graph, start, end, visited=None):\n        if visited is None:\n            visited = set()\n        if start == end:\n            return True\n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited and is_connected(graph, neighbor, end, visited):\n                return True\n        return False\n\n    def read_graph(stdin):\n        lines = stdin.split(\"\\n\")\n        N = int(lines[0].split()[0])\n        s, t = map(int, lines[0].split()[1:])\n        graph = {i: set() for i in range(N)}\n        for i in range(N):\n            line = lines[i + 1]\n            if line[0] == \"N\":\n                airports = set(map(int, line.split()[1:]))\n                graph[i] |= airports\n            else:\n                airports = set(range(N)) - set(map(int, line.split()[1:]))\n                graph[i] |= airports\n        return N, s, t, graph\n\n    N, s, t, graph = read_graph(stdin)\n    if is_connected(graph, s, t):\n        return f\"{len(graph[s]) + len(graph[t]) - 2}\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3373,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pieces = stdin.split('\\n')[1:]\n\n    def is_balanced(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def longest_balanced(s: str) -> str:\n        if is_balanced(s):\n            return s\n        for i in range(len(s)):\n            if not is_balanced(s[:i] + s[i + 1:]):\n                continue\n            return longest_balanced(s[:i] + s[i + 1:])\n\n    longest = ''\n    for piece in pieces:\n        longest_piece = longest_balanced(piece)\n        if len(longest_piece) > len(longest):\n            longest = longest_piece\n\n    return len(longest)"
    },
    {
        "number": 3374,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def uw_distance(gravity_values):\n        capacitance = [gravity_values[i + 1] + gravity_values[i] for i in range(len(gravity_values) - 1)]\n        potential = [gravity_values[i + 1] - gravity_values[i] for i in range(len(gravity_values) - 1)]\n        inductance = [gravity_values[i + 1] * gravity_values[i] for i in range(len(gravity_values) - 1)]\n        return abs(sum(potential * (capacitance * capacitance - inductance)))\n\n    def find_min_uw_distance(systems, links):\n        min_uw_distance = float('inf')\n        for alien_system, human_system in links:\n            if systems[alien_system][1] == 'a' and systems[human_system][1] == 'h':\n                min_uw_distance = min(min_uw_distance, uw_distance([systems[alien_system][0], systems[human_system][0]]))\n        return min_uw_distance\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    systems = [(int(line.split()[0]), line.split()[1]) for line in lines[1:n+1]]\n    e = int(lines[n+1])\n    links = [(int(line.split()[0]), int(line.split()[1])) for line in lines[n+2:n+2+e]]\n\n    return str(find_min_uw_distance(systems, links))"
    },
    {
        "number": 3375,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    V, E = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(V)]\n    for _ in range(E):\n        A, B = map(int, stdin.readline().split())\n        adj_list[A-1].append(B-1)\n        adj_list[B-1].append(A-1)\n\n    def dfs(node, visited, parent):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n\n    def is_cyclic(node, visited, parent):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if is_cyclic(neighbor, visited, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n\n    def count_spanning_unicycles():\n        count = 0\n        for i in range(V):\n            visited = [False] * V\n            if not is_cyclic(i, visited, -1):\n                for j in range(V):\n                    if not visited[j]:\n                        visited[j] = True\n                        if dfs(j, visited, -1):\n                            count += 1\n        return count\n\n    MOD = 10**9 + 7\n    return str(count_spanning_unicycles() % MOD)"
    },
    {
        "number": 3376,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split(\"\\n\")\n        num_families = int(lines[0])\n        families = []\n        for i in range(1, num_families + 1):\n            family_info = lines[i].split()\n            num_nudgemons = int(family_info[0])\n            nudgemons = []\n            for j in range(1, num_nudgemons * 2, 2):\n                nudgemons.append((family_info[j], int(family_info[j + 1])))\n            families.append((nudgemons, family_info[-1]))\n        num_nudgemons_caught = int(lines[num_families + 1])\n        nudgemons_caught = []\n        for i in range(num_families + 2, num_families + 2 + num_nudgemons_caught):\n            time, nudgemon = lines[i].split()\n            nudgemons_caught.append((int(time), nudgemon))\n        return families, nudgemons_caught\n\n    def calculate_xp(families: list, nudgemons_caught: list) -> int:\n        total_xp = 0\n        egg_activation_time = -1\n        egg_activated = False\n        for time, nudgemon in nudgemons_caught:\n            if egg_activation_time == -1:\n                egg_activation_time = time\n                egg_activated = True\n            if egg_activated and time - egg_activation_time >= 1800:\n                egg_activated = False\n            for family in families:\n                nudgemons, strongest_nudgemon = family\n                if nudgemon == strongest_nudgemon:\n                    continue\n                for prev_nudgemon, candy_cost in nudgemons:\n                    if nudgemon == prev_nudgemon:\n                        total_xp += 500 if egg_activated else 100\n                        break\n        return total_xp\n\n    families, nudgemons_caught = parse_input(stdin)\n    return calculate_xp(families, nudgemons_caught)"
    },
    {
        "number": 3377,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(pegs, point):\n        if point == 1:\n            return True\n        for peg in pegs:\n            if peg in points[point]:\n                return True\n        return False\n\n    def dfs(pegs, step, plan):\n        if step == t:\n            return plan\n        for i in range(1, n + 1):\n            if i not in pegs and is_safe(pegs, i):\n                pegs.add(i)\n                plan.append(f\"{i}\")\n                result = dfs(pegs, step + 1, plan)\n                if result:\n                    return result\n                pegs.remove(i)\n                plan.pop()\n        return None\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    points = {i: set() for i in range(1, n + 1)}\n    for i in range(1, n + 1):\n        p, deps = lines[i].split()\n        points[i + 1].update(map(int, deps.split(',')))\n\n    t = int(lines[n + 1])\n    safe_dry_plan = lines[n + 2:]\n\n    pegs = set()\n    for step in safe_dry_plan:\n        i = int(step)\n        if step.startswith('-'):\n            pegs.remove(i)\n        else:\n            pegs.add(i)\n\n    safe_wet_plan = dfs(pegs, 0, [])\n    if not safe_wet_plan:\n        return \"-1\\n\"\n\n    safe_wet_plan = safe_dry_plan + safe_wet_plan\n    return f\"{len(safe_wet_plan)}\\n\" + \"\\n\".join(safe_wet_plan) + \"\\n\""
    },
    {
        "number": 3378,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_cost(start, end, one_way, round_trip):\n        if start == end:\n            return 0\n        min_cost = float('inf')\n        for i in range(len(one_way)):\n            if one_way[i][0] == start and one_way[i][1] == end:\n                min_cost = min(min_cost, one_way[i][2])\n        for i in range(len(round_trip)):\n            if round_trip[i][0] == start and round_trip[i][1] == end:\n                min_cost = min(min_cost, round_trip[i][2])\n        return min_cost\n\n    def dfs(start, target, one_way, round_trip, cost=0):\n        if start == target:\n            return cost\n        min_cost = float('inf')\n        for i in range(len(one_way)):\n            if one_way[i][0] == start and one_way[i][1] != target:\n                min_cost = min(min_cost, dfs(one_way[i][1], target, one_way, round_trip, cost + one_way[i][2]))\n        for i in range(len(round_trip)):\n            if round_trip[i][0] == start and round_trip[i][1] != target:\n                min_cost = min(min_cost, dfs(round_trip[i][1], target, one_way, round_trip, cost + round_trip[i][2]))\n        return min_cost\n\n    n, d = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    m = int(stdin.readline())\n    one_way = []\n    round_trip = []\n    for _ in range(m):\n        s, d, t, p = stdin.readline().split()\n        s, d, p = map(int, [s, d, p])\n        if t == 'O':\n            one_way.append([s, d, p])\n        else:\n            round_trip.append([s, d, p])\n\n    min_cost = float('inf')\n    for i in range(len(a) - 1):\n        min_cost = min(min_cost, find_min_cost(a[i], a[i + 1], one_way, round_trip))\n\n    return str(min_cost)"
    },
    {
        "number": 3379,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n)]\n    in_degree = [0] * n\n\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        adj_list[x].append(y)\n        in_degree[y] += 1\n\n    queue = []\n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n\n    max_size = len(queue)\n    while queue:\n        node = queue.pop(0)\n        for neighbor in adj_list[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n                max_size = max(max_size, len(queue))\n\n    return str(max_size)"
    },
    {
        "number": 3380,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    probability = 1\n    for i in range(N - 1):\n        probability *= (N - i - 1) / (N - 1)\n    return f\"{1 - probability:.10f}\""
    },
    {
        "number": 3381,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_collinear(p1, p2, p3):\n        return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) == 0\n\n    def is_valid(vertices):\n        for i in range(len(vertices)):\n            p1, p2, p3 = vertices[i - 2], vertices[i - 1], vertices[i]\n            if is_collinear(p1, p2, p3):\n                return False\n        return True\n\n    def generate_polygon(n):\n        vertices = [(0, 0)]\n        for i in range(1, n):\n            x = 40000000 if i % 2 == 0 else 0\n            y = 40000000 if i % 2 == 1 else 0\n            vertices.append((x, y))\n        return vertices\n\n    def main(stdin: str) -> str:\n        n = int(stdin.strip())\n        vertices = generate_polygon(n)\n        while not is_valid(vertices):\n            vertices = generate_polygon(n)\n        return \"\\n\".join(f\"{x} {y}\" for x, y in vertices)\n\n    return main(stdin) "
    },
    {
        "number": 3382,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_int(num):\n        return int(num) == float(num)\n\n    def generate_expressions(base_values, target_value, memo, depth):\n        if depth == 0:\n            return []\n\n        if (base_values, target_value, depth) in memo:\n            return memo[(base_values, target_value, depth)]\n\n        result = []\n        for i in range(len(base_values)):\n            for j in range(i + 1, len(base_values)):\n                a, b = base_values[:i] + base_values[i + 1:j] + base_values[j + 1:], [base_values[i]] + [base_values[j]]\n                for op in ['+', '-', '*', '/']:\n                    if op == '+' or op == '-':\n                        new_base_values = a + b\n                    else:\n                        new_base_values = a + [f'({b[0]}{op}{b[1]})']\n                    if op == '/' and not is_int(eval(''.join(new_base_values))):\n                        continue\n                    new_expression = f'{\"\".join(new_base_values)}'\n                    if eval(new_expression) == target_value:\n                        result.append(new_expression)\n                    else:\n                        result.extend(generate_expressions(new_base_values, target_value, memo, depth - 1))\n\n        memo[(base_values, target_value, depth)] = result\n        return result\n\n    def grade(expression):\n        return expression.count('(') + expression.count('+') + expression.count('-') + expression.count('*') + expression.count('/')\n\n    base_values = list(map(int, stdin.split()))\n    expressions = generate_expressions(base_values, 24, {}, 4)\n    if not expressions:\n        return 'impossible'\n    return min(grade(expression) for expression in expressions)"
    },
    {
        "number": 3383,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(tastiness: int, scoops: int, cost: int) -> bool:\n        return tastiness > 0 and scoops <= n and cost <= a * n + b\n\n    def dfs(scoops: int, flavour: int, tastiness: int, cost: int) -> int:\n        if not is_valid(tastiness, scoops, cost):\n            return float('-inf')\n        if scoops == n:\n            return tastiness / cost\n        next_flavours = [i for i in range(k) if i != flavour]\n        return max(dfs(scoops + 1, j, tastiness + t[flavour] + u[flavour][j], cost + a) for j in next_flavours)\n\n    n, k, a, b = map(int, stdin.split()[0].split())\n    t = list(map(int, stdin.split()[1].split()))\n    u = [[int(x) for x in line.split()] for line in stdin.split()[2:]]\n\n    if not is_valid(sum(t), 1, a + b):\n        return \"0\"\n\n    return f\"{dfs(1, 0, sum(t), a + b):.6f}\""
    },
    {
        "number": 3384,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    n_str = str(n)\n    closest_handsome_numbers = []\n\n    for i in range(len(n_str) - 1):\n        if int(n_str[i]) % 2 == int(n_str[i + 1]) % 2:\n            if i == 0:\n                new_number = int(n_str[i]) + 1\n            else:\n                new_number = int(n_str[:i] + str(int(n_str[i]) + 1))\n\n            if new_number == n:\n                continue\n\n            closest_handsome_numbers.append(new_number)\n\n            if len(closest_handsome_numbers) == 2:\n                break\n\n    if not closest_handsome_numbers:\n        return str(n - 1) + \" \" + str(n + 1)\n    elif len(closest_handsome_numbers) == 1:\n        return str(closest_handsome_numbers[0])\n    else:\n        return str(min(closest_handsome_numbers)) + \" \" + str(max(closest_handsome_numbers))"
    },
    {
        "number": 3385,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    observations = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    MOD = 10**9 + 7\n    dp = [[0, 0] for _ in range(n)]\n    dp[0] = [1, 1] if observations[0][2] == 0 else [0, 1]\n\n    for i in range(1, n):\n        l, r, x = observations[i]\n        prev_l, prev_r = observations[i - 1][0], observations[i - 1][1]\n        if x == 0:\n            dp[i][0] = (dp[i - 1][0] * (prev_l + prev_r + 1) + dp[i - 1][1] * prev_l) % MOD\n            dp[i][1] = (dp[i - 1][1] * (prev_l + prev_r + 1) + dp[i - 1][0] * prev_l) % MOD\n        else:\n            dp[i][0] = (dp[i - 1][0] * prev_l + dp[i - 1][1] * prev_l) % MOD\n            dp[i][1] = (dp[i - 1][1] * prev_l + dp[i - 1][0] * prev_l) % MOD\n\n    return dp[n - 1][0] if observations[n - 1][2] == 0 else dp[n - 1][1]"
    },
    {
        "number": 3386,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M\n\n    def dfs(x, y, visited):\n        if not is_valid(x, y):\n            return False\n        if visited[x][y]:\n            return True\n        visited[x][y] = True\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if d(x, y, nx, ny) in [2, 3] and dfs(nx, ny, visited):\n                return True\n        return False\n\n    def d(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    N, M = map(int, stdin.split())\n    visited = [[False] * M for _ in range(N)]\n\n    for i in range(N):\n        for j in range(M):\n            if dfs(i, j, visited):\n                for i in range(N):\n                    for j in range(M):\n                        if visited[i][j]:\n                            print(i + 1, j + 1)\n                return \"\"\n\n    print(-1)\n    return \"\""
    },
    {
        "number": 3387,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def fair_share(t, d, a, b):\n        y = t * d / sum(d)\n        if a <= y <= b:\n            return y\n        elif y < a:\n            return a\n        else:\n            return b\n\n    def objective(x, y):\n        return sum((x - y) ** 2 / y)\n\n    n, t = map(int, stdin.readline().split())\n    d = []\n    a = []\n    b = []\n\n    for _ in range(n):\n        a_i, b_i, d_i = map(int, stdin.readline().split())\n        d.append(d_i)\n        a.append(a_i)\n        b.append(b_i)\n\n    x = [fair_share(t, d[i], a[i], b[i]) for i in range(n)]\n    y = [t * d[i] / sum(d) for i in range(n)]\n\n    if objective(x, y) <= 10 ** -6:\n        return \"\\n\".join(str(x_i) for x_i in x)\n    else:\n        raise ValueError(\"No valid solution found\")"
    },
    {
        "number": 3388,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, scores = map(int, stdin.split())\n    scores = sorted(scores, reverse=True)\n    lead = scores.index(scores[0])\n    return str(lead)"
    },
    {
        "number": 3389,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    video_types = stdin.readline()\n\n    # Count the occurrences of each video type\n    type_counts = [video_types.count(chr(i + 97)) for i in range(k)]\n\n    # Calculate the minimum number of clicks needed\n    min_clicks = 0\n    for count in type_counts:\n        min_clicks += count - 1\n\n    return str(min_clicks)"
    },
    {
        "number": 3390,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj_list = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        adj_list[a].append(b)\n\n    visited = [False] * (n + 1)\n    max_length = 0\n\n    def dfs(node, length):\n        nonlocal max_length\n        if visited[node]:\n            return\n        visited[node] = True\n        max_length = max(max_length, length)\n        for neighbor in adj_list[node]:\n            dfs(neighbor, length + 1)\n        visited[node] = False\n\n    for i in range(1, n + 1):\n        dfs(i, 1)\n        max_length = max(max_length, 1)\n\n    return str(max_length)"
    },
    {
        "number": 3391,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def find_min_square(houses, a, b):\n        min_side = float(\"inf\")\n        for i in range(len(houses)):\n            for j in range(i + 1, len(houses)):\n                if a <= i < b - 1 and a <= j < b - 1:\n                    side = distance(houses[i], houses[j])\n                    min_side = min(min_side, side)\n        return min_side\n\n    n, q = map(int, stdin.readline().split())\n    houses = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    requests = [tuple(map(int, stdin.readline().split())) for _ in range(q)]\n\n    return \"\\n\".join(str(find_min_square(houses, a, b)) for a, b in requests)"
    },
    {
        "number": 3392,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(matrix, start_i, start_j, visited):\n        queue = [(start_i, start_j)]\n        visited[start_i][start_j] = True\n        max_height = matrix[start_i][start_j]\n\n        while queue:\n            i, j = queue.pop(0)\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < N and 0 <= y < N and not visited[x][y]:\n                    visited[x][y] = True\n                    max_height = max(max_height, matrix[x][y])\n                    queue.append((x, y))\n\n        return max_height\n\n    N = int(stdin.readline().strip())\n    matrix = [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n    speeds = [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n\n    max_height = 0\n    visited = [[False] * N for _ in range(N)]\n\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                max_height = max(max_height, bfs(matrix, i, j, visited))\n\n    return str(max_height)"
    },
    {
        "number": 3393,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    courses = []\n    for _ in range(n):\n        name, difficulty = input().split()\n        courses.append((name, int(difficulty)))\n\n    courses.sort(key=lambda x: x[1])\n\n    total_difficulty = 0\n    level_ii = set()\n    for i in range(n):\n        if courses[i][0].endswith('2'):\n            level_ii.add(courses[i][0][:-1])\n\n    for i in range(n):\n        if not courses[i][0].endswith('2') and courses[i][0] not in level_ii:\n            total_difficulty += courses[i][1]\n            if k == 1:\n                break\n            k -= 1\n\n    return str(total_difficulty)"
    },
    {
        "number": 3394,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start):\n        n = len(graph)\n        visited = [False] * n\n        weights = [float('inf')] * n\n        weights[start] = 0\n        queue = [(0, start)]\n\n        while queue:\n            weight, node = heapq.heappop(queue)\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, dist in graph[node]:\n                    new_weight = weight + dist\n                    if new_weight < weights[neighbor]:\n                        weights[neighbor] = new_weight\n                        heapq.heappush(queue, (new_weight, neighbor))\n\n        return weights\n\n    def find_path(graph, start, end):\n        visited = [False] * len(graph)\n        queue = [(start, [])]\n\n        while queue:\n            node, path = queue.pop(0)\n            if node not in visited:\n                visited.append(node)\n                path.append(node)\n                if node == end:\n                    return path\n                for neighbor, dist in graph[node]:\n                    queue.append((neighbor, path))\n\n        return None\n\n    def find_max_wait_time(n, m, roads, orders):\n        graph = [[] for _ in range(n + 1)]\n        for u, v, d in roads:\n            graph[u].append((v, d))\n            graph[v].append((u, d))\n\n        dijkstra_result = dijkstra(graph, 1)\n        max_wait_time = 0\n\n        for s, u, t in orders:\n            path = find_path(graph, u, 1)\n            time_to_pizzeria = dijkstra_result[u]\n            time_to_customer = sum(graph[node][0][1] for node in path)\n            max_wait_time = max(max_wait_time, t + time_to_pizzeria + time_to_customer - s)\n\n        return max_wait_time\n\n    n, m, k = map(int, stdin.readline().split())\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n    orders = [tuple(map(int, stdin.readline().split())) for _ in range(k)]\n\n    return str(find_max_wait_time(n, m, roads, orders))"
    },
    {
        "number": 3395,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start, target, graph):\n        visited = [False] * (n + 1)\n        queue = [(start, 0)]\n        visited[start] = True\n\n        while queue:\n            node, dist = queue.pop(0)\n            if node == target:\n                return dist\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    queue.append((neighbor, dist + 1))\n                    visited[neighbor] = True\n        return -1\n\n    stdin_list = stdin.split('\\n')\n    n, m, k = map(int, stdin_list[0].split())\n    iron_ore_cells = set(map(int, stdin_list[1].split()))\n    coal_cells = set(map(int, stdin_list[2].split()))\n\n    graph = [[] for _ in range(n + 1)]\n    for i in range(3, 3 + n):\n        a, *b = map(int, stdin_list[i].split())\n        for j in range(a):\n            graph[b[j]].append(b[j - a])\n\n    min_settlers = float('inf')\n\n    for ore_cell in iron_ore_cells:\n        for coal_cell in coal_cells:\n            if ore_cell == 1 or coal_cell == 1:\n                continue\n            dist_ore = bfs(1, ore_cell, graph)\n            dist_coal = bfs(1, coal_cell, graph)\n            if dist_ore != -1 and dist_coal != -1:\n                min_settlers = min(min_settlers, dist_ore + dist_coal)\n\n    return str(min_settlers) if min_settlers != float('inf') else \"impossible\""
    },
    {
        "number": 3396,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    posts = [(int(x), int(y)) for x, y in [line.split() for line in stdin.split('\\n')[1:n+1]]]\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            distance = ((posts[i][0] - posts[j][0])**2 + (posts[i][1] - posts[j][1])**2)**0.5\n            max_distance = max(max_distance, distance)\n\n    return '{:.2f}'.format(max_distance * 2)"
    },
    {
        "number": 3397,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    dog_times = [list(map(int, stdin.readline().split())) for _ in range(N)]\n\n    dog_times.sort(key=lambda x: min(x))\n    total_time = 0\n    for i in range(N):\n        bowl_index = dog_times[i].index(min(dog_times[i]))\n        total_time += min(dog_times[i])\n        for j in range(N):\n            if j != i:\n                dog_times[j][bowl_index] = max(dog_times[j][bowl_index], dog_times[i][bowl_index])\n\n    return str(total_time)"
    },
    {
        "number": 3398,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_r, n_c, n, m, *coords = list(map(int, stdin.split()))\n    files_to_delete = coords[:n * 2]\n    files_to_keep = coords[n * 2:]\n\n    def can_delete_rect(top_left: tuple, bottom_right: tuple) -> bool:\n        for file in files_to_delete:\n            if top_left[0] <= file[0] < bottom_right[0] and top_left[1] <= file[1] < bottom_right[1]:\n                if file not in files_to_keep:\n                    return True\n        return False\n\n    def min_moves_to_delete(top_left: tuple, bottom_right: tuple) -> int:\n        if not can_delete_rect(top_left, bottom_right):\n            return float('inf')\n        moves = 0\n        for file in files_to_delete:\n            if file not in files_to_keep and (file[0] < top_left[0] or file[0] >= bottom_right[0] or file[1] < top_left[1] or file[1] >= bottom_right[1]):\n                moves += 1\n        return moves\n\n    min_moves = float('inf')\n    for i in range(n_r):\n        for j in range(n_c):\n            for k in range(i, n_r):\n                for l in range(j, n_c):\n                    min_moves = min(min_moves, min_moves_to_delete((i, j), (k, l)))\n\n    return str(min_moves)"
    },
    {
        "number": 3399,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    arwegian = []\n    banish = []\n    cwedish = []\n\n    for i in range(n):\n        row = stdin.readline().strip()\n        for j in range(m):\n            if row[j] == \"1\":\n                arwegian.append((i, j))\n                banish.append((i, j))\n                cwedish.append((i, j))\n            elif row[j] == \"2\":\n                arwegian.append((i, j))\n                banish.append((i, j))\n                cwedish.append((i, j))\n\n    def is_connected(language, n, m):\n        visited = set()\n        stack = [language[0]]\n        while stack:\n            cell = stack.pop()\n            if cell not in visited:\n                visited.add(cell)\n                i, j = cell\n                if i > 0 and language[n * (i - 1) + j] not in visited:\n                    stack.append((i - 1, j))\n                if i < n - 1 and language[n * (i + 1) + j] not in visited:\n                    stack.append((i + 1, j))\n                if j > 0 and language[n * i + j - 1] not in visited:\n                    stack.append((i, j - 1))\n                if j < m - 1 and language[n * i + j + 1] not in visited:\n                    stack.append((i, j + 1))\n        return len(visited) == len(language)\n\n    if not (is_connected(arwegian, n, m) and is_connected(banish, n, m) and is_connected(cwedish, n, m)):\n        return \"impossible\"\n\n    output = \"\"\n    for i in range(n):\n        for j in range(m):\n            if (i, j) in arwegian:\n                output += \"A\"\n            else:\n                output += \".\"\n        output += \"\\n\"\n    output += \"\\n\"\n\n    for i in range(n):\n        for j in range(m):\n            if (i, j) in banish:\n                output += \"B\"\n            else:\n                output += \".\"\n        output += \"\\n\"\n    output += \"\\n\"\n\n    for i in range(n):\n        for j in range(m):\n            if (i, j) in cwedish:\n                output += \"C\"\n            else:\n                output += \".\"\n        output += \"\\n\"\n\n    return output"
    },
    {
        "number": 3400,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, A, R, T = map(int, stdin.split()[:4])\n    trips = []\n    for _ in range(T):\n        d, p, *a = map(int, stdin.split())\n        trips.append((d, p, a))\n\n    # Create adjacency matrix\n    adj_matrix = [[0] * N for _ in range(N)]\n    for d, p, a in trips:\n        for i in range(p - 1):\n            u, v = a[i], a[i + 1]\n            adj_matrix[u - 1][v - 1] = d // p\n            adj_matrix[v - 1][u - 1] = d // p\n\n    # Run Dijkstra's algorithm\n    visited = [False] * N\n    distances = [float('inf')] * N\n    distances[A - 1] = 0\n    min_heap = [(0, A)]\n\n    while min_heap:\n        d, u = heapq.heappop(min_heap)\n        if not visited[u - 1]:\n            visited[u - 1] = True\n            for v in range(N):\n                if not visited[v] and adj_matrix[u - 1][v] != 0:\n                    new_distance = d + adj_matrix[u - 1][v]\n                    if new_distance < distances[v]:\n                        distances[v] = new_distance\n                        heapq.heappush(min_heap, (new_distance, v + 1))\n\n    return str(distances[R - 1])"
    },
    {
        "number": 3401,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def find_path(start, end, max_length):\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            node, length = queue.pop(0)\n            if node == end:\n                return length\n            if node not in visited and length + hill_heights[node] <= max_length:\n                visited.add(node)\n                for neighbor in hill_map[node]:\n                    if neighbor not in visited:\n                        queue.append((neighbor, length + distance(hill_coords[node][0], hill_coords[node][1], hill_coords[neighbor][0], hill_coords[neighbor][1])))\n        return None\n\n    stdin = stdin.split('\\n')\n    n, s, t, q = map(int, stdin[0].split())\n    hill_coords = [(0, 0)] * (n + 1)\n    hill_heights = [0] * (n + 1)\n    hill_map = [[] for _ in range(n + 1)]\n    spring_hills = [0] * s\n    town_hills = [0] * t\n\n    for i in range(1, n + 1):\n        x, y, h = map(int, stdin[i].split())\n        hill_coords[i] = (x, y)\n        hill_heights[i] = h\n\n    for i in range(s):\n        spring_hills[i] = int(stdin[n + i + 1])\n\n    for i in range(t):\n        town_hills[i] = int(stdin[n + s + i + 1])\n\n    total_length = 0\n    for i in range(t):\n        path_length = find_path(town_hills[i], spring_hills[i], q)\n        if path_length is None:\n            return 'IMPOSSIBLE'\n        total_length += path_length\n\n    return round(total_length, 6)"
    },
    {
        "number": 3402,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    S = lines[0]\n    T = lines[1].split() + lines[2].split()\n    K = int(lines[3])\n    M = int(lines[4])\n    m = list(map(int, lines[5].split()))\n\n    def f(s: str) -> str:\n        result = ''\n        for char in s:\n            result += T[ord(char) - ord('a')]\n        return result\n\n    P = f(S)\n    for _ in range(K - 1):\n        P = f(P)\n\n    result = ''\n    for i in range(M):\n        result += P[m[i] - 1]\n\n    return result"
    },
    {
        "number": 3403,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    words = [stdin.readline().strip() for _ in range(n)]\n    q = int(stdin.readline().strip())\n    queries = [stdin.readline().strip() for _ in range(q)]\n\n    def lcp(a: str, b: str) -> int:\n        length = min(len(a), len(b))\n        result = 0\n        for i in range(length):\n            if a[i] != b[i]:\n                break\n            result += 1\n        return result\n\n    def search_word(word: str) -> int:\n        steps = 0\n        for i, db_word in enumerate(words):\n            steps += lcp(word, db_word)\n            if db_word == word:\n                return steps\n            steps += max(len(word), len(db_word)) - lcp(word, db_word)\n        return steps\n\n    return [str(search_word(query)) for query in queries]"
    },
    {
        "number": 3404,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X = map(int, stdin.readline().split())\n    encrypted_message = stdin.readline().strip()\n\n    def f(x):\n        return (33 * x + 1) % (2 ** 20)\n\n    one_time_pad = \"\"\n    for i in range(1, X + 1):\n        for j in range(i):\n            one_time_pad += str(f(i + j))\n\n    one_time_pad = int(one_time_pad, 10)\n    one_time_pad = format(one_time_pad, f\"0{N}\")\n\n    decrypted_message = \"\"\n    for i, letter in enumerate(encrypted_message):\n        if letter == \" \":\n            decrypted_message += \" \"\n            continue\n        shift = int(one_time_pad[i], 27)\n        decrypted_letter = (ord(letter) - 65 + shift) % 27 + 65\n        decrypted_message += chr(decrypted_letter)\n\n    return decrypted_message"
    },
    {
        "number": 3405,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = float(stdin)\n    result = []\n\n    for i in range(1, 10**7):\n        original_number = i\n        moved_digits = int(str(i)[:1])\n        remaining_digits = int(str(i)[1:])\n\n        if remaining_digits * X == original_number + moved_digits * (10 ** (len(str(original_number)) - 1)):\n            result.append(i)\n\n    if not result:\n        return \"No solution\"\n    else:\n        return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3406,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_non_degenerate_quadrilateral(a, b, c, d):\n        def is_collinear(p1, p2, p3):\n            return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) == 0\n\n        def is_intersecting(e1, e2):\n            x1, y1, x2, y2 = e1[0][0], e1[0][1], e1[1][0], e1[1][1]\n            x3, y3, x4, y4 = e2[0][0], e2[0][1], e2[1][0], e2[1][1]\n            denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n            if denom == 0:\n                return False\n            ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom\n            ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom\n            return 0 <= ua <= 1 and 0 <= ub <= 1\n\n        for e1 in [(a, b), (b, c), (c, d), (d, a)]:\n            for e2 in [(a, b), (b, c), (c, d), (d, a)]:\n                if e1 != e2 and is_collinear(e1[0], e1[1], e2[0]) and is_collinear(e1[0], e1[1], e2[1]):\n                    return False\n                if is_intersecting(e1, e2):\n                    return False\n        return True\n\n    def is_inside_or_on_border(castle, quadrilateral):\n        a, b, c, d = quadrilateral\n        x1, y1 = a\n        x2, y2 = b\n        x3, y3 = c\n        x4, y4 = d\n        x, y = castle\n        return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) * (x - x1) + \\\n               (x2 * (y1 - y3) + x3 * (y2 - x1) + x1 * (y3 - y2)) * (y - y1) <= 0 and \\\n               (x3 * (y2 - y4) + x4 * (y1 - y3) + x1 * (y3 - y2)) * (x - x2) + \\\n               (x4 * (y3 - y1) + x1 * (y4 - y2) + x2 * (y1 - y3)) * (y - y2) <= 0\n\n    N = int(stdin.readline().strip())\n    nazi_troops = [tuple(map(int, stdin.readline().strip().split())) for _ in range(N)]\n    S = int(stdin.readline().strip())\n    castles = [tuple(map(int, stdin.readline().strip().split())) for _ in range(S)]\n\n    in_danger_castles = 0\n    for i in range(S):\n        for j in range(i + 1, S):\n            for k in range(j + 1, S):\n                for l in range(k + 1, S):\n                    if is_non_degenerate_quadrilateral(castles[i], castles[j], castles[k], castles[l]):\n                        for castle in castles:\n                            if is_inside_or_on_border(castle, [castles[i], castles[j], castles[k], castles[l]]):\n                                in_danger_castles += 1\n                                break\n\n    return str(in_danger_castles)"
    },
    {
        "number": 3407,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def euclidean_distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def find_closest_point(x, y, points):\n        min_distance = float('inf')\n        closest_point = None\n        for i, (px, py) in enumerate(points):\n            distance = euclidean_distance(x, y, px, py)\n            if distance < min_distance:\n                min_distance = distance\n                closest_point = i\n        return closest_point\n\n    def is_valid_solution(points, edges):\n        for a, b in edges:\n            if euclidean_distance(*points[a - 1], *points[b - 1]) != 1:\n                return False\n        return True\n\n    def generate_valid_solution(n, edges):\n        points = [(0, 0)] * n\n        points[0] = (0, 0)\n\n        for i in range(1, n):\n            closest_point = find_closest_point(0, 0, points[:i])\n            x, y = points[closest_point]\n            points[i] = (x + 1, y)\n\n        if is_valid_solution(points, edges):\n            return points\n\n        for i in range(1, n):\n            closest_point = find_closest_point(0, 0, points[:i])\n            x, y = points[closest_point]\n            points[i] = (x, y + 1)\n\n        if is_valid_solution(points, edges):\n            return points\n\n        for i in range(1, n):\n            closest_point = find_closest_point(0, 0, points[:i])\n            x, y = points[closest_point]\n            points[i] = (x - 1, y)\n\n        if is_valid_solution(points, edges):\n            return points\n\n        for i in range(1, n):\n            closest_point = find_closest_point(0, 0, points[:i])\n            x, y = points[closest_point]\n            points[i] = (x, y - 1)\n\n        if is_valid_solution(points, edges):\n            return points\n\n        return None\n\n    n, *edges = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    points = generate_valid_solution(n, edges)\n\n    if points:\n        return '\\n'.join(f'{x:.8f} {y:.8f}' for x, y in points)\n    else:\n        return 'No valid solution found'"
    },
    {
        "number": 3408,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, Q = map(int, lines[0].split())\n    words = set(lines[1:N+1])\n    patterns = lines[N+1:]\n\n    def is_covered(word: str, pattern: str) -> bool:\n        if len(word) != len(pattern):\n            return False\n        for i in range(len(word)):\n            if pattern[i] == '*':\n                continue\n            if pattern[i] != word[i]:\n                return False\n        return True\n\n    def count_covered(pattern: str) -> int:\n        count = 0\n        for word in words:\n            if is_covered(word, pattern):\n                count += 1\n        return count\n\n    result = []\n    for pattern in patterns:\n        result.append(count_covered(pattern))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3409,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    r, c = map(int, lines[0].split())\n    start_board = [list(line) for line in lines[1:1+r]]\n    target_board = [list(line) for line in lines[1+r:1+2*r]]\n\n    def hammer(board: list, row: int, col: int) -> None:\n        if board[row][col] == 'O':\n            board[row] = ['X' if i == col else 'O' for i in range(c)]\n            for i in range(r):\n                if i != row:\n                    board[i][col] = 'O' if board[i][col] == 'X' else 'X'\n\n    def is_target(board: list, target: list) -> bool:\n        return all(board[i] == target[i] for i in range(r))\n\n    def dfs(board: list, target: list) -> bool:\n        for i in range(r):\n            for j in range(c):\n                if board[i][j] == 'O':\n                    hammer(board, i, j)\n                    if is_target(board, target):\n                        return True\n                    if dfs(board, target):\n                        return True\n                    # backtrack\n                    hammer(board, i, j)\n        return False\n\n    return '1' if dfs(start_board, target_board) else '0'"
    },
    {
        "number": 3410,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def area(x1, y1, x2, y2, x3, y3, x4, y4):\n        return abs((x1 * (y2 - y3) + x2 * (y3 - y4) + x3 * (y4 - y1) + x4 * (y1 - y2)) / 2.0)\n\n    def is_valid(a, b, c, d, used_points):\n        for i in range(len(used_points)):\n            for j in range(i + 1, len(used_points)):\n                if (used_points[i][0], used_points[j][0]) == (a, b) and (used_points[i][1], used_points[j][1]) == (c, d):\n                    return False\n        return True\n\n    def play_game(points, used_points, player, score):\n        if player == 1:\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    for k in range(j + 1, len(points)):\n                        for l in range(k + 1, len(points)):\n                            if is_valid(points[i][0], points[j][0], points[k][0], points[l][0], used_points) and is_valid(points[i][1], points[j][1], points[k][1], points[l][1], used_points):\n                                new_used_points = used_points + [(points[i][0], points[j][0]), (points[j][0], points[k][0]), (points[k][0], points[l][0]), (points[l][0], points[i][0])]\n                                new_used_points = new_used_points + [(points[i][1], points[j][1]), (points[j][1], points[k][1]), (points[k][1], points[l][1]), (points[l][1], points[i][1])]\n                                new_score = score + 2 * area(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1], points[l][0], points[l][1])\n                                if new_score % 1000003 == 0:\n                                    return new_score\n                                new_score = play_game(points, new_used_points, 2, new_score)\n        else:\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    for k in range(j + 1, len(points)):\n                        for l in range(k + 1, len(points)):\n                            if is_valid(points[i][0], points[j][0], points[k][0], points[l][0], used_points) and is_valid(points[i][1], points[j][1], points[k][1], points[l][1], used_points):\n                                new_used_points = used_points + [(points[i][0], points[j][0]), (points[j][0], points[k][0]), (points[k][0], points[l][0]), (points[l][0], points[i][0])]\n                                new_used_points = new_used_points + [(points[i][1], points[j][1]), (points[j][1], points[k][1]), (points[k][1], points[l][1]), (points[l][1], points[i][1])]\n                                new_score = score + 2 * area(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1], points[l][0], points[l][1])\n                                if new_score % 1000003 == 0:\n                                    return new_score\n                                new_score = play_game("
    },
    {
        "number": 3411,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, r, scores = map(int, stdin.split())\n    scores = sorted(scores, key=lambda x: abs(x))\n    time = 0\n    for i in range(1, len(scores), 2):\n        time += c + r\n        time += abs(scores[i - 1]) + abs(scores[i])\n        scores[i - 1] = -scores[i - 1]\n        scores[i] = -scores[i]\n    return str(time)"
    },
    {
        "number": 3412,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def shortest_path(x1, y1, x2, y2, x_stations, y_stations, v_walk, v_bike):\n        min_time = float('inf')\n        for x_station, y_station in zip(x_stations, y_stations):\n            d1 = distance(x1, y1, x_station, y_station)\n            d2 = distance(x_station, y_station, x2, y2)\n            min_time = min(min_time, d1 / v_walk + d2 / v_bike)\n        return min_time\n\n    input_list = stdin.split('\\n')\n    v_walk, v_bike = map(int, input_list[0].split())\n    x1, y1, x2, y2 = map(int, input_list[1].split())\n    x_G, y_G = map(int, input_list[2].split())\n    x_D, y_D = map(int, input_list[3].split())\n    n = int(input_list[4])\n    x_stations = []\n    y_stations = []\n    for i in range(n):\n        x_station, y_station = map(int, input_list[5 + i].split())\n        x_stations.append(x_station)\n        y_stations.append(y_station)\n\n    min_time = min(distance(x_G, y_G, x_D, y_D) / v_walk,\n                     distance(x_G, y_G, x1, y1) / v_walk + distance(x1, y1, x2, y2) / v_bike + distance(x2, y2, x_D, y_D) / v_walk,\n                     distance(x_G, y_G, x1, y1) / v_walk + distance(x1, y1, x2, y2) / v_bike + distance(x2, y2, x_D, y_D) / v_bike,\n                     shortest_path(x_G, y_G, x_D, y_D, x_stations, y_stations, v_walk, v_bike))\n\n    return f\"{min_time:.10f}\""
    },
    {
        "number": 3413,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    parties = list(map(int, stdin.readline().split()))\n    adj_list = [[] for _ in range(n)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        adj_list[a - 1].append(b - 1)\n        adj_list[b - 1].append(a - 1)\n\n    def bfs(start, target_party):\n        visited = [False] * n\n        queue = [(start, target_party)]\n        visited[start] = True\n\n        while queue:\n            node, party = queue.pop(0)\n            for neighbor in adj_list[node]:\n                if not visited[neighbor]:\n                    if parties[neighbor] == party:\n                        visited[neighbor] = True\n                        queue.append((neighbor, party))\n                    elif parties[neighbor] == 1 - party:\n                        return False\n        return True\n\n    months = 0\n    while not all(party == parties[0] for party in parties):\n        for i in range(n):\n            if not bfs(i, parties[i]):\n                parties[i] = 1 - parties[i]\n                months += 1\n                break\n\n    return str(months)"
    },
    {
        "number": 3414,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def atan2(y, x):\n        if x == 0:\n            return math.pi / 2 if y > 0 else -math.pi / 2\n        elif y == 0:\n            return 0 if x > 0 else math.pi\n        else:\n            angle = math.atan(y / x)\n            if x < 0:\n                angle += math.pi\n            if y < 0:\n                angle += math.pi * 2 if x > 0 else -math.pi * 2\n            return angle\n\n    def eulerian_circuit(graph):\n        circuit = []\n        for node in graph:\n            if len(node) > 1:\n                next_node = node.pop()\n                circuit.append((next_node, len(node)))\n        return circuit\n\n    def calculate_turning(circuit, nodes):\n        total_turning = 0\n        for i in range(len(circuit) - 1):\n            node1, node2 = circuit[i][0], circuit[i + 1][0]\n            turning = atan2(nodes[node2][1] - nodes[node1][1], nodes[node2][0] - nodes[node1][0])\n            total_turning += abs(turning)\n        return total_turning\n\n    def main(stdin: str) -> str:\n        lines = stdin.strip().split('\\n')\n        N, M = map(int, lines[0].split())\n        nodes = [(int(x), int(y)) for x, y in (line.split() for line in lines[1:N + 1])]\n        graph = [[] for _ in range(N)]\n        for line in lines[N + 1:]:\n            i, j = map(int, line.split())\n            graph[i].append(j)\n            graph[j].append(i)\n\n        circuit = eulerian_circuit(graph)\n        total_turning = calculate_turning(circuit, nodes)\n        return f\"{total_turning:.6f}\"\n\n    return main(stdin) "
    },
    {
        "number": 3415,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"1 2 3\"\n    else:\n        left_subtree = [str(i) for i in range(1, 2 ** (n - 1))]\n        right_subtree = [str(i) for i in range(2 ** (n - 1) + 1, 2 ** n)]\n        root = str(2 ** n - 1)\n        return \" \".join([root] + left_subtree + right_subtree)"
    },
    {
        "number": 3416,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m = map(int, stdin.readline().split())\n    train_lines = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    # Create adjacency list\n    adj_list = [[] for _ in range(n + 1)]\n    for a, b in train_lines:\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    # Initialize visited and airport_cities\n    visited = [False] * (n + 1)\n    airport_cities = set()\n\n    # DFS function\n    def dfs(city, flights):\n        visited[city] = True\n        if flights == 0:\n            airport_cities.add(city)\n        for neighbor in adj_list[city]:\n            if not visited[neighbor]:\n                dfs(neighbor, flights - 1)\n\n    # Find minimum number of flights and airport cities\n    min_flights = float('inf')\n    for start_city in range(1, n + 1):\n        visited = [False] * (n + 1)\n        dfs(start_city, m)\n        if visited.count(True) == n + 1:\n            min_flights = min(min_flights, m)\n            airport_cities.add(start_city)\n\n    # Output\n    return f\"{min_flights}\\n{' '.join(map(str, sorted(airport_cities)))}\\n\""
    },
    {
        "number": 3417,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    graph = [[0] * n for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.split()[2:4])\n        graph[a - 1][b - 1] = 1\n        graph[b - 1][a - 1] = 1\n\n    def dfs(v, visited):\n        visited[v] = True\n        for i in range(n):\n            if graph[v][i] and not visited[i]:\n                dfs(i, visited)\n\n    max_size = 0\n    for i in range(n):\n        visited = [False] * n\n        dfs(i, visited)\n        size = sum(visited)\n        max_size = max(max_size, size)\n\n    return str(n - max_size)"
    },
    {
        "number": 3418,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    supply = 0\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            if i % j == 0:\n                supply += 1\n    return str(supply)"
    },
    {
        "number": 3419,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s1, s2 = map(int, stdin.split())\n    times = list(map(int, input().split()))\n\n    times.sort()\n\n    served_customers = 0\n    counter1_time = 0\n    counter2_time = 0\n\n    for time in times:\n        if counter1_time + time <= s1:\n            counter1_time += time\n            served_customers += 1\n        elif counter2_time + time <= s2:\n            counter2_time += time\n            served_customers += 1\n        else:\n            break\n\n    return str(served_customers)"
    },
    {
        "number": 3420,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split('\\n')\n    B, G = map(int, lines[0].split())\n    boys = {}\n    girls = {}\n    for i in range(B):\n        name, N = lines[i + 1].split()\n        boys[name] = set(lines[i + 1].split()[1:])\n    for i in range(G):\n        name, N = lines[i + B + 1].split()\n        girls[name] = set(lines[i + B + 1].split()[1:])\n\n    # Find the minimum number of presentations\n    P = 0\n    while boys or girls:\n        P += 1\n        presenters = set()\n        for boy in boys:\n            for girl in girls:\n                if boys[boy] & girls[girl]:\n                    presenters.add(boy)\n                    presenters.add(girl)\n                    break\n            if presenters:\n                break\n        for presenter in presenters:\n            if presenter in boys:\n                del boys[presenter]\n            else:\n                del girls[presenter]\n\n    return str(P)"
    },
    {
        "number": 3421,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.readline().strip())\n    results = stdin.readline().strip()\n\n    max_success_rate = 0\n    max_success_rate_start = 0\n    max_success_rate_length = 0\n\n    success_count = 0\n    current_start = 0\n\n    for i, result in enumerate(results):\n        if result == '1':\n            success_count += 1\n\n        if i - current_start + 1 >= k:\n            current_success_rate = success_count / (i - current_start + 1)\n\n            if current_success_rate > max_success_rate:\n                max_success_rate = current_success_rate\n                max_success_rate_start = current_start\n                max_success_rate_length = i - current_start + 1\n\n            if results[current_start] == '1':\n                success_count -= 1\n\n            current_start += 1\n\n    return f\"{max_success_rate_start + 1} {max_success_rate_length}\""
    },
    {
        "number": 3422,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(matrix):\n        return [list(reversed(row)) for row in zip(*matrix)]\n\n    def find_pieces(pieces, width, height):\n        for i, piece in enumerate(pieces):\n            if piece[0] == width and piece[1] == height:\n                yield i, piece\n\n    def assemble_map(pieces, width, height):\n        map_pieces = [None] * (width * height)\n        for i in range(width):\n            for j in range(height):\n                index = i * height + j\n                for piece_index, (piece_width, piece_height, piece_grid) in find_pieces(pieces, piece_width, piece_height):\n                    for rotation in range(4):\n                        rotated_grid = rotate(piece_grid)\n                        if i > 0 and map_pieces[(i - 1) * height + j] is not None and map_pieces[(i - 1) * height + j][1] != rotated_grid[0]:\n                            continue\n                        if j > 0 and map_pieces[i * height + j - 1] is not None and map_pieces[i * height + j - 1][2] != rotated_grid[:, -1]:\n                            continue\n                        for y in range(piece_height):\n                            for x in range(piece_width):\n                                map_pieces[index + y * height + x] = (piece_index, rotated_grid[y, x])\n                        break\n                if map_pieces[index] is None:\n                    return None\n        return map_pieces\n\n    def reconstruct_map(map_pieces, width, height):\n        reconstructed_map = [[' ' for _ in range(width)] for _ in range(height)]\n        for i in range(width):\n            for j in range(height):\n                index = i * height + j\n                piece_index, square = map_pieces[index]\n                reconstructed_map[j][i] = str(piece_index + 1)\n        return reconstructed_map\n\n    pieces = []\n    num_pieces = int(stdin.readline().strip())\n    for _ in range(num_pieces):\n        width, height = map(int, stdin.readline().strip().split())\n        grid = [list(map(int, stdin.readline().strip())) for _ in range(height)]\n        pieces.append((width, height, grid))\n\n    width, height = min(p[0] for p in pieces), sum(p[1] for p in pieces)\n    map_pieces = assemble_map(pieces, width, height)\n    if map_pieces is None:\n        return \"No solution exists.\"\n\n    reconstructed_map = reconstruct_map(map_pieces, width, height)\n    output = [f\"{width} {height}\"]\n    output.extend([\"\".join(row) for row in reconstructed_map])\n    output.append(\"-\" * width)\n    output.extend([f\"{''.join(str(p[0] + 1) for p in map_pieces[i * height:i * height + height])}\" for i in range(width)])\n    return \"\\n\".join(output)"
    },
    {
        "number": 3423,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, node, stack):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(graph, visited, neighbor, stack)\n        stack.append(node)\n\n    def topological_sort(graph):\n        visited = [False] * len(graph)\n        stack = []\n        for node in range(len(graph)):\n            if not visited[node]:\n                dfs(graph, visited, node, stack)\n        return stack[::-1]\n\n    def build_dependency_graph(packages):\n        graph = [[] for _ in range(len(packages))]\n        for i, package in enumerate(packages):\n            for dependency in package[1]:\n                j = packages.index(dependency)\n                graph[i].append(j)\n        return graph\n\n    def is_cyclic(graph, node, visited, rec_stack):\n        visited[node] = True\n        rec_stack[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cyclic(graph, neighbor, visited, rec_stack):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n        rec_stack[node] = False\n        return False\n\n    def has_cycle(graph):\n        visited = [False] * len(graph)\n        rec_stack = [False] * len(graph)\n        for node in range(len(graph)):\n            if not visited[node]:\n                if is_cyclic(graph, node, visited, rec_stack):\n                    return True\n        return False\n\n    packages = []\n    for line in stdin.split('\\n'):\n        if line.isdigit():\n            continue\n        if not line:\n            break\n        name, *dependencies = line.split()\n        packages.append((name, dependencies))\n\n    graph = build_dependency_graph(packages)\n\n    if has_cycle(graph):\n        return 'cannot be ordered'\n    else:\n        order = topological_sort(graph)\n        return '\\n'.join(packages[i][0] for i in order)"
    },
    {
        "number": 3424,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, l = map(int, stdin.split())\n    b = 10\n    while True:\n        digits = []\n        num = y\n        while num > 0:\n            digits.append(num % b)\n            num //= b\n        if all(d < 10 for d in digits) and y // b >= l:\n            return str(b)\n        b += 1"
    },
    {
        "number": 3425,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y, board, queens):\n        for i, j in queens:\n            if i == x or j == y or abs(i - x) == abs(j - y):\n                return False\n        return True\n\n    def place_queens(x, board, queens, count, result):\n        if x == len(board):\n            result[0] = max(result[0], len(queens))\n            result[1] += 1\n            return\n\n        for y in range(len(board[0])):\n            if board[x][y] == \".\" and is_valid(x, y, board, queens):\n                place_queens(x + 1, board, queens + [(x, y)], count, result)\n\n    n, m = map(int, stdin.split()[0].split())\n    board = [list(stdin.split()[i + 1]) for i in range(n)]\n    result = [0, 0]\n    place_queens(0, board, [], n * m, result)\n    return f\"{result[0]} {result[1]}\""
    },
    {
        "number": 3426,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        queue = []\n        visited = [False] * len(graph)\n        weights = [float('inf')] * len(graph)\n        weights[start - 1] = 0\n        queue.append((0, start))\n\n        while queue:\n            current_weight, current_node = heapq.heappop(queue)\n            if current_node == end:\n                return current_weight\n            if not visited[current_node - 1]:\n                visited[current_node - 1] = True\n                for neighbor, weight in graph[current_node - 1]:\n                    new_weight = current_weight + weight\n                    if new_weight < weights[neighbor - 1]:\n                        weights[neighbor - 1] = new_weight\n                        heapq.heappush(queue, (new_weight, neighbor))\n        return -1\n\n    def min_length(graph, start, end):\n        queue = []\n        visited = [False] * len(graph)\n        weights = [float('inf')] * len(graph)\n        weights[start - 1] = 0\n        queue.append((0, start))\n\n        while queue:\n            current_weight, current_node = heapq.heappop(queue)\n            if current_node == end:\n                return current_weight\n            if not visited[current_node - 1]:\n                visited[current_node - 1] = True\n                for neighbor, weight in graph[current_node - 1]:\n                    new_weight = current_weight + weight\n                    if new_weight < weights[neighbor - 1]:\n                        weights[neighbor - 1] = new_weight\n                        heapq.heappush(queue, (new_weight, neighbor))\n        return -1\n\n    def build_graph(tunnels, cables):\n        graph = [[] for _ in range(len(tunnels))]\n        for i, (a, b, l, c) in enumerate(tunnels):\n            if c == 1:\n                graph[a - 1].append((b, l))\n                graph[b - 1].append((a, l))\n        return graph\n\n    def find_unknown_tunnels(tunnels):\n        return [(i, a, b) for i, (a, b, l, c) in enumerate(tunnels) if l == '?']\n\n    def find_min_lengths(graph, tunnels, cables):\n        min_lengths = []\n        for i, a, b in find_unknown_tunnels(tunnels):\n            min_lengths.append(min_length(graph, a, 1) + min_length(graph, b, 1))\n        return min_lengths\n\n    N, M = map(int, stdin.readline().split())\n    tunnels = [list(map(int, stdin.readline().split())) for _ in range(M)]\n    graph = build_graph(tunnels, cables)\n    min_lengths = find_min_lengths(graph, tunnels, cables)\n    return '\\n'.join(map(str, min_lengths))"
    },
    {
        "number": 3427,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected(graph, node1, node2):\n        visited = set()\n        queue = [node1]\n\n        while queue:\n            current = queue.pop(0)\n            if current == node2:\n                return True\n            if current not in visited:\n                visited.add(current)\n                queue.extend(graph[current] - visited)\n\n        return False\n\n    def find_max_secure_rooms(graph, rooms, doors):\n        max_secure_rooms = 0\n\n        for door in doors:\n            if door[0] == -1:\n                start_room = door[1]\n            elif door[1] == -1:\n                start_room = door[0]\n            else:\n                continue\n\n            secure_rooms = set([start_room])\n            queue = [start_room]\n\n            while queue:\n                current = queue.pop(0)\n                for neighbor in graph[current]:\n                    if neighbor not in secure_rooms:\n                        secure_rooms.add(neighbor)\n                        queue.append(neighbor)\n\n            if len(secure_rooms) > max_secure_rooms:\n                max_secure_rooms = len(secure_rooms)\n\n        return max_secure_rooms\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    graph = {i: set() for i in range(N)}\n    doors = []\n\n    for i in range(1, M + 1):\n        u, v = map(int, lines[i].split())\n        graph[u].add(v)\n        graph[v].add(u)\n        if u == -1 or v == -1:\n            doors.append((u, v))\n\n    max_secure_rooms = find_max_secure_rooms(graph, N, doors)\n    return str(max_secure_rooms)"
    },
    {
        "number": 3428,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    f = {}\n    for i in range(n):\n        for j in range(i, n):\n            gcd = a[i]\n            for k in range(i, j):\n                gcd = gcd(gcd, a[k])\n            if j+1 < n:\n                gcd = gcd(gcd, a[j+1])\n            f[gcd] = True\n    return str(len(f))"
    },
    {
        "number": 3429,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_s, y_s, s_s, r_i, r_f, x_a, y_a, s_a = map(int, stdin.split())\n\n    distance = ((x_a - x_s) ** 2 + (y_a - y_s) ** 2) ** 0.5\n\n    if distance <= r_i:\n        return \"0.000000\"\n    elif distance <= r_f:\n        time = (distance - r_f) / s_s\n        damage = time\n        return f\"{damage:.6f}\"\n    else:\n        time = (r_f - r_i) / s_s\n        distance_traveled = s_a * time\n        distance_to_safety = r_i + distance_traveled\n\n        if distance_to_safety <= r_f:\n            time_to_safety = (r_f - distance_to_safety) / s_a\n            time += time_to_safety\n            damage = time\n            return f\"{damage:.6f}\"\n        else:\n            return \"0.000000\""
    },
    {
        "number": 3430,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_transmission_cost(n, cables, m, cables2):\n        total_cost = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                cost = 0\n                for cable in cables:\n                    if i in cable or j in cable:\n                        cost += 1\n                total_cost += cost ** 2\n\n        for i in range(n, n + m):\n            for j in range(i + 1, n + m):\n                cost = 0\n                for cable in cables2:\n                    if i in cable or j in cable:\n                        cost += 1\n                total_cost += cost ** 2\n\n        return total_cost\n\n    def get_min_transmission_cost(n, cables, m, cables2):\n        min_cost = float('inf')\n        for i in range(n):\n            for j in range(m):\n                new_cables = cables + [[i, n + j]]\n                cost = get_transmission_cost(n, new_cables, m, cables2)\n                min_cost = min(min_cost, cost)\n        return min_cost\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    cables = [list(map(int, line.split())) for line in lines[1:n]]\n    m = int(lines[n])\n    cables2 = [list(map(int, line.split())) for line in lines[n + 1:n + m]]\n\n    return str(get_min_transmission_cost(n, cables, m, cables2))"
    },
    {
        "number": 3431,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def find_mst(points):\n        edges = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                distance = manhattan_distance(points[i], points[j])\n                edges.append((distance, i, j))\n        edges.sort()\n\n        parent = [i for i in range(len(points))]\n        rank = [0] * len(points)\n\n        def find(x):\n            if x == parent[x]:\n                return x\n            parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            x_root = find(x)\n            y_root = find(y)\n\n            if x_root == y_root:\n                return False\n\n            if rank[x_root] > rank[y_root]:\n                parent[y_root] = x_root\n            elif rank[x_root] < rank[y_root]:\n                parent[x_root] = y_root\n            else:\n                parent[y_root] = x_root\n                rank[x_root] += 1\n            return True\n\n        mst_weight = 0\n        for edge in edges:\n            if union(edge[1], edge[2]):\n                mst_weight += edge[0]\n\n        return mst_weight\n\n    N = int(stdin.readline().strip())\n    points = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    return str(find_mst(points))"
    },
    {
        "number": 3432,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    result = []\n\n    for i in range(1, N + 1):\n        A, B = map(int, lines[i].split())\n        A_sorted = sorted(A)\n        B_sorted = sorted(B)\n        max_sum = 0\n\n        for j in range(len(A_sorted)):\n            max_sum += A_sorted[j] + B_sorted[j]\n\n        result.append(max_sum)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3433,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 0 <= x < R and 0 <= y < C and maze[x][y] != '#'\n\n    def bfs(start_x, start_y):\n        queue = [(start_x, start_y, 0)]\n        visited = set()\n\n        while queue:\n            x, y, time = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n\n            if x in [0, R - 1] or y in [0, C - 1]:\n                return time\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n                if is_valid(new_x, new_y) and (new_x, new_y) not in visited:\n                    queue.append((new_x, new_y, time + 1))\n\n        return \"IMPOSSIBLE\"\n\n    R, C = map(int, stdin.readline().split())\n    maze = [list(stdin.readline().strip()) for _ in range(R)]\n\n    for i in range(R):\n        for j in range(C):\n            if maze[i][j] == 'J':\n                start_x, start_y = i, j\n                break\n\n    return str(bfs(start_x, start_y))"
    },
    {
        "number": 3434,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split('\\n')[0].split())\n    your_minions = list(map(int, stdin.split('\\n')[1].split()))\n    opponent_minions = list(map(int, stdin.split('\\n')[2].split()))\n\n    def calculate_probability(your_minions, opponent_minions, d):\n        total_combinations = 0\n        successful_combinations = 0\n\n        for i in range(1, d + 1):\n            for j in range(1, i + 1):\n                total_combinations += 1\n                if j == opponent_minions[0]:\n                    opponent_minions.pop(0)\n                    if len(opponent_minions) == 0:\n                        successful_combinations += 1\n                        break\n                elif j == your_minions[0]:\n                    your_minions.pop(0)\n                    if len(your_minions) == 0:\n                        successful_combinations += 1\n                        break\n\n        return successful_combinations / total_combinations\n\n    probability = calculate_probability(your_minions, opponent_minions, d)\n    return f\"{probability:.9f}\""
    },
    {
        "number": 3435,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pattern = stdin.split('\\n')\n    n = int(n)\n    pattern = pattern.replace('*', '0')\n    count = 0\n    for i in range(2 ** n):\n        binary = bin(i)[2:].zfill(n)\n        if all(x == '1' or y == '0' for x, y in zip(binary, pattern)):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3436,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def matrix_multiply(a, b):\n        result = [[0] * len(b[0]) for _ in range(len(a))]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] += a[i][k] * b[k][j]\n                    result[i][j] %= MOD\n        return result\n\n    def matrix_power(matrix, n):\n        if n == 1:\n            return matrix\n        if n % 2 == 0:\n            half_power = matrix_power(matrix, n // 2)\n            return matrix_multiply(half_power, half_power)\n        else:\n            return matrix_multiply(matrix, matrix_power(matrix, n - 1))\n\n    def fibonacci_matrix(n):\n        if n == 0:\n            return [[1, 0], [0, 1]]\n        if n == 1:\n            return [[1, 1], [1, 0]]\n        matrix = fibonacci_matrix(n // 2)\n        square = matrix_multiply(matrix, matrix)\n        if n % 2 == 0:\n            return square\n        else:\n            return matrix_multiply(square, [[1, 1], [1, 0]])\n\n    def fibonacci(n):\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        matrix = fibonacci_matrix(n - 1)\n        return matrix[0][0]\n\n    return fibonacci(x + y - 1)"
    },
    {
        "number": 3437,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L1, L2, N = map(int, stdin.split()[:3])\n    tubes = sorted(map(int, stdin.split()[3:]), reverse=True)\n\n    if N < 4:\n        return \"Impossible\"\n\n    max_length = 0\n    for i in range(N - 3):\n        for j in range(i + 1, N - 2):\n            for k in range(j + 1, N - 1):\n                for l in range(k + 1, N):\n                    if tubes[i] + tubes[j] <= L1 and tubes[k] + tubes[l] <= L2:\n                        max_length = max(max_length, tubes[i] + tubes[j] + tubes[k] + tubes[l])\n\n    return max_length if max_length > 0 else \"Impossible\""
    },
    {
        "number": 3438,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    cache_size, num_objects, num_accesses = map(int, stdin.split('\\n')[0].split())\n    accesses = list(map(int, stdin.split('\\n')[1:]))\n\n    # Initialize variables\n    cache = [None] * cache_size\n    cache_count = [0] * num_objects\n    cache_hit = 0\n\n    # Iterate through accesses\n    for access in accesses:\n        if access in cache:\n            cache_hit += 1\n        else:\n            # Evict object if cache is full\n            if None not in cache:\n                min_count = min(cache_count)\n                index = cache_count.index(min_count)\n                cache[cache.index(index)] = None\n            # Add new object to cache\n            cache[cache.index(None)] = access\n            cache_count[access] += 1\n\n    return str(len(accesses) - cache_hit)"
    },
    {
        "number": 3439,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(grid, i, j):\n        queue = [(i, j)]\n        visited = set()\n        volume = 0\n\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n\n            if grid[x][y] < 0:\n                volume += -grid[x][y]\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < h and 0 <= ny < w and (nx, ny) not in visited:\n                        queue.append((nx, ny))\n\n        return volume\n\n    stdin = stdin.split('\\n')\n    h, w = map(int, stdin[0].split())\n    grid = [list(map(int, line.split())) for line in stdin[1:h + 1]]\n    i, j = map(int, stdin[-1].split())\n\n    return str(bfs(grid, i - 1, j - 1))"
    },
    {
        "number": 3440,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, R, F = map(int, stdin.readline().split())\n    flights = [tuple(map(int, stdin.readline().split())) for _ in range(R)]\n    additional_flights = [tuple(map(int, stdin.readline().split())) for _ in range(F)]\n\n    # Create a graph of airports and their connections\n    graph = {i: set() for i in range(1, N + 1)}\n    for a, b, c in flights:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Add additional flights to the graph\n    for a, b, c in additional_flights:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Perform a depth-first search to find all possible paths from Stockholm to other airports\n    def dfs(node, visited):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(neighbor, visited)\n\n    visited = set()\n    dfs(1, visited)\n\n    # Calculate the total cost of the flights for each path\n    min_cost = float('inf')\n    for airport in visited:\n        cost = sum(c for a, b, c in flights if airport in (a, b))\n        min_cost = min(min_cost, cost)\n\n    return str(min_cost)"
    },
    {
        "number": 3441,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_round_trip(towns: List[int]) -> bool:\n        return towns[0] == towns[-1] and len(set(towns)) == len(towns)\n\n    def count_round_trips(towns: List[int], roads: List[Tuple[int, int]]) -> int:\n        count = 0\n        for i in range(len(towns)):\n            for j in range(i + 2, len(towns)):\n                if (towns[i], towns[j]) in roads or (towns[j], towns[i]) in roads:\n                    count += 1\n        return count\n\n    def find_max_roads(n: int, m: int, roads: List[Tuple[int, int]]) -> int:\n        max_roads = 0\n        for i in range(n):\n            for j in range(n):\n                if (i, j) not in roads and (j, i) not in roads:\n                    for k in range(n):\n                        if (j, k) not in roads and (k, j) not in roads:\n                            new_roads = [(i, j), (j, k), (k, i)]\n                            if len(set(new_roads)) == len(new_roads) and count_round_trips([i, j, k], new_roads) == 0:\n                                max_roads = max(max_roads, len(new_roads))\n        return max_roads\n\n    input_data = list(map(int, stdin.split()))\n    n, m = input_data[0], input_data[1]\n    roads = [tuple(map(int, input_data[i + 2].split())) for i in range(m)]\n\n    return str(find_max_roads(n, m, roads))"
    },
    {
        "number": 3442,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    count = 0\n\n    for num in range(X, Y + 1):\n        binary_num = bin(num)[2:]\n        if \"1\" not in binary_num or \"0\" not in binary_num:\n            continue\n\n        A, B = \"\", \"\"\n        for bit in binary_num:\n            if bit == \"1\":\n                A += bit\n                if B:\n                    B = B[:-1]\n            else:\n                B += bit\n                if A:\n                    A = A[:-1]\n\n        if A == B or not A:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3443,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_symmetric(spots):\n        x_coords = [spot[0] for spot in spots]\n        y_coords = [spot[1] for spot in spots]\n\n        x_center = sum(x_coords) / len(spots)\n        y_center = sum(y_coords) / len(spots)\n\n        for i in range(len(spots)):\n            x, y = spots[i]\n            if not (2 * x_center - x == x and 2 * y_center - y == y):\n                return False\n\n        return True\n\n    def is_line_symmetric(spots):\n        x_coords = [spot[0] for spot in spots]\n        y_coords = [spot[1] for spot in spots]\n\n        x_diff = max(x_coords) - min(x_coords)\n        y_diff = max(y_coords) - min(y_coords)\n\n        if x_diff == 0 or y_diff == 0:\n            return True\n\n        gcd_val = gcd(x_diff, y_diff)\n        x_step = x_diff // gcd_val\n        y_step = y_diff // gcd_val\n\n        for i in range(len(spots)):\n            x, y = spots[i]\n            if not ((x + x_step, y + y_step) in spots or (x - x_step, y - y_step) in spots):\n                return False\n\n        return True\n\n    def min_spots_to_symmetry(spots):\n        if is_symmetric(spots):\n            return 0\n\n        if is_line_symmetric(spots):\n            return 0\n\n        min_spots = float('inf')\n        for i in range(len(spots)):\n            for j in range(i + 1, len(spots)):\n                new_spot = ((spots[i][0] + spots[j][0]) / 2, (spots[i][1] + spots[j][1]) / 2)\n                new_spots = spots + [new_spot]\n                min_spots = min(min_spots, min_spots_to_symmetry(new_spots))\n\n        return min_spots + 1\n\n    n = int(stdin.readline().strip())\n    spots = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    return str(min_spots_to_symmetry(spots))"
    },
    {
        "number": 3444,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    graph = [[0] * N for _ in range(N)]\n    pistes = []\n\n    for _ in range(M):\n        a, b, w = map(float, stdin.readline().split())\n        a, b = int(a), int(b)\n        graph[a][b] = w\n        graph[b][a] = w\n        pistes.append((a, b, w))\n\n    dp = [[0] * N for _ in range(N)]\n    dp[0][0] = 1\n\n    for k in range(1, N):\n        for i in range(N - 1, -1, -1):\n            for j in range(i + 1, N):\n                if graph[i][j] == 0:\n                    continue\n\n                dp[i][k] = max(dp[i][k], dp[j][k - 1] * (1 - graph[i][j]))\n                dp[j][k] = max(dp[j][k], dp[i][k - 1] * (1 - graph[i][j]))\n\n    result = []\n    for i in range(N):\n        if dp[i][i] > 0:\n            result.append(dp[i][i])\n        else:\n            result.append(-1)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3445,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def farthest_customer(customers, center):\n        return max(customers, key=lambda customer: distance(customer, center))\n\n    def divide_customers(customers):\n        x_sorted = sorted(customers, key=lambda customer: customer[0])\n        y_sorted = sorted(customers, key=lambda customer: customer[1])\n        center_x = x_sorted[len(x_sorted) // 2]\n        center_y = y_sorted[len(y_sorted) // 2]\n        return farthest_customer(customers, center_x), farthest_customer(customers, center_y)\n\n    def longest_delivery_time(customers):\n        if len(customers) == 1:\n            return 0\n        farthest_x, farthest_y = divide_customers(customers)\n        return max(distance(farthest_x, farthest_y), longest_delivery_time(customers[:len(customers) // 2]), longest_delivery_time(customers[len(customers) // 2:]))\n\n    N = int(stdin.readline().strip())\n    customers = [tuple(map(int, stdin.readline().strip().split())) for _ in range(N)]\n\n    return str(longest_delivery_time(customers))"
    },
    {
        "number": 3446,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_time(components: str, assembly_table: List[List[int]], result_table: List[List[str]]) -> Tuple[int, str]:\n        if not components:\n            return 0, \"\"\n        if len(components) == 1:\n            return assembly_table[ord(components[0]) - ord('a')][ord(components[0]) - ord('a')], components[0]\n        min_time = float('inf')\n        min_result = \"\"\n        for i in range(len(components) - 1):\n            time1, result1 = find_min_time(components[:i + 1], assembly_table, result_table)\n            time2, result2 = find_min_time(components[i + 1:], assembly_table, result_table)\n            time = assembly_table[ord(result1) - ord('a')][ord(result2) - ord('a')] + time1 + time2\n            if time < min_time:\n                min_time = time\n                min_result = result2\n            elif time == min_time:\n                if result2 < min_result:\n                    min_result = result2\n        return min_time, min_result\n\n    def read_input(stdin: str) -> Tuple[List[List[int]], List[List[str]]]:\n        lines = stdin.split('\\n')\n        k = int(lines[0])\n        symbols = lines[1].split()\n        assembly_table = [list(map(int, lines[i + 2].split())) for i in range(k)]\n        result_table = [list(map(lambda x: chr(ord('a') + x), range(k))) for _ in range(k)]\n        return assembly_table, result_table\n\n    assembly_table, result_table = read_input(stdin)\n    output = []\n    for components in stdin.split('\\n')[2:-1]:\n        min_time, min_result = find_min_time(components, assembly_table, result_table)\n        output.append(f\"{min_time}-{min_result}\")\n    return '\\n'.join(output)"
    },
    {
        "number": 3447,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_word(word: str, dictionary: list) -> str:\n        for i, w in enumerate(dictionary):\n            if w.startswith(word):\n                return w\n        return None\n\n    def find_next_word(word: str, dictionary: list, index: int) -> str:\n        for i, w in enumerate(dictionary[index:]):\n            if w.startswith(word):\n                return w\n        return None\n\n    def find_previous_word(word: str, dictionary: list, index: int) -> str:\n        for i, w in enumerate(reversed(dictionary[:index])):\n            if w.startswith(word):\n                return w\n        return None\n\n    def keypresses_for_word(word: str, dictionary: list) -> str:\n        keypresses = \"\"\n        current_word = \"\"\n        index = 0\n        for c in word:\n            if current_word == \"\":\n                current_word = find_word(c, dictionary)\n                if current_word is None:\n                    current_word = c\n                keypresses += str(dictionary.index(current_word) + 2)\n            elif c == current_word[len(current_word) - 1]:\n                continue\n            elif c in current_word:\n                next_word = find_next_word(c, dictionary, dictionary.index(current_word))\n                if next_word is not None:\n                    keypresses += \"U\" + str(dictionary.index(next_word) - dictionary.index(current_word))\n                    current_word = next_word\n                else:\n                    current_word = find_word(c, dictionary)\n                    if current_word is None:\n                        current_word = c\n                    keypresses += \"R\" + str(dictionary.index(current_word) + 2)\n            else:\n                previous_word = find_previous_word(c, dictionary, dictionary.index(current_word))\n                if previous_word is not None:\n                    keypresses += \"D\" + str(dictionary.index(current_word) - dictionary.index(previous_word))\n                    current_word = previous_word\n                else:\n                    current_word = find_word(c, dictionary)\n                    if current_word is None:\n                        current_word = c\n                    keypresses += \"R\" + str(dictionary.index(current_word) + 2)\n        return keypresses\n\n    lines = stdin.split(\"\\n\")\n    dictionary = lines[1:101]\n    words_to_type = lines[101:]\n\n    keypresses = []\n    for word in words_to_type:\n        keypresses.append(keypresses_for_word(word, dictionary))\n\n    return \"\\n\".join(keypresses)"
    },
    {
        "number": 3448,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k >= n:\n        return \"NO\"\n\n    mobi_stations = []\n    vina_stations = []\n\n    for i in range(1, n + 1):\n        if i <= k:\n            mobi_stations.append([i, i + 1])\n            vina_stations.append([i, i + 1])\n        else:\n            for j in range(len(mobi_stations)):\n                if mobi_stations[j][1] < i:\n                    mobi_stations[j][1] = i\n                    break\n            for j in range(len(vina_stations)):\n                if vina_stations[j][0] > i:\n                    vina_stations[j][0] = i\n                    break\n\n    for i in range(len(mobi_stations)):\n        for j in range(i + 1, len(mobi_stations)):\n            if mobi_stations[i][1] > mobi_stations[j][0] and mobi_stations[i][0] < mobi_stations[j][1]:\n                return \"NO\"\n\n    for i in range(len(vina_stations)):\n        for j in range(i + 1, len(vina_stations)):\n            if vina_stations[i][1] > vina_stations[j][0] and vina_stations[i][0] < vina_stations[j][1]:\n                return \"NO\"\n\n    for i in range(len(mobi_stations)):\n        for j in range(len(vina_stations)):\n            if mobi_stations[i][0] < vina_stations[j][0] and mobi_stations[i][1] > vina_stations[j][1]:\n                return \"NO\"\n            if vina_stations[i][0] < mobi_stations[j][0] and vina_stations[i][1] > mobi_stations[j][1]:\n                return \"NO\"\n\n    output = [\"YES\"]\n    for station in mobi_stations:\n        output.append(\" \".join(map(str, station)))\n    for station in vina_stations:\n        output.append(\" \".join(map(str, station)))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3449,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    B = int(lines[0])\n    H = int(lines[1])\n    R, C = map(int, lines[2].split())\n    grid = [list(map(int, line)) for line in lines[3:]]\n\n    def light_level(x, y, z):\n        return sum(grid[r][c] / (x**2 + y**2 + z**2) for r in range(R) for c in range(C))\n\n    total_cost = 0\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] < B:\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if 0 <= r + dr < R and 0 <= c + dc < C and grid[r + dr][c + dc] >= B:\n                            total_cost += 11\n                        elif 0 <= r + dr < R and 0 <= c + dc < C:\n                            total_cost += 43\n\n    return str(total_cost)"
    },
    {
        "number": 3450,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n\n    # Count the trailing zeroes\n    trailing_zeroes = 0\n    while factorial % 10 == 0:\n        trailing_zeroes += 1\n        factorial //= 10\n\n    # Find the 3 digits before the trailing zeroes\n    last_digits = str(factorial)[-3:]\n\n    return last_digits"
    },
    {
        "number": 3451,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    sequence = stdin.readline().strip()\n    costs = [int(stdin.readline().strip()) for _ in range(n)]\n\n    def is_balanced(s: str) -> bool:\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    def min_cost(s: str, k: int) -> int:\n        if k == 0:\n            return 0 if is_balanced(s) else float('inf')\n        if len(s) == 0:\n            return 0\n\n        min_cost = float('inf')\n        for i in range(len(s)):\n            if s[i] == '(':\n                new_s = s[:i] + ')' + s[i + 1:]\n                cost = costs[i] + min_cost(new_s, k - 1)\n                min_cost = min(min_cost, cost)\n            else:\n                new_s = s[:i] + '(' + s[i + 1:]\n                cost = costs[i] + min_cost(new_s, k - 1)\n                min_cost = min(min_cost, cost)\n        return min_cost\n\n    result = min_cost(sequence, k)\n    return '?' if result == float('inf') else result"
    },
    {
        "number": 3452,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_effectively_identical(room1, room2):\n        if len(room1) != len(room2):\n            return False\n        for i in range(len(room1)):\n            if room1[i] != room2[i]:\n                return False\n        return True\n\n    def find_sets(rooms):\n        sets = []\n        for i in range(len(rooms)):\n            for j in range(i + 1, len(rooms)):\n                if is_effectively_identical(rooms[i], rooms[j]):\n                    new_set = set([i + 1, j + 1])\n                    for s in sets:\n                        if s.intersection(new_set):\n                            s.update(new_set)\n                            new_set = s\n                            break\n                    sets.append(new_set)\n        return sets\n\n    def print_sets(sets):\n        if not sets:\n            print(\"none\")\n        else:\n            for s in sets:\n                print(\" \".join(map(str, sorted(s))))\n\n    n = int(stdin.readline().strip())\n    rooms = []\n    for _ in range(n):\n        k, *room = map(int, stdin.readline().strip().split())\n        rooms.append(room)\n\n    sets = find_sets(rooms)\n    print_sets(sets)"
    },
    {
        "number": 3453,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b, c = map(int, stdin.readline().split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    def dfs(start, visited, dist):\n        visited[start] = True\n        for next_node, length in graph[start]:\n            if not visited[next_node]:\n                dist[next_node] = min(dist[next_node], dist[start] + length)\n                dfs(next_node, visited, dist)\n\n    danger_level = [0] * (N + 1)\n    for i in range(1, N + 1):\n        dist = [float('inf')] * (N + 1)\n        visited = [False] * (N + 1)\n        dist[i] = 0\n        dfs(i, visited, dist)\n        for j in range(1, N + 1):\n            if i != j:\n                danger_level[i] += dist[j]\n\n    result = [danger_level[i] % (10**9 + 7) for i in range(1, N + 1)]\n    return ' '.join(map(str, result))"
    },
    {
        "number": 3454,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n\n    def count_ways(M: int, N: int, c: List[int]) -> int:\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\n        dp[0][0] = 1\n\n        for i in range(N):\n            for j in range(M + 1):\n                for k in range(j + 1):\n                    if j - k >= c[i]:\n                        dp[i + 1][j] += dp[i][j - k]\n\n        return dp[N][M]\n\n    X = 100003\n    Y = count_ways(M, N, c)\n    Y_m = Y % 100003\n    result = f\"{X}^{Y // 100003} {Y_m}\"\n\n    return result"
    },
    {
        "number": 3455,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_safety_factor(plan: List[int], sensor_range: int, car_length: int) -> float:\n        safety_factor = float('inf')\n        for distance in plan:\n            if distance < car_length:\n                return 0\n            safety_factor = min(safety_factor, distance - car_length)\n        return safety_factor\n\n    def is_valid_plan(plan: List[int], sensor_range: int, car_length: int) -> bool:\n        for distance in plan:\n            if distance < car_length:\n                return False\n        return True\n\n    def get_plans(cars: List[List[int]], sensor_range: int, car_length: int) -> List[List[int]]:\n        plans = []\n        for i in range(len(cars)):\n            if cars[i][0] == 0 and cars[i][1] == car_length:\n                plan = [cars[j][2] for j in range(len(cars)) if cars[j][0] == i + 1]\n                if is_valid_plan(plan, sensor_range, car_length):\n                    plans.append(plan)\n        return plans\n\n    def get_max_safety_factor(plans: List[List[int]], sensor_range: int, car_length: int) -> float:\n        max_safety_factor = 0\n        for plan in plans:\n            safety_factor = get_safety_factor(plan, sensor_range, car_length)\n            max_safety_factor = max(max_safety_factor, safety_factor)\n        return max_safety_factor\n\n    lines = stdin.split('\\n')\n    N, M, R = map(int, lines[0].split())\n    cars = [list(map(int, lines[i + 1].split())) for i in range(M)]\n    sensor_range = cars[0][2]\n    car_length = cars[0][1]\n\n    plans = get_plans(cars, sensor_range, car_length)\n    if not plans:\n        return 'Impossible'\n\n    max_safety_factor = get_max_safety_factor(plans, sensor_range, car_length)\n    return '{:.6f}'.format(max_safety_factor)"
    },
    {
        "number": 3456,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, stacks = int(stdin.split(\"\\n\")[0]), list(map(int, stdin.split(\"\\n\")[1].split()))\n    stacks.sort()\n    total_crates = sum(stacks)\n    min_actions = 0\n\n    while stacks[-1] != stacks[0]:\n        min_actions += 1\n        new_stacks = [0] * N\n\n        for i in range(N):\n            if stacks[i] > stacks[0]:\n                new_stacks[i] = stacks[i] - stacks[0]\n                stacks[i] = stacks[0]\n\n        for i in range(N):\n            if new_stacks[i] > 0:\n                if i == N - 1:\n                    stacks.append(new_stacks[i])\n                    N += 1\n                else:\n                    stacks[i + 1] += new_stacks[i]\n\n    return str(min_actions)"
    },
    {
        "number": 3457,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, Y = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i + X <= N:\n                dp[i + X][j] += dp[i][j]\n                dp[i + X][j] %= mod\n            if j + Y <= N:\n                dp[i][j + Y] += dp[i][j]\n                dp[i][j + Y] %= mod\n\n    return str(dp[N][N])"
    },
    {
        "number": 3458,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    numbers = list(map(int, stdin.readline().strip().split()))\n\n    def xor_sum(subset):\n        result = 0\n        for number in subset:\n            result ^= number\n        return result\n\n    def max_xor_sum(numbers, index, current_subset, current_xor_sum, best_xor_sum):\n        if index == len(numbers):\n            return max(current_xor_sum, best_xor_sum)\n\n        best_xor_sum = max_xor_sum(numbers, index + 1, current_subset, current_xor_sum, best_xor_sum)\n        current_subset.append(numbers[index])\n        current_xor_sum = xor_sum(current_subset)\n        best_xor_sum = max(current_xor_sum, best_xor_sum)\n        best_xor_sum = max_xor_sum(numbers, index + 1, current_subset, current_xor_sum, best_xor_sum)\n\n        return best_xor_sum\n\n    result = max_xor_sum(numbers, 0, [], 0, 0)\n    return str(result)"
    },
    {
        "number": 3459,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_council_members(residents):\n        council_members = []\n        for resident in residents:\n            if len(resident[2]) == 0:\n                council_members.append((resident[0], None))\n            else:\n                club = resident[2].pop()\n                council_members.append((resident[0], club))\n                for i in range(len(residents)):\n                    if club in residents[i][2]:\n                        residents[i][2].remove(club)\n        return council_members\n\n    def is_valid_council(council_members, n, parties):\n        party_count = {}\n        for member, _ in council_members:\n            party = parties[member]\n            if party not in party_count:\n                party_count[party] = 0\n            party_count[party] += 1\n        for count in party_count.values():\n            if count > n / 2:\n                return False\n        return True\n\n    def process_test_case(residents):\n        if len(residents) % 2 == 1:\n            return \"Impossible.\"\n\n        parties = {}\n        for resident in residents:\n            parties[resident[0]] = resident[1]\n\n        council_members = find_council_members(residents)\n        if is_valid_council(council_members, len(residents), parties):\n            return \"\\n\".join([f\"{member} {club}\" for member, club in council_members])\n        else:\n            return \"Impossible.\"\n\n    test_cases = stdin.split(\"\\n\")\n    num_test_cases = int(test_cases[0])\n    test_cases = test_cases[1:]\n\n    result = []\n    for i in range(num_test_cases):\n        n = int(test_cases[0])\n        residents = [test_cases[j].split() for j in range(1, n + 1)]\n        for j in range(n):\n            residents[j][2] = residents[j][2:]\n        test_cases = test_cases[n + 1:]\n        result.append(process_test_case(residents))\n\n    return \"\\n\\n\".join(result) "
    },
    {
        "number": 3460,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    cans = []\n    for i in range(n):\n        x, r = map(int, stdin.readline().split())\n        cans.append((x, r))\n\n    def count_explosions(cans, index):\n        count = 0\n        x, r = cans[index]\n        for i, (x2, r2) in enumerate(cans):\n            if i == index:\n                continue\n            if abs(x2 - x) <= r + r2:\n                count += 1\n        return count\n\n    result = []\n    for i in range(n):\n        result.append(count_explosions(cans, i))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3461,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def expected_value(s, a, b):\n        return (b - a + 1) / 2 * (s + a + b) - (b - a + 1) * a\n\n    def optimal_strategy(hearings):\n        n = len(hearings)\n        dp = [0] * (n + 1)\n        dp[n] = 0\n\n        for i in range(n - 1, -1, -1):\n            s, a, b = hearings[i]\n            dp[i] = expected_value(s, a, b)\n\n            for j in range(i + 1, n):\n                s2, a2, b2 = hearings[j]\n                if s2 >= s + b:\n                    break\n                dp[i] = max(dp[i], dp[j] + expected_value(s, a, min(b, s2 - s - a2)))\n\n        return dp[0]\n\n    n = int(stdin.readline().strip())\n    hearings = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    return f\"{optimal_strategy(hearings):.4f}\""
    },
    {
        "number": 3462,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    pattern = lines[0]\n    num_files = int(lines[1])\n    files = lines[2:2+num_files]\n\n    def match(filename: str, pattern: str) -> bool:\n        pattern_parts = pattern.split('*')\n        if pattern_parts[0] and not filename.startswith(pattern_parts[0]):\n            return False\n        for part in pattern_parts[1:]:\n            if part not in filename:\n                return False\n        return True\n\n    matching_files = [f for f in files if match(f, pattern)]\n    return '\\n'.join(matching_files)"
    },
    {
        "number": 3463,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    p = [float(input()) for _ in range(N + M - 1)]\n\n    win_prob = 0\n    for i in range(N, N + M):\n        if i < N:\n            win_prob += (1 - p[i]) * (2 ** (i - N))\n        elif i > N:\n            win_prob += p[i] * (2 ** (i - N - 1))\n\n    return f\"{win_prob:.6f}\""
    },
    {
        "number": 3464,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, p = map(float, stdin.split())\n    p /= 100\n    x /= 100\n\n    def expected_profit(bet_count, win_count, loss_count):\n        if bet_count == 0:\n            return 0\n        win_prob = (p ** win_count) * (1 - p) ** loss_count\n        expected_profit_if_win = win_count * 2 - (bet_count - win_count) + x * (bet_count - win_count)\n        expected_profit_if_lose = loss_count * 2 + (bet_count - loss_count) - x * (bet_count - loss_count)\n        return win_prob * expected_profit_if_win + (1 - win_prob) * expected_profit_if_lose\n\n    bet_count = 1\n    while True:\n        profit = expected_profit(bet_count, bet_count, 0)\n        if profit <= 0:\n            break\n        bet_count += 1\n\n    return f\"{profit:.3f}\""
    },
    {
        "number": 3465,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    roads = [tuple(map(int, line.strip().split())) for line in stdin]\n    cities = set(range(1, n + 1))\n    city_roads = {}\n\n    for a, b in roads:\n        if a in city_roads:\n            city_roads[a].append((a, b))\n        else:\n            city_roads[a] = [(a, b)]\n\n        if b in city_roads:\n            city_roads[b].append((a, b))\n        else:\n            city_roads[b] = [(a, b)]\n\n    output = []\n    for city in sorted(city_roads.keys()):\n        for road in city_roads[city]:\n            if road[0] == city:\n                output.append(f\"{road[0]} {road[1]}\")\n                cities.remove(road[1])\n                break\n\n    return \"\\n\".join(output) + \"\\n\" + \"\\n\".join(f\"{city} {list(cities)[0]}\" for city in sorted(cities))"
    },
    {
        "number": 3466,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    total_sweets = sum(a)\n    f = [a[i] / total_sweets for i in range(m)]\n\n    s = [0] * m\n    for sweet_type in b:\n        s[sweet_type - 1] += 1\n\n    n = sum(s)\n    max_additional_sweets = float('inf')\n\n    for i in range(m):\n        if s[i] < n * f[i] - 1:\n            max_additional_sweets = min(max_additional_sweets, (n * f[i] - s[i] - 1) // f[i])\n        elif s[i] > n * f[i] + 1:\n            max_additional_sweets = min(max_additional_sweets, (s[i] - n * f[i] - 1) // (1 - f[i]))\n\n    return str(max_additional_sweets) if max_additional_sweets < float('inf') else \"forever\""
    },
    {
        "number": 3467,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split()[:3])\n    stops = [[] for _ in range(n)]\n    for i in range(m):\n        u, v, t0, p, d = map(int, stdin.split()[3 * i + 3:3 * i + 8])\n        stops[u].append((v, t0, p, d))\n\n    def dfs(stop, time, visited):\n        if stop == n - 1:\n            return time\n        if time > s:\n            return float('inf')\n        if (stop, time) in visited:\n            return visited[(stop, time)]\n\n        result = float('inf')\n        for v, t0, p, d in stops[stop]:\n            if time >= t0 and (time - t0) % p == 0:\n                visited[(stop, time)] = result\n                new_time = time + d\n                result = min(result, dfs(v, new_time, visited))\n\n        return result\n\n    result = dfs(0, 0, {})\n    return str(result) if result != float('inf') else 'impossible' "
    },
    {
        "number": 3468,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.readline().split())\n    apps = []\n    for i in range(n):\n        d, s = map(int, stdin.readline().split())\n        apps.append((d, s))\n\n    apps.sort(key=lambda x: x[1], reverse=True)\n\n    installed_apps = []\n    for i in range(n):\n        if c >= apps[i][1]:\n            installed_apps.append(i + 1)\n            c -= apps[i][1]\n\n    return f\"{len(installed_apps)}\\n{' '.join(map(str, installed_apps))}\""
    },
    {
        "number": 3469,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    g, k, p = stdin.split('\\n')\n    p = float(p)\n\n    # Calculate the probability that Gon wins\n    probability_g = 0\n    for i in range(len(g)):\n        probability_g += (p ** i) * ((1 - p) ** (len(g) - i - 1))\n\n    # Calculate the probability that Killua wins\n    probability_k = 0\n    for i in range(len(k)):\n        probability_k += (p ** i) * ((1 - p) ** (len(k) - i - 1))\n\n    # Calculate the probability that the game ends in a draw\n    probability_draw = 1 - probability_g - probability_k\n\n    # Calculate the probability that Gon wins\n    probability_gon_wins = probability_g / (probability_g + probability_k + probability_draw)\n\n    return f\"{probability_gon_wins:.10f}\""
    },
    {
        "number": 3470,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    safe_cells = []\n\n    for i in range(1, 4 * n + 5, 2):\n        if i not in [2, 4 * n + 4, 4 * n + 2, 2 * n + 3]:\n            safe_cells.append(i)\n\n    return f\"{len(safe_cells)}\\n{' '.join(map(str, safe_cells))}\""
    },
    {
        "number": 3471,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xorbonacci(a, k):\n        x = [0] * (k + 1)\n        x[1] = a[0]\n        x[2] = a[1]\n        for i in range(3, k + 1):\n            x[i] = x[i - 1] ^ x[i - 2] ^ a[i - 1]\n        return x\n\n    def xor_range(x, l, r):\n        return x[l] ^ x[r]\n\n    lines = stdin.split('\\n')\n    k = int(lines[0])\n    a = list(map(int, lines[1].split()))\n    q = int(lines[2])\n    x = xorbonacci(a, k)\n    result = []\n    for i in range(3, 3 + q):\n        l, r = map(int, lines[i].split())\n        result.append(xor_range(x, l, r))\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3472,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, N = map(int, stdin.readline().split())\n    lines = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, stdin.readline().split())\n        lines.append((x1, y1, x2, y2))\n\n    # Check if there are any lines that intersect with each other\n    def intersect(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        numerator1 = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)\n        numerator2 = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)\n        if denominator == 0:\n            return False\n        return numerator1 / denominator == numerator2 / denominator\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if intersect(lines[i], lines[j]):\n                print(\"Infinity\")\n                return\n\n    # Check if there are any lines that are parallel\n    def parallel(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        return (x1 - x2) * (y3 - y4) == (y1 - y2) * (x3 - x4)\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if parallel(lines[i], lines[j]):\n                print(\"Infinity\")\n                return\n\n    # Check if there are any lines that are collinear\n    def collinear(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        return (x1 * (y2 - y1) + y1 * (x1 - x2)) * (x3 - x4) == (x3 * (y4 - y3) + y3 * (x3 - x4)) * (x1 - x2)\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if collinear(lines[i], lines[j]):\n                print(\"Infinity\")\n                return\n\n    # If all lines are non-intersecting, non-parallel, and non-collinear,\n    # then the number of extra lines needed is the number of warlords minus the number of lines\n    print(W - N)"
    },
    {
        "number": 3473,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_leap_year(year: int) -> bool:\n        return (year % 4 == 0) and (year % 100 != 0 or year % 400 == 0)\n\n    def days_in_month(year: int, month: int) -> int:\n        if month in [4, 6, 9, 11]:\n            return 30\n        elif month == 2:\n            return 29 if is_leap_year(year) else 28\n        else:\n            return 31\n\n    def days_before(year: int, month: int, day: int) -> int:\n        days = 0\n        for y in range(2018, year):\n            days += 365 + is_leap_year(y)\n        for m in range(1, month):\n            days += days_in_month(year, m)\n        days += day - 1\n        return days\n\n    def surprise_penalty(year: int, month: int, day: int, prev_year: int, prev_month: int, prev_day: int) -> int:\n        return (days_before(year, month, day) - days_before(prev_year, prev_month, prev_day)) ** 2\n\n    def find_best_schedule(forbidden_dates: set, Z: int) -> tuple:\n        best_schedule = []\n        min_penalty = float('inf')\n\n        for year in range(2019, 2019 + Z):\n            for month in [10]:\n                for day in range(1, days_in_month(year, month) + 1):\n                    date = (year, month, day)\n                    if date not in forbidden_dates and days_before(year, month, day) % 7 == 5:\n                        penalty = sum(surprise_penalty(year, month, day, *prev_date) for prev_date in best_schedule)\n                        if penalty < min_penalty:\n                            min_penalty = penalty\n                            best_schedule = [(year, month, day)] + best_schedule\n                        elif penalty == min_penalty:\n                            best_schedule = [(year, month, day)] + best_schedule\n\n        return min_penalty, best_schedule\n\n    def format_schedule(schedule: list) -> str:\n        return '\\n'.join([' '.join(map(str, date)) for date in schedule])\n\n    stdin_list = stdin.split('\\n')\n    Z = int(stdin_list[0])\n    F = int(stdin_list[1])\n    forbidden_dates = set()\n\n    for i in range(2, 2 + F):\n        year, month, day = map(int, stdin_list[i].split())\n        forbidden_dates.add((year, month, day))\n\n    min_penalty, best_schedule = find_best_schedule(forbidden_dates, Z)\n    return f'{min_penalty}\\n{format_schedule(best_schedule)}'"
    },
    {
        "number": 3474,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_mirror_line(x1, y1, x2, y2):\n        if x1 == x2:\n            return None\n        return (y2 - y1) / (x2 - x1), y1 - (x1 * (y2 - y1)) / (x2 - x1)\n\n    def get_intersection(line1, line2):\n        if line1 is None or line2 is None:\n            return None\n        x = (line2[1] - line1[1]) / (line1[0] - line2[0])\n        y = line1[0] * x + line1[1]\n        return x, y\n\n    def get_distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def get_range(x1, y1, x2, y2, x3, y3):\n        mirror_line = get_mirror_line(x1, y1, x2, y2)\n        intersection = get_intersection(mirror_line, (1, -y3))\n        if intersection is None:\n            return \"can't hit the wall\"\n        x, y = intersection\n        if x1 < x2:\n            if x < x1:\n                return \"negative-infinity\", y\n            elif x > x2:\n                return \"positive-infinity\", y\n            else:\n                return y, y + get_distance(x, y, x1, y1)\n        else:\n            if x < x2:\n                return \"positive-infinity\", y\n            elif x > x1:\n                return \"negative-infinity\", y\n            else:\n                return y, y + get_distance(x, y, x1, y1)\n\n    result = []\n    for line in stdin.split('\\n'):\n        if not line:\n            continue\n        x1, y1, x2, y2, x3, y3 = map(float, line.split())\n        res = get_range(x1, y1, x2, y2, x3, y3)\n        if isinstance(res, str):\n            result.append(res)\n        else:\n            result.append(\"{:.4f} {:.4f}\".format(*res))\n    return '\\n'.join(result)"
    },
    {
        "number": 3475,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(i, j, d_min, a):\n        total_distance = sum(distances[i:j])\n        if total_distance < d_min:\n            return False\n\n        heading = 0\n        for k in range(i, j - 1):\n            heading += headings[k]\n            if abs(heading) > a:\n                return False\n\n        return True\n\n    stdin = stdin.split('\\n')\n    t, n = map(int, stdin[0].split())\n    modes = []\n    for i in range(1, t + 1):\n        d_min, a = map(int, stdin[i].split())\n        modes.append((d_min, a))\n\n    distances = [0] * (n - 1)\n    headings = [0] * (n - 1)\n    for i in range(n - 1):\n        distances[i], headings[i] = map(int, stdin[t + i].split())\n\n    switch_points = []\n    for i in range(n - 1):\n        for d_min, a in modes:\n            if is_valid(0, i + 1, d_min, a):\n                switch_points.append(i)\n                break\n\n    if not switch_points or switch_points[-1] != n - 2:\n        return \"IMPOSSIBLE\"\n\n    return str(len(switch_points))"
    },
    {
        "number": 3476,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_row(matrix, i, k):\n        row = matrix[i]\n        return row[-k:] + row[:-k]\n\n    def rotate_column(matrix, j, k):\n        column = [matrix[i][j] for i in range(len(matrix))]\n        return column[-k:] + column[:-k]\n\n    def negate_row(matrix, i):\n        row = matrix[i]\n        return [-x for x in row]\n\n    def negate_column(matrix, j):\n        column = [matrix[i][j] for i in range(len(matrix))]\n        return [-x for x in column]\n\n    R, C = map(int, stdin.readline().split())\n    matrix = [list(map(int, stdin.readline().split())) for _ in range(R)]\n\n    max_sum = sum(sum(row) for row in matrix)\n    max_operations = 0\n    max_sequence = []\n\n    for i in range(R):\n        for k in range(1, C):\n            rotated_row = rotate_row(matrix, i, k)\n            new_sum = sum(sum(row) for row in matrix)\n            if new_sum > max_sum:\n                max_sum = new_sum\n                max_operations = len(max_sequence) + 1\n                max_sequence.append(f\"rotR {i + 1} {k}\")\n\n    for j in range(C):\n        for k in range(1, R):\n            rotated_column = rotate_column(matrix, j, k)\n            for i in range(R):\n                matrix[i][j] = rotated_column[i]\n            new_sum = sum(sum(row) for row in matrix)\n            if new_sum > max_sum:\n                max_sum = new_sum\n                max_operations = len(max_sequence) + 1\n                max_sequence.append(f\"rotS {j + 1} {k}\")\n\n    for i in range(R):\n        negated_row = negate_row(matrix, i)\n        new_sum = sum(sum(row) for row in matrix)\n        if new_sum > max_sum:\n            max_sum = new_sum\n            max_operations = len(max_sequence) + 1\n            max_sequence.append(f\"negR {i + 1}\")\n\n    for j in range(C):\n        negated_column = negate_column(matrix, j)\n        for i in range(R):\n            matrix[i][j] = negated_column[i]\n        new_sum = sum(sum(row) for row in matrix)\n        if new_sum > max_sum:\n            max_sum = new_sum\n            max_operations = len(max_sequence) + 1\n            max_sequence.append(f\"negS {j + 1}\")\n\n    return f\"{max_sum} {max_operations}\\n\" + \"\\n\".join(max_sequence)"
    },
    {
        "number": 3477,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    k = list(map(int, stdin.split()))\n    E = []\n    for i in range(m):\n        E.append(sum(k) / n)\n        k = [k[j] * (E[i] - j) / n for j in range(n)]\n    return str(sum(k_i * min((i - E_j) ** 2 for E_j in E) for i, k_i in enumerate(k, 1)))"
    },
    {
        "number": 3478,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    # Create adjacency list\n    adj_list = [set() for _ in range(n + 1)]\n    for road in roads:\n        adj_list[road[0]].add(road[1])\n        adj_list[road[1]].add(road[0])\n\n    # Check if it is possible to partition the cities\n    if not is_possible_partition(adj_list):\n        return \"impossible\"\n\n    # Find the partition\n    partition = find_partition(adj_list)\n\n    # Print the cities in each collection\n    return f\"{partition[0]} {partition[1]}\"\n\ndef"
    },
    {
        "number": 3479,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    times = [int(stdin.readline()) for _ in range(n)]\n    times.sort()\n\n    total_time = 0\n    cars = k\n    i = 0\n    while cars > 0:\n        if cars > 4:\n            total_time += times[i]\n            i += 1\n            cars -= 1\n        else:\n            total_time += times[i]\n            i += 1\n            cars = k\n\n    return str(total_time)"
    },
    {
        "number": 3480,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def format_syllable(syllable, time):\n        return syllable + '_' * (time - len(syllable))\n\n    def find_overlap(first_voice_syllables, second_voice_syllables, delay):\n        first_voice_index, second_voice_index = 0, 0\n        output = []\n\n        while first_voice_index < len(first_voice_syllables) and second_voice_index < len(second_voice_syllables):\n            first_voice_syllable, first_voice_time = first_voice_syllables[first_voice_index]\n            second_voice_syllable, second_voice_time = second_voice_syllables[second_voice_index]\n\n            if first_voice_time + delay <= second_voice_time:\n                output.append(format_syllable(first_voice_syllable, first_voice_time))\n                first_voice_index += 1\n            elif second_voice_time <= first_voice_time:\n                output.append('_' * second_voice_time)\n                second_voice_index += 1\n            else:\n                output.append(format_syllable(first_voice_syllable, second_voice_time - delay))\n                first_voice_index += 1\n                second_voice_index += 1\n\n        while first_voice_index < len(first_voice_syllables):\n            first_voice_syllable, first_voice_time = first_voice_syllables[first_voice_index]\n            output.append(format_syllable(first_voice_syllable, first_voice_time))\n            first_voice_index += 1\n\n        while second_voice_index < len(second_voice_syllables):\n            second_voice_syllable, second_voice_time = second_voice_syllables[second_voice_index]\n            output.append('_' * second_voice_time)\n            second_voice_index += 1\n\n        return output\n\n    lines = stdin.split('\\n')\n    num_lines, delay = map(int, lines[0].split())\n    first_voice_syllables = []\n    second_voice_syllables = []\n\n    for i in range(1, len(lines), 2):\n        first_voice_syllable_times = list(map(int, lines[i + 1].split()))\n        first_voice_syllables.extend(list(zip(lines[i].split(), first_voice_syllable_times)))\n        second_voice_syllables.extend(list(zip(['_'] * len(lines[i].split()), first_voice_syllable_times)))\n\n    first_voice_output = find_overlap(first_voice_syllables, second_voice_syllables, delay)\n    second_voice_output = find_overlap(second_voice_syllables, first_voice_syllables, -delay)\n\n    output = []\n    for i in range(len(first_voice_output)):\n        output.append(first_voice_output[i] + '\\n' + second_voice_output[i] + '\\n')\n\n    return ''.join(output)"
    },
    {
        "number": 3481,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(source, target, visited, graph, time):\n        if source == target:\n            return time\n        if source in visited:\n            return -1\n        visited.add(source)\n        for neighbor, dist in graph[source]:\n            if neighbor not in visited:\n                res = dfs(neighbor, target, visited.copy(), graph, time + dist)\n                if res != -1:\n                    return res\n        return -1\n\n    def dijkstra(start, graph):\n        dist = {vertex: float('inf') for vertex in graph}\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            current_dist, current_vertex = heapq.heappop(pq)\n            if current_dist > dist[current_vertex]:\n                continue\n            for neighbor, weight in graph[current_vertex]:\n                new_dist = current_dist + weight\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, neighbor))\n        return dist\n\n    def max_cryptocents(gigs, roads, K, R):\n        graph = defaultdict(list)\n        for A, B, T in roads:\n            graph[A].append((B, T))\n            graph[B].append((A, T))\n\n        dist = dijkstra(1, graph)\n        for i in range(len(gigs)):\n            gigs[i] = (*gigs[i], dist[gigs[i][0]])\n\n        gigs.sort(key=lambda x: x[1])\n        dp = [0] * (K + 1)\n        for i in range(len(gigs)):\n            dp[gigs[i][0]] = max(dp[gigs[i][0]], dp[gigs[i][3]] + gigs[i][4])\n            for j in range(i + 1, len(gigs)):\n                if gigs[j][1] < gigs[i][2]:\n                    dp[gigs[i][0]] = max(dp[gigs[i][0]], dp[gigs[j][0]] + gigs[i][4])\n                else:\n                    break\n        return dp[1]\n\n    data = list(map(int, stdin.split()))\n    G, K, R = data[0], data[1], data[2]\n    data = data[3:]\n    roads = [data[i * 3:i * 3 + 3] for i in range(R)]\n    gigs = [data[R * 3 + i * 4:R * 3 + i * 4 + 4] for i in range(G)]\n\n    return str(max_cryptocents(gigs, roads, K, R))"
    },
    {
        "number": 3482,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    l, p, d, t, n = map(int, lines[0].split()), map(int, lines[1].split()), map(int, lines[2].split()), map(int, lines[3].split())\n    trips = [list(map(int, lines[i+4].split())) for i in range(n)]\n\n    def get_cost(days, prices, levels):\n        cost = 0\n        for i in range(len(levels)):\n            cost += sum(prices[i] for _ in range(min(days, levels[i])))\n            days -= levels[i]\n            if days == 0:\n                break\n        else:\n            cost += days * prices[-1]\n        return cost\n\n    total_days = sum(b-a+1 for a, b in trips)\n    max_level = [d[i-1] + l[i-1] for i in range(1, len(d)+1)]\n    min_cost = get_cost(total_days, p, max_level)\n\n    for a, b in trips:\n        days_home = b - a + 1\n        days_away = total_days - days_home\n        cost_home = get_cost(days_home, p, d)\n        cost_away = get_cost(days_away, p, max_level)\n        min_cost = min(min_cost, cost_home + cost_away)\n\n    return str(min_cost)"
    },
    {
        "number": 3483,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    weights = list(map(int, stdin.readline().strip().split()))\n\n    max_weight = sum(sorted(weights, reverse=True)[:4])\n    min_weight = sum(sorted(weights)[:4])\n\n    distinct_weights = len(set(weights))\n\n    total_weight = sum(weights)\n    expected_weight = total_weight / N\n\n    return f\"{max_weight} {min_weight} {distinct_weights} {expected_weight:.4f}\""
    },
    {
        "number": 3484,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(board: List[List[int]], row: int, col: int, num: int) -> bool:\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        start_row, start_col = row - row % 3, col - col % 3\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n        return True\n\n    def solve(board: List[List[int]], row: int, col: int) -> bool:\n        if row == 9:\n            return True\n        new_row, new_col = (row + 1, 0) if col == 8 else (row, col + 1)\n        if board[row][col] != 0:\n            return solve(board, new_row, new_col)\n        for num in range(1, 10):\n            if is_valid(board, row, col, num):\n                board[row][col] = num\n                if solve(board, new_row, new_col):\n                    return True\n                board[row][col] = 0\n        return False\n\n    n, k = map(int, stdin.split())\n    board = [[0] * n for _ in range(n)]\n    for i in range(k):\n        board[i] = list(map(int, input().split()))\n\n    if solve(board, 0, 0):\n        print(\"yes\")\n        for row in board:\n            print(\" \".join(map(str, row)))\n    else:\n        print(\"no\")"
    },
    {
        "number": 3485,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, cards = map(int, stdin.split())\n    cards = list(map(int, cards))\n\n    # Calculate the sum of all cards\n    total_sum = sum(cards)\n\n    # Calculate the maximum payout by counting all positive cards and ignoring all negative cards\n    positive_sum = sum(filter(lambda x: x > 0, cards))\n    counted_cards = len(list(filter(lambda x: x > 0, cards)))\n    max_payout = positive_sum / counted_cards if counted_cards > 0 else 0\n\n    # Calculate the minimum payout by counting all negative cards and ignoring all positive cards\n    negative_sum = sum(filter(lambda x: x < 0, cards))\n    counted_cards = len(list(filter(lambda x: x < 0, cards)))\n    min_payout = negative_sum / counted_cards if counted_cards > 0 else 0\n\n    # Calculate the maximum payout by counting the cards in the optimal way\n    optimal_payout = max(max_payout, min_payout)\n\n    # Calculate the payout if we stop counting before the first negative card\n    stop_counting_index = next((i for i, x in enumerate(cards) if x < 0), None)\n    if stop_counting_index is not None:\n        stop_counting_sum = sum(cards[:stop_counting_index])\n        stop_counting_cards = stop_counting_index\n        start_counting_sum = sum(cards[stop_counting_index:])\n        start_counting_cards = N - stop_counting_index\n        stop_counting_payout = (stop_counting_sum + start_counting_sum) / (stop_counting_cards + start_counting_cards)\n    else:\n        stop_counting_payout = 0\n\n    # Calculate the payout if we start counting after the last negative card\n    start_counting_index = next((i for i, x in enumerate(cards[::-1]) if x < 0), None)\n    if start_counting_index is not None:\n        start_counting_sum = sum(cards[::-1][:start_counting_index])\n        start_counting_cards = start_counting_index\n        stop_counting_sum = sum(cards[::-1][start_counting_index:])\n        stop_counting_cards = N - start_counting_index\n        start_counting_payout = (stop_counting_sum + start_counting_sum) / (stop_counting_cards + start_counting_cards)\n    else:\n        start_counting_payout = 0\n\n    # Return the maximum payout\n    return max(optimal_payout, stop_counting_payout, start_counting_payout)"
    },
    {
        "number": 3486,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    nums = [int(x) for x in stdin.split('\\n')[1:]]\n    MOD = 10**9 + 7\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def count_ways(nums):\n        total = 1\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if gcd(nums[i], nums[j]) not in [1, nums[i], nums[j]]:\n                    total *= 2\n                elif nums[i] == nums[j]:\n                    total *= 2\n        return total\n\n    def count_ways_helper(nums):\n        total = 1\n        for i in range(len(nums)):\n            total *= count_ways(nums[i:i + 2])\n            total %= MOD\n        return total\n\n    def count_ways_circular(nums):\n        total = count_ways_helper(nums)\n        for i in range(len(nums)):\n            temp = nums[i:] + nums[:i]\n            total -= count_ways_helper(temp)\n            total %= MOD\n        return abs(total)\n\n    return str(count_ways_circular(nums))"
    },
    {
        "number": 3487,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from math import sqrt\n    from itertools import permutations\n\n    def value(F, W):\n        return F ** a * W ** (1 - a)\n\n    def find_max_value(n, pipes, v, a):\n        max_value = 0\n        max_solution = None\n\n        for p in permutations(pipes):\n            solution = [0] * (n - 1)\n            for i in range(len(p)):\n                j, k, c = p[i]\n                solution[i] = (k, j, c) if solution[i] == 0 else (j, k, c)\n\n            F = [0] * n\n            W = [0] * n\n            F[1] = 1\n            W[2] = 1\n\n            for i in range(len(solution)):\n                j, k, c = solution[i]\n                f = min(F[j], c - W[k])\n                w = min(W[j], c - F[k])\n                F[k] += f\n                W[k] += w\n                F[j] -= f\n                W[j] -= w\n\n            F[3] = F[1] - F[3]\n            W[3] = W[2] - W[3]\n\n            current_value = value(F[3], W[3])\n            if current_value > max_value:\n                max_value = current_value\n                max_solution = solution\n\n        return max_value, max_solution\n\n    def print_solution(max_solution, n, v, a):\n        for i in range(len(max_solution)):\n            j, k, c = max_solution[i]\n            f = min(F[j], c - W[k])\n            w = min(W[j], c - F[k])\n            F[k] += f\n            W[k] += w\n            F[j] -= f\n            W[j] -= w\n            print(f, -w)\n\n        F[3] = F[1] - F[3]\n        W[3] = W[2] - W[3]\n        print(F[3], W[3])\n\n    input_data = list(map(int, stdin.split()))\n    n, p, v, a = input_data[0], input_data[1], input_data[2], input_data[3]\n    pipes = [tuple(map(int, stdin.split())) for _ in range(p)]\n\n    max_value, max_solution = find_max_value(n, pipes, v, a)\n    print_solution(max_solution, n, v, a)\n    print(f\"{max_value:.10f}\")"
    },
    {
        "number": 3488,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(x, y, k):\n        for i in range(k):\n            if (x - x_sightings[i]) * (y - y_sightings[i]) <= 0:\n                return False\n        return True\n\n    def is_valid(x, y, k):\n        for i in range(k):\n            if (x - x_sightings[i]) * (y - y_sightings[i]) > 0:\n                return False\n        return True\n\n    def dfs(vertex, edges, visited, vertices):\n        if visited[vertex]:\n            return\n        visited[vertex] = True\n        vertices.append(vertex)\n        for neighbor in edges[vertex]:\n            dfs(neighbor, edges, visited, vertices)\n\n    def find_polygon(k):\n        for i in range(n):\n            x, y = x_coordinates[i], y_coordinates[i]\n            if is_inside(x, y, k):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    x1, y1 = x_coordinates[j], y_coordinates[j]\n                    if is_valid(x1, y1, k):\n                        edges = [[] for _ in range(n)]\n                        for u in range(n):\n                            for v in range(n):\n                                if u == v:\n                                    continue\n                                if is_valid(x_coordinates[u], y_coordinates[u], k) and is_valid(x_coordinates[v], y_coordinates[v], k):\n                                    edges[u].append(v)\n                        visited = [False] * n\n                        vertices = []\n                        dfs(j, edges, visited, vertices)\n                        if i in vertices:\n                            return len(vertices)\n        return n\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    x_coordinates = [int(line.split()[0]) for line in lines[1:n + 1]]\n    y_coordinates = [int(line.split()[1]) for line in lines[1:n + 1]]\n    k = int(lines[n + 1])\n    x_sightings = [int(line.split()[0]) for line in lines[n + 2:n + 2 + k]]\n    y_sightings = [int(line.split()[1]) for line in lines[n + 2:n + 2 + k]]\n\n    return str(find_polygon(k))"
    },
    {
        "number": 3489,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_route(start, end, visited, graph):\n        if start == end:\n            return []\n        visited.add(start)\n        for node in graph[start]:\n            if node not in visited:\n                route = find_route(node, end, visited, graph)\n                if route:\n                    return [start] + route\n        return None\n\n    def add_route(start, end, graph):\n        if start not in graph:\n            graph[start] = set()\n        if end not in graph:\n            graph[end] = set()\n        graph[start].add(end)\n        graph[end].add(start)\n\n    def min_routes(n, h, graph):\n        min_routes = float('inf')\n        min_combination = []\n        for i in range(n):\n            if i != h:\n                visited = set()\n                route = find_route(i, h, visited, graph)\n                if route:\n                    routes = [tuple(sorted([i, j])) for j in route if i < j]\n                    routes = set(routes)\n                    if len(routes) < min_routes:\n                        min_routes = len(routes)\n                        min_combination = routes\n        return min_routes, min_combination\n\n    lines = stdin.split('\\n')\n    n, h = map(int, lines[0].split())\n    graph = {}\n    for i in range(1, n):\n        a, b = map(int, lines[i].split())\n        add_route(a, b, graph)\n\n    min_routes, min_combination = min_routes(n, h, graph)\n    output = [str(min_routes)]\n    for route in min_combination:\n        output.append(' '.join(map(str, route)))\n    return '\\n'.join(output)"
    },
    {
        "number": 3490,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_collision(witch1, witch2):\n        x1, y1, r1 = witch1\n        x2, y2, r2 = witch2\n        dx, dy = x2 - x1, y2 - y1\n        distance = (dx ** 2 + dy ** 2) ** 0.5\n        if distance > 1:\n            return False\n        angle1 = math.atan2(dy, dx)\n        angle2 = math.atan2(y2 - y1, x2 - x1)\n        return abs(angle1 - angle2) % math.pi < math.pi / 2\n\n    def check_collision(witches):\n        for i in range(len(witches)):\n            for j in range(i + 1, len(witches)):\n                if is_collision(witches[i], witches[j]):\n                    return True\n        return False\n\n    N = int(stdin.readline().strip())\n    witches = []\n    for _ in range(N):\n        x, y, r = map(float, stdin.readline().strip().split())\n        witches.append((x, y, r))\n\n    if check_collision(witches):\n        return \"crash\"\n    else:\n        return \"ok\""
    },
    {
        "number": 3491,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    current_state = [[] for _ in range(N)]\n    desired_state = [[] for _ in range(N)]\n\n    for _ in range(M):\n        i, j = map(int, stdin.readline().split())\n        current_state[i].append(j)\n\n    for _ in range(M):\n        i, j = map(int, stdin.readline().split())\n        desired_state[i].append(j)\n\n    def move_staircase(i, j, direction):\n        if direction == \"R\":\n            return i, (j + 1) % N\n        else:\n            return i, (j - 1) % N\n\n    def find_moves(current_state, desired_state):\n        moves = []\n        for i in range(N):\n            for j in desired_state[i]:\n                if j not in current_state[i]:\n                    if i == 0:\n                        moves.append((\"G\", i))\n                    else:\n                        prev_i, prev_j = move_staircase(i, j, \"R\")\n                        while (prev_j not in current_state[prev_i] or current_state[prev_i][current_state[prev_i].index(prev_j)] != prev_i) and prev_i != i:\n                            moves.append((\"R\", prev_i))\n                            prev_i, prev_j = move_staircase(prev_i, prev_j, \"R\")\n                        moves.append((\"R\", i))\n        return moves\n\n    moves = find_moves(current_state, desired_state)\n    if len(moves) > 250000:\n        return \"IMPOSSIBLE\"\n\n    return f\"{len(moves)}\\n\" + \"\\n\".join([f\"{move[0]} {move[1]}\" for move in moves])"
    },
    {
        "number": 3492,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(state_list, transport_list):\n        for transport in transport_list:\n            if transport[0] in state_list:\n                return True\n        return False\n\n    def find_max_factories(state_list, transport_list):\n        max_factories = 0\n        for i in range(len(state_list)):\n            for j in range(i + 1, len(state_list)):\n                for k in range(len(transport_list)):\n                    if is_valid(state_list[i:i + 1] + state_list[j:j + 1], transport_list[k:]):\n                        max_factories += 1\n                        break\n        return max_factories\n\n    lines = stdin.split('\\n')\n    s, r, f, t = map(int, lines[0].split())\n    raw_material_states = lines[1].split()\n    factory_states = lines[2].split()\n    transport_companies = [line.split()[1:] for line in lines[3:]]\n\n    max_factories = find_max_factories(raw_material_states, transport_companies)\n    max_factories += find_max_factories(factory_states, transport_companies)\n\n    return str(max_factories)"
    },
    {
        "number": 3493,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    buttons = [[] for _ in range(n)]\n    for i in range(n):\n        line = stdin.readline().strip()\n        for j in range(n):\n            if line[j] == 'Y':\n                buttons[j].append(i)\n\n    def dfs(start: int, visited: set, path: list) -> bool:\n        if len(path) == n:\n            return True\n        for i in range(start, n):\n            if len(buttons[i]) > 0 and not visited.issuperset(buttons[i]) and dfs(i + 1, visited.union(buttons[i]), path + [i]):\n                return True\n        return False\n\n    max_count = 0\n    for i in range(n):\n        if len(buttons[i]) > 0:\n            visited = set(buttons[i])\n            path = [i]\n            if dfs(0, visited, path):\n                max_count += 1\n\n    output = [f\"{max_count}\\n\"]\n    for i in range(max_count):\n        line = \"\"\n        for j in range(n):\n            if j in path:\n                line += f\"{path.index(j) + 1} \"\n            else:\n                line += \"0 \"\n        output.append(line.strip() + \"\\n\")\n\n    return \"\".join(output)"
    },
    {
        "number": 3494,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.readline().split())\n    matrix = []\n    for _ in range(R):\n        matrix.append(list(stdin.readline().strip()))\n\n    G = int(stdin.readline())\n    distances = []\n    for _ in range(G):\n        r, s = map(int, stdin.readline().split())\n        nearest_tree = None\n        min_distance = float('inf')\n        for i in range(R):\n            for j in range(S):\n                if matrix[i][j] == 'x':\n                    distance = (i - r) ** 2 + (j - s) ** 2\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_tree = (i, j)\n        distances.append(min_distance)\n\n    return '\\n'.join(map(str, distances))"
    },
    {
        "number": 3495,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def angle(x1, y1, x2, y2):\n        return math.atan2(y2 - y1, x2 - x1)\n\n    def solve(lengths, target_x, target_y):\n        def backtrack(i, x, y, a):\n            if i == len(lengths):\n                return (x, y), a\n\n            for j in range(len(lengths)):\n                if j not in used and j != 0:\n                    used.append(j)\n                    next_x = x + lengths[j] * math.cos(a)\n                    next_y = y + lengths[j] * math.sin(a)\n                    next_a = angle(x, y, next_x, next_y)\n                    result = backtrack(i + 1, next_x, next_y, next_a)\n                    if result:\n                        return result\n                    used.pop()\n\n        used = []\n        return backtrack(0, 0, 0, 0)\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    lengths = [int(line) for line in lines[1:n + 1]]\n    target_x, target_y = [float(x) for x in lines[n + 1].split()]\n\n    result, angles = solve(lengths, target_x, target_y)\n    if result:\n        output = '\\n'.join([f'{x:.3f} {y:.3f}' for x, y in result])\n        return output\n    else:\n        return 'No solution found'"
    },
    {
        "number": 3496,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q, a, queries = parse_input(stdin)\n    dp = [0] * (n + 1)\n    dp[1:n+1] = a\n\n    for i in range(n, 0, -1):\n        for j in range(i, n+1):\n            dp[i] = min(dp[i], dp[j])\n            if j - i < n:\n                dp[j] = min(dp[j], dp[j - i] + dp[i])\n\n    return \"\\n\".join(str(dp[k]) for k in queries)\n\ndef"
    },
    {
        "number": 3497,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent, visited):\n        visited.add(node)\n        for neighbor in tree[node]:\n            if neighbor != parent and neighbor not in visited:\n                dfs(neighbor, node, visited)\n\n    def find_leaves(node, parent, visited, leaves):\n        visited.add(node)\n        for neighbor in tree[node]:\n            if neighbor != parent and neighbor not in visited:\n                find_leaves(neighbor, node, visited, leaves)\n        if len(tree[node]) == 1:\n            leaves.add(node)\n\n    def bfs(start, visited):\n        queue = [start]\n        visited.add(start)\n        while queue:\n            node = queue.pop(0)\n            for neighbor in tree[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n\n    lines = stdin.split('\\n')\n    V, P = map(int, lines[0].split())\n    tree = [set() for _ in range(V)]\n    for i in range(1, V):\n        u, v = map(int, lines[i].split())\n        tree[u].add(v)\n        tree[v].add(u)\n\n    pigs = set(map(int, lines[-1].split()))\n    visited = set()\n    for pig in pigs:\n        dfs(pig, -1, visited)\n\n    leaves = set()\n    for pig in pigs:\n        find_leaves(pig, -1, visited, leaves)\n\n    wolves = set()\n    for node in range(V):\n        if node not in visited:\n            wolves.add(node)\n\n    W = 0\n    for wolf in wolves:\n        if wolf not in leaves:\n            visited = set()\n            bfs(wolf, visited)\n            if not visited.intersection(leaves):\n                W += 1\n\n    return str(W)"
    },
    {
        "number": 3498,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def execute_instruction(task, instruction, resources, tasks):\n        if instruction[0] == \"C\":\n            task[\"clock\"] += int(instruction[1:])\n        elif instruction[0] == \"L\":\n            resource_key = int(instruction[1:])\n            if resource_key in task[\"resources\"]:\n                return False\n            for other_task in tasks:\n                if other_task[\"resources\"] and max(other_task[\"resources\"]) >= task[\"priority\"]:\n                    return False\n            task[\"resources\"].add(resource_key)\n            resources[resource_key].add(task)\n        elif instruction[0] == \"U\":\n            resource_key = int(instruction[1:])\n            if resource_key not in task[\"resources\"]:\n                return False\n            resources[resource_key].remove(task)\n            task[\"resources\"].remove(resource_key)\n        return True\n\n    def update_priorities(tasks, resources):\n        for task in tasks:\n            task[\"priority\"] = max(task[\"priority\"], task[\"base_priority\"])\n            for resource_key in task[\"resources\"]:\n                for other_task in resources[resource_key]:\n                    if other_task[\"base_priority\"] > task[\"priority\"]:\n                        task[\"priority\"] = other_task[\"base_priority\"]\n\n    def find_next_task(tasks):\n        running_tasks = [task for task in tasks if task[\"start_time\"] <= task[\"clock\"] and not task[\"instructions\"]]\n        running_tasks.sort(key=lambda x: x[\"priority\"], reverse=True)\n        return running_tasks[0] if running_tasks else None\n\n    def run_tasks(tasks, resources):\n        while True:\n            update_priorities(tasks, resources)\n            next_task = find_next_task(tasks)\n            if not next_task:\n                break\n            instruction = next_task[\"instructions\"].pop(0)\n            if not execute_instruction(next_task, instruction, resources, tasks):\n                next_task[\"instructions\"].insert(0, instruction)\n\n    def parse_input(stdin):\n        t, r = map(int, stdin.readline().strip().split())\n        tasks = []\n        for _ in range(t):\n            start_time, base_priority, instruction_count = map(int, stdin.readline().strip().split())\n            instructions = stdin.readline().strip().split()\n            tasks.append({\n                \"start_time\": start_time,\n                \"base_priority\": base_priority,\n                \"priority\": base_priority,\n                \"clock\": 0,\n                \"resources\": set(),\n                \"instructions\": instructions\n            })\n        resources = {i: set() for i in range(1, r + 1)}\n        return tasks, resources\n\n    tasks, resources = parse_input(stdin)\n    run_tasks(tasks, resources)\n    return \"\\n\".join(str(task[\"clock\"]) for task in tasks)"
    },
    {
        "number": 3499,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    mod = 10**9 + 7\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def count_palindromes(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if is_palindrome(s[i:j+1]):\n                    count += 1\n        return count\n\n    total_palindromes = 0\n    for i in range(2**n):\n        binary = format(i, f'0{n}b')\n        palindrome = ''\n        for j in range(n):\n            if binary[j] == '0':\n                palindrome += s[j].lower()\n            else:\n                palindrome += s[j].upper()\n        total_palindromes += count_palindromes(palindrome)\n\n    return str(total_palindromes % mod)"
    },
    {
        "number": 3500,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_tie(card1, card2, sequence):\n        for i in range(len(sequence) - 1):\n            if sequence[i] in card1 and sequence[i + 1] in card2:\n                return True\n            if sequence[i] in card2 and sequence[i + 1] in card1:\n                return True\n        return False\n\n    def create_card(card_input):\n        card = []\n        for row in card_input:\n            card.append(list(map(int, row.split())))\n        return card\n\n    def create_cards(stdin):\n        n = int(stdin.readline().strip())\n        cards = []\n        for i in range(n):\n            card_input = [stdin.readline().strip() for _ in range(5)]\n            cards.append(create_card(card_input))\n            stdin.readline()\n        return cards\n\n    def find_tie(cards):\n        for i in range(len(cards) - 1):\n            for j in range(i + 1, len(cards)):\n                for sequence in itertools.permutations(range(1, 3001)):\n                    if check_tie(cards[i], cards[j], sequence):\n                        return i + 1, j + 1\n        return \"no ties\"\n\n    cards = create_cards(stdin)\n    result = find_tie(cards)\n    return result "
    },
    {
        "number": 3501,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    jaap = list(map(int, stdin.split('\\n')[1].split()))\n    jan = list(map(int, stdin.split('\\n')[2].split()))\n    thijs = list(map(int, stdin.split('\\n')[3].split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if jaap[i] < jaap[j] and jan[i] < jan[j] and thijs[i] < thijs[j]:\n                count += 1\n            elif jaap[i] > jaap[j] and jan[i] > jan[j] and thijs[i] > thijs[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3502,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def prob_first_red_light(lights):\n        total_period = sum(r + g for _, r, g in lights)\n        prob = 0\n        for i, (x, r, g) in enumerate(lights):\n            if i == 0:\n                prob += r / total_period\n            else:\n                prob += (r - x * (r + g) / total_period) / (len(lights) - 1)\n        return prob\n\n    def prob_make_it_through(lights):\n        total_period = sum(r + g for _, r, g in lights)\n        prob = 1\n        for i, (x, r, g) in enumerate(lights):\n            if i == 0:\n                prob *= g / total_period\n            else:\n                prob *= (g - x * (r + g) / total_period) / (len(lights) - 1)\n        return prob\n\n    n = int(stdin.readline())\n    lights = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    output = []\n    for light in lights:\n        output.append(str(prob_first_red_light([light])))\n    output.append(str(prob_make_it_through(lights)))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3503,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pairs = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_valid(a: int, b: int, op: str) -> bool:\n        if op == '+':\n            return a + b >= 0\n        elif op == '-':\n            return abs(a - b) >= 0\n        else:\n            return a * b >= 0\n\n    def generate_expression(a: int, b: int) -> str:\n        operators = ['+', '-', '*']\n        for op in operators:\n            if is_valid(a, b, op):\n                return f\"{a} {op} {b} = {eval(str(a) + op + str(b))}\"\n        return \"impossible\"\n\n    result = [generate_expression(a, b) for a, b in pairs]\n    return '\\n'.join(result)"
    },
    {
        "number": 3504,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_disintegration(droplet, sensors):\n        for sensor in sensors:\n            if sensor[0] <= droplet[0] <= sensor[1] and sensor[2] == droplet[1]:\n                return sensor[2]\n        return 0\n\n    def main(stdin: str):\n        lines = stdin.split('\\n')\n        D, S = map(int, lines[0].split())\n        droplets = [tuple(map(int, line.split())) for line in lines[1:D + 1]]\n        sensors = [tuple(map(int, line.split())) for line in lines[D + 1:D + S + 1]]\n\n        disintegration_results = [check_disintegration(droplet, sensors) for droplet in droplets]\n        return '\\n'.join(map(str, disintegration_results))\n\n    return main(stdin)"
    },
    {
        "number": 3505,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    nums = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if nums[i] + nums[j] == nums[k]:\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 3506,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, m = map(int, stdin.readline().split())\n    sportify_cheerleaders = [0] * 90\n    spoilify_cheerleaders = [0] * 90\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        for i in range(a, b):\n            spoilify_cheerleaders[i] += 1\n\n    for i in range(90):\n        if i + t <= 90:\n            sportify_cheerleaders[i:i + t] = [1] * t\n\n    sportify_goals = 0\n    spoilify_goals = 0\n\n    for i in range(90):\n        if i + 5 > 90:\n            break\n\n        sportify_score = sum(sportify_cheerleaders[i:i + 5])\n        spoilify_score = sum(spoilify_cheerleaders[i:i + 5])\n\n        if sportify_score > spoilify_score:\n            sportify_goals += 1\n        elif spoilify_score > sportify_score:\n            spoilify_goals += 1\n\n    return f\"{sportify_goals} {spoilify_goals}\""
    },
    {
        "number": 3507,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, W, d = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_ways(red_wines, white_wines, max_red_pile_size):\n        if red_wines == 0 and white_wines == 0:\n            return 1\n        if red_wines < 0 or white_wines < 0:\n            return 0\n\n        if red_wines > 0:\n            if red_wines > max_red_pile_size:\n                return count_ways(red_wines - max_red_pile_size, white_wines, max_red_pile_size) % MOD\n            else:\n                return (count_ways(red_wines - 1, white_wines, max_red_pile_size) +\n                        count_ways(red_wines, white_wines - 1, max_red_pile_size)) % MOD\n        else:\n            return count_ways(red_wines, white_wines - 1, max_red_pile_size)\n\n    return str(count_ways(R, W, d))"
    },
    {
        "number": 3508,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *b = [int(x) for x in stdin.split()]\n    max_damage = 0\n    max_pillar = -1\n\n    for i in range(1, n - 1):\n        left_weight = sum(b[:i])\n        right_weight = sum(b[i + 1:])\n        total_weight = left_weight + right_weight\n\n        if total_weight > b[i]:\n            damage = i + 1\n            if damage > max_damage:\n                max_damage = damage\n                max_pillar = i\n\n    return f\"{max_damage} {max_pillar + 1}\""
    },
    {
        "number": 3509,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n, m = map(int, stdin.split()[0:4])\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, t = map(int, stdin.split()[4:7])\n        graph[u].append((v, t))\n\n    def dijkstra(start, end):\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if u == end:\n                return d\n            if d > dist[u]:\n                continue\n            for v, t in graph[u]:\n                if dist[u] + t < dist[v]:\n                    dist[v] = dist[u] + t\n                    heapq.heappush(pq, (dist[v], v))\n        return float('inf')\n\n    return str(min(dijkstra(1, i) + dijkstra(i, n) for i in range(2, n + 1)))"
    },
    {
        "number": 3510,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, end, visited, graph):\n        if start == end:\n            return True\n        if start in visited:\n            return False\n        visited.add(start)\n        for neighbor in graph[start]:\n            if dfs(neighbor, end, visited, graph):\n                return True\n        return False\n\n    def build_graph(n, options):\n        graph = {chr(i + 97): set() for i in range(n)}\n        for i, option in enumerate(options):\n            for positions in option:\n                for j in range(len(positions)):\n                    graph[positions[j]].add(positions[(j + 1) % len(positions)])\n        return graph\n\n    def find_solution(n, options):\n        graph = build_graph(n, options)\n        result = []\n        for i in range(n):\n            row = []\n            for j in range(n):\n                if dfs(chr(i + 97), chr(j + 97), set(), graph):\n                    row.append(0)\n                else:\n                    row.append(-1)\n            result.append(row)\n        return result\n\n    n = int(stdin.readline().strip())\n    options = [stdin.readline().strip().split()[1:] for _ in range(n)]\n    result = find_solution(n, options)\n    return \"\\n\".join(\" \".join(map(str, row)) for row in result)"
    },
    {
        "number": 3511,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def expected_value(a, b):\n        return (a * (a + 1) * (2 * a + 1)) // 6 - (b * (b + 1) * (2 * b + 1)) // 6\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def reduce_fraction(numerator, denominator):\n        gcd_value = gcd(numerator, denominator)\n        return f\"{numerator // gcd_value} {denominator // gcd_value}\"\n\n    N, Q = map(int, stdin.readline().split())\n    A = [0] * (N + 1)\n    B = [0] * (N + 1)\n\n    for _ in range(Q):\n        query = list(map(int, stdin.readline().split()))\n        if query[0] == 1:\n            u, v = query[1], query[2]\n            for i in range(u, v + 1):\n                A[i] += 1\n        elif query[0] == 2:\n            mod = 10**9 + 7\n            numerator = sum(expected_value(a, b) for a, b in zip(A, B))\n            denominator = 1\n            for i in range(1, N + 1):\n                denominator = (denominator * (i + 1)) % mod\n            result = reduce_fraction(numerator, denominator)\n            print(result)\n            A = [0] * (N + 1)\n            B = [0] * (N + 1)\n"
    },
    {
        "number": 3512,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_duration(matrix, visited, start, end, total_duration):\n        if len(visited) == len(matrix):\n            return total_duration\n\n        min_duration = float('inf')\n        for i in range(len(matrix)):\n            if i not in visited and (start < end and i > start or start > end and i < start):\n                new_visited = visited.copy()\n                new_visited.add(i)\n                new_duration = find_min_duration(matrix, new_visited, i, end, total_duration + matrix[start][i])\n                min_duration = min(min_duration, new_duration)\n\n        return min_duration\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    matrix = [[int(x) for x in line.split()] for line in lines[1:]]\n\n    min_duration = float('inf')\n    for i in range(n):\n        min_duration = min(min_duration, find_min_duration(matrix, {i}, i, i, 0))\n\n    return str(min_duration)"
    },
    {
        "number": 3513,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin.strip())\n    k = 1\n    while True:\n        Y = [i for i in range(2, X // k + 1)]\n        Y_sum = sum(Y)\n        if Y_sum * k == X:\n            return str(k)\n        k += 1"
    },
    {
        "number": 3514,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(R)]\n\n    def is_valid(x: int, y: int) -> bool:\n        if 0 <= x < R and 0 <= y < C:\n            return True\n        return False\n\n    def dfs(x: int, y: int, visited: set) -> int:\n        if not is_valid(x, y) or (x, y) in visited or grid[x][y] != 'x':\n            return 0\n\n        visited.add((x, y))\n        count = 1\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and (nx, ny) not in visited and grid[nx][ny] == 'x':\n                count += dfs(nx, ny, visited)\n\n        return count\n\n    result = 0\n    visited = set()\n\n    for i in range(R):\n        for j in range(C):\n            if (i, j) not in visited and grid[i][j] == 'x':\n                result = max(result, dfs(i, j, visited))\n\n    return str(result)"
    },
    {
        "number": 3515,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        distances = {vertex: float('infinity') for vertex in graph}\n        distances[start] = 0\n        pq = [(0, start)]\n        while len(pq) > 0:\n            current_distance, current_vertex = heapq.heappop(pq)\n            if current_vertex == end:\n                return current_distance\n            if current_distance > distances[current_vertex]:\n                continue\n            for neighbor, weight in graph[current_vertex].items():\n                distance = current_distance + weight\n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n        return -1\n\n    N = int(stdin.readline().strip())\n    graph = {i: {} for i in range(1, N + 1)}\n    for i in range(1, N):\n        y_i, d_i, r_i = map(int, stdin.readline().strip().split())\n        for j in range(i + 1, N + 1):\n            y_j = int(stdin.readline().strip().split()[0])\n            if abs(y_i - y_j) >= d_i:\n                graph[i][j] = r_i + abs(y_i - y_j)\n                graph[j][i] = r_i + abs(y_i - y_j)\n\n    result = []\n    for i in range(2, N + 1):\n        result.append(dijkstra(graph, 1, i))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3516,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    levels = []\n    for i in range(n):\n        line = stdin.readline().split()\n        shortcut_item = int(line[0])\n        shortcut_time = int(line[1])\n        item_times = [int(x) for x in line[2:]]\n        levels.append((shortcut_item, shortcut_time, item_times))\n\n    def find_fastest_path(current_level, current_item, visited, memo):\n        if current_level == n:\n            return 0\n        if (current_level, current_item) in memo:\n            return memo[(current_level, current_item)]\n        if current_level in visited:\n            return float('inf')\n\n        visited.add(current_level)\n        next_levels = [i for i in range(current_level + 1, n + 1) if i not in visited]\n        min_time = float('inf')\n\n        for next_level in next_levels:\n            min_time = min(min_time, find_fastest_path(next_level, current_item, visited, memo))\n\n        for next_level in next_levels:\n            if levels[next_level - 1][1] < levels[current_level][2][next_level]:\n                min_time = min(min_time, levels[next_level - 1][1] + find_fastest_path(next_level, next_level, visited, memo))\n            else:\n                min_time = min(min_time, levels[current_level][2][next_level] + find_fastest_path(next_level, current_item, visited, memo))\n\n        memo[(current_level, current_item)] = min_time\n        visited.remove(current_level)\n        return min_time\n\n    return str(find_fastest_path(1, 0, set(), {}))"
    },
    {
        "number": 3517,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, node):\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                dfs(graph, visited, neighbor)\n\n    def build_graph(steps, dependencies):\n        graph = {i: set() for i in range(1, steps + 1)}\n        for i in range(1, steps):\n            for j in dependencies[i]:\n                graph[i].add(j)\n        return graph\n\n    def find_min_time(graph, steps, dependencies):\n        visited = set()\n        dfs(graph, visited, 1)\n        not_visited = [i for i in range(1, steps + 1) if i not in visited]\n        min_time = 0\n        for step in not_visited:\n            min_time += dependencies[step][0]\n        return min_time\n\n    def find_max_time(graph, steps, dependencies):\n        visited = set()\n        dfs(graph, visited, 1)\n        not_visited = [i for i in range(1, steps + 1) if i not in visited]\n        max_time = 0\n        for step in not_visited:\n            max_time += dependencies[step][0]\n        return max_time\n\n    def find_eligible_steps(dependencies):\n        eligible_steps = []\n        for i in range(1, len(dependencies) + 1):\n            if len(dependencies[i]) == 0:\n                eligible_steps.append(i)\n        return eligible_steps\n\n    def find_min_eligible_step(dependencies, eligible_steps):\n        min_time = float('inf')\n        min_step = -1\n        for step in eligible_steps:\n            time = dependencies[step][0]\n            if time < min_time:\n                min_time = time\n                min_step = step\n        return min_step\n\n    def main(stdin):\n        lines = stdin.split('\\n')\n        steps = int(lines[0])\n        times = list(map(int, lines[1].split()))\n        dependencies = [list(map(int, line.split()[1:])) for line in lines[2:]]\n\n        graph = build_graph(steps, dependencies)\n        eligible_steps = find_eligible_steps(dependencies)\n        min_eligible_step = find_min_eligible_step(dependencies, eligible_steps)\n        min_time = find_min_time(graph, steps, dependencies)\n        max_time = find_max_time(graph, steps, dependencies)\n\n        if min_eligible_step == -1:\n            return max_time\n        else:\n            dependencies[min_eligible_step] = []\n            new_graph = build_graph(steps, dependencies)\n            new_min_time = find_min_time(new_graph, steps, dependencies)\n            return min(min_time, new_min_time)\n\n    return str(main(stdin))"
    },
    {
        "number": 3518,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    friends = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        p, q, c = map(int, stdin.readline().split())\n        friends[p].append((q, c))\n        friends[q].append((p, c))\n\n    def dfs(u: int, visited: set) -> int:\n        if not friends[u]:\n            return 0\n        visited.add(u)\n        min_cost = float('inf')\n        for v, cost in friends[u]:\n            if v not in visited:\n                min_cost = min(min_cost, dfs(v, visited))\n        return min_cost + cost\n\n    total_cost = float('inf')\n    for i in range(1, n + 1):\n        if not friends[i]:\n            continue\n        visited = set()\n        total_cost = min(total_cost, dfs(i, visited))\n\n    return \"impossible\" if total_cost == float('inf') else total_cost"
    },
    {
        "number": 3519,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    expected_turns = 0.0\n\n    for i in range(1, N + 1):\n        expected_turns += i * (1 / (N * (N - 1)))\n\n    return f\"{expected_turns:.10f}\""
    },
    {
        "number": 3520,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, c = map(int, stdin.readline().split())\n    pills = []\n    for _ in range(p):\n        t, x, y = map(int, stdin.readline().split())\n        pills.append((t, x, y))\n\n    def can_live_longer(pills, c):\n        pills.sort()\n        current_pill = None\n        current_pill_start = 0\n        current_pill_elapsed = 0\n        max_age = 0\n\n        for pill in pills:\n            t, x, y = pill\n\n            if current_pill is not None:\n                max_age = max(max_age, current_pill_elapsed + (t - current_pill_start) * y / x)\n\n            current_pill = pill\n            current_pill_start = t + c\n            current_pill_elapsed = (t + c) * y / x\n\n        if current_pill is not None:\n            max_age = max(max_age, current_pill_elapsed + (n - current_pill_start) * y / x)\n\n        return max_age\n\n    return f\"{can_live_longer(pills, c):.12f}\""
    },
    {
        "number": 3521,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dist(a, b):\n        return abs(a - b) * 2\n\n    def max_distance(T_i, s_i, a_i, angle):\n        return max(0, T_i - s_i * dist(a_i, angle))\n\n    N = int(stdin.readline().strip())\n    stars = []\n    for _ in range(N):\n        T_i, s_i, a_i = map(float, stdin.readline().strip().split())\n        stars.append((T_i, s_i, a_i))\n\n    max_T = 0\n    for angle in range(2 * 10**6):\n        T = sum(max_distance(T_i, s_i, a_i, angle * 2 * pi / 10**6) for T_i, s_i, a_i in stars)\n        max_T = max(max_T, T)\n\n    return f\"{max_T:.6f}\""
    },
    {
        "number": 3522,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    batteries = list(map(int, stdin.readline().split()))\n\n    batteries.sort()\n\n    min_diff = float('inf')\n    for i in range(0, len(batteries), 2 * n * k):\n        chips = [batteries[i + j:i + j + k] for j in range(0, 2 * n, 2)]\n        diff = max(max(chips[j]) - min(chips[j]) for j in range(n))\n        min_diff = min(min_diff, diff)\n\n    return str(min_diff)"
    },
    {
        "number": 3523,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P, N1, N5, N10, N25 = map(int, stdin.split())\n    coins = [1, 5, 10, 25]\n    num_coins = [N1, N5, N10, N25]\n    total_value = sum([coins[i] * num_coins[i] for i in range(4)])\n\n    if total_value < P:\n        return \"Impossible\"\n\n    for i in range(3, -1, -1):\n        while total_value >= P:\n            if num_coins[i] == 0:\n                break\n            total_value -= coins[i]\n            num_coins[i] -= 1\n\n        if total_value == P:\n            return sum(num_coins)\n\n        total_value += num_coins[i]\n        num_coins[i] += 1\n\n    return \"Impossible\""
    },
    {
        "number": 3524,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, s1, s2 = stdin.split('\\n')\n    s1_dict = {}\n    s2_dict = {}\n\n    for i in range(len(s1)):\n        if s1[i] not in s1_dict:\n            s1_dict[s1[i]] = [i]\n        else:\n            s1_dict[s1[i]].append(i)\n\n    for i in range(len(s2)):\n        if s2[i] not in s2_dict:\n            s2_dict[s2[i]] = [i]\n        else:\n            s2_dict[s2[i]].append(i)\n\n    for char in s:\n        if char in s1_dict and s.index(char) < s1_dict[char][-1]:\n            return \"no\"\n        if char in s2_dict and s.index(char) < s2_dict[char][-1]:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3525,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_path(start, end, badge_id):\n        visited = set()\n        queue = [(start, badge_id)]\n\n        while queue:\n            curr_room, curr_badge = queue.pop(0)\n            if curr_room == end:\n                return True\n            if curr_room not in visited:\n                visited.add(curr_room)\n                for next_room, lower_bound, upper_bound in locks:\n                    if curr_room == next_room and lower_bound <= curr_badge <= upper_bound:\n                        queue.append((next_room, curr_badge))\n\n        return False\n\n    lines = stdin.split('\\n')\n    N, L, B = map(int, lines[0].split())\n    S, D = map(int, lines[1].split())\n    locks = [list(map(int, line.split())) for line in lines[2:2 + L]]\n\n    valid_badges = 0\n    for badge_id in range(1, B + 1):\n        if is_valid_path(S, D, badge_id):\n            valid_badges += 1\n\n    return str(valid_badges)"
    },
    {
        "number": 3526,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n    hints = []\n    for i in range(m):\n        l, r, same_or_diff = input().split()\n        l, r = int(l), int(r)\n        if same_or_diff == \"same\":\n            hints.append((l, r, 0))\n        else:\n            hints.append((l, r, 1))\n\n    def count_sequences(start, end, same):\n        if start > end:\n            return 1\n        if same:\n            return count_sequences(start + 1, end, True)\n        else:\n            return (count_sequences(start + 1, end, True) +\n                    count_sequences(start + 1, end, False)) % mod\n\n    def is_consistent(sequence):\n        for l, r, same in hints:\n            if same and not all(sequence[l - 1:r]):\n                return False\n            elif not same and any(sequence[l - 1:r]) and not all(sequence[l - 1:r]):\n                return False\n        return True\n\n    total_sequences = count_sequences(1, n, True)\n    consistent_sequences = 0\n    for i in range(1, total_sequences):\n        sequence = [i % 2 == 1 for i in range(n)]\n        if is_consistent(sequence):\n            consistent_sequences += 1\n\n    return str(consistent_sequences % mod)"
    },
    {
        "number": 3527,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n\n    n, m = map(int, stdin.readline().split())\n    parent = [i for i in range(n)]\n    rank = [0] * n\n\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        union(parent, rank, a, b)\n\n    return str(max(max(find(parent, i) for i in range(n)) + 1, 2))"
    },
    {
        "number": 3528,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def area(a, b, c):\n        return abs((a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) / 2)\n\n    def find_coordinates(nails, left, right, up, down):\n        return nails[left], nails[right], nails[up], nails[down]\n\n    def find_area(nails, left, right, up, down):\n        left_nail, right_nail, up_nail, down_nail = find_coordinates(nails, left, right, up, down)\n        a = distance(left_nail, up_nail)\n        b = distance(up_nail, right_nail)\n        c = distance(right_nail, down_nail)\n        d = distance(down_nail, left_nail)\n        return area(a, b, c) + area(b, c, d)\n\n    n = int(stdin.readline().strip())\n    nails = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    directions = stdin.readline().strip()\n\n    areas = []\n    for i in range(n - 2):\n        if directions[i] == 'L':\n            left = i\n        elif directions[i] == 'R':\n            right = i\n        elif directions[i] == 'U':\n            up = i\n        elif directions[i] == 'D':\n            down = i\n        areas.append(find_area(nails, left, right, up, down))\n\n    return '\\n'.join(f\"{area:.1f}\" for area in areas)"
    },
    {
        "number": 3529,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    edges = [line.split() for line in stdin.split('\\n')[1:]]\n    adj_list = [[] for _ in range(n + 1)]\n\n    for edge in edges:\n        color, start, end = edge\n        adj_list[int(start)].append((int(end), color))\n        adj_list[int(end)].append((int(start), color))\n\n    def dfs(node, visited, blue_edges):\n        visited[node] = True\n        for neighbor, color in adj_list[node]:\n            if not visited[neighbor]:\n                if color == 'B':\n                    blue_edges += 1\n                dfs(neighbor, visited, blue_edges)\n        return blue_edges\n\n    def is_spanning_tree(k):\n        visited = [False] * (n + 1)\n        return k == dfs(1, visited, 0)\n\n    return '1' if is_spanning_tree(k) else '0'"
    },
    {
        "number": 3530,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def fun_value(a, b, k):\n        return a - (k - 1) ** 2 * b\n\n    def max_fun(N, coasters, Q, visits):\n        max_fun_values = []\n        for T in visits:\n            fun = [0] * N\n            for i in range(N):\n                for k in range(1, T // coasters[i][2] + 1):\n                    fun[i] += fun_value(coasters[i][0], coasters[i][1], k)\n                    if fun[i] <= 0:\n                        break\n            max_fun_values.append(sum(fun))\n        return max_fun_values\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    coasters = []\n    for i in range(1, N + 1):\n        a, b, t = map(int, lines[i].split())\n        coasters.append((a, b, t))\n    Q = int(lines[N + 1])\n    visits = list(map(int, lines[N + 2:]))\n\n    max_fun_values = max_fun(N, coasters, Q, visits)\n    return '\\n'.join(map(str, max_fun_values))"
    },
    {
        "number": 3531,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def kruskal(n, m, k, w, edges):\n        parent = [i for i in range(n + 1)]\n        rank = [0] * (n + 1)\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            root_x = find(x)\n            root_y = find(y)\n            if root_x == root_y:\n                return False\n            if rank[root_x] > rank[root_y]:\n                parent[root_y] = root_x\n            else:\n                parent[root_x] = root_y\n                if rank[root_x] == rank[root_y]:\n                    rank[root_y] += 1\n            return True\n\n        def mst():\n            edges.sort(key=lambda x: x[2])\n            cost = 0\n            special_trails = 0\n            for edge in edges:\n                if union(edge[0], edge[1]):\n                    cost += edge[2]\n                    if edge[0] in special_places or edge[1] in special_places:\n                        special_trails += 1\n                        if special_trails == w:\n                            return cost\n            return -1\n\n        return mst()\n\n    input_data = list(map(int, stdin.split()))\n    n, m, k, w = input_data[0], input_data[1], input_data[2], input_data[3]\n    special_places = set(input_data[4:4 + k])\n    edges = [tuple(map(int, stdin.split())) for _ in range(4 + k, 4 + k + m)]\n\n    result = kruskal(n, m, k, w, edges)\n    return str(result)"
    },
    {
        "number": 3532,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def explode(s: str, explosion: str) -> str:\n        result = \"\"\n        i = 0\n        while i < len(s):\n            if s[i:i+len(explosion)] == explosion:\n                i += len(explosion)\n            else:\n                result += s[i]\n                i += 1\n        return result\n\n    def chain_reaction(s: str, explosion: str) -> str:\n        while True:\n            new_s = explode(s, explosion)\n            if new_s == s:\n                return s\n            s = new_s\n\n    stdin = stdin.split(\"\\n\")\n    s = stdin[0]\n    explosion = stdin[1]\n\n    result = chain_reaction(s, explosion)\n    if result == \"\":\n        return \"FRULA\"\n    else:\n        return result"
    },
    {
        "number": 3533,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_toll(entrance, exit):\n        return abs(entrance - exit)\n\n    def get_min_tolls(trucks):\n        trucks.sort(key=lambda x: x[0])\n        total_tolls = 0\n        for i in range(len(trucks)):\n            if i == len(trucks) - 1:\n                break\n            if trucks[i][1] > trucks[i + 1][0]:\n                total_tolls += get_toll(trucks[i][0], trucks[i + 1][1])\n                trucks[i + 1][0] = trucks[i][0]\n        return total_tolls\n\n    N = int(stdin.split('\\n')[0])\n    trucks = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    min_tolls = get_min_tolls(trucks)\n    return str(min_tolls)"
    },
    {
        "number": 3534,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    keys = list(map(int, stdin.readline().strip().split()))\n\n    max_correct = 0\n    best_k = None\n\n    for k in range(2 * 10**9):\n        correct = 1\n        prev = keys[0]\n        for key in keys[1:]:\n            if key > prev:\n                new_key = prev + k\n            elif key < prev:\n                new_key = prev - k\n            else:\n                new_key = prev\n\n            if new_key != key:\n                correct -= 1\n                break\n            prev = new_key\n\n        if correct > max_correct:\n            max_correct = correct\n            best_k = k\n\n    return f\"{max_correct}\\n{best_k}\""
    },
    {
        "number": 3535,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    spins = stdin.split('\\n')[1:]\n    pos_spins = [0] * (n * m)\n    neg_spins = [0] * (n * m)\n\n    for i in range(k):\n        spin, y, x = spins[i].split()\n        y, x = int(y) - 1, int(x) - 1\n        if spin == '+':\n            pos_spins[y * m + x] += 1\n        else:\n            neg_spins[y * m + x] += 1\n\n    mod = 10**9 + 7\n    total = 0\n\n    for i in range(n):\n        for j in range(m):\n            if i % 2 == j % 2:\n                total += pos_spins[i * m + j] * neg_spins[i * m + j]\n            else:\n                total += (pos_spins[i * m + j] + neg_spins[i * m + j]) * (pos_spins[i * m + j] + neg_spins[i * m + j] - 1) // 2\n\n    return str(total % mod)"
    },
    {
        "number": 3536,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def mod_inverse(a, m):\n        g = gcd(a, m)\n        if g != 1:\n            raise Exception(\"Inverse doesn't exist\")\n        else:\n            return pow(a, m - 2, m)\n\n    def is_heap(node, parent):\n        if parent == 0:\n            return True\n        if node < parent:\n            return True\n        return False\n\n    def count_heaps(n, b, p, memo):\n        if n == 1:\n            return 1 if is_heap(b[0], p[0]) else 0\n\n        if (n, b, p) in memo:\n            return memo[(n, b, p)]\n\n        total_heaps = 0\n        for i in range(1, n + 1):\n            if is_heap(b[i - 1], p[i - 1]):\n                new_b = b[:i - 1] + b[i:]\n                new_p = p[:i - 1] + p[i:]\n                total_heaps += count_heaps(n - i, new_b, new_p, memo)\n\n        memo[(n, b, p)] = total_heaps\n        return total_heaps\n\n    n = int(stdin.readline().strip())\n    b = []\n    p = []\n    for _ in range(n):\n        node_info = list(map(int, stdin.readline().strip().split()))\n        b.append(node_info[0])\n        p.append(node_info[1])\n\n    total_heaps = count_heaps(n, b, p, {})\n    total_cases = 1\n    for i in range(n):\n        total_cases *= b[i]\n\n    P = total_heaps\n    Q = total_cases\n    q_inv = mod_inverse(Q, 10**9 + 7)\n    result = (P * q_inv) % (10**9 + 7)\n\n    return str(result)"
    },
    {
        "number": 3537,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(current_country, current_time, visited, graph, memo):\n        if current_country == n:\n            return 0\n        if (current_country, current_time) in memo:\n            return memo[(current_country, current_time)]\n\n        min_frustration = float('inf')\n        for next_country, next_time in graph[current_country]:\n            if next_time >= current_time and next_country not in visited:\n                frustration = (next_time - current_time) ** 2\n                visited.add(current_country)\n                frustration += dfs(next_country, next_time, visited, graph, memo)\n                visited.remove(current_country)\n                min_frustration = min(min_frustration, frustration)\n\n        memo[(current_country, current_time)] = min_frustration\n        return min_frustration\n\n    stdin_list = stdin.split('\\n')\n    n, m = map(int, stdin_list[0].split())\n\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, s, e = map(int, stdin_list[i + 1].split())\n        graph[a].append((b, e))\n\n    memo = {}\n    visited = set()\n    result = dfs(1, 0, visited, graph, memo)\n    return str(result)"
    },
    {
        "number": 3538,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_carry(frog_a, frog_b):\n        return frog_a[1] + frog_b[1] <= frog_a[2]\n\n    def can_escape(frog, height):\n        return frog[0] + height >= d\n\n    def dfs(frogs, height, used):\n        if not frogs or height >= d:\n            return 0\n\n        frog = frogs[0]\n        if can_escape(frog, height):\n            return 1 + dfs(frogs[1:], height + frog[0], used + [frogs[0]])\n\n        if not used or frog[1] + sum([u[1] for u in used]) <= used[-1][2]:\n            return max(dfs(frogs[1:], height, used),\n                       dfs(frogs[1:], height, used + [frogs[0]]) if frog[1] + sum([u[1] for u in used]) <= used[-1][2] else 0)\n\n        return dfs(frogs[1:], height, used)\n\n    stdin = stdin.split('\\n')\n    n, d = map(int, stdin[0].split())\n    frogs = [list(map(int, stdin[i + 1].split())) for i in range(n)]\n    frogs.sort(key=lambda x: x[0], reverse=True)\n\n    return str(dfs(frogs, 0, []))"
    },
    {
        "number": 3539,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(graphs: List[Tuple[int, int]], edges: List[Tuple[int, int]]) -> bool:\n        for edge in edges:\n            u, v = edge\n            for i, graph in enumerate(graphs):\n                a, b = graph\n                if 1 <= u <= a and 1 <= v <= b:\n                    return True\n        return False\n\n    def count_valid_graphs(graphs: List[Tuple[int, int]], edges: List[Tuple[int, int]]) -> int:\n        total = 1\n        for i, graph in enumerate(graphs):\n            a, b = graph\n            valid_edges = [edge for edge in edges if 1 <= edge[0] <= a and 1 <= edge[1] <= b]\n            total *= (a * b - len(valid_edges)) % (10**9 + 7)\n        return total\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    graphs = [(int(line.split()[0]), int(line.split()[1])) for line in lines[1:N+1]]\n    edges = [(u, v) for u in range(1, N+1) for v in range(1, N+1) if u != v]\n\n    if is_valid(graphs, edges):\n        return str(count_valid_graphs(graphs, edges))\n    else:\n        return \"0\""
    },
    {
        "number": 3540,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_misplaced_tiles(state: List[List[str]]) -> int:\n        count = 0\n        for i in range(4):\n            for j in range(4):\n                if state[i][j] != \"RGYB\"[i]:\n                    count += 1\n        return count\n\n    def move_row_left(state: List[List[str]], row: int) -> None:\n        state[row].append(state[row].pop(0))\n\n    def move_row_right(state: List[List[str]], row: int) -> None:\n        state[row].insert(0, state[row].pop())\n\n    def move_column_up(state: List[List[str]], column: int) -> None:\n        state.append(state.pop(0))\n        for i in range(4):\n            state[i][column] = state[(i - 1) % 4][column]\n\n    def move_column_down(state: List[List[str]], column: int) -> None:\n        state.insert(0, state.pop())\n        for i in range(4):\n            state[i][column] = state[(i + 1) % 4][column]\n\n    def solve(state: List[List[str]]) -> int:\n        if count_misplaced_tiles(state) == 0:\n            return 0\n\n        min_moves = float(\"inf\")\n        for i in range(4):\n            for j in range(4):\n                if state[i][j] != \"RGYB\"[i]:\n                    for k in range(4):\n                        if k != i:\n                            move_row_left(state, k)\n                            moves = solve(state)\n                            if moves >= 0:\n                                min_moves = min(min_moves, moves + 1)\n                            move_row_right(state, k)\n\n                        move_column_up(state, j)\n                        moves = solve(state)\n                        if moves >= 0:\n                            min_moves = min(min_moves, moves + 1)\n                        move_column_down(state, j)\n\n        return min_moves if min_moves != float(\"inf\") else -1\n\n    state = [list(stdin.readline().strip()) for _ in range(4)]\n    return str(solve(state))"
    },
    {
        "number": 3541,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n\n    result = []\n    for i in range(N):\n        if abs(a[i]) > abs(b[i]):\n            result.append('A')\n        else:\n            result.append('B')\n\n    return ''.join(result)"
    },
    {
        "number": 3542,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    A1, A2, B1, B2 = [tuple(map(int, stdin.split()[2 * i + 2:2 * i + 4])) for i in range(4)]\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    if A1[0] == A2[0] and B1[0] == B2[0]:\n        return \"IMPOSSIBLE\"\n    if A1[1] == A2[1] and B1[1] == B2[1]:\n        return \"IMPOSSIBLE\"\n\n    return max(distance(A1, A2), distance(B1, B2))"
    },
    {
        "number": 3543,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    dictionary = stdin.readline().split()\n    words_to_type = [stdin.readline().strip() for _ in range(m)]\n\n    def min_keystrokes(word: str) -> int:\n        keystrokes = 0\n        for i, c in enumerate(word):\n            if i == 0:\n                keystrokes += 1\n            else:\n                prefix = word[:i]\n                candidates = [w for w in dictionary if w.startswith(prefix)]\n                if candidates:\n                    candidate = min(candidates, key=len)\n                    if candidate == word[:i + len(candidate)]:\n                        keystrokes += 1\n                        if candidate == word:\n                            return keystrokes\n                    else:\n                        keystrokes += len(candidate) - len(prefix)\n                else:\n                    keystrokes += 1\n        return keystrokes\n\n    return [min_keystrokes(word) for word in words_to_type]"
    },
    {
        "number": 3544,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *group_sizes = list(map(int, stdin.split()))\n    group_sizes = group_sizes[::-1]\n    total_people = sum(group_sizes)\n    seats_per_row = total_people\n    while seats_per_row > 12:\n        seats_per_row = total_people % seats_per_row\n        total_people -= 1\n    return str(seats_per_row)"
    },
    {
        "number": 3545,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def generate_trees(preorder, inorder):\n        if not preorder or not inorder:\n            return []\n        root = preorder[0]\n        left_inorder = [x for x in inorder if x < root]\n        right_inorder = [x for x in inorder if x > root]\n        left_preorder = [x for x in preorder if x in left_inorder]\n        right_preorder = [x for x in preorder if x in right_inorder]\n        left_trees = generate_trees(left_preorder, left_inorder)\n        right_trees = generate_trees(right_preorder, right_inorder)\n        return [(root, left, right) for left in left_trees for right in right_trees]\n\n    def inorder_print(tree):\n        if tree is None:\n            return \"\"\n        return inorder_print(tree[1]) + tree[0] + inorder_print(tree[2])\n\n    def postorder_print(tree):\n        if tree is None:\n            return \"\"\n        return postorder_print(tree[1]) + postorder_print(tree[2]) + tree[0]\n\n    def preorder_print(tree):\n        if tree is None:\n            return \"\"\n        return tree[0] + preorder_print(tree[1]) + preorder_print(tree[2])\n\n    def reconstruct_tree(preorder, inorder):\n        if not preorder or not inorder:\n            return None\n        root = preorder[0]\n        left_inorder = [x for x in inorder if x < root]\n        right_inorder = [x for x in inorder if x > root]\n        left_preorder = [x for x in preorder if x in left_inorder]\n        right_preorder = [x for x in preorder if x in right_inorder]\n        left_tree = reconstruct_tree(left_preorder, left_inorder)\n        right_tree = reconstruct_tree(right_preorder, right_inorder)\n        return (root, left_tree, right_tree)\n\n    def find_reconstructions(preorder, inorder, postorder):\n        pre_calls = []\n        in_calls = []\n        post_calls = []\n        for i, c in enumerate(preorder):\n            if c in inorder:\n                pre_calls.append(\"In\")\n            else:\n                pre_calls.append(\"Pre\")\n        for i, c in enumerate(inorder):\n            if c in preorder:\n                in_calls.append(\"Pre\")\n            else:\n                in_calls.append(\"In\")\n        for i, c in enumerate(postorder):\n            if c in preorder:\n                post_calls.append(\"Pre\")\n            else:\n                post_calls.append(\"Post\")\n        reconstructions = []\n        for p in itertools.permutations(pre_calls):\n            for i in itertools.permutations(in_calls):\n                for post in itertools.permutations(post_calls):\n                    if p[0] == \"Pre\" and p[-1] == \"Post\" and i[0] == \"Pre\" and i[-1] == \"In\" and post[0] == \"Pre\" and post[-1] == \"Post\":\n                        reconstructions.append((p, i, post))\n        return reconstructions\n\n    preorder, inorder, postorder = stdin.strip().split(\"\\n\")\n    preorder = list(preorder)\n    inorder = list(inorder)\n    postorder = list(postorder)\n\n    reconstructions = find_reconstructions(preorder, inorder, postorder)\n    for p, i, post in reconstructions:\n        tree = reconstruct_tree(preorder, inorder)\n        print(\" \".join(p + i + post))\n        print(preorder_print(tree))\n        print(inorder_print(tree))\n        print(postorder_print(tree))\n        print()"
    },
    {
        "number": 3546,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    proof_lengths = []\n    for i in range(n):\n        p_i = int(stdin.readline())\n        for j in range(p_i):\n            l, k, *deps = stdin.readline().split()\n            l = int(l)\n            k = int(k)\n            if k == 0:\n                proof_lengths.append(l)\n    return str(min(proof_lengths))"
    },
    {
        "number": 3547,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import product\n    n = int(stdin.readline())\n    plots = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(float, stdin.readline().split())\n        plots.append((x1, y1, x2, y2))\n\n    area = 0\n    for p1, p2 in product(plots, repeat=2):\n        x1, y1, x2, y2 = p1\n        x3, y3, x4, y4 = p2\n        if x1 < x4 and x2 > x3 and y1 < y4 and y2 > y3:\n            area += (x2 - x1) * (y2 - y1)\n\n    return f\"{area:.2f}\""
    },
    {
        "number": 3548,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.readline().split())\n    bad_pairs = set()\n    for _ in range(P):\n        a, b = map(int, stdin.readline().split())\n        bad_pairs.add((a, b))\n        bad_pairs.add((b, a))\n\n    mod = 10**9 + 7\n    total_drinks = 0\n    for i in range(1, N):\n        total_drinks += i\n\n    for i in range(1, N):\n        for j in range(i + 1, N):\n            if (i, j) not in bad_pairs:\n                total_drinks += 1\n\n    return str(total_drinks % mod)"
    },
    {
        "number": 3549,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m1, m2, m3, x1, x2, x3, y1, y2, y3 = map(int, stdin.split())\n\n    def find_z(m, x, y):\n        z = x\n        while True:\n            if (z - x) % m <= y:\n                return z\n            z += m\n\n    z1 = find_z(m1, x1, y1)\n    z2 = find_z(m2, x2, y2)\n    z3 = find_z(m3, x3, y3)\n\n    z = z1\n    while True:\n        if (z - z2) % m2 <= y2 and (z - z3) % m3 <= y3:\n            return str(z)\n        z += m1"
    },
    {
        "number": 3550,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    variables = {}\n    for line in stdin.split('\\n')[:-1]:\n        if line.startswith('var'):\n            name, value = line[4:].split('=')\n            name = name.strip()\n            value = value.strip()[1:-1]\n            variables[name] = value\n        elif line.startswith('print'):\n            expression = line[6:-2]\n            if expression.startswith('`'):\n                while '${' in expression:\n                    start = expression.index('${')\n                    end = expression.index('}', start)\n                    sub_expression = expression[start + 2:end]\n                    expression = expression[:start] + variables[sub_expression] + expression[end + 1:]\n            else:\n                expression = variables[expression]\n            print(expression)\n    return ''"
    },
    {
        "number": 3551,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def fill(bottle):\n        return f\"fill {bottle}\\n\"\n\n    def discard(bottle):\n        return f\"discard {bottle}\\n\"\n\n    def transfer(source, target):\n        return f\"transfer {source} {target}\\n\"\n\n    N, volumes, T = [int(x) for x in stdin.split(\"\\n\")]\n    volumes = [int(x) for x in volumes.split(\" \")]\n\n    total_volume = sum(volumes)\n    if T > total_volume:\n        return \"impossible\\n\"\n\n    moves = []\n    for i, volume in enumerate(volumes):\n        if volume >= T:\n            moves.append(fill(0))\n            moves.append(transfer(i + 1, 0))\n            moves.append(discard(i + 1))\n            break\n        else:\n            moves.append(fill(i + 1))\n            T -= volume\n\n    return \"\".join(moves)"
    },
    {
        "number": 3552,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    return str(n * m - (n % m) * (n // m + 1))"
    },
    {
        "number": 3553,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_subarray(arr: List[int]) -> int:\n        left, right = 0, 0\n        min_len = float('inf')\n        num_count = [0] * (K + 1)\n        total_count = 0\n\n        for i, num in enumerate(arr):\n            num_count[num] += 1\n            total_count += 1\n\n            while num_count[1] > 0 and num_count[K] > 0 and total_count > K:\n                num_count[arr[left]] -= 1\n                total_count -= 1\n                left += 1\n\n            if total_count == K:\n                min_len = min(min_len, i - left + 1)\n\n        return min_len if min_len != float('inf') else -1\n\n    lines = stdin.split('\\n')\n    N, K, M = map(int, lines[0].split())\n    arr = list(map(int, lines[1].split()))\n    queries = lines[2:]\n\n    result = []\n    for query in queries:\n        if query.startswith('1'):\n            p, v = map(int, query.split()[1:])\n            arr[p - 1] = v\n        elif query.startswith('2'):\n            result.append(find_shortest_subarray(arr))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3554,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D, W, C = map(int, stdin.split())\n\n    def energy_consumed(distance):\n        return distance\n\n    def containers_needed(weight):\n        return (weight + C - 1) // C\n\n    def transport_smoothie(distance, weight):\n        containers_to_use = min(2, containers_needed(weight))\n        weight_per_container = weight // containers_to_use\n        energy = energy_consumed(distance)\n        return energy, weight_per_container\n\n    smoothie_remaining = W\n    energy_remaining = 0\n    containers_remaining = 0\n\n    while D > 0:\n        energy_needed, weight_per_container = transport_smoothie(D, smoothie_remaining)\n\n        if energy_needed > energy_remaining:\n            break\n\n        energy_remaining -= energy_needed\n        smoothie_remaining -= weight_per_container * containers_needed(weight_per_container)\n        containers_remaining += containers_needed(weight_per_container)\n        D -= D * (containers_needed(weight_per_container) - 1)\n\n    return f\"{smoothie_remaining:.15f}\""
    },
    {
        "number": 3555,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    toys = []\n    trees = []\n\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        toys.append((x, y))\n\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        trees.append((x, y))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_blocked(p1, p2):\n        for tree in trees:\n            if distance(p1, tree) + distance(tree, p2) < distance(p1, p2):\n                return True\n        return False\n\n    def find_max_distance(start, toys):\n        max_distance = 0\n        for toy in toys:\n            if not is_blocked(start, toy):\n                max_distance = max(max_distance, distance(start, toy))\n        return max_distance\n\n    max_distance = find_max_distance((0, 0), toys)\n\n    return f\"{max_distance:.2f}\""
    },
    {
        "number": 3556,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_taller(a, b):\n        return a[2] > b[2]\n\n    def is_higher_salary(a, b):\n        return a[1] > b[1]\n\n    def find_immediate_boss(employees, employee_id):\n        boss = None\n        for e in employees:\n            if e[0] == employee_id:\n                continue\n            if is_taller(e, employees[employee_id]) and is_higher_salary(e, employees[employee_id]):\n                if boss is None or is_higher_salary(e, employees[boss]):\n                    boss = e[0]\n        return boss\n\n    def count_subordinates(employees, employee_id):\n        subordinates = 0\n        for e in employees:\n            if employees[e][0] == employee_id:\n                subordinates += 1\n        return subordinates\n\n    lines = stdin.split('\\n')\n    m, q = map(int, lines[0].split())\n    employees = {}\n\n    for i in range(1, m + 1):\n        employee_id, salary, height = map(int, lines[i].split())\n        employees[employee_id] = (employee_id, salary, height)\n\n    chairperson = max(employees, key=lambda x: employees[x][1])\n    output = []\n\n    for i in range(m + 1, m + 1 + q):\n        employee_id = int(lines[i])\n        immediate_boss = find_immediate_boss(employees, employee_id)\n        subordinates = count_subordinates(employees, employee_id)\n        if employee_id == chairperson:\n            immediate_boss = 0\n        output.append(f\"{immediate_boss} {subordinates}\")\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3557,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, passengers, order = map(int, stdin.split())\n    segments = [0] * n\n    for i in range(n):\n        segments[i] = (passengers[i] + 9) // 10 * 10\n    segments = sorted(segments, reverse=True)\n    chaos = 0\n    for i in range(n):\n        chaos += segments[i] * (n - i)\n    return str(chaos)"
    },
    {
        "number": 3558,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_covered(x, heights):\n        for h in heights:\n            if x <= h[0] or x - h[0] ** 2 / (2 * h[1]):\n                return True\n        return False\n\n    def compute_coverage(heights):\n        covered_length = 0\n        for x in range(1, int(D) + 1):\n            if is_covered(x, heights):\n                covered_length = x\n        return covered_length\n\n    N, D = map(int, stdin.split()[:2])\n    buildings = []\n    for _ in range(N):\n        transmitter, x, h = map(int, stdin.split())\n        if transmitter:\n            buildings.append((x, h))\n\n    return f\"{compute_coverage(buildings):.6f}\""
    },
    {
        "number": 3559,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def find_closest_enemy(x, y, enemies):\n        closest_enemy = None\n        closest_distance = float('inf')\n        for enemy in enemies:\n            distance = manhattan_distance(x, y, enemy[0], enemy[1])\n            if distance < closest_distance:\n                closest_enemy = enemy\n                closest_distance = distance\n        return closest_enemy\n\n    def find_move_direction(x, y, closest_enemy_x, closest_enemy_y):\n        directions = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n        closest_direction = None\n        closest_distance = float('inf')\n        for direction in directions:\n            new_x = x + direction[0]\n            new_y = y + direction[1]\n            distance = manhattan_distance(new_x, new_y, closest_enemy_x, closest_enemy_y)\n            if distance < closest_distance:\n                closest_direction = direction\n                closest_distance = distance\n        return closest_direction\n\n    def move_zergling(x, y, direction, empty_squares):\n        new_x = x + direction[0]\n        new_y = y + direction[1]\n        if (new_x, new_y) in empty_squares:\n            return (new_x, new_y)\n        else:\n            return (x, y)\n\n    def attack_enemy(x, y, enemies, attack_value, armour_value):\n        for enemy in enemies:\n            distance = manhattan_distance(x, y, enemy[0], enemy[1])\n            if distance == 1:\n                enemy[2] -= attack_value - armour_value\n                if enemy[2] <= 0:\n                    enemies.remove(enemy)\n\n    def simulate_turn(zerglings, enemies, attack_upgrades, armour_upgrades):\n        for zergling in zerglings:\n            x, y, hit_points = zergling\n            attack_value = 5 + attack_upgrades[0 if y <= 8 else 1]\n            armour_value = armour_upgrades[0 if y <= 8 else 1]\n\n            closest_enemy = find_closest_enemy(x, y, enemies)\n            if closest_enemy:\n                closest_enemy_x, closest_enemy_y, _ = closest_enemy\n                attack_enemy(x, y, enemies, attack_value, armour_value)\n            else:\n                closest_enemy_x, closest_enemy_y = find_closest_enemy(x, y, enemies)\n                move_direction = find_move_direction(x, y, closest_enemy_x, closest_enemy_y)\n                new_position = move_zergling(x, y, move_direction, empty_squares)\n                zergling[0], zergling[1] = new_position\n\n        for zergling in zerglings:\n            x, y, hit_points = zergling\n            hit_points = max(hit_points + 1, 35)\n            zergling[2] = hit_points\n\n    stdin_list = stdin.split('\\n')\n    N = int(stdin_list[0])\n    attack_upgrades = [int(x) for x in stdin_list[1].split()]\n    armour_upgrades = [int(x) for x in stdin_list[2].split()]\n    map_str = stdin_list[3]\n    t = int(stdin_list[4])\n\n    map_list = [list(row) for row in map_str.split('\\n')]\n    zerglings = []\n    empty_squares = set()\n    enemies = []\n\n    for y, row in enumerate(map_list):\n        for x, cell in"
    },
    {
        "number": 3560,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_consecutive_substrings(word: str, tablet: str) -> int:\n        count = 0\n        for i in range(len(tablet) - len(word) + 1):\n            if tablet[i:i + len(word)] == word:\n                count += 1\n        return count\n\n    N, Q = map(int, stdin.readline().split())\n    tablets = [stdin.readline().strip() for _ in range(N)]\n\n    result = []\n    for _ in range(Q):\n        T, *args = stdin.readline().split()\n        T = int(T)\n        if T == 1:\n            P = args[0]\n            for tablet in tablets:\n                count = count_consecutive_substrings(P, tablet)\n                result.append(str(count))\n        elif T == 2:\n            S = int(args[0])\n            count = count_consecutive_substrings(tablets[S - 1], tablets[S - 1])\n            result.append(str(count))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3561,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, S, C, K = map(int, stdin.split())\n\n    if W == S == C == 0:\n        return \"YES\"\n\n    if K < 2:\n        return \"NO\"\n\n    if W == S == C:\n        if W % (K - 1) == 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if W % (K - 1) == 0 and S % (K - 1) == 0 and C % (K - 1) == 0:\n        return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 3562,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f(t, a, b, c):\n        return a * t ** 2 + b * t + c\n\n    def df(t, a, b):\n        return 2 * a * t + b\n\n    def optimal_time(a, b, c):\n        if a == 0:\n            return T if b > 0 else 0\n        x = (-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n        if x >= 0 and x <= T:\n            return x\n        else:\n            return T if x < 0 else 0\n\n    def average_grade(a, b, c, T):\n        t = optimal_time(a, b, c)\n        return f(t, a, b, c)\n\n    N, T = map(int, stdin.readline().split())\n    subjects = []\n    for _ in range(N):\n        a, b, c = map(float, stdin.readline().split())\n        subjects.append((a, b, c))\n\n    total_grade = sum(average_grade(*subject, T) for subject in subjects)\n    return f\"{total_grade:.10f}\""
    },
    {
        "number": 3563,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *coords = list(map(int, stdin.split()))\n    coords = [coords[i:i + 2] for i in range(0, len(coords), 2)]\n    coords.sort()\n\n    lines = []\n    for i in range(n):\n        if i == 0:\n            lines.append((coords[i], coords[i + 1]))\n        else:\n            last_line = lines[-1]\n            if last_line[0][0] <= coords[i][0] <= last_line[1][0] and \\\n                    last_line[0][1] <= coords[i][1] <= last_line[1][1]:\n                continue\n            else:\n                lines.append((coords[i], coords[i + 1]))\n\n    return str(len(lines))"
    },
    {
        "number": 3564,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def find_min_tunnel_length(n, m, k, islands, palm_trees):\n        min_tunnel_length = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                if distance(islands[i], islands[j]) > 2 * min(islands[i][2], islands[j][2]):\n                    continue\n                for p1 in palm_trees:\n                    for p2 in palm_trees:\n                        if p1 == p2:\n                            continue\n                        if distance(p1, p2) > k * min(p1[2], p2[2]):\n                            continue\n                        if distance(p1, islands[i]) + distance(p2, islands[j]) <= distance(islands[i], islands[j]):\n                            min_tunnel_length = min(min_tunnel_length, distance(p1, p2))\n        return min_tunnel_length\n\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    n, m, k = map(int, input_data[0].split())\n    islands = [tuple(map(int, input_data[i + 1].split())) for i in range(n)]\n    palm_trees = [tuple(map(int, input_data[i + n + 1].split())) for i in range(m)]\n\n    min_tunnel_length = find_min_tunnel_length(n, m, k, islands, palm_trees)\n    return f\"{min_tunnel_length:.6f}\" if min_tunnel_length != float('inf') else \"impossible\""
    },
    {
        "number": 3565,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    cities = lines[1:n+1]\n    routes = [tuple(line.split()[:2]) for line in lines[n+1:n+1+m]]\n    costs = [int(line.split()[2]) for line in lines[n+1:n+1+m]]\n    assignments = [tuple(line.split()) for line in lines[n+1+m:n+1+m+4]]\n\n    # Create a graph of cities and routes\n    graph = {city: [] for city in cities}\n    for route, cost in zip(routes, costs):\n        graph[route[0]].append((route[1], cost))\n        graph[route[1]].append((route[0], cost))\n\n    # Calculate the minimum cost to set up all four train lines\n    min_cost = float('inf')\n    for assignment in assignments:\n        start, end = assignment\n        visited = {city: False for city in cities}\n        visited[start] = True\n        stack = [(start, 0)]\n        while stack:\n            city, cost = stack.pop()\n            if city == end:\n                min_cost = min(min_cost, cost)\n                break\n            for neighbor, neighbor_cost in graph[city]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    stack.append((neighbor, cost + neighbor_cost))\n\n    return str(min_cost)"
    },
    {
        "number": 3566,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_optimal_position(huts, changes):\n        left_queue = []\n        right_queue = []\n        for i, hut in enumerate(huts):\n            if i < changes[0]:\n                left_queue.append(hut)\n            else:\n                right_queue.append(hut)\n\n        left_sum = sum(left_queue)\n        right_sum = sum(right_queue)\n        diff = abs(left_sum - right_sum)\n\n        for i in range(1, len(changes)):\n            if changes[i] > changes[i - 1]:\n                left_queue.pop()\n                right_queue.pop(0)\n            else:\n                right_queue.pop()\n                left_queue.pop(0)\n\n            left_sum = sum(left_queue)\n            right_sum = sum(right_queue)\n            new_diff = abs(left_sum - right_sum)\n\n            if new_diff < diff:\n                diff = new_diff\n            elif new_diff > diff:\n                break\n\n        return diff\n\n    lines = stdin.split('\\n')\n    n, q = map(int, lines[0].split())\n    huts = list(map(int, lines[1].split()))\n    changes = [list(map(int, lines[i].split())) for i in range(2, 2 + q)]\n\n    optimal_positions = [find_optimal_position(huts, change) for change in changes]\n    return '\\n'.join(map(str, optimal_positions))"
    },
    {
        "number": 3567,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    players = [stdin.readline().strip() for _ in range(n)]\n\n    tira_features = [\"1\"] * k\n    for i in range(k):\n        for player in players:\n            if player[i] == \"1\":\n                tira_features[i] = \"0\"\n                break\n\n    return \"\".join(tira_features)"
    },
    {
        "number": 3568,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(frequencies: list) -> bool:\n        for i in range(len(frequencies)):\n            t_i, n_i = frequencies[i][0]\n            intervals = frequencies[i][1]\n            for j in range(n_i):\n                t_start = intervals[2 * j]\n                t_end = intervals[2 * j + 1]\n                if t_end - t_start != t_i:\n                    return False\n        return True\n\n    f, frequencies = int(stdin.split(\"\\n\")[0]), []\n    for i in range(f):\n        t_i, n_i = map(int, stdin.split(\"\\n\")[1 + i * 2].split())\n        intervals = [int(x) for x in stdin.split(\"\\n\")[2 + i * 2].split()]\n        frequencies.append((t_i, n_i, intervals))\n\n    if is_possible(frequencies):\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3569,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def count_hits(angle, enemies):\n        hits = 0\n        for enemy in enemies:\n            x, y, r = enemy\n            if distance(0, 0, x, y) <= r and x * math.cos(angle) + y * math.sin(angle) > 0:\n                hits += 1\n        return hits\n\n    def binary_search(enemies):\n        low, high = -math.pi, math.pi\n        while high - low > 10 ** -9:\n            mid = (low + high) / 2\n            hits = count_hits(mid, enemies)\n            if hits > count_hits(low, enemies) and hits > count_hits(high, enemies):\n                return hits\n            elif hits < count_hits(low, enemies):\n                high = mid\n            else:\n                low = mid\n        return max(count_hits(low, enemies), count_hits(high, enemies))\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    enemies = []\n    for i in range(1, n + 1):\n        x, y, r = map(float, lines[i].split())\n        enemies.append((x, y, r))\n\n    return str(binary_search(enemies))"
    },
    {
        "number": 3570,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_event(line: str) -> bool:\n        return line.startswith(\"E \")\n\n    def is_dream(line: str) -> bool:\n        return line.startswith(\"D \")\n\n    def is_scenario(line: str) -> bool:\n        return line.startswith(\"S \")\n\n    def parse_event(line: str) -> str:\n        return line[2:].strip()\n\n    def parse_dream(line: str) -> int:\n        return int(line[2:].strip())\n\n    def parse_scenario(line: str) -> tuple:\n        k, *events = line[2:].strip().split()\n        return int(k), [e.lstrip(\"!\") for e in events]\n\n    def is_consistent(scenario: tuple, events: list, dreams: list) -> str:\n        k, scenario_events = scenario\n        if not all(e in events for e in scenario_events):\n            return \"Plot Error\"\n\n        if not dreams:\n            return \"Yes\"\n\n        r = min(dreams)\n        if all(e in events[:-r] for e in scenario_events):\n            return f\"{r} Just A Dream\"\n        else:\n            return \"Plot Error\"\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    events = []\n    dreams = []\n    scenarios = [parse_scenario(line) for line in lines[1:] if is_scenario(line)]\n\n    for line in lines[1:]:\n        if is_event(line):\n            events.append(parse_event(line))\n        elif is_dream(line):\n            r = parse_dream(line)\n            dreams.append(r)\n            events = events[:-r]\n        elif is_scenario(line):\n            scenario = parse_scenario(line)\n            result = is_consistent(scenario, events, dreams)\n            print(result)\n"
    },
    {
        "number": 3571,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, H, F, N = map(int, stdin.split()[0:4])\n    text = stdin.split(\"\\n\")[1:]\n\n    def adjust_text(text: list, width: int) -> str:\n        adjusted_text = \"\"\n        for line in text:\n            if len(line) <= width:\n                adjusted_text += line + \"\\n\"\n            else:\n                adjusted_text += line[:width - 1] + \"-\\n\"\n        return adjusted_text\n\n    def thumb_position(lines: int, height: int, first: int) -> int:\n        denominator = lines - height\n        numerator = first * height\n        return numerator // denominator\n\n    def build_window(adjusted_text: str, width: int, height: int, thumb_pos: int) -> str:\n        viewport = adjusted_text.split(\"\\n\")[thumb_pos:thumb_pos + height]\n        window = \"\"\n        for i, line in enumerate(viewport):\n            if i == 0:\n                window += \"+\" + \"-\" * width + \"+\\n\"\n            else:\n                window += \"|\" + line + \" \" * (width - len(line)) + \"|\\n\"\n        window += \"+\" + \"-\" * width + \"+\\n\"\n        window += \"|\" + \"^\" * (width - 3) + \"v\" + \"|\\n\"\n        return window\n\n    adjusted_text = adjust_text(text, W)\n    thumb_pos = thumb_position(len(text), H, F)\n    window = build_window(adjusted_text, W, H, thumb_pos)\n\n    return window"
    },
    {
        "number": 3572,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.readline().split())\n    distances = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def dfs(current, visited, total_distance):\n        if total_distance == L:\n            return \"possible\"\n        if current == 0 and all(visited):\n            return \"impossible\"\n        for i in range(n):\n            if not visited[i] and distances[current][i] + total_distance <= L:\n                visited[current] = True\n                result = dfs(i, visited, total_distance + distances[current][i])\n                if result == \"possible\":\n                    return \"possible\"\n                visited[current] = False\n        return \"impossible\"\n\n    visited = [False] * n\n    result = dfs(0, visited, 0)\n    return result"
    },
    {
        "number": 3573,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D, C = map(int, stdin.split())\n    cesar_numbers = list(map(int, input().split()))\n    raul_numbers = list(map(int, input().split()))\n\n    cesar_prob = 1 / N\n    raul_prob = 1 / N\n    for _ in range(D):\n        cesar_prob *= len(set(cesar_numbers) - set(raul_numbers)) / N\n        raul_prob *= len(set(raul_numbers) - set(cesar_numbers)) / N\n\n    return f\"{1 / (cesar_prob + raul_prob)}\""
    },
    {
        "number": 3574,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_magical(arr):\n        return all(arr[0] <= num <= arr[-1] for num in arr)\n\n    def longest_magical_subarray(arr, L, R):\n        max_length = 0\n        for i in range(L - 1, R):\n            for j in range(i + 1, R + 1):\n                if is_magical(arr[i:j]):\n                    max_length = max(max_length, j - i)\n        return max_length\n\n    lines = stdin.strip().split('\\n')\n    N = int(lines[0])\n    arr = list(map(int, lines[1].split()))\n    Q = int(lines[2])\n    queries = [list(map(int, line.split())) for line in lines[3:]]\n\n    output = []\n    for L, R in queries:\n        output.append(longest_magical_subarray(arr, L, R))\n\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3575,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_neighbor(u, v, neighbors):\n        return (u, v) in neighbors or (v, u) in neighbors\n\n    def find_path(start, end, neighbors, visited):\n        if start == end:\n            return True\n        if start in visited:\n            return False\n        visited.add(start)\n        for neighbor in neighbors[start]:\n            if find_path(neighbor, end, neighbors, visited):\n                return True\n        return False\n\n    def find_connected_components(neighbors):\n        components = []\n        visited = set()\n        for i in range(len(neighbors)):\n            if i not in visited:\n                component = {i}\n                visited.add(i)\n                for neighbor in neighbors[i]:\n                    if neighbor not in visited:\n                        component.add(neighbor)\n                        visited.add(neighbor)\n                components.append(component)\n        return components\n\n    def find_min_time(s, t, neighbors, components):\n        if s == t:\n            return 0\n        for component in components:\n            if s in component and t in component:\n                return 0\n        min_time = float('inf')\n        for neighbor in neighbors[s]:\n            min_time = min(min_time, 1 + find_min_time(neighbor, t, neighbors, components))\n        return min_time\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    neighbors = [set() for _ in range(n)]\n    for i in range(m):\n        u, v = map(int, lines[i + 1].split())\n        neighbors[u].add(v)\n        neighbors[v].add(u)\n    s, t = map(int, lines[-1].split())\n\n    components = find_connected_components(neighbors)\n    if not find_path(s, t, neighbors, set()):\n        return \"never meet\"\n    else:\n        min_time = find_min_time(s, t, neighbors, components)\n        return f\"{min_time:.6f}\""
    },
    {
        "number": 3576,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n\n    def choose(n, k):\n        if k == 0 or k == n:\n            return 1\n        return choose(n - 1, k - 1) * n // k\n\n    total_blocks = R * C\n    safe_blocks = sum(choose(total_blocks - 1, i) for i in range(K + 1))\n    unsafe_blocks = total_blocks - safe_blocks\n\n    p = unsafe_blocks\n    q = total_blocks\n    q_inv = pow(q, -1, 10**11 + 3)\n\n    return str((p * q_inv) % (10**11 + 3))"
    },
    {
        "number": 3577,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_flowers(coordinates):\n        flowers = []\n        for i in range(len(coordinates)):\n            new_flowers = 0\n            for j in range(i):\n                if coordinates[i][0] < coordinates[j][0] < coordinates[i][1] < coordinates[j][1]:\n                    new_flowers += 1\n            flowers.append(new_flowers)\n        return flowers\n\n    def main():\n        N = int(stdin.readline().strip())\n        coordinates = [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n        flowers = count_flowers(coordinates)\n        return flowers\n\n    return '\\n'.join(map(str, main()))"
    },
    {
        "number": 3578,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, R, F = map(int, lines[0].split())\n    flights = []\n    for i in range(1, R + 1):\n        a, b, c = map(int, lines[i].split())\n        flights.append((a, b, c))\n    additional_flights = []\n    for i in range(R + 1, R + F + 1):\n        a, b, c = map(int, lines[i].split())\n        additional_flights.append((a, b, c))\n\n    def dfs(current_city, visited, cost):\n        if current_city == 1:\n            return cost\n        min_cost = float('inf')\n        for flight in flights + additional_flights:\n            if flight[0] == current_city and flight[1] not in visited:\n                new_visited = visited.copy()\n                new_visited.add(flight[1])\n                new_cost = dfs(flight[1], new_visited, cost + flight[2])\n                min_cost = min(min_cost, new_cost)\n        return min_cost\n\n    return str(dfs(1, {1}, 0))"
    },
    {
        "number": 3579,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[:2])\n    a, b = map(int, stdin.split()[2:4])\n    grid = [list(map(int, line.split())) for line in stdin.split('\\n')[4:]]\n\n    def density(rect):\n        return sum(grid[y][x] for y in range(rect[0], rect[0] + rect[2]) for x in range(rect[1], rect[1] + rect[3])) / (rect[2] * rect[3])\n\n    def is_valid(rect):\n        return a <= rect[2] * rect[3] <= b\n\n    def is_covered(rect):\n        return all(grid[y][x] == 0 for y in range(rect[0], rect[0] + rect[2]) for x in range(rect[1], rect[1] + rect[3]))\n\n    def helper(rects):\n        if not rects:\n            return []\n        x, y, w, h = rects[0]\n        rects.pop(0)\n        result = []\n        for dx in range(w):\n            for dy in range(h):\n                new_rect = (x + dx, y + dy, 1, 1)\n                if is_valid(new_rect) and not is_covered(new_rect):\n                    result.append(new_rect)\n        return result + helper(rects)\n\n    rects = helper([(0, 0, h, w)])\n    densities = [density(rect) for rect in rects]\n    densities.sort()\n    n = len(densities)\n    if n % 2 == 0:\n        return str((densities[n // 2 - 1] + densities[n // 2]) / 2)\n    else:\n        return str(densities[n // 2])"
    },
    {
        "number": 3580,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    q = int(stdin.split('\\n')[2])\n    result = []\n\n    for i in range(3, 3 + q):\n        line = stdin.split('\\n')[i]\n        start_index, m = map(int, line.split()[:2])\n        b = set(map(int, line.split()[2:]))\n        max_length = 0\n\n        for j in range(start_index, n):\n            if a[j] in b:\n                max_length += 1\n            else:\n                break\n\n        result.append(max_length)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3581,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbors(hole_number, holes):\n        neighbors = []\n        if hole_number > 1:\n            neighbors.append(hole_number - 1)\n        if hole_number < len(holes):\n            neighbors.append(hole_number + 1)\n        if hole_number > holes[hole_number - 1]:\n            neighbors.append(hole_number - holes[hole_number - 1])\n        if hole_number < len(holes) - holes[::-1].index(len(holes) - hole_number):\n            neighbors.append(hole_number + holes[::-1].index(len(holes) - hole_number))\n        return neighbors\n\n    def expected_value(holes, probabilities, expected_values, hole_number, bounces):\n        if bounces == 0:\n            return holes[hole_number - 1]\n        if expected_values[hole_number - 1][bounces] is not None:\n            return expected_values[hole_number - 1][bounces]\n\n        neighbors = get_neighbors(hole_number, holes)\n        expected_value = 0\n        for neighbor in neighbors:\n            expected_value += probabilities[hole_number - 1][neighbor - 1] * expected_value(holes, probabilities, expected_values, neighbor, bounces - 1)\n        expected_value += probabilities[hole_number - 1][-1] * holes[hole_number - 1]\n\n        expected_values[hole_number - 1][bounces] = expected_value\n        return expected_value\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    holes = list(map(int, lines[1].split()))\n    probabilities = [list(map(float, lines[i + 2].split())) for i in range(N)]\n\n    expected_values = [[None] * (N + 1) for _ in range(len(holes))]\n    return f\"{expected_value(holes, probabilities, expected_values, 1, N):.10f}\""
    },
    {
        "number": 3582,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph, start):\n        visited = [False] * n\n        stack = [False] * n\n        for i in range(n):\n            if not visited[i]:\n                cycle = set()\n                if find_cycle_util(graph, i, visited, stack, cycle):\n                    return cycle\n        return set()\n\n    def find_cycle_util(graph, node, visited, stack, cycle):\n        visited[node] = True\n        stack[node] = True\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if find_cycle_util(graph, neighbor, visited, stack, cycle):\n                    return True\n            elif stack[neighbor]:\n                cycle.add(neighbor)\n                return True\n\n        stack[node] = False\n        return False\n\n    def get_best_assignment(n, a, graph):\n        best_assignment = a.copy()\n        for i in range(1, n):\n            if best_assignment[i] == i:\n                cycle = find_cycle(graph, i)\n                if cycle:\n                    for j in cycle:\n                        if j < i and (best_assignment[i] == i or a[i] == i):\n                            best_assignment[i] = j\n                            break\n        return best_assignment\n\n    def get_graph(n, a):\n        graph = [set() for _ in range(n)]\n        for i in range(n):\n            graph[a[i]].add(i)\n        return graph\n\n    stdin = stdin.split('\\n')\n    n = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n\n    graph = get_graph(n, a)\n    best_assignment = get_best_assignment(n, a, graph)\n\n    return ' '.join(map(str, best_assignment))"
    },
    {
        "number": 3583,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def circumference(a, b, c, d, e, f):\n        return distance(a, b) + distance(b, c) + distance(c, d) + distance(d, e) + distance(e, f) + distance(f, a)\n\n    n = int(stdin.readline())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    max_circumference = [0] * n\n    for i in range(n):\n        max_circumference[i] = max(circumference(points[(i - 5) % n], points[(i - 4) % n], points[(i - 3) % n], points[(i - 2) % n], points[(i - 1) % n], points[i]),\n                                                  circumference(points[(i - 4) % n], points[(i - 3) % n], points[(i - 2) % n], points[(i - 1) % n], points[i], points[(i + 1) % n]),\n                                                  circumference(points[(i - 3) % n], points[(i - 2) % n], points[(i - 1) % n], points[i], points[(i + 1) % n], points[(i + 2) % n]),\n                                                  circumference(points[(i - 2) % n], points[(i - 1) % n], points[i], points[(i + 1) % n], points[(i + 2) % n], points[(i + 3) % n]),\n                                                  circumference(points[(i - 1) % n], points[i], points[(i + 1) % n], points[(i + 2) % n], points[(i + 3) % n], points[(i + 4) % n]),\n                                                  circumference(points[i], points[(i + 1) % n], points[(i + 2) % n], points[(i + 3) % n], points[(i + 4) % n], points[(i + 5) % n]))\n\n    return '\\n'.join(map(str, max_circumference))"
    },
    {
        "number": 3584,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n    def cross_product(a, b, c):\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\n    def convex_hull(points):\n        hull = []\n        for p in points:\n            while len(hull) > 1 and cross_product(hull[-2], hull[-1], p) <= 0:\n                hull.pop()\n            hull.append(p)\n        return hull\n\n    def is_inside(point, hull):\n        for i in range(len(hull)):\n            a = hull[i]\n            b = hull[(i + 1) % len(hull)]\n            if cross_product(a, b, point) < 0:\n                return False\n        return True\n\n    def max_onions(onions, posts, k):\n        hull = convex_hull(posts)\n        upgraded = set()\n        for i in range(len(hull)):\n            a = hull[i]\n            b = hull[(i + 1) % len(hull)]\n            for j in range(len(onions)):\n                if is_inside(onions[j], [a, b]):\n                    upgraded.add(j)\n        return len(upgraded)\n\n    data = [line.split() for line in stdin.split('\\n') if line]\n    N, M, K = map(int, data[0])\n    onions = [(int(x), int(y)) for x, y in data[1:N + 1]]\n    posts = [(int(x), int(y)) for x, y in data[N + 1:N + M + 1]]\n\n    return str(max_onions(onions, posts, K))"
    },
    {
        "number": 3585,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    max_bags = 0\n\n    for i in range(1, m + 1):\n        max_bags += i * k\n        if max_bags >= m:\n            break\n\n    return str(max_bags % 998244353)"
    },
    {
        "number": 3586,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    S = set(map(int, stdin.readlines()))\n\n    max_d = -float('inf')\n    for a in S:\n        for b in S:\n            for c in S:\n                if a != b and b != c and c != a:\n                    d = a + b + c\n                    if d in S and d > max_d:\n                        max_d = d\n\n    if max_d == -float('inf'):\n        return \"no solution\"\n    else:\n        return str(max_d)"
    },
    {
        "number": 3587,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s: str, taboo_strings: List[str]) -> bool:\n        for taboo in taboo_strings:\n            if taboo in s:\n                return False\n        return True\n\n    def generate_clues(length: int, taboo_strings: List[str]) -> str:\n        if length == 0:\n            return \"\"\n\n        for i in range(2):\n            bit = str(i)\n            for clue in generate_clues(length - 1, taboo_strings):\n                if is_valid(bit + clue, taboo_strings):\n                    return bit + clue\n\n        return None\n\n    def longest_clue(taboo_strings: List[str]) -> str:\n        max_length = 0\n        longest_clues = []\n\n        for length in range(1, len(taboo_strings) + 1):\n            clue = generate_clues(length, taboo_strings)\n            if clue is not None:\n                if len(clue) > max_length:\n                    max_length = len(clue)\n                    longest_clues = [clue]\n                elif len(clue) == max_length:\n                    longest_clues.append(clue)\n\n        if not longest_clues:\n            return -1\n\n        return min(longest_clues)\n\n    N = int(stdin.readline().strip())\n    taboo_strings = [stdin.readline().strip() for _ in range(N)]\n\n    return longest_clue(taboo_strings) "
    },
    {
        "number": 3588,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_data = list(map(int, stdin.split()))\n    C = input_data[0]\n    input_data = input_data[1:]\n\n    # Initialize variables\n    total_shares = [0] * 366\n    current_index = 0\n\n    # Iterate through each company's records\n    for _ in range(C):\n        K = input_data[current_index]\n        current_index += 1\n\n        for _ in range(K):\n            N, D = input_data[current_index], input_data[current_index + 1]\n            current_index += 2\n            total_shares[D] += N\n\n    # Print the share totals\n    output = [str(total_shares[i]) for i in range(1, 366) if total_shares[i] > 0]\n    return \" \".join(output)"
    },
    {
        "number": 3589,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = [0] * 10\n\n    for x in range(L, R + 1):\n        product = 1\n        for digit in str(x):\n            if digit != '0':\n                product *= int(digit)\n        while product > 9:\n            temp_product = 1\n            for digit in str(product):\n                temp_product *= int(digit)\n            product = temp_product\n        count[product] += 1\n\n    return ' '.join(map(str, count[1:]))"
    },
    {
        "number": 3590,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_inside(polygon, point):\n        n = len(polygon)\n        inside = False\n        p2 = polygon[0]\n        for i in range(1, n + 1):\n            p1, p2 = p2, polygon[i % n]\n            if (p1[1] <= point[1] < p2[1]) or (p2[1] <= point[1] < p1[1]):\n                if p1[0] + (point[1] - p1[1]) / (p2[1] - p1[1]) * (p2[0] - p1[0]) < point[0]:\n                    inside = not inside\n        return inside\n\n    def min_cost(A, B):\n        n = len(A)\n        m = len(B)\n        min_cost = float('inf')\n        for i in range(n):\n            for j in range(m):\n                p1, p2 = B[j], B[(j + 1) % m]\n                if is_inside(A, p1) and is_inside(A, p2):\n                    cut_cost = distance(p1, p2)\n                    min_cost = min(min_cost, cut_cost + min_cost(A, B[:j] + B[j + 1:]))\n        return min_cost\n\n    input_list = [line.strip().split() for line in stdin.split('\\n') if line.strip()]\n    a = int(input_list[0][0])\n    A = [(int(x), int(y)) for x, y in input_list[1:a + 1]]\n    b = int(input_list[a + 1][0])\n    B = [(int(x), int(y)) for x, y in input_list[a + 2:a + b + 2]]\n\n    return f\"{min_cost(A, B):.6f}\""
    },
    {
        "number": 3591,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(heights: List[int]) -> bool:\n        alice_index = -1\n        bob_index = -1\n        for i, height in enumerate(heights):\n            if height > heights[0]:\n                alice_index = i\n                break\n        for i, height in enumerate(reversed(heights)):\n            if height > heights[-1]:\n                bob_index = len(heights) - i - 1\n                break\n        return alice_index != -1 and bob_index != -1 and alice_index < bob_index\n\n    k = int(stdin.readline().strip())\n    valid_photos = []\n\n    for i in range(k):\n        n = int(stdin.readline().strip())\n        heights = list(map(int, stdin.readline().strip().split()))\n        if is_valid(heights):\n            valid_photos.append(i)\n\n    return f\"{len(valid_photos)}\\n{' '.join(map(str, valid_photos))}\""
    },
    {
        "number": 3592,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    profit, pita_profit, pizza_profit = map(float, stdin.split())\n    pitas = 0\n    pizzas = 0\n    while pizzas * pizza_profit <= profit:\n        pizzas += 1\n    pizzas -= 1\n    while pitas * pita_profit <= profit - pizzas * pizza_profit:\n        pitas += 1\n    pitas -= 1\n    combinations = []\n    for i in range(pitas + 1):\n        j = (profit - pita_profit * i) / pizza_profit\n        if j.is_integer():\n            combinations.append((i, int(j)))\n    combinations.sort(key=lambda x: x[0])\n    output = []\n    for combination in combinations:\n        output.append(\"{} {}\".format(combination[0], combination[1]))\n    return \"\\n\".join(output) if output else \"none\""
    },
    {
        "number": 3593,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    board = [list(map(int, stdin.readline().split())) for _ in range(N)]\n\n    def is_valid(x: int, y: int, dx: int, dy: int) -> bool:\n        for _ in range(2):\n            x += dx\n            y += dy\n            if not (0 <= x < N and 0 <= y < 3):\n                return False\n            if board[x][y] != -1:\n                return False\n        return True\n\n    def dfs(x: int, y: int, k: int) -> int:\n        if k == 0:\n            return 0\n\n        max_sum = 0\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            if is_valid(x, y, dx, dy):\n                for i in range(2):\n                    board[x][y] = 1\n                    x += dx\n                    y += dy\n                max_sum = max(max_sum, dfs(x - dx, y - dy, k - 1))\n                for i in range(2):\n                    board[x][y] = -1\n                    x -= dx\n                    y -= dy\n        return max_sum\n\n    result = dfs(0, 0, K)\n    return str(result)"
    },
    {
        "number": 3594,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    players = [\"Odd\", \"Even\", \"Ingmariay\"]\n    scores = [0, 0, 0]\n    for i in range(int(stdin.split('\\n')[0])):\n        line = stdin.split('\\n')[i + 1].split()\n        start_player = line[0]\n        start_number = int(line[1])\n        if start_number == 1:\n            for j in range(len(players)):\n                scores[j] += 1\n        else:\n            current_player = players.index(start_player)\n            current_number = start_number\n            while current_number > 1:\n                if current_number % 2 == 0:\n                    current_number //= 2\n                else:\n                    for p in range(current_number - 1, 1, -1):\n                        if is_prime(p) and current_number % p == 0:\n                            current_number //= p\n                            break\n                current_player = (current_player + 1) % 3\n            scores[current_player] += 1\n    return f\"{scores[0]} {scores[1]} {scores[2]}\"\n\ndef"
    },
    {
        "number": 3595,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_point_in_room(x, y, room):\n        return room[0] <= x <= room[1] and room[2] <= y <= room[3]\n\n    def is_line_in_room(x1, y1, x2, y2, room):\n        return is_point_in_room(x1, y1, room) and is_point_in_room(x2, y2, room)\n\n    def is_line_intersect_room(x1, y1, x2, y2, room):\n        if is_line_in_room(x1, y1, x2, y2, room):\n            return True\n\n        if is_point_in_room(x1, y1, room) or is_point_in_room(x2, y2, room):\n            if x1 == x2 or y1 == y2:\n                return True\n\n            if x1 < x2:\n                x1, x2 = x2, x1\n            if y1 < y2:\n                y1, y2 = y2, y1\n\n            if x1 - x2 >= y2 - y1:\n                for y in range(y1, y2):\n                    if is_point_in_room(x2, y, room):\n                        return True\n            else:\n                for x in range(x1, x2):\n                    if is_point_in_room(x, y2, room):\n                        return True\n\n        return False\n\n    def count_rooms_hit(x, y, angle, rooms):\n        count = 0\n        for room in rooms:\n            if is_line_intersect_room(x, y, x + 10 * math.cos(angle), y + 10 * math.sin(angle), room):\n                count += 1\n        return count\n\n    r, l = map(int, stdin.readline().split())\n    rooms = []\n    for _ in range(r):\n        x1, y1, x2, y2 = map(int, stdin.readline().split())\n        rooms.append((x1, y1, x2, y2))\n\n    max_count = 0\n    for x in range(1001):\n        for y in range(1001):\n            for angle in range(361):\n                count = count_rooms_hit(x, y, angle * math.pi / 180, rooms)\n                max_count = max(max_count, count)\n\n    return str(max_count)"
    },
    {
        "number": 3596,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, t1, t2, t3, t4, n, k, r, s, l = map(float, stdin.split())\n\n    from math import sqrt, pi, cos, log, exp\n    from scipy.special import erf, gamma, jv\n\n    def f(x):\n        return c * (x * gamma(t1) + sqrt(log(erf(t2 * x))) - jv(t3, x) ** t4)\n\n    def p(x):\n        return sum(f(0).diff(x, i) / i! * x ** i for i in range(r + 1))\n\n    def pn(n):\n        return sum(pn(n - 1).diff(x, i) / i! * x ** i for i in range(r + n + 1))\n\n    def g(s):\n        return pn(s).diff(x, r + 1)\n\n    location = (g(s)(n) + l) ** 2 / (pi * exp(1)) + 1 / (l + 1)\n    return f\"{location:.2f}\""
    },
    {
        "number": 3597,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, l, r, x1, y1, x2, y2, x3, y3, h = map(float, stdin.split())\n    d = None\n    theta = None\n\n    # Your code here\n\n    return f\"{d} {theta}\" if d and theta else \"impossible\""
    },
    {
        "number": 3598,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    magnets = []\n    for i in range(n):\n        magnets.append(stdin.readline().strip())\n\n    # Replace 6 and 9 with '?' to make it easier to distinguish them from their upside-down counterparts\n    for i in range(n):\n        magnets[i] = magnets[i].replace('6', '?')\n        magnets[i] = magnets[i].replace('9', '?')\n\n    # Generate all possible combinations of the magnets\n    def generate_combinations(magnets):\n        if len(magnets) == 1:\n            return [magnets[0], magnets[0][::-1]]\n        else:\n            combinations = []\n            for i in range(len(magnets)):\n                for c in generate_combinations(magnets[:i] + magnets[i+1:]):\n                    combinations.append(magnets[i] + c)\n                    combinations.append(magnets[i][::-1] + c)\n            return combinations\n\n    # Find the minimum price by trying all combinations\n    min_price = float('inf')\n    for c in generate_combinations(magnets):\n        # Replace '?' with 6 and 9\n        c = c.replace('?', '6')\n        # Check if the price is valid (i.e. no consecutive zeros)\n        valid = True\n        for i in range(len(c)-1):\n            if c[i] == '0' and c[i+1] == '0':\n                valid = False\n                break\n        if valid:\n            min_price = min(min_price, int(c))\n\n    return str(min_price)"
    },
    {
        "number": 3599,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, N = map(int, stdin.split())\n    breaks = list(map(int, input().split()))\n\n    # Sort the breaks in descending order\n    breaks.sort(reverse=True)\n\n    # Initialize the time spent on stage for each musician\n    time_spent = [0] * N\n\n    # Iterate through the breaks\n    for i in range(N):\n        # Find the time the musician will spend on stage before going on the break\n        time_spent[i] = T - breaks[i]\n\n        # Check if the time spent on stage for the current musician will cause trouble\n        if i >= 2 and time_spent[i] + time_spent[i - 1] + time_spent[i - 2] > T:\n            # Move the current musician's break start time earlier\n            breaks[i] -= (time_spent[i] + time_spent[i - 1] + time_spent[i - 2]) - T\n\n    # Return the time spent on stage for each musician\n    return \" \".join(map(str, time_spent))"
    },
    {
        "number": 3600,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(drone_positions: set, intersection: int, neighbours: set) -> bool:\n        for neighbour in neighbours:\n            if neighbour in drone_positions:\n                return False\n        return True\n\n    def dfs(k: int, current: int, drones_placed: set, intersections: list) -> bool:\n        if k == 0:\n            return True\n\n        if current > n:\n            return False\n\n        if len(intersections[current - 1]) == 0:\n            return dfs(k, current + 1, drones_placed, intersections)\n\n        for neighbour in intersections[current - 1]:\n            if is_valid(drones_placed, neighbour, intersections[neighbour - 1]):\n                drones_placed.add(neighbour)\n                if dfs(k - 1, current + 1, drones_placed, intersections):\n                    return True\n                drones_placed.remove(neighbour)\n\n        return False\n\n    lines = stdin.split('\\n')\n    k = int(lines[0])\n    n = int(lines[1])\n    intersections = [set() for _ in range(n + 1)]\n\n    for i in range(2, n + 2):\n        line = lines[i].split()\n        d = int(line[0])\n        for j in range(1, d + 1):\n            intersections[i - 1].add(int(line[j]))\n            intersections[int(line[j]) - 1].add(i - 1)\n\n    if dfs(k, 1, set(), intersections):\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3601,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def find_intersection(misha_path, nadia_path):\n        min_time = float('inf')\n        for i in range(len(misha_path) - 1):\n            for j in range(len(nadia_path) - 1):\n                misha_segment = misha_path[i], misha_path[i + 1]\n                nadia_segment = nadia_path[j], nadia_path[j + 1]\n                intersection = find_intersection_segments(misha_segment, nadia_segment)\n                if intersection:\n                    time = misha_path[i][2] + distance(*misha_path[i], *intersection)\n                    time += distance(*intersection, *nadia_path[j]) + nadia_path[j][2]\n                    min_time = min(min_time, time)\n        return min_time\n\n    def find_intersection_segments(misha_segment, nadia_segment):\n        x1, y1, t1 = misha_segment[0]\n        x2, y2, t2 = misha_segment[1]\n        x3, y3, t3 = nadia_segment[0]\n        x4, y4, t4 = nadia_segment[1]\n\n        denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if denominator == 0:\n            return None\n\n        t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator\n        u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator\n\n        if 0 <= t <= 1 and 0 <= u <= 1:\n            intersection_x = x1 + t * (x2 - x1)\n            intersection_y = y1 + t * (y2 - y1)\n            return intersection_x, intersection_y, t1 + t * (t2 - t1)\n        else:\n            return None\n\n    misha_path, nadia_path = [[(x, y, i / len(misha_path)) for i, (x, y) in enumerate(misha_path)] for misha_path in stdin.strip().split('\\n\\n')]\n    min_time = find_intersection(misha_path, nadia_path)\n    return f\"{min_time:.5f}\" if min_time != float('inf') else \"impossible\""
    },
    {
        "number": 3602,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(grid, row, col, reach):\n        for i in range(max(0, row - reach), min(row + reach + 1, len(grid))):\n            for j in range(max(0, col - reach), min(col + reach + 1, len(grid[0]))):\n                if grid[i][j] == 2:\n                    return False\n        return True\n\n    def light_lamps(grid, lamps, reach):\n        for lamp in lamps:\n            row, col = lamp\n            if grid[row][col] == 0:\n                grid[row][col] = 1\n                if not is_valid(grid, row, col, reach):\n                    grid[row][col] = 0\n                    return False\n        return True\n\n    n, r, k = map(int, stdin.split()[0].split())\n    lamps = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n    grid = [[0] * n for _ in range(n)]\n\n    for lamp in lamps:\n        row, col = lamp\n        grid[row][col] = 2\n\n    if light_lamps(grid, lamps, r):\n        return \"1\"\n    else:\n        return \"0\""
    },
    {
        "number": 3603,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_pair(translators, language_pairs):\n        for i in range(len(translators)):\n            for j in range(i + 1, len(translators)):\n                if translators[i][1] == translators[j][0] and translators[i][0] == translators[j][1]:\n                    language_pairs.append([translators[i][2], translators[j][2]])\n                    translators.pop(i)\n                    translators.pop(j - 1)\n                    return True\n        return False\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    translators = [list(map(int, line.split())) + [i] for i, line in enumerate(lines[1:])]\n    translators.sort(key=lambda x: (x[0], x[1]))\n\n    language_pairs = []\n    while translators:\n        if not find_pair(translators, language_pairs):\n            return \"impossible\"\n\n    return '\\n'.join([' '.join(map(str, pair)) for pair in language_pairs])"
    },
    {
        "number": 3604,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.readline().split())\n    sensors = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def can_communicate(s1, s2):\n        return sum((s1[i] - s2[i]) ** 2 for i in range(2)) <= d ** 2\n\n    def dfs(start, visited):\n        visited.add(start)\n        for i in range(start + 1, n):\n            if i not in visited and can_communicate(sensors[start], sensors[i]):\n                dfs(i, visited)\n        return visited\n\n    max_subset = set()\n    for i in range(n):\n        subset = dfs(i, set())\n        if len(subset) > len(max_subset):\n            max_subset = subset\n\n    return f\"{len(max_subset)}\\n{' '.join(map(str, sorted(max_subset)))}\\n\""
    },
    {
        "number": 3605,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    trees = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    min_diff = float('inf')\n    for i in range(n - k + 1):\n        min_diff = min(min_diff, trees[i + k - 1] - trees[i])\n\n    return str(min_diff)"
    },
    {
        "number": 3606,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    directions = stdin.readline().strip()\n    plants = [tuple(map(int, stdin.readline().split())) for _ in range(N)]\n\n    x, y = plants[0]\n    for direction in directions:\n        if direction == 'A':\n            x += 1\n        elif direction == 'B':\n            x += 1\n            y -= 1\n        elif direction == 'C':\n            x -= 1\n        elif direction == 'D':\n            x -= 1\n            y -= 1\n\n        if not (0 <= x <= 1000000000 and 0 <= y <= 1000000000):\n            break\n\n        for i, plant in enumerate(plants):\n            if plant == (x, y):\n                plants.pop(i)\n                break\n\n    return f\"{x} {y}\\n\""
    },
    {
        "number": 3607,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    variables = {chr(i): 0 for i in range(ord('A'), ord('Z') + 1)}\n    statements = []\n\n    for line in stdin.split('\\n'):\n        label, statement = line.split(' ', 1)\n        statements.append((int(label), statement))\n\n    statements.sort(key=lambda x: x[0])\n    output = []\n\n    for label, statement in statements:\n        if statement.startswith('LET'):\n            var, value = statement[4:].strip().split('=')\n            var = var.strip()\n            value = value.strip()\n\n            if value.isdigit():\n                variables[var] = int(value)\n            else:\n                variables[var] = variables[value]\n        elif statement.startswith('IF'):\n            condition, action = statement[3:].strip().split('THEN')\n            condition = condition.strip()\n            action = action.strip()\n\n            if '=' in condition:\n                x, y = condition.split('=')\n                x = x.strip()\n                y = y.strip()\n                if x.isdigit():\n                    x = int(x)\n                else:\n                    x = variables[x]\n                if y.isdigit():\n                    y = int(y)\n                else:\n                    y = variables[y]\n                if x == y:\n                    label = int(action.split('GOTO')[-1].strip())\n                    for l, s in statements:\n                        if l == label:\n                            break\n                    else:\n                        continue\n                    label, statement = l, s\n            else:\n                raise ValueError(\"Invalid condition\")\n        elif statement.startswith('PRINT'):\n            value = statement[6:].strip()\n            if value.startswith('\"') and value.endswith('\"'):\n                output.append(value[1:-1])\n            else:\n                output.append(str(variables[value]))\n        elif statement.startswith('PRINTLN'):\n            value = statement[7:].strip()\n            if value.startswith('\"') and value.endswith('\"'):\n                output.append(value[1:-1] + '\\n')\n            else:\n                output.append(str(variables[value]) + '\\n')\n        else:\n            raise ValueError(\"Invalid statement\")\n\n    return ''.join(output)"
    },
    {
        "number": 3608,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    tasks = list(map(int, stdin.split('\\n')[1].split()))\n    consecutive_tasks = list(map(int, stdin.split('\\n')[2].split()))\n\n    mod = 1000000007\n\n    dp = [0] * (N + 1)\n    dp[0] = 1\n\n    for i in range(N):\n        dp[i + 1] += dp[i] * tasks[i]\n        dp[i + 1] %= mod\n\n        if i < N - 1:\n            dp[i + 2] += dp[i] * consecutive_tasks[i]\n            dp[i + 2] %= mod\n\n    return str(dp[N])"
    },
    {
        "number": 3609,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(2 * (n - 1))]\n\n    def is_valid(left_edges, right_edges):\n        left_nodes = set()\n        right_nodes = set()\n        for u, v in left_edges:\n            if v in left_nodes or u in right_nodes:\n                return False\n            left_nodes.add(u)\n            left_nodes.add(v)\n        for u, v in right_edges:\n            if v in right_nodes or u in left_nodes:\n                return False\n            right_nodes.add(u)\n            right_nodes.add(v)\n        return True\n\n    for i in range(2 ** (n - 1)):\n        left_edges = [edges[j] for j in range(2 * (n - 1)) if (i >> j) & 1]\n        right_edges = [edges[j] for j in range(2 * (n - 1)) if not (i >> j) & 1]\n        if is_valid(left_edges, right_edges):\n            return ''.join(['L' if (i >> j) & 1 else 'R' for j in range(2 * (n - 1))])\n    return \"impossible\""
    },
    {
        "number": 3610,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def invite_people(teams, friend_id):\n        team_members = set()\n        for team in teams:\n            team_members.add(team[0])\n            team_members.add(team[1])\n        invitees = set()\n        for team in teams:\n            if team[0] == friend_id or team[1] == friend_id:\n                invitees.add(team[0])\n                invitees.add(team[1])\n        if len(invitees) == 0:\n            invitees.add(team_members.pop())\n        return len(invitees), invitees\n\n    def parse_input(stdin):\n        lines = stdin.split(\"\\n\")\n        m = int(lines[0])\n        teams = [list(map(int, line.split())) for line in lines[1:]]\n        return m, teams\n\n    m, teams = parse_input(stdin)\n    k, invitees = invite_people(teams, 1009)\n    return f\"{k}\\n{' '.join(map(str, invitees))}\""
    },
    {
        "number": 3611,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, s, t = map(int, stdin.split()[:4])\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v, w = map(int, stdin.split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = [float('inf')] * N\n    dist[s] = 0\n    visited = [False] * N\n    queue = [(0, s)]\n\n    while queue:\n        d, node = heapq.heappop(queue)\n        if visited[node]:\n            continue\n        visited[node] = True\n        for neighbor, weight in graph[node]:\n            if dist[node] + weight < dist[neighbor]:\n                dist[neighbor] = dist[node] + weight\n                heapq.heappush(queue, (dist[neighbor], neighbor))\n\n    path = set()\n    node = t\n    while node != s:\n        for neighbor, weight in graph[node]:\n            if dist[node] == dist[neighbor] + weight:\n                path.add(node)\n                node = neighbor\n                break\n\n    return ' '.join(map(str, sorted(list(path))))"
    },
    {
        "number": 3612,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def euclidean_distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_safe(x1, y1, x2, y2, height_map):\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if height_map[i][j] > 1:\n                    return False\n        return True\n\n    def find_max_distance(a, m, W, H, X, Y, height_map):\n        max_distance = 0\n        for i in range(W):\n            for j in range(H):\n                if (i, j) != (X, Y):\n                    distance = euclidean_distance(i, j, X, Y)\n                    if is_safe(i, j, X + W - 1, Y + H - 1, height_map):\n                        max_distance = max(max_distance, distance)\n        return max_distance\n\n    input_data = list(map(str, stdin.split()))\n    a, m = float(input_data[0]), float(input_data[1])\n    W, H, X, Y = int(input_data[2]), int(input_data[3]), int(input_data[4]), int(input_data[5])\n    height_map = [list(map(int, input_data[6 + i].split())) for i in range(H)]\n\n    max_distance = find_max_distance(a, m, W, H, X, Y, height_map)\n    return str(int(max_distance))"
    },
    {
        "number": 3613,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_best_partition(teachers, preferences, n):\n        min_T = float('inf')\n        for T in range(1, n):\n            is_valid = True\n            for i in range(n):\n                if teachers[i] == teachers[preferences[i][T]]:\n                    is_valid = False\n                    break\n            if is_valid:\n                min_T = min(min_T, T)\n        return min_T\n\n    def parse_input(stdin):\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        teachers = [0] * n\n        preferences = [[] for _ in range(n)]\n        for i in range(n):\n            line = lines[i + 1].split()\n            teachers[i] = int(line[0])\n            for j in range(n - 1):\n                preferences[i].append(int(line[j + 1]))\n        return teachers, preferences, n\n\n    teachers, preferences, n = parse_input(stdin)\n    min_T = find_best_partition(teachers, preferences, n)\n    return str(min_T)"
    },
    {
        "number": 3614,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(r1, c1, r2, c2, petals):\n        if abs(r1 - r2) == 1 and abs(c1 - c2) > 1:\n            return petals[r2][c2] > petals[r1][c1]\n        elif abs(c1 - c2) == 1 and abs(r1 - r2) > 1:\n            return petals[r2][c2] > petals[r1][c1]\n        return False\n\n    def dfs(r, c, visited, petals):\n        if (r, c) in visited:\n            return visited[(r, c)]\n\n        visited[(r, c)] = 1\n        for r2, c2 in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:\n            if 0 < r2 <= N and 0 < c2 <= N and not visited.get((r2, c2)) and is_valid_move(r, c, r2, c2, petals):\n                visited[(r2, c2)] = max(visited[(r2, c2)], visited[(r, c)] + 1)\n                dfs(r2, c2, visited, petals)\n\n        return visited[(r, c)]\n\n    N = int(stdin.readline().strip())\n    R, C = map(int, stdin.readline().strip().split())\n    petals = [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n\n    visited = {}\n    return str(dfs(R, C, visited, petals))"
    },
    {
        "number": 3615,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_valid(towers, new_tower):\n        for tower in towers:\n            if distance(tower, new_tower) < 1.0:\n                return False\n        return True\n\n    def find_connected_components(towers):\n        visited = [False] * len(towers)\n        components = []\n\n        def dfs(node, component):\n            visited[node] = True\n            component.append(node)\n            for neighbor in range(len(towers)):\n                if not visited[neighbor] and distance(towers[node], towers[neighbor]) <= 1.0:\n                    dfs(neighbor, component)\n\n        for i in range(len(towers)):\n            if not visited[i]:\n                component = []\n                dfs(i, component)\n                components.append(component)\n\n        return components\n\n    n = int(stdin.readline().strip())\n    towers = []\n    for _ in range(n):\n        x, y = map(float, stdin.readline().strip().split())\n        towers.append((x, y))\n\n    max_connected_components = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if distance(towers[i], towers[j]) > 1.0:\n                new_tower = ((towers[i][0] + towers[j][0]) / 2, (towers[i][1] + towers[j][1]) / 2)\n                if is_valid(towers, new_tower):\n                    new_towers = towers + [new_tower]\n                    components = find_connected_components(new_towers)\n                    max_connected_components = max(max_connected_components, len(components))\n\n    return str(max_connected_components)"
    },
    {
        "number": 3616,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    k, *durations = list(map(int, stdin.split()))\n    if k == 1:\n        return str(durations[0])\n\n    lcm_value = durations[0]\n    for i in range(1, k):\n        lcm_value = lcm(lcm_value, durations[i])\n\n    return str(lcm_value)"
    },
    {
        "number": 3617,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split())\n    A, B, C, t0 = map(int, input().split())\n\n    t = [t0]\n    for i in range(1, N):\n        t.append(((A * t[-1] + B) % C) + 1)\n\n    total_time = sum(t)\n    if total_time > T:\n        return \"0 0\"\n\n    penalty = 0\n    problems_solved = 0\n    current_time = 0\n\n    for i in range(N):\n        if current_time + t[i] <= T:\n            current_time += t[i]\n            penalty += current_time\n            problems_solved += 1\n        else:\n            break\n\n    return f\"{problems_solved} {penalty % 1000000007}\""
    },
    {
        "number": 3618,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    total_pairs = 0\n\n    for i in range(1, 10**n):\n        str_i = str(i)\n        if len(str_i) == n:\n            for j in range(n - 1):\n                if int(str_i[j]) + int(str_i[j + 1]) == 10:\n                    total_pairs += 1\n\n    return str(total_pairs % 998244353)"
    },
    {
        "number": 3619,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def round_half_up(n, decimals=3):\n        multiplier = 10 ** decimals\n        return math.floor(n * multiplier + 0.5) / multiplier\n\n    def find_max_value(k, n, candidates):\n        candidates.sort(key=lambda x: x[1], reverse=True)\n        total_value = 0\n        team = []\n\n        for candidate in candidates:\n            if candidate[3] == 0 or candidate[3] in team:\n                team.append(candidate[0])\n                total_value += candidate[1] / candidate[2]\n                if len(team) == k:\n                    break\n\n        return round_half_up(total_value)\n\n    input_data = list(map(str.strip, stdin.split('\\n')))\n    k, n = map(int, input_data[0].split())\n    candidates = [list(map(int, line.split())) for line in input_data[1:]]\n\n    max_value = find_max_value(k, n, candidates)\n\n    return f\"{max_value:.3f}\""
    },
    {
        "number": 3620,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, k, P = map(int, stdin.split()[0:4])\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        u, v = map(int, stdin.split()[4:6])\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, color, parent):\n        if color[node] != -1:\n            return color[node] == parent\n        color[node] = (color[parent] + 1) % k\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                if not dfs(neighbor, color, node):\n                    return False\n        return True\n\n    def is_valid(color):\n        for node in range(1, N + 1):\n            if color[node] == -1:\n                if not dfs(node, color, 0):\n                    return False\n        return True\n\n    def count_colorings(color):\n        if not is_valid(color):\n            return 0\n        count = 1\n        for node in range(1, N + 1):\n            if color[node] == -1:\n                for new_color in range(k):\n                    color[node] = new_color\n                    count = (count + count_colorings(color)) % P\n                color[node] = -1\n        return count\n\n    color = [-1] * (N + 1)\n    return count_colorings(color)"
    },
    {
        "number": 3621,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f(S):\n        max_subset = set()\n        for node in S:\n            if not max_subset:\n                max_subset.add(node)\n            else:\n                for neighbor in graph[node]:\n                    if neighbor in max_subset and colors[node][neighbor] == colors[list(max_subset)[0]][neighbor]:\n                        max_subset.add(node)\n                        break\n        return len(max_subset)\n\n    n = int(stdin.readline().strip())\n    colors = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j and colors[i][j] != 0:\n                graph[i].append(j)\n                graph[j].append(i)\n\n    total_sum = 0\n    for i in range(1, 2 ** n):\n        S = [j for j in range(n) if (i & (1 << j))]\n        total_sum += f(S)\n\n    return str(total_sum % (10 ** 9 + 7))"
    },
    {
        "number": 3622,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, u, d, l, r = map(int, stdin.split('\\n')[0].split())\n    probabilities = [u, d, l, r]\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def bounce(x, y, dx, dy):\n        new_x = x + dx\n        new_y = y + dy\n\n        if 0 <= new_x < w and 0 <= new_y < h:\n            if grid[new_y][new_x] != 'X':\n                return new_x, new_y\n        return x, y\n\n    def simulate_ball(x, y):\n        total_moves = 0\n        while grid[y][x] != 'T':\n            dx, dy = random.choices([-1, 0, 1], weights=probabilities)[0], random.choices([-1, 0, 1], weights=probabilities)[0]\n            x, y = bounce(x, y, dx, dy)\n            total_moves += 1\n            if total_moves > 10**9:\n                break\n\n        return total_moves\n\n    target_counts = [0] * len([x for x in grid[0] if x == 'T'])\n    for i, row in enumerate(grid):\n        if 'T' in row:\n            target_index = row.index('T')\n            target_counts[target_index] += simulate_ball(target_index, i)\n\n    total_moves = sum(target_counts)\n    target_probabilities = [count / total_moves for count in target_counts]\n\n    return '\\n'.join(f'{probability:.10f}' for probability in target_probabilities)"
    },
    {
        "number": 3623,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(float, stdin.split())\n    total_area = 2 * (a + b + c + d)\n    watered_area = a + b + c + d - 4 * (a * b / (a + b) + c * d / (c + d))\n    return str(watered_area / total_area)"
    },
    {
        "number": 3624,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    trails = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n    dp = [float('inf')] * n\n    dp[0] = 0\n\n    for i in range(12):\n        for u, v, d in trails:\n            if dp[u] != float('inf'):\n                dp[v] = min(dp[v], dp[u] + d)\n\n        if dp[-1] != float('inf'):\n            return str(i)\n\n    return str(-1)"
    },
    {
        "number": 3625,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_population(Y, I, S, B):\n        max_population = S + Y * I\n        return max_population\n\n    def get_max_harvest(N, populations):\n        max_harvest = 0\n        for i in range(N):\n            max_population = get_max_population(populations[i][0], populations[i][1], populations[i][2], populations[i][3])\n            max_harvest += max_population\n        return max_harvest\n\n    input_list = list(map(int, stdin.split()))\n    N = input_list[0]\n    populations = []\n    for i in range(1, len(input_list), 4):\n        populations.append([input_list[i], input_list[i + 1], input_list[i + 2], input_list[i + 3]])\n\n    max_harvest = get_max_harvest(N, populations)\n    return str(max_harvest)"
    },
    {
        "number": 3626,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    rectangles = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, stdin.readline().split())\n        rectangles.append((x1, y1, x2, y2))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if intersect(rectangles[i], rectangles[j]):\n                return \"1\"\n    return \"0\"\n\ndef"
    },
    {
        "number": 3627,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x, y, energy):\n        if energy < 0:\n            return float('inf')\n        if x == R - 1 and y == C - 1:\n            return energy\n        if (x, y) in visited:\n            return float('inf')\n        visited.add((x, y))\n        min_energy = float('inf')\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C and (nx, ny) not in visited:\n                min_energy = min(min_energy, dfs(nx, ny, energy - X[nx][ny]))\n        visited.remove((x, y))\n        return min_energy\n\n    R, C = map(int, stdin.readline().split())\n    X = [list(map(int, stdin.readline().split())) for _ in range(R)]\n    S = stdin.readline().strip()\n    start_points = [(i, j) for i in range(R) for j in range(C) if S[j] == 'S']\n    visited = set()\n    min_energy = float('inf')\n    for x, y in start_points:\n        min_energy = min(min_energy, dfs(x, y, 0))\n    return str(min_energy)"
    },
    {
        "number": 3628,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    pi = []\n    sigma = []\n\n    for i in range(n):\n        pi.append(a[i] - i)\n        sigma.append(a[i] - pi[i])\n\n    if len(set(pi)) == n and len(set(sigma)) == n:\n        return \" \".join(map(str, pi)) + \"\\n\" + \" \".join(map(str, sigma))\n    else:\n        return \"impossible\""
    },
    {
        "number": 3629,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def area_of_overlap(x1, y1, r1, x2, y2, r2):\n        d = distance(x1, y1, x2, y2)\n        if d >= r1 + r2:\n            return 0\n        elif d <= abs(r1 - r2) or d == 0:\n            return min(r1, r2) ** 2 * 3.141592653589793\n        else:\n            theta = 2 * math.acos((r1 ** 2 + d ** 2 - r2 ** 2) / (2 * r1 * d))\n            return theta * r1 ** 2 - r1 ** 2 * math.sin(theta)\n\n    def area_of_union(x1, y1, r1, x2, y2, r2):\n        return area_of_overlap(x1, y1, r1, x2, y2, r2) + r1 ** 2 * 3.141592653589793 + r2 ** 2 * 3.141592653589793\n\n    def probability(n, x, y, r, b, d):\n        total_area = 0\n        for i in range(n):\n            total_area += area_of_union(0, 0, b, x[i], y[i], r[i])\n        return 1 - total_area / (b ** 2 * 3.141592653589793)\n\n    stdin = stdin.split('\\n')\n    n = int(stdin[0])\n    x = []\n    y = []\n    r = []\n    for i in range(1, n + 1):\n        x_i, y_i, r_i = map(int, stdin[i].split())\n        x.append(x_i)\n        y.append(y_i)\n        r.append(r_i)\n    b, d = map(int, stdin[n + 1].split())\n\n    return str(probability(n, x, y, r, b, d))"
    },
    {
        "number": 3630,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2 = stdin.split()\n    n = len(s1)\n    s1 = [ord(c) for c in s1]\n    s2 = [ord(c) for c in s2]\n    moves = 0\n\n    for i in range(n):\n        if s1[i] == s2[i]:\n            continue\n        elif s1[i] == ord('z') or s2[i] == ord('a'):\n            moves += n - i\n            break\n        else:\n            moves += abs(s1[i] - s2[i])\n\n    return str(moves)"
    },
    {
        "number": 3631,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_visible(beacon1, beacon2, peaks):\n        x1, y1 = beacon1\n        x2, y2 = beacon2\n        for peak in peaks:\n            px, py, pr = peak\n            if (x1 - px) ** 2 + (y1 - py) ** 2 <= pr ** 2:\n                if (x2 - px) ** 2 + (y2 - py) ** 2 <= pr ** 2:\n                    continue\n                else:\n                    return False\n        return True\n\n    def light_beacons(beacons, peaks, lit_beacons):\n        new_lit_beacons = set()\n        for beacon in beacons:\n            if beacon in lit_beacons:\n                continue\n            for other_beacon in lit_beacons:\n                if is_visible(beacon, other_beacon, peaks):\n                    new_lit_beacons.add(beacon)\n                    break\n        return new_lit_beacons\n\n    def count_messages(beacons, peaks):\n        lit_beacons = set()\n        while len(lit_beacons) < len(beacons):\n            lit_beacons = light_beacons(beacons, peaks, lit_beacons)\n            if len(lit_beacons) == len(beacons):\n                return 0\n            else:\n                lit_beacons.add(min(beacons - lit_beacons, key=lambda b: (b[0], b[1])))\n                # print(f\"Lit beacon: {lit_beacons}\")\n        return len(beacons) - len(lit_beacons)\n\n    n, m = map(int, stdin.readline().strip().split())\n    beacons = set()\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        beacons.add((x, y))\n\n    peaks = []\n    for _ in range(m):\n        x, y, r = map(int, stdin.readline().strip().split())\n        peaks.append((x, y, r))\n\n    return str(count_messages(beacons, peaks))"
    },
    {
        "number": 3632,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    initial_strings = [stdin.readline().strip() for _ in range(n)]\n    test_string = stdin.readline().strip()\n\n    def count_composite_strings(choices: int) -> int:\n        result = 1\n        for i in range(choices):\n            result *= len(initial_strings) - i\n        return result\n\n    def generate_composite_strings(choices: int) -> list:\n        result = []\n        for i in range(len(initial_strings)):\n            for j in range(i + 1, len(initial_strings)):\n                for l in range(j + 1, len(initial_strings)):\n                    result.append(initial_strings[i] + initial_strings[j] + initial_strings[l])\n        return result\n\n    modulo = 10**9 + 7\n    total_composite_strings = count_composite_strings(k)\n    sorted_composite_strings = sorted(generate_composite_strings(k))\n    test_position = sorted_composite_strings.index(test_string)\n\n    return str((test_position + 1) * total_composite_strings)"
    },
    {
        "number": 3633,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def avg_score(order: List[int]) -> float:\n        score = 0\n        for i in range(n):\n            if i == 0:\n                score += m\n            else:\n                if i == order[i - 1]:\n                    score += m\n                else:\n                    score += a[i]\n        return score / n\n\n    def helper(order: List[int], start: int) -> List[int]:\n        if start == n:\n            if avg_score(order) == k / n:\n                return order\n            else:\n                return []\n\n        for i in range(start, n):\n            if i not in order:\n                order[start], order[i] = order[i], order[start]\n                res = helper(order, start + 1)\n                if res:\n                    return res\n                order[start], order[i] = order[i], order[start]\n\n        return []\n\n    order = [0] * n\n    res = helper(order, 0)\n    if res:\n        return ' '.join(map(str, res))\n    else:\n        return \"impossible\""
    },
    {
        "number": 3634,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(snow_log, n):\n        snow_log.sort()\n        count = 0\n        for i in range(n - 2):\n            if snow_log[i][1] < snow_log[i + 1][0]:\n                count += 1\n        return count\n\n    def is_valid(snow_log, n):\n        snow_log.sort()\n        for i in range(n - 1):\n            if snow_log[i][1] >= snow_log[i + 1][0]:\n                return False\n        return True\n\n    def mod_pow(a, b, c):\n        res = 1\n        while b > 0:\n            if b % 2 == 1:\n                res = (res * a) % c\n            a = (a * a) % c\n            b //= 2\n        return res\n\n    def mod_inverse(a, m):\n        return mod_pow(a, m - 2, m)\n\n    n = int(stdin.readline().strip())\n    snow_log = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        snow_log.append((a, b))\n\n    if n < 3:\n        return \"shovel time!\"\n\n    if is_valid(snow_log, n):\n        return count_ways(snow_log, n) % 1000000009\n    else:\n        return \"shovel time!\" "
    },
    {
        "number": 3635,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(briefcases: List[int], executives: int, min_evil: int) -> bool:\n        evil_executives = 0\n        total_bananas = 0\n        for i in range(executives):\n            if i < min_evil:\n                evil_executives += 1\n            total_bananas += briefcases[i]\n        return evil_executives >= min_evil and total_bananas % executives == 0\n\n    def binary_search(briefcases: List[int], executives: int) -> int:\n        left, right = 0, executives\n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(briefcases, executives, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    N, briefcases = map(int, stdin.split())\n    briefcases = list(map(int, briefcases.split()))\n    return str(binary_search(briefcases, N))"
    },
    {
        "number": 3636,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    MOD = p\n\n    def count_ways(n, m):\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        dp[2][2] = 1\n\n        for i in range(2, n + 1):\n            for j in range(2, m + 1):\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n\n        return dp[n][m]\n\n    def count_obstacles(n, m):\n        total_cells = n * m\n        empty_cells = count_ways(n, m)\n        obstacles = total_cells - empty_cells\n\n        return obstacles\n\n    result = count_obstacles(n, m)\n    return f\"{result % MOD}\""
    },
    {
        "number": 3637,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_wishes(wishes: str) -> int:\n        return len(wishes) // 2\n\n    def count_fulfilled_wishes(wishes: str, toppings: set) -> int:\n        count = 0\n        for i in range(0, len(wishes), 2):\n            if wishes[i] == \"+\" and wishes[i + 1:] in toppings:\n                count += 1\n            elif wishes[i] == \"-\" and wishes[i + 1:] not in toppings:\n                count += 1\n        return count\n\n    def find_toppings(friends: list) -> set:\n        toppings = set()\n        for friend in friends:\n            wishes = friend.split()\n            for i in range(1, len(wishes), 2):\n                toppings.add(wishes[i])\n        return toppings\n\n    def find_fulfillable_toppings(friends: list, toppings: set) -> set:\n        fulfillable_toppings = set()\n        for friend in friends:\n            wishes = friend.split()\n            num_wishes = count_wishes(wishes)\n            for i in range(1, len(wishes), 2):\n                if count_fulfilled_wishes(wishes, fulfillable_toppings) >= num_wishes * 2 / 3:\n                    break\n                if wishes[i - 1] == \"+\":\n                    fulfillable_toppings.add(wishes[i])\n        return fulfillable_toppings\n\n    def main(stdin: str) -> str:\n        num_friends = int(stdin.readline().strip())\n        friends = [stdin.readline().strip() for _ in range(num_friends)]\n        toppings = find_toppings(friends)\n        fulfillable_toppings = find_fulfillable_toppings(friends, toppings)\n        return \"\\n\".join(sorted(fulfillable_toppings))\n\n    return main(stdin) "
    },
    {
        "number": 3638,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.readline().split())\n    predictions = [stdin.readline().strip() for _ in range(s)]\n\n    def count_subsequences(sequence: str, n: int) -> int:\n        count = 0\n        for i in range(n - len(sequence) + 1):\n            if all(stdin[j] == sequence[j - i] for j in range(i, i + len(sequence))):\n                count += 1\n        return count\n\n    predictions.sort(key=lambda x: count_subsequences(x, n), reverse=True)\n    return '\\n'.join(predictions)"
    },
    {
        "number": 3639,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, c, d = map(float, stdin.split()[0:3])\n    rain = [int(x) for x in stdin.split()[3:]]\n\n    def total_wet(speed, start_time, end_time):\n        total_rain = sum(rain[start_time:end_time])\n        total_sweat = (speed ** 2) * c * (end_time - start_time)\n        return total_rain + total_sweat\n\n    min_wet = float('inf')\n    for speed in range(1, int(d) + 1):\n        time_taken = d / speed\n        if time_taken > T:\n            break\n        start_time = int(T - time_taken)\n        end_time = int(T)\n        wet = total_wet(speed, start_time, end_time)\n        min_wet = min(min_wet, wet)\n\n    return f\"{min_wet:.6f}\""
    },
    {
        "number": 3640,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    s_len = len(s)\n    meow = \"meow\"\n    meow_len = len(meow)\n    dp = [[0] * meow_len for _ in range(s_len)]\n\n    for i in range(s_len):\n        for j in range(meow_len):\n            if s[i] == meow[j]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n\n    return dp[s_len - 1][meow_len - 1]"
    },
    {
        "number": 3641,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split()[0:2])\n    weights = list(map(int, stdin.split()[2:]))\n\n    total_weight = sum(weights)\n    if total_weight % k != 0:\n        return \"NO\"\n\n    segment_weight = total_weight // k\n    current_segment_weight = 0\n    current_bead = 0\n\n    while current_bead < n:\n        current_segment_weight += weights[current_bead]\n        if current_segment_weight == segment_weight:\n            current_segment_weight = 0\n            if current_bead == n - 1:\n                return \"YES\"\n        elif current_segment_weight > segment_weight:\n            return \"NO\"\n        current_bead += 1\n\n    return \"NO\""
    },
    {
        "number": 3642,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def reduce_fraction(numerator, denominator):\n        if denominator < 0:\n            numerator, denominator = -numerator, -denominator\n        gcd_val = gcd(abs(numerator), denominator)\n        return numerator // gcd_val, denominator // gcd_val\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    edges = []\n    magics = []\n    for i in range(1, N):\n        A, B = map(int, lines[i].split())\n        edges.append((A - 1, B - 1))\n    for i in range(N):\n        X = int(lines[N + i])\n        magics.append(X)\n\n    visited = [False] * N\n    min_magic = float('inf')\n    min_path = []\n\n    def dfs(node, parent):\n        nonlocal min_magic, min_path\n        visited[node] = True\n        for neighbor, magic in edges[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, node)\n        if parent != -1:\n            magic_product = magics[node] * magics[parent]\n            path_magic = magic_product / (2 * N - 2)\n            if path_magic < min_magic:\n                min_magic = path_magic\n                min_path = [node, parent]\n\n    dfs(0, -1)\n    numerator = 1\n    denominator = 1\n    for node in min_path:\n        numerator *= magics[node]\n        denominator *= (N - 1)\n    denominator //= (N - 1)\n    numerator //= denominator\n    reduced_numerator, reduced_denominator = reduce_fraction(numerator, denominator)\n    return f\"{reduced_numerator}/{reduced_denominator}\""
    },
    {
        "number": 3643,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_expected_damages(N, L, R):\n        total_damages = 0\n        for i in range(2, N + 1):\n            for j in range(1, i):\n                diff = (R[i - 1] - L[i - 1]) - (R[j - 1] - L[j - 1])\n                total_damages += max(diff, 0)\n        return total_damages / (N * N)\n\n    N = int(stdin.readline().strip())\n    L = [0] * N\n    R = [0] * N\n    for i in range(N):\n        L[i], R[i] = map(float, stdin.readline().strip().split())\n\n    return f\"{get_expected_damages(N, L, R):.8f}\""
    },
    {
        "number": 3644,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_hr_people(n: int, firings: List[int], hirings: List[int]) -> int:\n        total_fired = sum(firings)\n        total_hired = sum(hirings)\n        max_hr_people = total_fired + total_hired\n\n        hr_people = [0] * (n + 1)\n        for i in range(n):\n            for j in range(1, max_hr_people + 1):\n                if j not in hr_people[:i + 1]:\n                    hr_people[i + 1] = j\n                    break\n\n        return max(hr_people)\n\n    def assign_hr_people(n: int, firings: List[int], hirings: List[int], min_hr_people: int) -> List[int]:\n        hr_people = [0] * (n + 1)\n        for i in range(n):\n            for j in range(1, min_hr_people + 1):\n                if j not in hr_people[:i + 1]:\n                    hr_people[i + 1] = j\n                    break\n\n        return hr_people\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    firings = [int(line.split()[0]) for line in lines[1:]]\n    hirings = [int(line.split()[1]) for line in lines[1:]]\n\n    min_hr_people = find_min_hr_people(n, firings, hirings)\n    hr_people = assign_hr_people(n, firings, hirings, min_hr_people)\n\n    return f\"{min_hr_people}\\n{' '.join(map(str, hr_people[1:]))}\""
    },
    {
        "number": 3645,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    papers = list(map(int, stdin.readline().strip().split()))\n\n    if len(set(papers)) == n:\n        return \"none\"\n\n    possible_values = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if papers[i] == papers[j]:\n                possible_values.add(papers[i])\n\n    return \" \".join(map(str, sorted(list(possible_values))))"
    },
    {
        "number": 3646,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    spots = list(map(int, stdin.split('\\n')[1].split()))\n\n    jumps = {0: [0]}\n    max_distance = 0\n\n    for i in range(1, N):\n        jumps[i] = []\n        for j in range(i):\n            if spots[i] + spots[j] == abs(i - j):\n                jumps[i].append(j)\n                if max_distance < i - j:\n                    max_distance = i - j\n\n    return str(max_distance)"
    },
    {
        "number": 3647,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(maze, start, goal):\n        R, C = len(maze), len(maze[0])\n        visited = [[False] * C for _ in range(R)]\n        visited[goal[0]][goal[1]] = True\n        queue = [(goal, 0)]\n\n        while queue:\n            (r, c), moves = queue.pop(0)\n            if (r, c) == start:\n                return moves\n\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_r, new_c = r + dr, c + dc\n                if 0 <= new_r < R and 0 <= new_c < C and not visited[new_r][new_c]:\n                    visited[new_r][new_c] = True\n                    if maze[new_r][new_c] == '_':\n                        queue.append(((new_r, new_c), moves + 1))\n                        queue.append(((new_r + dr, new_c + dc), moves + 1))\n                    else:\n                        queue.append(((new_r, new_c), moves + 1))\n\n        return -1\n\n    C, R = map(int, stdin.readline().split())\n    maze = [list(stdin.readline().strip()) for _ in range(R)]\n    goal = next((r, c) for r in range(R) for c in range(C) if maze[r][c] == 'M')\n    start = next((r, c) for r in range(R) for c in range(C) if maze[r][c] == '.')\n\n    result = [bfs(maze, (r, c), goal) for r in range(R) for c in range(C)]\n    return '\\n'.join([' '.join(map(str, result[i:i + C])) for i in range(0, len(result), C)])"
    },
    {
        "number": 3648,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.readline().split())\n    insecure_buildings = set(map(int, stdin.readline().split()))\n    graph = [[0] * n for _ in range(n)]\n    costs = []\n\n    for _ in range(m):\n        x, y, cost = map(int, stdin.readline().split())\n        graph[x - 1][y - 1] = cost\n        graph[y - 1][x - 1] = cost\n        costs.append((x, y, cost))\n\n    def dfs(start, end, visited):\n        if start == end:\n            return 0\n        if start in visited:\n            return float('inf')\n        visited.add(start)\n        result = float('inf')\n        for i in range(n):\n            if graph[start][i] != 0:\n                result = min(result, graph[start][i] + dfs(i, end, visited))\n        return result\n\n    def is_insecure(building):\n        return building in insecure_buildings\n\n    def is_secure(building):\n        return not is_insecure(building)\n\n    def is_path_secure(path):\n        for building in path:\n            if is_insecure(building):\n                return False\n        return True\n\n    def find_cheapest_secure_network():\n        min_cost = float('inf')\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    cost = dfs(i, j, set())\n                    if cost != float('inf') and is_path_secure((i, j)):\n                        min_cost = min(min_cost, cost)\n        return min_cost if min_cost != float('inf') else 'impossible'\n\n    return find_cheapest_secure_network()"
    },
    {
        "number": 3649,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a > 2 * d or b > 2 * d or c > 2 * d or d > 2 * d:\n        return \"impossible\"\n    result = \"\"\n    for i in range(a):\n        result += \"00\"\n    for i in range(b):\n        result += \"01\"\n    for i in range(c):\n        result += \"10\"\n    for i in range(d):\n        result += \"11\"\n    return result"
    },
    {
        "number": 3650,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_move(board: List[List[int]], move: str, k: int) -> bool:\n        if move == \"<\":\n            for row in board:\n                if row[0] == 1 and row.count(1) == 1:\n                    return False\n            return True\n        elif move == \">\":\n            for row in board:\n                if row[-1] == 1 and row.count(1) == 1:\n                    return False\n            return True\n        elif move == \"^\":\n            for i in range(len(board[0])):\n                if board[0][i] == 1 and board.count(1) == 1:\n                    return False\n            return True\n        elif move == \"v\":\n            for i in range(len(board[0])):\n                if board[-1][i] == 1 and board.count(1) == 1:\n                    return False\n            return True\n\n    def perform_move(board: List[List[int]], move: str, k: int) -> List[List[int]]:\n        new_board = [row.copy() for row in board]\n        if move == \"<\":\n            new_board[k-1][0] = 1\n        elif move == \">\":\n            new_board[k-1][-1] = 1\n        elif move == \"^\":\n            for i in range(len(new_board[0])):\n                new_board[0][i] = 1\n        elif move == \"v\":\n            for i in range(len(new_board[0])):\n                new_board[-1][i] = 1\n        return new_board\n\n    def is_target_reachable(board: List[List[int]], target: List[List[int]]) -> bool:\n        if board == target:\n            return True\n        for move, k in product([\"<\", \">\", \"^\", \"v\"], range(1, len(board[0])+1)):\n            if is_valid_move(board, move, k):\n                new_board = perform_move(board, move, k)\n                if is_target_reachable(new_board, target):\n                    return True\n        return False\n\n    lines = stdin.split(\"\\n\")\n    N, M, B = map(int, lines[0].split())\n    board = [[0] * M for _ in range(N)]\n    target = [[0] * M for _ in range(N)]\n    for i in range(B):\n        r, c = map(int, lines[i+1].split())\n        board[r-1][c-1] = 1\n        target[r-1][c-1] = 1\n\n    if is_target_reachable(board, target):\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3651,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    planets = []\n    for i in range(n):\n        planets.append(list(map(int, stdin.readline().strip().split())))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** 0.5\n\n    def tsp(points):\n        n = len(points)\n        dp = [[float('inf') for _ in range(n)] for _ in range(1 << n)]\n        for i in range(n):\n            dp[1 << i][i] = 0\n\n        for mask in range(1, 1 << n):\n            for i in range(n):\n                if mask & (1 << i) != 0:\n                    for j in range(n):\n                        if mask & (1 << j) == 0:\n                            new_mask = mask | (1 << j)\n                            dp[new_mask][j] = min(dp[new_mask][j], dp[mask][i] + distance(points[i], points[j]))\n\n        return min(dp[-1])\n\n    return str(round(tsp(planets), 6))"
    },
    {
        "number": 3652,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    row1 = list(map(int, stdin.readline().strip().split()))\n    row2 = list(map(int, stdin.readline().strip().split()))\n    row3 = list(map(int, stdin.readline().strip().split()))\n\n    def is_identical(row1, row2, row3):\n        return sorted(row1) == sorted(row2) == sorted(row3)\n\n    def delete_columns(row1, row2, row3):\n        for i in range(N):\n            new_row1 = row1.copy()\n            new_row2 = row2.copy()\n            new_row3 = row3.copy()\n\n            new_row1.pop(i)\n            new_row2.pop(i)\n            new_row3.pop(i)\n\n            if is_identical(new_row1, new_row2, new_row3):\n                return i + 1\n        return N\n\n    return str(delete_columns(row1, row2, row3))"
    },
    {
        "number": 3653,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, x1, y1, x2, y2 = map(int, stdin.split())\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def area(chain_length, x1, y1, x2, y2):\n        wall_length = distance(x1, y1, x2, y2)\n        wall_height = chain_length / wall_length\n        return wall_length * wall_height\n\n    def binary_search(L, x1, y1, x2, y2):\n        left, right = 0, 1000000\n        while left < right:\n            mid = (left + right) // 2\n            if area(mid, x1, y1, x2, y2) < L:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\n    result = binary_search(L, x1, y1, x2, y2)\n    return str(result)"
    },
    {
        "number": 3654,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    F = [42, 11 * k + 77]\n    for i in range(2, n + 1):\n        F.append(2 * F[-1] - F[-2] + 10 * k)\n    count = 0\n    for i in range(1, n + 1):\n        for p in range(1, int(F[i] ** 0.5) + 1):\n            if F[i] % p == 0 and is_prime(p) and is_prime(F[i] // p):\n                count += 1\n                break\n    return str(count)\n\ndef"
    },
    {
        "number": 3655,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_image(stdin):\n        W, H = map(int, stdin.readline().split())\n        image = []\n        for _ in range(H):\n            row = list(map(int, stdin.readline().split()))\n            image.append(row)\n        return image\n\n    robot_image = read_image(stdin)\n    floor_image = read_image(stdin)\n\n    def count_same_pixels(x, y):\n        same_pixels = 0\n        for i in range(len(robot_image)):\n            for j in range(len(robot_image[0])):\n                if robot_image[i][j] == floor_image[i + y][j + x]:\n                    same_pixels += 1\n        return same_pixels\n\n    max_same_pixels = 0\n    candidates = []\n    for y in range(len(floor_image) - len(robot_image) + 1):\n        for x in range(len(floor_image[0]) - len(robot_image[0]) + 1):\n            same_pixels = count_same_pixels(x, y)\n            if same_pixels > max_same_pixels:\n                max_same_pixels = same_pixels\n                candidates = [(x, y)]\n            elif same_pixels == max_same_pixels:\n                candidates.append((x, y))\n\n    return \"\\n\".join(f\"{x} {y}\" for x, y in sorted(candidates, key=lambda x: (x[0], x[1])))"
    },
    {
        "number": 3656,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def expected_severity(p, s, f, t):\n        if t == 0:\n            return 0\n        if p >= 1:\n            return s\n        return s * p + (1 - p) * expected_severity(p * f, s, f, t - 1)\n\n    B, T, f = map(float, stdin.split()[:3])\n    B = int(B)\n    T = int(T)\n    bugs = []\n    for _ in range(B):\n        p, s = map(float, stdin.split())\n        bugs.append((p, s))\n\n    max_expected_severity = 0\n    for i in range(B):\n        for j in range(i + 1, B):\n            p1, s1 = bugs[i]\n            p2, s2 = bugs[j]\n            expected_severity_i = expected_severity(p1, s1, f, T)\n            expected_severity_j = expected_severity(p2, s2, f, T)\n            max_expected_severity = max(max_expected_severity, expected_severity_i + expected_severity_j)\n\n    return f\"{max_expected_severity:.6f}\""
    },
    {
        "number": 3657,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, v_h, N = map(int, stdin.readline().split())\n    gates = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().split())\n        gates.append((x, y))\n    S = int(stdin.readline())\n    skis = [int(stdin.readline()) for _ in range(S)]\n\n    def can_pass(v_s, gates):\n        time = 0\n        for x, y in gates:\n            time += (y - v_s * time) / v_h\n            if time < 0 or time > y / v_s:\n                return False\n        return True\n\n    min_time = float('inf')\n    best_ski = -1\n    for ski in skis:\n        if can_pass(ski, gates):\n            time = sum(y / ski for _, y in gates)\n            if time < min_time:\n                min_time = time\n                best_ski = ski\n\n    return str(best_ski) if best_ski != -1 else \"IMPOSSIBLE\""
    },
    {
        "number": 3658,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_triangle(p, a, b):\n        x1, y1 = a[0] - p[0], a[1] - p[1]\n        x2, y2 = b[0] - p[0], b[1] - p[1]\n        return x1 * y2 - x2 * y1 > 0\n\n    def area_of_polygon(points):\n        n = len(points)\n        area = 0.0\n        for i in range(n):\n            j = (i + 1) % n\n            area += points[i][0] * points[j][1]\n            area -= points[j][0] * points[i][1]\n        return abs(area) / 2\n\n    P, A = map(int, stdin.readline().split())\n    pine_trees = [list(map(float, stdin.readline().split())) for _ in range(P)]\n    aspen_trees = [list(map(float, stdin.readline().split())) for _ in range(A)]\n\n    shared_area = []\n    for pine in pine_trees:\n        for aspen in aspen_trees:\n            if is_inside_triangle(pine, aspen_trees[0], aspen_trees[1]):\n                shared_area.append(pine)\n                break\n\n    for aspen in aspen_trees:\n        if is_inside_triangle(aspen, pine_trees[0], pine_trees[1]):\n            shared_area.append(aspen)\n            break\n\n    return area_of_polygon(shared_area)"
    },
    {
        "number": 3659,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_height(books, shelves):\n        return sum(max(b[0] for b in shelf) for shelf in shelves)\n\n    def max_width(books, shelves):\n        return max(sum(b[1] for b in shelf) for shelf in shelves)\n\n    def area(books, shelves):\n        return max_height(books, shelves) * max_width(books, shelves)\n\n    def min_area(books, shelves):\n        if not books:\n            return 0\n        if len(shelves) == 1:\n            return area(books, [books])\n        min_shelf = min(books, key=lambda b: b[0])\n        books.remove(min_shelf)\n        shelves[0].append(min_shelf)\n        return area(books, shelves)\n\n    N = int(stdin.readline().strip())\n    books = [tuple(map(int, line.split())) for line in stdin]\n    shelves = [[] for _ in range(3)]\n\n    return str(min_area(books, shelves))"
    },
    {
        "number": 3660,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_assemble(word, stickers):\n        if not word:\n            return True\n        for sticker in stickers:\n            if word.startswith(sticker):\n                if can_assemble(word[len(sticker):], stickers):\n                    return True\n        return False\n\n    def min_cost(word, stickers, prices):\n        if not word:\n            return 0\n        min_cost = float('inf')\n        for sticker in stickers:\n            if word.startswith(sticker):\n                cost = prices[sticker] + min_cost(word[len(sticker):], stickers, prices)\n                min_cost = min(min_cost, cost)\n        return min_cost\n\n    lines = stdin.split('\\n')\n    message = lines[0]\n    n = int(lines[1])\n    stickers = {}\n    prices = {}\n    for i in range(2, n + 2):\n        sticker, price = lines[i].split()\n        stickers[sticker] = True\n        prices[sticker] = int(price)\n\n    if can_assemble(message, stickers.keys()):\n        return str(min_cost(message, stickers.keys(), prices))\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3661,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S, L = map(int, stdin.split()[0:3])\n    lawsuits = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    individual_wins = [0] * (R + 1)\n    corporation_wins = [0] * (S + 1)\n\n    for i in range(L):\n        individual, corporation = lawsuits[i]\n        if individual_wins[individual] + corporation_wins[corporation] < individual_wins[individual] + corporation_wins[corporation] + 1:\n            individual_wins[individual] += 1\n        else:\n            corporation_wins[corporation] += 1\n\n    result = []\n    for individual, corporation in lawsuits:\n        if individual_wins[individual] <= corporation_wins[corporation]:\n            result.append(f\"INDV {individual}\")\n        else:\n            result.append(f\"CORP {corporation}\")\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3662,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def min_distance(positions):\n        n = len(positions)\n        positions.sort()\n        total_distance = 0\n        for i in range(0, n, 2):\n            if i + 1 < n:\n                total_distance += distance(positions[i], 0, positions[i + 1], 0)\n            if i + 2 < n:\n                total_distance += distance(positions[i], 0, positions[i + 2], 0)\n        return total_distance\n\n    input_data = list(map(int, stdin.split()))\n    n, l, w = input_data[0], input_data[1], input_data[2]\n    positions = input_data[3:]\n\n    return str(min_distance(positions))"
    },
    {
        "number": 3663,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    routes = []\n    for i in range(1, n - 1):\n        u, v, c = map(int, lines[i].split())\n        routes.append((u, v, c))\n\n    armies = []\n    for i in range(n, 2 * n):\n        x, y = map(int, lines[i].split())\n        armies.append((x, y))\n\n    total_armies = sum(x for x, _ in armies)\n    total_required = sum(y for _, y in armies)\n\n    if total_armies < total_required:\n        return \"Impossible\"\n\n    adj_list = [[] for _ in range(n)]\n    for u, v, c in routes:\n        adj_list[u - 1].append((v - 1, c))\n        adj_list[v - 1].append((u - 1, c))\n\n    visited = [False] * n\n    min_cost = [float('inf')] * n\n    min_cost[0] = 0\n\n    queue = [(0, 0)]  # (cost, node)\n    while queue:\n        cost, node = queue.pop(0)\n        if not visited[node]:\n            visited[node] = True\n            for neighbor, distance in adj_list[node]:\n                new_cost = cost + distance * (armies[node][0] - armies[neighbor][0])\n                min_cost[neighbor] = min(min_cost[neighbor], new_cost)\n                queue.append((new_cost, neighbor))\n\n    return str(min_cost[n - 1])"
    },
    {
        "number": 3664,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, i, j, n = map(int, stdin.split())\n    ice = [['.' for _ in range(c)] for _ in range(r)]\n    direction = (-1, 0)  # up\n    color = 'A'\n    step_size = 1\n\n    def move(x, y, dx, dy):\n        return (x + dx) % r, (y + dy) % c\n\n    for _ in range(n):\n        x, y = i, j\n        for _ in range(step_size):\n            ice[x][y] = color\n            x, y = move(x, y, *direction)\n        direction = (-direction[1], direction[0])  # rotate 90 degrees clockwise\n        color = chr((ord(color) - 64) % 26 + 65)  # next letter in the alphabet\n        step_size += 1\n\n    ice[i][j] = '@'\n    return '\\n'.join([''.join(row) for row in ice])"
    },
    {
        "number": 3665,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    numbers = [stdin.readline().strip() for _ in range(n)]\n\n    def is_sorted(numbers: List[str]) -> bool:\n        for i in range(1, len(numbers)):\n            if numbers[i] < numbers[i - 1]:\n                return False\n        return True\n\n    def lossy_sort(numbers: List[str], index: int) -> List[str]:\n        if index == len(numbers):\n            return numbers\n\n        current_number = numbers[index]\n        for i in range(m):\n            for digit in range(10):\n                new_number = current_number[:i] + str(digit) + current_number[i + 1:]\n                numbers[index] = new_number\n                if is_sorted(numbers):\n                    return numbers\n\n        return numbers\n\n    sorted_numbers = lossy_sort(numbers, 0)\n    return \"\\n\".join(sorted_numbers)"
    },
    {
        "number": 3666,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    gear_ratios = []\n    for i in range(12):\n        n, d = map(int, stdin.split('/')[i].split())\n        gear_ratios.append((n, d))\n\n    for u in range(1, 3):\n        for v1 in range(1, 7):\n            for v2 in range(1, 7):\n                for v3 in range(1, 7):\n                    for v4 in range(1, 7):\n                        for v5 in range(1, 7):\n                            for v6 in range(1, 7):\n                                if (u/v1, u/v2, u/v3, u/v4, u/v5, u/v6) == tuple(sorted([n/d for n, d in gear_ratios])):\n                                    return f\"{u} {v1} {v2} {v3} {v4} {v5} {v6}\\n{v1} {v2} {v3} {v4} {v5} {v6}\"\n    return \"impossible\""
    },
    {
        "number": 3667,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_intersection(x1, y1, x2, y2, x3, y3):\n        return (x1 * (y2 - y3) + y1 * (x3 - x2) + x2 * y3 - y2 * x3) == 0\n\n    def is_collinear(x1, y1, x2, y2, x3, y3):\n        return (x1 * (y2 - y3) + y1 * (x3 - x2)) == 0\n\n    def is_between(x1, y1, x2, y2, x3, y3):\n        return x1 <= x3 <= x2 or x1 >= x3 >= x2 and y1 <= y3 <= y2 or y1 >= y3 >= y2\n\n    def is_valid(wells, pipes):\n        for i in range(len(pipes)):\n            for j in range(i + 1, len(pipes)):\n                x1, y1, x2, y2 = pipes[i][1], pipes[i][2], pipes[j][1], pipes[j][2]\n                if is_intersection(x1, y1, x2, y2, wells[pipes[i][0]][0], wells[pipes[i][0]][1]) and \\\n                   is_intersection(x1, y1, x2, y2, wells[pipes[j][0]][0], wells[pipes[j][0]][1]):\n                    if is_collinear(x1, y1, x2, y2, wells[pipes[i][0]][0], wells[pipes[i][0]][1]) and \\\n                       is_collinear(x1, y1, x2, y2, wells[pipes[j][0]][0], wells[pipes[j][0]][1]):\n                        if is_between(x1, y1, x2, y2, wells[pipes[i][0]][0], wells[pipes[i][0]][1]) and \\\n                           is_between(x1, y1, x2, y2, wells[pipes[j][0]][0], wells[pipes[j][0]][1]):\n                            return False\n        return True\n\n    lines = stdin.split('\\n')\n    w, p = map(int, lines[0].split())\n    wells = [tuple(map(int, lines[i + 1].split())) for i in range(w)]\n    pipes = [tuple(map(int, lines[i + w + 1].split())) for i in range(p)]\n\n    if is_valid(wells, pipes):\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3668,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    burger_recipients = []\n    salad_recipients = [i for i in range(n)]\n\n    for _ in range(m):\n        a = int(input())\n        burger_recipients.extend(salad_recipients[:a])\n        salad_recipients = salad_recipients[a:]\n\n    return str(len(set(burger_recipients)))"
    },
    {
        "number": 3669,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_winner(points, prev_line):\n        for point in points:\n            if point not in prev_line:\n                return \"Mirko\"\n        return \"Slavko\"\n\n    def get_parallel_lines(points, line):\n        parallel_lines = []\n        for point in points:\n            if point[0] == line[0][0]:\n                parallel_lines.append((point, (point[0], line[1][1])))\n            elif point[1] == line[0][1]:\n                parallel_lines.append((point, (line[1][0], point[1])))\n        return parallel_lines\n\n    N = int(stdin.readline().strip())\n    points = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    winner = \"Mirko\"\n    prev_line = None\n    while points:\n        parallel_lines = get_parallel_lines(points, prev_line)\n        if not parallel_lines:\n            winner = \"Slavko\"\n            break\n        prev_line = parallel_lines[0]\n        points.remove(prev_line[0])\n        points.remove(prev_line[1])\n\n    return winner"
    },
    {
        "number": 3670,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    numbers = [int(stdin.readline()) for _ in range(n)]\n    min_num = min(numbers)\n    lcm = min_num\n    for i in range(min_num + 1, max(numbers) + 1):\n        for num in numbers:\n            if num % i != num % min_num:\n                break\n        else:\n            lcm = i\n    return \" \".join(str(i) for i in range(2, lcm + 1) if all(num % i == 0 for num in numbers))"
    },
    {
        "number": 3671,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    job_offers = sorted([int(x) for x in stdin.split('\\n')[1].split()])\n\n    cookies = 0\n    accepted_jobs = []\n\n    for offer in job_offers:\n        if not accepted_jobs or offer - accepted_jobs[-1][0] >= 4 * 10**5:\n            if offer == job_offers[-1] or job_offers[job_offers.index(offer) + 1] - offer >= 4 * 10**5:\n                accepted_jobs.append((offer, 4 * 10**5))\n                cookies += 1\n\n    for i in range(len(accepted_jobs)):\n        if i == 0 or accepted_jobs[i][0] - accepted_jobs[i - 1][0] >= 4 * 10**5:\n            cookies += accepted_jobs[i][1] // 10**5\n\n    return str(cookies)"
    },
    {
        "number": 3672,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.readline().split())\n    resources = [set() for _ in range(n)]\n    for i in range(m):\n        island = list(map(int, stdin.readline().split()))[:-1]\n        for resource in island:\n            resources[resource - 1].add(i)\n\n    for resource in resources:\n        if len(resource) != 2:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3673,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    start = list(map(int, stdin.readline().split()))\n    end = [0] * N\n    for i in range(N):\n        end[start[i] - 1] = i + 1\n\n    if start == end:\n        return \" \".join(map(str, start))\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3674,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, p, q = map(int, stdin.split())\n    if m == 1:\n        return \"IMPOSSIBLE\"\n    if n == 0:\n        return \"IMPOSSIBLE\"\n    if p == 0:\n        return \"IMPOSSIBLE\"\n    if q == 0:\n        return \"IMPOSSIBLE\"\n\n    for i in range(1, 10):\n        if m == 2 and n == 1 and p == i and q == 4:\n            return f\"{i}1\"\n        if m == 3 and n == 1 and p == i and q == 4:\n            return f\"{i}0{i}1\"\n        if m == 4 and n == 1 and p == i and q == 4:\n            return f\"{i}00{i}1\"\n        if m == 5 and n == 1 and p == i and q == 4:\n            return f\"{i}000{i}1\"\n        if m == 6 and n == 1 and p == i and q == 4:\n            return f\"{i}0000{i}1\"\n        if m == 7 and n == 1 and p == i and q == 4:\n            return f\"{i}00000{i}1\"\n        if m == 8 and n == 1 and p == i and q == 4:\n            return f\"{i}000000{i}1\"\n        if m == 9 and n == 1 and p == i and q == 4:\n            return f\"{i}0000000{i}1\"\n\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3675,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    strings = [stdin.readline().strip() for _ in range(n)]\n\n    def lcs(x: str, y: str) -> int:\n        m, n = len(x), len(y)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if x[i - 1] == y[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[m][n]\n\n    result = strings[0]\n    for string in strings[1:]:\n        result = strings[0]\n        for i in range(k):\n            if string[i] not in result:\n                result += string[i]\n        strings[0] = result\n\n    length = len(strings[0])\n    for i in range(1, n):\n        length = min(length, lcs(strings[0], strings[i]))\n\n    return str(length)"
    },
    {
        "number": 3676,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    total_chocolates = R * C\n    total_polygons = 0\n\n    for i in range(1, total_chocolates // 3 + 1):\n        for j in range(1, total_chocolates // 3 + 1):\n            if i * j * 3 <= total_chocolates:\n                total_polygons += 1\n\n    return str(total_polygons)"
    },
    {
        "number": 3677,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_largest_committee(N, K, disagreements):\n        def is_valid_committee(committee):\n            for i in range(len(committee)):\n                for j in range(i + 1, len(committee)):\n                    if committee[i] not in disagreements[committee[j]]:\n                        return False\n            return True\n\n        for size in range(K, 0, -1):\n            for committee in itertools.combinations(range(N), size):\n                if is_valid_committee(committee):\n                    return size\n        return 0\n\n    lines = stdin.splitlines()\n    N, K = map(int, lines[0].split())\n    disagreements = [set() for _ in range(N)]\n\n    for i, line in enumerate(lines[1:]):\n        data = list(map(int, line.split()))\n        D_i = data[0]\n        for j in data[1:]:\n            disagreements[i].add(j)\n            disagreements[j].add(i)\n\n    return str(find_largest_committee(N, K, disagreements))"
    },
    {
        "number": 3678,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_segment(p1, p2, points):\n        x1, y1 = p1\n        x2, y2 = p2\n        for point in points:\n            px, py = point\n            if (x1 == x2 and px == x1 and py != y1 and py != y2) or (y1 == y2 and py == y1 and px != x1 and px != x2):\n                return False\n        return True\n\n    def is_valid_loop(points):\n        n = len(points)\n        for i in range(n):\n            p1, p2 = points[i], points[(i + 1) % n]\n            if not is_valid_segment(p1, p2, points):\n                return False\n        return True\n\n    def find_loop(points):\n        n = len(points)\n        for i in range(n):\n            p1, p2 = points[i], points[(i + 1) % n]\n            if p1[0] == p2[0] or p1[1] == p2[1]:\n                continue\n            new_points = [point for point in points if point != p1 and point != p2]\n            for j in range(n - 2):\n                if not is_valid_segment(p1, new_points[j], new_points):\n                    continue\n                if not is_valid_segment(p2, new_points[j + 1], new_points):\n                    continue\n                new_points.pop(j)\n                if is_valid_loop(new_points):\n                    return True\n                new_points.insert(j, new_points.pop())\n        return False\n\n    test_cases = int(stdin.readline().strip())\n    result = []\n    for _ in range(test_cases):\n        n = int(stdin.readline().strip())\n        points = [tuple(map(int, stdin.readline().strip().split())) for _ in range(n)]\n        if find_loop(points):\n            result.append('YES')\n        else:\n            result.append('NO')\n    return '\\n'.join(result)"
    },
    {
        "number": 3679,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    expected_gifts = 0\n\n    for i in range(1, n + 1):\n        expected_gifts += i * (1 / n)\n\n    return f\"{expected_gifts:.10f}\""
    },
    {
        "number": 3680,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, N = map(int, stdin.split())\n    poles = list(map(int, stdin.split()))\n    poles.sort(reverse=True)\n    cuts = 0\n    for i in range(N):\n        if poles[i] > i + 1:\n            cuts += poles[i] - (i + 1)\n    return str(cuts)"
    },
    {
        "number": 3681,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(teachers, k):\n        return teachers[k:] + teachers[:k]\n\n    def find_teacher(teacher_map, week, day, teacher):\n        class_num = teacher_map[teacher][week - 1]\n        if day == 1:\n            return class_num\n        else:\n            return (class_num + day - 1) % N + 1\n\n    N, M, Q = map(int, stdin.split()[:3])\n    teacher_map = {i: [i] * M for i in range(1, N + 1)}\n    plans = []\n\n    for i in range(Q):\n        query = list(map(int, stdin.split()[3 * i: 3 * (i + 1)]))\n        if query[0] == 0:\n            k, x, *teachers = query\n            plans.append((x, k, teachers))\n        else:\n            d, x, day = query\n            print(find_teacher(teacher_map, x, day, d))\n\n    for x, k, teachers in sorted(plans):\n        for i in range(1, N + 1):\n            teacher_map[i][x - 1:] = rotate(teacher_map[i][x - 1:], k)\n\n    return \"\""
    },
    {
        "number": 3682,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    fragments = []\n    lines = stdin.split('\\n')\n    n_fragments = int(lines[0])\n    i = 1\n    while n_fragments > 0:\n        file_name = lines[i]\n        fragment = []\n        i += 1\n        while lines[i] != '***END***':\n            fragment.append(lines[i])\n            i += 1\n        fragments.append((file_name, fragment))\n        i += 1\n        n_fragments -= 1\n\n    code_snippet = []\n    while lines[i] != '***END***':\n        code_snippet.append(lines[i])\n        i += 1\n\n    max_match_length = 0\n    matching_fragments = []\n    for file_name, fragment in fragments:\n        match_length = 0\n        for i in range(len(fragment)):\n            if fragment[i].strip() == code_snippet[i].strip():\n                match_length += 1\n            else:\n                match_length = 0\n            if match_length > max_match_length:\n                max_match_length = match_length\n                matching_fragments = [(file_name, match_length)]\n            elif match_length == max_match_length:\n                matching_fragments.append((file_name, match_length))\n\n    if max_match_length == 0:\n        return \"0\"\n\n    output = f\"{max_match_length} \"\n    for file_name, match_length in matching_fragments:\n        output += f\"{file_name} \"\n\n    return output.strip()"
    },
    {
        "number": 3683,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, h = map(int, stdin.readline().split())\n    scores = [list(map(int, stdin.readline().split())) for _ in range(p)]\n\n    for i in range(p):\n        for j in range(h):\n            if scores[i][j] > 10**9:\n                scores[i][j] = 10**9\n\n    for i in range(p):\n        scores[i] = sorted(scores[i])\n\n    ranks = [0] * p\n    for i in range(p):\n        for j in range(p):\n            if scores[j] >= scores[i]:\n                ranks[i] += 1\n        ranks[i] -= 1\n\n    return \" \".join(map(str, ranks))"
    },
    {
        "number": 3684,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, C = map(int, stdin.readline().split())\n    users = []\n\n    for _ in range(n):\n        p, b, u = map(int, stdin.readline().split())\n        users.append((p, b, u))\n\n    users.sort(key=lambda x: x[0] + C)\n\n    for i in range(n):\n        p, b, u = users[i]\n        buffer_size = b - (p + C)\n        for j in range(i + 1, n):\n            p_next, b_next, u_next = users[j]\n            if p_next > p + C:\n                break\n            buffer_size += min(u_next, b_next - (p_next + C))\n        users[i] = (p, b, u, buffer_size)\n\n    return str(min(users, key=lambda x: x[3])[3])"
    },
    {
        "number": 3685,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y):\n        return 1 <= x <= r and 1 <= y <= c and not blocked[x][y]\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            (x, y), steps = queue.pop(0)\n            if (x, y) == end:\n                return steps\n\n            if (x, y) not in visited:\n                visited.add((x, y))\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny):\n                        queue.append(((nx, ny), steps + 1))\n\n        return None\n\n    stdin = stdin.split('\\n')\n    r, c = map(int, stdin[0].split())\n    bed, fridge = stdin[1].replace('(', '').replace(')', '').split()\n    bed = tuple(map(int, bed.split()))\n    fridge = tuple(map(int, fridge.split()))\n    blocked = [[False] * c for _ in range(r)]\n\n    for i in range(2, r + 1):\n        row = stdin[i]\n        for j, cell in enumerate(row):\n            if cell == '#':\n                blocked[i - 1][j] = True\n\n    p = int(stdin[r + 1])\n    masters = []\n\n    for i in range(r + 2, r + 2 + p):\n        master = stdin[i].split()\n        master = [(int(x.split()[0]), int(x.split()[1])) for x in master]\n        masters.append(master)\n\n    min_turns = float('inf')\n\n    for master in masters:\n        for i in range(len(master) - 1):\n            start = master[i]\n            end = master[i + 1]\n            if start[0] == end[0]:\n                for j in range(min(start[1], end[1]), max(start[1], end[1]) + 1):\n                    blocked[start[0] - 1][j - 1] = True\n            elif start[1] == end[1]:\n                for j in range(min(start[0], end[0]), max(start[0], end[0]) + 1):\n                    blocked[j - 1][start[1] - 1] = True\n\n        turns = bfs(bed, fridge)\n        if turns is not None:\n            min_turns = min(min_turns, turns)\n\n    return str(min_turns) if min_turns != float('inf') else 'IMPOSSIBLE' "
    },
    {
        "number": 3686,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_on_line(p1, p2, p3):\n        return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) == 0\n\n    def is_hit(targets, shot1, shot2):\n        hit = set()\n        for i in range(len(targets)):\n            for j in range(i + 1, len(targets)):\n                if is_on_line(targets[i], targets[j], shot1) and is_on_line(targets[i], targets[j], shot2):\n                    hit.add(targets[i])\n                    hit.add(targets[j])\n        return len(hit) == len(targets)\n\n    N = int(stdin.readline().strip())\n    targets = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().strip().split())\n        targets.append((x, y))\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if is_hit(targets, targets[i], targets[j]):\n                return \"success\"\n    return \"failure\""
    },
    {
        "number": 3687,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_line() -> str:\n        return stdin.readline().strip()\n\n    def read_int() -> int:\n        return int(read_line())\n\n    def read_ints() -> List[int]:\n        return list(map(int, read_line().split()))\n\n    n, q, s = read_ints()\n    q_to_sensor = read_ints()\n    queue_size = read_ints()\n\n    for _ in range(n):\n        downlink_window = read_ints()\n        d, a = downlink_window[0], downlink_window[1:]\n\n        for i in range(s):\n            if a[i] > queue_size[q_to_sensor[i] - 1]:\n                return \"impossible\"\n\n    return \"possible\""
    },
    {
        "number": 3688,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    shopping_malls = []\n    for i in range(n):\n        x, y, t = map(int, stdin.readline().split())\n        shopping_malls.append((x, y, t))\n\n    vertical_moves = 0\n    for i in range(n):\n        x1, y1, t1 = shopping_malls[i]\n        for j in range(i + 1, n):\n            x2, y2, t2 = shopping_malls[j]\n            if t1 == t2:\n                if abs(x1 - x2) < abs(y1 - y2):\n                    vertical_moves += 1\n\n    return str(vertical_moves)"
    },
    {
        "number": 3689,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    digits = list(map(int, stdin.readline()))\n\n    def is_beautiful(num: int) -> bool:\n        num_str = str(num)\n        for i in range(len(num_str) - k):\n            if num_str[i] != num_str[i + k]:\n                return False\n        return True\n\n    def next_beautiful(num: int) -> int:\n        num += 1\n        while not is_beautiful(num):\n            num += 1\n        return num\n\n    x = int(\"\".join(map(str, digits)))\n    y = next_beautiful(x)\n    y_digits = list(map(int, str(y)))\n\n    return f\"{len(y_digits)}\\n{''.join(map(str, y_digits))}\""
    },
    {
        "number": 3690,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, m, s, t1, t2 = map(int, stdin.split())\n\n    def angle(h, m, s):\n        return (360 * h + 6 * m + s / 10) % 360\n\n    def distance(a1, a2):\n        return min(abs(a1 - a2), 360 - abs(a1 - a2))\n\n    a1 = angle(h, m, s)\n    a2 = angle(0, t1, 0)\n    a3 = angle(0, t2, 0)\n\n    if distance(a1, a2) + distance(a2, a3) <= distance(a1, a3):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3691,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x0, y0, a_x, a_y, b_x, b_y, x_s, y_s, t = map(int, stdin.split())\n\n    def get_node_coords(i):\n        if i == 0:\n            return x0, y0\n        else:\n            x_prev, y_prev = get_node_coords(i - 1)\n            return a_x * x_prev + b_x, a_y * y_prev + b_y\n\n    def get_min_time_to_collect_nodes(x, y, t_left):\n        if t_left <= 0:\n            return 0, 0\n\n        min_time = float('inf')\n        max_collected_nodes = 0\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_x, new_y = x + dx, y + dy\n            new_t_left = t_left - 1\n\n            if (new_x, new_y) == (x_s, y_s):\n                continue\n\n            if 0 <= new_x <= 10**16 and 0 <= new_y <= 10**16:\n                time_to_collect, nodes_collected = get_min_time_to_collect_nodes(new_x, new_y, new_t_left)\n                if nodes_collected + 1 > max_collected_nodes:\n                    min_time = time_to_collect + 1\n                    max_collected_nodes = nodes_collected + 1\n\n        return min_time, max_collected_nodes\n\n    min_time, max_collected_nodes = get_min_time_to_collect_nodes(x_s, y_s, t)\n    return str(max_collected_nodes)"
    },
    {
        "number": 3692,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    circles = []\n    for i in range(n):\n        x, y, r = map(int, stdin.readline().split())\n        circles.append((x, y, r))\n\n    regions = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1, r1 = circles[i]\n            x2, y2, r2 = circles[j]\n            d = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n            if d > r1 + r2:\n                continue\n            elif d == 0 and r1 == r2:\n                continue\n            else:\n                regions.append((x1, y1, r1, x2, y2, r2))\n\n    def is_inside(x, y, x1, y1, r1):\n        return (x - x1) ** 2 + (y - y1) ** 2 <= r1 ** 2\n\n    def is_intersect(x1, y1, r1, x2, y2, r2):\n        d = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n        if d > r1 + r2:\n            return False\n        elif d == 0 and r1 == r2:\n            return True\n        else:\n            return (is_inside(x1, y1, x2, y2, r2) or is_inside(x2, y2, x1, y1, r1))\n\n    for x1, y1, r1, x2, y2, r2 in regions:\n        for x in range(x1 - r1, x1 + r1 + 1):\n            for y in range(y1 - r1, y1 + r1 + 1):\n                if is_inside(x, y, x1, y1, r1) and not is_intersect(x, y, r1, x2, y2, r2):\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        return 1\n\n    return 2\n\n    # for x in range(-10, 11):\n    #     for y in range(-10, 11):\n    #         if not is_inside(x, y, x1, y1, r1) and not is_inside(x, y, x2, y2, r2):\n    #             if is_intersect(x, y, r1, x2, y2, r2):\n    #                 continue\n    #             else:\n    #                 break\n    #     else:\n    #         continue\n    #     break\n    # else:\n    #     return 3\n    #\n    # return 4\n\n    # for x in range(-10, 11):\n    #     for y in range(-10, 11):\n    #         if not is_inside(x, y, x1, y1, r1) and not is_inside(x, y, x2, y2, r2):\n    #             if is_intersect(x, y, r1, x2, y2, r2):\n    #                 continue\n    #             else:\n    #                 break\n    #     else:\n    #         continue\n    #     break\n    # else:\n    #     return 4\n    #\n    # return 5\n\n    # for x in range(-10, 11):\n    #     for y in range(-10, 11):\n    #         if not is_inside(x, y, x1, y1, r1) and not is_inside(x, y, x2, y2, r2):\n    #             if is_intersect(x, y, r1, x2, y2, r2):\n    #                 continue\n    #             else:\n    #                 break\n    #     else:\n    #         continue\n    #     break\n    # else:\n    #     return 5\n    #\n    # return 6\n\n    # for x in range(-10, 11):\n    #     for"
    },
    {
        "number": 3693,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_intersect(a1, a2, b1, b2):\n        return a1 <= b2 and b1 <= a2\n\n    def is_point_inside_square(point, square):\n        x, y = point\n        x1, y1, x2, y2, x3, y3, x4, y4 = square\n        return is_intersect(x1, x2, x, x) and is_intersect(y1, y2, y, y)\n\n    def is_square_intersect(square1, square2):\n        for point in square1:\n            if is_point_inside_square(point, square2):\n                return True\n        for point in square2:\n            if is_point_inside_square(point, square1):\n                return True\n        return False\n\n    def parse_square(line):\n        x1, y1, x2, y2, x3, y3, x4, y4 = map(int, line.split())\n        return [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]\n\n    square1, square2 = stdin.split('\\n')\n    square1 = parse_square(square1)\n    square2 = parse_square(square2)\n\n    return \"YES\" if is_square_intersect(square1, square2) else \"NO\""
    },
    {
        "number": 3694,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = sorted(a, reverse=True)\n\n    if n == 1:\n        if a[0] == 0:\n            return \"cslnb\"\n        else:\n            return \"sjfnb\"\n\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            return \"sjfnb\"\n\n    return \"cslnb\""
    },
    {
        "number": 3695,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.readline().split())\n    t = list(map(int, stdin.readline().split()))\n\n    bowls = [i for i in range(1, n + 1)]\n    eaten_bowls = []\n\n    for i in range(n):\n        if t[i] <= T:\n            eaten_bowls.append(bowls[i])\n\n    return str(len(eaten_bowls))"
    },
    {
        "number": 3696,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n\n    if n == 1:\n        return \"1\\n0 1\\n0\\n1\"\n    elif n == 2:\n        return \"2\\n-1 0 1\\n1\\n0 1\"\n    else:\n        return \"-1\"\n\n    return \"\""
    },
    {
        "number": 3697,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m, a = map(int, stdin.split()[0:4])\n    g = list(map(int, stdin.split()[4:]))\n    r = [0] * n\n\n    for i in range(a):\n        r[g[i] - 1] += 1\n\n    for i in range(n):\n        if r[i] >= k:\n            r[i] = 1\n        elif r[i] > 0:\n            r[i] = 2\n        else:\n            r[i] = 3\n\n    return \" \".join(map(str, r))"
    },
    {
        "number": 3698,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def count_set_bits(x: int) -> int:\n        count = 0\n        while x:\n            count += x & 1\n            x >>= 1\n        return count\n\n    def is_special(x: int) -> bool:\n        count = 0\n        while x > 1:\n            count += 1\n            x &= x - 1\n        return count == k\n\n    special_count = 0\n    for i in range(n + 1):\n        if is_special(i):\n            special_count += 1\n\n    return str(special_count % mod)"
    },
    {
        "number": 3699,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_x, a_y, b_x, b_y, t_x, t_y = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n    bottles = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def min_distance(p1, p2, bottles):\n        if not bottles:\n            return distance(p1, p2)\n        bottles = sorted(bottles, key=lambda x: distance(p1, x))\n        return min(distance(p1, bottles[0]) + min_distance(bottles[0], p2, bottles[1:]), distance(p2, bottles[0]) + min_distance(p1, bottles[0], bottles[1:]))\n\n    return f\"{min_distance((a_x, a_y), (b_x, b_y), bottles):.6f}\""
    },
    {
        "number": 3700,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for i in range(1, n // 2 + 1):\n        j = k - i\n        if j > n or j < i:\n            continue\n        count += 1\n    return str(count)"
    },
    {
        "number": 3701,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.readline().split())\n    a = stdin.readline().strip()\n\n    def count_zeros(s: str) -> int:\n        return sum(1 for c in s if c == '0')\n\n    def count_ones(s: str) -> int:\n        return sum(1 for c in s if c == '1')\n\n    def reverse_substring(s: str, i: int, j: int) -> str:\n        return s[:i] + s[i:j + 1][::-1] + s[j + 1:]\n\n    def invert_substring(s: str, i: int, j: int) -> str:\n        return s[:i] + ''.join('1' if c == '0' else '0' for c in s[i:j + 1]) + s[j + 1:]\n\n    min_cost = float('inf')\n\n    for i in range(n):\n        for j in range(i, n):\n            s = a\n            cost = 0\n\n            if count_zeros(s[i:j + 1]) > 0:\n                s = invert_substring(s, i, j)\n                cost += y * (j - i + 1)\n\n            if count_ones(s[i:j + 1]) < (j - i + 1):\n                s = reverse_substring(s, i, j)\n                cost += x\n\n            min_cost = min(min_cost, cost)\n\n    return min_cost if min_cost != float('inf') else 0"
    },
    {
        "number": 3702,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, d = map(int, stdin.split())\n    b, e = -1, -1\n\n    for i in range(2, 2**64):\n        if i * d < 10**18:\n            continue\n        b = i\n        break\n\n    for i in range(1, 2**64):\n        if (a + i * d) % 10**18 == 0:\n            continue\n        e = i\n        break\n\n    if b == -1 or e == -1:\n        return \"-1\\n\"\n\n    return f\"{b} {e}\\n\""
    },
    {
        "number": 3703,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 1000000007\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def f(n):\n        res = 0\n        for x in range(1, n // 2 + 1):\n            if gcd(x, n - x) == 1:\n                res += 1\n        return res\n\n    def g(n):\n        res = 0\n        for d in range(1, n + 1):\n            if n % d == 0:\n                res += f(d)\n        return res\n\n    def F(k, n):\n        if k == 1:\n            return f(g(n)) % mod\n        elif k % 2 == 0:\n            return F(k - 1, g(n)) % mod\n        else:\n            return F(k - 1, f(n)) % mod\n\n    return str(F(k, n))"
    },
    {
        "number": 3704,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def ip_to_int(ip: str) -> int:\n        return sum(int(x) << (24 - 8 * i) for i, x in enumerate(ip.split('.')))\n\n    def int_to_ip(num: int) -> str:\n        return '.'.join(str((num >> (24 - 8 * i)) & 255) for i in range(4))\n\n    def subnet_to_range(subnet: str) -> tuple:\n        if '/' in subnet:\n            ip, mask = subnet.split('/')\n            mask = int(mask)\n        else:\n            ip, mask = subnet, 32\n        ip_int = ip_to_int(ip)\n        mask_int = (1 << (32 - mask)) - 1\n        return ip_int & ~mask_int, ip_int | mask_int\n\n    def range_to_subnet(start: int, end: int) -> str:\n        mask = 32 - (start ^ end).bit_length()\n        ip_int = start & ~((1 << (32 - mask)) - 1)\n        return int_to_ip(ip_int) + '/' + str(mask)\n\n    def merge_ranges(ranges: list) -> list:\n        ranges.sort()\n        merged_ranges = []\n        start, end = ranges[0]\n        for s, e in ranges[1:]:\n            if s <= end:\n                end = max(end, e)\n            else:\n                merged_ranges.append((start, end))\n                start, end = s, e\n        merged_ranges.append((start, end))\n        return merged_ranges\n\n    def subnets_to_ranges(subnets: list) -> list:\n        ranges = []\n        for subnet in subnets:\n            start, end = subnet_to_range(subnet)\n            ranges.append((start, end))\n        return ranges\n\n    def ranges_to_subnets(ranges: list) -> list:\n        subnets = []\n        for start, end in ranges:\n            subnets.append(range_to_subnet(start, end))\n        return subnets\n\n    def blacklist_optimizer(blacklist: list, whitelist: list) -> list:\n        blacklist_ranges = subnets_to_ranges(blacklist)\n        whitelist_ranges = subnets_to_ranges(whitelist)\n        optimised_blacklist_ranges = merge_ranges(blacklist_ranges + whitelist_ranges)\n        optimised_blacklist = ranges_to_subnets(optimised_blacklist_ranges)\n        return optimised_blacklist\n\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        blacklist = []\n        whitelist = []\n        for line in lines[1:n + 1]:\n            if line[0] == '+':\n                whitelist.append(line[1:])\n            elif line[0] == '-':\n                blacklist.append(line[1:])\n        return blacklist, whitelist\n\n    def main(stdin: str) -> str:\n        blacklist, whitelist = parse_input(stdin)\n        optimised_blacklist = blacklist_optimizer(blacklist, whitelist)\n        if any(subnet in optimised_blacklist for subnet in whitelist):\n            return '-1'\n        else:\n            output = [str(len(optimised_blacklist))] + optimised_blacklist\n            return '\\n'.join(output)\n\n    return main(stdin) "
    },
    {
        "number": 3705,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    digits = stdin.readline().strip()\n\n    phone_numbers = []\n    for i in range(n - 10):\n        for j in range(i + 1, n - 9 + i):\n            for k in range(j + 1, n - 8 + j):\n                for l in range(k + 1, n - 7 + k):\n                    for m in range(l + 1, n - 6 + l):\n                        for p in range(m + 1, n - 5 + m):\n                            for q in range(p + 1, n - 4 + p):\n                                for r in range(q + 1, n - 3 + q):\n                                    for s in range(r + 1, n - 2 + r):\n                                        for t in range(s + 1, n - 1 + s):\n                                            for u in range(t + 1, n):\n                                                phone_number = \"8\" + digits[i] + digits[j] + digits[k] + digits[l] + digits[m] + digits[p] + digits[q] + digits[r] + digits[s] + digits[t] + digits[u]\n                                                if phone_number not in phone_numbers:\n                                                    phone_numbers.append(phone_number)\n\n    return str(len(phone_numbers))"
    },
    {
        "number": 3706,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_moves(grid, n, m, g):\n        moves = []\n        for i in range(n):\n            if sum(grid[i]) != g[i]:\n                for j in range(m):\n                    if grid[i][j] == 0:\n                        grid[i][j] = 1\n                        if sum(grid[i]) == g[i]:\n                            moves.append(f\"row {i + 1}\")\n                            return moves, len(moves)\n                        else:\n                            grid[i][j] = 0\n        for j in range(m):\n            if sum(grid[i][j] for i in range(n)) != g[j]:\n                for i in range(n):\n                    if grid[i][j] == 0:\n                        grid[i][j] = 1\n                        if sum(grid[i][j] for i in range(n)) == g[j]:\n                            moves.append(f\"col {j + 1}\")\n                            return moves, len(moves)\n                        else:\n                            grid[i][j] = 0\n        return moves, -1\n\n    def process_input(stdin: str) -> tuple:\n        n, m = map(int, stdin.split()[:2])\n        grid = [list(map(int, stdin.split()[2 + i * m:2 + (i + 1) * m])) for i in range(n)]\n        g = [sum(grid[i]) for i in range(n)]\n        return n, m, grid, g\n\n    n, m, grid, g = process_input(stdin)\n    moves, min_moves = find_min_moves(grid, n, m, g)\n\n    if min_moves == -1:\n        return \"-1\"\n    else:\n        output = [str(min_moves)] + moves\n        return \"\\n\".join(output)"
    },
    {
        "number": 3707,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, k, d = map(int, stdin.split())\n\n    time_needed = n * t\n\n    if d >= time_needed:\n        return \"NO\"\n\n    time_with_second_oven = time_needed - d + t\n\n    if time_with_second_oven < time_needed:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3708,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    volcanoes = set()\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        volcanoes.add((x, y))\n\n    if (n, n) in volcanoes:\n        return \"-1\"\n\n    dp = [[float(\"inf\") for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[1][1] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if (i, j) in volcanoes:\n                continue\n\n            if i + 1 <= n:\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1)\n            if j + 1 <= n:\n                dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + 1)\n\n    return str(dp[n][n]) if dp[n][n] != float(\"inf\") else \"-1\""
    },
    {
        "number": 3709,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    problems = []\n    for _ in range(n):\n        problems.append(list(map(int, stdin.readline().split())))\n\n    for team in range(k):\n        known_problems = 0\n        for problem in problems:\n            if problem[team] == 1:\n                known_problems += 1\n        if known_problems > n // 2:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 3710,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    ancient_numbers = list(map(int, stdin.split()[2:]))\n\n    if k in ancient_numbers:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 3711,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n\n    if k > 2 * (n + m - 1):\n        return \"-1\"\n\n    area = n * m\n    if k % 2 == 0:\n        return str(area // 2)\n    else:\n        return str(min(n, m))"
    },
    {
        "number": 3712,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, students = map(int, stdin.split())\n    students = sorted(students, reverse=True)\n\n    count = 0\n    for i in range(n):\n        if students[i] == 1 or students[i] == 2:\n            count += 1\n        elif students[i] == 3 or students[i] == 4:\n            count += 2\n\n    return str(count) if count <= n else \"-1\""
    },
    {
        "number": 3713,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def longest_alternating_subsequence(s: str) -> int:\n        n = len(s)\n        dp = [1] * n\n        for i in range(n):\n            if s[i] == '0':\n                dp[i] = 1\n            else:\n                if i > 0:\n                    dp[i] = dp[i - 1] + 1\n                if i > 1 and s[i - 1] == '1' and s[i - 2] == '0':\n                    dp[i] = max(dp[i], dp[i - 2] + 1)\n        return max(dp)\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            new_s = s[:i] + s[i:j].replace('0', '2').replace('1', '0').replace('2', '1') + s[j:]\n            max_length = max(max_length, longest_alternating_subsequence(new_s))\n\n    return max_length"
    },
    {
        "number": 3714,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    crushes = list(map(int, stdin.readline().strip().split()))\n\n    def find_joon_joon(start, t):\n        if crushes[start - 1] == start:\n            return start\n        return find_joon_joon(crushes[start - 1], t - 1)\n\n    def is_valid_t(t):\n        for i in range(1, n + 1):\n            joon_joon = find_joon_joon(i, t)\n            if joon_joon != i:\n                return False\n        return True\n\n    t = 1\n    while True:\n        if is_valid_t(t):\n            return str(t)\n        t += 1\n\n    return \"-1\""
    },
    {
        "number": 3715,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    rest_days = 0\n    prev_sport = False\n    prev_contest = False\n\n    for i in range(n):\n        if a[i] == 2:\n            if prev_sport:\n                rest_days += 1\n            prev_sport = True\n            prev_contest = False\n        elif a[i] == 3:\n            if prev_contest:\n                rest_days += 1\n            prev_sport = False\n            prev_contest = True\n        else:\n            prev_sport = False\n            prev_contest = False\n\n    return str(rest_days)"
    },
    {
        "number": 3716,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        lcm = 1\n        for i in range(2, n + 1):\n            lcm = (i * lcm) // gcd(i, lcm)\n        return lcm\n\ndef"
    },
    {
        "number": 3717,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(x, y, rectangles):\n        for rect in rectangles:\n            if rect[0] <= x <= rect[2] and rect[1] <= y <= rect[3]:\n                return True\n        return False\n\n    n = int(stdin.readline().strip())\n    rectangles = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        rectangles.append((x1, y1, x2, y2))\n\n    for x in range(1000000001):\n        for y in range(1000000001):\n            if is_inside(x, y, rectangles):\n                return f\"{x} {y}\\n\"\n\n    return \"-1\\n\""
    },
    {
        "number": 3718,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    balls = sorted(list(map(int, stdin.split('\\n')[1].split())))\n\n    for i in range(n - 2):\n        if balls[i + 2] - balls[i] <= 2:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 3719,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    y1 = list(map(int, stdin.readline().split()))\n    y2 = list(map(int, stdin.readline().split()))\n\n    y1.sort()\n    y2.sort()\n\n    i, j = 0, 0\n    count = 0\n\n    while i < n and j < m:\n        if abs(y1[i] - y2[j]) <= 10000:\n            count += 1\n            i += 1\n            j += 1\n        elif y1[i] < y2[j]:\n            i += 1\n        else:\n            j += 1\n\n    return str(count)"
    },
    {
        "number": 3720,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"Vasya\"\n    elif n == 2:\n        return \"Petya\"\n    else:\n        return \"Petya\" if n % 2 == 0 else \"Vasya\" "
    },
    {
        "number": 3721,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    elements = set()\n    for _ in range(q):\n        r, c = map(int, input().split())\n        elements.add((r, c))\n\n    def can_produce(r1, c1, r2, c2):\n        return (r1, c1) in elements and (r2, c2) in elements and (r1 != r2 or c1 != c2)\n\n    missing_elements = set()\n    for r1 in range(1, n + 1):\n        for c1 in range(1, m + 1):\n            for r2 in range(1, n + 1):\n                for c2 in range(1, m + 1):\n                    if can_produce(r1, c1, r2, c2):\n                        missing_elements.add((r2, c2))\n\n    return len(missing_elements - elements)"
    },
    {
        "number": 3722,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, c_AA, c_AB, c_BA, c_BB = stdin.split()\n    N = int(N)\n    mod = 10**9 + 7\n\n    if N == 2:\n        if c_AA == c_AB == c_BA == c_BB:\n            return str(2)\n        elif c_AA == c_AB == c_BA or c_AA == c_AB == c_BB or c_AA == c_BA == c_BB or c_AB == c_BA == c_BB:\n            return str(1)\n        else:\n            return str(0)\n\n    if c_AA == c_AB == c_BA == c_BB:\n        return str((2**(N-2)) % mod)\n    elif c_AA == c_AB == c_BA or c_AA == c_AB == c_BB or c_AA == c_BA == c_BB or c_AB == c_BA == c_BB:\n        return str((2**(N-2) + 1) % mod)\n    else:\n        return str((2**(N-2) + 2**(N-3)) % mod)"
    },
    {
        "number": 3723,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pokemons = list(map(int, stdin.split('\\n')[1].split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_valid(pokemons):\n        for i in range(len(pokemons)):\n            for j in range(len(pokemons)):\n                if i != j and gcd(pokemons[i], pokemons[j]) == 1:\n                    return False\n        return True\n\n    pokemons.sort()\n    max_pokemons = 0\n    for i in range(1, n + 1):\n        for j in range(n - i + 1):\n            if is_valid(pokemons[j:j + i]):\n                max_pokemons = max(max_pokemons, i)\n\n    return str(max_pokemons)"
    },
    {
        "number": 3724,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split()\n    n = int(n)\n    s = list(s)\n    mod = 10**9 + 7\n\n    def count_distinct_strings(s: List[str]) -> int:\n        distinct_strings = set()\n        for i in range(len(s) - 1):\n            if s[i] != s[i + 1]:\n                for c in set(\"ABC\") - set(s[i] + s[i + 1]):\n                    new_s = s[:i] + [c] + s[i + 2:]\n                    distinct_strings.add(tuple(new_s))\n        return len(distinct_strings)\n\n    return count_distinct_strings(s) % mod"
    },
    {
        "number": 3725,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.split('\\n')[0])\n    h_1, a_1 = map(int, stdin.split('\\n')[1].split())\n    x_1, y_1 = map(int, stdin.split('\\n')[2].split())\n    h_2, a_2 = map(int, stdin.split('\\n')[3].split())\n    x_2, y_2 = map(int, stdin.split('\\n')[4].split())\n\n    time = 0\n    while True:\n        h_1 = (x_1 * h_1 + y_1) % m\n        h_2 = (x_2 * h_2 + y_2) % m\n        time += 1\n\n        if h_1 == a_1 and h_2 == a_2:\n            return str(time)\n        elif h_1 == a_1 or h_2 == a_2:\n            return '-1'"
    },
    {
        "number": 3726,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def find_min_operations(cards: list) -> int:\n        n = len(cards)\n        operations = 0\n\n        for p in range(3, n + 1):\n            if is_prime(p):\n                for i in range(n - p + 1):\n                    if all(cards[i + j] for j in range(p)):\n                        for j in range(p):\n                            cards[i + j] -= 1\n                        operations += 1\n\n        return operations\n\n    N, *cards = list(map(int, stdin.split()))\n    return str(find_min_operations(cards))"
    },
    {
        "number": 3727,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n\n    if a + b + c + d <= 2 or (a + b + c + d) % 2 == 1:\n        return \"NO\"\n\n    sequence = []\n    for _ in range(a):\n        sequence.append(0)\n    for _ in range(b):\n        sequence.append(1)\n    for _ in range(c):\n        sequence.append(2)\n    for _ in range(d):\n        sequence.append(3)\n\n    return \"YES\\n\" + \" \".join(map(str, sequence))"
    },
    {
        "number": 3728,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    table = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    def is_sorted(row: list) -> bool:\n        return all(row[i] < row[i + 1] for i in range(len(row) - 1))\n\n    def is_identity(row: list) -> bool:\n        return row == list(range(1, m + 1))\n\n    def can_obtain_identity(table: list) -> bool:\n        for row in table:\n            if not is_sorted(row):\n                if not is_identity(row):\n                    return False\n        return True\n\n    if can_obtain_identity(table):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3729,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    f, w, h = map(int, stdin.split())\n    total_arrangements = 2**f * 2**w\n    good_arrangements = 2**f * (2**w - (w - h))\n    probability = good_arrangements / total_arrangements\n    p = int(probability)\n    q = 10**9 + 7\n    return f\"{p * pow(q - 2, q - 10, q)}\""
    },
    {
        "number": 3730,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_length = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j - i + 1 > max_length:\n                if all(a[k] < a[k + 1] for k in range(i, j)):\n                    max_length = j - i + 1\n                    max_start = i\n                    max_end = j\n\n            if j - i + 1 > max_length and any(a[k] >= a[k + 1] for k in range(i, j)):\n                for k in range(i, j):\n                    if a[k] >= a[k + 1]:\n                        if k == i or k == j - 1 or (a[k - 1] < a[k + 1] and a[k] < a[k - 1]):\n                            if k == i:\n                                if a[k] < a[k + 2]:\n                                    max_length = j - i + 1\n                                    max_start = i\n                                    max_end = j\n                            elif k == j - 1:\n                                if a[k] < a[k - 1]:\n                                    max_length = j - i + 1\n                                    max_start = i\n                                    max_end = j\n                            else:\n                                if a[k] < a[k + 1] and a[k] < a[k - 1]:\n                                    max_length = j - i + 1\n                                    max_start = i\n                                    max_end = j\n                            break\n\n    return str(max_length)"
    },
    {
        "number": 3731,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, l, r = map(int, stdin.split())\n    s = \"abcdefghijklmnopqrstuvwxyz\"[:a]\n    t = \"\"\n    while len(t) < a:\n        for c in s:\n            if c not in t:\n                t += c\n                if len(t) == a:\n                    break\n    s += t\n    return len(set(s[l-1:r]))"
    },
    {
        "number": 3732,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, m = map(int, stdin.split())\n\n    if x >= m or y >= m:\n        return \"0\"\n\n    if x < 0 and y < 0:\n        return \"-1\"\n\n    if x < 0:\n        x = 0\n\n    if y < 0:\n        y = 0\n\n    if x + y >= m:\n        return \"1\"\n\n    if x == y:\n        if x + y < m:\n            return \"-1\"\n        else:\n            return \"1\"\n\n    steps = 1\n    while x < m and y < m:\n        if x < y:\n            x += y\n        else:\n            y += x\n        steps += 1\n\n    if x >= m or y >= m:\n        return str(steps)\n    else:\n        return \"-1\""
    },
    {
        "number": 3733,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, I = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    K = len(set(a))\n    k = ceil(log2(K))\n\n    if k * n <= I * 8:\n        return 0\n\n    a.sort()\n    l = a[0]\n    r = a[-1]\n\n    while True:\n        changed = sum(1 for x in a if x < l or x > r)\n        bits_needed = ceil(log2(K - 1))\n        bits_per_value = k + bits_needed\n        total_bits = n * bits_per_value\n\n        if total_bits <= I * 8:\n            return changed\n\n        if l == r:\n            break\n\n        if l + 1 < r:\n            l += 1\n            r -= 1\n        else:\n            break\n\n    return min(sum(1 for x in a if x < l), sum(1 for x in a if x > r))"
    },
    {
        "number": 3734,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    days = [\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"]\n    day1, day2 = stdin.split(\"\\n\")\n    day1_index, day2_index = days.index(day1), days.index(day2)\n\n    if day1_index == day2_index:\n        return \"NO\"\n    elif day1_index < day2_index:\n        return \"YES\" if (day2_index - day1_index) % 7 == 1 else \"NO\"\n    else:\n        return \"YES\" if (day1_index - day2_index) % 7 == 6 else \"NO\" "
    },
    {
        "number": 3735,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_sum = 0\n\n    for a in range(n + 1):\n        b = n - a\n        if 0 <= b <= n:\n            max_sum = max(max_sum, sum(int(digit) for digit in str(a)) + sum(int(digit) for digit in str(b)))\n\n    return str(max_sum)"
    },
    {
        "number": 3736,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    name = stdin.strip()\n    mirror_name = name[::-1]\n\n    if name == mirror_name:\n        return 'YES'\n    else:\n        return 'NO'"
    },
    {
        "number": 3737,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    stewards = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for i in range(n):\n        less_than = [steward for steward in stewards if steward < stewards[i]]\n        greater_than = [steward for steward in stewards if steward > stewards[i]]\n        if less_than and greater_than:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3738,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.readline().strip().split())\n    s = stdin.readline().strip()\n\n    x, y = 0, 0\n    for move in s:\n        if move == 'U':\n            y += 1\n        elif move == 'D':\n            y -= 1\n        elif move == 'L':\n            x -= 1\n        elif move == 'R':\n            x += 1\n\n    if x == a and y == b:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 3739,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    for line in lines:\n        if not line.strip():\n            continue\n        tokens = line.split()\n        if len(tokens) != 3:\n            return '0'\n        try:\n            even_number = int(tokens[0])\n            prime1 = int(tokens[1])\n            prime2 = int(tokens[2])\n        except ValueError:\n            return '0'\n\n        if even_number % 2 != 0 or even_number < 4:\n            return '0'\n\n        if not is_prime(prime1) or not is_prime(prime2):\n            return '0'\n\n        if prime1 + prime2 != even_number:\n            return '0'\n    return '1'\n\ndef"
    },
    {
        "number": 3740,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = int(stdin)\n    mod = 10**9 + 7\n    count = 0\n\n    for l in range(1, 10):\n        for r in range(l, 10):\n            if f(l) + f(l + 1) + ... + f(r) == S:\n                count += 1\n                count %= mod\n\n    return str(count)\n\ndef"
    },
    {
        "number": 3741,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bitwise_and(a: int, b: int) -> int:\n        return a & b\n\n    def is_connected(a: int, b: int) -> bool:\n        return bitwise_and(a, b) != 0\n\n    def find_shortest_cycle(graph: List[List[int]]) -> int:\n        n = len(graph)\n        visited = [False] * n\n        distances = [float('inf')] * n\n        queue = deque()\n\n        for i in range(n):\n            if not visited[i]:\n                distances[i] = 0\n                queue.append(i)\n\n                while queue:\n                    node = queue.popleft()\n                    visited[node] = True\n\n                    for neighbor in graph[node]:\n                        if not visited[neighbor]:\n                            distances[neighbor] = distances[node] + 1\n                            queue.append(neighbor)\n\n        shortest_cycle = float('inf')\n        for i in range(n):\n            for neighbor in graph[i]:\n                if distances[i] + distances[neighbor] + 2 < shortest_cycle:\n                    shortest_cycle = distances[i] + distances[neighbor] + 2\n\n        return shortest_cycle if shortest_cycle != float('inf') else -1\n\n    def build_graph(numbers: List[int]) -> List[List[int]]:\n        graph = [[] for _ in range(len(numbers))]\n        for i in range(len(numbers)):\n            for j in range(i + 1, len(numbers)):\n                if is_connected(numbers[i], numbers[j]):\n                    graph[i].append(j)\n                    graph[j].append(i)\n        return graph\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    numbers = list(map(int, lines[1].strip().split()))\n\n    graph = build_graph(numbers)\n    shortest_cycle = find_shortest_cycle(graph)\n\n    return str(shortest_cycle)"
    },
    {
        "number": 3742,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, bulbs = map(int, stdin.split())\n    bulbs = list(filter(lambda x: x != 0, bulbs))\n    bulbs.sort()\n\n    complexity = 0\n    for i in range(len(bulbs) - 1):\n        if bulbs[i] % 2 != bulbs[i + 1] % 2:\n            complexity += 1\n\n    return complexity"
    },
    {
        "number": 3743,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        return n\n\n    # Read input\n    n = int(input())\n\n    # Calculate the maximum number of colors\n    if n == 1:\n        max_colors = 1\n    elif n == 2:\n        max_colors = 2\n    else:\n        max_colors = n\n\n    # Print the result\n    print(max_colors) "
    },
    {
        "number": 3744,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, s = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    max_strength = 0\n    programming_team = []\n    sports_team = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if len(programming_team) == p and len(sports_team) == s:\n                    break\n                if len(programming_team) < p and (i not in programming_team) and (j not in programming_team) and (k not in programming_team):\n                    programming_team.append(i)\n                    programming_team.append(j)\n                    programming_team.append(k)\n                if len(sports_team) < s and (i not in sports_team) and (j not in sports_team) and (k not in sports_team):\n                    sports_team.append(i)\n                    sports_team.append(j)\n                    sports_team.append(k)\n                if len(programming_team) == p and len(sports_team) == s:\n                    strength = sum([a[i] for i in programming_team]) + sum([b[i] for i in sports_team])\n                    if strength > max_strength:\n                        max_strength = strength\n                        programming_team_copy = programming_team.copy()\n                        sports_team_copy = sports_team.copy()\n\n    return f\"{max_strength}\\n{' '.join(map(str, programming_team_copy))}\\n{' '.join(map(str, sports_team_copy))}\""
    },
    {
        "number": 3745,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    edges = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    def is_valid(s: str) -> bool:\n        for u, v in edges:\n            if s[u - 1] not in ('a', 'b', 'c') or s[v - 1] not in ('a', 'b', 'c'):\n                return False\n            if abs(ord(s[u - 1]) - ord(s[v - 1])) != 1:\n                return False\n        return True\n\n    for s in ('a', 'b', 'c'):\n        if is_valid(s * n):\n            return \"Yes\\n\" + s * n\n    return \"No\""
    },
    {
        "number": 3746,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def hanoi(n, src, dst, via, t):\n        if n == 1:\n            return t[src][dst]\n        else:\n            return t[src][via] + hanoi(n - 1, src, via, dst, t) + t[via][dst]\n\n    lines = stdin.split('\\n')\n    t = [[int(x) for x in line.split()] for line in lines[:3]]\n    n = int(lines[3])\n\n    return str(hanoi(n, 1, 3, 2, t))"
    },
    {
        "number": 3747,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    count = 0\n    for i in range(len(s) - 9):\n        if s[i] == 'b' and s[i + 1] == 'u' and s[i + 2] == 'l' and s[i + 3] == 'b' and s[i + 4] == 'a' and s[i + 5] == 's' and s[i + 6] == 'a' and s[i + 7] == 'u' and s[i + 8] == 'r':\n            count += 1\n    return count"
    },
    {
        "number": 3748,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.readline().split())\n    S = [stdin.readline().strip() for _ in range(H)]\n\n    for i in range(H):\n        for j in range(W):\n            if S[i][j] != S[H - i - 1][W - j - 1]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3749,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor(a, b):\n        return a ^ b\n\n    def mod_pow(base, exponent, modulus):\n        result = 1\n        base = base % modulus\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % modulus\n            exponent = exponent // 2\n            base = (base * base) % modulus\n        return result\n\n    def count_bits(n):\n        count = 0\n        while n:\n            n &= (n - 1)\n            count += 1\n        return count\n\n    def count_integers(n, x):\n        mod = 998244353\n        return (mod_pow(2, count_bits(x) - n, mod) + mod_pow(2, count_bits(x) - n - 1, mod) * (x - 2**n + 1)) % mod\n\n    lines = stdin.split('\\n')\n    n, x = map(int, lines[0].split())\n    a = [int(line, 2) for line in lines[1:n + 1]]\n\n    return str(count_integers(n, x))"
    },
    {
        "number": 3750,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n\n    if a + b <= k:\n        return \"-1\"\n\n    sets = 0\n    misha_points = 0\n    vanya_points = 0\n\n    while misha_points != k and vanya_points != k:\n        if misha_points < k and vanya_points < k:\n            if misha_points + a <= k:\n                misha_points += a\n            else:\n                misha_points = k\n\n            if vanya_points + b <= k:\n                vanya_points += b\n            else:\n                vanya_points = k\n        else:\n            if misha_points == k:\n                vanya_points = 0\n            else:\n                misha_points = 0\n\n        sets += 1\n\n    return str(sets)"
    },
    {
        "number": 3751,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    identifiers = []\n    current_identifier = \"\"\n    \n    for char in stdin:\n        if char.islower():\n            current_identifier += char\n        else:\n            if current_identifier:\n                identifiers.append(current_identifier)\n                current_identifier = \"\"\n    \n    if current_identifier:\n        identifiers.append(current_identifier)\n    \n    if len(set(identifiers)) > 26:\n        return \"NO\"\n    \n    return \"YES\""
    },
    {
        "number": 3752,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, d, t = map(int, stdin.split())\n\n    if t * 2 <= k:\n        return str(t * 2 / 6)\n\n    time_on_stove = t / 6\n    time_off_stove = t / 12\n    total_time = time_on_stove + time_off_stove\n\n    while total_time < k:\n        time_on_stove += t / 6\n        time_off_stove += t / 12\n        total_time += d\n\n    return str(time_on_stove + time_off_stove)"
    },
    {
        "number": 3753,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    island = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= m and island[x - 1][y - 1] != \"#\"\n\n    def bfs():\n        queue = [(1, 1)]\n        visited = set()\n\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) not in visited:\n                visited.add((x, y))\n                if x == n and y == m:\n                    return True\n                if is_valid(x + 1, y):\n                    queue.append((x + 1, y))\n                if is_valid(x, y + 1):\n                    queue.append((x, y + 1))\n\n        return False\n\n    result = 0\n    for i in range(n):\n        for j in range(m):\n            if island[i][j] == \".\":\n                island[i][j] = \"#\"\n                if not bfs():\n                    result += 1\n                island[i][j] = \".\"\n\n    return str(result)"
    },
    {
        "number": 3754,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *d = map(int, stdin.split())\n    MOD = 998244353\n\n    def count_ways(N, d):\n        dp = [[0] * N for _ in range(N)]\n        for i in range(N):\n            dp[i][i] = 1\n\n        for l in range(2, N + 1):\n            for i in range(N - l + 1):\n                j = i + l - 1\n                for k in range(i, j):\n                    dp[i][j] += dp[i][k] * dp[k + 1][j]\n                    dp[i][j] %= MOD\n\n        return dp[0][N - 1]\n\n    return str(count_ways(N, d))"
    },
    {
        "number": 3755,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_index(arr):\n        max_index = 0\n        for i in range(1, len(arr) - 1):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        return max_index\n\n    def find_max_value(arr):\n        max_index = find_max_index(arr)\n        if max_index == 0:\n            return arr[max_index] + arr[max_index + 1], [max_index + 1]\n        elif max_index == len(arr) - 1:\n            return arr[max_index] + arr[max_index - 1], [max_index - 1]\n        else:\n            left_sum = arr[max_index] + arr[max_index - 1]\n            right_sum = arr[max_index] + arr[max_index + 1]\n            if left_sum > right_sum:\n                return left_sum, [max_index - 1, max_index + 1]\n            else:\n                return right_sum, [max_index, max_index + 1]\n\n    N = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    max_value, indices = find_max_value(arr)\n    operations = len(indices)\n\n    output = [str(max_value), str(operations)]\n    for index in indices:\n        output.append(str(index + 1))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3756,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    grade = float(input())\n\n    def round_grade(grade: float, position: int) -> float:\n        rounded_grade = round(grade, position)\n        if position == 0:\n            return rounded_grade\n        return round_grade(rounded_grade, position - 1)\n\n    max_grade = grade\n    for i in range(1, n + 1):\n        max_grade = max(max_grade, round_grade(grade, i))\n\n    return str(max_grade)\n"
    },
    {
        "number": 3757,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_00, a_01, a_10, a_11 = map(int, stdin.split())\n\n    if a_00 + a_01 + a_10 + a_11 == 0:\n        return \"Impossible\"\n\n    s = \"\"\n    while len(s) <= 1000000:\n        if a_00 == 0 and a_01 == 0 and a_10 == 0 and a_11 == 0:\n            return s\n\n        if a_00 > 0:\n            a_00 -= 1\n            s += \"00\"\n        elif a_01 > 0:\n            a_01 -= 1\n            s += \"01\"\n        elif a_10 > 0:\n            a_10 -= 1\n            s += \"10\"\n        elif a_11 > 0:\n            a_11 -= 1\n            s += \"11\"\n\n    return \"Impossible\"\n"
    },
    {
        "number": 3758,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, field = stdin.split('\\n')\n    n = int(n)\n    packmen_positions = [i for i in range(n) if field[i] == 'P']\n    asterisks_positions = [i for i in range(n) if field[i] == '*']\n    time = 0\n\n    while asterisks_positions:\n        time += 1\n        for i in packmen_positions:\n            if i - 1 in asterisks_positions:\n                asterisks_positions.remove(i - 1)\n            if i + 1 in asterisks_positions:\n                asterisks_positions.remove(i + 1)\n            if not asterisks_positions:\n                break\n\n    return str(time)"
    },
    {
        "number": 3759,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    min_blocked_points = 4\n    for i in range(1, n + 1):\n        min_blocked_points += 4 * i\n    return str(min_blocked_points)"
    },
    {
        "number": 3760,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, a, b = map(int, stdin.split())\n\n    def is_valid(x1, y1, x2, y2):\n        return (x1, y1, x2, y2) == sorted((x1, x2, x, x)) and (x2 - x1) * (y2 - y1) == a * b\n\n    def distance(x1, y1, x2, y2):\n        center_x = (x1 + x2) / 2\n        center_y = (y1 + y2) / 2\n        return ((x - center_x) ** 2 + (y - center_y) ** 2) ** 0.5\n\n    candidates = [(i, j, i + a, j + b) for i in range(x) for j in range(y) if is_valid(i, j, i + a, j + b)]\n    if not candidates:\n        return \"No solution found\"\n\n    closest = min(candidates, key=lambda rect: distance(*rect))\n    return \" \".join(map(str, closest))"
    },
    {
        "number": 3761,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x, y = stdin.split()\n    x, y = int(x), int(y)\n\n    dx = [0, -1, 0, 1]\n    dy = [1, 0, -1, 0]\n    direction = 0\n\n    for instruction in s:\n        if instruction == 'F':\n            nx = x + dx[direction]\n            ny = y + dy[direction]\n            if abs(nx) > abs(x) or abs(ny) > abs(y):\n                return 'No'\n            x, y = nx, ny\n        elif instruction == 'T':\n            direction = (direction + 1) % 4\n\n    if x == 0 and y == 0:\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
        "number": 3762,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    dp[1] = 2\n\n    for i in range(2, k + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % (10**9 + 7)\n        for j in range(i - 1, 0, -1):\n            if i ^ j not in range(i):\n                dp[i] = (dp[i] + dp[i - 1] * dp[j]) % (10**9 + 7)\n\n    return str(dp[k])"
    },
    {
        "number": 3763,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, p = map(int, stdin.split())\n    a.sort()\n    total_people = 0\n    for i in range(n):\n        if sum(a[:i + 1]) <= p:\n            total_people += 1\n        else:\n            break\n    return str(total_people / n)"
    },
    {
        "number": 3764,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    rangers = list(map(int, input().split()))\n    rangers.sort()\n\n    for i in range(1, n, 2):\n        rangers[i] ^= x\n\n    for _ in range(k - 1):\n        rangers.sort()\n        for i in range(1, n, 2):\n            rangers[i] ^= x\n\n    return f\"{max(rangers)} {min(rangers)}\""
    },
    {
        "number": 3765,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, h, w, n = map(int, stdin.split()[0].split())\n    extensions = list(map(int, stdin.split()[1].split()))\n\n    min_extensions = -1\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                width = max(h * extensions[i], w * extensions[j])\n                length = max(h * extensions[j], w * extensions[i])\n            else:\n                width = max(h * extensions[i], w)\n                length = max(h, w * extensions[i])\n\n            if width >= a and length >= b:\n                min_extensions = i + j + 1\n                break\n        if min_extensions != -1:\n            break\n\n    return str(min_extensions)"
    },
    {
        "number": 3766,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    cards = stdin.split('\\n')[1].split()\n    colors = set([card[0] for card in cards])\n    values = set([card[1] for card in cards])\n\n    min_hints = 0\n\n    for color in colors:\n        count = 0\n        for card in cards:\n            if card[0] == color:\n                count += 1\n        if count > 1:\n            min_hints += 1\n\n    for value in values:\n        count = 0\n        for card in cards:\n            if card[1] == value:\n                count += 1\n        if count > 1:\n            min_hints += 1\n\n    return str(min_hints)"
    },
    {
        "number": 3767,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    total_soda = sum(a)\n    k = 1\n    t = 0\n\n    while total_soda > 0:\n        current_bottle = 0\n        max_volume = 0\n\n        for i in range(n):\n            if b[i] > max_volume and a[i] > 0:\n                max_volume = b[i]\n                current_bottle = i\n\n        pour_amount = min(a[current_bottle], b[current_bottle] - a[current_bottle])\n        a[current_bottle] -= pour_amount\n        total_soda -= pour_amount\n        t += pour_amount\n\n        if a[current_bottle] == 0:\n            k += 1\n\n    return f\"{k} {t}\""
    },
    {
        "number": 3768,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n\n    if x == 0 or y == 0:\n        return \"Impossible\"\n\n    if x == 1 and y == 1:\n        return \"AB\"\n\n    if x == 2 and y == 2:\n        return \"Impossible\"\n\n    if x == 3 and y == 2:\n        return \"1A1B\"\n\n    if x == 4 and y == 3:\n        return \"3B\"\n\n    return \"Impossible\"\n"
    },
    {
        "number": 3769,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n    return str((k * pow(k, p - 2, p)) % MOD)"
    },
    {
        "number": 3770,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, i):\n        t = parent[i]\n        if t < 0:\n            return i\n        t = find(parent, t)\n        parent[i] = t\n        return t\n\n    def union(parent, i, j):\n        i = find(parent, i)\n        j = find(parent, j)\n        if i == j:\n            return False\n        parent[j] += parent[i]\n        parent[i] = j\n        return True\n\n    def get_score(parent, B):\n        score = 0\n        for i in range(1, len(parent)):\n            if parent[i] < 0:\n                score += abs(B[i - 1])\n        return score\n\n    N, M = map(int, stdin.readline().split())\n    A = list(map(int, stdin.readline().split()))\n    B = list(map(int, stdin.readline().split()))\n    parent = [-1] * N\n    edges = []\n    for _ in range(M):\n        u, v = map(int, stdin.readline().split())\n        union(parent, u, v)\n        edges.append((u, v))\n\n    max_profit = float('-inf')\n    for i in range(1, N + 1):\n        if find(parent, i) == i:\n            profit = get_score(parent, B)\n            for u, v in edges:\n                if u == i:\n                    profit -= A[v - 1]\n                elif v == i:\n                    profit -= A[u - 1]\n            max_profit = max(max_profit, profit)\n\n    return str(max_profit)"
    },
    {
        "number": 3771,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_leaf(matrix, leaf):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == leaf:\n                    return (i, j)\n        return None\n\n    def is_reachable(matrix, start, end):\n        visited = set()\n        queue = [start]\n\n        while queue:\n            current = queue.pop(0)\n            if current == end:\n                return True\n            if current in visited:\n                continue\n            visited.add(current)\n\n            row, col = current\n            if row - 1 >= 0 and matrix[row - 1][col] != '.':\n                queue.append((row - 1, col))\n            if row + 1 < len(matrix) and matrix[row + 1][col] != '.':\n                queue.append((row + 1, col))\n            if col - 1 >= 0 and matrix[row][col - 1] != '.':\n                queue.append((row, col - 1))\n            if col + 1 < len(matrix[0]) and matrix[row][col + 1] != '.':\n                queue.append((row, col + 1))\n\n        return False\n\n    H, W = map(int, stdin.readline().split())\n    matrix = [list(stdin.readline().strip()) for _ in range(H)]\n\n    S_pos = find_leaf(matrix, 'S')\n    T_pos = find_leaf(matrix, 'T')\n\n    if is_reachable(matrix, S_pos, T_pos):\n        return -1\n    else:\n        leaves_to_remove = 0\n        for i in range(H):\n            for j in range(W):\n                if matrix[i][j] == 'o' and (i, j) != S_pos and (i, j) != T_pos:\n                    leaves_to_remove += 1\n                    if is_reachable(matrix, S_pos, T_pos):\n                        return -1\n        return leaves_to_remove "
    },
    {
        "number": 3772,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == 1 and b == 1:\n        return \"1\"\n    elif a == 0 and b == 1:\n        return \"0\"\n    else:\n        return str(b)"
    },
    {
        "number": 3773,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    stones = []\n    for i in range(1, N + 1):\n        A_i, K_i = map(int, stdin.split('\\n')[i].split())\n        stones.append((A_i, K_i))\n\n    takahashi_turn = True\n    while True:\n        stones_copy = stones.copy()\n        for i, (A_i, K_i) in enumerate(stones):\n            if takahashi_turn:\n                max_stones = A_i // K_i\n            else:\n                max_stones = A_i // (K_i + 1)\n\n            if max_stones > 0:\n                stones_copy[i] = (A_i - max_stones * K_i, K_i)\n            else:\n                stones_copy[i] = (A_i, K_i)\n\n        if stones_copy == stones:\n            break\n\n        stones = stones_copy\n        takahashi_turn = not takahashi_turn\n\n    if takahashi_turn:\n        return \"Takahashi\"\n    else:\n        return \"Aoki\""
    },
    {
        "number": 3774,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    max_chessmen = 0\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if abs(i - j) == 3:\n                max_chessmen += 1\n\n    return str(max_chessmen)"
    },
    {
        "number": 3775,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    set1 = set(map(tuple, stdin.readline().split()))\n    set2 = set(map(tuple, stdin.readline().split()))\n\n    shared_numbers = set1.intersection(set2)\n\n    if len(shared_numbers) == 1:\n        return str(shared_numbers.pop())\n    elif len(shared_numbers) > 1:\n        return \"0\"\n    else:\n        return \"-1\""
    },
    {
        "number": 3776,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    format, time = stdin.split('\\n')\n    hours, minutes = time.split(':')\n    hours, minutes = int(hours), int(minutes)\n\n    if format == '24':\n        if hours < 0 or hours > 23 or minutes < 0 or minutes > 59:\n            return 'Invalid time'\n        else:\n            return '{:02d}:{:02d}'.format(hours, minutes)\n    elif format == '12':\n        if hours < 1 or hours > 12 or minutes < 0 or minutes > 59:\n            return 'Invalid time'\n        else:\n            if hours > 12:\n                hours -= 12\n            elif hours == 0:\n                hours = 12\n            return '{:02d}:{:02d}'.format(hours, minutes)\n    else:\n        return 'Invalid format'"
    },
    {
        "number": 3777,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find(parent, i):\n        if parent[i] == i:\n            return i\n        return find(parent, parent[i])\n\n    def union(parent, rank, x, y):\n        xroot = find(parent, x)\n        yroot = find(parent, y)\n\n        if xroot == yroot:\n            return False\n\n        if rank[xroot] < rank[yroot]:\n            parent[xroot] = yroot\n        elif rank[xroot] > rank[yroot]:\n            parent[yroot] = xroot\n        else:\n            parent[yroot] = xroot\n            rank[xroot] += 1\n        return True\n\n    def kruskal(parent, rank):\n        edges.sort(key=lambda x: x[2])\n        MST = []\n        for edge in edges:\n            u, v, w = edge\n            if union(parent, rank, u, v):\n                MST.append(w)\n        return MST\n\n    N, M, X = map(int, stdin.readline().split())\n    edges = []\n    for _ in range(M):\n        u, v, w = map(int, stdin.readline().split())\n        edges.append((u, v, w))\n\n    parent = [i for i in range(N + 1)]\n    rank = [0] * (N + 1)\n    MST = kruskal(parent, rank)\n\n    white_edges = [edge for edge in edges if edge[2] <= X]\n    black_edges = [edge for edge in edges if edge[2] > X]\n\n    white_MST = kruskal(parent, rank)\n    black_MST = kruskal(parent, rank)\n\n    white_count = sum(1 for edge in white_edges if edge[2] <= X and (edge[2] in white_MST or edge[2] in black_MST))\n    black_count = sum(1 for edge in black_edges if edge[2] > X and (edge[2] in white_MST or edge[2] in black_MST))\n\n    return (white_count * black_count) % (10**9 + 7)"
    },
    {
        "number": 3778,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(targets: List[List[int]]) -> bool:\n        for i in range(n):\n            row_count = sum(1 for target in targets if target[0] == i + 1)\n            col_count = sum(1 for target in targets if target[1] == i + 1)\n            if row_count > 2 or col_count > 2:\n                return False\n        return True\n\n    def find_targets(a: List[int], targets: List[List[int]], index: int) -> bool:\n        if index == n:\n            return True\n\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if a[index] == 0 or (a[index] > 0 and not targets):\n                    targets.append([i, j])\n                    if find_targets(a, targets, index + 1):\n                        return True\n                    targets.pop()\n        return False\n\n    n, a = map(int, stdin.split())\n    a = list(map(int, a))\n\n    targets = []\n    if find_targets(a, targets, 0) and is_valid(targets):\n        print(len(targets))\n        for target in targets:\n            print(target[0], target[1])\n    else:\n        print(-1)\n\n    return 0"
    },
    {
        "number": 3779,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    def convert_to_martian(num, base):\n        martian_num = []\n        while num:\n            num, digit = divmod(num, base)\n            martian_num.append(str(digit))\n        return int(''.join(martian_num[::-1]))\n\n    def find_divine_digits(base):\n        divine_digits = set()\n        for num in a:\n            martian_num = convert_to_martian(num, base)\n            last_digit = martian_num % base\n            divine_digits.add(last_digit)\n        return divine_digits\n\n    divine_digits = find_divine_digits(k)\n    result = [str(d) for d in sorted(list(divine_digits))]\n\n    return str(len(result)) + '\\n' + ' '.join(result) + '\\n'"
    },
    {
        "number": 3780,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2, v_max, t = map(int, stdin.split()[0].split())\n    v1, w1, v2, w2 = map(lambda x: list(map(int, x.split())), stdin.split()[1:])\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def time_to_reach(x1, y1, x2, y2, v_x, v_y):\n        return distance(x1, y1, x2, y2) / ((v_x ** 2 + v_y ** 2) ** 0.5)\n\n    def position(x1, y1, v_x, v_y, t):\n        return x1 + t * v_x, y1 + t * v_y\n\n    def min_time(x1, y1, x2, y2, v_max, t, v1, w1, v2):\n        t1 = time_to_reach(x1, y1, x2, y2, v1[0], v1[1])\n        t2 = time_to_reach(x1, y1, x2, y2, v2[0], v2[1])\n        t3 = time_to_reach(x1, y1, x2, y2, w1[0], w1[1])\n        t4 = time_to_reach(x1, y1, x2, y2, w2[0], w2[1])\n\n        if t1 <= t:\n            return t1\n        elif t2 <= t:\n            return t2\n        elif t3 <= t:\n            return t3\n        else:\n            return t4\n\n    return f\"{min_time(x1, y1, x2, y2, v_max, t, v1, w1, v2):.15f}\""
    },
    {
        "number": 3781,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def game(a: List[int]) -> str:\n        n = len(a)\n        dp = [0] * n\n        for i in range(n):\n            dp[i] = sum(a[i:])\n\n        taro_turn = True\n        while True:\n            if all(dp[i] == 0 for i in range(n)):\n                return \"Second\" if taro_turn else \"First\"\n\n            if any(a[i] > 0 for i in range(n)):\n                for i in range(n):\n                    if a[i] > 0:\n                        for j in range(n):\n                            if dp[j] > 0:\n                                a[i] -= 1\n                                dp[j] -= 1\n                                break\n                        break\n            else:\n                for i in range(n):\n                    if dp[i] > 0:\n                        dp[i] -= 1\n                        break\n\n            taro_turn = not taro_turn\n\n    T = int(stdin.readline())\n    result = []\n    for _ in range(T):\n        N = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        result.append(game(a))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3782,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, Q = map(int, stdin.split()[0:3])\n    A = list(map(int, stdin.split()[3:]))\n\n    A.sort()\n\n    X = A[-1]\n    Y = A[0]\n\n    for _ in range(Q):\n        X = max(X, A[-K - 1])\n        Y = max(Y, A[K - 1])\n        A.pop(K - 1)\n        A.pop(-K - 1)\n\n    return str(X - Y)"
    },
    {
        "number": 3783,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    total_cost = 0\n    mod = 10**9 + 7\n\n    for i in range(1, n + 1):\n        total_cost += (i ** k)\n        total_cost %= mod\n\n    return str(total_cost)"
    },
    {
        "number": 3784,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_non_similar_worlds(n: int, m: int) -> int:\n        total_worlds = 0\n        for i in range(m, n + 1):\n            total_worlds += count_trees(i)\n        return total_worlds % MOD\n\n    def count_trees(n: int) -> int:\n        if n <= 1:\n            return 1\n        return (2 * count_trees(n - 1) - count_trees(n - 2)) % MOD\n\n    return str(count_non_similar_worlds(n, m))"
    },
    {
        "number": 3785,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    maze = [list(line) for line in stdin.split('\\n')[1:]]\n\n    def is_connected(x, y, visited):\n        if (x, y) in visited or maze[x][y] == '#':\n            return False\n        visited.add((x, y))\n        if x > 0 and is_connected(x - 1, y, visited):\n            return True\n        if x < n - 1 and is_connected(x + 1, y, visited):\n            return True\n        if y > 0 and is_connected(x, y - 1, visited):\n            return True\n        if y < m - 1 and is_connected(x, y + 1, visited):\n            return True\n        return False\n\n    def dfs(x, y, visited):\n        if (x, y) in visited or maze[x][y] == '#':\n            return\n        visited.add((x, y))\n        if x > 0 and (x - 1, y) not in visited and maze[x - 1][y] == '.':\n            dfs(x - 1, y, visited)\n        if x < n - 1 and (x + 1, y) not in visited and maze[x + 1][y] == '.':\n            dfs(x + 1, y, visited)\n        if y > 0 and (x, y - 1) not in visited and maze[x][y - 1] == '.':\n            dfs(x, y - 1, visited)\n        if y < m - 1 and (x, y + 1) not in visited and maze[x][y + 1] == '.':\n            dfs(x, y + 1, visited)\n\n    for i in range(n):\n        for j in range(m):\n            if maze[i][j] == '.':\n                visited = set()\n                if not is_connected(i, j, visited):\n                    k -= 1\n                    maze[i][j] = 'X'\n                    dfs(i, j, visited)\n                if k == 0:\n                    break\n        if k == 0:\n            break\n\n    return '\\n'.join([''.join(line) for line in maze])"
    },
    {
        "number": 3786,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = list(map(int, stdin.split()))\n    apples = [0] * n\n    apples[0] = 1\n    for i in range(1, n):\n        apples[p[i - 1] - 1] += 1\n    for i in range(n):\n        if apples[i] > 1:\n            apples[i] = 1\n    return str(sum(apples))"
    },
    {
        "number": 3787,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split())\n\n    if A + B > N:\n        return -1\n\n    if A == N:\n        return \" \".join(map(str, range(1, N + 1)))\n\n    if B == N:\n        return \" \".join(map(str, range(N, 0, -1)))\n\n    sequence = []\n    i, j = 1, N\n\n    for _ in range(A):\n        sequence.append(i)\n        i += 1\n\n    for _ in range(B):\n        sequence.append(j)\n        j -= 1\n\n    if len(sequence) == N:\n        return \" \".join(map(str, sequence))\n\n    if A > B:\n        sequence.append(j)\n    else:\n        sequence.append(i)\n\n    return \" \".join(map(str, sequence))"
    },
    {
        "number": 3788,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n - 1):\n        if gcd(a[i], a[i + 1]) <= 1:\n            return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 3789,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *a = list(map(int, stdin.split()))\n    a.sort(key=abs)\n    smashed = set()\n    total = 0\n\n    for x in a:\n        if x not in smashed:\n            total += x\n            for i in range(x, N + 1, x):\n                smashed.add(i)\n\n    return str(total)"
    },
    {
        "number": 3790,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] >= a[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return str(max(dp))\n\nn, T = map(int, input().split())\na = list(map(int, input().split()))\nprint(solution(f\"{n} {T}\")) "
    },
    {
        "number": 3791,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n\n    min_deviation = sum(abs(p[i] - (i + 1)) for i in range(n))\n    min_id = 0\n\n    for i in range(1, n):\n        shifted_p = p[i:] + p[:i]\n        deviation = sum(abs(shifted_p[j] - (j + 1)) for j in range(n))\n\n        if deviation < min_deviation:\n            min_deviation = deviation\n            min_id = i\n\n    return f\"{min_deviation} {min_id}\""
    },
    {
        "number": 3792,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s, t = stdin.split()\n\n    def count_prefixes(s: str, t: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            if s[i] == t[i]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_suffixes(s: str, t: str) -> int:\n        count = 0\n        for i in range(1, len(s) + 1):\n            if s[-i] == t[-i]:\n                count += 1\n            else:\n                break\n        return count\n\n    prefixes = count_prefixes(s, t)\n    suffixes = count_suffixes(s, t)\n\n    max_c = (prefixes + 1) * (suffixes + 1)\n\n    return str(max_c)"
    },
    {
        "number": 3793,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_cube(points):\n        for i in range(8):\n            for j in range(i + 1, 8):\n                if points[i] == points[j]:\n                    return False\n        return True\n\n    def restore_cube(points):\n        cube = []\n        for i in range(8):\n            for j in range(i + 1, 8):\n                for k in range(j + 1, 8):\n                    if points[i][0] + points[j][0] + points[k][0] == 0 and \\\n                            points[i][1] + points[j][1] + points[k][1] == 0 and \\\n                            points[i][2] + points[j][2] + points[k][2] == 0:\n                        cube.append([points[i], points[j], points[k]])\n        return cube\n\n    def check_cube(cube):\n        for i in range(3):\n            if not (cube[0][i] == cube[1][i] == cube[2][i] == cube[3][i] == cube[4][i] == cube[5][i] == cube[6][i] == cube[7][i]):\n                return False\n        return True\n\n    points = [list(map(int, line.split())) for line in stdin.split('\\n')[:-1]]\n\n    if is_valid_cube(points):\n        cube = restore_cube(points)\n        if check_cube(cube[0]):\n            return 'YES\\n' + '\\n'.join([' '.join(map(str, vertex)) for vertex in cube[0]])\n    return 'NO'"
    },
    {
        "number": 3794,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_valid(group1, group2):\n        return gcd(group1) == 1 and gcd(group2) == 1\n\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    for i in range(1, n + 1):\n        group1 = [arr[j] for j in range(i) if j % 2 == 0]\n        group2 = [arr[j] for j in range(i) if j % 2 != 0]\n\n        if is_valid(group1, group2):\n            return \"YES\\n\" + ' '.join(map(str, [1 if j % 2 == 0 else 2 for j in range(n)]))\n\n    return \"NO\""
    },
    {
        "number": 3795,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, e = map(int, stdin.split())\n    dollar_bills = [1, 2, 5, 10, 20, 50, 100]\n    euro_bills = [5, 10, 20, 50, 100, 200]\n\n    def count_bills(bills, price):\n        total = 0\n        for bill in bills:\n            total += bill\n        return total // price\n\n    dollar_count = count_bills(dollar_bills, d)\n    euro_count = count_bills(euro_bills, e)\n\n    return n - dollar_count * d - euro_count * e"
    },
    {
        "number": 3796,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    nums = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    nums_set = set(nums)\n    nums_dict = {}\n    for i, num in enumerate(nums):\n        if num in nums_dict:\n            nums_dict[num].append(i)\n        else:\n            nums_dict[num] = [i]\n\n    max_size = 0\n    max_rect = []\n\n    for p in range(1, n + 1):\n        for q in range(p, 0, -1):\n            if p * q <= max_size:\n                break\n            if p * q > len(nums_set):\n                continue\n            if p * q > max_size:\n                for num in nums_set:\n                    if num in nums_dict:\n                        nums_dict[num] = sorted(nums_dict[num])\n                rect = []\n                is_valid = True\n                for i in range(p):\n                    row = []\n                    for j in range(q):\n                        if i * q + j >= len(nums):\n                            is_valid = False\n                            break\n                        num = nums[i * q + j]\n                        if num in nums_dict:\n                            if len(nums_dict[num]) == 0:\n                                is_valid = False\n                                break\n                            index = bisect_left(nums_dict[num], i * q + j)\n                            if index < len(nums_dict[num]) and nums_dict[num][index] == i * q + j:\n                                nums_dict[num].pop(index)\n                            else:\n                                is_valid = False\n                                break\n                        row.append(num)\n                    if not is_valid:\n                        break\n                    rect.append(row)\n                if is_valid and len(rect) == p and len(rect[0]) == q:\n                    max_size = p * q\n                    max_rect = rect\n\n    output = [str(max_size), str(p), str(q)]\n    for row in max_rect:\n        output.append(\" \".join(map(str, row)))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3797,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    dp = [1] * (N + 1)\n    mod = 10**9 + 7\n\n    for _ in range(M):\n        l, r, x = map(int, stdin.readline().split())\n        for i in range(l, r + 1):\n            dp[i] = dp[i - 1] * dp[i]\n            dp[i] %= mod\n            if i - l >= x:\n                dp[i] -= dp[i - x]\n                dp[i] %= mod\n\n    return dp[N]"
    },
    {
        "number": 3798,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    b = 2\n    while True:\n        if n < b:\n            if n == s:\n                return str(b)\n            else:\n                return \"-1\"\n        else:\n            f_n_b = n // b + (n % b)\n            if f_n_b == s:\n                return str(b)\n            elif f_n_b < s:\n                return \"-1\"\n        b += 1"
    },
    {
        "number": 3799,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n\n    if n == 3:\n        return \"First\"\n\n    if n % 2 == 0:\n        return \"First\"\n\n    if n % 2 == 1:\n        return \"Second\"\n"
    },
    {
        "number": 3800,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, s = stdin.split('\\n')\n    a = int(a)\n    s = s.strip()\n    n = len(s)\n    b = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            b[i][j] = s[i] * s[j]\n\n    count = 0\n    for x in range(n):\n        for y in range(x, n):\n            for z in range(n):\n                for t in range(z, n):\n                    if sum(b[i][j] for i in range(x, y + 1) for j in range(z, t + 1)) == a:\n                        count += 1\n\n    return str(count)"
    },
    {
        "number": 3801,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    w = list(map(int, stdin.readline().split()))\n\n    for i in range(m):\n        p = sum(w)\n        q = 0\n        for j in range(n):\n            if a[j] == 1:\n                w[j] += 1\n                q += w[j]\n            else:\n                w[j] -= 1\n                q -= w[j]\n        p_i = q\n        q_i = p\n        gcd = find_gcd(p_i, q_i)\n        p_i //= gcd\n        q_i //= gcd\n        mod = 998244353\n        r = mod_inv(q_i, mod)\n        r *= p_i\n        r %= mod\n        w = [r * x for x in w]\n\n    return \" \".join(str(x) for x in w)\n\ndef"
    },
    {
        "number": 3802,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s_1, s_2, virus = stdin.split('\\n')\n    len_s1, len_s2, len_virus = len(s_1), len(s_2), len(virus)\n\n    dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)]\n\n    for i in range(1, len_s1 + 1):\n        for j in range(1, len_s2 + 1):\n            if s_1[i - 1] == s_2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    result = []\n    i, j = len_s1, len_s2\n    while i > 0 and j > 0:\n        if s_1[i - 1] == s_2[j - 1]:\n            result.append(s_1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    result = ''.join(result[::-1])\n\n    if any(result.find(virus[i:i + len_s1]) != -1 for i in range(len_virus - len_s1 + 1)):\n        return '0'\n    else:\n        return result\n"
    },
    {
        "number": 3803,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_list = list(map(int, stdin.split()))\n    HP_Y, ATK_Y, DEF_Y = input_list[0:3]\n    HP_M, ATK_M, DEF_M = input_list[3:6]\n    h, a, d = input_list[6:]\n\n    # Calculate minimum bitcoins needed\n    bitcoins_needed = 0\n    while HP_Y > 0 and HP_M > 0:\n        HP_M -= max(0, ATK_Y - DEF_M)\n        HP_Y -= max(0, ATK_M - DEF_Y)\n        bitcoins_needed += h\n\n    if HP_Y > 0:\n        bitcoins_needed += (HP_Y - 1) * h\n    if HP_M <= 0:\n        return str(bitcoins_needed)\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3804,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    count = 0\n\n    for m in range(1, n + 1):\n        if (m ^ (m + 1)) == t:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3805,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sequence = stdin.strip()\n    plus_above = 0\n    minus_above = 0\n\n    for char in sequence:\n        if char == \"+\":\n            plus_above += 1\n            if plus_above == 0:\n                return \"No\"\n        else:\n            plus_above -= 1\n            minus_above += 1\n            if minus_above == 0:\n                return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 3806,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def area_of_polygon(vertices):\n        area = 0\n        n = len(vertices)\n        for i in range(n):\n            j = (i + 1) % n\n            area += vertices[i][0] * vertices[j][1]\n            area -= vertices[j][0] * vertices[i][1]\n        return abs(area) / 2\n\n    def area_of_circle_segment(r, h):\n        return r ** 2 * (h / r * acos(h / r) - sin(h / r))\n\n    def snow_clearing_area(n, P, vertices):\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            A = vertices[i]\n            B = vertices[j]\n            C = P\n            r = distance(A, C)\n            h = abs(cross_product(A, B) / 2)\n            area += area_of_circle_segment(r, h)\n        return area\n\n    lines = stdin.split('\\n')\n    n, x, y = map(int, lines[0].split())\n    P = (x, y)\n    vertices = [tuple(map(int, line.split())) for line in lines[1:n + 1]]\n\n    return f\"{snow_clearing_area(n, P, vertices):.12f}\""
    },
    {
        "number": 3807,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    x = 1\n    blocks = 0\n\n    while x <= m:\n        blocks += m // x\n        x *= 2\n\n    return f\"{blocks} {m}\""
    },
    {
        "number": 3808,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_correct(s: str) -> bool:\n        stack = []\n        for bracket in s:\n            if bracket == \"(\":\n                stack.append(bracket)\n            else:\n                if not stack or stack.pop() != \"(\":\n                    return False\n        return not stack\n\n    def can_move_one_bracket(s: str) -> bool:\n        for i in range(len(s)):\n            for j in range(len(s)):\n                if i != j:\n                    new_s = s[:i] + s[j] + s[i + 1:j] + s[i] + s[j + 1:]\n                    if is_correct(new_s):\n                        return True\n        return False\n\n    if is_correct(s):\n        print(\"Yes\")\n    elif can_move_one_bracket(s):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n"
    },
    {
        "number": 3809,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    weights = list(map(int, stdin.split()[2:]))\n\n    if sum(weights) > k:\n        return \"-1 0\"\n\n    def count_ways(n, k, weights, index, curr_weight, curr_trip, memo):\n        if curr_weight > k:\n            return 0\n        if index == n:\n            return 1\n        if (index, curr_weight, curr_trip) in memo:\n            return memo[(index, curr_weight, curr_trip)]\n\n        count = 0\n        if curr_weight + weights[index] <= k:\n            count += count_ways(n, k, weights, index + 1, curr_weight + weights[index], curr_trip, memo)\n        count += count_ways(n, k, weights, index + 1, curr_weight, curr_trip + 1, memo)\n\n        memo[(index, curr_weight, curr_trip)] = count\n        return count\n\n    memo = {}\n    min_trips = n\n    for i in range(n):\n        if weights[i] == 50:\n            min_trips = min(min_trips, 2 * i + 1)\n        else:\n            min_trips = min(min_trips, 2 * i + 2)\n\n    ways = count_ways(n, k, weights, 0, 0, 0, memo)\n    modulo = 10**9 + 7\n    return f\"{min_trips} {ways % modulo}\""
    },
    {
        "number": 3810,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    boxes = list(map(int, stdin.readline().strip().split()))\n\n    mod = 10**9 + 7\n    piles = []\n\n    for i in range(n):\n        for j in range(n):\n            if i != j and boxes[i] % boxes[j] == 0:\n                for k in range(n):\n                    if k != i and k != j and boxes[i] % boxes[k] == 0:\n                        piles.append((i, j, k))\n\n    max_boxes = 0\n    for pile in piles:\n        box_count = 0\n        for box in pile:\n            if boxes[box] not in pile:\n                box_count += 1\n        max_boxes = max(max_boxes, box_count)\n\n    return str(max_boxes)"
    },
    {
        "number": 3811,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def wcd(pairs):\n        result = pairs[0][0]\n        for a, b in pairs:\n            result = gcd(result, a)\n            result = gcd(result, b)\n        return result\n\n    n = int(stdin.readline())\n    pairs = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    return str(wcd(pairs))\n"
    },
    {
        "number": 3812,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    n = 0\n    result = []\n\n    while not (s.isalpha() and t.isalpha()):\n        if s[0] != t[0]:\n            if s[0] == 'a':\n                s = s[1:] + 'b'\n                t = 'a' + t[1:]\n            else:\n                s = 'b' + s[:-1]\n                t = t[1:] + 'a'\n        else:\n            s = s[1:]\n            t = t[1:]\n        n += 1\n        result.append((len(s) + 1, len(t) + 1))\n\n    output = [str(n)] + [' '.join(map(str, x)) for x in result]\n    return '\\n'.join(output)"
    },
    {
        "number": 3813,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P, X = map(int, stdin.split())\n    P = list(map(int, P.split()))\n    X = list(map(int, X.split()))\n\n    parent = [0] * (N + 1)\n    for i in range(2, N + 1):\n        parent[i] = P[i - 1]\n\n    weight = [0] * (N + 1)\n    for i in range(1, N + 1):\n        weight[i] = X[i - 1]\n\n    def dfs(v: int) -> int:\n        if v == 0:\n            return 0\n        w = weight[v]\n        for child in children[v]:\n            w += dfs(child)\n        weight[v] = w\n        return w\n\n    children = [[] for _ in range(N + 1)]\n    for i in range(2, N + 1):\n        children[parent[i]].append(i)\n\n    dfs(1)\n\n    for i in range(1, N + 1):\n        if weight[i] != X[i - 1]:\n            return \"IMPOSSIBLE\"\n    return \"POSSIBLE\""
    },
    {
        "number": 3814,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    result = 2 ** N - N - 1\n    return str(result % M)"
    },
    {
        "number": 3815,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k = map(int, stdin.split()[0].split())\n    s = list(map(lambda x: 1 if x == '+' else -1, stdin.split()[1]))\n\n    def compute_periodic_sum(s: list, a: int, b: int, k: int, n: int) -> int:\n        periodic_sum = 0\n        for i in range(k):\n            periodic_sum += s[i] * pow(a, n - i, 10**9 + 9) * pow(b, i, 10**9 + 9)\n        return periodic_sum\n\n    periodic_sum = compute_periodic_sum(s, a, b, k, n)\n\n    for i in range(k, n + 1):\n        periodic_sum += s[i % k] * pow(a, n - i, 10**9 + 9) * pow(b, i, 10**9 + 9)\n\n    return str(periodic_sum % (10**9 + 9))"
    },
    {
        "number": 3816,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, l = map(int, stdin.split())\n    total_length = a + b + c\n    if total_length <= l:\n        return 1\n    elif total_length - l <= 2 * min(a, b, c):\n        return 0\n    else:\n        return 4\n\n    # Read input\n    a, b, c, l = map(int, input().split())\n\n    # Check if it's possible to make a non-degenerate triangle\n    total_length = a + b + c\n    if total_length <= l:\n        return 1\n    elif total_length - l <= 2 * min(a, b, c):\n        return 0\n    else:\n        return 4 "
    },
    {
        "number": 3817,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 9\n\n    def count_wool_sequences(length, max_value):\n        if length == 1:\n            return 1\n        if length == 2:\n            return max_value + 1\n\n        dp = [0] * (max_value + 1)\n        dp[0] = 1\n        for i in range(1, max_value + 1):\n            dp[i] = (dp[i - 1] + dp[i]) % mod\n\n        total = 0\n        for i in range(1, max_value + 1):\n            total = (total + dp[i - 1] * i) % mod\n\n        return total * (2**(length - 2)) % mod\n\n    total = 2**n\n    for i in range(1, n + 1):\n        total -= count_wool_sequences(i, 2**m - 1)\n\n    return str(total % mod)"
    },
    {
        "number": 3818,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent, depth):\n        d[node] = depth\n        for child in graph[node]:\n            if child != parent:\n                dfs(child, node, depth + 1)\n\n    def get_niceness(color):\n        max_dist = 0\n        for i in range(1, N + 1):\n            if d[i] % 2 == color:\n                for j in range(1, N + 1):\n                    if d[j] % 2 == color and i != j:\n                        max_dist = max(max_dist, abs(d[i] - d[j]))\n        return max_dist\n\n    N = int(stdin.readline().strip())\n    graph = {i: [] for i in range(1, N + 1)}\n    for i in range(N - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    d = {}\n    dfs(1, -1, 0)\n\n    white_niceness = get_niceness(0)\n    black_niceness = get_niceness(1)\n    niceness_sum = max(white_niceness, black_niceness)\n\n    return str(niceness_sum)"
    },
    {
        "number": 3819,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    operations = 0\n    for i in range(n):\n        while a[i] == 0:\n            a[i], b[i] = b[i], a[i]\n            operations += 1\n        while a[i] != i + 1:\n            a[i], b[i] = b[i], a[i]\n            operations += 1\n\n    return str(operations)"
    },
    {
        "number": 3820,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n\n    if '*' not in s:\n        if s == t:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if len(s) - 1 != len(t):\n        return \"NO\"\n\n    for i in range(len(s)):\n        if s[i] == '*':\n            continue\n        if s[i] != t[i]:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 3821,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    probabilities = list(map(float, stdin.split('\\n')[1].split()))\n\n    if n == 1:\n        return str(min(1, max(0, probabilities[0])))\n\n    probabilities.sort(reverse=True)\n    total_probability = sum(probabilities)\n\n    if total_probability <= 1:\n        return str(total_probability)\n\n    probability_sum = 0\n    for i in range(n):\n        probability_sum += probabilities[i]\n        if probability_sum >= 1:\n            return str(min(1, max(0, probability_sum - probabilities[i])))\n\n    return str(probability_sum)"
    },
    {
        "number": 3822,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, v1, v2, k = map(int, stdin.split())\n    time = l / v2\n    return f\"{time:.10f}\""
    },
    {
        "number": 3823,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(float, stdin.split(\"\\n\")[1].split()))\n\n    a.sort()\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                a[i] = round(a[i])\n                a[j] = round(a[j])\n\n    return \"{:.3f}\".format(abs(sum(a[:2 * n]) - sum(a)))"
    },
    {
        "number": 3824,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    return str(abs(x1 - x2) + abs(y1 - y2) + 2)"
    },
    {
        "number": 3825,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n + 1):\n        count += 4 * (n - i) + 1\n    return str(count)"
    },
    {
        "number": 3826,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    if len(set(a)) == n:\n        return str(0)\n\n    i = 0\n    j = 1\n    count = 0\n    while j < n:\n        if a[i] == a[j]:\n            count += 1\n            if count > 1:\n                return str(j - i)\n            else:\n                while a[i] == a[j]:\n                    i += 1\n        j += 1\n\n    return str(n - i)"
    },
    {
        "number": 3827,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_count = stdin.count('a')\n    b_count = stdin.count('b')\n    c_count = stdin.count('c')\n\n    if c_count == a_count or c_count == b_count:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3828,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    p = list(map(int, p.split()))\n    sorted_p = sorted(p)\n    count = 0\n    for i in range(n):\n        if p[i] != sorted_p[i]:\n            count += 1\n    return str(count // 2)"
    },
    {
        "number": 3829,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    expected_max = 0\n\n    for i in range(1, m + 1):\n        expected_max += i * (1 / m)\n\n    expected_max_after_n_tosses = expected_max * n\n\n    return f\"{expected_max_after_n_tosses:.11f}\""
    },
    {
        "number": 3830,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    stdin = stdin.split('\\n')[1:]\n    result = []\n\n    for i in range(test_cases):\n        n = int(stdin[i * 2])\n        conveyor_belt_states = stdin[i * 2 + 1]\n\n        returnable_rooms = 0\n        for room in range(n):\n            clockwise_neighbor = (room + 1) % n\n            anticlockwise_neighbor = (room - 1) % n\n\n            if conveyor_belt_states[room] == '-' or (conveyor_belt_states[room] == '>' and conveyor_belt_states[clockwise_neighbor] != '<') or (conveyor_belt_states[room] == '<' and conveyor_belt_states[anticlockwise_neighbor] != '>'):\n                returnable_rooms += 1\n\n        result.append(str(returnable_rooms))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3831,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_plan(s, g, n):\n        x = [0] * n\n        for i in range(n):\n            x[i] = min(s[i], g[i])\n            if i > 0:\n                x[i] = min(x[i], s[i - 1] - s[i] + g[i - 1] - x[i - 1])\n        return x\n\n    def check_plan(s, g, x, n):\n        for i in range(1, n):\n            if abs(s[i] + x[i] - s[i - 1] - x[i - 1]) > 1:\n                return False\n        return True\n\n    def apply_plan(s, g, x, n):\n        for i in range(n):\n            s[i] += x[i]\n            g[i] -= x[i]\n\n    n = int(stdin.readline().strip())\n    s = []\n    g = []\n    for _ in range(n):\n        si, gi = map(int, stdin.readline().strip().split())\n        s.append(si)\n        g.append(gi)\n\n    x = find_plan(s, g, n)\n    if check_plan(s, g, x, n):\n        apply_plan(s, g, x, n)\n        total_lawn = sum(x)\n        output = f\"{total_lawn}\\n\"\n        output += \" \".join(map(str, s))\n        return output\n    else:\n        return \"-1\""
    },
    {
        "number": 3832,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    heights = list(map(int, stdin.split('\\n')[1].split()))\n\n    def can_build_house(heights: list, k: int) -> bool:\n        suitable_hills = [heights[0]]\n        for i in range(1, len(heights)):\n            if heights[i] > suitable_hills[-1]:\n                suitable_hills.append(heights[i])\n        return len(suitable_hours) >= k\n\n    def binary_search(heights: list, k: int) -> int:\n        left, right = 0, n * 100000\n        while left <= right:\n            mid = (left + right) // 2\n            modified_heights = [h - mid for h in heights]\n            if can_build_house(modified_heights, k):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    result = []\n    for k in range(1, n // 2 + 1):\n        result.append(binary_search(heights, k))\n\n    return ' '.join(map(str, result))"
    },
    {
        "number": 3833,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    n = len(s)\n    m = len(t)\n    max_count = 0\n    max_schedule = ''\n\n    for i in range(n - m + 1):\n        count = 0\n        schedule = ''\n        for j in range(n):\n            if j < i or j >= i + m:\n                schedule += s[j]\n            else:\n                schedule += t[j - i]\n                if s[j] == t[j - i]:\n                    count += 1\n        if count > max_count:\n            max_count = count\n            max_schedule = schedule\n\n    return max_schedule"
    },
    {
        "number": 3834,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    def is_valid(a: list) -> bool:\n        for i in range(n):\n            for j in range(m):\n                if a[i][j] == 1:\n                    h, w = 1, 1\n                    while i + h < n and all(a[p][j] == 1 for p in range(i, i + h)):\n                        h += 1\n                    while j + w < m and all(a[i + p][q] == 1 for p in range(h) for q in range(j, j + w)):\n                        w += 1\n                    if h * w > 1:\n                        for p in range(i, i + h):\n                            for q in range(j, j + w):\n                                if a[p][q] == 0:\n                                    return False\n        return True\n\n    if k >= n * m - sum(sum(row) for row in a):\n        for i in range(n):\n            for j in range(m):\n                if a[i][j] == 0:\n                    a[i][j] = 1\n                    if is_valid(a):\n                        return str(sum(sum(row) for row in a) - n * m + k)\n                    a[i][j] = 0\n    return \"-1\""
    },
    {
        "number": 3835,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    M = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    a = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                a[i] = M[i][j] // M[i][i]\n                break\n\n    return ' '.join(map(str, a))"
    },
    {
        "number": 3836,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_influence(spectators: list, alice_support: int, bob_support: int) -> int:\n        max_influence = 0\n        for i in range(len(spectators)):\n            for j in range(i + 1, len(spectators)):\n                if spectators[i][1] + spectators[j][1] >= alice_support and spectators[i][1] + spectators[j][1] >= bob_support:\n                    max_influence = max(max_influence, spectators[i][1] + spectators[j][1])\n        return max_influence\n\n    def is_valid(spectators: list, alice_support: int, bob_support: int) -> bool:\n        alice_count = 0\n        bob_count = 0\n        for s in spectators:\n            if s[0] == \"10\" or s[0] == \"11\":\n                alice_count += 1\n            if s[0] == \"01\" or s[0] == \"11\":\n                bob_count += 1\n        return alice_count >= alice_support and bob_count >= bob_support\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    spectators = [(s[0], int(s[1])) for s in (line.split() for line in lines[1:])]\n\n    alice_support = n // 2\n    bob_support = n // 2\n\n    if not is_valid(spectators, alice_support, bob_support):\n        return \"0\"\n\n    return str(find_max_influence(spectators, alice_support, bob_support))"
    },
    {
        "number": 3837,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_fix(bug_complexity, student_ability):\n        return bug_complexity <= student_ability\n\n    def find_best_student(bug_complexity, students):\n        best_student = -1\n        best_ability = 0\n        for i, (ability, passes) in enumerate(students):\n            if can_fix(bug_complexity, ability) and passes > 0 and ability > best_ability:\n                best_student = i\n                best_ability = ability\n        return best_student\n\n    def update_student(student_index, passes):\n        students[student_index][1] -= passes\n\n    def fix_bugs(bugs, students, max_passes):\n        schedule = [-1] * len(bugs)\n        total_passes = 0\n        for i, bug_complexity in enumerate(bugs):\n            student_index = find_best_student(bug_complexity, students)\n            if student_index == -1:\n                return None\n            schedule[i] = student_index\n            update_student(student_index, 1)\n            total_passes += 1\n            if total_passes > max_passes:\n                return None\n        return schedule\n\n    n, m, s = map(int, stdin.readline().split())\n    bugs = list(map(int, stdin.readline().split()))\n    students = list(zip(map(int, stdin.readline().split()), map(int, stdin.readline().split())))\n\n    schedule = fix_bugs(bugs, students, s)\n    if schedule is None:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \" \".join(map(str, schedule))"
    },
    {
        "number": 3838,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    q = list(map(int, stdin.readline().split()))\n    s = list(map(int, stdin.readline().split()))\n\n    for i in range(k):\n        if i % 2 == 0:\n            q = [q[q[i - 1] - 1] for i in range(n)]\n        else:\n            q = [q.index(i + 1) + 1 for i in range(n)]\n\n    return \"YES\" if s == q else \"NO\""
    },
    {
        "number": 3839,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    knights = [(1, 1)]\n\n    for i in range(2, n + 1):\n        x, y = knights[-1]\n        while True:\n            x, y = x + 1, y + 2\n            if (x, y) not in knights:\n                knights.append((x, y))\n                break\n\n    return \"\\n\".join(f\"{x} {y}\" for x, y in knights)"
    },
    {
        "number": 3840,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a.sort(reverse=True)\n\n    moves = 0\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        x = (i // 2) + 1\n        if 2 * x + 1 <= n:\n            moves += (a[i] // x)\n            a[i] %= x\n        else:\n            moves += (a[i] // (n - i)) * (n - i)\n            a[i] %= (n - i)\n\n        if a[i] == 0:\n            moves -= 1\n\n    return str(moves)"
    },
    {
        "number": 3841,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, k = map(int, stdin.split())\n\n    if p % k != 0:\n        return \"-1\"\n\n    d = 0\n    coefficients = []\n\n    while p >= 0:\n        coefficient = p % k\n        if coefficient != 0:\n            d += 1\n            coefficients.append(str(coefficient))\n        p //= k\n\n    return f\"{d}\\n{' '.join(coefficients)}\"\n"
    },
    {
        "number": 3842,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split()[0:3])\n    a = []\n    b = []\n    for i in range(n):\n        a_i, b_i = map(int, stdin.split()[3 + 2 * i:5 + 2 * i])\n        a.append(a_i)\n        b.append(b_i)\n\n    def binary_search(a, b, p, q):\n        left, right = 0, 10**12\n        while right - left > 10**-6:\n            mid = (left + right) / 2\n            total_a = sum([int(a_i * mid) for a_i in a])\n            total_b = sum([int(b_i * mid) for b_i in b])\n            if total_a >= p and total_b >= q:\n                right = mid\n            else:\n                left = mid\n        return right\n\n    return f\"{binary_search(a, b, p, q):.10f}\""
    },
    {
        "number": 3843,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    total_pairs = 0\n\n    for hour in range(n):\n        hour_digits = set(str(hour))\n        for minute in range(m):\n            minute_digits = set(str(minute))\n            if hour_digits.isdisjoint(minute_digits):\n                total_pairs += 1\n\n    return str(total_pairs)"
    },
    {
        "number": 3844,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def remove_cards(i: int) -> None:\n        nonlocal a\n        j = 0\n        while j < len(a):\n            if a[j] < a[i]:\n                a.pop(j)\n            else:\n                j += 1\n\n    i = 0\n    while i < len(a):\n        if a[i] == n:\n            return \"Conan\"\n        remove_cards(i)\n        i += 1\n    return \"Agasa\""
    },
    {
        "number": 3845,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    h, w = A + B, A + B\n\n    def paint_grid(h: int, w: int, A: int, B: int) -> str:\n        grid = [['.' for _ in range(w)] for _ in range(h)]\n        for i in range(h):\n            for j in range(w):\n                if i < A or j < A:\n                    grid[i][j] = '#'\n        return grid\n\n    def print_grid(grid: List[List[str]]) -> str:\n        output = ''\n        for row in grid:\n            output += ''.join(row) + '\\n'\n        return output\n\n    grid = paint_grid(h, w, A, B)\n    output = print_grid(grid)\n    output = f'{h} {w}\\n' + output\n    return output"
    },
    {
        "number": 3846,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    messages = [line.strip() for line in stdin.readlines()]\n\n    leaders = set(range(1, n + 1))\n    for message in messages:\n        action, user_id = message.split()\n        user_id = int(user_id)\n        if action == '+':\n            leaders.add(user_id)\n        else:\n            leaders.discard(user_id)\n\n    if not leaders:\n        return \"0\"\n    else:\n        return f\"{len(leaders)}\\n{' '.join(map(str, sorted(leaders)))}\""
    },
    {
        "number": 3847,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    x = int(stdin.readline())\n\n    c = [[a[i] * b[j] for j in range(m)] for i in range(n)]\n\n    max_area = 0\n    for x1 in range(1, n + 1):\n        for x2 in range(x1, n + 1):\n            for y1 in range(1, m + 1):\n                for y2 in range(y1, m + 1):\n                    if sum(sum(c[i][j] for j in range(y1 - 1, y2)) for i in range(x1 - 1, x2)) <= x:\n                        max_area = max(max_area, (x2 - x1 + 1) * (y2 - y1 + 1))\n\n    return str(max_area)"
    },
    {
        "number": 3848,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    s = input()\n\n    def is_tolerable(s: str) -> bool:\n        for c in s:\n            if ord(c) - ord('a') >= p:\n                return False\n        for i in range(n - 1):\n            for j in range(i + 2, n + 1):\n                if s[i:j] == s[i:j][::-1]:\n                    return False\n        return True\n\n    def next_lexicographic(s: str) -> str:\n        for i in range(n - 1, -1, -1):\n            if s[i] < 'z':\n                return s[:i] + chr(ord(s[i]) + 1) + 'a' * (n - i - 1)\n        return 'a' * n\n\n    next_s = next_lexicographic(s)\n    while not is_tolerable(next_s):\n        next_s = next_lexicographic(next_s)\n\n    if next_s == 'a' * n:\n        return \"NO\"\n    else:\n        return next_s"
    },
    {
        "number": 3849,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    cards = stdin.readline().strip()\n\n    def can_win(player: str, cards: str, n: int, k: int) -> bool:\n        if n <= k:\n            return True\n        if cards.count('1') == 0:\n            return True\n        if cards.count('0') == 0:\n            return False\n        if cards[0] == cards[-1]:\n            return True\n        if cards[0] == '1' and cards[-k] == '1':\n            return False\n        if cards[0] == '0' and cards[-k] == '0':\n            return False\n        return True\n\n    if n * k > 10**9:\n        return \"once again\"\n    if can_win(\"tokitsukaze\", cards, n, k):\n        return \"tokitsukaze\"\n    if can_win(\"quailty\", cards, n, k):\n        return \"quailty\"\n"
    },
    {
        "number": 3850,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split('\\n')[0].split())\n    a = sorted(map(int, stdin.split('\\n')[1].split()))\n    b = sorted(map(int, stdin.split('\\n')[2].split()))\n\n    time = 0\n    i = 0\n    j = 0\n\n    while i < n and j < k:\n        if a[i] < b[j]:\n            time = max(time, b[j] - a[i])\n            i += 1\n        elif a[i] > b[j]:\n            time = max(time, a[i] - b[j])\n            j += 1\n        else:\n            time = max(time, abs(a[i] - p))\n            i += 1\n            j += 1\n\n    while i < n:\n        time = max(time, abs(a[i] - p))\n        i += 1\n\n    while j < k:\n        time = max(time, abs(b[j] - p))\n        j += 1\n\n    return str(time)"
    },
    {
        "number": 3851,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    a, b = map(int, stdin.split()[1].split())\n\n    x = 1\n    y = (n - 1) * k\n\n    if a == 0 and b == 0:\n        x = y = n\n\n    return f\"{x} {y}\""
    },
    {
        "number": 3852,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def check_condition(a: List[int]) -> bool:\n        return all(a[i] <= a[i + 1] for i in range(len(a) - 1))\n\n    def find_operation(a: List[int]) -> Tuple[int, int]:\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if a[i] + a[j] <= a[i] and a[i] <= a[j]:\n                    return i + 1, j + 1\n        return -1, -1\n\n    N, *a = list(map(int, stdin.split()))\n    m = 0\n    operations = []\n\n    while not check_condition(a):\n        x, y = find_operation(a)\n        if x == -1:\n            break\n        a[y - 1] += a[x - 1]\n        operations.append((x, y))\n        m += 1\n\n    output = [str(m)]\n    for op in operations:\n        output.append(\" \".join(map(str, op)))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3853,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    boxes = []\n    for i in range(n):\n        k, a = map(int, stdin.readline().split())\n        boxes.extend([2**k] * a)\n    max_box = max(boxes)\n    p = 0\n    while max_box > 0:\n        max_box >>= 1\n        p += 1\n    return str(p - 1)"
    },
    {
        "number": 3854,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    coins = list(map(int, stdin.split('\\n')[1].split()))\n\n    def count_subsets(sum_k, n):\n        dp = [[0 for _ in range(sum_k + 1)] for _ in range(n + 1)]\n\n        for i in range(n + 1):\n            dp[i][0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(1, sum_k + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= coins[i - 1]:\n                    dp[i][j] += dp[i - 1][j - coins[i - 1]]\n\n        return dp[n][sum_k]\n\n    result = []\n    for i in range(k + 1):\n        if count_subsets(i, n) > 0:\n            result.append(i)\n\n    return str(len(result)) + '\\n' + ' '.join(map(str, result)) + '\\n'"
    },
    {
        "number": 3855,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"2\"\n    else:\n        return str(n // 2 + (n % 2))"
    },
    {
        "number": 3856,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    rectangles = []\n    for _ in range(n):\n        w, h = map(int, stdin.readline().strip().split())\n        rectangles.append((w, h))\n\n    rectangles.sort(key=lambda x: x[1], reverse=True)\n    max_height = rectangles[0][1]\n\n    n_laying = n // 2\n    width = sum(rect[0] for rect in rectangles[:n_laying])\n    height = sum(rect[1] for rect in rectangles[:n_laying])\n\n    area = width * height\n\n    for i in range(n_laying, n):\n        rect_width, rect_height = rectangles[i]\n        if rect_height > max_height:\n            area += rect_height * rect_width\n        else:\n            area += rect_width * max_height\n\n    return str(area)"
    },
    {
        "number": 3857,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x = list(map(int, stdin.split('\\n')[1].split()))\n\n    piles = 0\n    while any(x):\n        pile = []\n        for i in range(n):\n            if x[i] > 0:\n                pile.append(i)\n                x[i] -= 1\n        piles += 1\n\n    return str(piles)"
    },
    {
        "number": 3858,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import combinations\n    from functools import reduce\n    from operator import mul\n    from collections import Counter\n    import sys\n\n    sys.setrecursionlimit(10**6)\n\n    def is_convex(points):\n        n = len(points)\n        if n < 3:\n            return False\n        sign = None\n        for i in range(n):\n            p1, p2, p3 = points[i], points[(i + 1) % n], points[(i + 2) % n]\n            det = (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n            if det == 0:\n                return False\n            if sign is None:\n                sign = det > 0\n            else:\n                if sign != (det > 0):\n                    return False\n        return True\n\n    def inside_polygon(point, polygon):\n        n = len(polygon)\n        if n < 3:\n            return False\n        prev_side = (polygon[-1][0] - point[0]) * (polygon[-1][1] - point[1])\n        for i in range(n):\n            side = (polygon[i][0] - point[0]) * (polygon[i][1] - point[1])\n            if side == 0:\n                return False\n            if side * prev_side < 0:\n                return False\n            prev_side = side\n        return True\n\n    def convex_hull(points):\n        n = len(points)\n        if n < 3:\n            return points\n        hull = []\n        points.sort(key=lambda x: (x[0], x[1]))\n        for p in points:\n            while len(hull) > 1 and ((hull[-1][0] - hull[-2][0]) * (p[1] - hull[-2][1]) - (p[0] - hull[-2][0]) * (hull[-1][1] - hull[-2][1])) <= 0:\n                hull.pop()\n            hull.append(p)\n        return hull\n\n    def score(points):\n        n = len(points)\n        hull = convex_hull(points)\n        inside = 0\n        for p in points:\n            if inside_polygon(p, hull):\n                inside += 1\n        return 2 ** (inside - n)\n\n    def main(stdin: str) -> str:\n        n, points = int(stdin.splitlines()[0]), [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n        scores = []\n        for i in range(1, n + 1):\n            for s in combinations(points, i):\n                if is_convex(s):\n                    scores.append(score(s))\n        return str(sum(scores) % 998244353)\n\n    return main(stdin) "
    },
    {
        "number": 3859,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_sorted(arr):\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i - 1]:\n                return False\n        return True\n\n    def find_min_operations(arr, color):\n        operations = 0\n        i = 0\n        while i < len(arr) - 1:\n            if arr[i] > arr[i + 1]:\n                j = i + 1\n                while j < len(arr) and arr[j] < arr[i]:\n                    j += 1\n                arr[i:j + 1] = arr[i:j + 1][::-1]\n                operations += 1\n                if color[i] == 'W' and not is_sorted(arr[:i + 1]):\n                    return -1\n                if color[i] == 'B' and not is_sorted(arr[i + 1:2 * n]):\n                    return -1\n            i += 1\n        return operations\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    arr = []\n    color = []\n    for i in range(1, len(lines)):\n        c, a = lines[i].split()\n        arr.append(int(a))\n        color.append(c)\n\n    n = len(arr) // 2\n    white_arr = arr[:n]\n    white_color = color[:n]\n    black_arr = arr[n:]\n    black_color = color[n:]\n\n    white_operations = find_min_operations(white_arr, white_color)\n    black_operations = find_min_operations(black_arr, black_color)\n\n    if white_operations == -1 or black_operations == -1:\n        return -1\n    else:\n        return white_operations + black_operations"
    },
    {
        "number": 3860,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, g, n = map(int, stdin.split())\n\n    min_decks = float('inf')\n\n    for i in range(n + 1):\n        blue_badges = i\n        red_badges = n - i\n\n        if blue_badges * g >= red_badges * b:\n            min_decks = min(min_decks, i)\n\n    return str(min_decks)"
    },
    {
        "number": 3861,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    max_num = max(arr)\n    while is_perfect_square(max_num):\n        max_num -= 1\n    return str(max_num)\n\ndef"
    },
    {
        "number": 3862,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    a.sort(reverse=True)\n\n    total_volume = 0\n    for i in range(k):\n        total_volume += a[i]\n\n    if n > total_volume:\n        return -1\n\n    liters = 0\n    for i in range(k):\n        liters += n // a[i]\n        n %= a[i]\n\n    return liters"
    },
    {
        "number": 3863,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_palindromes(N, K):\n        dp = [[0] * (K + 1) for _ in range(N + 1)]\n        for i in range(1, N + 1):\n            for j in range(1, K + 1):\n                if i == 1:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + dp[i - 1][j - 1]) % MOD\n        return dp[N][K]\n\n    return str(count_palindromes(N, K) * 2 % MOD)"
    },
    {
        "number": 3864,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    expected_value = 3 // 2\n    r = 499122178\n    return [r * expected_value] * n"
    },
    {
        "number": 3865,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 2:\n        return \"6\"\n    elif a == 3:\n        return \"6669\"\n    else:\n        return \"-1\""
    },
    {
        "number": 3866,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_lucky_permutation(a, b, c):\n        for i in range(n):\n            if (a[i] + b[i]) % n != c[i]:\n                return False\n        return True\n\n    def print_permutation(p):\n        return ' '.join(map(str, p))\n\n    n = int(stdin.strip())\n    for a in permutations(range(n)):\n        for b in permutations(range(n)):\n            c = [(-a[i] - b[i]) % n for i in range(n)]\n            if is_lucky_permutation(a, b, c):\n                return '\\n'.join([print_permutation(a), print_permutation(b), print_permutation(c)])\n    return '-1'"
    },
    {
        "number": 3867,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(tree, start):\n        visited = [False] * (n + 1)\n        queue = [start]\n        visited[start] = True\n\n        while queue:\n            vertex = queue.pop(0)\n            yield vertex\n            for neighbor in tree[vertex]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n\n    n, *edges, sequence = map(int, stdin.split())\n    tree = {i: [] for i in range(1, n + 1)}\n\n    for x, y in zip(edges[::2], edges[1::2]):\n        tree[x].append(y)\n        tree[y].append(x)\n\n    bfs_sequence = list(bfs(tree, 1))\n\n    return \"Yes\" if bfs_sequence == sequence else \"No\""
    },
    {
        "number": 3868,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    flights = [list(map(int, stdin.split()[3:])) for _ in range(m)]\n    flights.sort(key=lambda x: x[0])\n\n    total_cost = 0\n    jury_members = [False] * (n + 1)\n    jury_members[0] = True\n\n    for flight in flights:\n        if jury_members[flight[1]]:\n            total_cost += flight[3]\n            jury_members[flight[2]] = True\n        elif jury_members[flight[2]]:\n            total_cost += flight[3]\n            jury_members[flight[1]] = True\n\n    if all(jury_members):\n        return str(total_cost)\n    else:\n        return \"-1\""
    },
    {
        "number": 3869,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, alpha = map(int, stdin.split())\n    alpha = alpha * 2 * pi / 360\n\n    # Calculate the area of the first rectangle\n    area_rect1 = w * h\n\n    # Calculate the area of the second rectangle\n    area_rect2 = w * h * (sin(alpha) + cos(alpha))\n\n    # Calculate the area of the region which belongs to both given rectangles\n    area_common = w * h * sin(alpha) * cos(alpha)\n\n    # Calculate the total area of the two rectangles\n    total_area = area_rect1 + area_rect2 - 2 * area_common\n\n    return f\"{total_area:.10f}\""
    },
    {
        "number": 3870,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    jiro_cards = []\n    for _ in range(n):\n        position, strength = stdin.readline().strip().split()\n        jiro_cards.append((position, int(strength)))\n    ciel_cards = []\n    for _ in range(m):\n        strength = int(stdin.readline())\n        ciel_cards.append(strength)\n\n    jiro_alive_cards = [card for card in jiro_cards if card[0] == \"ATK\"]\n    jiro_def_cards = [card for card in jiro_cards if card[0] == \"DEF\"]\n    jiro_damage = 0\n\n    for ciel_card in ciel_cards:\n        if not jiro_alive_cards:\n            jiro_damage += ciel_card\n        else:\n            max_damage = 0\n            for i, jiro_card in enumerate(jiro_alive_cards):\n                if jiro_card[1] <= ciel_card:\n                    damage = ciel_card - jiro_card[1]\n                    jiro_alive_cards.pop(i)\n                    max_damage = max(max_damage, damage)\n                    break\n            jiro_damage += max_damage\n\n    for jiro_def_card in jiro_def_cards:\n        if not jiro_alive_cards:\n            jiro_damage += jiro_def_card[1]\n        else:\n            for i, jiro_card in enumerate(jiro_alive_cards):\n                if jiro_card[1] > jiro_def_card[1]:\n                    jiro_alive_cards.pop(i)\n                    break\n\n    return str(jiro_damage)"
    },
    {
        "number": 3871,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_profit(candidates, costs, profitability, n, m):\n        def process_candidates(candidates, profitability, n, m):\n            events = []\n            for candidate in candidates:\n                events.append((candidate, 1))\n                events.append((candidate + 1, -1))\n            events.sort()\n\n            aggressiveness = [0] * (n + m)\n            for event in events:\n                if event[1] == 1:\n                    aggressiveness[event[0] - 1] += 1\n                else:\n                    aggressiveness[event[0] - 1] -= 1\n\n            return aggressiveness\n\n        def calculate_revenue(aggressiveness, profitability):\n            revenue = 0\n            for level in aggressiveness:\n                revenue += profitability[level - 1]\n            return revenue\n\n        aggressiveness = process_candidates(candidates, profitability, n, m)\n        revenue = calculate_revenue(aggressiveness, profitability)\n\n        return revenue - sum(costs)\n\n    def parse_input(stdin: str):\n        lines = stdin.splitlines()\n        n, m = map(int, lines[0].split())\n        candidates = list(map(int, lines[1].split()))\n        costs = list(map(int, lines[2].split()))\n        profitability = list(map(int, lines[3].split()))\n        return n, m, candidates, costs, profitability\n\n    n, m, candidates, costs, profitability = parse_input(stdin)\n    max_profit = calculate_profit(candidates, costs, profitability, n, m)\n    return str(max_profit)"
    },
    {
        "number": 3872,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('\\n')\n    n = len(a)\n\n    def is_equivalent(a: str, b: str) -> bool:\n        if a == b:\n            return True\n        for i in range(n // 2):\n            a_1, a_2 = a[:i], a[i:]\n            b_1, b_2 = b[:i], b[i:]\n            if (is_equivalent(a_1, b_1) and is_equivalent(a_2, b_2)) or (is_equivalent(a_1, b_2) and is_equivalent(a_2, b_1)):\n                return True\n        return False\n\n    if is_equivalent(a, b):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3873,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    if n % 2 == 0:\n        return \"NO\"\n    else:\n        output = [\"YES\"]\n        for i in range(n - 1):\n            output.append(f\"{i + 1} {i + 2}\")\n        return \"\\n\".join(output)"
    },
    {
        "number": 3874,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    filenames = [stdin.readline().strip() for _ in range(n)]\n    indices = list(map(int, stdin.readline().split()))\n\n    def matches_pattern(filename: str, pattern: str) -> bool:\n        if len(filename) != len(pattern):\n            return False\n        for f, p in zip(filename, pattern):\n            if p != \"?\" and f != p:\n                return False\n        return True\n\n    def generate_pattern(filename: str) -> str:\n        pattern = \"\"\n        for c in filename:\n            pattern += \"?\" if c in \"abcdefghijklmnopqrstuvwxyz\" else c\n        return pattern\n\n    def is_valid_pattern(pattern: str) -> bool:\n        for i in indices:\n            if not matches_pattern(filenames[i - 1], pattern):\n                return False\n        return True\n\n    for filename in filenames:\n        pattern = generate_pattern(filename)\n        if is_valid_pattern(pattern):\n            return \"Yes\\n\" + pattern\n\n    return \"No\"\n"
    },
    {
        "number": 3875,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A = map(int, stdin.split())\n    A_max = max(A)\n    dp = [0] * (A_max + 1)\n    for a in A:\n        dp[a] = max(dp[:a]) + 1\n    total = sum(dp)\n    ans = (total + N) // N\n    return str(ans)"
    },
    {
        "number": 3876,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent, u):\n        if parent[u] == u:\n            return u\n        parent[u] = find_parent(parent, parent[u])\n        return parent[u]\n\n    def union_parent(parent, u, v):\n        u = find_parent(parent, u)\n        v = find_parent(parent, v)\n        if u != v:\n            parent[u] = v\n\n    N, edges = int(stdin.strip().split('\\n')[0]), [tuple(map(int, edge.split())) for edge in stdin.strip().split('\\n')[1:]]\n    parent = list(range(N + 1))\n    for u, v in edges:\n        union_parent(parent, u, v)\n    components = set()\n    for u in range(1, N + 1):\n        components.add(find_parent(parent, u))\n    return str((2 ** (N // 2)) % (10**9 + 7))"
    },
    {
        "number": 3877,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    lst = [n]\n    while any(x > 1 for x in lst):\n        x = max(i for i in lst if i > 1)\n        pos = lst.index(x)\n        lst[pos] = x % 2\n        lst[pos + 1:pos + 1] = [x // 2] * 2\n\n    return str(sum(1 for i in range(l - 1, r) if lst[i] == 1))"
    },
    {
        "number": 3878,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected(graph, n):\n        visited = [False] * (n + 1)\n        def dfs(node):\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor)\n        dfs(1)\n        return all(visited[2:])\n\n    def find_guest(graph, n):\n        for i in range(1, n + 1):\n            if i not in graph[1] and graph[i] and is_connected(graph, n):\n                return i\n        return None\n\n    def make_friends(graph, n):\n        steps = 0\n        while not is_connected(graph, n):\n            guest = find_guest(graph, n)\n            if guest is None:\n                return -1\n            graph[1].add(guest)\n            for friend in graph[guest]:\n                graph[friend].add(1)\n            steps += 1\n        return steps\n\n    n, m = map(int, stdin.readline().split())\n    graph = {i: set() for i in range(1, n + 1)}\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        graph[u].add(v)\n        graph[v].add(u)\n\n    steps = make_friends(graph, n)\n    if steps == -1:\n        return \"-1\\n\"\n\n    result = [1]\n    for _ in range(steps - 1):\n        guest = find_guest(graph, n)\n        result.append(guest)\n        graph[1].add(guest)\n        for friend in graph[guest]:\n            graph[friend].add(1)\n\n    return f\"{steps}\\n{' '.join(map(str, result))}\\n\""
    },
    {
        "number": 3879,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    bids = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    bids.sort()\n\n    if bids[0] == bids[-1]:\n        return \"Yes\"\n\n    for i in range(1, n):\n        if bids[i] != bids[0] and bids[i] // 2 == bids[0]:\n            return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 3880,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = list(map(int, stdin.split(\"\\n\")[1].split()))\n    arr.sort()\n    max_sum = sum(arr)\n    for i in range(n):\n        max_sum -= 2 * arr[i]\n    return str(max_sum)"
    },
    {
        "number": 3881,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.readline().split())\n    operations = []\n    for _ in range(q):\n        a, b = stdin.readline().strip().split()\n        operations.append((a, b))\n\n    def is_valid(s: str) -> bool:\n        if len(s) < 2:\n            return False\n        for a, b in operations:\n            if s[:2] == a:\n                s = b + s[2:]\n        return s == \"a\"\n\n    count = 0\n    for i in range(26):\n        for j in range(26):\n            s = chr(i + ord('a')) + chr(j + ord('a'))\n            if len(s) == n and is_valid(s):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3882,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    mod = 10**9 + 7\n\n    # dp[i][j] represents the number of binary relations of size i with j elements\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Base case: for size 1, there is only one such relation\n    for i in range(1, n + 1):\n        dp[i][1] = 1\n\n    # For each size i, generate all valid relations with j elements\n    for i in range(2, n + 1):\n        for j in range(2, i + 1):\n            # The number of valid relations with j elements is the sum of:\n            # 1. The number of valid relations with j - 1 elements\n            # 2. The number of valid relations with j - 1 elements and the last element is related to the first one\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1]) % mod\n\n    # Calculate the total number of valid relations\n    total = sum(dp[n][j] for j in range(2, n + 1)) % mod\n\n    return str(total)"
    },
    {
        "number": 3883,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    x = 1.0\n    while True:\n        if (a <= x and b <= x) or (a <= x + b and b <= x):\n            return '{:.11f}'.format(x)\n        elif a <= x and b > x:\n            return '-1'\n        x += 0.01\n"
    },
    {
        "number": 3884,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def can_make_flight(fuel_mass, payload_mass, takeoff_coefficients, landing_coefficients):\n        total_mass = payload_mass + fuel_mass\n        for i in range(1, n):\n            takeoff_fuel = (total_mass // takeoff_coefficients[i]) + 1\n            landing_fuel = (total_mass // landing_coefficients[i]) + 1\n            total_mass = total_mass - takeoff_fuel + landing_fuel\n            if total_mass < 0:\n                return False\n        return True\n\n    def binary_search(left, right, payload_mass, takeoff_coefficients, landing_coefficients):\n        while left <= right:\n            mid = (left + right) / 2\n            if can_make_flight(mid, payload_mass, takeoff_coefficients, landing_coefficients):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    n, m, a, b = map(int, stdin.split())\n    takeoff_coefficients = [0] + a\n    landing_coefficients = [0] + b\n\n    if n == 2:\n        return \"-1\"\n\n    left, right = 0, m * (n - 2) * sum(takeoff_coefficients)\n    result = binary_search(left, right, m, takeoff_coefficients, landing_coefficients)\n\n    return f\"{result:.10f}\""
    },
    {
        "number": 3885,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    min_cost = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            min_cost += (i + j) % (n + 1)\n    return str(min_cost)"
    },
    {
        "number": 3886,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def generate_string(n: int) -> str:\n        if n == 0:\n            return \"What are you doing at the end of the world? Are you busy? Will you save us?\"\n        else:\n            return f\"What are you doing while sending \\\"{generate_string(n - 1)}\\\"? Are you busy? Will you send \\\"{generate_string(n - 1)}\\\"?\"\n\n    def get_kth_char(n: int, k: int) -> str:\n        f_n = generate_string(n)\n        if k > len(f_n):\n            return '.'\n        else:\n            return f_n[k - 1]\n\n    q = int(stdin.readline().strip())\n    answers = []\n    for _ in range(q):\n        n, k = map(int, stdin.readline().strip().split())\n        answers.append(get_kth_char(n, k))\n\n    return ''.join(answers)"
    },
    {
        "number": 3887,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"=\")[1].strip())\n    question_marks = stdin.split(\"=\")[0].strip().split(\" \")\n    ops = []\n    for i, op in enumerate(question_marks):\n        if op in [\"+\", \"-\"]:\n            ops.append(op)\n            question_marks.pop(i)\n\n    def backtrack(index, current_sum, used):\n        if index == len(question_marks):\n            if current_sum == n:\n                return True\n            return False\n\n        for i in range(1, n + 1):\n            if i not in used:\n                used.add(i)\n                if (index == 0 or ops[index - 1] == \"+\") and (current_sum + i <= n):\n                    if backtrack(index + 1, current_sum + i, used):\n                        return True\n                elif (index == 0 or ops[index - 1] == \"-\") and (current_sum - i >= 0):\n                    if backtrack(index + 1, current_sum - i, used):\n                        return True\n                used.remove(i)\n        return False\n\n    if backtrack(0, 0, set()):\n        output = \"Possible\\n\"\n        for i, op in enumerate(ops):\n            output += str(question_marks[i]) + op\n        output += str(question_marks[-1]) + \" = \" + str(n)\n    else:\n        output = \"Impossible\"\n\n    return output"
    },
    {
        "number": 3888,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    a = [list(map(int, row.split())) for row in stdin.split('\\n')[1:]]\n\n    def mex(x, y):\n        if x == 0 and y == 0:\n            return 1\n        elif x == 0 and y == 1:\n            return 2\n        elif x == 0 and y == 2:\n            return 0\n        elif x == 1 and y == 0:\n            return 0\n        elif x == 1 and y == 1:\n            return 1\n        elif x == 1 and y == 2:\n            return 2\n        elif x == 2 and y == 0:\n            return 1\n        elif x == 2 and y == 1:\n            return 0\n        elif x == 2 and y == 2:\n            return 1\n\n    for i in range(2, N + 1):\n        for j in range(2, N + 1):\n            a[i - 1][j - 1] = mex(a[i - 2][j - 1], a[i - 1][j - 2])\n\n    counts = [0, 0, 0]\n    for i in range(N):\n        for j in range(N):\n            counts[a[i][j]] += 1\n\n    return f\"{counts[0]} {counts[1]} {counts[2]}\""
    },
    {
        "number": 3889,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n    s = s.strip()\n    colors = [0] * 26\n    for c in s:\n        colors[ord(c) - ord('a')] += 1\n    for i in range(26):\n        if colors[i] >= 2:\n            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 3890,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 1000000007\n\n    def count_ways(n: int, k: int) -> int:\n        dp = [0] * (n + 1)\n        dp[1] = 1\n\n        for i in range(2, n + 1):\n            for j in range(1, i):\n                if j >= k:\n                    dp[i] += dp[j]\n                    dp[i] %= MOD\n\n        return dp[n]\n\n    return str(count_ways(n, k))"
    },
    {
        "number": 3891,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    table = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def find_square(table):\n        for i in range(n):\n            for j in range(m):\n                if table[i][j] == 'B':\n                    if i + 1 < n and j + 1 < m and table[i + 1][j] == 'B' and table[i][j + 1] == 'B':\n                        return i, j\n        return None\n\n    def find_center(i, j):\n        if i == 0 or i == n - 1 or j == 0 or j == m - 1:\n            return None\n        if table[i - 1][j] == 'B' and table[i + 1][j] == 'B' and table[i][j - 1] == 'B' and table[i][j + 1] == 'B':\n            return i, j\n        return None\n\n    i, j = find_square(table)\n    if i is not None and j is not None:\n        center = find_center(i, j)\n        if center is not None:\n            return f\"{center[0] + 1} {center[1] + 1}\\n\"\n    return \"No black square with odd side length found.\\n\""
    },
    {
        "number": 3892,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    stations = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        stations[a-1].append(b-1)\n\n    def dfs(start, visited, time):\n        if visited[start]:\n            return time\n        visited[start] = True\n        for next_station in stations[start]:\n            if not visited[next_station]:\n                time = dfs(next_station, visited, time) + 1\n        return time\n\n    answer = []\n    for i in range(n):\n        visited = [False] * n\n        answer.append(dfs(i, visited, 0))\n\n    return ' '.join(map(str, answer))"
    },
    {
        "number": 3893,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    x1, y1, x2, y2, n = map(int, stdin.split()[:5])\n    roads = [list(map(int, line.split())) for line in stdin.split('\\n')[2:2 + n]]\n\n    # Check if the home and university are in the same block\n    def check_same_block(x1, y1, x2, y2, roads):\n        for a, b, c in roads:\n            if a * x1 + b * y1 + c == 0 and a * x2 + b * y2 + c == 0:\n                return True\n        return False\n\n    if check_same_block(x1, y1, x2, y2, roads):\n        return '0'\n\n    # Find the blocks\n    def find_blocks(roads):\n        blocks = []\n        for a, b, c in roads:\n            block = set()\n            for x in range(-10**6, 10**6):\n                y = -(a * x + c) / b\n                if y.is_integer():\n                    block.add((x, int(y)))\n            blocks.append(block)\n        return blocks\n\n    blocks = find_blocks(roads)\n\n    # Find the shortest path\n    def bfs(start, end, blocks):\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            (x, y), steps = queue.pop(0)\n            if (x, y) == end:\n                return steps\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            for i, block in enumerate(blocks):\n                if (x, y) in block:\n                    for j in range(len(blocks)):\n                        if i != j and not blocks[i].isdisjoint(blocks[j]):\n                            for point in blocks[j]:\n                                if point != (x, y):\n                                    queue.append((point, steps + 1))\n\n    return str(bfs((x1, y1), (x2, y2), blocks))"
    },
    {
        "number": 3894,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_even(x):\n        return x % 2 == 0\n\n    def find_winner(a, k):\n        while any(x > 0 for x in a):\n            if is_even(a[0]):\n                x = a[0] // 2\n                if x * k <= 10**9:\n                    a[0] = x * k\n                else:\n                    return \"Nicky\"\n            else:\n                a.sort(reverse=True)\n                a[0] -= 1\n        return \"Kevin\"\n\n    return find_winner(a, k)"
    },
    {
        "number": 3895,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_m(f, n):\n        m = max(f)\n        while True:\n            if all(x == 1 or x <= m and x >= 1 for x in f):\n                return m\n            m += 1\n\n    def find_g_h(f, n, m):\n        g = [0] * n\n        h = [0] * m\n        for i in range(n):\n            g[i] = f[i]\n            h[f[i] - 1] = i + 1\n        return g, h\n\n    n = int(stdin.split('\\n')[0])\n    f = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 1:\n        return \"1\\n1\\n1\"\n\n    m = find_m(f, n)\n    if m is None:\n        return \"-1\\n\"\n\n    g, h = find_g_h(f, n, m)\n    return f\"{m}\\n{' '.join(map(str, g))}\\n{' '.join(map(str, h))}\\n\""
    },
    {
        "number": 3896,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    x = int(stdin, 2)\n    complexity = 0\n\n    for i in range(2**n):\n        for j in range(i + 1, 2**n):\n            if i ^ x < j ^ x:\n                complexity += 1\n\n    return str(complexity % (10**9 + 7))"
    },
    {
        "number": 3897,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    m = 1\n    for i in a:\n        m *= i\n    mod = 1000000007\n    dp = [0] * (m + 1)\n    dp[1] = 1\n    for i in range(n):\n        for j in range(a[i], m + 1):\n            dp[j] += dp[j // a[i]]\n            dp[j] %= mod\n    return str(dp[m])"
    },
    {
        "number": 3898,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(lambda x: list(map(int, x.split())), stdin.split('\\n')[1:])\n    visited = [False] * n\n    def dfs(i):\n        if visited[i]:\n            return False\n        visited[i] = True\n        if a[i] == 0:\n            return True\n        for j in range(n):\n            if j != i and not visited[j] and (a[i] == b[j] or a[j] == b[i]):\n                if dfs(j):\n                    return True\n        return False\n    for i in range(n):\n        if a[i] == 0:\n            if dfs(i):\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 3899,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    a.sort()\n    b.sort()\n\n    total_power = sum(a)\n    total_processors = sum(b)\n\n    threshold = total_power / total_processors\n\n    for i in range(n):\n        if b[i] == 1:\n            continue\n        else:\n            if a[i] * 2 > threshold:\n                threshold = a[i] * 2\n\n    return str(round(threshold * 1000))"
    },
    {
        "number": 3900,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    coders = [set() for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        x, y = map(int, input().split())\n        coders[i].add(x)\n        coders[i].add(y)\n\n    def count_agreements(suspect1, suspect2):\n        agreements = 0\n        for i in range(1, n + 1):\n            if suspect1 in coders[i] or suspect2 in coders[i]:\n                agreements += 1\n        return agreements\n\n    valid_sets = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if count_agreements(i, j) >= p:\n                valid_sets += 1\n\n    return str(valid_sets)"
    },
    {
        "number": 3901,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def is_possible():\n        for i in range(n - 1):\n            if a[i] != a[i + 1]:\n                if gcd(a[i], a[i + 1]) == 1:\n                    return False\n        return True\n\n    def count_operations():\n        operations = 0\n        for i in range(n - 1):\n            if a[i] != a[i + 1]:\n                g = gcd(a[i], a[i + 1])\n                a[i] = a[i] // g\n                a[i + 1] = a[i + 1] // g\n                operations += 1\n        return operations\n\n    if is_possible():\n        return str(count_operations())\n    else:\n        return '-1'"
    },
    {
        "number": 3902,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    suffixes = set()\n\n    for i in range(len(s) - 2):\n        for j in range(i + 2, len(s) - 1):\n            if s[j - 1] != s[j]:\n                suffixes.add(s[j:])\n                suffixes.add(s[i:j])\n\n    suffixes = sorted(list(suffixes))\n    output = [str(len(suffixes))] + suffixes\n    return \"\\n\".join(output)"
    },
    {
        "number": 3903,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(stdin.readline().strip()))\n\n    def is_passable(x, y):\n        return 0 < x <= n and 0 < y <= m and matrix[x][y] != '#'\n\n    def bfs(start_x, start_y):\n        queue = [(start_x, start_y)]\n        visited = set()\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            if matrix[x][y] != '.':\n                return True\n            queue.append((x + 1, y))\n            queue.append((x - 1, y))\n            queue.append((x, y + 1))\n            queue.append((x, y - 1))\n        return False\n\n    road_count = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if matrix[i][j] != '.':\n                continue\n            if not bfs(i, j):\n                road_count += 1\n                for x in range(1, n + 1):\n                    for y in range(1, m + 1):\n                        if is_passable(x, y) and not bfs(x, y):\n                            return -1\n\n    return road_count"
    },
    {
        "number": 3904,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sequence = stdin.split(\"\\n\")\n    n = int(n)\n\n    if n % 2 != 0:\n        return \"-1\"\n\n    opening_brackets = 0\n    closing_brackets = 0\n    for char in sequence:\n        if char == \"(\":\n            opening_brackets += 1\n        else:\n            closing_brackets += 1\n\n        if closing_brackets > opening_brackets:\n            return \"-1\"\n\n    return str(n // 2)"
    },
    {
        "number": 3905,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_experiment(data_centers, clients, experiment_data_centers):\n        for client in clients:\n            if data_centers[client[0] - 1] in experiment_data_centers and data_centers[client[1] - 1] in experiment_data_centers:\n                return False\n        return True\n\n    def find_min_experiment_data_centers(data_centers, clients):\n        min_experiment_data_centers = len(data_centers)\n        experiment_data_centers = set()\n\n        for i in range(1, len(data_centers) + 1):\n            for experiment_data_center in itertools.combinations(data_centers, i):\n                if is_valid_experiment(data_centers, clients, set(experiment_data_center)):\n                    if i < min_experiment_data_centers:\n                        min_experiment_data_centers = i\n                        experiment_data_centers = set(experiment_data_center)\n\n        return min_experiment_data_centers, experiment_data_centers\n\n    lines = stdin.split('\\n')\n    n, m, h = map(int, lines[0].split())\n    data_centers = [int(u) for u in lines[1].split()]\n    clients = [(int(c1), int(c2)) for c1, c2 in map(lambda x: x.split(), lines[2:])]\n\n    min_experiment_data_centers, experiment_data_centers = find_min_experiment_data_centers(data_centers, clients)\n\n    return f\"{min_experiment_data_centers}\\n\" + ' '.join(map(str, experiment_data_centers)) + '\\n'"
    },
    {
        "number": 3906,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 7\n    total = 2 ** (n * m)\n    black_rows = [0] * n\n    black_cols = [0] * m\n\n    for i in range(n):\n        for j in range(m):\n            black_rows[i] += 1\n            black_cols[j] += 1\n            total -= black_rows[i] * black_cols[j]\n\n    return str(total % MOD)"
    },
    {
        "number": 3907,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    coupons = []\n    for _ in range(m):\n        q, w = map(int, input().split())\n        coupons.append((q, w))\n\n    coupons.sort(key=lambda x: x[0])\n\n    max_money = 0\n    for i in range(m):\n        q, w = coupons[i]\n        max_money += w\n        for j in range(i + 1, m):\n            q_next, w_next = coupons[j]\n            if q_next != q + 1:\n                break\n            max_money -= w_next\n\n    return str(max_money)"
    },
    {
        "number": 3908,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    max_occurrences = 0\n\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            substring = s[i:i + length]\n            occurrences = 0\n            common_diff = 1\n\n            while common_diff <= length:\n                indices = []\n                j = i\n                k = 0\n\n                while k < length:\n                    if j >= n:\n                        break\n                    if s[j] == substring[k]:\n                        indices.append(j)\n                        k += 1\n                    j += 1\n\n                if len(indices) == length and all(indices[i + 1] - indices[i] == common_diff for i in range(length - 1)):\n                    occurrences += 1\n                else:\n                    break\n\n                common_diff += 1\n\n            max_occurrences = max(max_occurrences, occurrences)\n\n    return str(max_occurrences)"
    },
    {
        "number": 3909,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907, 43046721, 129140163, 387420489, 1162261467, 3486784401, 1048576, 3145728, 9437184, 285212672, 822653357, 2413756736, 7036874417, 21120895037, 63382530231, 187491942465, 523022617469, 15053565305665, 40685028318324, 1063382396628161, 288230376151711729, 754974723156689283, 20365835801606297654, 5105147815468010106]\n    min_coins = n\n    for coin in coins:\n        if coin <= n:\n            min_coins = min(min_coins, 1 + solution(n - coin))\n    return min_coins"
    },
    {
        "number": 3910,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    pairs = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().split())\n        pairs.append((a, b))\n\n    def is_valid(foods: list) -> bool:\n        for i in range(n):\n            if foods[i][0] == foods[i][1]:\n                return False\n            if pairs[i][0] == pairs[i][1]:\n                return False\n            if pairs[i][0] == pairs[i][1] - 1:\n                return False\n            if pairs[i][0] == pairs[i][1] + 1:\n                return False\n            if pairs[i][0] > pairs[i][1]:\n                return False\n        return True\n\n    def print_foods(foods: list) -> str:\n        result = []\n        for food in foods:\n            if food[0] == 1:\n                result.append(\"1 2\")\n            else:\n                result.append(\"2 1\")\n        return \"\\n\".join(result)\n\n    foods = [[1, 2] for _ in range(n)]\n    if is_valid(foods):\n        return print_foods(foods)\n    else:\n        return \"-1\""
    },
    {
        "number": 3911,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    row = [1] * n\n\n    for i in range(1, n):\n        if row[-1] == 1:\n            row[-1] = 2\n        else:\n            row.append(1)\n\n    return \" \".join(map(str, row))"
    },
    {
        "number": 3912,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def find_min_palindromes(s: str) -> int:\n        for length in range(1, len(s) // 2 + 1):\n            if len(s) % length == 0:\n                parts = [s[i:i + length] for i in range(0, len(s), length)]\n                if all(is_palindrome(part) for part in parts):\n                    return len(parts)\n        return len(s)\n\n    def rearrange_string(s: str) -> str:\n        s = sorted(s, key=lambda x: (x.isdigit(), x.islower(), x.isupper(), x))\n        return ''.join(s)\n\n    s = rearrange_string(s)\n    k = find_min_palindromes(s)\n    parts = [s[i:i + len(s) // k] for i in range(0, len(s), len(s) // k)]\n\n    return f\"{k}\\n{' '.join(parts)}\""
    },
    {
        "number": 3913,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, revealed, m, words = parse_input(stdin)\n    possible_words = filter_words(revealed, words)\n    letters = set()\n\n    for word in possible_words:\n        for i in range(n):\n            if word[i] not in revealed:\n                letters.add(word[i])\n\n    return str(len(letters))\n\ndef"
    },
    {
        "number": 3914,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, b = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n\n    x1 = 0\n    x2 = 0\n\n    for i in range(1, n):\n        if i <= d:\n            x1 += min(a[i], b) != b\n            x2 += min(a[n - i], b) != b\n        else:\n            x1 += min(a[i - d], b) != b\n            x2 += min(a[n - i + d], b) != b\n\n    return str(max(x1, x2))"
    },
    {
        "number": 3915,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    A = p / q\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    def is_palindromic(n: int) -> bool:\n        return str(n) == str(n)[::-1]\n\n    def count_primes(n: int) -> int:\n        count = 0\n        for i in range(2, n + 1):\n            if is_prime(i):\n                count += 1\n        return count\n\n    def count_palindromics(n: int) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if is_palindromic(i):\n                count += 1\n        return count\n\n    def find_max_n(A: float) -> int:\n        n = 1\n        while True:\n            if count_primes(n) <= A * count_palindromics(n):\n                return n\n            n += 1\n\n    if A < 1 / 42 or A > 42:\n        return \"Palindromic tree is better than splay tree\"\n    else:\n        return find_max_n(A) "
    },
    {
        "number": 3916,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_node(x):\n        if x == 1:\n            return 1\n        prime_factors = []\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                prime_factors.append(i)\n                prime_factors.append(x // i)\n        return min(prime_factors)\n\n    def get_path_length(node, target):\n        length = 0\n        while node != target:\n            node = get_next_node(node)\n            length += 1\n        return length\n\n    n = int(stdin.readline().strip())\n    k = list(map(int, stdin.readline().strip().split()))\n\n    fragments = [factorial(ki) for ki in k]\n    target = min(fragments)\n    total_length = sum(get_path_length(fragment, target) for fragment in fragments)\n\n    return str(total_length)"
    },
    {
        "number": 3917,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def g(i, j):\n        return sum(a[min(i, j) + 1:max(i, j) + 1])\n\n    def f(i, j):\n        return (i - j) ** 2 + g(i, j) ** 2\n\n    min_value = float('inf')\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                min_value = min(min_value, f(i, j))\n\n    return str(min_value)"
    },
    {
        "number": 3918,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k1, k2 = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    a.sort()\n    b.sort()\n\n    i, j = 0, 0\n    error = 0\n\n    while i < n and j < n:\n        if a[i] < b[j]:\n            error += (b[j] - a[i]) ** 2\n            i += 1\n        elif a[i] > b[j]:\n            error += (a[i] - b[j]) ** 2\n            j += 1\n        else:\n            i += 1\n            j += 1\n\n    while i < n:\n        error += (b[-1] - a[i]) ** 2\n        i += 1\n\n    while j < n:\n        error += (a[-1] - b[j]) ** 2\n        j += 1\n\n    return error"
    },
    {
        "number": 3919,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    S = stdin.readline().strip()\n    l_i = [0] * M\n    r_i = [0] * M\n    for i in range(M):\n        l_i[i], r_i[i] = map(int, stdin.readline().split())\n\n    mod = 1000000007\n    total_permutations = 0\n\n    for i in range(M):\n        unique_chars = set(S[l_i[i] - 1:r_i[i]])\n        n = r_i[i] - l_i[i] + 1\n        total_permutations += len(unique_chars) * factorial(n, mod)\n        total_permutations %= mod\n\n    return str(total_permutations)\n\ndef"
    },
    {
        "number": 3920,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sides = list(map(int, stdin.split()))\n    triangles = 0\n    for side in sides:\n        triangles += side - 1\n    return str(triangles)"
    },
    {
        "number": 3921,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] % a[j] == 0 or a[j] % a[i] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return str(max(dp))"
    },
    {
        "number": 3922,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(grid, organs):\n        for organ in organs:\n            if organ not in grid:\n                return False\n        return True\n\n    def find_empty_cell(grid):\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == \"E\":\n                    return (i, j)\n        return None\n\n    def move_organ(grid, organs, organ, direction):\n        empty_cell = find_empty_cell(grid)\n        if direction == \"u\":\n            grid[empty_cell[0]][empty_cell[1]] = grid[empty_cell[0] - 1][empty_cell[1]]\n            grid[empty_cell[0] - 1][empty_cell[1]] = \"E\"\n        elif direction == \"d\":\n            grid[empty_cell[0]][empty_cell[1]] = grid[empty_cell[0] + 1][empty_cell[1]]\n            grid[empty_cell[0] + 1][empty_cell[1]] = \"E\"\n        elif direction == \"l\":\n            grid[empty_cell[0]][empty_cell[1]] = grid[empty_cell[0]][empty_cell[1] - 1]\n            grid[empty_cell[0]][empty_cell[1] - 1] = \"E\"\n        elif direction == \"r\":\n            grid[empty_cell[0]][empty_cell[1]] = grid[empty_cell[0]][empty_cell[1] + 1]\n            grid[empty_cell[0]][empty_cell[1] + 1] = \"E\"\n        organs.remove(organ)\n\n    def create_grid(k):\n        grid = [[\"E\" for _ in range(2 * k + 1)] for _ in range(2)]\n        for i in range(2):\n            for j in range(k + 1):\n                grid[i][j] = i * (2 * k + 1) + j + 1\n            for j in range(k + 1, 2 * k + 1):\n                grid[i][j] = (i + 1) * (2 * k + 1) - j\n        return grid\n\n    def print_grid(grid):\n        for row in grid:\n            print(\" \".join(str(cell) for cell in row))\n\n    def find_shortcuts(moves):\n        shortcuts = {}\n        for i in range(len(moves)):\n            for j in range(i + 1, len(moves) + 1):\n                if moves[i:j] not in shortcuts:\n                    shortcuts[moves[i:j]] = \"\".join(moves[i:j])\n        return shortcuts\n\n    def expand_shortcuts(moves, shortcuts):\n        expanded_moves = []\n        i = 0\n        while i < len(moves):\n            if moves[i] in shortcuts:\n                expanded_moves.append(shortcuts[moves[i]])\n                i += len(moves[i])\n            else:\n                expanded_moves.append(moves[i])\n                i += 1\n        return \"\".join(expanded_moves)\n\n    def surgery_procedure(grid, k, organs):\n        moves = []\n        while not is_valid(grid, organs):\n            empty_cell = find_empty_cell(grid)\n            if empty_cell[1] == 0:\n                move_organ(grid, organs, grid[empty_cell[0]][empty_cell[1] + 1], \"r\")\n                moves.append(\"r\")\n            elif empty_cell[1] == len(grid[0]) - 1:\n                move_organ(grid, organs, grid[empty_cell[0]][empty_cell[1] - 1], \"l\")\n                moves.append(\"l\")\n            elif empty_cell[0] == 0:\n                move_organ(grid, organs, grid[empty_cell[0] + 1][empty_cell[1]], \"d\")\n                moves.append(\"d\")\n            elif empty_cell[0] == len(grid)"
    },
    {
        "number": 3923,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split())\n    P = []\n\n    def f(i, j):\n        if j == 1:\n            return P[i - 1]\n        else:\n            return f(P[i - 1], j - 1)\n\n    def g(i):\n        j = 1\n        while f(i, j) != i:\n            j += 1\n        return j\n\n    for i in range(1, N + 1):\n        if g(i) == A or g(i) == B:\n            P.append(i)\n\n    if len(P) == N:\n        return \" \".join(map(str, P))\n    else:\n        return -1\n"
    },
    {
        "number": 3924,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    garbage_per_day = list(map(int, stdin.split()[2:]))\n    bags = 0\n    current_bag = 0\n\n    for i in range(n):\n        current_bag += garbage_per_day[i]\n\n        if current_bag >= k:\n            bags += current_bag // k\n            current_bag = current_bag % k\n        elif i == n - 1 and current_bag > 0:\n            bags += 1\n\n    return str(bags)"
    },
    {
        "number": 3925,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    max_len = 0\n\n    for i in range(n):\n        black = s[i] == 'b'\n        curr_len = 1\n        for j in range(i + 1, n):\n            if s[j] == 'b' and black:\n                curr_len += 1\n            elif s[j] == 'w' and not black:\n                curr_len += 1\n            else:\n                break\n            black = not black\n        max_len = max(max_len, curr_len)\n\n    return str(max_len)"
    },
    {
        "number": 3926,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    r, c = map(int, stdin.readline().split())\n    x, y = map(int, stdin.readline().split())\n    maze = [list(stdin.readline().strip()) for _ in range(n)]\n\n    def is_valid_move(row, col):\n        return 1 <= row <= n and 1 <= col <= m and maze[row - 1][col - 1] != '*'\n\n    def dfs(row, col, x_moves, y_moves):\n        if not is_valid_move(row, col):\n            return False\n\n        if x_moves < 0 or y_moves < 0:\n            return False\n\n        if row == r and col == c:\n            return True\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_row, new_col = row + dx, col + dy\n            if dfs(new_row, new_col, x_moves - abs(dx), y_moves - abs(dy)):\n                return True\n\n        return False\n\n    reachable_cells = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if dfs(i, j, x, y):\n                reachable_cells += 1\n\n    return str(reachable_cells)"
    },
    {
        "number": 3927,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    weights = sorted([int(x) for x in stdin.split('\\n')[1].split()])\n\n    max_weights = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if weights[i] + weights[j] <= 100:\n                max_weights = max(max_weights, 2)\n            else:\n                break\n\n    return str(max_weights)"
    },
    {
        "number": 3928,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    s = input()\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = a\n        for j in range(i):\n            if s[j:i + 1] == s[j:i + 1 - j]:\n                dp[i] = min(dp[i], dp[j] + b)\n    return str(dp[-1])\n\nn, a, b = map(int, input().split())\ns = input()\nprint(solution(f\"{n} {a} {b}\")) "
    },
    {
        "number": 3929,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def count_sequences(N: int, K: int) -> int:\n        if K > N // 2:\n            return (N - K + 1) * pow(2, N - K, mod) % mod\n        else:\n            return pow(2, K - 1, mod)\n\n    return str(count_sequences(N, K))"
    },
    {
        "number": 3930,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    total_affection = sum(a)\n    count = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            segment_affection = sum(a[i:j + 1])\n            if total_affection - segment_affection == 0:\n                continue\n            if total_affection - segment_affection > 0 and (total_affection - segment_affection) % abs(k) == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3931,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_cost(trips, a, b, k, f):\n        n, stops = len(trips), set()\n        for trip in trips:\n            stops.add(trip[0])\n            stops.add(trip[1])\n        stops = list(stops)\n\n        dp = [[0] * len(stops) for _ in range(len(stops))]\n        for i in range(len(stops)):\n            dp[i][i] = a\n\n        for l in range(2, n + 1):\n            for i in range(n - l + 1):\n                j = i + l - 1\n                for mid in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid + 1][j])\n\n        for i in range(len(stops)):\n            for j in range(len(stops)):\n                if stops[i] == trips[0][0] and stops[j] == trips[0][1]:\n                    dp[i][j] = a\n                elif i != j:\n                    dp[i][j] += b\n\n        min_cost = min(dp[i][j] for i in range(len(stops)) for j in range(len(stops)))\n\n        if k == 0:\n            return min_cost\n\n        for i in range(len(stops)):\n            for j in range(len(stops)):\n                if stops[i] == trips[0][0] and stops[j] == trips[0][1]:\n                    dp[i][j] = a\n                elif i != j:\n                    dp[i][j] += b\n\n        for i in range(len(stops)):\n            for j in range(len(stops)):\n                if i != j:\n                    dp[i][j] -= f\n\n        min_cost_with_cards = min(dp[i][j] for i in range(len(stops)) for j in range(len(stops)))\n\n        return min(min_cost, min_cost_with_cards)\n\n    lines = stdin.split('\\n')\n    params = list(map(int, lines[0].split()))\n    trips = [line.split() for line in lines[1:params[0] + 1]]\n\n    min_cost = find_min_cost(trips, params[1], params[2], params[3], params[4])\n    return str(min_cost)"
    },
    {
        "number": 3932,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    c = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid_tree(node: int, parent: int) -> bool:\n        if node == 0:\n            return False\n        if node == 1:\n            return True\n        if c[node] < 2:\n            return False\n        for i in range(1, node):\n            if is_valid_tree(i, node) and is_valid_tree(node - i, node):\n                return True\n        return False\n\n    for i in range(1, n):\n        if is_valid_tree(i, 0):\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 3933,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    temperatures = list(map(int, stdin.split('\\n')[1].split()))\n\n    if len(temperatures) != n:\n        raise ValueError(\"Invalid input: temperatures list length does not match n\")\n\n    if n == 2:\n        return str(temperatures[1])\n\n    difference = temperatures[1] - temperatures[0]\n    is_arithmetic_progression = True\n\n    for i in range(2, n):\n        if temperatures[i] - temperatures[i - 1] != difference:\n            is_arithmetic_progression = False\n            break\n\n    if is_arithmetic_progression:\n        predicted_temperature = temperatures[-1] + difference\n    else:\n        predicted_temperature = temperatures[-1]\n\n    return str(predicted_temperature)"
    },
    {
        "number": 3934,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [(int(x[0]), int(x[1])) for x in map(lambda x: x.split(' '), stdin.split('\\n')[1:])]\n\n    def find_root(node: int) -> int:\n        if parent[node] == node:\n            return node\n        return find_root(parent[node])\n\n    def union(u: int, v: int) -> None:\n        u_root = find_root(u)\n        v_root = find_root(v)\n        if u_root == v_root:\n            return\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n        elif rank[u_root] > rank[v_root]:\n            parent[v_root] = u_root\n        else:\n            parent[v_root] = u_root\n            rank[u_root] += 1\n\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    for u, v in edges:\n        union(u, v)\n\n    for i in range(1, n + 1):\n        if find_root(i) != find_root(1):\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3935,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_bipartite(graph, n):\n        color = [-1] * n\n        color[0] = 0\n        q = [0]\n        while q:\n            u = q.pop(0)\n            for v in graph[u]:\n                if color[u] == color[v]:\n                    return False\n                if color[v] == -1:\n                    color[v] = 1 - color[u]\n                    q.append(v)\n        return True\n\n    def bfs(graph, n):\n        color = [-1] * n\n        color[0] = 0\n        q = [0]\n        while q:\n            u = q.pop(0)\n            for v in graph[u]:\n                if color[u] == color[v]:\n                    return False\n                if color[v] == -1:\n                    color[v] = 1 - color[u]\n                    q.append(v)\n        return True\n\n    def dfs(graph, n):\n        color = [-1] * n\n        stack = []\n        for i in range(n):\n            if color[i] == -1:\n                color[i] = 0\n                stack.append(i)\n                while stack:\n                    u = stack.pop()\n                    for v in graph[u]:\n                        if color[u] == color[v]:\n                            return False\n                        if color[v] == -1:\n                            color[v] = 1 - color[u]\n                            stack.append(v)\n        return True\n\n    n = int(stdin.readline().strip())\n    B = list(map(int, stdin.readline().strip().split()))\n\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(B[i] - B[j]) in B:\n                graph[i].append(j)\n                graph[j].append(i)\n\n    if is_bipartite(graph, n):\n        return \"0\"\n\n    for i in range(n):\n        if i not in graph[i]:\n            graph[i].append(i)\n\n    if dfs(graph, n):\n        return \"0\"\n\n    min_size = float(\"inf\")\n    min_subset = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(B[i] - B[j]) in B:\n                graph[i].remove(j)\n                graph[j].remove(i)\n                if dfs(graph, n):\n                    size = len(graph[i]) + len(graph[j])\n                    if size < min_size:\n                        min_size = size\n                        min_subset = [B[i], B[j]]\n                graph[i].append(j)\n                graph[j].append(i)\n\n    return f\"{len(min_subset)}\\n{' '.join(map(str, min_subset))}\""
    },
    {
        "number": 3936,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    mod = 1000000007\n    N = int(stdin.split(\"\\n\")[0])\n    S_1 = stdin.split(\"\\n\")[1]\n    S_2 = stdin.split(\"\\n\")[2]\n\n    def paint(i, j, color):\n        if i < 0 or i >= N or j < 0 or j >= N:\n            return 0\n        if S_1[i] == S_2[j]:\n            return 0\n        if dp[i][j][color] != -1:\n            return dp[i][j][color]\n\n        if color == 0:\n            dp[i][j][color] = (paint(i - 1, j, 1) + paint(i + 1, j, 1) + paint(i, j - 1, 1) + paint(i, j + 1, 1)) % mod\n        elif color == 1:\n            dp[i][j][color] = (paint(i - 1, j, 2) + paint(i + 1, j, 2) + paint(i, j - 1, 2) + paint(i, j + 1, 2)) % mod\n        else:\n            dp[i][j][color] = (paint(i - 1, j, 0) + paint(i + 1, j, 0) + paint(i, j - 1, 0) + paint(i, j + 1, 0)) % mod\n\n        return dp[i][j][color]\n\n    dp = [[[-1] * 3 for _ in range(N)] for _ in range(N)]\n    result = paint(0, 0, 0) + paint(0, 0, 1) + paint(0, 0, 2)\n    return str(result % mod)"
    },
    {
        "number": 3937,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    def generate_g(n: int, m: int) -> list:\n        g = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                g[i][j] = gcd(i + 1, j + 1)\n        return g\n\n    def find_sequence(g: list, a: list) -> bool:\n        for i in range(n):\n            for j in range(m - k + 1):\n                if all(g[i][j + l] == a[l] for l in range(k)):\n                    return True\n        return False\n\n    g = generate_g(n, m)\n    if find_sequence(g, a):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3938,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def min_cost(x1, y1, x2, y2):\n        return min(x2 - x1 + 1, y2 - y1 + 1)\n\n    n, m = map(int, stdin.readline().split())\n    black_rectangles = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    min_cost_total = 0\n    for x1, y1, x2, y2 in black_rectangles:\n        min_cost_total += min_cost(x1, y1, x2, y2)\n\n    return str(min_cost_total)\n"
    },
    {
        "number": 3939,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_median(arr):\n        n = len(arr)\n        if n % 2 == 0:\n            return (sorted(arr)[n // 2 - 1] + sorted(arr)[n // 2]) // 2\n        else:\n            return sorted(arr)[n // 2]\n\n    def is_possible(n, k, arr):\n        if k < min(arr) or k > max(arr):\n            return False\n        for i in range(n):\n            if arr[i] != k:\n                break\n        else:\n            return True\n\n        for i in range(n):\n            for j in range(i, n):\n                if find_median(arr[i:j + 1]) == k:\n                    return True\n        return False\n\n    t = int(stdin.readline())\n    result = []\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        if is_possible(n, k, a):\n            result.append(\"yes\")\n        else:\n            result.append(\"no\")\n    return \"\\n\".join(result)"
    },
    {
        "number": 3940,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mex(arr):\n        mex_val = 0\n        while mex_val in arr:\n            mex_val += 1\n        return mex_val\n\n    def find_max_mex(n, m, subarrays):\n        a = [0] * n\n        max_mex = 0\n\n        for l, r in subarrays:\n            subarray = a[l - 1:r]\n            mex_val = mex(subarray)\n            max_mex = max(max_mex, mex_val)\n            a[l - 1:r] = [mex_val] * (r - l + 1)\n\n        return max_mex, a\n\n    input_data = list(map(int, stdin.split()))\n    n, m = input_data[0], input_data[1]\n    subarrays = [tuple(map(int, input_data[i + 1].split())) for i in range(m)]\n\n    max_mex, a = find_max_mex(n, m, subarrays)\n\n    return f\"{max_mex}\\n{' '.join(map(str, a))}\""
    },
    {
        "number": 3941,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    rooms = list(map(int, stdin.readline().split()))\n    switches = []\n\n    for _ in range(m):\n        x, *rooms_numbers = map(int, stdin.readline().split())\n        switches.append((x, rooms_numbers))\n\n    def toggle_switch(switch_index: int) -> None:\n        x, rooms_numbers = switches[switch_index]\n        for room_number in rooms_numbers:\n            rooms[room_number - 1] ^= 1\n\n    def can_unlock_all_doors() -> bool:\n        initial_state = sum(rooms)\n        for i in range(2 ** m):\n            binary = format(i, '0{}b'.format(m))\n            for j in range(m):\n                if binary[j] == '1':\n                    toggle_switch(j)\n            if sum(rooms) == n:\n                return True\n            for j in range(m):\n                if binary[j] == '1':\n                    toggle_switch(j)\n        return False\n\n    if can_unlock_all_doors():\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3942,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if s.count('#') == 0:\n        return \"-1\"\n\n    def is_beautiful(s: str, replace_index: int, replace_count: int) -> bool:\n        left_count = 0\n        right_count = 0\n        for i in range(len(s)):\n            if i == replace_index:\n                right_count += replace_count\n            else:\n                if s[i] == '(':\n                    left_count += 1\n                elif s[i] == ')':\n                    right_count += 1\n\n            if left_count < right_count:\n                return False\n\n        return left_count == right_count\n\n    result = []\n    for i in range(len(s)):\n        if s[i] == '#':\n            replace_count = 0\n            while not is_beautiful(s, i, replace_count):\n                replace_count += 1\n\n            if replace_count > 0:\n                result.append(str(replace_count))\n            else:\n                return \"-1\"\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3943,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_score = float('-inf')\n    max_deck = ''\n\n    for i in range(a + 1):\n        for j in range(b + 1):\n            if i + j == a + b:\n                deck = ['o'] * i + ['x'] * j\n                score = calculate_score(deck)\n                if score > max_score:\n                    max_score = score\n                    max_deck = ''.join(deck)\n\n    return f\"{max_score}\\n{max_deck}\"\n\ndef"
    },
    {
        "number": 3944,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def count_patterns(n, m, k):\n        if n == 0 and m == 0 and k == 0:\n            return 1\n        if n < 0 or m < 0 or k < 0:\n            return 0\n        return (count_patterns(n - 1, m, k) + count_patterns(n, m - 1, k) +\n                count_patterns(n, m, k - 1)) % mod\n\n    total_patterns = count_patterns(N, M, K)\n    alice_wins = (count_patterns(N - 1, M, K) +\n                    count_patterns(N, M - 1, K) +\n                    count_patterns(N, M, K - 1)) % mod\n    bob_wins = (count_patterns(N - 1, M - 1, K) +\n                  count_patterns(N - 1, M, K - 1) +\n                  count_patterns(N, M - 1, K - 1)) % mod\n    charlie_wins = (count_patterns(N - 1, M - 1, K - 1)) % mod\n\n    alice_win_patterns = (alice_wins - bob_wins - charlie_wins) % mod\n\n    return str(alice_win_patterns)"
    },
    {
        "number": 3945,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_x(heights: List[int]) -> int:\n        heights.sort()\n        min_x = 1\n        for i in range(len(heights)):\n            if heights[i] > min_x:\n                heights[i] = min_x\n            else:\n                min_x += 1\n        return min_x\n\n    n, m = map(int, stdin.readline().split())\n    matrix = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    result = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(find_min_x([matrix[i][j]] + [matrix[k][j] for k in range(n) if k != i] + [matrix[i][l] for l in range(m) if l != j]))\n        result.append(row)\n\n    return '\\n'.join([' '.join(map(str, row)) for row in result])"
    },
    {
        "number": 3946,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    w = list(map(int, stdin.readline().split()))\n\n    for i in range(n):\n        if a[i] == 0:\n            w[i] = -w[i]\n\n    for _ in range(m):\n        total_weight = sum(w)\n        for i in range(n):\n            p = total_weight - w[i] + 1\n            q = w[i]\n            gcd_value = gcd(p, q)\n            p //= gcd_value\n            q //= gcd_value\n            r = pow(q, -1, p)\n            w[i] = (r * p * q) % 998244353\n\n    return \" \".join(map(str, w))\n\ndef"
    },
    {
        "number": 3947,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    arr.sort()\n\n    points = 0\n    for i in range(n - 1):\n        points += min(arr[i], arr[i + 1])\n\n    return str(points)"
    },
    {
        "number": 3948,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, parent):\n        children = 0\n        for child in graph[node]:\n            if child != parent:\n                children += 1\n                dfs(child, node)\n        if node != 1 and children != 1:\n            return False\n        return True\n\n    def is_hedgehog(node, parent):\n        degree = len(graph[node])\n        if degree < 3:\n            return False\n        for child in graph[node]:\n            if child != parent:\n                if not is_hedgehog(child, node):\n                    return False\n        return True\n\n    if not is_hedgehog(1, -1):\n        return \"No\"\n\n    for _ in range(k - 1):\n        new_graph = [[] for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in graph[i]:\n                if i != j:\n                    new_graph[i].append(j)\n        for i in range(1, n + 1):\n            if len(new_graph[i]) == 1:\n                u = i\n                v = new_graph[i][0]\n                new_graph[u].remove(v)\n                new_graph[v].remove(u)\n                new_graph[u].append(n + 1)\n                new_graph[n + 1] = [u, v]\n                n += 1\n        graph = new_graph\n\n    if not dfs(1, -1):\n        return \"No\"\n    return \"Yes\""
    },
    {
        "number": 3949,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(n, m, grid, north_magnets):\n        for i in range(n):\n            if not any(grid[j][i] == \".\" for j in range(m)):\n                return False\n        for j in range(m):\n            if not any(grid[i][j] == \".\" for i in range(n)):\n                return False\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == \".\":\n                    if not any(grid[k][j] == \"#\" for k in range(n) if k != i):\n                        return False\n                    if not any(grid[i][k] == \"#\" for k in range(m) if k != j):\n                        return False\n        return True\n\n    def dfs(n, m, grid, north_magnets, start_i, start_j):\n        for i in range(n):\n            for j in range(m):\n                if i != start_i or j != start_j:\n                    if grid[i][j] == \"#\" and (i == start_i or j == start_j):\n                        if i != start_i:\n                            if start_i < i:\n                                north_magnets[start_i][start_j] = 1\n                                north_magnets[i][j] = 0\n                            else:\n                                north_magnets[i][j] = 1\n                                north_magnets[start_i][start_j] = 0\n                        else:\n                            if start_j < j:\n                                north_magnets[start_i][start_j] = 1\n                                north_magnets[i][j] = 0\n                            else:\n                                north_magnets[i][j] = 1\n                                north_magnets[start_i][start_j] = 0\n                        if is_valid(n, m, grid, north_magnets):\n                            return True\n                        north_magnets[i][j] = north_magnets[start_i][start_j] = 0\n        return False\n\n    n, m = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(n)]\n\n    north_magnets = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \".\":\n                north_magnets[i][j] = 1\n                if dfs(n, m, grid, north_magnets, i, j):\n                    return str(sum(sum(row) for row in north_magnets))\n                north_magnets[i][j] = 0\n    return \"-1\""
    },
    {
        "number": 3950,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(a: List[int], n: int, q: int) -> bool:\n        for i in range(1, n + 1):\n            if a[i - 1] == 0:\n                continue\n            if a[i - 1] > q:\n                return False\n            if i == 1:\n                if a[i] != 1:\n                    return False\n            else:\n                if a[i - 2] == 0:\n                    if a[i - 1] != 1:\n                        return False\n                else:\n                    if a[i - 1] <= a[i - 2]:\n                        return False\n        return True\n\n    def restore(a: List[int], n: int, q: int) -> List[int]:\n        for i in range(1, n + 1):\n            if a[i - 1] == 0:\n                if i == 1:\n                    a[i - 1] = 1\n                else:\n                    a[i - 1] = a[i - 2] + 1\n        return a\n\n    lines = stdin.split('\\n')\n    n, q = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n\n    if is_valid(a, n, q):\n        return 'YES\\n' + ' '.join(map(str, restore(a, n, q)))\n    else:\n        return 'NO'"
    },
    {
        "number": 3951,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    gcd_table = list(map(int, stdin.readline().strip().split()))\n\n    a = []\n    for i in range(n):\n        a.append(gcd_table[i])\n\n    for i in range(n):\n        for j in range(n):\n            if gcd_table[i * n + j] != a[i] and gcd_table[i * n + j] != a[j]:\n                a[i], a[j] = a[j], a[i]\n\n    return \" \".join(map(str, a))"
    },
    {
        "number": 3952,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_points(points, l, r, a):\n        count = 0\n        for x, y in points:\n            if l < x < r and y > a:\n                count += 1\n        return count\n\n    def find_sets(points, l, r, a):\n        sets = []\n        for i in range(1, len(points) + 1):\n            for subset in itertools.combinations(points, i):\n                if len(subset) == i and all(count_points(subset, l, r, a_) == i for a_ in range(1, a + 1)):\n                    sets.append(set(subset))\n        return sets\n\n    def process_case(stdin: str) -> str:\n        n = int(stdin.readline())\n        points = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n        l, r, a = map(int, stdin.readline().split())\n\n        sets = find_sets(points, l, r, a)\n        return str(len(sets))\n\n    return process_case(stdin) "
    },
    {
        "number": 3953,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    evil_cells = []\n    for i in range(n):\n        row = stdin.readline().strip()\n        for j in range(n):\n            if row[j] == 'E':\n                evil_cells.append((i, j))\n\n    if not evil_cells:\n        return \"-1\"\n\n    def is_valid(x: int, y: int) -> bool:\n        for i, j in evil_cells:\n            if i == x or j == y:\n                return False\n        return True\n\n    def find_nearest_valid_cell(x: int, y: int) -> tuple:\n        min_distance = float('inf')\n        nearest_cell = None\n        for i in range(n):\n            for j in range(n):\n                if is_valid(i, j):\n                    distance = abs(x - i) + abs(y - j)\n                    if distance < min_distance:\n                        min_distance = distance\n                        nearest_cell = (i, j)\n        return nearest_cell\n\n    result = []\n    while evil_cells:\n        nearest_valid_cell = find_nearest_valid_cell(*evil_cells[0])\n        if not nearest_valid_cell:\n            return \"-1\"\n        result.append(nearest_valid_cell)\n        evil_cells = [(i, j) for i, j in evil_cells if i != nearest_valid_cell[0] and j != nearest_valid_cell[1]]\n\n    return \"\\n\".join(f\"{i + 1} {j + 1}\" for i, j in result)"
    },
    {
        "number": 3954,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def max_sum(a: list) -> int:\n        return sum(a)\n\n    def swap(a: list, i: int, j: int) -> None:\n        a[i], a[j] = a[j], a[i]\n\n    def max_m(a: list, k: int) -> int:\n        a.sort()\n        max_sum = max_sum(a)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if a[i] + a[j] > max_sum:\n                    if k > 0:\n                        swap(a, i, j)\n                        k -= 1\n                    else:\n                        continue\n                    max_sum = max(max_sum, a[i] + a[j], a[i] + a[n - 1] + a[j], a[i] + a[j] + a[n - 1])\n        return max_sum\n\n    return str(max_m(a, k))"
    },
    {
        "number": 3955,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    a.sort(reverse=True)\n\n    for i in range(k):\n        a[i] *= x\n\n    return str(sum(a) - (len(a) - 1))"
    },
    {
        "number": 3956,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    K, N = map(int, lines[0].split())\n\n    mod = 998244353\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod\n\n    result = []\n    for i in range(2, 2 * K + 1):\n        total = 0\n        for j in range(1, K + 1):\n            if i - j >= 0 and i - j <= K:\n                total += dp[N][j] * dp[N - 1][i - j]\n                total %= mod\n        result.append(total)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3957,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    universities = list(map(int, stdin.readline().split()))\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(n - 1)]\n\n    def find_min_length_road(town1, town2, visited_towns, roads):\n        if town1 == town2:\n            return 0\n        min_length = float('inf')\n        for road in roads:\n            if road[0] == town1 and road[1] not in visited_towns:\n                visited_towns.add(road[1])\n                min_length = min(min_length, find_min_length_road(road[1], town2, visited_towns, roads) + 1)\n                visited_towns.remove(road[1])\n            elif road[1] == town1 and road[0] not in visited_towns:\n                visited_towns.add(road[0])\n                min_length = min(min_length, find_min_length_road(road[0], town2, visited_towns, roads) + 1)\n                visited_towns.remove(road[0])\n        return min_length\n\n    total_distance = 0\n    for i in range(0, len(universities), 2):\n        total_distance += find_min_length_road(universities[i], universities[i + 1], set(), roads)\n\n    return str(total_distance)"
    },
    {
        "number": 3958,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_zebra(subseq: str) -> bool:\n        return subseq[0] == '0' and subseq[-1] == '0' and all(subseq[i] != subseq[i + 1] for i in range(len(subseq) - 1))\n\n    def find_zebras(s: str) -> List[List[int]]:\n        zebras = []\n        for length in range(1, len(s) + 1):\n            for start in range(len(s) - length + 1):\n                subseq = s[start:start + length]\n                if is_zebra(subseq):\n                    zebras.append([start + 1 + i for i in range(length)])\n        return zebras\n\n    zebras = find_zebras(stdin)\n\n    if not zebras:\n        return \"-1\"\n\n    output = [str(len(zebras))]\n    for zebra in zebras:\n        output.append(\" \".join(map(str, [len(zebra)] + zebra)))\n\n    return \"\\n\".join(output)"
    },
    {
        "number": 3959,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def factorial(n):\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n\n    def count_permutations(n, m):\n        return factorial(n) // factorial(n - m)\n\n    n, m = map(int, stdin.readline().split())\n    gyms = []\n    for _ in range(n):\n        gym_size, *pokemons = map(int, stdin.readline().split())\n        gyms.append(pokemons)\n\n    total_permutations = 1\n    for gym in gyms:\n        gym_types = [0] * m\n        for pokemon in gym:\n            gym_types[pokemon - 1] += 1\n\n        for count in gym_types:\n            total_permutations *= count_permutations(count, 1)\n\n    modulo = 10**9 + 7\n    return str(total_permutations % modulo)"
    },
    {
        "number": 3960,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_f = float('-inf')\n\n    for l in range(1, n):\n        for r in range(l + 1, n + 1):\n            f = 0\n            for i in range(l, r - 1):\n                f += abs(a[i] - a[i + 1]) * (-1) ** (i - l)\n            max_f = max(max_f, f)\n\n    return str(max_f)"
    },
    {
        "number": 3961,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p_i = map(int, stdin.split())\n    mod = 10**9 + 7\n    crosses = 1\n    moves = 0\n\n    for i in range(1, n + 1):\n        if crosses % 2 == 0:\n            moves += 1\n            crosses = 1\n        else:\n            moves += 2\n            crosses = 2\n\n        crosses = (crosses * 2) % mod\n\n    return str(moves)"
    },
    {
        "number": 3962,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    guests = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    total_chairs = 0\n    circles = []\n\n    while guests:\n        circle = []\n        circle_chairs = 0\n        for i, guest in enumerate(guests):\n            if guest[0] <= circle_chairs and guest[1] <= circle_chairs:\n                circle.append(guest)\n                circle_chairs += guest[0] + guest[1] + 1\n        total_chairs += circle_chairs\n        circles.append(circle)\n        for guest in circle:\n            guests.remove(guest)\n\n    return str(total_chairs)"
    },
    {
        "number": 3963,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, m = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    @lru_cache(maxsize=None)\n    def count_ways(amount, index):\n        if amount == 0:\n            return 1\n        if amount < 0 or index == n:\n            return 0\n        count = 0\n        for i in range(b[index]):\n            count += count_ways(amount - i * (index + 1), index + 1)\n            count %= mod\n        return count\n\n    return str(count_ways(m, 0))"
    },
    {
        "number": 3964,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, b, mod = map(int, stdin.split())\n    a = list(map(int, input().split()))\n    dp = [[0] * (b + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(b + 1):\n            for k in range(a[i] + 1):\n                if j - k >= 0:\n                    dp[i + 1][j] += dp[i][j - k]\n\n    ans = 0\n    for i in range(m + 1):\n        if i > 0:\n            for j in range(b + 1):\n                if j - a[i - 1] >= 0:\n                    dp[i][j] += dp[i - 1][j - a[i - 1]]\n        if i == m:\n            ans += dp[i][b]\n\n    return str(ans % mod)"
    },
    {
        "number": 3965,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_vowel(c: str) -> bool:\n        return c in 'aeiouy'\n\n    def count_syllables(word: str) -> int:\n        count = 0\n        for i in range(len(word)):\n            if is_vowel(word[i]):\n                count += 1\n                while i + 1 < len(word) and not is_vowel(word[i + 1]):\n                    i += 1\n        return count\n\n    n, *p = map(int, stdin.split())\n    text = [line.split() for line in stdin.split('\\n')][1:]\n\n    for i in range(n):\n        total_syllables = sum(count_syllables(word) for word in text[i])\n        if total_syllables != p[i]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3966,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split()))\n    score = sum(a)\n    while len(a) > 1:\n        a.sort()\n        i = 0\n        while i < len(a) - 1:\n            if a[i] == a[i + 1]:\n                score += a[i]\n                i += 2\n            else:\n                i += 1\n        a = a[::2]\n    return str(score)"
    },
    {
        "number": 3967,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, input().split()))\n\n    a.sort()\n    d = 0\n    total_length = 0\n\n    for i in range(n):\n        d += a[i]\n        total_length += a[i]\n        if d > k:\n            break\n\n    return d"
    },
    {
        "number": 3968,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_infected(person: int, infected_people: set, room_state: list) -> bool:\n        for i in range(len(room_state)):\n            if room_state[i] == person and i in infected_people:\n                return True\n        return False\n\n    def update_room_state(room_state: list, person: int, s: int, t: int) -> list:\n        for i in range(s, t + 1):\n            room_state[i] = person\n        return room_state\n\n    def simulate(N: int, D: int, C: int, infected_people: set, room_state: list) -> set:\n        for _ in range(D):\n            new_infected_people = set()\n            for i in range(N):\n                if is_infected(i + 1, infected_people, room_state):\n                    new_infected_people.add(i + 1)\n            infected_people.update(new_infected_people)\n            room_state = [0] * 1000001\n            for i in range(N):\n                s, t = times[i]\n                room_state = update_room_state(room_state, i + 1, s, t)\n        return infected_people\n\n    lines = stdin.split('\\n')\n    N, D = map(int, lines[0].split())\n    C = int(lines[1])\n    infected_people = set(map(int, lines[1].split()[1:]))\n    times = [list(map(int, lines[i + 2].split())) for i in range(N)]\n\n    room_state = [0] * 1000001\n    for i in range(N):\n        s, t = times[i]\n        room_state = update_room_state(room_state, i + 1, s, t)\n\n    infected_people = simulate(N, D, C, infected_people, room_state)\n    return ' '.join(map(str, sorted(infected_people)))"
    },
    {
        "number": 3969,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    species = [0] * (m + 1)\n    positions = [0] * n\n    for i in range(n):\n        s, x = map(float, stdin.readline().split())\n        species[int(s)] += 1\n        positions[i] = x\n\n    borders = [0] * (m - 1)\n    for i in range(m - 1):\n        borders[i] = sum(species[:i + 1])\n\n    replants = 0\n    for i in range(n):\n        if i < borders[positions[i] - 1]:\n            replants += 1\n\n    return str(replants)"
    },
    {
        "number": 3970,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n    arr.sort()\n\n    max_size = 0\n    current_size = 0\n\n    for i in range(n):\n        if arr[i] * k > arr[-1]:\n            break\n        j = i + 1\n        while j < n and arr[j] < arr[i] * k:\n            j += 1\n        current_size = j - i\n        max_size = max(max_size, current_size)\n\n    return str(max_size)"
    },
    {
        "number": 3971,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    points = 0\n    while a:\n        a.sort()\n        k = a[0]\n        points += k\n        a = [x for x in a if x != k and x != k - 1 and x != k + 1]\n\n    return str(points)"
    },
    {
        "number": 3972,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[1] = 2\n\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * 2) % MOD\n\n    return str(dp[n])\n"
    },
    {
        "number": 3973,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n\n    def count_presses(x: int) -> int:\n        presses = 0\n        for i in range(n - 1):\n            if a[i] < x:\n                presses += x - a[i]\n                a[i + 1] = 1\n            elif a[i] > x:\n                presses += a[i] - x\n                a[i + 1] = m\n        return presses\n\n    min_presses = float('inf')\n    for x in range(1, m + 1):\n        presses = count_presses(x)\n        if presses < min_presses:\n            min_presses = presses\n\n    return str(min_presses)"
    },
    {
        "number": 3974,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string into a list of characters\n    events = list(stdin)\n\n    # Initialize variables to keep track of the number of people in the club\n    # and the maximum number of people seen at the same time\n    num_people = 0\n    max_people = 0\n\n    # Iterate through the list of events\n    for event in events:\n        # If a person entered the club, increment the number of people\n        if event == \"+\":\n            num_people += 1\n        # If a person left the club, decrement the number of people\n        else:\n            num_people -= 1\n        # Update the maximum number of people seen at the same time\n        max_people = max(max_people, num_people)\n\n    # Return the minimum number of distinct people seen\n    return str(max_people)"
    },
    {
        "number": 3975,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    graph = [[] for _ in range(n + 1)]\n    inputs = []\n\n    for i in range(1, n + 1):\n        line = stdin.readline().split()\n        if line[0] == \"IN\":\n            inputs.append((i, int(line[1])))\n        else:\n            for j in range(1, len(line)):\n                graph[i].append(int(line[j]))\n\n    output = []\n    for i, value in inputs:\n        output.append(dfs(graph, i, value))\n\n    return \"\".join(map(str, output))\n\ndef"
    },
    {
        "number": 3976,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[0:3])\n    a = list(map(int, stdin.split()[3:3 + n]))\n    b = list(map(int, stdin.split()[3 + n:]))\n\n    valid_qs = []\n\n    for q in range(1, n - m * p + 1):\n        if a[q:q + m * p:p] == b:\n            valid_qs.append(q)\n\n    return f\"{len(valid_qs)}\\n{' '.join(map(str, valid_qs))}\""
    },
    {
        "number": 3977,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    governments = list(map(int, stdin.readline().split()))\n    edges = [list(map(int, stdin.readline().split())) for _ in range(m)]\n\n    # Check if the graph is already stable\n    for i in range(k):\n        for j in range(i + 1, k):\n            if governments[i] in edges and governments[j] in edges[edges.index(governments[i])]:\n                return \"0\"\n\n    # Calculate the maximum number of edges Hongcow can add\n    max_edges = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if i not in governments and j not in governments:\n                max_edges += 1\n\n    return str(max_edges)"
    },
    {
        "number": 3978,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def lcm(x, y):\n        return (x * y) // gcd(x, y)\n\n    colors = set()\n    for i in range(n):\n        colors.add(a[i])\n        for j in range(i + 1, n):\n            colors.add(lcm(a[i], a[j]))\n\n    return str(len(colors))"
    },
    {
        "number": 3979,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_lexicographically_greater(word1, word2):\n        for i in range(min(len(word1), len(word2))):\n            if word1[i] < word2[i]:\n                return True\n            elif word1[i] > word2[i]:\n                return False\n        return len(word1) > len(word2)\n\n    def find_capitalization(words, n, m):\n        for letter in range(1, m + 1):\n            capitalized_words = [word.replace(str(letter), str(letter) + \"'\") for word in words]\n            if all(not is_lexicographically_greater(word1, word2) for word1, word2 in zip(capitalized_words, capitalized_words[1:])):\n                return letter\n        return None\n\n    n, m = map(int, stdin.readline().split())\n    words = [stdin.readline().strip() for _ in range(n)]\n\n    capitalization = find_capitalization(words, n, m)\n\n    if capitalization is not None:\n        return \"Yes\\n1\\n{}\\n\".format(capitalization)\n    else:\n        return \"No\""
    },
    {
        "number": 3980,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    max_beauty = 0\n    max_permutation = []\n\n    for i in range(1, n + 1):\n        max_beauty += i ^ i\n\n    max_beauty += (n + 1) ^ (n + 1)\n    max_permutation = list(range(n + 1))\n\n    return f\"{max_beauty}\\n{max_permutation}\"\n"
    },
    {
        "number": 3981,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(n: int, m: int, engine1: List[Tuple[int, int]], engine2: List[Tuple[int, int]]) -> bool:\n        def generate_power_field(engine: List[Tuple[int, int]]) -> Set[Tuple[int, int]]:\n            power_field = set(engine)\n            while True:\n                new_power_field = set()\n                for i in range(len(power_field)):\n                    for j in range(i + 1, len(power_field)):\n                        x1, y1 = power_field[i]\n                        x2, y2 = power_field[j]\n                        new_power_field.add((x1 + x2, y1 + y2))\n                if not new_power_field.issubset(power_field):\n                    power_field.update(new_power_field)\n                else:\n                    break\n            return power_field\n\n        def rotate(engine: List[Tuple[int, int]], theta: float) -> List[Tuple[int, int]]:\n            return [(int(x * cos(theta) - y * sin(theta)), int(x * sin(theta) + y * cos(theta))) for x, y in engine]\n\n        def shift(engine: List[Tuple[int, int]], a: float, b: float) -> List[Tuple[int, int]]:\n            return [(x + a, y + b) for x, y in engine]\n\n        power_field1 = generate_power_field(engine1)\n        power_field2 = generate_power_field(engine2)\n\n        for a in range(-1000, 1001, 1):\n            for b in range(-1000, 1001, 1):\n                manipulated_engine1 = shift(engine1, a, b)\n                manipulated_engine2 = engine2.copy()\n\n                for theta in range(0, 361, 15):\n                    manipulated_engine1 = rotate(manipulated_engine1, radians(theta))\n                    manipulated_engine2 = rotate(manipulated_engine2, radians(theta))\n\n                manipulated_power_field1 = generate_power_field(manipulated_engine1)\n                manipulated_power_field2 = generate_power_field(manipulated_engine2)\n\n                for x, y in power_field1:\n                    if (x, y) not in manipulated_power_field1:\n                        return False\n\n                for x, y in power_field2:\n                    if (x, y) not in manipulated_power_field2:\n                        return False\n\n        return True\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    engine1 = [tuple(map(int, line.split())) for line in lines[1:n + 1]]\n    engine2 = [tuple(map(int, line.split())) for line in lines[n + 1:n + m + 1]]\n\n    if is_safe(n, m, engine1, engine2):\n        return 'YES'\n    else:\n        return 'NO'"
    },
    {
        "number": 3982,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.readline())\n    morse_code = {\n        \"0\": \"10\",\n        \"1\": \"110\"\n    }\n    morse_code_lengths = [1, 2, 3, 4]\n    modulo = 10**9 + 7\n\n    def count_sequences(s: str) -> int:\n        if s in [\"0011\", \"0101\", \"1110\", \"1111\"]:\n            return 0\n        return sum(\n            (26 * (26 ** (length - 1)) for length in morse_code_lengths if len(s) >= length and s[:length] in morse_code)\n        )\n\n    S = \"\"\n    result = []\n    for _ in range(m):\n        S += stdin.readline().strip()\n        result.append(count_sequences(S) % modulo)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3983,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_graph(N: int, M: int, edges: List[Tuple[int, int]]) -> bool:\n        if edges[0][0] == 1 and edges[0][1] == N:\n            return False\n        for i in range(M):\n            for j in range(i + 1, M):\n                if edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1]:\n                    return False\n        return True\n\n    def taro_wins(N: int, M: int, edges: List[Tuple[int, int]]) -> bool:\n        if not is_good_graph(N, M, edges):\n            return False\n        for i in range(M):\n            for j in range(i + 1, M):\n                new_edges = edges.copy()\n                new_edges.append((edges[i][0], edges[j][1]))\n                new_edges.append((edges[j][0], edges[i][1]))\n                if not is_good_graph(N, M + 1, new_edges):\n                    return True\n        return False\n\n    T = int(stdin.readline().strip())\n    results = []\n    for _ in range(T):\n        N, M = map(int, stdin.readline().strip().split())\n        edges = []\n        for _ in range(M):\n            u, v = map(int, stdin.readline().strip().split())\n            edges.append((u, v))\n        if taro_wins(N, M, edges):\n            results.append(\"First\")\n        else:\n            results.append(\"Second\")\n    return \"\\n\".join(results)"
    },
    {
        "number": 3984,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    result = []\n\n    for k in range(n):\n        if s[k] == 'a':\n            result.append(\"Mike\")\n        else:\n            result.append(\"Ann\")\n\n    return result"
    },
    {
        "number": 3985,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    good_pairs = []\n    for _ in range(m):\n        i, j = map(int, stdin.readline().split())\n        if (i + j) % 2 == 1 and i < j:\n            good_pairs.append((i, j))\n\n    max_operations = 0\n    for i, j in good_pairs:\n        v = a[i]\n        if a[j] % v == 0:\n            max_operations += 1\n        v = a[j]\n        if a[i] % v == 0:\n            max_operations += 1\n\n    return str(max_operations)"
    },
    {
        "number": 3986,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return \"-1\"\n    if k == n:\n        return \"a\" * n\n    if k == 1:\n        return \"a\" * (n - 1) + \"b\"\n    return \"a\" * (n - k) + \"b\" * k"
    },
    {
        "number": 3987,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def longest_non_decreasing_subsequence(arr):\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i, n):\n            temp = a.copy()\n            temp[i:j + 1] = reversed(temp[i:j + 1])\n            max_length = max(max_length, longest_non_decreasing_subsequence(temp))\n\n    return str(max_length)"
    },
    {
        "number": 3988,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, vertex):\n        visited.add(vertex)\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                dfs(graph, visited, neighbor)\n\n    def transitive_closure(graph, n):\n        reachable = [[False] * n for _ in range(n)]\n        for i in range(n):\n            visited = set()\n            dfs(graph, visited, i)\n            for vertex in visited:\n                reachable[i][vertex] = True\n        return reachable\n\n    def count_vertices(graph, reachable, s):\n        visited = set()\n        dfs(graph, visited, s)\n        return len(visited)\n\n    def find_plan(graph, reachable, s):\n        max_vertices = count_vertices(graph, reachable, s)\n        min_vertices = n - max_vertices + 1\n        max_plan = [\"+\"] * m\n        min_plan = [\"-\"] * m\n\n        for i in range(m):\n            if t[i] == 2:\n                u, v = uv[i]\n                if reachable[u][v] and reachable[v][u]:\n                    if count_vertices(graph, reachable, s) > max_vertices:\n                        max_plan[i] = \"+\"\n                    else:\n                        max_plan[i] = \"-\"\n                elif reachable[u][v]:\n                    max_plan[i] = \"+\"\n                    min_plan[i] = \"-\"\n                else:\n                    max_plan[i] = \"-\"\n                    min_plan[i] = \"+\"\n\n        return max_vertices, max_plan, min_vertices, min_plan\n\n    lines = stdin.split(\"\\n\")\n    n, m, s = map(int, lines[0].split())\n    t, uv = [], []\n    for i in range(1, m + 1):\n        t_i, u_i, v_i = map(int, lines[i].split())\n        t.append(t_i)\n        uv.append((u_i, v_i))\n\n    directed_graph = [[] for _ in range(n)]\n    for i in range(m):\n        if t[i] == 1:\n            u, v = uv[i]\n            directed_graph[u].append(v)\n        else:\n            u, v = uv[i]\n            directed_graph[u].append(v)\n            directed_graph[v].append(u)\n\n    reachable = transitive_closure(directed_graph, n)\n    max_vertices, max_plan, min_vertices, min_plan = find_plan(directed_graph, reachable, s - 1)\n\n    output = f\"{max_vertices}\\n{''.join(max_plan)}\\n{min_vertices}\\n{''.join(min_plan)}\\n\"\n    return output"
    },
    {
        "number": 3989,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    digits = [int(d) for d in str(a)]\n    ones = digits.count(1)\n    sixes = digits.count(6)\n    eights = digits.count(8)\n    nines = digits.count(9)\n\n    if ones + sixes + eights + nines != len(digits):\n        return \"0\"\n\n    if ones % 2 != 0 or sixes % 2 != 0 or eights % 2 != 0 or nines % 2 != 0:\n        return \"0\"\n\n    result = []\n    for _ in range(ones):\n        result.append(1)\n    for _ in range(nines):\n        result.append(9)\n    for _ in range(eights):\n        result.append(8)\n    for _ in range(sixes):\n        result.append(6)\n\n    if len(result) > len(digits):\n        return \"0\"\n\n    if result == digits:\n        return \"0\"\n\n    while result and result[0] == 0:\n        result.pop(0)\n\n    return \"\".join(str(d) for d in result)"
    },
    {
        "number": 3990,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    railways = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    # Create a set of all the railway connections\n    railway_connections = set()\n    for u, v in railways:\n        railway_connections.add((u, v))\n        railway_connections.add((v, u))\n\n    # Initialize the bus and train routes\n    bus_route = [1]\n    train_route = [1]\n\n    # Initialize the arrival times\n    bus_arrival_time = 1\n    train_arrival_time = 1\n\n    # Initialize the current town\n    current_town = 1\n\n    while True:\n        # Check if the bus can travel to the next town\n        if (current_town, bus_route[-1]) in railway_connections:\n            bus_route.append(bus_route[-1])\n            bus_arrival_time += 1\n        else:\n            next_town = None\n            for town in range(1, n + 1):\n                if town != current_town and (current_town, town) not in railway_connections:\n                    next_town = town\n                    break\n            if next_town is None:\n                break\n            bus_route.append(next_town)\n            bus_arrival_time += 1\n\n        # Check if the train can travel to the next town\n        if (current_town, train_route[-1]) in railway_connections:\n            train_route.append(train_route[-1])\n            train_arrival_time += 1\n        else:\n            next_town = None\n            for town in range(1, n + 1):\n                if town != current_town and (current_town, town) in railway_connections:\n                    next_town = town\n                    break\n            if next_town is None:\n                break\n            train_route.append(next_town)\n            train_arrival_time += 1\n\n        # Update the current town\n        current_town = bus_route[-1]\n\n        # Check if both vehicles have reached town n\n        if current_town == n:\n            break\n\n    # Check if both vehicles have reached town n\n    if current_town != n:\n        return -1\n\n    # Return the minimum arrival time\n    return max(bus_arrival_time, train_arrival_time)"
    },
    {
        "number": 3991,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x = list(map(int, stdin.split('\\n')[1].split()))\n    x.sort()\n    mod = 10**9 + 7\n    total = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += (x[j] - x[i])\n\n    return str(total % mod)"
    },
    {
        "number": 3992,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n\n    if all(x == 0 for x in a):\n        return \"-1\"\n\n    lcm = a[0]\n    for i in range(1, n):\n        lcm = (a[i] * lcm) // math.gcd(a[i], lcm)\n\n    return str(sum(a) // lcm)"
    },
    {
        "number": 3993,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0].split())\n    p = list(map(int, stdin.split()[1].split()))\n    p.sort()\n\n    special_pages = []\n    for i in range(1, n + 1):\n        if i in p:\n            if not special_pages or special_pages[-1] < (i - 1) // k + 1:\n                special_pages.append((i - 1) // k + 1)\n\n    operations = 0\n    while special_pages:\n        page = special_pages.pop(0)\n        special_items_on_page = [i for i in p if (i - 1) // k + 1 == page]\n        p = [i for i in p if i not in special_items_on_page]\n        operations += 1\n\n    return str(operations)"
    },
    {
        "number": 3994,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    initial_states = stdin.readline().strip()\n    parameters = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    events = []\n    for i in range(n):\n        a, b = parameters[i]\n        events.append((b, a, i))\n\n    events.sort()\n\n    max_on_lights = 0\n    on_lights = 0\n    last_toggle = -1\n\n    for event in events:\n        time, period, index = event\n\n        if initial_states[index] == '1':\n            if time - last_toggle > period:\n                on_lights += 1\n            else:\n                on_lights -= 1\n\n            max_on_lights = max(max_on_lights, on_lights)\n            last_toggle = time\n\n    return str(max_on_lights)"
    },
    {
        "number": 3995,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = \"\"\n    if k == n:\n        s = \"1\" * n\n    elif k == 1:\n        s = \"10\" * (n // 2)\n        if n % 2 == 1:\n            s += \"1\"\n    else:\n        s = \"101\" * (n // 3)\n        if n % 3 == 1:\n            s += \"1\"\n        elif n % 3 == 2:\n            s += \"10\"\n    return s"
    },
    {
        "number": 3996,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a = map(int, stdin.split())\n    n = 1\n    for i in range(k):\n        n *= a[i]\n\n    p = 1\n    q = n\n    for i in range(1, n + 1):\n        p *= (i - 1)\n        q *= (n - i + 1)\n\n    p %= 10**9 + 7\n    q %= 10**9 + 7\n\n    return f\"{p} {q}\""
    },
    {
        "number": 3997,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input(stdin: str) -> tuple:\n        lines = stdin.splitlines()\n        n = int(lines[0])\n        a = list(map(int, lines[1].split()))\n        edges = [list(map(int, lines[i].split())) for i in range(2, n)]\n        return n, a, edges\n\n    def dfs(v: int, parent: int) -> tuple:\n        res = [0] * n\n        for u, w in tree[v]:\n            if u != parent:\n                subtree_res = dfs(u, v)\n                for i in range(n):\n                    res[i] += subtree_res[i]\n                res[u] += w\n        res[v] += a[v]\n        return res\n\n    n, a, edges = read_input(stdin)\n    tree = [[] for _ in range(n)]\n    for u, w in edges:\n        tree[u - 1].append((u, w))\n        tree[u].append((u - 1, w))\n\n    res = dfs(0, -1)\n    for i in range(n):\n        res[i] -= a[i]\n        if res[i] < 0:\n            res[i] = 0\n\n    return \" \".join(map(str, res))"
    },
    {
        "number": 3998,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_rating(ratings: list) -> int:\n        return max(ratings)\n\n    def find_min_rating(ratings: list) -> int:\n        return min(ratings)\n\n    def find_rating_difference(ratings: list) -> int:\n        return find_max_rating(ratings) - find_min_rating(ratings)\n\n    def find_optimal_matches(ratings: list) -> tuple:\n        max_rating = find_max_rating(ratings)\n        min_rating = find_min_rating(ratings)\n        rating_diff = find_rating_difference(ratings)\n\n        if rating_diff == 0:\n            return (max_rating, [])\n\n        matches = []\n        for i in range(2, 6):\n            for subset in itertools.combinations(ratings, i):\n                if find_rating_difference(list(subset)) == 0:\n                    matches.append(subset)\n\n        if not matches:\n            return (max_rating, [])\n\n        min_matches = min(matches, key=len)\n        return (max_rating, min_matches)\n\n    def create_match_schedule(ratings: list, match_members: list) -> list:\n        match_schedule = []\n        for _ in range(len(match_members)):\n            match_schedule.append([0] * len(ratings))\n\n        for i, member in enumerate(match_members):\n            match_schedule[i][member] = 1\n\n        return match_schedule\n\n    n, ratings = stdin.split('\\n')\n    n = int(n)\n    ratings = list(map(int, ratings.split()))\n\n    max_rating, optimal_match_members = find_optimal_matches(ratings)\n    match_schedule = create_match_schedule(ratings, optimal_match_members)\n\n    output = [str(max_rating)]\n    for match in match_schedule:\n        output.append(''.join(map(str, match)))\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3999,
        "checkpoint": "34B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(cube: List[List[int]]) -> bool:\n        for i in range(6):\n            for j in range(4):\n                if cube[i][j] != cube[(i + 1) % 6][j] and cube[i][j] != cube[(i - 1) % 6][j]:\n                    return False\n        return True\n\n    def rotate(tile: List[int]) -> List[int]:\n        return [tile[1], tile[2], tile[3], tile[0]]\n\n    def generate_tiles(colors: List[List[int]]) -> List[List[int]]:\n        tiles = []\n        for i in range(len(colors)):\n            for j in range(4):\n                tiles.append([colors[i][j]] + colors[i][1:] if j == 0 else [colors[i][j]] + colors[i][:j] + colors[i][j + 1:])\n        return tiles\n\n    def generate_cubes(tiles: List[List[int]]) -> Set[Tuple[int]]:\n        cubes = set()\n        for i in range(len(tiles)):\n            for j in range(4):\n                cube = [tiles[i][j]]\n                for k in range(1, 6):\n                    for l in range(4):\n                        if cube[-1] == tiles[k - 1][l]:\n                            cube.append(tiles[k - 1][(l + 1) % 4])\n                            break\n                if len(cube) == 6 and is_valid(cube):\n                    cubes.add(tuple(cube))\n        return cubes\n\n    N, colors = int(stdin.readline()), [list(map(int, stdin.readline().split())) for _ in range(N)]\n    tiles = generate_tiles(colors)\n    cubes = generate_cubes(tiles)\n    return len(cubes)"
    }
]