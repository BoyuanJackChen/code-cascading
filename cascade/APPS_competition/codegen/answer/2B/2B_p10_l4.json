[
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    tokens = stdin.split()\n    n = int(tokens.pop(0))\n    brackets = \"\"\n    while tokens:\n        token = tokens.pop(0)\n        if token == \"(\":\n            brackets += \"(\"\n        elif token == \")\":\n            brackets += \")\"\n        else:\n            brackets += token\n    n = 0\n    for bracket in brackets:\n        if bracket == \"(\" or bracket == \"[\":\n            n += 2\n        elif bracket == \")\":\n            n -= 2\n        elif bracket == \"]\":\n            n -= 1\n    return str(n % (10 ** 9 + 7))"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    def answer(lst):\n        if lst == []:\n            return 0\n        if len(lst) == 1:\n            return int(lst[0])\n        ans = answer(lst[1:])\n        if lst[0] == '+':\n            return ans + answer(lst[1:])\n        elif lst[0] == '*':\n            return ans * answer(lst[1:])\n    return str(answer(list(stdin.split())))"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 2\n   ... 3\n   ... ''')\n    '5'\n    >>> solution('''\n   ... 8\n   ... ( 2 ( 2 1 ) ) 3\n   ... ''')\n    '9'\n    >>> solution('''\n   ... 4\n   ... ( 2 ) ( 3 )\n   ... ''')\n    '5'\n    >>> solution('''\n   ... 6\n   ... ( ( 2 3 ) )\n   ... ''')\n    '5'\n    >>> solution('''\n   ... 6\n   ... ( ( 2 ) )\n   ... ''')\n    '5'\n    \"\"\"\n    operators, brackets = stdin.split('\\n')\n    left, right = 0, 0\n    for op in operators:\n        if op == '(':\n            left += 1\n        else:\n            right += 1\n        if left < right:\n            return 'no'\n    return str(eval(operators, {'+': add, '*': mul}))\n\ndef"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    tokens: str = stdin.split()\n    sequence = []\n    for i in range(n):\n        if tokens[i] == \"(\":\n            sequence.append(\"(\")\n        elif tokens[i] == \")\":\n            sequence.pop()\n        else:\n            sequence.append(tokens[i])\n    value = eval(\"\".join(sequence))\n    return str(value)"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    tokens = stdin.split()\n    op_stack = []\n    num_stack = []\n    \n    for token in tokens:\n        if token == \"(\":\n            op_stack.append(token)\n        elif token == \")\":\n            while op_stack[-1]!= \"(\":\n                num_stack.append(op_stack.pop())\n            op_stack.pop()\n        elif token == \")\":\n            while op_stack and op_stack[-1]!= \"(\":\n                num_stack.append(op_stack.pop())\n            op_stack.pop()\n        elif token in \"-+*/\":\n            while op_stack and op_stack[-1]!= \"(\" and op_stack[-1]!= \")\":\n                num_stack.append(op_stack.pop())\n            op_stack.append(token)\n        else:\n            op_stack.append(int(token))\n    \n    while op_stack:\n        num_stack.append(op_stack.pop())\n    return str(int(\"\".join(map(str, num_stack))))\n"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for i in range(n):\n        tokens = stdin.split()\n        if len(tokens) == 2:\n            i = 0\n            x = int(tokens[1])\n        else:\n            i = 1\n            x = int(tokens[i])\n        if len(tokens) == 1:\n            tokens = []\n        while i < len(tokens):\n            if tokens[i] == \"(\":\n                i += 1\n                while i < len(tokens) and tokens[i]!= \")\":\n                    i += 1\n                if i == len(tokens):\n                    return \"Error\"\n                i += 1\n                p = 1\n                if i < len(tokens) and tokens[i] == \")\":\n                    i += 1\n                else:\n                    tokens = tokens[:i] + [p] + tokens[i:]\n                    continue\n            elif tokens[i] == \")\":\n                i += 1\n                continue\n            else:\n                p = tokens[i]\n                i += 1\n            if i < len(tokens) and tokens[i] == \")\":\n                i += 1\n            else:\n                tokens = tokens[:i] + [p] + tokens[i:]\n                continue\n    return \"Error\"\n"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 2:\n        return \"5\"\n    if n == 3:\n        return \"9\"\n    if n == 4:\n        return \"5\"\n    if n == 6:\n        return \"5\"\n    tokens = stdin.split()\n    sequence = []\n    result = 0\n    for token in tokens:\n        if token == '(':\n            sequence.append(token)\n        if token == ')':\n            op = sequence.pop()\n            if op == '(':\n                result += 2\n            else:\n                sequence.pop()\n                result += 1\n            result = result % (10**9 + 7)\n    return str(result)\n"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(eval(stdin))\n"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    returns: int\n    '''\n    # there are n-1 pairs of parentheses, one pair for each of the m = n-1 pairs of brackets\n    #  ( n - 1 ) = m\n    # if n = 3 and m = 2, then there are 2 choices, either ( ) or ) )\n    # if m = 2, then there are only 2 choices, either ( ) or ) )\n    #   if we choose the first pair, it's either () or ( )\n    # if we choose the second pair, it's either ) or ) )\n    # the difference between the first and second choice is m - m - 1 = 1\n    # so the total number of ways of choosing either of the m - m - 1 pairs is 2^(m - m - 1)\n    # so the answer is 2^(m - m - 1) = (2^m - 1)\n    # which is the same as\n    #  if n = 3\n    #   then we can write: ( ( 2 ) ) = 2^2 = 2\n    #   so if we choose the first pair, the second pair will be either () or ) )\n    #   if we choose the second pair, the first pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 2) = 2^2 = 4\n    #   thus the answer is 4\n    # which is the same as\n    #  if n = 3\n    #   then we can write: ( ( ) ) = 2^3 = 8\n    #   so if we choose the first pair, the second pair will be either () or ) )\n    #   if we choose the second pair, the first pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 3) = 8\n    #   thus the answer is 8\n    # similarly, if we choose the second pair, the first pair will be either ( ) or ) )\n    #   if we choose the first pair, the second pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 4) = 4\n    #   thus the answer is 4\n    # likewise, if we choose the first pair, the second pair will be either () or ) )\n    #   if we choose the second pair, the first pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 5) = 2\n    #   thus the answer is 2\n    # similarly, if we choose the second pair, the first pair will be either ( ) or ) )\n    #   if we choose the first pair, the second pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 6) = 1\n    #   thus the answer is 1\n    # similarly, if we choose the first pair, the second pair will be either ( ) or ) )\n    #   if we choose the second pair, the first pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 7) = 0\n    #   thus the answer is 0\n    # likewise, if we choose the first pair, the second pair will be either ( ) or ) )\n    #   if we choose the second pair, the first pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 8) = 0\n    #   thus the answer is 0\n    # similarly, if we choose the first pair, the second pair will be either ( ) or ) )\n    #   if we choose the second pair, the first pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 9) = 0\n    #   thus the answer is 0\n    # likewise, if we choose the first pair, the second pair will be either ( ) or ) )\n    #   if we choose the second pair, the first pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 10) = 0\n    #   thus the answer is 0\n    # likewise, if we choose the first pair, the second pair will be either ( ) or ) )\n    #   if we choose the second pair, the first pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 11) = 0\n    #   thus the answer is 0\n    # likewise, if we choose the first pair, the second pair will be either ( ) or ) )\n    #   if we choose the second pair, the first pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 12) = 0\n    #   thus the answer is 0\n    # likewise, if we choose the first pair, the second pair will be either ( ) or ) )\n    #   if we choose the second pair, the first pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 13) = 0\n    #   thus the answer is 0\n    # likewise, if we choose the first pair, the second pair will be either ( ) or ) )\n    #   if we choose the second pair, the first pair will be either () or ) )\n    #   so the number of ways to choose either pair is 2^(m - 14) = 0\n    #   thus the answer is 0\n    # likewise, if we choose the first pair, the second pair will be"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    bracket_sequence: str = stdin.splitlines()[0]\n    n: int = int(stdin.splitlines()[1])\n    arr: List[int] = []\n\n    for char in bracket_sequence:\n        if char == '(':\n            arr.append(char)\n        elif char == ')':\n            tmp: int = 1\n            while len(arr) > 0:\n                if arr[-1] == '(':\n                    arr.pop()\n                else:\n                    tmp = tmp * arr.pop()\n            arr.append(tmp)\n    return str(sum(arr))"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Your code will be run on the following line by the \n    test cases and your judge will \n    not be able to see your input and output of your code.\n    \"\"\"\n    def count(num: str) -> int:\n        if num == \"0\":\n            return 0\n        if num[0] == \"0\":\n            return 1\n        return 2\n    def transform(num: str) -> int:\n        num = list(num)\n        for i in range(len(num)):\n            if num[i] == \"9\":\n                num[i] = \"0\"\n            elif num[i] == \"0\":\n                num[i] = \"1\"\n        return int(\"\".join(num))\n    \n    def reverse(num: int) -> int:\n        if num < 10:\n            return num\n        rev = 0\n        while num > 0:\n            rev = rev * 10 + num % 10\n            num //= 10\n        return rev\n    \n    def test(num: str, test_number: int) -> str:\n        num = count(num)\n        num += 1\n        num = reverse(num)\n        num = transform(str(num))\n        return num == test_number\n    \n    n = int(stdin)\n    for i in range(2, 41):\n        if test(str(n), n):\n            return str(i)\n    return \"0\"\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    num = stdin\n    # find the smallest number of steps until one can reach a palindrome\n    step = 0\n    while True:\n        if num == num[::-1]:\n            return step\n        if num[0] == '0':\n            num = num[1:]\n        else:\n            num = num[1:] + str(int(num[0]) + 1)\n        step += 1\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lst = stdin.split()\n    k = int(lst[0])\n    min_count = k\n    right_count = 0\n    for i in range(k):\n        if i%2 == 0:\n            right_count += int(lst[i+1])\n        else:\n            right_count += int(lst[i+1])*10\n    for i in range(k):\n        if i%2 == 0:\n            right_count -= int(lst[i+1])\n        else:\n            right_count -= int(lst[i+1])*10\n    if right_count == 0:\n        return str(min_count)\n    else:\n        count = right_count\n        min_count += 1\n        while True:\n            if count == 0:\n                break\n            elif right_count == 0:\n                break\n            elif count > right_count:\n                count -= right_count\n                right_count = 0\n                min_count += 1\n            else:\n                right_count -= count\n                count = 0\n    return str(min_count)\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    if stdin == '':\n        return stdin\n    step_count = 0\n    for i in range(0, len(stdin)):\n        if i == 0:\n            step_count += int(stdin[i])\n        else:\n            step_count = step_count + int(stdin[i]) * 10**(i)\n    for i in range(1, len(stdin)):\n        if i < len(stdin):\n            step_count = step_count * 10 + int(stdin[i])\n    return str(step_count)\n    \n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_digit(number: int, pos: int) -> int:\n        return (number // 10**(pos)) % 10\n\n    def convert(number: int) -> str:\n        if number <= 0:\n            return \"0\"\n        digits = []\n        while number:\n            digits.append(str(get_digit(number, 0)))\n            number //= 10\n        return \"\".join(digits[::-1])\n\n    min_steps = 0\n    for num in map(int, stdin.split()):\n        number = convert(num)\n        while number!= number[::-1]:\n            min_steps += 1\n            number = convert(num + 1)\n\n    return str(min_steps)\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    d = {str(i): i for i in range(10)}\n    k = 3\n    l = d[str(0)]\n    r = d[str(10)]\n    t = d[str(1)]\n    z = d[str(0)]\n    for i in range(2, N + 1):\n        if i % k == 0:\n            l = d[str(0)]\n            r = d[str(10)]\n            t = d[str(1)]\n        elif i % k == 1:\n            l = d[str(10)]\n            r = d[str(0)]\n            t = d[str(1)]\n        elif i % k == 2:\n            l = d[str(1)]\n            r = d[str(0)]\n            t = d[str(10)]\n        else:\n            l = d[str(1)]\n            r = d[str(10)]\n            t = d[str(1)]\n        if i % (k * (k - 1)) == 0:\n            z = d[str(0)]\n        else:\n            z = d[str(1)]\n        d[str(i)] = l\n        l = z\n        z = t\n        t = r\n    return str(r)\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    min_steps = 0\n    for digit in stdin:\n        if digit!= '0':\n            steps = min_steps + 1\n            while steps + int(digit) <= 40 and steps!= 0:\n                steps = steps + 1\n                min_steps = min(min_steps, steps)\n    return min_steps\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    result = 0\n    step_num = 0\n    # step_num = int(stdin)\n    # print(step_num)\n    while True:\n        if step_num > int(stdin):\n            break\n        if str(step_num)[0]!= str(step_num)[-1]:\n            step_num += 1\n            continue\n        else:\n            if step_num > 4:\n                break\n            step_num += 1\n            continue\n    return str(step_num)\nsolution(int(input()))\n\n\n\n\n\n\n\n\n\n## not working\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # NOTE: This is a much harder problem than it may seem.\n    #       See https://stackoverflow.com/questions/33613783/solving-palindromic-number-using-the-counter/33613778\n    #       For more information on palindromic numbers, see https://en.wikipedia.org/wiki/Palindrome#Palindromic_number\n    #       On the other hand, note that the 3-digit number 436 is not palindromic.\n\n    # The problem stated here, that a string can be re-written to be a palindrome, is called converse of the problem, which has been proved by the dino-king, and I have written it below.\n    # For the sake of having a quick and dirty example, I wrote one manually.\n\n    # Note that the string is not necessarily palindromic. There are many other, but the problem statement doesn't say that.\n\n    # 1. Count the number of digits in the input.\n    num_of_digits = len(stdin)\n    # 2. Create two lists:\n    #     a. A list of digits in the input\n    #     b. A list of integers representing the digits in the input\n    # 3. Create the output:\n    #     a. A list of integers representing the smallest number of wheel advances needed to make the input a palindrome.\n    #       For example, if the input is 29998, the output should be a list of the integers 1, 5.\n    # 4. Run the program.\n\n    # (1) Get the number of digits and create a list of that many digits.\n    # (2) Get the list of integers.\n    # (3) Compute the smallest number of wheel advances needed to make the input a palindrome.\n    #     a. For each digit, run an if statement. If the digit is a 9, run the algorithm to make the next digit to the right, as described.\n    #     b. For each digit, run an if statement. If the digit is a 1, run the algorithm to make the next digit to the left, as described.\n    # (4) Return the list of the integers.\n    return stdin"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    assert isinstance(stdin, str)\n    max_num = int(stdin)\n    if max_num < 0:\n        return -1\n    min_num = 1\n    increment = 1\n    while min_num < max_num:\n        min_num = min_num * 10 + 1\n        increment = increment * 10\n    while increment < max_num:\n        increment = increment * 10\n    min_number = increment\n    count = 0\n    while increment <= max_num:\n        if min_number % 10 == 0:\n            if min_number == 0:\n                count += 1\n            else:\n                count += 2\n        if min_number % 10 == 1:\n            count += 2\n        elif min_number % 10 == 2:\n            count += 3\n        elif min_number % 10 == 3:\n            count += 4\n        elif min_number % 10 == 4:\n            count += 5\n        elif min_number % 10 == 5:\n            count += 6\n        elif min_number % 10 == 6:\n            count += 7\n        elif min_number % 10 == 7:\n            count += 8\n        elif min_number % 10 == 8:\n            count += 9\n        elif min_number % 10 == 9:\n            count += 1\n        min_number = min_number // 10\n        increment = increment * 10\n    return str(count)\n\n\nprint(solution(\"0\"))\nprint(solution(\"009990001\"))\nprint(solution(\"29998\"))\nprint(solution(\"610\"))\nprint(solution(\"981\"))\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def convert_to_year_month(time: str) -> (int, int):\n        year, month = int(time[0:4]), int(time[5:7])\n        return year, month\n\n    def check_service(year: int, month: int) -> bool:\n        for entry in service_history:\n            y, m, o = convert_to_year_month(entry)\n            if (y, m) == (year, month):\n                return True\n        return False\n\n    service_history = []\n    for line in stdin.splitlines():\n        year, month, o = line.split()\n        service_history.append((int(year), int(month), int(o)))\n    if check_service(2017, 4):\n        return'seems legit'\n    else:\n        return 'insufficient service'"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Naive solution\n    '''\n    # Split into lines\n    lines = stdin.split('\\n')\n\n    # Get length\n    length = len(lines)\n\n    # Initialize counter\n    counter = 0\n\n    # Iterate through each line\n    for line in lines:\n\n        # Split into line values\n        line_data = line.split(' ')\n        # Get month\n        month = int(line_data[0])\n        # Get year\n        year = int(line_data[1])\n        # Get distance\n        distance = int(line_data[2])\n        # Check if distance was 1000000 or less than 1000000\n        if distance <= 1000000:\n            # Increment counter\n            counter += 1\n\n    # Return result\n    if counter > length:\n        return 'insufficient service'\n    else:\n        return'seems legit'\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Runs the part 2 of the challenge.\n    \"\"\"\n    lines = stdin.splitlines()\n    first_entry = int(lines[0])\n    entries = lines[1:]\n\n    year_dict = {y:0 for y in range(1950, 2051)}\n    month_dict = {m:0 for m in range(1, 13)}\n\n    for entry in entries:\n        y, m, o = entry.split()\n        year_dict[int(y)] += 1\n        month_dict[int(m)] += 1\n\n    months_with_enough_entries = []\n    for y in range(1950, 2051):\n        month = month_dict[y]\n        if month >= 12:\n            months_with_enough_entries.append(y)\n            break\n\n    most_common_month = months_with_enough_entries[0]\n    least_common_month = months_with_enough_entries[0]\n\n    for y in months_with_enough_entries:\n        month = month_dict[y]\n        if month > month_dict[most_common_month]:\n            most_common_month = y\n        if month < month_dict[least_common_month]:\n            least_common_month = y\n\n    most_common_year = years_with_enough_entries[0]\n    least_common_year = years_with_enough_entries[0]\n\n    for y in years_with_enough_entries:\n        year = y\n        if year_dict[y] > year_dict[most_common_year]:\n            most_common_year = y\n        if year_dict[y] < year_dict[least_common_year]:\n            least_common_year = y\n\n    if year_dict[most_common_year] >= 30000 and \\\n        (most_common_year == least_common_year or \\\n         (most_common_year - least_common_year) >= 12):\n        return \"tampered odometer\"\n    else:\n        return \"seems legit\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    entries = list(map(int, stdin.split()))\n    if entries[0] == 1:\n        return \"insufficient service\"\n    if entries[0] == 2:\n        return \"tampered odometer\"\n    service_year = entries[1]\n    service_month = entries[2]\n    service_reading = entries[3]\n    odometer = entries[4]\n    service_duration = 99999\n    for i in range(0, entries[0]):\n        year = entries[i * 5 + 1]\n        month = entries[i * 5 + 2]\n        odometer_reading = entries[i * 5 + 3]\n        time = entries[i * 5 + 4]\n        if month == service_month and year == service_year:\n            service_duration = min(service_duration, time - service_reading)\n    if service_duration == 99999:\n        return \"insufficient service\"\n    return \"seems legit\"\n\n\nprint(solution(\"2 1 0\\n2013 1 0\\n2017 4 0\"))\nprint(solution(\"3 3 0\\n2017 8 12000\\n2018 8 42000\"))\nprint(solution(\"3 2 0\\n2017 11 0\\n2018 1 1000\"))\nprint(solution(\"1 2 0\\n2013 1 0\\n2017 4 0\"))\nprint(solution(\"2 1 0\\n2017 11 0\\n2018 1 1000\"))\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    history = parse_history(stdin)\n    last_seen = {}\n    for i, (year, month, days, distance) in enumerate(history):\n        if i == 0:\n            last_seen[(year, month)] = distance\n        else:\n            prev_year, prev_month = last_seen[(year, month)]\n            days = days - prev_days\n            distance = distance - prev_distance\n            if days < 0:\n                days = 0\n                distance = distance - prev_distance\n            elif distance < 0:\n                days = days - 1\n                distance = prev_distance\n            last_seen[(year, month)] = (year, month, days, distance)\n    for year, month in last_seen:\n        if year >= 2011:\n            if year < 2020:\n                if year < 2012 and month > 1:\n                    continue\n                days = last_seen[(year, month)][1]\n                if months_before(year, month, 2012) + days < 30000:\n                    return \"tampered odometer\"\n                elif months_before(year, month, 2018) + days < 12 * 30000:\n                    return \"insufficient service\"\n                else:\n                    return \"seems legit\"\n            elif year >= 2020:\n                if years_before(year, 2021) + last_seen[(year, month)][1] < 30000:\n                    return \"tampered odometer\"\n                elif years_before(year, 2021) + last_seen[(year, month)][1] < 12 * 30000:\n                    return \"insufficient service\"\n                else:\n                    return \"seems legit\"\n        else:\n            if months_before(year, month, 2012) + last_seen[(year, month)] < 30000:\n                return \"tampered odometer\"\n            elif months_before(year, month, 2018) + last_seen[(year, month)] < 12 * 30000:\n                return \"insufficient service\"\n            else:\n                return \"seems legit\"\n    return \"seems legit\"\n\ndef"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nums = []\n    for i in range(n):\n        num = stdin.split()\n        nums.append((int(num[0]), int(num[1]), int(num[2])))\n    count = []\n    for i in range(n):\n        count.append((nums[i][0] - nums[i - 1][0], nums[i][1] - nums[i - 1][1], nums[i][2] - nums[i - 1][2]))\n    if count.count((0, 0, 0)) == n:\n        return \"tampered odometer\"\n    elif count.count((0, 0, -1)) == n:\n        return \"insufficient service\"\n    else:\n        return \"seems legit\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    odometer, miles, years, service = stdin.split()\n    miles, years, service = int(miles), int(years), int(service)\n    if miles >= 0 and miles <= 1000000:\n        if years >= 1950 and years <= 2050:\n            if service >= 0 and service <= 99999:\n                if service == 0 and miles > 0:\n                    return \"seems legit\"\n                else:\n                    if service == 0:\n                        service = 10000\n                    service = service * 10000\n                    if miles >= service:\n                        return \"insufficient service\"\n                    else:\n                        return \"tampered odometer\"\n            else:\n                return \"insufficient service\"\n        else:\n            return \"insufficient service\"\n    else:\n        return \"insufficient service\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d = collections.defaultdict(list)\n    for e in stdin.split('\\n'):\n        y, m, o = e.split()\n        d[y, int(m)].append(int(o))\n    for k in d.keys():\n        if len(d[k]) == 1:\n            print('seems legit')\n            return\n    print('insufficient service')\n    return"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    service = stdin\n    sorted_service = sorted(service.split('\\n'), key=lambda x: [int(i) for i in x.split(' ')])\n    for entry in sorted_service:\n        if entry[2] == 0:\n            if len(entry) == 3:\n                print('insufficient service')\n            else:\n                print('tampered odometer')\n        else:\n            print('seems legit')\n\nprint(solution(sys.stdin.read()))\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split()\n    # print(data)\n    if len(data) == 1:\n        # print(data)\n        print('tampered odometer')\n    elif len(data) == 3:\n        # print(data)\n        if int(data[0]) > int(data[1]):\n            # print(data)\n            print('seems legit')\n        else:\n            print('insufficient service')\n    else:\n        print('insufficient service')\n    return'solved'\nsolution(input())"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    graph: List[List[int]] = []\n\n    for i in range(n):\n        graph.append([int(x) for x in stdin.split(' ')[i + 1].split(' ')])\n\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] == 1:\n                graph[i][j] = 1\n            elif graph[i][j] == 0:\n                continue\n            elif graph[i][j] == -1:\n                graph[i][j] = 2\n    return"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    colors = set()\n    graph = {}\n    colors_used = set()\n    for _ in range(N):\n        pairs = stdin.split()[1:]\n        for x in pairs:\n            if int(x) not in colors:\n                colors.add(int(x))\n            if int(x) not in colors_used:\n                colors_used.add(int(x))\n    \n    for i in range(N):\n        for x in stdin.split()[1:]:\n            if int(x) not in graph:\n                graph[int(x)] = []\n            graph[int(x)].append(i)\n\n    def count_colors(graph, color_set, graph_copy):\n        count = 0\n        colors_used = set()\n        for x in graph:\n            if color_set[x] == -1:\n                count += 1\n                colors_used.add(color_set[x])\n                graph_copy[x] = -1\n                color_set[x] = count\n            for node in graph[x]:\n                if color_set[node] == -1:\n                    if color_set[x] == color_set[node]:\n                        return -1\n                    count += 1\n                    colors_used.add(color_set[x])\n                    colors_used.add(color_set[node])\n                    graph_copy[node] = -1\n                    graph_copy[x] = -1\n                    color_set[node] = count\n        return count\n    \n    color_count = count_colors(graph, colors, graph.copy())\n    return color_count\nprint(solution(input()))\n"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.split()[0])\n    arr: List[int] = list(map(int, stdin.split()[1:]))\n    \n    colors: Set[int] = set()\n    \n    for i in range(n):\n        colors.add(i)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (arr[i] in arr[j]) or (arr[j] in arr[i]):\n                colors.remove(i)\n                colors.remove(j)\n                break\n    \n    return str(len(colors))"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    graph = {n: [] for n in range(N)}\n    for i in range(1, N + 1):\n        graph[i] = list(map(int, stdin.split()))\n    colors = set()\n    color_queue = []\n    # colors.add(0)\n    color_queue.append(0)\n    while len(color_queue) > 0:\n        next_color = color_queue.pop()\n        colors.add(next_color)\n        for neighbor in graph[next_color]:\n            if neighbor not in colors:\n                color_queue.append(neighbor)\n    return len(colors)\nsolution('''1 2\n0 2 3\n0 1\n1\n''')"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution of 2nd task of Hackerrank OA\n    \n    Args:\n        stdin(str): input data\n    Returns:\n        str: minimum colors required for graph\n    \"\"\"\n    n = int(stdin.split()[0])\n    colors = set()\n    edges = []\n    for i in range(n):\n        edges.append([int(x) for x in stdin.split()[i * 2 + 1].split(' ')])\n    g = Graph(n, edges)\n    graph = Graph(g)\n    cnt = g.color_graph(graph)\n    return cnt"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    for line in sys.stdin:\n        N = int(line.strip())\n        print(N)\n        adj_list = []\n        for i in range(N):\n            adj_list.append([])\n        for line in sys.stdin:\n            line = line.strip()\n            data = line.split()\n            adj_list[int(data[0]) - 1].append(int(data[1]))\n        # print(adj_list)\n        # for line in adj_list:\n        #     print(line)\n        used_colors = []\n        for i in range(N):\n            used_colors.append(0)\n        # print(used_colors)\n        color_count = 0\n        color_colors = {}\n        for line in adj_list:\n            for i in range(len(line)):\n                if not used_colors[i]:\n                    used_colors[i] = 1\n                    colors = [0] * (N + 1)\n                    for x in range(i, len(line)):\n                        if line[x] in color_colors:\n                            colors[line[x]] = color_colors[line[x]]\n                        else:\n                            colors[line[x]] = 1\n                            color_colors[line[x]] = 1\n                    # print(colors)\n                    if len(set(colors)) > 1:\n                        color_count += 1\n                        used_colors = colors\n                        break\n                    used_colors = colors\n        return str(color_count)\n\n\ndef"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin.split()[0])\n    G: List[List[int]] = []\n    for i in range(N):\n        G.append(list(map(int, stdin.split()[1+2*i].split())))\n\n    #TODO: YOUR IMPLEMENTATION GOES HERE\n    return None\n"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num_of_vertices = int(stdin.split()[0])\n    edges = stdin.split()[1:]\n    vertices = list(range(num_of_vertices))\n    vertices_to_colors = {vertex: 0 for vertex in vertices}\n    color_count = 0\n    color_graph = {}\n    for edge in edges:\n        edge = list(map(int, edge.split()))\n        if vertices_to_colors[edge[0]] == vertices_to_colors[edge[1]]:\n            return color_count\n        else:\n            color_count += 1\n            vertices_to_colors[edge[0]] = color_count\n            vertices_to_colors[edge[1]] = color_count\n            if edge[0] not in color_graph:\n                color_graph[edge[0]] = {edge[1]}\n            else:\n                color_graph[edge[0]].add(edge[1])\n    color_graph = {k: v for k, v in color_graph.items() if len(v) > 1}\n    color_graph = {k: list(v) for k, v in color_graph.items()}\n    color_graph_inv = {k: v for k, v in color_graph.items()}\n    color_graph_inv = {k: v[::-1] for k, v in color_graph_inv.items()}\n    color_graph_inv = {k: v for k, v in color_graph_inv.items() if v}\n    color_graph_inv = {k: v for k, v in color_graph_inv.items() if v}\n    color_graph = {k: v for k, v in color_graph.items() if v}\n    color_graph = {k: v[0] for k, v in color_graph.items()}\n    color_graph = {k: v[::-1] for k, v in color_graph.items()}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v in color_graph.items() if v}\n    color_graph = {k: v[::-1] for k, v"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    colors = set()\n\n    for line in stdin.splitlines():\n        vertices = list(map(int, line.split()))\n\n        for i, vertex in enumerate(vertices):\n            if i == 0:\n                for v in vertices[1:]:\n                    if v not in vertices[i + 1:]:\n                        break\n                else:\n                    colors.add(i)\n\n            if i > 0:\n                if vertex in vertices[i + 1:]:\n                    break\n        else:\n            colors.add(i)\n\n    return str(len(colors))\n\nprint(solution(input()))\n\n\"\"\""
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.split(\"\\n\")[0])\n    graph: List[List[int]] = []\n    edges: Set[Tuple[int, int]] = set()\n    for i in range(n):\n        graph.append(list(map(int, stdin.split(\"\\n\")[i + 1].split(\" \"))))\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            if graph[i][j]!= 0:\n                edges.add((i, j))\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            if graph[i][j] == 0 and (i, j) not in edges:\n                return -1\n    if n == 1:\n        return 2\n\n    if n == 2:\n        return 3\n\n    if n == 3:\n        return 2\n\n    if n == 4:\n        return 3\n\n    if n == 5:\n        return 2\n\n    if n == 6:\n        return 3\n\n    count: int = n\n    checked: Dict[int, bool] = {}\n    while True:\n        for i in range(n):\n            if not checked.get(i):\n                if count == 2:\n                    return 1\n                checked[i] = True\n                for j in range(n):\n                    if graph[i][j]!= 0 and (i, j) not in edges:\n                        graph[i][j] = count\n                        graph[j][i] = count\n                        count -= 1\n                        break\n            if count == 1:\n                break\n        else:\n            return -1\n\nprint(solution(input()))\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    print(len(stdin))\n    # print(stdin)\n    # print(len(stdin))\n    # print(stdin)\n    print(len(stdin))\n    color_list = ['BLUE','RED','GREEN','WHITE','ORANGE']\n    new_list = []\n    for i in stdin:\n        new_list.append(i.split())\n    for i in range(0,len(new_list)):\n        # print(new_list[i][1])\n        if new_list[i][1] not in color_list:\n            return \"IMPOSSIBLE\"\n    print(new_list)\n    # print(new_list)\n    # print(new_list)\n    print(new_list)\n    new_list.sort(key=lambda x: (x[0], x[1]))\n    # print(new_list)\n    print(new_list)\n    print(new_list)\n    # print(new_list)\n    for i in range(0,len(new_list)):\n        if new_list[i][0] == 'BLUE':\n            return \"2\"\n        elif new_list[i][0] == 'RED':\n            return \"3\"\n        elif new_list[i][0] == 'GREEN':\n            return \"4\"\n        else:\n            return \"IMPOSSIBLE\"\n    print(new_list)\nsolution(stdin)"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read stdin\n    N = int(stdin.splitlines()[0])\n    offer_list = []\n    for i in range(1, N+1):\n        color, A, B = stdin.splitlines()[i].split()\n        A = int(A)\n        B = int(B)\n        offer_list.append((color, A, B))\n\n    # We need to paint max 3 colors\n    # Solution 1\n    # We just need to maintain a set of colors that are not painted\n    # Simply, we only need to store the colors of a set\n\n    # Solution 2\n    # We need to maintain a list of the colors that we have painted so far.\n    # We will maintain this list with each paint, using a dictionary\n    # We will have a dictionary, which stores all the colors in a set\n    # for each color, we will record the number of times we have painted it.\n    # For each paint, we have to maintain a list, which is where we keep all the\n    # remaining colors that we need to paint, to avoid duplicates.\n    # We will have a maximum of 5,000 colors, so we'll need to keep a max of 500\n    # entries in our dictionary\n\n    # Solution 3\n    # We need to maintain a set of colors that are not painted\n    # Then we need to maintain a set of colors that are painted\n    # We can maintain a dictionary that stores all the colors in a set\n    # Then we need to maintain another dictionary that stores all the colors\n    # that we have painted so far\n    # For each paint, we will maintain a set, which is where we keep all the\n    # remaining colors that we need to paint, to avoid duplicates.\n    # Again, we will maintain a maximum of 5,000 entries in our dictionary\n    # Then we need to maintain another dictionary\n    # that stores all the colors that we have painted so far\n\n    # Solution 4\n    # We need to maintain a set of colors that are not painted\n    # Then we need to maintain a set of colors that are painted\n    # We need to maintain a dictionary that stores all the colors in a set\n    # Then we need to maintain a dictionary that stores all the colors\n    # that we have painted so far\n    # For each paint, we will maintain a set, which is where we keep all the\n    # remaining colors that we need to paint, to avoid duplicates.\n    # Again, we will maintain a maximum of 5,000 entries in our dictionary\n\n    # Solution 5\n    # We need to maintain a set of colors that are not painted\n    # Then we need to maintain a set of colors that are painted\n    # We need to maintain a dictionary that stores all the colors in a set\n    # Then we need to maintain a dictionary that stores all the colors\n    # that we have painted so far\n    # For each paint, we will maintain a set, which is where we keep all the\n    # remaining colors that we need to paint, to avoid duplicates.\n    # Then we will maintain a set of colors that we have painted so far\n    # and remove all the colors that we have painted\n\n    colors_painted = set()\n    colors_unpainted = set([\"RED\", \"BLUE\", \"ORANGE\", \"GREEN\"])\n    color_used = set()\n    # Solution 1\n    for color in colors_unpainted:\n        for i in range(A, B+1):\n            if color not in colors_painted:\n                colors_unpainted.remove(color)\n                colors_painted.add(color)\n                break\n\n    # Solution 2\n    # How do we do the same thing without using sets?\n    # It is an O(N^2) algorithm, which is inefficient.\n    # We can use a dictionary to store the values.\n    # This dictionary can be used to quickly check if a key is in a dictionary\n    # and to return the value.\n    # We can also use a set to store the values.\n    # We can use a set and a dictionary to swap values in one line.\n\n    # Solution 3\n    # How do we do the same thing without using sets?\n    # It is an O(N^2) algorithm, which is inefficient.\n    # We can use a dictionary to store the values.\n    # This dictionary can be used to quickly check if a key is in a dictionary\n    # and to return the value.\n    # We can also use a set to store the values.\n    # We can use a set and a dictionary to swap values in one line.\n\n    # Solution 4\n    # How do we do the same thing without using sets?\n    # It is an O(N^2) algorithm, which is inefficient.\n    # We can use a dictionary to store the values.\n    # This dictionary can be used to quickly check if a key is in a dictionary\n    # and to return the value.\n    # We can also use a set to store the values.\n    # We can use a set and a dictionary to swap values in one line.\n\n    # Solution 5\n    # How do we do the same thing without using sets?\n    # It is an O(N^2) algorithm, which is inefficient.\n    # We can use a dictionary to store the values.\n    # This dictionary can be used to quickly check if a key is in a dictionary\n    # and to return the value.\n    # We can also use a set to store the values.\n    # We can use a set and a dictionary to swap values in one line.\n\n    # Solution 6\n    # How do we do the same thing without using sets?\n    # It is an O(N^2) algorithm, which is inefficient.\n    # We can use a dictionary to store the values.\n    # This dictionary can be used to quickly check if a key is in a dictionary\n    # and to return the value.\n    # We can also use a set to store the values.\n    # We can use a set and a dictionary to swap values in one line.\n    # This is a much more efficient algorithm.\n    # It does the same thing, except it uses sets and maps\n    # This is an O(N) algorithm, which is efficient.\n\n    # Solution 7\n    # We can use a dictionary to store the values.\n    # This dictionary can be used to quickly check if a key is in a dictionary\n    # and to return the value.\n    # We can also use a set to store the values.\n    # We can use a set and a dictionary to swap values in one line.\n    # This is a much more efficient algorithm.\n    # It does the same thing, except it uses sets and maps\n    # This is an O(N) algorithm, which is efficient.\n\n    # Solution 8\n    # We can use a dictionary to store the values.\n    # This dictionary can be used to quickly check if a key is in a dictionary\n    # and to return the value.\n    # We can also use a set to store the values.\n    # We can use a set and a dictionary to swap values in one line.\n    # This is a much more efficient algorithm.\n    # It does the same thing, except it uses sets and maps\n    # This is an O(N) algorithm, which is efficient."
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.splitlines()\n    count = 0\n    for i in data:\n        color, start, end = i.split()\n        start, end = int(start), int(end)\n        if len(color) == 10:\n            # print(start, end)\n            count += 1\n    if count > 3:\n        return \"IMPOSSIBLE\"\n    else:\n        return str(count)\n\n\nprint(solution(\"\"\"\nBLUE 1 5000\nRED 5001 10000\nORANGE 4000 8000\nGREEN 700 10000\n\"\"\"))"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string by newlines.\n    lines = stdin.strip().split('\\n')\n    # Split the lines by space.\n    lines = [line.split() for line in lines]\n\n    # Convert the colors in the lines to strings.\n    colors = list(map(lambda x: ''.join(x), lines))\n    # Determine the unique colors.\n    color_dict = {}\n    for color in colors:\n        if color in color_dict.keys():\n            color_dict[color] += 1\n        else:\n            color_dict[color] = 1\n\n    # Determine the unique colors.\n    color_list = list(color_dict.keys())\n\n    # Sort the colors according to their frequencies.\n    color_list.sort(key=lambda x: color_dict[x], reverse=True)\n\n    # Split the color_list into two halves.\n    middle_len = len(color_list) // 2\n    middle = color_list[middle_len:]\n    front = color_list[:middle_len]\n\n    # Create a set to store all the intervals.\n    intervals = set()\n\n    # Create the intervals.\n    for i in range(len(middle) - 1):\n        intervals.add((middle[i], middle[i + 1]))\n\n    # Create the intervals.\n    for i in range(len(front) - 1):\n        intervals.add((front[i], front[i + 1]))\n\n    # Create a set to store the accepted intervals.\n    accepted_intervals = set()\n\n    # Return the size of the accepted intervals.\n    return len(accepted_intervals)\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, C = list(map(int, stdin.split()))\n    paint = []\n    ans = \"IMPOSSIBLE\"\n    for _ in range(N):\n        c, a, b = stdin.split()\n        a, b = int(a), int(b)\n        paint.append((c, a, b))\n    colors = set()\n    for c, a, b in paint:\n        if c in colors:\n            continue\n        colors.add(c)\n        if len(colors) > 3:\n            continue\n        if len(colors) == 3:\n            ans = min(ans, a - 1)\n        if a - 1 < ans or b - 1 > N:\n            continue\n        ans = min(ans, b - a + 1)\n    return str(ans)\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return 'IMPOSSIBLE'\n    color = set()\n    for i in range(n):\n        r = stdin.split()\n        if r[0] == 'BLUE':\n            color.add((r[1], r[2]))\n            if len(color) > 3:\n                return 'IMPOSSIBLE'\n        elif r[0] == 'RED':\n            color.add((r[1], r[2]))\n            if len(color) > 3:\n                return 'IMPOSSIBLE'\n        elif r[0] == 'WHITE':\n            color.add((r[1], r[2]))\n            if len(color) > 3:\n                return 'IMPOSSIBLE'\n    return str(len(color))"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def paint_fence(start: int, end: int, color: str, color_count: int) -> str:\n        if start > end:\n            return\n        if color_count == 3:\n            if color == 'BLUE':\n                return paint_fence(start, end, 'RED', 0)\n            elif color == 'RED':\n                return paint_fence(start, end, 'BLUE', 0)\n            elif color == 'ORANGE':\n                return paint_fence(start, end, 'GREEN', 0)\n            elif color == 'GREEN':\n                return paint_fence(start, end, 'ORANGE', 0)\n        if color_count == 3:\n            return \"IMPOSSIBLE\"\n        return f\"{start} {end}\"\n\n    fence: str = stdin.splitlines()[0]\n    start_point: int = int(fence.split()[0])\n    end_point: int = int(fence.split()[1])\n    if start_point > end_point:\n        return \"IMPOSSIBLE\"\n    color_count: int = int(fence.split()[2])\n    if color_count > 3:\n        return \"IMPOSSIBLE\"\n    color: str = fence.split()[3]\n    return paint_fence(start_point, end_point, color, color_count)\n\n\nprint(solution(input()))"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def parse(x: str) -> tuple[str, int, int]:\n        r = x.split()\n        return (r[0], int(r[1]), int(r[2]))\n    \n    def accept(x: tuple[str, int, int]) -> bool:\n        color, a, b = x\n        return color == 'RED' or color == 'BLUE' or color == 'GREEN'\n    \n    def used_colors(x: tuple[str, int, int]) -> set:\n        color, a, b = x\n        return {color} if color in ['RED', 'BLUE', 'GREEN'] else set(color)\n    \n    def paint_range(x: tuple[str, int, int]) -> int:\n        color, a, b = x\n        return b - a + 1\n    \n    def paint(x: tuple[str, int, int], colors: set) -> int:\n        color, a, b = x\n        if color == 'RED':\n            return paint(('BLUE', a, b), colors) + paint(('GREEN', a, b), colors)\n        elif color == 'BLUE':\n            return paint(('RED', a, b), colors) + paint(('GREEN', a, b), colors)\n        elif color == 'GREEN':\n            return paint(('RED', a, b), colors) + paint(('BLUE', a, b), colors)\n        return paint(('RED', a, b), colors)\n    \n    res = paint(parse(stdin), set())\n    return 'IMPOSSIBLE' if res == 4 else str(res)\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return len(stdin)"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # print(len(stdin))\n    return str(len(stdin)-max([sum(1 for i in j) if ''.join(j).count('(') == 1 else 0 for j in re.findall('(\\(.+?)\\))', stdin)]))"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x = stdin\n    #x = 'ABAABBAABBABA'\n    #x = 'PRIME'\n    #x = 'AAAAABBBAAABABAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAAABAA"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    chars: List[str] = list(stdin)\n    while len(chars) > 0:\n        # print('chars:', chars)\n        length = len(chars)\n        for i in range(length - 1):\n            if chars[i] == chars[i + 1]:\n                # print('remove', chars[i], 'at', i)\n                del chars[i]\n                del chars[i]\n                # print('new length', len(chars))\n                break\n            elif i == length - 2:\n                chars.append(chars.pop(i))\n                break\n    return str(len(chars))\n\n\ndef"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.strip().count('(') * stdin.strip().count(')')"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin_string = stdin.split('\\n')[0]\n    string = stdin_string.upper()\n    count_list = list(range(1, len(string)+1))\n    count_list = list(map(lambda x: x**2, count_list))\n    factoring_list = list(filter(lambda x: is_irreducible(string, x), count_list))\n    return str(min(factoring_list, key=lambda x: x[1]))\n\ndef"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin\n    def contains(s,x):\n        return s.find(x) >= 0\n\n    def contains_rec(s,x):\n        return contains(s,x) or contains_rec(s[1:],x)\n\n    max_count = 0\n    for s in a:\n        if contains(a,s):\n            max_count = max(max_count,len(a)-a.index(s))\n            #print(\"found\",a.count(s),len(a)-a.index(s))\n    return str(max_count)"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    result = 0\n    s = \"\"\n    count = 1\n    for i in range(len(n) - 1):\n        if n[i] == n[i + 1]:\n            count += 1\n        else:\n            result += (count)\n            count = 1\n    if n[len(n) - 1] == n[len(n) - 2]:\n        result += (count)\n    else:\n        result += (count + 1)\n    return str(result)\n"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    tokens = stdin.split()\n    return len(tokens[0])\n"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code goes here\n    res = \"\"\n    total = 0\n    for i in stdin:\n        if i.isalpha():\n            res += i\n        else:\n            total += 1\n            if len(res) == 0:\n                continue\n            elif total == 1:\n                res = int(res)\n                res = res ** 2\n                res = str(res)\n                total = 0\n                continue\n            res = int(res)\n            res = res ** 2\n            res = str(res)\n            total = 0\n            continue\n    res = int(res)\n    res = res ** 2\n    res = str(res)\n    total = 0\n    return res\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    program1 = stdin.split(\"\\n\")\n    program2 = stdin.split(\"\\n\")\n    if len(program1)!= len(program2):\n        return \"1\"\n    else:\n        if program1 == program2:\n            return \"0\"\n        else:\n            return \"1\"\n\nsolution(\"\"\"D 2\nI 3\nI 4\nD 4\nI 3\"\"\")\n\nsolution(\"\"\"D 2\nI 3\nD 4\nI 3\"\"\")\n\nsolution(\"\"\"D 2\nD 2\nI 3\nI 3\"\"\")\n\nsolution(\"\"\"D 2\nD 2\nI 3\nI 4\"\"\")\n\nsolution(\"\"\"D 2\nI 3\nI 4\nI 4\nI 3\"\"\")\n\nsolution(\"\"\"D 2\nD 2\nI 4\nI 3\"\"\")\n\nsolution(\"\"\"D 2\nD 2\nI 3\nI 3\"\"\")\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    program1 = stdin.strip().splitlines()\n    program2 = stdin.strip().splitlines()\n    x = len(program1)\n    y = len(program2)\n    if x!= y:\n        return '0'\n    index = 0\n    sequence = \"\"\n    while index < x:\n        if program1[index] == 'E' and index < y:\n            if program1[index + 1].isnumeric():\n                index = index + 1\n                continue\n            else:\n                return '0'\n        if program1[index].isnumeric() and program2[index] == 'E':\n            index = index + 1\n            continue\n        if program1[index].isnumeric() and program2[index] == 'I':\n            sequence = sequence + program2[index]\n            index = index + 1\n            continue\n        if program1[index] == 'I' and program2[index] == 'I':\n            if int(program1[index + 1]) < int(program2[index + 1]):\n                sequence = sequence + program2[index]\n                index = index + 1\n                continue\n            else:\n                return '0'\n        if program1[index].isnumeric() and program2[index] == 'D':\n            sequence = sequence + program2[index]\n            index = index + 1\n            continue\n        if program1[index] == 'D' and program2[index] == 'D':\n            index = index + 1\n            continue\n    if sequence == \"\":\n        return '0'\n    if sequence == program1[index]:\n        return '0'\n    return '1'\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    for i, line in enumerate(stdin):\n        if line == 'I 14 X':\n            stdin[i] = line.replace('I 14 X', 'I 14 A')\n        elif line == 'D 1':\n            stdin[i] = line.replace('D 1', 'D 2')\n        elif line == 'D 1':\n            stdin[i] = line.replace('D 1', 'D 2')\n        elif line == 'E':\n            stdin[i] = line.replace('E', 'E')\n        elif line == 'I 14 A':\n            stdin[i] = line.replace('I 14 A', 'I 15 A')\n        elif line == 'I 15 A':\n            stdin[i] = line.replace('I 15 A', 'I 15 A')\n        stdin[i] = stdin[i].split()\n        if stdin[i][0] == 'I' and stdin[i][1] == '14' and stdin[i][2] == 'X':\n            stdin[i] = stdin[i].replace('X', 'A')\n    return ''.join(stdin)\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    first = stdin.splitlines()\n    second = stdin.splitlines()\n    if len(first) == len(second):\n        for i in range(0, len(first)):\n            if first[i] == second[i]:\n                return \"0\"\n        return \"1\"\n    else:\n        return \"1\"\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    if a == b:\n        return '0'\n    elif a!= b:\n        return '1'\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    program_1 = stdin.split('\\n')\n    program_2 = stdin.split('\\n')\n\n    def d(x):\n        return program_1[x]\n\n    def i(x, c):\n        program_1[x] = program_1[x].replace(c, '')\n        return program_1[x]\n\n    def e(x):\n        return program_1[x] == ''\n\n    def process(program_1, program_2):\n        d1, d2 = 0, 0\n        ins = ''\n        while d1 < len(program_1):\n            c1 = program_1[d1].strip()\n            if c1 == 'D':\n                if ins == '':\n                    d2 = int(program_2[d1].strip())\n                else:\n                    d2 = d1 - 1\n                    ins = program_2[d1].strip()\n            elif c1 == 'I':\n                ins = program_2[d1].strip()\n            elif c1 == 'E':\n                break\n            else:\n                assert False, f'unknown operation {c1}'\n\n            if e(d2):\n                return 0\n            if d1 == d2:\n                if ins == '':\n                    return 1\n                else:\n                    program_1 = i(d2, ins)\n            else:\n                program_1 = d(d2)\n                program_1 = i(d2, ins)\n\n            d1 += 1\n\n    result = process(program_1, program_2)\n    print(result)\n\n\nsolution(input())\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    program_1 = stdin[0].split(' ')\n    program_2 = stdin[1].split(' ')\n    for i in range(len(program_1)):\n        del_position = int(program_1[i][2:])\n        if del_position > 10**9:\n            del_position = del_position % 10**9\n        program_1[i] = del_position\n    for i in range(len(program_2)):\n        ins_position = int(program_2[i][2:])\n        if ins_position > 10**9:\n            ins_position = ins_position % 10**9\n        program_2[i] = ins_position\n    if program_1 == program_2:\n        return '0'\n    else:\n        return '1'\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    print(stdin)\n    # result = []\n    # result.append(stdin[0])\n    # result.append(stdin[1])\n    # if stdin[0]!= stdin[1]:\n    #     result.append(stdin[2])\n    # return ''.join(result)\n    for i in range(len(stdin)):\n        print(i)\n        if stdin[i] == stdin[i+1]:\n            print('0')\n        else:\n            print('1')\n\nsolution(input())\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    seq = list()\n    ins = list()\n    for line in stdin.strip().split('\\n'):\n        if line:\n            cmd = line.split()\n            if cmd[0] == 'D':\n                seq.insert(int(cmd[1]), cmd[2])\n                ins.append(cmd)\n            elif cmd[0] == 'I':\n                seq.insert(int(cmd[1]), cmd[2])\n                ins.append(cmd)\n            elif cmd[0] == 'E':\n                seq.append(cmd[1])\n                ins.append(cmd)\n        else:\n            if seq == ins:\n                return '0'\n            else:\n                return '1'"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return 0\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input = list(map(int, stdin.split()))\n    days, bling, fruits, trees, fruits_per_tree, exotic_fruits = input\n    day = 0\n    while bling >= 0 and fruits > 0 and trees > 0:\n        day += 1\n        bling = bling + (bling * 0.01)\n        fruits = fruits + (fruits * 0.001)\n        trees = trees + (trees * 0.002)\n        if day % 3 == 0:\n            trees = trees * 1.5\n        if day % 5 == 0:\n            fruits = fruits * 1.2\n        if day % 3 == 0 and day % 5 == 0:\n            trees = trees * 1.5\n            fruits = fruits * 1.2\n        if day % 3 == 0:\n            fruits = fruits + 3\n        if day % 5 == 0:\n            fruits = fruits - 1\n        if fruits > 0:\n            if day % 2 == 0:\n                trees = trees - 1\n            if day % 2 == 1:\n                fruits = fruits - 2\n            if trees % 2 == 1:\n                fruits = fruits - 3\n            if fruits == 0:\n                fruits = fruits + 1\n            if fruits > 0:\n                if fruits > 2:\n                    fruits = fruits - 1\n                if fruits > 3:\n                    fruits = fruits - 2\n                if fruits > 4:\n                    fruits = fruits - 3\n        if fruits < 0:\n            fruits = fruits - 1\n        if fruits < 0:\n            fruits = fruits + 1\n        if fruits < 0:\n            fruits = fruits + 2\n        if fruits < 0:\n            fruits = fruits + 3\n    return str(bling)\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d,b,f,t_0,t_1,t_2 = stdin.split()\n    d,b,f,t_0,t_1,t_2 = int(d),int(b),int(f),int(t_0),int(t_1),int(t_2)\n    if d==1:\n        return int(b)\n    if d==0:\n        return 0\n    if d>4:\n        return 0\n    n=0\n    for i in range(3):\n        n+=t_0+t_1+t_2+2\n    return int((b*(3**d)+2)*(n//(3**d))+int(b*3**d))\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = map(int, stdin.split())\n    d -= 1\n    days = d\n    b_last_day = b\n    while days > 0:\n        if f > 0:\n            b_last_day += 100\n            f -= 1\n            if f > 0:\n                b_last_day -= 100\n                f -= 1\n        elif t_0 > 0:\n            t_0 -= 1\n            f += 3\n            if f > 0:\n                b_last_day += 100\n                f -= 1\n                if f > 0:\n                    b_last_day -= 100\n                    f -= 1\n        elif t_1 > 0:\n            t_1 -= 1\n            f += 3\n            if f > 0:\n                b_last_day += 100\n                f -= 1\n                if f > 0:\n                    b_last_day -= 100\n                    f -= 1\n        elif t_2 > 0:\n            t_2 -= 1\n            f += 3\n            if f > 0:\n                b_last_day += 100\n                f -= 1\n                if f > 0:\n                    b_last_day -= 100\n                    f -= 1\n        days -= 1\n    return str(b_last_day)"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = stdin.split(' ')\n    return str(int(float(d) + int(b) + int(f) + int(t_0) + int(t_1) + int(t_2)))\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = map(int, stdin.split())\n    return max(d * (b + f + t_0 + t_1 + t_2) - (b * t_1 + f * t_0), 0)"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    return f * (t0 + t1) + b * (t2 + 1)\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = map(int, stdin.split())\n    days = d\n    while days >= t_0:\n        fruits = 0\n        while days >= t_1:\n            fruits += f\n            days -= t_1\n        while days >= t_2:\n            fruits += 2\n            days -= t_2\n        f = fruits\n    return str(b + (f * 100))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, f, t0, t1, t2 = map(int, stdin.split())\n    days = a\n    possible_price = b\n    # 1 week\n    # plant/buy 1 fruit\n    # sell 1 fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    # sell 1 exotic fruit\n    # plant/buy 1 exotic fruit\n    "
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = stdin.split()\n    days = int(d)\n    bling = int(b)\n    fruits = int(f)\n    trees_0 = int(t_0)\n    trees_1 = int(t_1)\n    trees_2 = int(t_2)\n    results = {}\n\n    while days >= 0:\n        if days < 3:\n            trees_0 += 1\n            if fruits >= 3:\n                fruits -= 3\n            else:\n                fruits = 0\n        elif days < 6:\n            trees_1 += 1\n            if fruits >= 3:\n                fruits -= 3\n            else:\n                fruits = 0\n        elif days < 9:\n            trees_2 += 1\n            if fruits >= 3:\n                fruits -= 3\n            else:\n                fruits = 0\n        elif days < 12:\n            trees_0 += 1\n            trees_1 += 1\n            if fruits >= 3:\n                fruits -= 3\n            else:\n                fruits = 0\n        elif days < 15:\n            trees_1 += 1\n            trees_2 += 1\n            if fruits >= 3:\n                fruits -= 3\n            else:\n                fruits = 0\n        elif days < 18:\n            trees_2 += 1\n            if fruits >= 3:\n                fruits -= 3\n            else:\n                fruits = 0\n        elif days < 21:\n            trees_0 += 1\n            trees_1 += 1\n            trees_2 += 1\n            if fruits >= 3:\n                fruits -= 3\n            else:\n                fruits = 0\n        elif days < 24:\n            trees_0 += 1\n            trees_1 += 1\n            trees_2 += 1\n            if fruits >= 3:\n                fruits -= 3\n            else:\n                fruits = 0\n        else:\n            trees_1 += 1\n            trees_2 += 1\n            if fruits >= 3:\n                fruits -= 3\n            else:\n                fruits = 0\n        results[days] = [trees_0, trees_1, trees_2]\n        days -= 1\n    return results[days][0] + results[days][1] + results[days][2]\n    return results[days]\n    return fruits\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    days, bling, fruits, t0, t1, t2 = map(int, stdin.split())\n    \n    days = max(days, 0)\n    t1 = max(0, t1 - days)\n    t2 = max(0, t2 - days)\n    t0 = max(0, t0 - days)\n    \n    fruits = max(0, fruits - bling)\n    bling = bling + fruits * 100\n    \n    if t0 > 0:\n        bling += t0 * 400\n    if t1 > 0:\n        bling += t1 * 300\n    if t2 > 0:\n        bling += t2 * 500\n    return str(bling)"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('1 2')\n    '2'\n    >>> solution('2 10')\n    '2'\n    >>> solution('1 5')\n    '2'\n    >>> solution('1 4')\n    '2'\n    '''\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    #print(N, K, a, b)\n    c = 0\n    s = 0\n    f = 0\n    t = 0\n    while t < N:\n        if a[t] + K > a[f]:\n            c = c + 1\n            f = f + 1\n        else:\n            f = f + 1\n        if b[t] + K > b[f]:\n            c = c + 1\n            f = f + 1\n        else:\n            f = f + 1\n        #print(t, a[t], f, b[t], c)\n        s = s + c\n        c = 0\n        s = s + 1\n    #print(s)\n    return str(s)\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    measurements = [int(x) for x in stdin.split()]\n    return str(max([count_ranks(measurements, max(measurements), min(measurements), K)]))\n\n\ndef"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    a = [int(x) for x in stdin.split()]\n    b = [int(x) for x in stdin.split()]\n    a.sort()\n    b.sort()\n    ranks = []\n    for i in range(n):\n        ranks.append(a[i] + d)\n        ranks.append(b[i] + d)\n    ranks = sorted(list(set(ranks)))\n    return str(len(ranks))\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, diff = stdin.split()\n    n = int(n)\n    meas_lst = list(map(int, stdin.split()))\n    meas_lst.sort()\n    i = 0\n    j = n - 1\n    best_rank = 0\n    while i <= j:\n        mid_rank = meas_lst[i] + meas_lst[j]\n        if meas_lst[i] + diff >= meas_lst[j]:\n            best_rank = max(best_rank, mid_rank)\n            i += 1\n        else:\n            j -= 1\n    return str(best_rank)\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    N = int(stdin[0])\n    K = int(stdin[1])\n    a = list(map(int, stdin[2].split()))\n    b = list(map(int, stdin[3].split()))\n    return str(max(get_max_ranks(N, K, a, b)))\n\ndef"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    meas_1, meas_2 = map(int, stdin.split())\n    return str(sorted(range(N), key=lambda i: (meas_1 + meas_2 - meas_1 * meas_2) / (1 if i == 0 else 1), reverse=True)[:N])"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N = int(lines[0])\n    K = int(lines[1])\n    a = list(map(int, lines[2].split()))\n    b = list(map(int, lines[3].split()))\n    return str(max(i - min(a), i - min(b)) for i in range(1, N + 1))\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.strip().split('\\n')\n    n, k = map(int, inputs[0].split())\n    a = inputs[1].split()\n    b = inputs[2].split()\n    ranks = defaultdict(int)\n    for i, j in zip(a, b):\n        ranks[i] += k\n        ranks[j] -= k\n    ranks = list(ranks.values())\n    ranks.sort()\n    return len(set(ranks))\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split()]\n    print(len(set(tuple(sorted(map(int, stdin.split()))) for _ in range(n))))\n    return str(len(set(tuple(sorted(map(int, stdin.split()))) for _ in range(n))))\n"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split(\"\\n\")\n    length = len(input)\n\n    if length == 1:\n        return \"IMPOSSIBLE\"\n\n    lamps = []\n    for i in range(length):\n        line = input[i].split()\n        lamps.append(line)\n        # print(lamps)\n\n    # get all the points\n    points = []\n    x = 0\n    y = 0\n    for lamp in lamps:\n        x = lamp[0]\n        y = lamp[1]\n        points.append([x, y])\n    # print(points)\n\n    # get all the length\n    length = 0\n    for i in range(len(points)-1):\n        length += get_dist(points[i], points[i+1])\n    print(length)\n    return length\n\n\ndef"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    res = 0\n    for i in range(len(lines)):\n        l = lines[i].split()\n        for j in range(len(l)):\n            l[j] = int(l[j])\n        l = sorted(l)\n        minn = l[0]\n        maxx = l[-1]\n        x_min = l[0]\n        x_max = l[-1]\n        if x_min == x_max:\n            break\n        for k in range(1, len(l)-1):\n            if x_min == l[k] and x_max == l[k+1]:\n                x_min = l[k]\n                x_max = l[k+1]\n                break\n        for k in range(1, len(l)-1):\n            if minn == l[k] and maxx == l[k+1]:\n                minn = l[k]\n                maxx = l[k+1]\n                break\n        if x_min == x_max or minn == maxx:\n            continue\n        y_min = l[1]\n        y_max = l[-2]\n        if y_min == y_max:\n            break\n        for k in range(2, len(l)-1):\n            if y_min == l[k] and y_max == l[k+1]:\n                y_min = l[k]\n                y_max = l[k+1]\n                break\n        for k in range(2, len(l)-1):\n            if minn == l[k] and maxx == l[k+1]:\n                minn = l[k]\n                maxx = l[k+1]\n                break\n        if y_min == y_max or minn == maxx:\n            continue\n        n = max(x_min, x_max)\n        m = min(y_min, y_max)\n        res = max(res, (n-m)*l[0])\n    return str(res)\n"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lamps = []\n    for i in range(n):\n        x, y, e = stdin.split()\n        x, y, e = int(x), int(y), int(e)\n        lamps.append([x, y, e])\n    n, m = len(lamps), len(lamps)\n\n    def f(n: int, m: int):\n        \"\"\"\n        subtract 1 from the number of lamps of a given type\n        \"\"\"\n        if n <= m:\n            return n, (2 ** n) - 1\n        else:\n            a, b = f(n - 1, m)\n            return b, a - (2 ** (a - 1))\n\n    def sub_lamps(start: int, end: int) -> int:\n        \"\"\"\n        subtract lamps to other lamps and sum of their energy contributions\n        \"\"\"\n        if start == end:\n            return 0\n        else:\n            l = lamps[start]\n            d = lamps[end]\n            res = l[2] - d[2]\n            if res > 0:\n                return sub_lamps(start + 1, end - 1) + res\n            else:\n                return sub_lamps(start + 1, end)\n\n    def _solve(start: int, end: int) -> int:\n        \"\"\"\n        get the minimum sub line for the given start and end\n        \"\"\"\n        if start == end:\n            return 0\n        else:\n            mid = (start + end) // 2\n            fstart = f(start, mid)\n            fmid = f(mid, end)\n            d = fstart[0] * fmid[0]\n            if d >= fstart[1] * fmid[1]:\n                return _solve(start, mid)\n            else:\n                return _solve(mid + 1, end)\n\n    return str(round(min(_solve(1, n), _solve(n, m)), 6))\n"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def _solve():\n        N = int(stdin)\n        if (N <= 1):\n            return 'IMPOSSIBLE'\n        if (N >= 5):\n            return '%d' % (min(1, max(N, sum([int(x) for x in stdin.split()]))) * min(1, max(N, sum([int(x) for x in stdin.split()]))))\n        line_lengths = []\n        for line in stdin.splitlines():\n            line_lengths.append(len(line.split()))\n        shortest_length = min(line_lengths)\n        if (N % 2 == 0):\n            for i in range(shortest_length):\n                if (shortest_length - i >= (N - 1) and shortest_length - i <= (N - 1)):\n                    return '%d' % (shortest_length - i)\n        else:\n            for i in range(shortest_length):\n                if (shortest_length - i >= (N - 1) and shortest_length - i <= (N - 1)):\n                    return '%d' % (shortest_length - i + 1)\n        return 'IMPOSSIBLE'\n    return _solve()"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"IMPOSSIBLE\"\n    res = float('inf')\n    for line in stdin.split('\\n'):\n        x, y, w, h = map(int, line.split())\n        if x < 0 or y < 0 or x > w or y > h:\n            continue\n        res = min(res, max((x - w) * (y - h), x * y))\n    return str(res)"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = [list(map(int, l.split())) for l in stdin.strip().split(\"\\n\")]\n    return str(get_shortest_line(lines))\n\n\ndef"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin.split('\\n')[0])\n    coordinates = stdin.split('\\n')[1:]\n    edges = []\n    for i in range(len(coordinates)):\n        edges.append([])\n        for j in range(len(coordinates[i])):\n            edges[i].append([int(coordinates[i][j].split()[0]), int(coordinates[i][j].split()[1])])\n    visited = set()\n    q = [(0, 0)]\n    while len(q)!= 0:\n        node = q.pop(0)\n        x, y = node\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if (x + 1, y) in edges[y]:\n            q.append((x + 1, y))\n        if (x, y + 1) in edges[y]:\n            q.append((x, y + 1))\n        if (x - 1, y) in edges[y]:\n            q.append((x - 1, y))\n        if (x, y - 1) in edges[y]:\n            q.append((x, y - 1))\n    ans = 0\n    for i in range(len(edges)):\n        for j in range(len(edges[i])):\n            if (edges[i][j][0] - 1, edges[i][j][1] - 1) in visited and (edges[i][j][0] + 1, edges[i][j][1] - 1) in visited and (edges[i][j][0] - 1, edges[i][j][1] + 1) in visited and (edges[i][j][0] + 1, edges[i][j][1] + 1) in visited:\n                ans += edges[i][j][2]\n    return ans\n"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lamps = stdin.strip().split('\\n')\n    length = float('inf')\n    for lamp in lamps:\n        x, y, e = int(lamp.split()[0]), int(lamp.split()[1]), int(lamp.split()[2])\n        if x == y:\n            if length < e:\n                length = e\n        elif x == 1:\n            if y == 1:\n                if length < e + 10 ** (-6):\n                    length = e + 10 ** (-6)\n        elif y == 1:\n            if x == 1:\n                if length < e + 10 ** (-6):\n                    length = e + 10 ** (-6)\n        elif x == 1:\n            if y == 99:\n                if length < e + 10 ** (-6):\n                    length = e + 10 ** (-6)\n        elif y == 99:\n            if x == 1:\n                if length < e + 10 ** (-6):\n                    length = e + 10 ** (-6)\n        else:\n            if length < e + 10 ** (-6):\n                length = e + 10 ** (-6)\n    return str(length)"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')[:-1]\n    n = int(lines[0])\n    lines = lines[1:]\n    if n == 0:\n        return 'IMPOSSIBLE'\n    lamps = []\n    x_pos = []\n    y_pos = []\n    e_pos = []\n    x_neg = []\n    y_neg = []\n    e_neg = []\n    for line in lines:\n        x, y, e = line.split(' ')\n        x = int(x)\n        y = int(y)\n        e = int(e)\n        lamps.append((x, y, e))\n        if x > x_pos[-1]:\n            x_pos.append(x)\n            y_pos.append(y)\n            e_pos.append(e)\n        elif x < x_pos[-1]:\n            x_neg.append(x)\n            y_neg.append(y)\n            e_neg.append(e)\n    if len(x_pos) == 0:\n        return 'IMPOSSIBLE'\n    # 1\n    ans = 0\n    if len(x_pos) == 1:\n        ans = e_pos[0]\n        for i in range(n):\n            ans -= e_pos[i]\n        return str(ans)\n    # 2\n    if len(x_pos) == 2:\n        ans = e_pos[0] + e_pos[1]\n        for i in range(n):\n            ans -= e_pos[i]\n        return str(ans)\n    # 3\n    # ans = e_pos[0] + e_pos[1]\n    # for i in range(n):\n    #     ans -= e_pos[i]\n    # return str(ans)\n    # 4\n    # ans = e_pos[0] + e_pos[1]\n    # for i in range(n):\n    #     ans -= e_pos[i]\n    # return str(ans)\n    # 5\n    if len(x_neg) == 0:\n        return 'IMPOSSIBLE'\n    ans = e_neg[0]\n    for i in range(n):\n        ans -= e_neg[i]\n    return str(ans)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    all_points = []\n    for i in range(n):\n        all_points.append(list(map(int, stdin.split())))\n    intersections = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if all_points[i][0] == all_points[j][0]:\n                intersections.add(all_points[i][0])\n            elif all_points[i][1] == all_points[j][1]:\n                intersections.add(all_points[i][1])\n    if len(intersections) == 0:\n        return -1\n    return len(intersections)"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = [[int(i) for i in line.split()] for line in stdin.splitlines()]\n    count = 0\n    for i in range(len(lines)):\n        for j in range(i + 1, len(lines)):\n            if lines[i][0] <= lines[j][1] and lines[j][0] <= lines[i][1]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return str(len(set(get_distinct_points_from_input_data(stdin))))\n\n\ndef"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    [x0, y0, x1, y1]\n    '''\n    from math import sqrt\n    n = int(stdin.strip())\n    points = []\n    for i in range(n):\n        x0, y0, x1, y1 = map(int, stdin.strip().split())\n        points.append([x0, y0, x1, y1])\n    def dist(a, b):\n        return sqrt((a[0]-b[0])**2+(a[1]-b[1])**2)\n    def get_intersection(p1, p2, p3, p4):\n        if dist(p1, p3) <= dist(p1, p2) and dist(p1, p2) <= dist(p1, p4) and dist(p2, p3) <= dist(p2, p4):\n            return True\n        return False\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            p1 = points[i]\n            p2 = points[j]\n            for k in range(n):\n                p3 = points[k]\n                p4 = points[(k+1)%n]\n                if get_intersection(p1, p2, p3, p4):\n                    count += 1\n    print(count)\n    return count\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    points = [(int(x), int(y)) for x, y in stdin.split()]\n    \n    intersecting_points = set()\n    touching_points = set()\n    \n    for i in range(len(points) - 1):\n        point_a = points[i]\n        for j in range(i + 1, len(points)):\n            point_b = points[j]\n            if (point_a == point_b) or (point_b in intersecting_points or point_a in intersecting_points) or (point_a in touching_points or point_b in touching_points):\n                continue\n            x_overlap = (point_a[0] > point_b[0]) and (point_a[0] <= point_b[0] + abs(point_b[0] - point_a[0]))\n            y_overlap = (point_a[1] > point_b[1]) and (point_a[1] <= point_b[1] + abs(point_b[1] - point_a[1]))\n            if x_overlap:\n                if not (point_b[1] - point_a[1]):\n                    continue\n                intersecting_points.add(point_a)\n                intersecting_points.add(point_b)\n            elif y_overlap:\n                if not (point_b[0] - point_a[0]):\n                    continue\n                intersecting_points.add(point_a)\n                intersecting_points.add(point_b)\n            touching_points.add(point_a)\n            touching_points.add(point_b)\n    touching_points = set()\n    touching_points.add(points[0])\n    touching_points.add(points[-1])\n    intersecting_points = set()\n    intersecting_points.add(points[0])\n    intersecting_points.add(points[-1])\n    \n    # for each point that is not touching any other point\n    if intersecting_points:\n        print(len(intersecting_points))\n    else:\n        print(len(touching_points))\n    return\n\nsolution(stdin)\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    points = set()\n    for _ in range(int(stdin.splitlines()[0])):\n        p0, p1 = map(int, stdin.splitlines()[1].split())\n        points.add((p0, p1))\n        points.add((p1, p0))\n    print(len(points))\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split()\n    return \"1\" if find_intersection_point(input[0], input[1]) else \"0\"\n\n\ndef"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x0,y0,x1,y1 = list(map(int, stdin.split()))\n    if x0!= x1 and y0!= y1:\n        return \"1\"\n    if x0 == x1 and y0 == y1:\n        return \"1\"\n    if x0 == x1 or y0 == y1 or x0 == y1 or y0 == x1:\n        return \"1\"\n    else:\n        return \"0\"\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num_lines = int(stdin)\n    lines = list(map(lambda x: list(map(int, stdin.split()[x])), range(4)))\n    intersections = set()\n    for i in range(num_lines - 1):\n        for j in range(i + 1, num_lines):\n            intersection = sorted([lines[i][0], lines[i][1]]) + sorted([lines[i][2], lines[i][3]]) + sorted([lines[j][0], lines[j][1]]) + sorted([lines[j][2], lines[j][3]])\n            intersections.add(intersection)\n    return str(len(intersections))\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    points = []\n    for i in range(n):\n        points.append(list(map(int, stdin.split())))\n    points = sorted(points, key=lambda x: (x[1], x[0]))\n    points_set = set()\n    for i in range(1, n):\n        if (points[i-1][1], points[i-1][0]) in points_set or (points[i][0], points[i][1]) in points_set:\n            return '-1'\n        else:\n            points_set.add((points[i-1][1], points[i-1][0]))\n            points_set.add((points[i][0], points[i][1]))\n    return str(len(points_set))"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    for i in range(1, 100000):\n        if is_hill(i):\n            count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    i = n\n    cnt = 0\n    while i >= 1:\n        if str(i) in str(n):\n            cnt += 1\n            i -= 1\n        else:\n            i -= 1\n    return str(cnt)\n"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    hill_number = stdin\n    hill_number = int(hill_number)\n    if hill_number < 1:\n        return -1\n    if hill_number >= 10 ** 18:\n        return -1\n    if is_a_hill_number(hill_number):\n        return get_n_of_positive_hill_numbers(hill_number)\n    else:\n        return -1\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    num_hill_numbers: int = 0\n    while n >= 1:\n        n_below: int = n - 1\n        n_above: int = n + 1\n        if is_hill_number(n_below):\n            num_hill_numbers += 1\n            n = n_below\n        elif is_hill_number(n_above):\n            num_hill_numbers += 1\n            n = n_above\n        else:\n            n = n - 1\n    return str(num_hill_numbers)\n\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_hill(n: int) -> bool:\n        return ''.join(sorted(list(str(n)))) == str(n)\n\n    max_n = int(stdin)\n    count = 0\n    for n in range(2, max_n):\n        if is_hill(n):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    hill_num_count = 0\n    for x in range(1, 1000000):\n        x = str(x)\n        n = int(x[0]) - int(x[1])\n        if n < 0 or n > 9:\n            continue\n        if n == int(x[1]):\n            hill_num_count += 1\n    return str(hill_num_count)\n\"\"\"\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    for _ in range(int(stdin)):\n        num = int(stdin)\n        count = 0\n        while num >= 1:\n            if num % 10 >= 2:\n                num = num // 10\n                count += 1\n            else:\n                break\n        if count > 0:\n            print(count)\n        else:\n            print(-1)\n    return \"\""
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    for i in input_list:\n        if not is_hill(int(i)):\n            print(-1)\n        else:\n            print(count_hill(int(i)))\n    return\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    hill_numbers = [str(i) for i in range(N + 1)]\n    hill_numbers.sort(key=lambda i: int(i))\n    for i in range(N):\n        if str(i + 1) in hill_numbers:\n            hill_numbers.remove(str(i + 1))\n    if not hill_numbers:\n        return -1\n    return str(len(hill_numbers))\n"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    for i in range(len(stdin)):\n        if int(stdin) < 0 or int(stdin) > 10**18:\n            return str(-1)\n        elif (i + 1) % 2 == 0 and stdin[i] < stdin[i + 1]:\n            return str(int(stdin) + 1)\n        elif (i + 1) % 2 == 1 and stdin[i] > stdin[i + 1]:\n            return str(int(stdin) + 1)\n    return str(int(stdin) + 1)"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_attacker, n_defender, n_moves, n_atk, n_def = list(map(int, stdin.split()))\n    res = 0\n\n    # Iterate from N_atk to N_def\n    for n in range(n_atk, n_def + 1):\n        if n_def > n_atk and n_def - n_atk > 1:\n            # Check for valid moves\n            move_atk = list(itertools.combinations_with_replacement([i for i in range(n_atk)], n))\n            move_def = list(itertools.combinations_with_replacement([i for i in range(n_def)], n - n_atk))\n            move_atk_set = set(map(tuple, move_atk))\n            move_def_set = set(map(tuple, move_def))\n            if (move_atk_set & move_def_set):\n                res += 1\n\n    return str(res)\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2, a3, a4, n = map(int, stdin.split())\n    n_min, n_max = 0, 10 ** 18\n\n    if n < 0 or n > 10 ** 18 or n == 1:\n        return \"0\"\n\n    max_count_for_seq = 0\n    # 3\n    for i in range(n_min, n_max + 1):\n        if a3 - a2 <= 0:\n            break\n        count_for_seq = 2\n        for j in range(i - 1, n_max + 1):\n            if j < 0:\n                break\n            if a1 - a4 <= 0:\n                break\n            if a1 <= i and i <= j:\n                if a3 - a4 <= 0:\n                    break\n                if a3 - a2 <= 0:\n                    break\n                count_for_seq += 1\n            else:\n                break\n        max_count_for_seq = max(max_count_for_seq, count_for_seq)\n\n    # 2\n    for i in range(n_min, n_max + 1):\n        if a3 - a2 <= 0:\n            break\n        count_for_seq = 2\n        for j in range(i - 1, n_max + 1):\n            if j < 0:\n                break\n            if a1 - a4 <= 0:\n                break\n            if a1 <= i and i <= j:\n                if a3 - a2 <= 0:\n                    break\n                count_for_seq += 1\n            else:\n                break\n        max_count_for_seq = max(max_count_for_seq, count_for_seq)\n\n    # 1\n    for i in range(n_min, n_max + 1):\n        count_for_seq = 2\n        for j in range(i - 1, n_max + 1):\n            if j < 0:\n                break\n            if a1 - a4 <= 0:\n                break\n            if a1 <= i and i <= j:\n                if a3 - a2 <= 0:\n                    break\n                count_for_seq += 1\n            else:\n                break\n        max_count_for_seq = max(max_count_for_seq, count_for_seq)\n\n    # 0\n    for i in range(n_min, n_max + 1):\n        count_for_seq = 2\n        for j in range(i - 1, n_max + 1):\n            if j < 0:\n                break\n            if a1 - a4 <= 0:\n                break\n            if a1 <= i and i <= j:\n                if a3 - a2 <= 0:\n                    break\n                count_for_seq += 1\n            else:\n                break\n        max_count_for_seq = max(max_count_for_seq, count_for_seq)\n\n    return str(max_count_for_seq)\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, n = map(int, stdin.split())\n    if n == 1:\n        return n * (n - 1) % (10**9 + 7)\n    ans = 0\n    for i in range(1, n):\n        if a % i == 0 and b % i == 0 and c % i == 0 and d % i == 0:\n            ans += (a // i) * (b // i) * (c // i) * (d // i)\n            ans %= (10**9 + 7)\n    return ans\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num, m, n, p, q = map(int, stdin.split())\n    count = 0\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            for k in range(1, p+1):\n                for l in range(1, q+1):\n                    if i!= k or j!= l:\n                        count += 1\n    return str(count % 1000000007)\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split()\n    a11, a12, a21, a22, n = input\n    a11 = int(a11)\n    a12 = int(a12)\n    a21 = int(a21)\n    a22 = int(a22)\n    n = int(n)\n    seq_len = 0\n    player_count = 0\n    player_counts = set()\n    for i in range(n):\n        if a11 <= a12 and a21 <= a22:\n            if (a11, a21) not in player_counts and a12 <= a22:\n                player_count += 1\n                seq_len += 1\n                player_counts.add((a11, a21))\n            else:\n                break\n        else:\n            if (a21, a11) not in player_counts and a12 <= a22:\n                player_count += 1\n                seq_len += 1\n                player_counts.add((a21, a11))\n            else:\n                break\n    return seq_len"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, Atk, Def = map(int, stdin.split())\n    attack, defend = [[0] * (N + 2)] + [[0] + list(map(int, stdin.split())) for _ in range(Atk)] + [[0] * (N + 2)]\n    seen = set()\n    ans = 0\n\n    for i in range(N, -1, -1):\n        for j in range(N, i, -1):\n            attack[i][j] = attack[i][j - 1]\n            defend[i][j] = defend[i][j - 1]\n            attack[i][j] += attack[i][j - 2]\n            defend[i][j] += defend[i][j - 2]\n\n            if attack[i][j] == 2 or defend[i][j] == 2:\n                ans += 1\n            elif (attack[i][j] == 1 or defend[i][j] == 1) and (attack[i][j - 1] == 2 or defend[i][j - 1] == 2):\n                ans += 1\n\n    return str(ans % 1000000007)"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    players = []\n    for i in range(N):\n        players.append(stdin.split()[i + 1])\n    team_of_players = {}\n    team_of_players[players[0]] = 0\n    team_of_players[players[1]] = 1\n    result = 0\n    for i in range(2, N):\n        if players[i] not in team_of_players:\n            team_of_players[players[i]] = 0\n        result += (team_of_players[players[i]]) % 1000000007\n        team_of_players[players[i]] += 1\n        team_of_players[players[i] + players[i - 1]] += 1\n    return str(result)\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(stdin.count(tuple))"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, n, d = map(int, stdin.split())\n    if a == b == c == 0 and n == d == 0:\n        return '0'\n    if a == b == c == 0:\n        return str(n ** 2)\n    if n == 0:\n        return str(a * b * c)\n    if n == 1:\n        return str((a - 1) * (b - 1) * (c - 1))\n    if n == 2:\n        return str(((a - 1) * (b - 1) * (c - 1)) +\n                   ((a - 1) * (b - 1) * (c - 2)) +\n                   ((a - 1) * (b - 2) * (c - 1)))\n    if n == 3:\n        return str(((a - 2) * (b - 1) * (c - 1)) +\n                   ((a - 1) * (b - 1) * (c - 2)) +\n                   ((a - 1) * (b - 2) * (c - 1)))\n    if n == 4:\n        return str(((a - 2) * (b - 1) * (c - 1)) +\n                   ((a - 2) * (b - 1) * (c - 2)) +\n                   ((a - 1) * (b - 1) * (c - 3)) +\n                   ((a - 1) * (b - 2) * (c - 1)))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin\n    a, b, c, d, n = input.split()\n    a = int(a)\n    b = int(b)\n    c = int(c)\n    d = int(d)\n    n = int(n)\n    print(a, b, c, d, n)\n    #     print(a, b, c, d, n)\n    #     print(a,b)\n    #     print(b,c)\n    #     print(c,a)\n    #     print(d,b)\n    #     print(b,d)\n    #     print(c,d)\n    # print(a,b,c,d)\n    # print(a,c,d)\n    # print(b,d,a)\n    # print(c,b,a)\n    # print(b,a,c)\n    # print(d,b,a)\n    # print(c,a,d)\n    # print(a,d,c)\n    # print(d,c,a)\n    # print(c,a,b)\n    # print(d,b,c)\n    # print(a,c,d)\n    # print(c,d,a)\n    # print(b,c,d)\n    # print(c,d,b)\n    # print(b,d,c)\n    # print(a,d,c)\n    # print(d,c,a)\n    # print(c,d,b)\n    # print(d,b,c)\n    # print(c,a,d)\n    # print(d,a,c)\n    # print(b,c,d)\n    # print(c,d,b)\n    # print(d,b,c)\n    # print(c,d,a)\n    # print(d,a,c)\n    # print(c,d,b)\n    # print(d,b,c)\n    # print(c,d,a)\n    # print(d,a,c)\n    # print(b,d,c)\n    # print(d,c,b)\n    # print(c,d,a)\n    # print(d,a,c)\n    # print(c,d,b)\n    # print(d,b,c)\n    # print(c,d,a)\n    # print(d,a,c)\n    # print(c,d,b)\n    # print(d,b,c)\n    # print(c,d,a)\n    # print(d,a,c)\n    # print(c,d,b)\n    # print(d,b,c)\n    # print(c,d,a)\n    # print(d,a,c)\n    # print(c,d,b)\n    # print(d,b,c)\n    # print(c,d,a)\n    # print(d,a,c)\n    # print(c,d,b)\n    # print(d,b,c)\n    # print(c,d,a)\n    # print(d,a,c)\n    # print(c,d,b)\n    # print(d,b,c)\n    # print(c,d,a)\n    # print(d,a,c)\n    # print(c,d,b)\n    # print(d,b,c)\n    # print(c,d,a)\n    # print(d,a,c)\n    # print(c,d,b)\n    "
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_b, input_t_x, input_t_y = stdin.strip().split()\n    input_b, input_t_x, input_t_y = float(input_b), float(input_t_x), float(input_t_y)\n    v_x, v_y = 0, 1\n    b, t_x, t_y = input_b, input_t_x, input_t_y\n    x, y = t_x, t_y\n    count = 0\n    while sqrt((x - t_x) ** 2 + (y - t_y) ** 2) > b:\n        if count >= 12:\n            return \"impossible\"\n        if abs(x - t_x) > abs(y - t_y):\n            x += v_x * b\n            y += v_y * b\n        else:\n            x += v_y * b\n            y -= v_x * b\n        count += 1\n    return str(x) + \" \" + str(y)"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    angles = list(map(float, stdin.split()))\n    start = (0.5, -5.301, 3.098)\n    x_start, y_start, phi = start\n    x = x_start\n    y = y_start\n    for theta in angles:\n        x, y = rotate(x, y, theta)\n    return str(round(x, 2)) + \" \" + str(round(y, 2))\ndef"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b,t_x,t_y = map(float, stdin.split())\n    r = sqrt(t_x**2 + t_y**2)\n    return '{0:.5f} {1:.5f}'.format(b * t_x, b * t_y)\n"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b = float(stdin.split()[0])\n    t_x = float(stdin.split()[1])\n    t_y = float(stdin.split()[2])\n    r = b * math.sin(math.radians(t_y))\n    phi = t_x - math.sqrt((t_x ** 2) + (t_y ** 2))\n    return str(round(r * math.cos(math.radians(phi)), 5)) +'' + str(round(r * math.sin(math.radians(phi)), 5))"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Importing and using sys library\n    import sys\n\n    # sys.stdin = open('input.txt', 'r')\n\n    # Setting the input values to a list\n    input_list = stdin.split('\\n')\n\n    # Taking the first input value\n    input_list.pop(0)\n\n    # Taking the second input value\n    input_list.pop(0)\n\n    # Converts the input list into a list of floats\n    input_list = list(map(float, input_list))\n\n    # Setting the values of b to a, t_ x and t_ y to input_list\n    a = input_list[0]\n    t_x = input_list[1]\n    t_y = input_list[2]\n\n    # Calculating the value of b\n    b = 3*a\n    # Calculating the value of r\n    r = b*t_x\n    # Calculating the value of theta\n    theta = t_y*2*3.14159265358979/360\n\n    # Calculating the value of x\n    x = r*cos(theta)\n    # Calculating the value of y\n    y = r*sin(theta)\n\n    # Checking if the distance from point to closest spiral is greater than or equal to 10^-3\n    if (sqrt(t_x**2+t_y**2)>2*a):\n        # Checking if the distance from point to closest spiral is greater than or equal to 10^-5\n        if (abs(sqrt(t_x**2+t_y**2)-2*a)>=10**-5):\n            # Checking if the distance from point to closest spiral is greater than 10^-10\n            if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-10>=0):\n                # Checking if the distance from point to closest spiral is greater than 10^-15\n                if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-15>=0):\n                    # Checking if the distance from point to closest spiral is greater than 10^-20\n                    if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-20>=0):\n                        # Checking if the distance from point to closest spiral is greater than 10^-25\n                        if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-25>=0):\n                            # Checking if the distance from point to closest spiral is greater than 10^-30\n                            if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-30>=0):\n                                # Checking if the distance from point to closest spiral is greater than 10^-35\n                                if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-35>=0):\n                                    # Checking if the distance from point to closest spiral is greater than 10^-40\n                                    if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-40>=0):\n                                        # Checking if the distance from point to closest spiral is greater than 10^-45\n                                        if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-45>=0):\n                                            # Checking if the distance from point to closest spiral is greater than 10^-50\n                                            if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-50>=0):\n                                                # Checking if the distance from point to closest spiral is greater than 10^-55\n                                                if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-55>=0):\n                                                    # Checking if the distance from point to closest spiral is greater than 10^-60\n                                                    if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-60>=0):\n                                                        # Checking if the distance from point to closest spiral is greater than 10^-65\n                                                        if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-65>=0):\n                                                            # Checking if the distance from point to closest spiral is greater than 10^-70\n                                                            if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-70>=0):\n                                                                # Checking if the distance from point to closest spiral is greater than 10^-75\n                                                                if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-75>=0):\n                                                                    # Checking if the distance from point to closest spiral is greater than 10^-80\n                                                                    if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-80>=0):\n                                                                        # Checking if the distance from point to closest spiral is greater than 10^-85\n                                                                        if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-85>=0):\n                                                                            # Checking if the distance from point to closest spiral is greater than 10^-90\n                                                                            if (abs(sqrt(t_x**2+t_y**2)-2*a)-10**-90>=0):"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n    r = (b ** 2 + t_x ** 2 + t_y ** 2) ** 0.5\n    v_x = t_x / r\n    v_y = t_y / r\n    r_x = v_x * b * t_x\n    r_y = v_y * b * t_y\n    x_1 = -b\n    y_1 = 0\n    x_2 = b\n    y_2 = 0\n    dx = -r_x\n    dy = -r_y\n    t = 0\n    while True:\n        x_1 += dx\n        y_1 += dy\n        t += 1\n        if abs(x_1) >= 0.5 * b or abs(y_1) >= 0.5 * b:\n            break\n    if abs(x_1) >= 0.5 * b or abs(y_1) >= 0.5 * b:\n        return \"Impossible\"\n    while True:\n        x_2 += dx\n        y_2 += dy\n        t += 1\n        if abs(x_2) >= 0.5 * b or abs(y_2) >= 0.5 * b:\n            break\n    if abs(x_2) >= 0.5 * b or abs(y_2) >= 0.5 * b:\n        return \"Impossible\"\n    return str(round(x_2, 5)) + \" \" + str(round(y_2, 5))\n"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Builds a series of points that will form the spiral.\n    \"\"\"\n    x, y, b = map(float, stdin.split())\n    while True:\n        x_new, y_new = (x * math.cos(y) - y * math.sin(x), x * math.sin(y) + y * math.cos(x))\n        if math.sqrt(x_new**2 + y_new**2) > b:\n            break\n        x, y = x_new, y_new\n    return f\"{x:.4f} {y:.4f}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    (b, t_x, t_y) = map(float, stdin.strip().split())\n    r = b * math.sin(t_x * math.pi / 180)\n    phi = t_y * math.pi / 180\n    d = r * math.cos(phi)\n    x = r * math.cos(phi) - d * math.cos(t_x * math.pi / 180)\n    y = r * math.sin(phi) - d * math.sin(t_y * math.pi / 180)\n    return f\"{x:.2f} {y:.2f}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n    a = b * math.tan(math.pi / 180 * t_x)\n    b = math.pi / 180 * t_y\n    c = b - math.pi / 180 * a\n    return str(round(a * c + t_x, 5)) + \" \" + str(round(b * c + t_y, 5))"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n    return \"{:.5f} {:.5f}\".format(*hittarget(b, t_x, t_y))\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rooms = []\n    for i in range(1, int(stdin[0]) + 1):\n        rooms.append([])\n    for i in range(1, int(stdin[0]) + 1):\n        rooms[i - 1] = list(map(int, stdin[i].split()))\n\n    num_of_corridors = int(stdin[0])\n    corridors = stdin[1:]\n    corridors.sort(key=lambda x: x.split()[0])\n\n    for corridor in corridors:\n        room1, room2 = map(int, corridor.split())\n        if room1 in rooms[room2 - 1]:\n            num_of_corridors -= 1\n        elif room2 in rooms[room1 - 1]:\n            num_of_corridors -= 1\n\n    return str(num_of_corridors // 2)\n\n\ndef"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.strip().split()))\n    rooms = sorted(set([i for i in range(1, n + 1)] + [i for i in range(n + 1, n * 2 + 1)]))\n    rooms_graph = {room: [] for room in rooms}\n\n    for room in rooms:\n        for room_to in rooms:\n            if room_to == room:\n                continue\n            rooms_graph[room].append(room_to)\n    corners = set(rooms[:2])\n    corners = set(corners) | set(rooms[-2:])\n    corners = set(corners) - set(rooms[1:-1])\n    corners = list(corners)\n\n    def is_cycle(i: int, j: int) -> bool:\n        i_neighbors = rooms_graph[i]\n        j_neighbors = rooms_graph[j]\n\n        common_neighbors = set(i_neighbors) & set(j_neighbors)\n        if common_neighbors:\n            return True\n        return False\n\n    def remove_corridor(corridor: int) -> int:\n        j = corridor\n        corridor_is_open = True\n        while corridor_is_open:\n            if j == corridor:\n                corridor_is_open = False\n            else:\n                if is_cycle(j, corridor):\n                    return -1\n                j = corridor\n        i = corridor\n\n        while i!= corridor:\n            if i == corridor:\n                i = corridor\n            else:\n                if is_cycle(i, corridor):\n                    return -1\n                i = corridor\n        return 0\n\n    to_remove = 0\n    for corridor in corners:\n        corridor_removed = remove_corridor(corridor)\n        if corridor_removed == -1:\n            to_remove += 1\n    print(to_remove)\n    return_val = str(to_remove)\n    for corridor in corners:\n        corridor_removed = remove_corridor(corridor)\n        if corridor_removed == -1:\n            return_val +='' + str(corridor)\n    return return_val\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    m = int(lines[1])\n    rooms = [i for i in range(n)]\n    rooms_to_corridors = {i: [] for i in rooms}\n    corridors_to_rooms = {i: [] for i in range(n)}\n    for i in range(m):\n        u, v = map(int, lines[2*i+2].split())\n        rooms_to_corridors[u].append(v)\n        corridors_to_rooms[v].append(u)\n    visited_rooms = set()\n    removals = 0\n    to_visit = deque(rooms)\n    while len(to_visit)!= 0:\n        room = to_visit.popleft()\n        visited_rooms.add(room)\n        for corridor in rooms_to_corridors[room]:\n            if corridor in visited_rooms:\n                continue\n            corridors_to_rooms[corridor].remove(room)\n            if len(corridors_to_rooms[corridor]) == 0:\n                to_visit.append(corridor)\n    removals = len(visited_rooms)\n    for room in visited_rooms:\n        rooms_to_corridors[room] = [corridor for corridor in rooms_to_corridors[room]\n                                    if corridor not in visited_rooms]\n    rooms = list(rooms_to_corridors.keys())\n    rooms.sort()\n    rooms_to_corridors = {room: corridors for room, corridors in rooms_to_corridors.items()}\n    removals += sum([len(corridors) for corridors in rooms_to_corridors.values()]) // 2\n    removals = min(removals, m // 2)\n    return str(removals)\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    rooms = []\n    for i in range(n):\n        rooms.append([i, 0])\n    graph = {i: [] for i in range(1, n+1)}\n    for i in range(m):\n        room1, room2 = map(int, stdin.split())\n        graph[room1].append(room2)\n        graph[room2].append(room1)\n    to_be_removed = 0\n    for room in range(1, n+1):\n        if room in graph.keys():\n            rooms[room][1] = 1\n            nodes_to_be_visited = set()\n            nodes_to_be_visited.add(room)\n            while True:\n                if len(nodes_to_be_visited) == 0:\n                    break\n                node = nodes_to_be_visited.pop()\n                nodes_to_be_visited = nodes_to_be_visited.union(set(graph[node]))\n            for i in range(len(rooms)):\n                if rooms[i][0] in nodes_to_be_visited:\n                    rooms[i][1] = 0\n        for i in range(len(rooms)):\n            if rooms[i][0] == room:\n                to_be_removed += 1\n    return str(to_be_removed)"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    m, n, *lst = list(map(int, stdin.split()))\n\n    adj_list = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = list(map(int, lst[_].split()))\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    rm = m // 2\n    visited = {i: False for i in range(1, n)}\n\n    def dfs(u, visited, rm):\n        visited[u] = True\n        for v in adj_list[u]:\n            if visited[v] == False:\n                if dfs(v, visited, rm) == True:\n                    return True\n            elif rm == 0:\n                return False\n        return False\n\n    res = dfs(1, visited, rm)\n    for i in range(1, n):\n        if not visited[i]:\n            print(i)\n\n    return str(res)\n\nprint(solution(input()))"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    rooms, corridors = map(int, stdin.split())\n    rooms = list(map(lambda x: x - 1, rooms))\n    corridors = list(map(lambda x: x - 1, corridors))\n    room_corridors = dict()\n    for i in range(0, len(rooms)):\n        room = rooms[i]\n        room_corridors[room] = []\n        for j in range(i + 1, len(rooms)):\n            room_corridors[room].append(rooms[j])\n    if len(room_corridors) < corridors:\n        return \"0\"\n    for room in range(0, len(rooms)):\n        if room not in room_corridors.keys():\n            room_corridors[room] = []\n        else:\n            room_corridors[room].extend(room_corridors[room + 1])\n    corridors_to_remove = set()\n    for room, corridors in room_corridors.items():\n        corridors.extend(corridors[:])\n        corridors.extend(corridors[::-1])\n        for i in range(0, len(corridors)):\n            corridor = corridors[i]\n            for j in range(i + 1, len(corridors)):\n                corridor2 = corridors[j]\n                if (corridor, corridor2) not in corridors_to_remove and (corridor2, corridor) not in corridors_to_remove:\n                    if room_corridors[room][i - 1] == corridor2:\n                        corridors_to_remove.add((corridor, corridor2))\n                    if room_corridors[room][j - 1] == corridor:\n                        corridors_to_remove.add((corridor2, corridor))\n    room_corridors_length = dict()\n    for room in room_corridors.keys():\n        room_corridors_length[room] = len(room_corridors[room])\n    for room in sorted(room_corridors_length.keys()):\n        corridors_to_remove.update(room_corridors[room])\n    return len(corridors_to_remove)"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    # print(n, m)\n    # if n == 3 and m == 2:\n    #     print(1)\n    #     return\n\n    # # First we need to find which room has the higher length\n    # len_rooms = []\n    # for i in range(n):\n    #     len_rooms.append(len(str(i + 1)))\n    # max_room = max(len_rooms)\n    # print(max_room)\n\n    # # Now we need to find which room we need to remove\n    # num_to_remove = 0\n    # while m > 0:\n    #     len_rooms = []\n    #     for i in range(n):\n    #         len_rooms.append(len(str(i + 1)))\n    #     # print(len_rooms)\n    #     max_room = max(len_rooms)\n    #     if max_room < 2:\n    #         break\n    #     num_to_remove += 1\n    #     m -= 2\n    # print(num_to_remove)\n\n    # # Now we need to remove the corridors\n    # num_to_remove = 0\n    # while m > 0:\n    #     len_rooms = []\n    #     for i in range(n):\n    #         len_rooms.append(len(str(i + 1)))\n    #     # print(len_rooms)\n    #     max_room = max(len_rooms)\n    #     if max_room < 2:\n    #         break\n    #     num_to_remove += 1\n    #     m -= 2\n    # print(num_to_remove)\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    rooms, corridors = map(int, stdin.split())\n    visited = set()\n    start = 0\n    while len(visited)!= rooms:\n        to_visit = set()\n        for i, corridor in enumerate(corridors):\n            start = corridor\n            if start in visited:\n                corridors = corridors[i+1:]\n                break\n            else:\n                to_visit.add(start)\n                visited.add(start)\n        for j in range(0, len(to_visit), 2):\n            corridors.remove(to_visit.pop())\n        for i in range(0, len(corridors), 2):\n            corridors.remove(corridors.pop())\n        corridors.append(start)\n        corridors = corridors[-2::2]\n    return str(len(corridors)//2)\n\nsolution('''3 3\n1 2\n2 3\n3 1''')\nsolution('''4 5\n1 2\n2 3\n2 4\n3 1\n4 1''')\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    # print(n, m)\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        # print(u, v)\n        adj[u].append(v)\n        adj[v].append(u)\n    # print(adj)\n\n    def find_root(x):\n        if adj[x] == []:\n            return x\n        else:\n            temp = find_root(adj[x][0])\n            for i in adj[x]:\n                if i!= temp:\n                    adj[x].remove(i)\n            adj[x] = find_root(adj[x])\n            return temp\n\n    root_nodes = []\n    for i in range(1, n+1):\n        root_nodes.append(find_root(i))\n    # print(root_nodes)\n    roots = set(root_nodes)\n    print(len(roots))\n    if len(roots) == 1:\n        print(0)\n    else:\n        for i in range(len(root_nodes)):\n            for j in range(len(root_nodes)):\n                if root_nodes[i]!= root_nodes[j] and adj[root_nodes[i]][0] == root_nodes[j] and adj[root_nodes[i]][1] == root_nodes[j]:\n                    # print(root_nodes[i], root_nodes[j])\n                    adj[root_nodes[i]].remove(root_nodes[j])\n                    adj[root_nodes[j]].remove(root_nodes[i])\n        print(len(adj[1]) - 2)\n        for i in range(1, len(adj)):\n            print(adj[i])\n        for i in range(len(adj)):\n            for j in range(len(adj[i])):\n                if adj[i][j] == root_nodes[i]:\n                    adj[i].remove(adj[i][j])\n        for i in range(len(adj)):\n            print(adj[i])\n\nsolution(stdin)\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    rooms, corridors = int(stdin.split()[0]), int(stdin.split()[1])\n    to_remove = []\n    to_remove = [True] * corridors\n    start, end = 1, rooms\n    while start!= end:\n        mid = start + (end - start) // 2\n        for corridor in range(1, corridors + 1):\n            if to_remove[corridor - 1]:\n                continue\n            room1, room2 = stdin.split()[corridor - 1]\n            room1, room2 = int(room1), int(room2)\n            if room1 == room2:\n                to_remove[corridor - 1] = False\n                break\n            if abs(room1 - room2) <= mid:\n                start = mid\n                break\n        else:\n            end = mid\n    res = (start + end) // 2\n    print(res)\n    return '\\n'.join(map(str, sorted(range(1, corridors + 1), key=lambda x: int(stdin.split()[x]))))\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, S, T = map(int, stdin.split())\n    tubes = [[] for _ in range(M + 1)]\n    for _ in range(M):\n        a, b, w = map(int, stdin.split())\n        tubes[a] += [[a, b, w]]\n        tubes[b] += [[b, a, w]]\n    heuristic = [infinity] * (N + 1)\n    heuristic[S] = 0\n    prev_node = [None] * (N + 1)\n    for _ in range(N):\n        for u in range(1, N + 1):\n            for v in tubes[u]:\n                if heuristic[u] + v[2] < heuristic[v[1]]:\n                    heuristic[v[1]] = heuristic[u] + v[2]\n                    prev_node[v[1]] = u\n    # print(heuristic)\n    # print(prev_node)\n    def get_traversal_path(u: int, v: int) -> str:\n        ans = str(v)\n        while v!= S:\n            u = prev_node[u]\n            ans += str(u)\n            v = prev_node[v]\n        return ans\n    def get_h(u: int, v: int) -> int:\n        return heuristic[u] + heuristic[v]\n    # print(get_traversal_path(S, T))\n    # print(get_h(S, T))\n    while True:\n        start = tubes[S][0][0]\n        end = tubes[S][0][1]\n        min_dist = heuristic[end] + tubes[S][0][2]\n        ans = \"\"\n        for v in tubes[S]:\n            dist = get_h(start, v[1]) + v[2]\n            if dist < min_dist:\n                min_dist = dist\n                ans = get_traversal_path(start, v[1])\n        if min_dist == infinity:\n            break\n        S = int(ans)\n        # print(ans)\n        # print(S)\n    return ans"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    (n, m, s, t), *data = stdin.split()\n    n, m, s, t = int(n), int(m), int(s), int(t)\n    data = [tuple(map(int, line.split())) for line in data]\n\n    # write your code here\n    if n == t:\n        return f\"{t}\"\n\n    times = {\n        (n, i): [0]\n        for i in range(n)\n    }\n\n    for ball in range(n):\n        for tube in range(n):\n            time = 1\n            if tube > ball:\n                continue\n            for otherTube in range(tube + 1, n):\n                if otherTube in times and ball in times[otherTube]:\n                    time = max(time, times[otherTube][-1] - times[otherTube][0])\n            times[(ball, tube)].append(time)\n\n    #print(times)\n\n    time_to_reach_t = times[(t, s)]\n\n    # find the longest running time to reach the end\n    # initialize left and right runners\n    left_runner = 0\n    right_runner = 0\n\n    # check left runner\n    for i in range(len(time_to_reach_t)):\n        if time_to_reach_t[i] > left_runner:\n            left_runner = time_to_reach_t[i]\n\n    # check right runner\n    for i in range(len(time_to_reach_t) - 1, -1, -1):\n        if time_to_reach_t[i] > right_runner:\n            right_runner = time_to_reach_t[i]\n\n    return f\"{left_runner} {right_runner}\"\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.strip().split())\n    bounds = []\n    for i in range(m):\n        bounds.append(list(map(int, stdin.strip().split())))\n    ans = float('inf')\n    for i in range(2 ** m):\n        num_tubes_visited = []\n        curr = 0\n        if (i >> 0) & 1:\n            curr = s\n        for j in range(m):\n            if i >> j & 1:\n                curr = max(curr, bounds[j][1])\n                num_tubes_visited.append(bounds[j][0])\n            else:\n                num_tubes_visited.append(bounds[j][0])\n        if curr >= t and num_tubes_visited[-1] == n - 1:\n            ans = min(ans, curr - s)\n    return str(ans)\nprint(solution(input()))\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    m = int(lines[1])\n    start, end, time = map(int, lines[2].split())\n    plastic_balls = list(range(n))\n\n    def print_graph():\n        for i in range(n):\n            print(\" \".join(map(str, plastic_balls[i])))\n\n    def print_graph_correct():\n        for i in range(n):\n            print(\" \".join(map(str, plastic_balls[i])))\n\n    def get_neighbors(i):\n        return set(plastic_balls[i]) - {i}\n\n    def get_neighbors_correct():\n        return set(plastic_balls[i]) - {i}\n\n    def is_far_enough(i):\n        return len(plastic_balls) < n\n\n    # print_graph()\n    # print_graph_correct()\n\n    def get_hamsters_to_go():\n        # This part is pretty simple.\n        # We start with the start and end point in a single direction and then move to the other\n        # two directions. If we find a ball that has a tube from the start point to it, we immediately\n        # exit the loop because we would not be able to move further.\n        #\n        # Start at start and end, each moving in a single direction\n        start = 0\n        end = start + 1\n        while start <= end < len(plastic_balls):\n            # If we find a tube connecting start to end, exit the loop\n            if plastic_balls[start] in get_neighbors(end):\n                return\n\n            # Now move in both directions\n            start += 1\n            end += 1\n\n        # If we reached here, we are done!\n        print(\"inf\")\n\n    # print_graph()\n\n    def get_hamsters_to_go_correct():\n        # This part is pretty simple.\n        # We start with the start and end point in a single direction and then move to the other\n        # two directions. If we find a ball that has a tube from the start point to it, we immediately\n        # exit the loop because we would not be able to move further.\n        #\n        # Start at start and end, each moving in a single direction\n        start = 0\n        end = start + 1\n        while start <= end < len(plastic_balls):\n            # If we find a tube connecting start to end, exit the loop\n            if plastic_balls[start] in get_neighbors_correct(end):\n                return\n\n            # Now move in both directions\n            start += 1\n            end += 1\n\n        # If we reached here, we are done!\n        print(\"inf\")\n\n    # print_graph_correct()\n\n    # print(plastic_balls)\n    # print(get_neighbors(2))\n    # print(get_neighbors_correct(2))\n    # print(is_far_enough(2))\n    get_hamsters_to_go()\n    # get_hamsters_to_go_correct()\n    return \"inf\" if is_far_enough(start) else str(time)\n\nprint(solution(input()))"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, h, s, t = (int(i) for i in stdin.split())\n    h_left = 0\n    h_right = 0\n    b = 0\n    for i in range(m):\n        tube = (int(i), int(i) + 1, int(i) + 2)\n        if tube[0] == h:\n            h_left = tube[1]\n        if tube[0] == t:\n            h_right = tube[1]\n        if tube[1] == s:\n            b = tube[2]\n    if h_left == h_right:\n        return \"infinity\"\n    else:\n        return (h_right - h_left) * (b - h_left)"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t, = map(int, stdin.split())\n    if n == s == t == 0:\n        return 'infinity'\n    elif n <= m:\n        return '-1'\n    else:\n        a = []\n        w = {}\n        for i in range(m):\n            a.append(tuple(map(int, stdin.split())))\n        a.sort()\n        for t, b, w in a:\n            if (t, b) not in w:\n                w[(t, b)] = w[(b, t)] = w[(t, t)] = 0\n            w[(t, b)] += 1\n            w[(b, t)] += 1\n        def lc(a, n):\n            res = float('inf')\n            while a:\n                t, b = a.pop()\n                res = min(res, b + w[(t, b)])\n            return res\n        def rc(a, n):\n            res = float('inf')\n            while a:\n                t, b = a.pop()\n                res = min(res, t + w[(t, b)])\n            return res\n        def lu(a, n):\n            res = float('inf')\n            while a:\n                t, b = a.pop()\n                res = min(res, t + w[(t, b)])\n            return res\n        def ru(a, n):\n            res = float('inf')\n            while a:\n                t, b = a.pop()\n                res = min(res, b + w[(t, b)])\n            return res\n        res = float('inf')\n        for u in range(n):\n            res = min(res, max(lc(a[u:], n), lc(a[:u], n), rc(a[u:], n), rc(a[:u], n), lu(a[u:], n), lu(a[:u], n), ru(a[u:], n), ru(a[:u], n)))\n        return str(res)"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    m = int(stdin.split()[1])\n    s = int(stdin.split()[2])\n    t = int(stdin.split()[3])\n    # create list of tuples (starting ball, ending ball, tube length)\n    tube_info = list()\n    for i in range(m):\n        tube_info.append((i % n, i % n, int(stdin.split()[i + 4])))\n    # create dictionary with starting ball as key and ending ball as value\n    ball_to_tube = {}\n    # initialize dictionary\n    for ball in range(n):\n        ball_to_tube[ball] = []\n    # add the tuples to the dictionary with the correct keys\n    for tube in range(len(tube_info)):\n        start, end, length = tube_info[tube]\n        ball_to_tube[start].append((tube, end, length))\n    # make a list of tubes that are active\n    active_tubes = list()\n    # get the first tube\n    start, end, length = tube_info[0]\n    active_tubes.append((tube, end, length))\n    # start moving through the tubes, deciding on a tube to travel to\n    while len(active_tubes) > 0:\n        # get the current tube\n        tube = active_tubes.pop(0)\n        # get the current ball\n        ball = tube[0]\n        # get the next ball\n        next_ball = tube[1]\n        # make sure the next tube is not active\n        if len(active_tubes) > 0:\n            # make sure the next tube is not active\n            next_tube = active_tubes.pop(0)\n            # get the next tube and the ball\n            next_end = next_tube[1]\n            if next_end == next_ball:\n                # add the current tube to the list of active tubes\n                active_tubes.append(tube)\n        # if the ball is not active, make sure it is not in the dictionary\n        if not ball in ball_to_tube.keys():\n            # add the ball to the dictionary\n            ball_to_tube[ball] = []\n        # add the tube\n        ball_to_tube[ball].append(tube)\n        # if there are no more tubes left to travel, return infinity\n        if len(active_tubes) == 0:\n            return \"infinity\"\n        # get the current tube\n        tube = active_tubes.pop(0)\n        # get the current ball\n        ball = tube[0]\n        # get the next ball\n        next_ball = tube[1]\n        # get the length of the tube\n        length = tube[2]\n        # if the ball is the start of the tube, make sure the next tube is not active\n        if next_ball == start:\n            # if the next tube is active and not in the dictionary\n            if not next_ball in ball_to_tube.keys():\n                # add the tube to the dictionary\n                ball_to_tube[next_ball] = []\n            # add the tube\n            active_tubes.append(tube)\n        # if the ball is the end of the tube, make sure the next tube is not active\n        if next_ball == end:\n            # if the next tube is active and not in the dictionary\n            if not next_ball in ball_to_tube.keys():\n                # add the tube to the dictionary\n                ball_to_tube[next_ball] = []\n            # get the next tube\n            next_tube = active_tubes.pop(0)\n            # get the next tube and the ball\n            next_end = next_tube[1]\n            # make sure the next tube is not active\n            if not next_end == next_ball:\n                # add the current tube to the list of active tubes\n                active_tubes.append(tube)\n    # return the length of the shortest list of tubes\n    return len(min(ball_to_tube.values(), key=len))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    from collections import defaultdict\n    from functools import reduce\n    from itertools import permutations\n\n    n, m, s, t = map(int, re.findall(\"\\d+\", stdin))\n    d = defaultdict(int)\n    for _ in range(m):\n        a, b, w = map(int, re.findall(\"\\d+\", stdin))\n        d[(a, b)] = w\n        d[(b, a)] = w\n    dp = {(s, t): 0}\n    for _ in range(n):\n        dp2 = defaultdict(int)\n        for x, y in dp:\n            for z, w in d.items():\n                if x == z[0] and (y == z[1] or y == z[1] - 1) and w < dp[(x, y)]:\n                    dp2[(x, y)] = max(dp2[(x, y)], dp[(x, y)] + w)\n        dp = dp2\n    return str(max(dp.values())) if len(dp) == n else \"infinity\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_interval(s: int) -> Tuple[int, int]:\n        start, end = 0, 10\n        while start + 1 < end:\n            mid = start + (end - start) // 2\n            if s == mid:\n                return mid\n            elif s < mid:\n                end = mid\n            else:\n                start = mid\n        return end, start\n\n    def hamster_travel(s: int, t: int, w: int) -> float:\n        if s == t:\n            return 0\n        else:\n            if t - s > w:\n                return 10**5\n            else:\n                return t - s + w + 1\n\n    def run(n: int, m: int, s: int, t: int) -> float:\n        if s == n:\n            return 10**5\n        else:\n            return min(\n                hamster_travel(s, t, w) + run(s, t, w) for w in range(1, 10**4)\n            )\n\n    s, t, w = list(map(int, stdin.split()))\n    return str(run(s, t, w))\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split()\n    n = int(data[0])\n    m = int(data[1])\n    a = int(data[2])\n    b = int(data[3])\n    w = list(map(int, data[4:]))\n    s = 0\n    t = n\n    h1 = s\n    h2 = t\n    tubes = {h1: [], h2: []}\n    for i in range(m):\n        h1, h2 = h2, max(h1, h2)\n        tube = int(w[i])\n        tubes[h1].append(tube)\n        tubes[h2].append(tube)\n    best = -1\n    while True:\n        for i in range(len(tubes[h1])):\n            if h1 == 0 or h1 == n:\n                best = max(best, h1)\n                break\n            elif h2 == 0 or h2 == n:\n                best = max(best, h2)\n                break\n            elif h2 == h1:\n                best = max(best, h2)\n                break\n            elif h1 == h2:\n                best = max(best, h1)\n                break\n            else:\n                h1 -= 1\n                h2 += 1\n                if h1 == 0 or h1 == n:\n                    best = max(best, h1)\n                    break\n                elif h2 == 0 or h2 == n:\n                    best = max(best, h2)\n                    break\n                elif h2 == h1:\n                    best = max(best, h2)\n                    break\n                elif h1 == h2:\n                    best = max(best, h1)\n                    break\n    return str(best)"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l, *ss = list(map(int, stdin.split()))\n    sc = set(ss[:k])\n    counts = Counter(ss[k:])\n    counts_by_col = {}\n    for c in sc:\n        if c not in counts_by_col:\n            counts_by_col[c] = 0\n        counts_by_col[c] += 1\n\n    def f(x):\n        if x == 0:\n            return 1\n        if x in counts_by_col:\n            return counts_by_col[x]\n        return f(x - 1)\n\n    def count_sc_in_l(l, sc):\n        c = 0\n        for i in range(1, l + 1):\n            if i in sc:\n                c += f(i)\n        return c\n    return (count_sc_in_l(l, sc) - count_sc_in_l(l - 1, sc)) % 1000000007\n\nprint(solution(input()))\n"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    colors = list(map(int, stdin.strip().split()))\n    colors = sorted(colors, key=lambda x: colors.count(x))\n    bigger = {x: 0 for x in colors}\n    bigger[colors[0]] = 1\n    for i in range(1, len(colors)):\n        if colors[i] == colors[i-1]:\n            bigger[colors[i]] = bigger[colors[i-1]]\n        else:\n            bigger[colors[i]] = bigger[colors[i-1]] + bigger[colors[i]]\n    ans = 0\n    for i in range(len(colors)):\n        if colors[i] in bigger:\n            ans += bigger[colors[i]]\n        else:\n            ans += bigger[colors[i]] + 1\n    return str(ans % 1000000007)\n"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    balls = list(map(int, stdin.split()))\n    balls.sort()\n    frequency = {}\n    for ball in balls:\n        if ball not in frequency:\n            frequency[ball] = 1\n        else:\n            frequency[ball] += 1\n\n    removed_balls = set()\n    result = 0\n    for i in range(len(balls)):\n        if i < k:\n            result += frequency[balls[i]]\n        else:\n            if balls[i] in removed_balls:\n                continue\n            for j in range(i-k, i):\n                if balls[j] in removed_balls:\n                    continue\n                result += frequency[balls[j]]\n                removed_balls.add(balls[j])\n    result %= 1000000007\n    return str(result)"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = stdin.split()\n    costs = [[] for _ in range(n)]\n    for i, cost in enumerate(arr):\n        costs[int(cost) - 1].append(i)\n    max_len = 0\n    for cost in costs:\n        if len(cost) == 1:\n            continue\n        s_len = len(cost)\n        cost.sort()\n        # for i in range(s_len):\n        for j in range(s_len):\n            if i == j:\n                continue\n            if cost[i] > cost[j]:\n                max_len += 1\n                break\n    return str(max_len)\n"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = [int(i) for i in stdin.split()]\n    ans = 1\n    for i in range(1,n):\n        if s[i] == s[i-1]:\n            ans = 0\n            break\n    if not ans:\n        if s[0] > 1:\n            ans += 2**n - 1\n        for i in range(1,n):\n            if s[i] == s[i-1]:\n                ans -= 1\n            if s[i] > 1:\n                ans += 2**(i-1)\n    return str(ans % 1000000007)"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k, c, s = map(int, stdin.split())\n    def dp(c, s, n):\n        cache = [[[None] * (n + 1) for _ in range(c + 1)] for _ in range(n + 1)]\n        for j in range(1, n + 1):\n            for i in range(1, n + 1):\n                if j == 1:\n                    cache[i][1][0] = 1\n                else:\n                    for i_c in range(1, c + 1):\n                        if i_c == j:\n                            for i_s in range(1, s + 1):\n                                cache[i][i_c][i_s] = cache[i][i_c - 1][i_s - 1] + cache[i - 1][i_c][i_s]\n                        else:\n                            cache[i][i_c][1] = 0\n        return cache[n][c][s]\n    return str(dp(k, n, c))\n"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    n = int(inputs[0])\n    k = int(inputs[1])\n    color_counts = list(map(int, inputs[2:]))\n    possible = list(itertools.combinations(color_counts, k))\n    count = 0\n    for i in range(len(possible)):\n        if set(possible[i]) == set(color_counts):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 3 2 1 2\n   ... 2 1 2\n   ... 2 3 4\n   ... ''')\n    '0'\n    >>> solution('''\n   ... 4 2 1 2\n   ... 2 1 2\n   ... 2 3 4\n   ... ''')\n    '6'\n    \"\"\"\n    n = int(stdin)\n    # 1. Generate a list of colors\n    colors = list(range(1, n + 1))\n    # 2. Generate a list of frequency\n    frequencies = [int(c) for c in stdin.strip().split(\"\\n\")[1].split(\" \")]\n    # 3. Generate a list of balls that are not next to each other\n    balls_without_next_to = list(range(1, n + 1))\n    for c, freq in zip(colors, frequencies):\n        if freq > 0:\n            balls_without_next_to.remove(c)\n    # 4. Generate a list of possible sequences of balls\n    possible_balls = list(product(colors, repeat=len(balls_without_next_to)))\n    # 5. Generate a set of balls that don't make any of the sequences\n    balls_without_sequence = set(balls_without_next_to)\n    # 6. Filter out the balls that don't make the sequences and add them to the set of balls to not be next to each other\n    for possible_ball in possible_balls:\n        for c in possible_ball:\n            balls_without_sequence.remove(c)\n    # 7. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_next_to_combinations = combinations(balls_without_next_to, 2)\n    balls_without_sequence.update(balls_without_next_to_combinations)\n    # 8. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 2))\n    # 9. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 3))\n    # 10. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 4))\n    # 11. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 5))\n    # 12. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 6))\n    # 13. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 7))\n    # 14. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 8))\n    # 15. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 9))\n    # 16. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 10))\n    # 17. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 11))\n    # 18. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 12))\n    # 19. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 13))\n    # 20. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 14))\n    # 21. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 15))\n    # 22. Generate a list of combinations of balls that are not next to each other and add them to the set of balls to not be next to each other\n    balls_without_sequence.update(combinations(balls_without_sequence, 16))\n    # 23. Generate a list of combinations of balls"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # balls = []\n    balls = stdin.strip().split('\\n')\n    # balls = [int(x) for x in balls]\n    balls = [[int(x) for x in s.split()] for s in balls]\n\n    counts = []\n    for i in range(1, n + 1):\n        counts.append(balls.count(i))\n\n    # print(balls)\n    # print(counts)\n\n    # sort the list first\n    counts.sort(reverse=True)\n\n    # if there are only 2 elements, then return 1\n    if len(counts) == 2:\n        return 1\n\n    # if there are more than 2 elements, then run the following checks\n    else:\n        # sort the elements in the list\n        counts.sort()\n\n        # for each element,\n        for i in range(1, len(counts)):\n            # if the first element is equal to the second element\n            if counts[0] == counts[i]:\n                # increment the count by one and skip the first element\n                counts[i] = counts[i] + counts[i - 1]\n\n                # increment the count by one and skip the second element\n                counts[i - 1] = counts[i - 1] + counts[i]\n                # print(counts)\n\n        # count = counts[0]\n        # print(count)\n        return counts[0] % 1000000007"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    balls = sorted([int(x) for x in stdin.split()])\n    res = 0\n\n    if k == 0 and m == 0:\n        res = 1\n\n    for i in range(1, n):\n        # skipballs\n        # comb\n        # ex: [0,1,2]\n        # comb(3,2) = 0, comb(3,1) = 1, comb(3,0) = 1\n        # comb(4,3) = 1\n        res += comb(n, i) * comb(k - 1, n - i) * comb(m, i) * comb(k, m - i)\n        # print(f\"{i}:{comb(n,i)}\")\n\n    return str(res % 10000007)\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        string = str(i)\n        if len(string) == 1:\n            continue\n        elif len(string) == e:\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, e = (int(i) for i in stdin.split())\n    count = 0\n    for i in range(n+1):\n        if e in str(2**i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    decimal_to_binary = {str(i): bin(i) for i in range(1, 10)}\n    n = int(stdin)\n    k = 0\n    for power_of_two in range(2**e):\n        binary_number = decimal_to_binary[str(2**power_of_two)]\n        if binary_number in stdin:\n            k += 1\n    return str(k)"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, e = stdin.split()\n    count = 0\n    for i in range(1, int(n)):\n        if (int(e)) % 2 == 0:\n            str = str(i)\n            if int(str) ** 2 == int(n):\n                count += 1\n        else:\n            str = str(i)\n            if int(str) > int(n):\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Your code should return a single integer that is the number of numbers\n    that have the specified property.\n\n    *   **Note:** if the given number is not a power of $2$ then your program should return 0.\n\n    *   **Input Format**: The first line contains a single integer $n$ and a single integer $e$.\n    *   **Output Format**: Return a single integer denoting the number of distinct integers that have the\n    specified property.\n\n    *   **Example Input**:\n    *   ```\n    *   1000000 1\n    *   ```\n    *   **Example Output**:\n    *   ```\n    *   468559\n    *   ```\n\n    *   **Constraints**: $0 \\le n \\le 9 \\cdot 10^{18}, 0 \\le e \\le 62$\n    \"\"\"\n\n    # Your code here\n\n    # My solution\n\n    # def check_power(s):\n    #     power = 0\n    #     for i in range(len(s)):\n    #         if int(s[i]) == 2:\n    #             power = power + 1\n    #     return power\n\n    # def num_power_2(n, e):\n    #     return len([n for n in range(1, n) if check_power(str(n)) >= e])\n\n    # print(num_power_2(int(stdin[0]), int(stdin[1])))\n\n    # Best Practice\n\n    # def num_power_2(n, e):\n    #     return sum(int(n) == 2 ** i for i in range(e))\n\n    # print(num_power_2(int(stdin[0]), int(stdin[1])))\n\n    # Best Practice 2\n\n    # def num_power_2(n, e):\n    #     return sum(len([n]) >= e for i in range(n - e, n + 1) if i == 2 ** i)\n\n    # print(num_power_2(int(stdin[0]), int(stdin[1])))\n\n    # Best Practice 3\n\n    # def num_power_2(n, e):\n    #     return sum(len([n]) == 2 ** i for i in range(e))\n\n    # print(num_power_2(int(stdin[0]), int(stdin[1])))\n\n    # Sample Input 3:\n    # 9000000000000000000 62\n    # Sample Output 3:\n    # 1\n    # --------------------------------------\n    # My solution\n\n    # def num_power_2(n, e):\n    #     return len([n for n in range(1, n) if int(str(n)) == 2 ** e])\n\n    # print(num_power_2(int(stdin[0]), int(stdin[1])))\n\n    # Best Practice\n\n    # def num_power_2(n, e):\n    #     return sum([int(n) == 2 ** e])\n\n    # print(num_power_2(int(stdin[0]), int(stdin[1])))\n\n    # Best Practice 2\n\n    # def num_power_2(n, e):\n    #     return sum([len([n]) == 2 ** e])\n\n    # print(num_power_2(int(stdin[0]), int(stdin[1])))\n\n    # Best Practice 3\n\n    # def num_power_2(n, e):\n    #     return sum([int(n) == 2 ** e])\n\n    # print(num_power_2(int(stdin[0]), int(stdin[1])))\n    return len([n for n in range(1, int(stdin[0])) if int(str(n)) == 2 ** int(stdin[1])])\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x,y = map(int, stdin.split())\n    res = 0\n    for i in range(1,x+1):\n        s = str(2**y)\n        if s.count(str(2**y)) > 0:\n            res += 1\n    return str(res)\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    return str(len(set(str(n**e).split('0')).difference({''})))\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Get and parse the input\n    # Using stdin.readline() reads one line at a time\n    n, e = map(int, stdin.split())\n    # Convert the input integers into string\n    num = str(n)\n    # Parse the decimal representation of the input numbers into an array\n    # And find the elements whose decimal representation contains a substring of $2^e$\n    res = []\n    for i in range(len(num)):\n        if num[i] == '2':\n            sub = num[i:]\n            if '2' in sub:\n                res.append(int(sub))\n    print(len(res))\n    return str(len(res))"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(' ')\n    n = int(input_list[0])\n    e = int(input_list[1])\n    return str(len(list(filter(lambda x: (2**x).isdigit(), map(int, (bin(2**e)).split('0b')[1:])))))\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    number_of_powers_of_two = 0\n    for number in range(1,10**18):\n        if number >= 10**16:\n            continue\n        number_of_powers_of_two += 1 if number % 10**e == 2**e else 0\n    return str(number_of_powers_of_two)\nprint(solution(input()))\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    roll = sorted(map(int, stdin.split()))\n\n    cur_roll = 1\n    cur_total = 0\n    res = 1\n    while cur_roll <= K:\n        cur_total += roll[cur_roll - 1]\n        if cur_total <= T:\n            res = max(res, cur_roll)\n        cur_roll += 1\n    return str(res)\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    l, r, t, k = (0, 1, 0, 0)\n    while l <= r:\n        m = (l+r) >> 1\n        n = get_num(stdin, m)\n        if n < t:\n            l = m+1\n        else:\n            r = m-1\n        k = max(k, m)\n    return k\ndef"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    K, T = [int(i) for i in stdin.split()]\n    dice = list(map(int, stdin.split()[1:]))\n    dice_count = len(dice)\n\n    dp = [[0] * (K + 1) for _ in range(dice_count + 1)]\n    dp[0][1] = 1\n\n    for dice_index in range(1, dice_count + 1):\n        for dice_size in range(1, K + 1):\n            for k in range(1, min(dice_size + 1, K) + 1):\n                dp[dice_index][dice_size] = max(dp[dice_index][dice_size], dp[dice_index - 1][k - 1] + dp[dice_index - 1][dice_size - k])\n\n    return str(dp[dice_count][K])\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    dice_set = list(map(int, lines[1].split()))\n    target = int(lines[2])\n    num_dice = int(lines[0])\n    possible_sums = set()\n    for dice in range(1, num_dice + 1):\n        possible_sums.add(sum(dice_set[:dice]))\n    return str(min(possible_sums, key=lambda x: abs(x - target)))\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    _, _, k, t = stdin.split()\n    k, t = int(k), int(t)\n    candidates = []\n    for x in range(k):\n        for y in range(k):\n            for z in range(k):\n                for w in range(k):\n                    for v in range(k):\n                        for u in range(k):\n                            for b in range(k):\n                                candidate = (x, y, z, w, v, u, b)\n                                if sum(candidate) == t:\n                                    candidates.append(candidate)\n    candidates.sort()\n    print(candidates[0][0] + candidates[0][1] + candidates[0][2] + candidates[0][3] + candidates[0][4] + candidates[0][5] + candidates[0][6])\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lst = list(map(int, stdin.split()))\n    dice_sum = lst[0]\n    target_sum = lst[1]\n    dice_lst = lst[2:]\n    for dice_size in range(1, dice_sum+1):\n        dice_lst_sorted = sorted(dice_lst, reverse=True)\n        total = 0\n        for dice_num in dice_lst_sorted:\n            total += dice_num\n            if total >= target_sum:\n                return str(dice_size)\n            else:\n                continue\n    return str(dice_lst_sorted[0])"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    t = 0\n    while n > 0:\n        t += k\n        n -= k\n        k = 6 if k == 6 else 2\n    return str(t)"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Fill this in.\n    k, t = list(map(int, stdin.split()))\n\n    # Get all dice rolls\n    dice_rolls = list(map(int, stdin.split()))\n    dice_rolls.sort()\n    dice_counts = collections.defaultdict(int)\n\n    # Count occurrences of each number\n    for dice in dice_rolls:\n        dice_counts[dice] += 1\n\n    # Find max number of dice that can be picked up\n    max_dice = 0\n    max_possible = 0\n    for i in range(1, 7):\n        # Number of dice that will be used\n        cnt = dice_counts[i]\n        # Number of dice that can be used in addition\n        num_add = cnt + (k-1)\n        # Number of dice that can be used in addition\n        num_sub = cnt - (k-1)\n        # Number of dice that can be used in addition\n        max_possible = max(max_possible, num_add * (cnt - 1) + num_sub)\n        max_dice = max(max_dice, num_add)\n    return str(max_dice)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, T = map(int, stdin.split())\n    dice = sorted(list(map(int, stdin.split())))\n\n    def roll(a: list) -> int:\n        total = 0\n        targets = sorted(a)\n        for i, num in enumerate(targets):\n            if i == 0:\n                total += num\n            else:\n                total += num + a[i - 1]\n        return total\n\n    best = 0\n    for i in range(1, len(dice) + 1):\n        total = roll([dice[j] for j in range(len(dice)) if j % i == 0])\n        if total >= T:\n            best = max(best, i)\n    return str(best)\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Using dynamic programming\n    \"\"\"\n    K, T = map(int, stdin.split())\n    dice = list(map(int, stdin.split()))\n    dp = [[0 for _ in range(K+1)] for _ in range(T+1)]\n    dp[0][0] = 1\n    for t in range(T+1):\n        for k in range(1, K+1):\n            # rolling a number with k dice\n            for d in range(1, k+1):\n                # rolling a number with d dice\n                if t-d >= 0:\n                    dp[t][k] += dp[t-d][k-d]\n    return str(dp[T][K])\n"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    data = list(map(int, stdin.split()[1]))\n    \n    res = 0\n    for i in range(1, N):\n        if data[i-1] == 1:\n            continue\n        dp = {}\n        for j in range(i):\n            if data[j] in dp:\n                dp[data[j]] = max(dp[data[j]], i - j)\n            else:\n                dp[data[j]] = i - j\n        res = max(res, sum(dp.values()))\n    return str(res)"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    S = list(map(int, stdin.split()))\n\n    # \ucd1d \uac1c\uc218\uac00 \uace0\ub824\ud558\uc9c0 \uc54a\uc544\ub3c4 \ub418\ubbc0\ub85c \ub515\uc154\ub108\ub9ac\ub97c \uc0ac\uc6a9\n    # \ub515\uc154\ub108\ub9ac\ub97c \uc774\uc6a9\ud574\uc11c \uc790\uc2e0\uc758 \uce5c\uad6c\ub4e4\uc744 \uc800\uc7a5\ud55c\ub2e4.\n    # \uce5c\uad6c : \uce5c\uad6c \uc120\uc218\uac00 \uac16\uace0 \uc788\ub294 \uacf3\uc758 \uce5c\uad6c \uc120\uc218 \uc218\n    # \uc120\uc218 : \uce5c\uad6c \uc120\uc218 \uc218\n    # \uce5c\uad6c \uc218 : \uc120\uc218 \uc218\n    dic = {}\n    for i in range(len(S)):\n        dic[i] = 1\n\n    for i in range(len(S)):\n        if i+1 in dic:\n            dic[i+1] += 1\n        else:\n            dic[i+1] = 1\n\n    result = []\n    for i in range(len(dic)):\n        result.append(len(dic)-1-i)\n\n    return str(max(result))\n"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.strip().split(' ')\n    N = int(a[0])\n    primes = a[1].split(' ')\n    prime_list = []\n    for p in primes:\n        p = int(p)\n        prime_list.append(p)\n    prime_list = sorted(prime_list)\n    n = len(prime_list)\n    max_revenue = 0\n    i = 0\n    while i < n:\n        if prime_list[i] > N:\n            i += 1\n            continue\n        num_factors = 2\n        i += 1\n        factors = set()\n        while True:\n            if num_factors * prime_list[i] > N:\n                break\n            if prime_list[i] in factors:\n                break\n            else:\n                factors.add(prime_list[i])\n                num_factors += 1\n        revenue = num_factors\n        max_revenue = max(max_revenue, revenue)\n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = sorted(map(int, stdin.split()))\n    ans = 0\n    for i in range(1, n):\n        ans = max(ans, (s[i] - s[i - 1]) * s[i])\n    return str(ans)"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin)\n    data: list = list(map(int, stdin.split()))\n\n    primes = {}\n    for i in data:\n        for p in prime_factors(i):\n            if p not in primes:\n                primes[p] = 1\n            else:\n                primes[p] += 1\n\n    max_revenue: int = 0\n    for i in range(len(primes)):\n        if primes[i] > 1:\n            revenue = 0\n            for j in range(len(data)):\n                revenue += primes[i] * data[j]\n            max_revenue = max(max_revenue, revenue)\n\n    return str(max_revenue)\n"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    primes = [1,2,3,5]\n    sum = int(stdin.strip())\n    num_in_base_10 = (sum // 10) + 1\n    num_in_base_2 = (sum % 10) + 1\n    primes_sum = (2*(sum+1)) - sum\n    print(primes_sum)\n    if primes_sum <= sum:\n        return primes_sum\n    for i in range(4,num_in_base_10):\n        if primes_sum == sum:\n            return i\n        primes_sum = primes_sum - primes[num_in_base_10-i-1]\n    return sum\n    \n"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    S = list(map(int, stdin.split()[1]))\n    primes = list(primes(N))\n\n    for i in range(1, N):\n        for j in range(i, N):\n            if count_divisors(S[i] + S[j]) in primes:\n                #print(S[i], S[j], S[i] + S[j])\n                break\n\n    print(S[i] + S[j])\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    factors = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i * j < n:\n                factors[i * j] += 1\n    total = 0\n    for i in range(1, n + 1):\n        if i not in factors:\n            continue\n        total += i * factors[i]\n    return str(total)"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = sorted(list(map(int, stdin.split())))\n    cnt = 0\n    for i in range(n - 1, -1, -1):\n        if s[i] == 0:\n            continue\n        for j in range(i + 1, n):\n            if s[j] % s[i]!= 0:\n                break\n        else:\n            cnt += s[i]\n    return str(cnt)"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    primes = list(map(int, stdin.split()))\n    # \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0438\u043d\u0434\u0435\u043a\u0441\u043e\u0432 \u043f\u0440\u043e\u0441\u0442\u044b\u0445 \u0447\u0438\u0441\u0435\u043b\n    indices = []\n    for i in range(N):\n        indices.append(0)\n        while primes[i] % 2 == 0:\n            indices[i] += 1\n            primes[i] //= 2\n        if i >= 2:\n            while primes[i] % 3 == 0:\n                indices[i] += 1\n                primes[i] //= 3\n        if i >= 1:\n            while primes[i] % 5 == 0:\n                indices[i] += 1\n                primes[i] //= 5\n    # \u043f\u043e\u0438\u0441\u043a \u0441\u0443\u043c\u043c\u044b \u043f\u0440\u043e\u0441\u0442\u044b\u0445 \u0447\u0438\u0441\u0435\u043b\n    primesum = 0\n    for i in range(N):\n        if indices[i] == 0:\n            primesum += primes[i]\n    # \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\n    result = 0\n    for i in range(N):\n        result += indices[i] * primes[i]\n    return result\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for i in range(1, 1001):\n        for j in range(1, 1001):\n            for k in range(1, 1001):\n                if k*i+j*(i-1)+k*(i-1)==N:\n                    return str(k)\n    return \"-1\"\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N % 2 == 0:\n        if N < 99:\n            return str(N)\n        else:\n            return str(N // 2)\n    else:\n        if N < 99:\n            return str(int(str(N)[0]) * int(str(N)[1]))\n        else:\n            a = str(int(str(N)[0]) + 1) + str(int(str(N)[1]))\n            if int(a) > 99:\n                return str(int(str(N)[0]) * int(str(N)[1]))\n            else:\n                return str(int(a))\n    return '1' if N % 2 else '0'"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N <= 1:\n        return '-1'\n    digits = len(str(N))\n    i = digits - 1\n    while i >= 0:\n        # i is the number of the digits in N.\n        if N % (10 ** i) > 0:\n            break\n        i -= 1\n    if i < 0:\n        return '-1'\n    N = N // (10 ** i)\n    answer = int(N)\n    while N > 0:\n        N, i = divmod(N, 10)\n        answer = (answer * 10) + i\n    return str(answer)\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    num = str(N)\n    num = num[::-1]\n    carry = 0\n    for i in range(len(num)):\n        carry = int(num[i]) + carry\n    if carry == 0:\n        return str(N)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 0:\n        return '-1'\n    if N < 10:\n        return '-1'\n    if N >= 10:\n        digits = [int(i) for i in stdin]\n    if 10 not in digits:\n        return '-1'\n    digits.sort()\n    if digits[0] > 1:\n        return str(digits[0] * digits[1])\n    else:\n        return str(digits[0])"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for i in range(1, N):\n        if N % i == 0:\n            return str(i)\n    return str(-1)\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N = lines[0]\n    N = int(N)\n    \n    for i in range(1,25):\n        for j in range(1,25):\n            if i*j == N:\n                print(i)\n                print(j)\n                return\n    print(-1)\nsolution(input())\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    digits = stdin.split()\n    n = int(digits[0])\n    print(min(a*a for a in range(n,0,-1)))\n    return "
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    max = 9999999\n    min = 0\n    while min < max:\n        mid = (min + max) // 2\n        if mid * mid == N:\n            return str(mid)\n        elif mid * mid < N:\n            min = mid + 1\n        else:\n            max = mid - 1\n    return str(-1)\n\nsolution(input())\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    x = N\n    while x > 0:\n        if x % 10!= 0:\n            break\n        x //= 10\n    while x > 0:\n        if x % 10 == 0:\n            break\n        x //= 10\n    if x == 0:\n        return str(-1)\n    if x == N:\n        return str(x)\n    a = 1\n    while a <= x:\n        b = a\n        while b < x:\n            if a * b > N:\n                break\n            b *= a\n        a += 1\n    return str(a - 1)\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D, N = map(int, stdin.split())\n    l = ord('z') - ord('a')\n    ALPHABET = list(map(chr, range(ord('a'), ord('z') + 1)))\n\n    def m_f(words):\n        return len(max(words, key=len))\n\n    def a_c(words):\n        return sorted(words, key=lambda w: w[0])\n\n    def b_a(words):\n        return sorted(words, key=lambda w: w[1])\n\n    def c_a(words):\n        return sorted(words, key=lambda w: w[2])\n\n    def a_c_d(words):\n        return sorted(words, key=lambda w: w[1] + w[2])\n\n    def adcb_a_c(words):\n        return sorted(words, key=lambda w: w[0] + w[1] + w[2])\n\n    def caa_b_c(words):\n        return sorted(words, key=lambda w: w[0] + w[1] + w[2])\n\n    def b_a_c(words):\n        return sorted(words, key=lambda w: w[1] + w[2])\n\n    def a_a_d(words):\n        return sorted(words, key=lambda w: w[0] + w[1] + w[2])\n\n    def c_b_d(words):\n        return sorted(words, key=lambda w: w[2] + w[1])\n\n    def b_d_c(words):\n        return sorted(words, key=lambda w: w[2] + w[1])\n\n    def d_c_b(words):\n        return sorted(words, key=lambda w: w[1] + w[2])\n\n    ALPHABET_ORDERING = {\n        'a': a_a_d,\n        'b': b_a,\n        'c': c_a,\n        'd': d_c_b,\n        'e': e_c_d,\n        'f': f_c_d,\n        'g': g_c_b,\n        'h': h_c_b,\n        'i': i_a_c,\n        'j': j_b_c,\n        'k': k_a_c,\n        'l': l_b_a,\n       'm': m_f,\n        'n': n_a_c,\n        'o': o_c_d,\n        'p': p_b_d,\n        'q': q_e_d,\n        'r': r_f_d,\n       's': s_g_d,\n        't': t_i_d,\n        'u': u_h_d,\n        'v': v_i_d,\n        'w': w_a_d,\n        'x': x_e_d,\n        'y': y_e_d,\n        'z': z_f_d,\n        'a': a_c_d,\n        'b': b_c_d,\n        'c': c_c_d,\n        'd': d_c_b,\n        'e': e_a_c,\n        'f': f_a_c,\n        'g': g_a_c,\n        'h': h_a_c,\n        'i': i_a_c,\n        'j': j_a_c,\n        'k': k_a_c,\n        'l': l_a_c,\n       'm': m_f,\n        'n': n_a_c,\n        'o': o_a_c,\n        'p': p_a_d,\n        'q': q_a_d,\n        'r': r_a_d,\n       's': s_a_d,\n        't': t_a_d,\n        'u': u_a_d,\n        'v': v_a_d,\n        'w': w_a_d,\n        'x': x_a_d,\n        'y': y_a_d,\n        'z': z_a_d,\n        'a': a_adcb,\n        'b': b_adcb,\n        'c': c_adcb,\n        'd': d_adcb,\n        'e': e_adcb,\n        'f': f_adcb,\n        'g': g_adcb,\n        'h': h_adcb,\n        'i': i_adcb,\n        'j': j_adcb,\n        'k': k_adcb,\n        'l': l_adcb,\n       'm': m_adcb,\n        'n': n_adcb,\n        'o': o_adcb,\n        'p': p_adcb,\n        'q': q_adcb,\n        'r': r_adcb,\n       's': s_adcb,\n        't': t_adcb,\n        'u': u_adcb,\n        'v': v_adcb,\n        'w': w_adcb,\n        'x': x_adcb,\n        'y': y_adcb,\n        'z': z_adcb,\n    }\n\n    ALPHABET_ORDERING_VARIABLES = {\n        'a': a_adcb,\n        'b': b_adcb,\n        'c': c_adcb,\n        'd': d_adcb,\n        'e': e_adcb,\n        'f': f_adcb,\n        'g': g_adcb,\n        'h': h_adcb,\n        'i': i_adcb,\n        'j': j_adcb,\n        'k': k_adcb,\n        'l': l_adcb,\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    first_input = stdin.split()\n    if len(first_input)!= 2:\n        raise ValueError(\"Wrong input\")\n    alphabet = list(string.ascii_lowercase)\n    length, data = int(first_input[0]), first_input[1:]\n    min_len = min(length, len(alphabet))\n    if min_len == len(data):\n        return \"\".join(sorted(data))\n    else:\n        return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    if stdin == '':\n        return ''\n    if len(stdin.splitlines())!= 2:\n        return 'IMPOSSIBLE'\n    words = stdin.splitlines()\n    ordered_words = []\n    for word in words:\n        ordered_words.append(''.join(sorted(word)))\n    if ''.join(sorted(stdin.splitlines()[0])) == ordered_words[0]:\n        return ordered_words[0]\n    return 'AMBIGUOUS'\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    l = ord('b') - ord('a')\n    a = bytearray(range(l, l + 26))\n    n = int(stdin.split()[0])\n    strings = stdin.split()[1:]\n    ans = []\n    for s in strings:\n        s = set(s)\n        is_ok = True\n        for c in s:\n            if c > ord('z'):\n                continue\n            if c < ord('a') or c > l + ord('z'):\n                is_ok = False\n                break\n        if not is_ok:\n            continue\n        if len(s) < n:\n            continue\n        if len(s) > n:\n            return \"IMPOSSIBLE\"\n        ans.append(s)\n    if len(ans) == 0:\n        return \"IMPOSSIBLE\"\n    ans = sorted(ans, key=lambda s: (s, sum(ord(c) - ord('a') for c in s)))\n    return ''.join(a[ord(c) - ord('a')] for c in ans[0])\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return \"\".join(sorted(stdin.strip().split())) if \"\".join(sorted(stdin.strip().split()))!= \"IMPOSSIBLE\" else \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    res = 'IMPOSSIBLE'\n    s = stdin.strip().split('\\n')\n    f = lambda x, y: x < y\n    n = int(s.pop(0))\n    words = sorted(s, key=lambda x: sorted(list(x), key=lambda y: ''.join(sorted(y, key=lambda a: a.lower()))))\n    res = words[0] if (words[0] == words[1]) else 'IMPOSSIBLE'\n    return res\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    alphabet = {chr(c): c for c in range(ord('a'), ord('z') + 1)}\n    for _ in range(int(stdin.split()[1])):\n        string = stdin.split()[2]\n        if not is_string_consistent_with_the_alphabet(string, alphabet):\n            return \"IMPOSSIBLE\"\n    return \"\".join(sorted(string) for string in alphabet.keys())\n\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return '' if consistent(stdin) else 'IMPOSSIBLE'\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split())\n    data = [stdin.strip() for stdin in stdin.splitlines()]\n\n    # build dictionary that maps each letter to a set of characters that are the prefix of the letter\n    # e.g. in \"cab\", c = {a,b,c}, a = {a}, b = {b}, and c = {c}\n    # so the dictionary looks like this:\n    # letter: prefix_set\n    #  'a': {'a'}, 'b': {'a'}, 'c': {'a', 'b'}\n    letter_prefix = {}\n    for letter in string.ascii_lowercase:\n        letter_prefix[letter] = set()\n    for data_str in data:\n        for letter in data_str:\n            letter_prefix[letter].add(data_str)\n\n    # build dictionary that maps each letter to a set of characters that are the prefix of its reverse\n    # e.g. in \"cab\", b = {b,c}, a = {a,c}, and c = {c}\n    # so the dictionary looks like this:\n    # letter: prefix_set\n    #  'a': {'a'}, 'b': {'b'}, 'c': {'c'}\n    letter_prefix_rev = {}\n    for letter in string.ascii_lowercase:\n        letter_prefix_rev[letter] = set()\n    for data_str in data:\n        for letter in data_str[::-1]:\n            letter_prefix_rev[letter].add(data_str[::-1])\n\n    # build dictionary that maps each letter to its reverse to its prefix\n    # e.g. in \"cab\", a = {b,c}, and b = {a,c}, and c = {a}\n    # so the dictionary looks like this:\n    # letter: prefix_set\n    #  'a': {'c'}, 'b': {'a'}, 'c': {'b', 'a'}\n    letter_prefix_rev_rev = {}\n    for letter in string.ascii_lowercase:\n        letter_prefix_rev_rev[letter] = set()\n    for data_str in data:\n        for letter in data_str:\n            letter_prefix_rev_rev[letter].add(data_str[::-1])\n\n    # build dictionary that maps each letter to its reverse to its reverse to its prefix\n    # e.g. in \"cab\", a = {c,b}, and c = {a,b}, and b = {a}\n    # so the dictionary looks like this:\n    # letter: prefix_set\n    #  'a': {'b'}, 'b': {'a'}, 'c': {'b', 'a'}\n    letter_prefix_rev_rev_rev = {}\n    for letter in string.ascii_lowercase:\n        letter_prefix_rev_rev_rev[letter] = set()\n    for data_str in data:\n        for letter in data_str:\n            letter_prefix_rev_rev_rev[letter].add(data_str[::-1])\n\n    # if any of the letters of the data is not in the alphabet, return IMPOSSIBLE\n    # if there are any conflicts, return AMBIGUOUS\n    # otherwise, return the alphabetically ordered set of letters\n    # and remove duplicates in the set\n    for letter in string.ascii_lowercase:\n        if letter not in letter_prefix:\n            return \"IMPOSSIBLE\"\n        if letter not in letter_prefix_rev:\n            return \"IMPOSSIBLE\"\n        if letter not in letter_prefix_rev_rev:\n            return \"IMPOSSIBLE\"\n        if letter not in letter_prefix_rev_rev_rev:\n            return \"IMPOSSIBLE\"\n\n    # for each letter, try to find the prefix set that contains its letter\n    # if there is a conflict, return AMBIGUOUS\n    # otherwise, return the alphabetically ordered set of letters and remove duplicates\n    for letter in string.ascii_lowercase:\n        # find prefix set that contains this letter\n        letter_prefix_set = letter_prefix[letter]\n        # find prefix set that contains its reverse\n        letter_prefix_set_rev = letter_prefix_rev[letter]\n        # find prefix set that contains its reverse to its reverse\n        letter_prefix_set_rev_rev = letter_prefix_rev_rev[letter]\n        # find prefix set that contains its reverse to its reverse to its reverse\n        letter_prefix_set_rev_rev_rev = letter_prefix_rev_rev_rev[letter]\n\n        # if this letter is not in the prefix set, return IMPOSSIBLE\n        if letter not in letter_prefix_set:\n            return \"IMPOSSIBLE\"\n        if letter not in letter_prefix_set_rev:\n            return \"IMPOSSIBLE\"\n        if letter not in letter_prefix_set_rev_rev:\n            return \"IMPOSSIBLE\"\n        if letter not in letter_prefix_set_rev_rev_rev:\n            return \"IMPOSSIBLE\"\n\n        # if the prefix set contains the reverse of the reverse of the letter, return AMBIGUOUS\n        if letter in letter_prefix_set_rev_rev_rev and letter in letter_prefix_set_rev:\n            return \"IMPOSSIBLE\"\n\n        # if the prefix set contains the reverse of the letter, return AMBIGUOUS\n        if letter in letter_prefix_set_rev and letter in letter_prefix_set:\n            return \"IMPOSSIBLE\"\n\n        # if the prefix set contains the letter, return the alphabetically ordered set\n        if letter in letter_prefix_set:\n            letter_prefix_set = set(letter_prefix_set)\n            letter_prefix_set.discard(letter)\n            letter_prefix_set = sorted(letter_prefix_set"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    L = stdin[0]\n    N = stdin[1]\n    alphabet = {x: i for i, x in enumerate(string.ascii_lowercase)}\n    if all(letter in alphabet for letter in L):\n        return \"\".join(sorted(L))\n    else:\n        return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''2 3 3 3\n   ... 3\n   ... 1\n   ... 2\n   ... 1\n   ... 2\n   ... 2\n   ... 2\n   ... 2\n   ... ''')\n    9\n    \"\"\"\n    pass"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(answer(int(stdin)))\n\ndef"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, n = stdin.split(\" \")\n    a = int(a)\n    b = int(b)\n    c = int(c)\n    n = int(n)\n    a = a * n\n    b = b * n\n    c = c * n\n    a, b, c = max(a, b, c), min(a, b, c), a + b + c\n    print(a, b, c)\n    return str(a + b + c)\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    return str(max(A*N, (N - (A*N) % C)*B, (A*N + (N - (A*N) % C)*B)) // (N - (A*N) % C))"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = list(map(int, stdin.split()))\n    return str(max(A * 2 + B * 3 + C * 2 - 1, A * 2 + B * 3 + C * 2))"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    N, A, B, C = int(stdin[0]), int(stdin[1]), int(stdin[2]), int(stdin[3])\n    ans = 0\n    while A + B + C!= 0:\n        for x in range(3):\n            if A > 0:\n                A -= 1\n            elif B > 0:\n                B -= 1\n            elif C > 0:\n                C -= 1\n            else:\n                break\n            ans += 1\n    return str(ans)"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, n = stdin.split()\n    a, b, c, n = int(a), int(b), int(c), int(n)\n    a = a + b + c\n    b = a // n\n    c = a % n\n    print(b)\n    return b\n    # return str(a) + \" \" + str(b) + \" \" + str(c) + \" \" + str(n)"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = stdin.split()\n    return f'{int(n) * int(a) * int(b) * int(c)}'\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    a_cnt = b_cnt = c_cnt = 0\n    for i in range(n):\n        if i % 3 == 0:\n            a_cnt += a\n        if i % 3 == 1:\n            b_cnt += b\n        if i % 3 == 2:\n            c_cnt += c\n    return str(min(a_cnt, b_cnt, c_cnt))\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = stdin.strip().split()\n    return max(int(A), int(B), int(C))\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 4 3 3\n   ... 0 1\n   ... 1 0\n   ... -1 0\n   ... 0 -1\n   ... -1 1 -2\n   ... -1 -1 2\n   ... 0 -1 0\n   ... ''')\n    'no'\n    >>> solution('''\n   ... 3 2 3\n   ... 0 1\n   ... 1 2\n   ... -1 2\n   ... 0 -1\n   ... -1 1 -2\n   ... -1 -1 2\n   ... 0 -1 0\n   ... ''')\n    'yes'\n    >>> solution('''\n   ... 4 3 3\n   ... 0 1\n   ... 1 2\n   ... -1 2\n   ... 0 -1\n   ... -1 1 -2\n   ... -1 -1 2\n   ... 0 -1 0\n   ... ''')\n    'yes'\n    >>> solution('''\n   ... 1 1\n   ... 1 0\n   ... 1 0\n   ... ''')\n    'yes'\n    >>> solution('''\n   ... 1 1\n   ... 0 0\n   ... ''')\n    'yes'\n    >>> solution('''\n   ... 1 1\n   ... 0 0\n   ... 0 0\n   ... ''')\n    'yes'\n    >>> solution('''\n   ... 1 1\n   ... 0 0\n   ... 1 1\n   ... ''')\n    'yes'\n    >>> solution('''\n   ... 1 1\n   ... 1 0\n   ... ''')\n    'no'\n    \"\"\"\n    from collections import deque\n    data = deque([list(map(int, stdin.split()))])\n    pairs = []\n    while data:\n        candle, x, y = data.popleft()\n        if (x, y) not in pairs:\n            pairs.append((x, y))\n            for x_, y_ in ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)):\n                if 0 <= x_ < len(data[0]) and 0 <= y_ < len(data[0]) and data[0][x_][y_] == 0:\n                    data.append((data[0][x_][y_], x_, y_))\n    candles = 0\n    for i in range(len(data)):\n        for j in range(len(data[0])):\n            if data[i][j] == 0:\n                candles += 1\n    if candles % 2!= 0:\n        return 'no'\n    for i in range(len(data)):\n        for j in range(len(data[0])):\n            if data[i][j] == 0:\n                if i + 1 < len(data) and data[i + 1][j] == 0 and \\\n                        j + 1 < len(data[0]) and data[i][j + 1] == 0 and \\\n                        i + 1 < len(data) and data[i + 1][j + 1] == 0 and \\\n                        j - 1 >= 0 and data[i][j - 1] == 0 and \\\n                        i - 1 >= 0 and data[i - 1][j] == 0 and \\\n                        i - 1 >= 0 and data[i - 1][j - 1] == 0:\n                    return 'yes'\n    return 'no'\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    x, y = map(int, stdin.split())\n    candles = [(x_, y_) for x_, y_ in map(int, stdin.split())]\n    candles.sort()\n\n    start = candles[0][0]\n    end = candles[len(candles) - 1][0]\n    mid = (start + end) / 2\n    remain = candles[:]\n\n    def check_candle(candle):\n        if candle[0] - mid <= 0 < candle[0] or candle[0] - mid >= 0:\n            return False\n        if candle[1] - mid <= 0 < candle[1] or candle[1] - mid >= 0:\n            return False\n        return True\n\n    def cut(candle, n):\n        if not n:\n            return True\n        if check_candle(candle):\n            return False\n        for i in range(len(candles)):\n            candle_x, candle_y = candle\n            other_candle = remain[i]\n            if (candle_x, candle_y) == other_candle:\n                continue\n            if (candle_x - other_candle[0]) % 2!= 0:\n                continue\n            if (candle_y - other_candle[1]) % 2!= 0:\n                continue\n            if (candle_x, candle_y) == other_candle:\n                if cut(other_candle, n - 1):\n                    return True\n            else:\n                if cut(other_candle, n - 1):\n                    return True\n        return False\n\n    return \"yes\" if cut((x, y), n) else \"no\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    circles = set()\n    candles = set()\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        candles.add((x, y))\n        circles.add((x, y))\n        circles.add((-x, -y))\n    candles = list(candles)\n    candles.sort()\n    points = [[None] * len(candles)] * len(candles)\n    for i, j in enumerate(candles):\n        points[i][0] = j\n    for i in range(len(candles)):\n        for j in range(1, len(candles)):\n            p = points[i][j]\n            if p[0]!= p[1]:\n                x = (circles[i][0] * (circles[j][1] - p[1]) + circles[j][0] * (p[1] - circles[i][1])) / (p[0] - circles[i][0])\n                y = (circles[i][1] - x) * circles[i][0] + circles[i][1]\n                if ((circles[i][0] - x) ** 2 + (circles[i][1] - y) ** 2) < r ** 2:\n                    points[i][j] = (x, y)\n    for i in range(len(candles)):\n        for j in range(1, len(candles)):\n            p = points[i][j]\n            if p[0]!= p[1]:\n                if (candles[i][0] - candles[j][0]) ** 2 + (candles[i][1] - candles[j][1]) ** 2 <= r ** 2:\n                    if (candles[i][0] - candles[j][0]) ** 2 + (candles[i][1] - candles[j][1]) ** 2 <= (p[0] - circles[i][0]) ** 2 + (p[1] - circles[i][1]) ** 2:\n                        return \"no\"\n                    else:\n                        return \"yes\"\n    return \"no\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = (int(_) for _ in stdin.split())\n    points = [[int(_) for _ in stdin.split()[1:]] for _ in range(n)]\n    cuts = []\n    for point in points:\n        for x in range(-r, r + 1):\n            for y in range(-r, r + 1):\n                if (x ** 2 + y ** 2 <= r ** 2):\n                    cuts.append((x, y, (-point[0] * x) + (-point[1] * y),))\n\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1]))\n    cuts = sorted(cuts, key=lambda x: (x[2], x[3]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16], x[17]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16], x[17], x[18]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16], x[17], x[18], x[19]))\n    cuts = sorted(cuts, key=lambda x: (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16], x[17], x[18], x[19], x[20]))\n    cuts = sorted(cuts, key=lambda x: ("
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inputs = (\n        list(map(lambda x: list(map(int, x.split())), stdin.splitlines()))\n    )\n    n, m, r = inputs[0]\n    candles = inputs[1]\n    cuts = inputs[2:]\n    for cut in cuts:\n        if cut[0]**2 + cut[1]**2 > r**2:\n            print(\"no\")\n            return\n    divs = []\n    for cand in candles:\n        for cut in cuts:\n            if cand[0] - cand[1] * cut[0] - cand[1] * cut[1] + cand[0] * cut[2] == 0:\n                divs.append(cand)\n    divs.sort(key=lambda x: (x[0], x[1]))\n    if divs.count(divs[0]) > n:\n        print(\"no\")\n        return\n    divs = []\n    for cand in candles:\n        for cut in cuts:\n            if cand[0] - cand[1] * cut[0] - cand[1] * cut[1] + cand[0] * cut[2] == 0:\n                divs.append(cand)\n    divs.sort(key=lambda x: (x[0], x[1]))\n    if divs.count(divs[0]) > m:\n        print(\"no\")\n        return\n    return \"yes\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = list(map(int, stdin.split()))\n    candles = list(map(int, stdin.split()))\n    for i in range(n):\n        candles[i] = (-candles[i], candles[i])\n    candles.sort()\n    candles = [tuple(x) for x in candles]\n    candles = sorted(candles)\n    cuts = []\n    for i in range(m):\n        cuts.append(tuple(list(map(int, stdin.split()))))\n    cuts.sort()\n    cuts = sorted(cuts)\n    count = 0\n    for j in range(m):\n        cut = cuts[j]\n        for i in range(n):\n            if candles[i][0] > cut[0] or candles[i][1] > cut[1]:\n                break\n        else:\n            count += 1\n    if count == m:\n        return \"yes\"\n    return \"no\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    candles = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        candles.append((x, y))\n    c = (r**2 - sum(candles)**2)**0.5\n    if c > m:\n        return 'no'\n    ans = 'yes'\n    for a, b, c in (map(int, stdin.split()) for _ in range(m)):\n        p = c - (a * c - b * b)**0.5\n        if p < 0 or (p >= 0 and p + a >= r or p + b >= r):\n            return 'no'\n        else:\n            ans = 'no' if p == 0 else 'no'\n    return ans\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = list(map(int, stdin.split()))\n    return \"yes\" if n == r and n % 2!= 0 and m % 2 == 0 else \"no\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.strip().split())\n    candles = []\n    for _ in range(n):\n        x, y = list(map(int, stdin.strip().split()))\n        candles.append((x, y))\n\n    # We can check if the candles are in the right position for a candidate cut line\n    # by using the distance formula\n    candidate_cut_line = None\n    for candidate_cut_line_a in range(1, 1001):\n        for candidate_cut_line_b in range(1, 1001):\n            candidate_cut_line_c = candidate_cut_line_a * candidate_cut_line_b\n            candidate_cut_line = candidate_cut_line_a, candidate_cut_line_b, candidate_cut_line_c\n            if abs(candidate_cut_line_a) < 10 ** -4 and abs(candidate_cut_line_b) < 10 ** -4:\n                break\n            distance_sum = 0\n            for x, y in candles:\n                distance_sum += abs(x * candidate_cut_line_a + y * candidate_cut_line_b + candidate_cut_line_c)\n            if distance_sum <= r:\n                break\n        if distance_sum <= r:\n            break\n\n    # If we find a candidate cut line which works, we can start dividing the cake\n    if candidate_cut_line is not None:\n        candles = sorted(candles, key=lambda x: x[1])\n        divided_candles = []\n        candle_x, candle_y = candles[0]\n        divided_candle = None\n        candles_on_right = 0\n        for x, y in candles:\n            candle_x, candle_y = x, y\n            if x > candle_x:\n                candles_on_right += 1\n            if candles_on_right == m:\n                divided_candle = x, y\n                break\n\n        candles = sorted(candles, key=lambda x: x[0])\n        candles = candles[1:]\n\n        candle_x, candle_y = divided_candle\n        candles_on_right = 0\n        divided_candles = []\n        candle_x, candle_y = candles[0]\n        candles_on_right += 1\n        for x, y in candles:\n            candle_x, candle_y = x, y\n            if x < candle_x:\n                candles_on_right += 1\n            if candles_on_right == m:\n                divided_candle = x, y\n                break\n\n        candle_x, candle_y = divided_candle\n        candles_on_right = 0\n        divided_candles = []\n        candle_x, candle_y = candles[0]\n        candles_on_right += 1\n        for x, y in candles:\n            candle_x, candle_y = x, y\n            if x > candle_x:\n                candles_on_right += 1\n            if candles_on_right == m:\n                divided_candle = x, y\n                break\n\n        candle_x, candle_y = divided_candle\n        candles_on_right = 0\n        divided_candles = []\n        candle_x, candle_y = candles[0]\n        candles_on_right += 1\n        for x, y in candles:\n            candle_x, candle_y = x, y\n            if x < candle_x:\n                candles_on_right += 1\n            if candles_on_right == m:\n                divided_candle = x, y\n                break\n\n        candle_x, candle_y = divided_candle\n\n        candle_x_a, candle_y_a = candle_x, candle_y\n        candle_x_b, candle_y_b = candle_x, candle_y\n        while abs(candle_x_a) < 10 ** -4 and abs(candle_y_a) < 10 ** -4:\n            candle_x_a += candidate_cut_line_a\n            candle_y_a += candidate_cut_line_b\n        while abs(candle_x_b) < 10 ** -4 and abs(candle_y_b) < 10 ** -4:\n            candle_x_b += candidate_cut_line_a\n            candle_y_b += candidate_cut_line_b\n        if (abs(candle_x_a) < 10 ** -4 and abs(candle_y_a) < 10 ** -4) and (abs(candle_x_b) < 10 ** -4 and abs(candle_y_b) < 10 ** -4):\n            return \"yes\"\n        else:\n            return \"no\"\n\n    return \"no\"\n"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Read a input string s of up to 10^6 digits.\n\n    We can split s into two or more contiguous substrings, whose parts form a palindrome. More precisely, we say that strings $s_0, s_1, \\dots, s_{k-1}$ form a palindrome if $s_ i = s_{k-1-i}$ for all $0\\leq i < k$.\n\n    Return the minimal value of $k$ such that it is possible to split s into $k$ consecutive palindrome substrings.\n    '''\n    start = 0\n    end = 0\n    while end < len(stdin):\n        if stdin[start] == stdin[end]:\n            start += 1\n            end += 1\n        else:\n            break\n    \n    if end == len(stdin):\n        return 0\n\n    max_palindrome = 1\n    for i in range(1, end):\n        if stdin[i] == stdin[start]:\n            max_palindrome = max(max_palindrome, 1 + solution(stdin[i+1:end]))\n\n    return max_palindrome\n\nsolution(input())\n"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin\n    k = len(data)\n    palindrome = False\n    while k > 1:\n        for i in range(0, k, 2):\n            if data[i]!= data[k - 1 - i]:\n                palindrome = False\n                break\n            else:\n                palindrome = True\n        if palindrome:\n            break\n        k = k - 1\n    if palindrome:\n        return f\"{k}\"\n    else:\n        return f\"{0}\""
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_string = stdin\n    n = len(input_string)\n\n    if n == 1:\n        print(1)\n        return\n\n    all_palindromes = []\n\n    for i in range(n):\n        palindromes = []\n        input_string_part = input_string[i:n]\n        j = 0\n        while i + j < n:\n            palindrome = True\n            for k in range(j, n):\n                if input_string_part[k]!= input_string[i + k]:\n                    palindrome = False\n                    break\n            if palindrome:\n                palindromes.append(input_string_part[j:k + 1])\n            j += 1\n        if len(palindromes) == 0:\n            break\n        all_palindromes.append(palindromes)\n\n    for i in range(len(all_palindromes)):\n        all_palindromes[i] = \"\".join(all_palindromes[i])\n    print(len(all_palindromes))\n    return\n"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    memo = [[-1 for _ in range(n)] for _ in range(n)]\n    def check(start, end, k):\n        if memo[start][end]!= -1:\n            return memo[start][end]\n        if start == end:\n            return start + 1\n        if k == 1:\n            return 1\n        for i in range(start, end):\n            if stdin[start] == stdin[i]:\n                if check(start, i, k - 1) == (start + 1):\n                    memo[start][end] = i + 1\n                    return i + 1\n        memo[start][end] = -1\n        return -1\n\n    return str(check(0, n - 1, k))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    stdin = stdin.strip()\n    # check if palindrome\n    for k in range(len(stdin),0,-1):\n        if stdin == stdin[::-1]:\n            return k\n    return 1\n    \n"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def isPalindrome(string: str) -> bool:\n        if len(string) == 0:\n            return True\n        if len(string) == 1:\n            return True\n        if len(string) == 2:\n            return string[0] == string[1]\n        if len(string) == 3:\n            return string[0] == string[2] and string[1] == string[2]\n        if len(string) == 4:\n            return string[0] == string[3] and string[1] == string[2] and string[2] == string[3]\n        if len(string) == 5:\n            return string[0] == string[4] and string[1] == string[3] and string[2] == string[4] and string[3] == string[4]\n        if len(string) == 6:\n            return string[0] == string[5] and string[1] == string[4] and string[2] == string[5] and string[3] == string[4] and string[4] == string[5]\n        if len(string) == 7:\n            return string[0] == string[6] and string[1] == string[5] and string[2] == string[4] and string[3] == string[3] and string[4] == string[5] and string[5] == string[6]\n        if len(string) == 8:\n            return string[0] == string[7] and string[1] == string[6] and string[2] == string[5] and string[3] == string[4] and string[4] == string[5] and string[5] == string[6] and string[6] == string[7]\n\n    def findMax(string: str, k: int) -> int:\n        if len(string) == 0:\n            return 0\n        if k == 1:\n            return len(string)\n        if len(string) == 1:\n            return 1\n        if k == 2:\n            if string[0] == string[1]:\n                return 2\n            else:\n                return 1\n        if k == 3:\n            if string[0] == string[1] and string[1] == string[2]:\n                return 3\n            else:\n                return 2\n        if k == 4:\n            if string[0] == string[3] and string[1] == string[2] and string[2] == string[3]:\n                return 4\n            else:\n                return 3\n        if k == 5:\n            if string[0] == string[4] and string[1] == string[3] and string[2] == string[4] and string[3] == string[4]:\n                return 5\n            else:\n                return 4\n        if k == 6:\n            if string[0] == string[5] and string[1] == string[4] and string[2] == string[5] and string[3] == string[4] and string[4] == string[5]:\n                return 6\n            else:\n                return 5\n        if k == 7:\n            if string[0] == string[6] and string[1] == string[5] and string[2] == string[4] and string[3] == string[3] and string[4] == string[5] and string[5] == string[6]:\n                return 7\n            else:\n                return 6\n        if k == 8:\n            if string[0] == string[7] and string[1] == string[6] and string[2] == string[5] and string[3] == string[4] and string[4] == string[5] and string[5] == string[6] and string[6] == string[7]:\n                return 8\n            else:\n                return 7\n        if k == 9:\n            if string[0] == string[8] and string[1] == string[7] and string[2] == string[6] and string[3] == string[5] and string[4] == string[4] and string[5] == string[5] and string[6] == string[6] and string[7] == string[7]:\n                return 9\n            else:\n                return 8\n        if k == 10:\n            if string[0] == string[9] and string[1] == string[8] and string[2] == string[7] and string[3] == string[6] and string[4] == string[5] and string[5] == string[4] and string[6] == string[5] and string[7] == string[6] and string[8] == string[7]:\n                return 10\n            else:\n                return 9\n        if k == 11:\n            if string[0] == string[10] and string[1] == string[9] and string[2] == string[8] and string[3] == string[7] and string[4] == string[6] and string[5] == string[5] and string[6] == string[4] and string[7] == string[3] and string[8] == string[2] and string[9] == string[1]:\n                return 11\n            else:\n                return 10\n        if k == 12:\n            if string[0] == string[11] and string[1] == string[10] and string[2] == string[9] and string[3] == string[8] and string[4] == string[7] and string[5] == string[6] and string[6] == string[5] and string[7] == string[4] and string[8] == string[3] and string[9] == string[2] and string[10] == string[1]:\n                return 12\n            else:\n                return 11\n        if k == 13:\n            if string[0] == string[12] and string[1] == string[11] and string[2] == string[10] and string[3] == string[9] and string[4] == string[8] and string[5] == string[7] and string[6] == string[6] and string[7] == string[5] and string[8] == string[4] and string[9] == string[3] and string[10] == string[2] and string[11] == string[1]:\n                return 13\n            else:\n                return 12\n        if k == 14:\n            if string[0] == string[13] and string[1] == string[12] and string[2] == string[11] and string[3] == string[10] and string[4] == string[9] and string[5] == string[8] and string[6] == string[7] and string[7] == string[5] and string[8] == string[4] and string[9] == string[3] and string[10] == string[2] and string[11] == string[1]:\n                return 14\n            else:\n                return 13\n        if k == 15:\n            if string[0] == string[14] and string[1] == string[13] and string[2] == string[12] and string[3] == string[11] and string[4] == string[10] and string[5] == string[9] and string[6] == string[8] and string[7] == string[7] and string[8] == string[6] and string[9] == string[5] and string[10]"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    if s == s[::-1]:\n        return 0\n    max_len = 1\n    for i in range(2, len(s) + 1):\n        if s[:i] == s[:i][::-1]:\n            j = i\n            while j <= len(s) - 1:\n                if s[j] == s[j - i]:\n                    j += 1\n                else:\n                    break\n            max_len = max(max_len, j - i + 1)\n    return max_len\n"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n   ...\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    print(len(stdin))\n    print(stdin)\n    if len(stdin) <= 1:\n        return len(stdin)\n    max_palindrome = []\n    for i in range(1, len(stdin)):\n        if len(stdin[i-1:i+1]) > len(max_palindrome):\n            max_palindrome = stdin[i-1:i+1]\n    return max_palindrome"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, m = stdin.split()\n    n = int(n)\n    m = int(m)\n    villages = {}\n    roads = {}\n    for i in range(n-1):\n        a, b = stdin.split()\n        villages[int(a)] = int(b)\n        villages[int(b)] = int(a)\n        roads[int(a), int(b)] = int(roads.get(int(a), 0)) + 1\n        roads[int(b), int(a)] = int(roads.get(int(b), 0)) + 1\n    steal = 0\n    for k, v in roads.items():\n        steal = max(steal, villages[k[1]] - villages[k[0]])\n    return str(steal)\nprint(solution(input()))\n"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    data = stdin.split('\\n')\n    t = data.pop(0)\n    n, m = map(int, t.split())\n    v = list(map(int, data.pop(0).split()))\n    c = list(map(int, data.pop(0).split()))\n    gold = list(map(int, data.pop(0).split()))\n    max_gold = 0\n    # print(n, m, v, c)\n    # print(gold)\n    # print(max_gold)\n    return str(max_gold)"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    f = int(stdin)\n    if f == 0:\n        return \"0\"\n    return str(max(1, 2 * f * (f - 1) // 2))\n\nstdin = \"\"\nfor i in range(int(input())):\n    stdin += input()\nprint(solution(stdin))\n"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = list(map(int, stdin.split()))\n    for i in range(1, n):\n        roads.append(roads[i - 1] + i)\n    roads.append(roads[-1] + n)\n    roads.sort()\n    total = 0\n    for i in range(0, len(roads) - 1):\n        if roads[i] <= roads[i + 1] - 1:\n            total += roads[i + 1] - roads[i] - 1\n    return str(total)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    a, b = [], []\n    gold = 0\n    for i in range(1, n + 1):\n        gold += int(stdin.strip().split()[i - 1])\n    return str(gold)\n\n\nprint(solution(input()))"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    g = list(map(int, stdin.split()))\n\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # initialize dp[0][0] = 0\n    for i in range(1, n + 1):\n        dp[i][0] = 0\n        dp[i][i] = g[i - 1]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + g[i - 1])\n\n    return str(dp[n][m])\n"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    g = [*map(int, stdin.split())]\n    V = {i: i for i in range(1, n+1)}\n    V_castle = {1: 0}\n    taken = {i: [] for i in range(2, n)}\n    for i in range(m):\n        u, v = map(int, stdin.split())\n        V[u] = v\n    def dfs(castle):\n        nonlocal V_castle\n        nonlocal taken\n        if castle in taken:\n            return 0\n        if len(taken[castle]) == len(V)-1:\n            return 0\n        if V_castle[castle] > 0:\n            return V_castle[castle]\n        V_castle[castle] = max(V_castle[castle], dfs(V[castle]))\n        for v in V[castle]:\n            if v!= castle:\n                if v not in taken[castle]:\n                    taken[castle].append(v)\n                    dfs(v)\n                V_castle[castle] = max(V_castle[castle], V_castle[v] + V_castle[castle])\n                taken[castle].remove(v)\n        return V_castle[castle]\n    return str(dfs(1))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    What this means:\n        1. read in the input string\n        2. turn it into a list of integers\n        3. map those integers to strings in a dictionary\n        4. go through the map and write out the result\n    '''\n    # 1. read in the input string\n    input_string = stdin.strip()\n    input_strings = input_string.split()\n    # 2. turn it into a list of integers\n    list_of_integers = []\n    for item in input_strings:\n        list_of_integers.append(int(item))\n    # 3. map those integers to strings in a dictionary\n    dict_of_integers = {}\n    for idx in range(1, len(list_of_integers), 2):\n        # make a key that is the integer and a value that is a string that says 'key:value'\n        dict_of_integers[list_of_integers[idx]] = str(list_of_integers[idx - 1] + ':' + list_of_integers[idx])\n    # 4. go through the map and write out the result\n    result = 0\n    for key in dict_of_integers:\n        result += int(dict_of_integers[key])\n    #print(dict_of_integers)\n    return result\n\nprint(solution('1 1 2 3 3 4 4 1'))\nprint(solution('3 3'))\n"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    gold = list(map(int, stdin.strip().split()))\n    path = defaultdict(list)\n    for i in range(n - 1):\n        path[i + 1].append(i + 1)\n    for i in range(n - 1, 0, -1):\n        path[i].append(i)\n    p = 0\n    for j in range(m):\n        p += gold[j]\n        path[gold[j]].append(gold[j])\n    c = 0\n    for i in range(1, n + 1):\n        if gold[i - 1] in path[i] and gold[i] in path[i]:\n            c += p\n            break\n    return str(c)"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    villages = [i for i in range(1, n + 1)]\n    roads = [(i, j) for i in villages for j in villages if i!= j]\n    distances = {i: 0 for i in villages}\n    gold = {i: int(j) for i, j in map(lambda x: x.split(), stdin.split())}\n    for village in villages:\n        for road in roads:\n            if village == road[0]:\n                distances[village] += gold[village]\n            elif village == road[1]:\n                distances[village] += gold[village]\n    max_amount = 0\n    for village, dist in distances.items():\n        if dist >= n - 1:\n            max_amount = max(max_amount, gold[village] + distances[village])\n    return str(max_amount)\n"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = list(map(int, stdin.split()))\n    arr = sorted(arr)\n    index = 0\n    while index < len(arr):\n        i = index\n        j = index\n        while j < len(arr) - 1:\n            if arr[i] <= arr[j + 1]:\n                index += 1\n                j += 1\n            else:\n                break\n        if index == i:\n            index += 1\n        else:\n            print(arr[i])\n            break\n    return ''"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.split()\n    max_length = int(line[0])\n    sequence = line[1]\n    sequence_list = list(map(int, sequence.split(' ')))\n    if len(sequence_list) < 2:\n        return '-1'\n    sequence_list.sort()\n    count = 1\n    critical_elements = []\n    for num in sequence_list:\n        if count == 1:\n            critical_elements.append(num)\n            count += 1\n        else:\n            if num > critical_elements[-1]:\n                critical_elements.append(num)\n            else:\n                count = 1\n                critical_elements = []\n                critical_elements.append(num)\n    critical_elements.sort()\n    return''.join(critical_elements)\n"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    critical_elements = []\n    sequence = []\n    for i in range(1, n + 1):\n        sequence.append(i)\n    while len(sequence) > 0:\n        index = sequence.index(min(sequence))\n        critical_elements.append(sequence.pop(index))\n    critical_elements.sort()\n    if critical_elements[-1] == -1:\n        return \"-\"\n    return \",\".join(str(x) for x in critical_elements)"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    l = list(map(int, stdin.split()))\n    if l[0] <= 2:\n        return '-1'\n    l.sort()\n    n = len(l)\n    dp = []\n    for i in range(n):\n        dp.append([0]*n)\n    dp[0][0] = 1\n    for i in range(1, n):\n        for j in range(i):\n            if l[i] > l[j]:\n                dp[i][j] = max(dp[i-1][j]+1, dp[i-1][j+1])\n            elif l[i] < l[j]:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j+1])\n            else:\n                dp[i][j] = dp[i-1][j]\n    return str(l[n-1])"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    l = list(map(int, stdin.split()))\n    c = list()\n    res = list()\n    for i in range(1, l[0] + 1):\n        c.append(True)\n    c[0] = False\n    for i in range(1, l[0] + 1):\n        if not c[i - 1]:\n            for j in range(i + 1, l[0] + 1):\n                c[j] = False\n                if c[j - i] and i in l[1:]:\n                    res.append(i)\n    if res == []:\n        return '-1'\n    else:\n        return''.join([str(i) for i in sorted(res)])\n"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = list(map(int, stdin.split()))\n\n    dp = [0 for i in range(n)]\n    ans = []\n    dp[0] = 1\n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] < arr[i] and dp[i] < dp[j]:\n                dp[i] = dp[j]\n        dp[i] += 1\n        if dp[i] > dp[i - 1]:\n            ans.append(i)\n    print(' '.join(map(str, ans)))\n    return''.join(map(str, ans))\n"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = list(map(int, stdin.split()))\n    dp = []\n    for i in range(n):\n        dp.append(1)\n        for j in range(i):\n            if s[j] < s[i] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    for i in range(n - 1, -1, -1):\n        if dp[i] == n:\n            return str(-1)\n    return''.join(map(str, dp))"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    l = len(stdin[0])\n    res = []\n    for i in range(1, len(stdin)):\n        arr = stdin[i]\n        arr.sort()\n        if arr == stdin[i-1]:\n            continue\n        else:\n            res.append(arr[0])\n    if len(res) == 0:\n        return \"-1\"\n    else:\n        return''.join(map(str, res))"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = stdin.split()\n    sequence.sort()\n    def dp(sequence):\n        table = []\n        for i in range(len(sequence)):\n            table.append([0] * len(sequence))\n            table[i][i] = True\n        # Dynamic Programming\n        for i in range(len(sequence)):\n            for j in range(i):\n                if sequence[i] > sequence[j] and table[j+1][i] == True:\n                    table[j+1][i] = True\n        return table\n    \n    def helper(table, sequence):\n        # Base cases\n        if len(sequence) == 0:\n            return []\n        if len(sequence) == 1:\n            return sequence\n        \n        # Recursive cases\n        results = []\n        results.append(sequence[0])\n        for i in range(1, len(sequence)):\n            if table[i-1][i] == True and table[i-1][i-1] == True:\n                results.append(sequence[i])\n                # Backtracking\n                for k in range(i-2, -1, -1):\n                    if table[k+1][i] == True:\n                        results.append(sequence[k])\n                        break\n        return results\n        \n    table = dp(sequence)\n    return \" \".join(helper(table, sequence))\n\nprint(solution(\"5 2 1 3 4\"))"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    #your code here\n    seq = stdin\n    n = len(seq)\n    dp = [[0 for j in range(n)] for i in range(n)]\n    for i in range(1, n):\n        for j in range(i):\n            if seq[j] < seq[i]:\n                dp[i][j] = max(dp[i][j], dp[j][i] + 1)\n    critical = []\n    for i in range(n):\n        if dp[i][i] == n - 1:\n            critical.append(i + 1)\n    if critical:\n        return \",\".join([str(c) for c in critical])\n    else:\n        return \"-1\"\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.strip().split())\n    return str(w * h - (h * w - w * h) * 2)\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    paper = stdin.split()\n    min_nubs = 1\n    for i in range(len(paper)):\n        mark = paper[i]\n        mark = mark.replace(\"#\", \".\")\n        while len(mark) > 1:\n            mark = mark[1:]\n            mark = mark.replace(\".\", \"#\")\n            if len(mark) > min_nubs:\n                min_nubs = len(mark)\n    return str(min_nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return '{}'.format(int(min(map(lambda x: 2, count_marked(stdin)))))\n\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    s = stdin.strip()\n    r = (h - 2) // 2\n    c = (w - 2) // 2\n    nubs = 0\n    for i in range(r, h, 2):\n        for j in range(c, w, 2):\n            if s[i][j] == '#':\n                nubs += 1\n    return str(nubs)"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_mark(mark: str) -> tuple[int, int]:\n        count = 0\n        n = 0\n        for i in range(len(mark)):\n            if mark[i] == \"#\":\n                count += 1\n            else:\n                n = i\n                break\n        return count, n\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    m = int(lines[1])\n    mark = lines[2]\n    result = 1\n    while True:\n        count, n = get_mark(mark)\n        result = max(result, count)\n        if count == 1:\n            break\n        mark = mark[:n] + mark[n+1:]\n    return str(result)"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    return str\n    '''\n    n, m, p = stdin.split('\\n')\n    n = int(n)\n    m = int(m)\n    p = int(p)\n    board = [[0] * int(m) for _ in range(int(n))]\n    \n    for i in range(int(n)):\n        s = stdin.split('\\n')[i + 1]\n        for j in range(int(m)):\n            board[i][j] = int(s[j])\n            \n    def row(r):\n        for i in range(int(m)):\n            yield i, board[r][i]\n    \n    def col(c):\n        for i in range(int(n)):\n            yield i, board[i][c]\n    \n    def squares(r, c):\n        for r1, r2 in zip(range(r, r + int(m) + 1), range(r + 1, r + int(m) + 2)):\n            for c1, c2 in zip(range(c, c + int(m) + 1), range(c + 1, c + int(m) + 2)):\n                yield r1, c1, r2, c2\n                \n    def answer(board):\n        for i in range(int(n)):\n            for j in range(int(m)):\n                if board[i][j] == p:\n                    return i + 1 + j\n        return -1\n    \n    def move(board):\n        for i in range(int(n)):\n            for j in range(int(m)):\n                if board[i][j] == p:\n                    for r, c in row(i):\n                        if board[r][c] == p:\n                            board[i][j] = 0\n                            board[r][c] = 0\n                            continue\n                    for c, r in col(j):\n                        if board[r][c] == p:\n                            board[i][j] = 0\n                            board[r][c] = 0\n                            continue\n                    for r, c, r2, c2 in squares(i, j):\n                        if board[r][c] == p:\n                            board[i][j] = 0\n                            board[r][c] = 0\n                            continue\n    \n    def check(board):\n        for i in range(int(n)):\n            for j in range(int(m)):\n                if board[i][j] == p:\n                    return False\n        return True\n    \n    def delete(board, r, c, r2, c2):\n        board[r][c] = 0\n        board[r2][c2] = 0\n        \n    def backtrack(board, i, j, r1, c1, r2, c2):\n        if i < 0 or j < 0 or i >= int(n) or j >= int(m) or board[i][j]!= 0 or board[r2][c2]!= 0:\n            return\n        for r, c in row(i):\n            backtrack(board, r, c, r1, c1, r2, c2)\n        for c, r in col(j):\n            backtrack(board, r, c, r1, c1, r2, c2)\n        for r, c, r2, c2 in squares(i, j):\n            backtrack(board, r, c, r1, c1, r2, c2)\n    \n    if answer(board)!= -1:\n        return str(answer(board))\n    else:\n        for i in range(int(n)):\n            for j in range(int(m)):\n                if board[i][j] == 0:\n                    board[i][j] = p\n                    move(board)\n                    if check(board):\n                        return str(answer(board))\n                    backtrack(board, i, j, i, j, i, j)\n                    board[i][j] = 0\n        return str(-1)\n    \n    return str(answer(board))"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    board = [[] for _ in range(n)]\n    for i in range(m):\n        row = stdin.split()[i + 1]\n        for j, x in enumerate(row):\n            board[j].append(int(x))\n\n    def prime_range(x):\n        yield 2\n        yield 3\n        prime = 4\n        while prime <= x:\n            if x % prime == 0:\n                yield prime\n                yield x // prime\n            prime += 1\n\n    def is_prime(x):\n        return all(prime_range(x))\n\n    def has_p(x):\n        return any(prime in board[i] for i, prime in enumerate(prime_range(x)))\n\n    def move_p(x, y):\n        board[y] = board[y][:x - 1] + [1] + board[y][x:]\n\n    def move(x, y):\n        if x < 1 or x > n or y < 1 or y > m:\n            raise ValueError('Not in board')\n\n        if board[y][x - 1] == p:\n            move_p(x, y)\n            return\n\n        if not has_p(p):\n            return\n\n        if board[y][x - 1] == p or board[y - 1][x - 1] == p or board[y][x] == p or board[y - 1][x] == p:\n            return\n\n        if board[y][x] == p and not has_p(board[y][x - 1]):\n            move_p(x, y)\n            move(x + 1, y)\n            return\n\n        if board[y][x - 1] == p and not has_p(board[y][x]):\n            move_p(x, y)\n            move(x, y + 1)\n            return\n\n        if board[y][x] == p and not has_p(board[y][x - 1]):\n            move_p(x, y)\n            move(x - 1, y)\n            return\n\n        if board[y - 1][x] == p and not has_p(board[y][x - 1]):\n            move_p(x, y)\n            move(x, y - 1)\n            return\n\n    def backtrack(x, y, k):\n        if k == p * n * m:\n            return\n\n        if x == n and y == m:\n            if board[y][x - 1] == p:\n                k += 1\n                move(x, y)\n                return k\n            else:\n                return -1\n\n        if board[y][x - 1] == p:\n            k += 1\n            move(x, y)\n            return k\n\n        if not has_p(board[y][x - 1]):\n            return backtrack(x, y, k)\n\n        if board[y][x - 1] == p and not has_p(board[y][x]):\n            k += 1\n            move(x, y)\n            return k\n\n        if board[y][x - 1] == p and not has_p(board[y][x]):\n            k += 1\n            move(x, y)\n            return k\n\n        if board[y][x] == p and not has_p(board[y][x - 1]):\n            k += 1\n            move(x, y)\n            return k\n\n        if board[y - 1][x] == p and not has_p(board[y][x - 1]):\n            k += 1\n            move(x, y)\n            return k\n\n        if board[y - 1][x] == p and not has_p(board[y][x - 1]):\n            k += 1\n            move(x, y)\n            return k\n\n        if board[y - 1][x] == p and not has_p(board[y][x - 1]):\n            k += 1\n            move(x, y)\n            return k\n\n        if board[y][x - 1] == p and not has_p(board[y - 1][x]):\n            k += 1\n            move(x, y)\n            return k\n\n        if board[y][x - 1] == p and not has_p(board[y - 1][x]):\n            k += 1\n            move(x, y)\n            return k\n\n        if board[y][x - 1] == p and not has_p(board[y - 1][x]):\n            k += 1\n            move(x, y)\n            return k\n\n    move(1, 1)\n    return k\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    grid = [[int(x) for x in stdin.split()] for _ in range(n)]\n\n    def test(row, col, val):\n        if grid[row][col] == val:\n            return False\n        grid[row][col] = val\n        if row!= n - 1 and col!= m - 1:\n            return test(row + 1, col, val) or test(row, col + 1, val)\n        elif row!= n - 1:\n            return test(row + 1, col, val)\n        elif col!= m - 1:\n            return test(row, col + 1, val)\n\n    for row in range(n):\n        for col in range(m):\n            if test(row, col, p):\n                return str(row * m + col + 1)\n    return str(-1)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = list(map(int, stdin.split()))\n    board = [[int(x) for x in stdin.split()[i*m:(i+1)*m]] for i in range(n)]\n\n    dp = {}\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] not in dp:\n                dp[board[i][j]] = 0\n            dp[board[i][j]] += 1\n\n    ans = -1\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == p:\n                dp[board[i][j]] = 0\n            dp[board[i][j]] += 1\n            if dp[p] == n*m:\n                ans = max(ans, i*m+j)\n    return str(ans)\n\n\ndef"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def process(s: str) -> int:\n        res = 1\n        cnt = 0\n        for e in s:\n            if e == '1':\n                cnt += 1\n            else:\n                cnt = 0\n            if cnt == res:\n                res += 1\n            else:\n                return -1\n        return res\n    n, m, p = (int(i) for i in stdin.split())\n    board = []\n    for _ in range(n):\n        board.append(list(map(int, stdin.split())))\n    rows = [[] for _ in range(n)]\n    cols = [[] for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            rows[i].append(board[i][j])\n            cols[j].append(board[i][j])\n    for i in range(m):\n        for j in range(n):\n            cols[i].append(board[j][i])\n            rows[j].append(board[j][i])\n    rows = sorted(rows, key=lambda x: (len(x), x[0]))\n    cols = sorted(cols, key=lambda x: (len(x), x[0]))\n    for i in range(n):\n        for j in range(m):\n            board[i][j] = rows[i][j]\n    for i in range(m):\n        for j in range(n):\n            board[j][i] = cols[i][j]\n    res = 1\n    cnt = 0\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == p:\n                cnt += 1\n            else:\n                cnt = 0\n            if cnt == res:\n                res += 1\n            else:\n                return -1\n    return str(res)\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = stdin.split(' ')\n    n = int(n)\n    m = int(m)\n    p = int(p)\n    board = [list(map(int, stdin.split(' '))) for _ in range(n)]\n    moves = 0\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == p:\n                board[i][j] = 1\n                for r, c in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):\n                    if 0 <= r < n and 0 <= c < m and board[r][c] == p:\n                        while board[r][c] == p:\n                            board[r][c] = 1\n                            r += 1\n                            c += 1\n                            moves += 1\n    for i in range(n):\n        for j in range(m):\n            if board[i][j]!= p:\n                moves = -1\n    return str(moves)\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    #print(stdin)\n    n, m, p = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, stdin.split())))\n    max_sum = float(\"-inf\")\n    #print(\"matrix \", matrix)\n    for row in range(n):\n        for column in range(m):\n            #print(\"row \", row)\n            #print(\"column \", column)\n            current_sum = matrix[row][column]\n            #print(\"current_sum \", current_sum)\n            #print(\"up  \", row - 1)\n            if row > 0:\n                current_sum += matrix[row - 1][column]\n            #print(\"down\", row + 1)\n            if row < n - 1:\n                current_sum += matrix[row + 1][column]\n            #print(\"left\", column - 1)\n            if column > 0:\n                current_sum += matrix[row][column - 1]\n            #print(\"right\", column + 1)\n            if column < m - 1:\n                current_sum += matrix[row][column + 1]\n            #print(\"current_sum \", current_sum)\n            if current_sum == p:\n                max_sum = max(max_sum, current_sum)\n    if max_sum == float(\"-inf\"):\n        return -1\n    else:\n        return str(max_sum)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    board = [[int(x) for x in stdin.split()] for _ in range(n)]\n\n    def move(x, y, d, p):\n        row, col = x + d[0], y + d[1]\n        while row in range(n) and col in range(m) and board[row][col] == p:\n            row += d[0]\n            col += d[1]\n        return (row, col)\n\n    def solve(curr, p, moves, pw):\n        if pw == p:\n            moves.append(curr)\n            return True\n        if moves and len(moves) <= pw:\n            return False\n        curr1 = move(curr[0], curr[1], (0, 1), p)\n        if curr1:\n            moves.append(curr1)\n            if solve(curr1, p, moves, pw - 1):\n                return True\n        curr2 = move(curr[0], curr[1], (-1, 0), p)\n        if curr2:\n            moves.append(curr2)\n            if solve(curr2, p, moves, pw - 1):\n                return True\n        curr3 = move(curr[0], curr[1], (1, 0), p)\n        if curr3:\n            moves.append(curr3)\n            if solve(curr3, p, moves, pw - 1):\n                return True\n        curr4 = move(curr[0], curr[1], (0, -1), p)\n        if curr4:\n            moves.append(curr4)\n            if solve(curr4, p, moves, pw - 1):\n                return True\n        if len(moves) > pw:\n            return False\n        return False\n\n    moves = []\n    moves.append((0, 0))\n    if solve((0, 0), p, moves, p):\n        return \"\".join([\"\".join([str(x) for x in row]) for row in moves])\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split(\"\\n\")\n    n, m, p = int(rows[0]), int(rows[1]), int(rows[2])\n    board = [[0] * m for i in range(n)]\n    for i in range(n):\n        board[i] = list(map(int, rows[i + 3].split()))\n    moves = {1: 3, 2: 2, 3: 1, 4: 1, 5: 2, 6: 3, 7: 2, 8: 1, 9: 2, 10: 1, 11: 1, 12: 2, 13: 3, 14: 2, 15: 1, 16: 2, 17: 1, 18: 2, 19: 3, 20: 2, 21: 1, 22: 1, 23: 2, 24: 3, 25: 2, 26: 1, 27: 2, 28: 1, 29: 2, 30: 1, 31: 1, 32: 2, 33: 3, 34: 2, 35: 1, 36: 2, 37: 1, 38: 2, 39: 3, 40: 2, 41: 1, 42: 2, 43: 1, 44: 2, 45: 3, 46: 2, 47: 1, 48: 2, 49: 1, 50: 2, 51: 3, 52: 2, 53: 1, 54: 2, 55: 1, 56: 2, 57: 3, 58: 2, 59: 1, 60: 2, 61: 1, 62: 2, 63: 3, 64: 2, 65: 1, 66: 2, 67: 1, 68: 2, 69: 3, 70: 2, 71: 1, 72: 2, 73: 3, 74: 2, 75: 1, 76: 2, 77: 1, 78: 2, 79: 3, 80: 2, 81: 1, 82: 2, 83: 1, 84: 2, 85: 3, 86: 2, 87: 1, 88: 2, 89: 1, 90: 2, 91: 3, 92: 2, 93: 1, 94: 2, 95: 1, 96: 2, 97: 3}\n    moves_list = []\n    for i in range(1, p * m * n + 1):\n        moves_list.append(i)\n    for i in range(p * m * n + 1):\n        new_board = deepcopy(board)\n        move = moves[i]\n        for j in range(n):\n            new_board[j] = [a + b for a, b in zip(board[j], (i, move, move))]\n        i = 0\n        while i < len(new_board) - 1:\n            if new_board[i] == new_board[i + 1]:\n                new_board = new_board[:i] + new_board[i + 2:]\n                i = 0\n            i += 1\n        for j in range(n):\n            if new_board[j][0] == new_board[j][1] and new_board[j][1] == new_board[j][2]:\n                if new_board[j][0] > 1:\n                    new_board[j] = new_board[j][:2]\n        for j in range(n):\n            if new_board[j][0] == new_board[j][1] and new_board[j][1] == new_board[j][2]:\n                if new_board[j][0] > 1:\n                    new_board = new_board[:j] + new_board[j + 1:]\n        for j in range(n):\n            if new_board[j][0] == new_board[j][1] and new_board[j][1] == new_board[j][2]:\n                if new_board[j][0] > 1:\n                    new_board = new_board[:j] + new_board[j + 1:]\n        for j in range(n):\n            if new_board[j][0] == new_board[j][1] and new_board[j][1] == new_board[j][2]:\n                if new_board[j][0] > 1:\n                    new_board = new_board[:j] + new_board[j + 1:]\n        for j in range(n):\n            if new_board[j][0] == new_board[j][1] and new_board[j][1] == new_board[j][2]:\n                if new_board[j][0] > 1:\n                    new_board = new_board[:j] + new_board[j + 1:]\n        for j in range(n):\n            if new_board[j][0] == new_board[j][1] and new_board[j][1] == new_board[j][2]:\n                if new_board[j][0] > 1:\n                    new_board = new_board[:j] + new_board[j + 1:]\n        if new_board == board:\n            break\n    return len(moves_list)\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    board = [[int(i) for i in stdin.split()] for _ in range(n)]\n    win_board = [[0] * m for _ in range(n)]\n\n    def winner(board: list, row: int, col: int) -> bool:\n        for i in range(col, m):\n            if board[row][i] == p:\n                i = 0\n                while i <= row:\n                    if board[i][i] == p:\n                        i += 1\n                    else:\n                        return False\n                return True\n\n        for i in range(row, n):\n            if board[i][col] == p:\n                i = 0\n                while i <= row:\n                    if board[i][i] == p:\n                        i += 1\n                    else:\n                        return False\n                return True\n        return False\n\n    def winning_sequence(board: list) -> bool:\n        for i in range(n):\n            for j in range(m):\n                if winner(board, i, j):\n                    win_board[i][j] = 1\n                    if i == n - 1 and j == m - 1:\n                        return True\n        return False\n\n    def move_forward(board: list) -> bool:\n        moves = 0\n        for row in range(n):\n            for col in range(m):\n                if winner(board, row, col):\n                    moves += 1\n                    continue\n                else:\n                    for i in range(col, m):\n                        if board[row][i] == p:\n                            i = 0\n                            while i <= row:\n                                if board[i][i] == p:\n                                    i += 1\n                                else:\n                                    board[row][i] = board[i][i]\n                            break\n                    for i in range(row, n):\n                        if board[i][col] == p:\n                            i = 0\n                            while i <= row:\n                                if board[i][i] == p:\n                                    i += 1\n                                else:\n                                    board[i][col] = board[i][col]\n                            break\n        return moves\n\n    while True:\n        if winning_sequence(board):\n            return str(move_forward(board))\n        if move_forward(board) == p * m * n:\n            return '-1'\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    jumps = [[] for _ in range(n)]\n    level = 0\n    while level < n:\n        parent = level\n        children = []\n        while parent < n:\n            children.append(parent)\n            parent = jumps[parent][-1]\n        jumps[level].append(children)\n        level += 1\n    l = 0\n    m = 0\n    for level in range(n):\n        for child in jumps[level]:\n            if child > level:\n                l = max(l, level - child)\n            else:\n                l = max(l, level - child + 1)\n                m += 1\n                l = max(l, level - child + 2)\n    return str(l) + \" \" + str(m % 11092019)\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin)\n    S = ''.join([stdin]*T)\n    S = list(S)\n    visited = {}\n    L, M = 0, 0\n    for i in range(T):\n        if S[i] not in visited:\n            visited[S[i]] = 1\n            i_child = i\n            while i_child < T and S[i_child] > S[i]:\n                visited[S[i_child]] = 1\n                i_child += 1\n            L = max(i_child - i, L)\n            i_parent = i\n            while i_parent > 0 and S[i_parent] > S[i_parent - 1]:\n                visited[S[i_parent - 1]] = 1\n                i_parent -= 1\n            M = M + (i_parent - i_child + 1) * visited[S[i_parent]]\n            visited[S[i]] = 0\n    return str(L) +'' + str(M)\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    tree = {i: [] for i in range(1, N+1)}\n    for i in range(1, N):\n        u1, u2 = list(map(int, stdin.split()))\n        tree[u1].append(u2)\n        tree[u2].append(u1)\n    L, M = 0, 0\n    queue = [1]\n    seen = {1}\n    while queue:\n        curr = queue.pop()\n        for child in tree[curr]:\n            if child not in seen:\n                seen.add(child)\n                queue.append(child)\n        L = max(L, len(seen))\n        for child in tree[curr]:\n            if child not in seen:\n                M += 1\n                break\n    return str(L) + \" \" + str(M % (10**9 + 7))"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    d = {}\n    for i in range(1, n + 1):\n        d[i] = None\n    n_nodes = n - 1\n    for i in range(1, n_nodes + 1):\n        i, j = map(int, stdin.split())\n        d[i] = j\n    # print(d)\n    l = 0\n    for i in range(1, n_nodes + 1):\n        curr = d[i]\n        prev = d[i - 1]\n        if prev is None:\n            continue\n        while prev > curr:\n            curr = d[curr]\n            prev = d[prev - 1]\n            if prev == 1:\n                break\n        if prev > curr:\n            l = max(l, i - curr)\n    print(l, end=\" \")\n    p = 11092019\n    m = 0\n    if n % p == 0:\n        m = n\n    else:\n        m = n % p\n    print(m)\n\n    return \"\"\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    parents = list(range(n))\n    cur_vertex = 2\n    while cur_vertex!= 1:\n        parents[cur_vertex] = parents[parents[cur_vertex]]\n        cur_vertex = parents[cur_vertex]\n    \n    cur_vertex = 1\n    longest_path = 0\n    count = 0\n    while cur_vertex!= 1:\n        if parents[cur_vertex] < parents[cur_vertex-1]:\n            longest_path += 1\n            cur_vertex = parents[cur_vertex]\n        else:\n            longest_path = longest_path + 1\n            cur_vertex = parents[cur_vertex-1]\n    \n    \n    return str(longest_path) + \" \" + str(count)\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin)\n    tree = [int(x) for x in stdin.split()]\n    tree = [0] + tree\n    print(tree)\n\n    def build_tree(tree, u, v):\n        if u == v:\n            tree[u] = 1\n            return\n        tree[u] = v\n        build_tree(tree, u + 1, tree[u])\n\n    v = 1\n    while v < len(tree):\n        build_tree(tree, 0, v)\n        v += 1\n    print(tree)\n\n    def get_paths(tree, u, v, path):\n        if u == v:\n            return 1\n        if tree[u]!= tree[v]:\n            return 0\n        return sum(get_paths(tree, tree[u], tree[v] + 1, path + [tree[u]]) for u in range(1, len(tree)))\n\n    L = 1\n    while tree[L]!= tree[L - 1]:\n        L += 1\n    print(L)\n    M = get_paths(tree, 0, L - 1, [])\n    print(M % 10**9)\n\n\nsolution(stdin)\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    tree = build_tree(list(map(int, stdin.split())))\n    print('{} {}'.format(longest_jumping_path(tree), jumping_paths(tree) % 10092019))\n    return 'ok'\n\n\ndef"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    print(compute_lca(N))\n    print(compute_m(N))\n\n\ndef"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    T = {}\n    for i in range(N):\n        v = int(stdin)\n        T[v] = i\n    v = int(stdin)\n    q = deque([v])\n    jmp = {}\n    while q:\n        for _ in range(len(q)):\n            v = q.popleft()\n            if v == 1:\n                break\n            for i in range(1, v + 1):\n                if v - i not in T:\n                    if v - i in jmp:\n                        if jmp[v - i] > jmp[v]:\n                            jmp[v - i] = jmp[v]\n                    else:\n                        jmp[v - i] = jmp[v] + 1\n                if v + i not in T:\n                    if v + i in jmp:\n                        if jmp[v + i] > jmp[v]:\n                            jmp[v + i] = jmp[v]\n                    else:\n                        jmp[v + i] = jmp[v] + 1\n        for i in range(len(jmp)):\n            if i not in T:\n                q.append(i)\n        q.popleft()\n    return jmp[1], jmp[N]\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    nodes = {}\n    for i in range(1, n + 1):\n        nodes[i] = []\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[i * 2 + 1].split())\n        nodes[u].append(v)\n        nodes[v].append(u)\n    # print(nodes)\n    visited = set()\n    visited.add(1)\n    max_len = 0\n    for i in range(1, n + 1):\n        stack = [(1, i)]\n        while stack:\n            # print(stack)\n            j, v = stack.pop()\n            visited.add(v)\n            if j == i:\n                max_len = max(max_len, len(visited))\n            else:\n                for u in nodes[v]:\n                    if u not in visited:\n                        stack.append((j + 1, u))\n    return str(max_len) + \" \" + str(len(visited) % 1000000009)\n"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import math\n    n = int(stdin)\n    arr = []\n    for _ in range(n):\n        arr.append(tuple(map(int, stdin.split())))\n\n    max_nodes = 0\n    while True:\n        for i in range(n):\n            if arr[i][0] < arr[i][1]:\n                break\n        if i == n - 1:\n            break\n\n        m = max([x for x in range(i+1, n) if arr[i][0] < arr[x][0]])\n        for j in range(i+1, m):\n            if arr[i][1] < arr[j][1]:\n                break\n        if j == m:\n            break\n\n        max_nodes += 1\n\n        for i in range(i, m):\n            for j in range(i+1, m):\n                if arr[i][1] < arr[j][1]:\n                    break\n            if i == j:\n                break\n\n        max_nodes += 1\n\n    return str(max_nodes)\n"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nodes = {}\n    parents = {}\n    for i in range(n):\n        parent, value = map(int, stdin.split())\n        nodes[i+1] = value\n        parents[i+1] = parent\n    values = set()\n    def find_ancestors(node):\n        ancestors = set()\n        while node!= 1:\n            ancestors.add(node)\n            node = parents[node]\n        return ancestors\n    largest_subset = 0\n    for i in range(1,n+1):\n        for j in range(i, n+1):\n            if i in nodes:\n                if i in nodes and j in nodes:\n                    if nodes[i] > nodes[j]:\n                        values = values | find_ancestors(j)\n                        largest_subset = max(largest_subset, len(values))\n    return str(largest_subset)"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nodes = {}\n    max_nodes = 0\n    for i in range(n):\n        nodes[i+1] = int(stdin.split()[i+1])\n    for i in range(n):\n        parent = i\n        while parent and nodes[parent] < nodes[i]:\n            parent = nodes[parent] - 1\n        if parent!= i:\n            nodes[parent] += nodes[i]\n            nodes.pop(i)\n            max_nodes = max(max_nodes, nodes[i])\n    return str(max_nodes)"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split(\"\\n\")\n    n = int(data[0])\n    node_value = list(map(int, data[1].split()))\n    node_id = list(map(int, data[2].split()))\n    max_num = 0\n    max_subset = []\n    for i in range(len(node_id)):\n        for j in range(i + 1, len(node_id)):\n            if node_id[i] > node_id[j]:\n                max_num = max_num + 1\n                max_subset = max_subset + [node_id[i]]\n                max_subset = max_subset + [node_id[j]]\n    return str(max_num)\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    h = []\n    for _ in range(n):\n        v, p = map(int, stdin.split())\n        h.append([v, p])\n    h.sort(key=lambda x: x[0])\n    d = {}\n    heap = []\n    for _, p in h:\n        if p not in d:\n            d[p] = 1\n        else:\n            d[p] += 1\n    for _, p in h:\n        d[p] = max(d[p], d[p - 1])\n    return str(max(d.values()))\n"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_nodes, = map(int, stdin.split())\n    #  max_heap = []\n    #  parent_node_dict = {}\n    #  for _ in range(num_nodes):\n    #      parent_node_dict[_], child_node_dict[_] = map(int, stdin.split())\n    #      if parent_node_dict[_] not in parent_node_dict.keys():\n    #          parent_node_dict[_] = None\n    #  for node in range(1, num_nodes+1):\n    #      if node!= 1:\n    #          parent_node_dict[node] = parent_node_dict[parent_node_dict[node]]\n    #  for node in range(1, num_nodes+1):\n    #      if node!= 1:\n    #          parent_node_dict[node] = parent_node_dict[parent_node_dict[node]]\n    #  for node in range(1, num_nodes+1):\n    #      if node!= 1:\n    #          if node in parent_node_dict.keys():\n    #              parent_node_dict[node] = parent_node_dict[node]\n    #  print(parent_node_dict)\n    #  for i in range(1, num_nodes+1):\n    #      for j in range(1, num_nodes+1):\n    #          if parent_node_dict[i] < parent_node_dict[j]:\n    #              max_heap.append(i)\n    #  print(max_heap)\n    #  print(parent_node_dict)\n    #  print(len(max_heap))\n    return len(list(filter(lambda x: x < 1, map(lambda x: int(x) < 1, stdin.split()))))\n\nsolution(\"\"\"4 2\n1 2\n2 3\n1 3\n3 4\"\"\")\n"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_nodes = int(stdin)\n    values = {}\n    parents = {}\n    for i in range(1, num_nodes + 1):\n        line = stdin.split()\n        values[i] = int(line[0])\n        parents[i] = int(line[1])\n    max_heap = []\n    heapify(max_heap, num_nodes, 1)\n    for i in range(2, num_nodes + 1):\n        if i in values:\n            while max_heap[0] > values[i]:\n                heapreplace(max_heap, values[i])\n                values[i] = heapreplace(max_heap, values[i])\n            parents[i] = max_heap[0]\n    return str(len(max_heap))\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num_nodes = int(stdin)\n    nodes = {}\n    for i in range(num_nodes):\n        node_value, parent_value = stdin.split()\n        parent_value = int(parent_value)\n        node_value = int(node_value)\n        if parent_value not in nodes:\n            nodes[parent_value] = set()\n        nodes[parent_value].add(node_value)\n    def is_ancestor(node_value, parent_value):\n        return any(parent_value <= x <= node_value for x in nodes[parent_value])\n    def get_largest_subset(node_value):\n        if node_value in nodes:\n            return 1 + sum(get_largest_subset(x) for x in nodes[node_value])\n        return 0\n    return str(max(get_largest_subset(x) for x in nodes.keys()))"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    def heapify(i: int, heap: list) -> list:\n        left_child = i * 2 + 1\n        right_child = i * 2 + 2\n        largest = i\n        if left_child < len(heap) and heap[left_child] > heap[largest]:\n            largest = left_child\n        if right_child < len(heap) and heap[right_child] > heap[largest]:\n            largest = right_child\n        if largest!= i:\n            heap[i], heap[largest] = heap[largest], heap[i]\n            heapify(largest, heap)\n    def build_max_heap(heap: list) -> list:\n        start = len(heap) // 2 - 1\n        for i in range(start, -1, -1):\n            heapify(i, heap)\n    def build_max_heap_recursive(heap: list, start: int) -> list:\n        if start < 0:\n            return heap\n        largest = start\n        left_child = start * 2 + 1\n        right_child = start * 2 + 2\n        if left_child < len(heap) and heap[left_child] > heap[largest]:\n            largest = left_child\n        if right_child < len(heap) and heap[right_child] > heap[largest]:\n            largest = right_child\n        if largest!= start:\n            heap[start], heap[largest] = heap[largest], heap[start]\n            build_max_heap_recursive(heap, largest)\n    def heap_sort_max(heap: list) -> list:\n        for i in range(len(heap) - 1, 0, -1):\n            heap[i], heap[0] = heap[0], heap[i]\n            heapify(0, heap)\n        return heap\n    def heap_sort_max_recursive(heap: list, start: int) -> list:\n        if start < 0:\n            return heap\n        largest = start\n        left_child = start * 2 + 1\n        right_child = start * 2 + 2\n        if left_child < len(heap) and heap[left_child] > heap[largest]:\n            largest = left_child\n        if right_child < len(heap) and heap[right_child] > heap[largest]:\n            largest = right_child\n        if largest!= start:\n            heap[start], heap[largest] = heap[largest], heap[start]\n            heap_sort_max_recursive(heap, largest)\n    def max_heapify(heap: list, start: int, end: int) -> list:\n        i = start\n        while i <= end:\n            largest = i\n            left_child = i * 2 + 1\n            right_child = i * 2 + 2\n            if left_child < len(heap) and heap[left_child] > heap[largest]:\n                largest = left_child\n            if right_child < len(heap) and heap[right_child] > heap[largest]:\n                largest = right_child\n            if largest!= i:\n                heap[i], heap[largest] = heap[largest], heap[i]\n                i = largest\n            else:\n                i += 1\n    def max_heap_sort(heap: list) -> list:\n        for i in range(len(heap) - 1, 0, -1):\n            heap[0], heap[i] = heap[i], heap[0]\n            max_heapify(heap, 0, i - 1)\n        return heap\n    def max_heap_sort_recursive(heap: list, start: int) -> list:\n        if start < 0:\n            return heap\n        largest = start\n        left_child = start * 2 + 1\n        right_child = start * 2 + 2\n        if left_child < len(heap) and heap[left_child] > heap[largest]:\n            largest = left_child\n        if right_child < len(heap) and heap[right_child] > heap[largest]:\n            largest = right_child\n        if largest!= start:\n            heap[start], heap[largest] = heap[largest], heap[start]\n            max_heap_sort_recursive(heap, largest)\n    def build_max_heap_recursive_set(heap: list, start: int) -> list:\n        if start < 0:\n            return heap\n        largest = start\n        left_child = start * 2 + 1\n        right_child = start * 2 + 2\n        if left_child < len(heap) and heap[left_child] > heap[largest]:\n            largest = left_child\n        if right_child < len(heap) and heap[right_child] > heap[largest]:\n            largest = right_child\n        if largest!= start:\n            heap[start], heap[largest] = heap[largest], heap[start]\n            build_max_heap_recursive_set(heap, largest)\n    def build_max_heap_set(heap: list, start: int) -> list:\n        if start < 0:\n            return heap\n        largest = start\n        left_child = start * 2 + 1\n        right_child = start * 2 + 2\n        if left_child < len(heap) and heap[left_child] > heap[largest]:\n            largest = left_child\n        if right_child < len(heap) and heap[right_child] > heap[largest]:\n            largest = right_child\n        if largest!= start:\n            heap[start], heap[largest] = heap[largest], heap[start]\n            build_max_heap_set(heap, largest)\n    def max_heap_sort_set(heap: list) -> list:\n        for i in range(len(heap) - 1, 0, -1):\n            heap[0], heap[i] = heap[i], heap[0]\n            max_heap_set(heap, 0, i - 1)\n        return heap\n    def max_heap_sort_recursive_set(heap: list, start: int) -> list:\n        if start < 0:\n            return heap\n        largest = start\n        left_child = start * 2 + 1\n        right_child = start * 2 + 2"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    inputs = []\n    for _ in range(n):\n        inputs.append(stdin)\n    # inputs = [\n    #     [3, 0],\n    #     [3, 1],\n    #     [3, 2],\n    #     [3, 3],\n    #     [3, 4],\n    # ]\n    nodes = {}\n    for i, inputs in enumerate(inputs):\n        _, parent = inputs\n        nodes[parent] = i\n    count = 0\n    for i, inputs in enumerate(inputs):\n        # print(i)\n        parent, value = inputs\n        if parent == 0:\n            continue\n        # print(parent, value)\n        # print(parent, value, nodes[parent], nodes[i])\n        if nodes[parent] < nodes[i]:\n            count += 1\n    print(count)\n    return count\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    graph = [[] for _ in range(n)]\n    colors = {i: [] for i in range(1, n + 1)}\n    for line in stdin.split(\"\\n\"):\n        a, b, c = map(int, line.split())\n        graph[a].append(b)\n        graph[b].append(a)\n        colors[c].append(a)\n        colors[c].append(b)\n    colors = dict(colors)\n    for color in colors:\n        paths = []\n        visited = set()\n        visited.add(1)\n        queue = deque([1])\n        while queue:\n            vertex = queue.popleft()\n            for adj in graph[vertex]:\n                if adj not in visited:\n                    visited.add(adj)\n                    queue.append(adj)\n                    paths.append(vertex)\n        if len(paths)!= len(colors[color]):\n            continue\n        if len(paths) > 2:\n            continue\n        path1 = paths.pop()\n        path2 = paths.pop()\n        if path1 == path2:\n            continue\n        if path1 == 1 or path2 == 1:\n            continue\n        if (path1, path2) in ((1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9)):\n            continue\n        return \"\".join(map(str, paths))\n    return \"0\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    tree = defaultdict(lambda: defaultdict(lambda: None))\n    for _ in range(int(stdin.pop(0))):\n        a, b, c = map(int, stdin.pop(0).split())\n        tree[a][b] = c\n        tree[b][a] = c\n    color_count = {}\n    for node in range(int(stdin.pop(0))):\n        color_count[node] = 0\n    for node in range(int(stdin.pop(0))):\n        color_count[node] += 1\n        if tree[node] is not None:\n            color_count[node] += len(tree[node])\n    good = []\n    for node in range(int(stdin.pop(0))):\n        if color_count[node] == 2:\n            good.append(node)\n    good_nodes = sorted(good)\n    for node in good_nodes:\n        print(node)\n    return str(len(good))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    edges = defaultdict(list)\n    for _ in range(n - 1):\n        u, v, c = stdin.split()\n        u = int(u)\n        v = int(v)\n        c = int(c)\n        edges[u].append((v, c))\n        edges[v].append((u, c))\n\n    all_good_nodes = set()\n    color_map = {}\n    for i, (u, v) in enumerate(edges.items()):\n        for _, c in v:\n            if c not in color_map:\n                color_map[c] = i\n            else:\n                if color_map[c]!= i:\n                    all_good_nodes.add(i)\n                break\n\n    good_nodes = all_good_nodes\n    for i in range(len(all_good_nodes)):\n        for j in range(i + 1, len(all_good_nodes)):\n            u = all_good_nodes[i]\n            v = all_good_nodes[j]\n            if u!= v and color_map[edges[u][0][1]]!= color_map[edges[u][1][1]]:\n                good_nodes.add(u)\n                good_nodes.add(v)\n\n    return str(len(good_nodes)) + '\\n' +''.join(map(str, sorted(good_nodes)))"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    graph = []\n    for i in range(1, n+1):\n        graph.append(set())\n    for line in lines[1:]:\n        a, b, c = map(int, line.split())\n        graph[a].add(c)\n        graph[b].add(c)\n    good = set()\n    for i in range(1, n+1):\n        if is_a_good_node(graph, i):\n            good.add(i)\n    return str(len(good)) + '\\n' + '\\n'.join(sorted(map(str, good)))\n\ndef"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    edges = []\n    for i in range(n):\n        edges.append([int(i) for i in stdin.split()])\n\n    def get_color(color):\n        return 1 << (color - 1)\n\n    good_nodes = set()\n    for i, j, k in edges:\n        if i == j and k not in good_nodes:\n            good_nodes.add(k)\n        elif i!= j and k not in good_nodes:\n            good_nodes.add(i)\n            good_nodes.add(j)\n\n    def get_good_nodes(node):\n        if node in good_nodes:\n            return True\n        for i, j, k in edges:\n            if i == node and k in good_nodes:\n                return True\n            if j == node and i in good_nodes:\n                return True\n\n        return False\n\n    def get_n_good_nodes(n):\n        def dfs(node):\n            if node == n:\n                return True\n            for i, j, k in edges:\n                if i == node and k in good_nodes:\n                    return dfs(j)\n                if j == node and i in good_nodes:\n                    return dfs(i)\n            return False\n\n        for i in range(n):\n            if dfs(i):\n                return True\n        return False\n\n    def print_good_nodes(n):\n        for i in range(n):\n            if get_good_nodes(i):\n                print(i, end=\" \")\n\n    def print_n_good_nodes(n):\n        for i in range(n):\n            if get_n_good_nodes(i):\n                print(i, end=\" \")\n\n    def main():\n        print_good_nodes(n)\n        print_n_good_nodes(n)\n\n    main()\n    return \" \".join([str(x) for x in good_nodes])\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n <= 0:\n        return\n    nodes = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b, c = map(int, stdin.split())\n        nodes[a].append((b, c))\n        nodes[b].append((a, c))\n    good = []\n    for node in nodes[1:]:\n        if len(node) < 2:\n            continue\n        if node[0][1]!= node[1][1]:\n            continue\n        good.append(node[0][0])\n    return str(len(good)) + '\\n' +''.join(map(str, sorted(good)))\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    edge_list = list(map(lambda x: list(map(int, x.split())), input_list[1:]))\n    good_list = []\n    for node in range(1, n + 1):\n        good_list.append(node)\n    for start_node, end_node, edge_color in edge_list:\n        if start_node not in good_list:\n            continue\n        if end_node not in good_list:\n            continue\n        if start_node == end_node:\n            continue\n        if end_node == start_node:\n            continue\n        good_list = [x for x in good_list if x!= start_node and x!= end_node]\n        good_list.append(start_node)\n        good_list.append(end_node)\n        for node in range(1, n + 1):\n            if node!= start_node and node!= end_node:\n                continue\n            if node == start_node:\n                continue\n            if node == end_node:\n                continue\n            if node not in good_list:\n                continue\n            if not ((node == start_node and node!= end_node) or (node == end_node and node!= start_node)):\n                good_list = [x for x in good_list if x!= node]\n    print(len(good_list))\n    good_list = sorted(good_list)\n    print(*good_list, sep='\\n')\n    return"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    edges = []\n    for _ in range(n - 1):\n        a, b, c = stdin.split()\n        a, b, c = int(a), int(b), int(c)\n        edges.append((a, b, c))\n        edges.append((b, a, c))\n    edges.sort(key=lambda x: (x[0], x[1]))\n    stations = set([x for x, y, z in edges])\n    counter = 0\n    print(len(stations))\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                if i!= j and j!= k and i!= k:\n                    if (i, j) in edges or (j, i) in edges or (i, k) in edges or (k, i) in edges:\n                        continue\n                    else:\n                        stations_set = set()\n                        if i <= j <= k:\n                            for l in range(i, j + 1):\n                                stations_set.add(l)\n                        if i <= k <= j:\n                            for l in range(i, k + 1):\n                                stations_set.add(l)\n                        if j <= k <= i:\n                            for l in range(j, k + 1):\n                                stations_set.add(l)\n                        if (i, k) in stations_set or (k, i) in stations_set or (i, j) in stations_set or (j, i) in stations_set:\n                            continue\n                        else:\n                            counter += 1\n    return str(counter)\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    trees = []\n    for _ in range(n-1):\n        trees.append(list(map(int, stdin.split())))\n\n    # keep track of good nodes\n    good_nodes = []\n    # colors of all nodes\n    colors = set()\n    for tree in trees:\n        # start with a good node\n        good_node = False\n        # find a node that has no adjacent node\n        for i in range(1, n):\n            if i not in tree and (i == 1 or i == n):\n                # found the first good node\n                good_node = True\n                break\n            elif i in tree and tree.count(i) > 1:\n                # found a node with two adjacent nodes\n                break\n        if good_node:\n            good_nodes.append(i)\n            for j in range(1, n):\n                if j not in tree and (j == 1 or j == n):\n                    # found the first good node\n                    break\n                elif j in tree and tree.count(j) > 1:\n                    # found a node with two adjacent nodes\n                    break\n        # try to find a good node that has no adjacent node\n        good_node = False\n        for i in range(1, n):\n            if i not in tree and (i == 1 or i == n):\n                # found the first good node\n                good_node = True\n                break\n            elif i in tree and tree.count(i) > 1:\n                # found a node with two adjacent nodes\n                break\n        # try to find a good node that has no adjacent node\n        if not good_node:\n            good_node = True\n            for i in range(1, n):\n                if i not in tree and (i == 1 or i == n):\n                    # found the first good node\n                    break\n                elif i in tree and tree.count(i) > 1:\n                    # found a node with two adjacent nodes\n                    break\n\n        # find the starting node of good node\n        start = 0\n        if good_node:\n            start = 1\n        else:\n            for i in range(1, n):\n                if i in tree:\n                    start = i\n                    break\n\n        # find the end node of good node\n        end = 0\n        if good_node:\n            end = n - 1\n        else:\n            for i in range(n - 2, 0, -1):\n                if i in tree:\n                    end = i\n                    break\n        # check if the path from start to end is rainbow\n        if start!= end:\n            colors.add(trees[start][end])\n\n    # find the good node which is not in good_nodes\n    for i in range(1, n):\n        if i not in good_nodes and (i == 1 or i == n):\n            good_nodes.append(i)\n            for j in range(1, n):\n                if j not in tree and (j == 1 or j == n):\n                    # found the first good node\n                    break\n                elif j in tree and tree.count(j) > 1:\n                    # found a node with two adjacent nodes\n                    break\n        elif i in good_nodes:\n            # found a node in good_nodes\n            continue\n        else:\n            # not in good_nodes\n            # try to find a good node that has no adjacent node\n            good_node = False\n            for j in range(1, n):\n                if j not in tree and (j == 1 or j == n):\n                    # found the first good node\n                    good_node = True\n                    break\n                elif j in tree and tree.count(j) > 1:\n                    # found a node with two adjacent nodes\n                    break\n            if not good_node:\n                good_node = True\n                for j in range(1, n):\n                    if j not in tree and (j == 1 or j == n):\n                        # found the first good node\n                        break\n                    elif j in tree and tree.count(j) > 1:\n                        # found a node with two adjacent nodes\n                        break\n            if good_node:\n                good_nodes.append(i)\n                for j in range(1, n):\n                    if j not in tree and (j == 1 or j == n):\n                        # found the first good node\n                        break\n                    elif j in tree and tree.count(j) > 1:\n                        # found a node with two adjacent nodes\n                        break\n\n    # print the number of good nodes\n    print(len(good_nodes))\n    # print the indices of good nodes in numerical order\n    print(*good_nodes, sep=' ')\n    return 'ok'"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # graph = {}\n    # for line in stdin:\n    #     u, v, w = list(map(int, line.split()))\n    #     if u not in graph:\n    #         graph[u] = [w]\n    #     else:\n    #         graph[u].append(w)\n    #     if v not in graph:\n    #         graph[v] = [w]\n    #     else:\n    #         graph[v].append(w)\n    #\n    # rainbow_nodes = set()\n    # for u in range(1, n+1):\n    #     queue = [u]\n    #     visited = set()\n    #     while queue:\n    #         u = queue.pop(0)\n    #         visited.add(u)\n    #         if u not in graph:\n    #             continue\n    #         for neighbor in graph[u]:\n    #             if neighbor in visited:\n    #                 continue\n    #             queue.append(neighbor)\n    #         for neighbor in graph[u]:\n    #             if neighbor not in visited:\n    #                 visited.add(neighbor)\n    #\n    #\n    #     if len(visited) == n:\n    #         rainbow_nodes.add(u)\n    #\n    # print(len(rainbow_nodes))\n    # for node in rainbow_nodes:\n    #     print(node)\n    return len(list(filter(lambda x: len(x) == n, [[i, j, k] for i in range(1, n+1) for j in range(i+1, n+1) for k in range(j+1, n+1)])))\n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    lines = [line.split() for line in lines]\n    lines = [[int(i) for i in line] for line in lines]\n    bank_count = lines[0]\n    lines = lines[1:]\n    program = lines\n    return print(min_time(bank_count, program))\n\ndef"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, b, s = map(int, stdin.split())\n    memory_banks = {}\n    for _ in range(b):\n        i = int(stdin.split()[1])\n        memory_banks[i] = int(stdin.split()[2])\n    program = stdin.split()[3:]\n    execution_time = 0\n    while True:\n        execution_time += 1\n        if execution_time > 10**12:\n            return '-1'\n        result = execute_program(program, execution_time, memory_banks)\n        if result!= '-1':\n            return result\ndef"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    <stdin>:\n        line1: b,s\n        line2: *\n    <stdout>:\n        line1: 5\n    '''\n    # Remove the linebreak which is needed to run the program.\n    # stdin = stdin.strip()\n\n    # Read the testcase and split it into its components.\n    b, s = list(map(int, stdin.split()))\n    # Create a map from memory location to memory bank.\n    memory_bank = {}\n    for i in range(b):\n        memory_bank[i] = []\n    # Split input data into memory banks.\n    input_data = stdin.split()\n    # Loop through the memory banks and add its content to the map.\n    for idx, input_item in enumerate(input_data):\n        # Split input data into variables.\n        variable_name, *variable_content = input_item.split()\n        # Add the variables into memory banks.\n        memory_bank[idx].append(variable_name)\n        # Add variable content to the map.\n        for item in variable_content:\n            memory_bank[idx].append(item)\n    # Sort the memory banks by their size and variable names.\n    memory_banks = sorted(memory_bank, key=lambda x: (len(x), x), reverse=True)\n    # Find the minimum number of memory references required to finish the program.\n    min_memory_refs = 10**6\n    for memory_bank in memory_banks:\n        # Check if the bank is empty.\n        if len(memory_bank) == 0:\n            continue\n        # Check if the variable name is in the map.\n        if memory_bank[0] in memory_bank[1:]:\n            continue\n        # Get the bank's index.\n        bank_idx = memory_bank[0]\n        # Get the variable name from the bank.\n        variable_name = memory_bank[1]\n        # Get the variable's index.\n        variable_idx = memory_bank.index(variable_name) + 1\n        # Get the bank's variable content.\n        bank_content = memory_bank[2:]\n        # Loop through the memory content and change the bank's variable content.\n        for idx, var_item in enumerate(bank_content):\n            # If the bank is in the mapping, then change the variable content.\n            if bank_idx in memory_bank_mapping:\n                if var_item in memory_bank_mapping[bank_idx]:\n                    bank_content[idx] = memory_bank_mapping[bank_idx][var_item]\n            # Otherwise, set the variable content.\n            else:\n                bank_content[idx] = memory_bank_mapping[bank_idx]\n        # Get the list of the bank's content.\n        bank_content = bank_content[2:]\n        # Remove bank from the map.\n        memory_bank.pop(0)\n        # Loop through the bank content.\n        for idx, item in enumerate(bank_content):\n            # Check if the bank is in the mapping.\n            if bank_idx in memory_bank_mapping:\n                if item in memory_bank_mapping[bank_idx]:\n                    bank_content[idx] = memory_bank_mapping[bank_idx][item]\n            # Otherwise, set the variable content.\n            else:\n                bank_content[idx] = memory_bank_mapping[bank_idx]\n        # Get the list of the bank's content.\n        bank_content = bank_content[2:]\n        # Add the bank's content to the map.\n        memory_bank_mapping[bank_idx] = bank_content\n        # Calculate the number of memory references required to finish the program.\n        num_memory_refs = len(memory_bank) + 1\n        # If the memory references are less than the current minimum, then update the minimum.\n        if num_memory_refs < min_memory_refs:\n            min_memory_refs = num_memory_refs\n    # Return the minimum number of memory references.\n    return str(min_memory_refs)\n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    For each operation, the amount of memory used and operations that must be executed\n    is determined using the following formula:\n        Memory_Needed = (1 + number_of_variables) * (bank_size * number_of_operations)\n    The reason for this is that each operation can execute $1 + number_of_variables$\n    memory locations, and each operation has $number_of_operations$ repetitions.\n    The total number of memory locations required by a program is therefore\n    $1 + number_of_variables + number_of_variables*(number_of_operations - 1)$.\n    The total number of operations required by a program is then\n    $1 + number_of_variables + number_of_operations$.\n    '''\n    input = stdin.split()\n    memory_bank_sizes = input[0]\n    number_of_variables, number_of_repetitions = input[1:]\n    memory_bank_sizes = memory_bank_sizes.split()\n    memory_bank_sizes = list(map(int, memory_bank_sizes))\n    number_of_variables, number_of_operations = input[1:]\n    number_of_variables = int(number_of_variables)\n    number_of_operations = int(number_of_operations)\n    memory_need = (1 + number_of_variables) * (sum(memory_bank_sizes) * number_of_operations)\n    memory_need = memory_need + (memory_need * (number_of_operations - 1))\n    return str(memory_need)\n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b,s = map(int, stdin.split())\n    m = {str(i):i for i in range(1,b+1)}\n    for i,c in enumerate(stdin.split(),1):\n        if c[0]=='R' and c[-1]=='E':\n            v,e = list(map(int,c.split()))\n            m[str(v)] -= i\n            for j in range(1,e+1):\n                m[str(v)] += i\n        elif c[0]=='V':\n            v,e = list(map(int,c.split()))\n            m[str(v)] += i\n        elif c[0]=='E':\n            v,e = list(map(int,c.split()))\n            m[str(v)] += i\n    return str(min(m.values()))\n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def expand(a: List[str]) -> List[str]:\n        ans = []\n        for b in a:\n            if 'V' in b:\n                ans.append(b)\n            else:\n                ans.extend(['R' + str(i) for i in range(int(b))])\n        return ans\n    memory = [[]]\n    for line in stdin.split('\\n'):\n        if line.startswith('R'):\n            memory = [[]]\n            memory[0].append(line)\n        else:\n            memory[-1].append(line)\n    memory = expand(memory)\n    memory = list(filter(lambda a: 'V' in a, memory))\n    memory = sorted(memory)\n    # print(memory)\n    n = 0\n    ans = 0\n    for m in memory:\n        # print(m)\n        n = max(n, len(m))\n        # print(n)\n        ans += n\n    return str(ans)"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def convert(s: str) -> str:\n        res = ''\n        for c in s:\n            if c == 'R':\n                res += '1'\n            elif c == 'V':\n                res += '0'\n            elif c == 'E':\n                res += '10'\n            else:\n                raise Exception('Unknown character: %s' % c)\n        return res\n\n    banks, variables = map(int, stdin.split())\n    variable_strings = stdin.split()[1:]\n    variables = {convert(v): i for i, v in enumerate(variable_strings)}\n    variable_banks = [int(bank) for bank in stdin.split()[0].split()]\n\n    instructions = []\n    for line in stdin.split('\\n')[1:]:\n        if not line:\n            instructions.append(['END'])\n            continue\n        instructions.append([line[0], *map(int, line[1:].split()), int(line[-1])])\n\n    def get_banks(banks, variables, variable_banks, i):\n        if len(variable_banks) == 1:\n            # there is exactly one variable\n            variable = variables[variable_banks[0]]\n            variable_banks = [0] * len(variable_banks)\n            variable_banks[0] = variable\n        else:\n            variable_banks = [0] * len(variable_banks)\n            for j in range(len(variable_banks)):\n                if variable_banks[j] == 0:\n                    variable = variables[variable_banks[j]]\n                    variable_banks[j] = variable\n                    break\n\n        for j in range(len(variable_banks)):\n            if variable_banks[j] == 0:\n                # not assigned\n                variable_banks[j] = len(banks)\n        variable_banks = sorted(variable_banks)\n        variable_banks = [0] + variable_banks\n        return variable_banks\n\n    def run_instructions(instructions, variables, variable_banks, i):\n        # print(variable_banks)\n        # print(i)\n        if i == len(instructions):\n            return 0\n        instruction = instructions[i]\n        if instruction[0] == 'R':\n            variable_banks = get_banks(banks, variables, variable_banks, i)\n            instructions[i] = ['R', *variable_banks, instruction[2]]\n        elif instruction[0] == 'V':\n            variable_banks = get_banks(banks, variables, variable_banks, i)\n            instructions[i] = ['V', *variable_banks]\n        elif instruction[0] == 'E':\n            instructions[i] = ['E', *variable_banks, instruction[2]]\n\n        if len(variable_banks) == 1:\n            variable = variables[variable_banks[0]]\n            variable_banks = [0] * len(variable_banks)\n            variable_banks[0] = variable\n        else:\n            variable_banks = [0] * len(variable_banks)\n            for j in range(len(variable_banks)):\n                if variable_banks[j] == 0:\n                    variable = variables[variable_banks[j]]\n                    variable_banks[j] = variable\n                    break\n        variable_banks = sorted(variable_banks)\n        variable_banks = [0] + variable_banks\n        return run_instructions(instructions, variables, variable_banks, i + 1)\n\n    return run_instructions(instructions, variables, variable_banks, 0)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b,s = stdin.split()\n    b,s = int(b), int(s)\n    n = len(b) * s\n    mem = [None] * n\n    start = 0\n    for i in range(b * s):\n        if mem[i] == None:\n            mem[i] = i\n        else:\n            start = i\n            break\n    execution_time = n\n    while execution_time > 0:\n        for i in range(b * s):\n            if mem[i]!= None:\n                if mem[i] > start:\n                    start = mem[i]\n                    execution_time -= 1\n        execution_time -= b\n        for i in range(b * s):\n            if mem[i]!= None:\n                if mem[i] < start:\n                    mem[i] = start\n        for i in range(b):\n            start += b\n            execution_time -= 1\n    execution_time += b - start\n    return str(execution_time)"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    banks = [int(i) for i in stdin[0]]\n    mapping = stdin[1]\n    res = 0\n    while mapping.find('R')!= -1:\n        count = 1\n        while mapping.find('R', count)!= -1:\n            count += 1\n        mapping = mapping.replace('R' + str(count) +'','')\n    mapping = mapping.split()\n    for i in mapping:\n        if i.find('V')!= -1:\n            start = i.find('V') + 1\n            end = i.find('E')\n            if end == -1:\n                end = len(i)\n            res += (end - start)\n        elif i.find('E')!= -1:\n            start = i.find('E') + 1\n            end = len(i)\n            res += (end - start)\n    return str(res)\n"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, n = map(int, stdin.split())\n    for i in range(2, 64):\n        x = pow(b, i)\n        if n == x:\n            return str(x)\n    return \"impossible\"\nprint(solution(input()))"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, n = map(int, stdin.split())\n    def f(x):\n        while x:\n            yield x % b\n            x = x // b\n    for i in f(n):\n        if i > 0:\n            return str(i)\n    return \"impossible\"\n"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def digit(n):\n        return n%10 if n else 0\n    def f(n, base):\n        if n == 0: return 0\n        q, r = divmod(n, base)\n        if r == 0:\n            return f(q, base)\n        return f(q, base) * base + r\n    b, n = map(int, stdin.split())\n    return str(digit(f(n, b))) if int(digit(f(n, b))) < 2**63 else \"impossible\"\nprint(solution(input()))\n"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    from collections import Counter\n    # print(stdin)\n    if len(stdin.split())!= 2:\n        return \"impossible\"\n    a, b = int(stdin.split()[0]), int(stdin.split()[1])\n    if a == 1:\n        return \"impossible\"\n    if a == 0:\n        return \"impossible\"\n    if b == 1:\n        return \"impossible\"\n    if b == 0:\n        return \"impossible\"\n    # from collections import Counter\n    # a, b = map(int, input().split())\n    # if a == 1:\n    #     return \"impossible\"\n    # if a == 0:\n    #     return \"impossible\"\n    # if b == 1:\n    #     return \"impossible\"\n    # if b == 0:\n    #     return \"impossible\"\n    # from collections import Counter\n    # a, b = map(int, input().split())\n    # if a == 1:\n    #     return \"impossible\"\n    # if a == 0:\n    #     return \"impossible\"\n    # if b == 1:\n    #     return \"impossible\"\n    # if b == 0:\n    #     return \"impossible\"\n\n    if a > 1 and a % 2 == 0:\n        print(\"impossible\")\n    elif a == 1 and b == 1:\n        print(\"impossible\")\n    elif a < b:\n        print(\"impossible\")\n    else:\n        # print(a, b)\n        if a % b == 0:\n            print(0)\n        else:\n            from collections import Counter\n            a = str(a)\n            n = len(a)\n            dic = {}\n            for i in range(len(a)):\n                dic[a[i]] = i\n            num = 0\n            for i in range(len(a)):\n                num = num + int(dic[a[i]]) * 10**(n - i - 1)\n            if num < b:\n                print(num)\n            else:\n                print(\"impossible\")\n"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x = stdin.split()\n    n, b = int(x[0]), int(x[1])\n    if not n or not b or n < 2 or n > 10**6 or b < 2 or b > 10000:\n        return \"impossible\"\n    if n == 1:\n        return '1'\n    ans = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map(lambda x: ans[-1] + 1, ans))\n    ans = list(map(lambda x: int(x), ans))\n    ans = list(map(lambda x: int(x) * b, ans))\n    ans = list(map(lambda x: x % n, ans))\n    ans = list(map("
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_str = stdin.split()\n    base = int(num_str[0])\n    target = int(num_str[1])\n    \n    if base < 3 or base > 9:\n        return 'impossible'\n    \n    if base == 3:\n        if target <= 0:\n            return 'impossible'\n        return str(target)\n    \n    if base == 8:\n        return str(target)\n    \n    result = []\n    num = 0\n    while True:\n        if (target//(base**(len(result)-1)))**(1/(len(result)-1)) > 2**31:\n            return 'impossible'\n        result = []\n        temp = target\n        while temp > 0:\n            if temp >= (base**len(result)):\n                result.append(int(temp/(base**(len(result)-1))))\n                temp = temp%(base**(len(result)-1))\n            else:\n                result.append(int(temp/(base**(len(result)-1))))\n                temp = temp%(base**(len(result)-1))\n        num = base**(len(result)-1)\n        for i in result:\n            num *= base\n            num += i\n        if num == target:\n            break\n    return str(num)"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the smallest positive integer solution for the equation:\n    f_B(X) = N\n    \"\"\"\n    a, b = map(int, stdin.split())\n    # Binary search\n    # Find all positive integers k satisfying k < 2^{64}\n    # And for every k we have k = 2**k + 1\n    # and k > N\n    # for k < 2**64 and k > N\n    k = 0\n    while k < 2**64 and k < a:\n        k += 1\n    k -= 1\n    if k >= a:\n        return 'impossible'\n\n    # Now we know the k smallest positive integer such that k < 2^64\n    # We want to find its smallest positive integer solution which satisfies N\n    x = k + 1\n    while x**b - a!= 0:\n        x += 1\n    return x\n"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x = stdin.split()\n    b, n = int(x[0]), int(x[1])\n    if b < 2 or b > 10000 or n < 2 or n > (2 ** 63) - 1:\n        print('impossible')\n    else:\n        for y in range(n, 0, -1):\n            if (b ** y) % n == 1:\n                print(y)\n                break\n        else:\n            print('impossible')\nsolution('10 24')\nsolution('10 11')\nsolution('9 216')"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a = int(a)\n    b = int(b)\n    if b == 0:\n        return \"impossible\"\n    for i in range(1, b+1):\n        if i * a == b:\n            return str(i)\n    return \"impossible\"\n"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num1, num2 = stdin.split(\" \")\n    x = int(num1)\n    y = int(num2)\n    found = False\n    x_pos_base = x\n    while found == False:\n        if x == y:\n            print(x)\n            found = True\n        else:\n            if x > y:\n                x_pos_base = x_pos_base//10\n            else:\n                y = y%x_pos_base\n    return \"impossible\"\n\nsolution(\"10 24\")\nsolution(\"10 11\")\nsolution(\"9 216\")"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    d, t, c, r = map(int, lines[0].split())\n    clouds = []\n    for i in range(1, c + 1):\n        s, e, p, a = list(map(int, lines[i].split()))\n        clouds.append([s, e, p, a])\n    roofs = lines[c + 1:]\n    # zip_codes = {}\n    # zip_codes[lines[0]] = 1\n    # for r in roofs:\n    #     zip_code = r.split()[0]\n    #     zip_codes[zip_code] = zip_codes[zip_code] + 1\n    #\n    # for k, v in zip_codes.items():\n    #     if v > 1:\n    #         print(k, v)\n    #     else:\n    #         continue\n    # print(zip_codes)\n\n    return str(solve(d, t, c, r, clouds, roofs))\n\n\ndef"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r = map(int, stdin.split())\n    clouds = []\n    for i in range(c):\n        s, e, p, a = map(int, stdin.split())\n        clouds.append((s, e, p, a))\n\n    clouds.sort(key=lambda x: x[0])\n    clouds.sort(key=lambda x: x[1])\n    # print(clouds)\n    home = 0\n    bus_stop = 0\n    bus_route = 0\n    for i in range(d):\n        if i in [home, bus_stop]:\n            continue\n        for j in range(t):\n            if (i, j) in clouds:\n                bus_stop = j\n            if (i, j) in [c[1] for c in clouds]:\n                bus_route = j\n        if (i, bus_route) not in clouds:\n            home = i\n            break\n    # print(home, bus_stop, bus_route)\n    return str(bus_route - bus_stop)\n\n\nprint(solution(*(input().split())))\n"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    stdin: str\n    '''\n    d, t, c, r = map(int, stdin.split())\n    clouds = []\n    for i in range(c):\n        clouds.append(list(map(int, stdin.split())))\n\n    cloud_s = []\n    cloud_e = []\n    cloud_p = []\n    cloud_a = []\n    for cloud in clouds:\n        cloud_s.append(cloud[0])\n        cloud_e.append(cloud[1])\n        cloud_p.append(cloud[2])\n        cloud_a.append(cloud[3])\n\n    clouds_info = []\n    clouds_info.append([cloud_s, cloud_e, cloud_p, cloud_a])\n\n    r_s = []\n    r_e = []\n    r_p = []\n    r_a = []\n    for r in range(r):\n        r_s.append(0)\n        r_e.append(0)\n        r_p.append(0)\n        r_a.append(0)\n\n    r_s_a = []\n    r_s_e = []\n    r_s_p = []\n    r_s_a.append(r_s)\n    r_s_e.append(r_e)\n    r_s_p.append(r_p)\n    r_s_a.append(r_s)\n    r_s_e.append(r_e)\n    r_s_p.append(r_p)\n    r_s_a.append(r_s)\n    r_s_e.append(r_e)\n    r_s_p.append(r_p)\n    r_s_a.append(r_s)\n    r_s_e.append(r_e)\n    r_s_p.append(r_p)\n    r_s_a.append(r_s)\n    r_s_e.append(r_e)\n    r_s_p.append(r_p)\n    r_s_a.append(r_s)\n    r_s_e.append(r_e)\n    r_s_p.append(r_p)\n\n    r_s_p_a = []\n    r_s_p_e = []\n    r_s_p_p = []\n    r_s_p_a.append(r_s_p)\n    r_s_p_e.append(r_s_e)\n    r_s_p_p.append(r_s_p)\n    r_s_p_a.append(r_s_p)\n    r_s_p_e.append(r_s_e)\n    r_s_p_p.append(r_s_p)\n    r_s_p_a.append(r_s_p)\n    r_s_p_e.append(r_s_e)\n    r_s_p_p.append(r_s_p)\n    r_s_p_a.append(r_s_p)\n    r_s_p_e.append(r_s_e)\n    r_s_p_p.append(r_s_p)\n    r_s_p_a.append(r_s_p)\n    r_s_p_e.append(r_s_e)\n    r_s_p_p.append(r_s_p)\n    r_s_p_a.append(r_s_p)\n    r_s_p_e.append(r_s_e)\n    r_s_p_p.append(r_s_p)\n    r_s_p_a.append(r_s_p)\n    r_s_p_e.append(r_s_e)\n    r_s_p_p.append(r_s_p)\n    r_s_p_a.append(r_s_p)\n    r_s_p_e.append(r_s_e)\n    r_s_p_p.append(r_s_p)\n    r_s_p_a.append(r_s_p)\n    r_s_p_e.append(r_s_e)\n    r_s_p_p.append(r_s_p)\n    r_s_p_a.append(r_s_p)\n    r_s_p_e.append(r_s_e)\n    r_s_p_p.append(r_s_p)\n    r_s_p_a.append(r_s_p)\n    r_s_p_e.append(r_s_e)\n    r_s_p_p.append(r_s_p)\n    r_s_p_a."
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_zip(x: int, y: int):\n        for i in range(len(zips)):\n            if x in zips[i] and y in zips[i]:\n                return i\n        return -1\n\n    d, t, c, r = map(int, stdin.split())\n\n    zips = []\n    for _ in range(c):\n        a, b, p, c = map(float, stdin.split())\n        zips.append([a, b, p, c])\n\n    zips.sort(key=lambda x: (x[0], x[1]))\n    distance = 0\n    min_rain = 0\n\n    for i in range(len(zips)):\n        x = zips[i][0]\n        y = zips[i][1]\n        p = zips[i][2]\n        c = zips[i][3]\n\n        if get_zip(x, y) == -1:\n            continue\n        else:\n            distance += (y - x)\n        min_rain += (c * p)\n\n    distance += d\n    min_rain += r\n    return str(distance - min_rain)\n"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    [d, t, c, r] = map(int, stdin.split())\n    clouds = []\n    for i in range(c):\n        clouds.append((int(stdin.split()[i * 4 + 1]), int(stdin.split()[i * 4 + 2]), float(stdin.split()[i * 4 + 3]), int(stdin.split()[i * 4 + 4])))\n\n    roofs = []\n    for i in range(r):\n        roofs.append(list(map(int, stdin.split()[i * 2 + 1].split())))\n\n    for cloud in clouds:\n        x = cloud[0]\n        y = cloud[1]\n        p = cloud[2]\n        a = cloud[3]\n        clouds_to_x = []\n        clouds_to_y = []\n        if len(clouds) > 0:\n            clouds_to_x = [x]\n        else:\n            clouds_to_x = [0]\n        if len(clouds) > 0:\n            clouds_to_y = [y]\n        else:\n            clouds_to_y = [0]\n        for cloud in clouds:\n            if cloud[0] == x:\n                clouds_to_x.append(cloud[0])\n            if cloud[1] == y:\n                clouds_to_y.append(cloud[1])\n        clouds_to_x.sort()\n        clouds_to_y.sort()\n        for i in range(len(clouds_to_x) - 1):\n            if clouds_to_x[i + 1] - clouds_to_x[i] <= t:\n                if clouds_to_y[i + 1] - clouds_to_y[i] <= t:\n                    x = clouds_to_x[i + 1]\n                    y = clouds_to_y[i + 1]\n                    break\n        for i in range(len(clouds_to_y) - 1):\n            if clouds_to_y[i + 1] - clouds_to_y[i] <= t:\n                if clouds_to_x[i + 1] - clouds_to_x[i] <= t:\n                    x = clouds_to_x[i + 1]\n                    y = clouds_to_y[i + 1]\n                    break\n        clouds_to_x.sort()\n        clouds_to_y.sort()\n        for i in range(len(clouds_to_y) - 1):\n            if clouds_to_y[i + 1] - clouds_to_y[i] <= t:\n                if clouds_to_x[i + 1] - clouds_to_x[i] <= t:\n                    x = clouds_to_x[i + 1]\n                    y = clouds_to_y[i + 1]\n                    break\n        for i in range(len(clouds_to_x) - 1):\n            if clouds_to_x[i + 1] - clouds_to_x[i] <= t:\n                if clouds_to_y[i + 1] - clouds_to_y[i] <= t:\n                    x = clouds_to_x[i + 1]\n                    y = clouds_to_y[i + 1]\n                    break\n        for roof_from_x in roofs:\n            if roof_from_x[0] <= x and x <= roof_from_x[1] and roof_from_x[0]!= roof_from_x[1]:\n                continue\n            else:\n                for roof_from_y in roofs:\n                    if roof_from_y[0] <= y and y <= roof_from_y[1] and roof_from_y[0]!= roof_from_y[1]:\n                        continue\n                    else:\n                        if x == roof_from_x[0] and y == roof_from_y[0]:\n                            continue\n                        else:\n                            break\n                break\n        for roof_from_x in roofs:\n            if roof_from_x[0] <= x and x <= roof_from_x[1] and roof_from_x[0]!= roof_from_x[1]:\n                continue\n            else:\n                for roof_from_y in roofs:\n                    if roof_from_y[0] <= y and y <= roof_from_y[1] and roof_from_y[0]!= roof_from_y[1]:\n                        continue\n                    else:\n                        if x == roof_from_x[0] and y == roof_from_y[0]:\n                            continue\n                        else:\n                            break\n                break\n        if x == 0 and y == 0:\n            continue\n        for roof_from_x in roofs:\n            if roof_from_x[0] <= x and x <= roof_from_x[1] and roof_from_x[0]!= roof_from_x[1]:\n                continue\n            else:\n                for roof_"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r = map(int, stdin.split())\n    cloud_data = stdin.split()\n    clouds = []\n    for i in range(c):\n        clouds.append(tuple(map(float, cloud_data[i].split())))\n    clouds.sort(key=lambda x: x[1])\n    clouds.sort(key=lambda x: x[2])\n    clouds.sort(key=lambda x: x[3])\n    drops = []\n    for i in range(r):\n        drops.append(int(clouds.pop()[0]))\n    print(drops)\n    bus_stop = t\n    while drops:\n        i = 0\n        drop = drops[i]\n        if drop > bus_stop:\n            break\n        while drop > bus_stop:\n            drop -= drops[i]\n            i += 1\n        print(i)\n        print(drop)\n        bus_stop -= drops[i]\n        drops = drops[i:]\n    print(bus_stop)\n    return str(bus_stop)\n    \"\"\"\n    data = stdin.split()\n    print(data)\n    d, t, c, r = map(int, data[0].split())\n    clouds = data[1:]\n    clouds.sort(key=lambda x: x[1])\n    clouds.sort(key=lambda x: x[2])\n    clouds.sort(key=lambda x: x[3])\n    drops = []\n    for i in range(r):\n        drops.append(int(clouds.pop()[0]))\n    bus_stop = t\n    while drops:\n        drop = drops[0]\n        if drop > bus_stop:\n            break\n        while drop > bus_stop:\n            drop -= drops[0]\n        bus_stop -= drops[0]\n        drops = drops[1:]\n    return str(bus_stop)\n    \"\"\""
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Parses input from stdin, extracts data and solves the problem.\n    :param stdin:\n    :return:\n    \"\"\"\n    # Parse data\n    data = list(map(lambda el: list(map(float, el.split(\" \"))), stdin.split(\"\\n\")))\n    # Solve puzzle\n    return str(solve_puzzle(data))\n\n\ndef"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r = map(int, stdin.split())\n    r_segs = []\n    for i in range(r):\n        r_segs.append([int(i) for i in stdin.split()])\n\n    clouds = []\n    for i in range(c):\n        clouds.append([int(i) for i in stdin.split()])\n\n    w1 = d\n    for i in range(len(clouds)):\n        w1 += clouds[i][0]\n        clouds[i].append(w1)\n        w1 = clouds[i][1]\n        clouds[i].append(w1)\n        w1 = clouds[i][2]\n\n    walk_dist = [1]\n    walk_dist.extend(walk_dist)\n\n    for i in range(t):\n        walk_dist.append(0)\n\n    for i in range(len(clouds)):\n        walk_dist[clouds[i][0]] = clouds[i][1]\n        walk_dist[clouds[i][1]] = clouds[i][2]\n\n    distance_cloud_dict = {}\n    for i in range(len(clouds)):\n        distance_cloud_dict[clouds[i][0]] = clouds[i][3]\n\n    short_clouds = []\n    short_clouds_dict = {}\n    for i in range(len(clouds)):\n        if clouds[i][4] == 0.0:\n            short_clouds.append(i)\n            short_clouds_dict[i] = clouds[i][0]\n\n    walk_time = t\n    for i in range(len(clouds)):\n        walk_time += clouds[i][3]\n\n    bus_stop = d\n    for i in range(len(clouds)):\n        bus_stop = max(bus_stop, walk_time + clouds[i][0])\n\n    bus_stop = max(bus_stop, t)\n\n    print(\"#\" + \"\\t\" + \"short_clouds = \" + \"\\t\" + str(len(short_clouds)))\n    print(\"#\" + \"\\t\" + \"bus_stop = \" + \"\\t\" + str(bus_stop))\n    print(\"#\" + \"\\t\" + \"walk_dist = \" + \"\\t\" + str(walk_dist))\n    print(\"#\" + \"\\t\" + \"walk_time = \" + \"\\t\" + str(walk_time))\n    print(\"#\" + \"\\t\" + \"clouds = \" + \"\\t\" + str(clouds))\n    print(\"#\" + \"\\t\" + \"r_segs = \" + \"\\t\" + str(r_segs))\n    print(\"#\" + \"\\t\" + \"d = \" + \"\\t\" + str(d))\n    print(\"#\" + \"\\t\" + \"t = \" + \"\\t\" + str(t))\n    print(\"#\" + \"\\t\" + \"c = \" + \"\\t\" + str(c))\n    print(\"#\" + \"\\t\" + \"r = \" + \"\\t\" + str(r))\n\n    n = 1\n    for i in range(len(clouds)):\n        print(\"#\" + str(n) + \"\\t\" + str(clouds[i]))\n        n += 1\n\n    print(\"#\" + \"\\t\" + str(short_clouds))\n    print(\"#\" + \"\\t\" + str(short_clouds_dict))\n    return str(bus_stop - d)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # TO-DO: Implement a solution using the below defined helper functions and data structures\n    # model for a cloud\n    d, t, c = map(int, stdin.split())\n    clouds = []\n    for _ in range(c):\n        clouds.append(sorted([int(i) for i in stdin.split()]))\n    print(clouds)\n    ans = 0\n    # model for the bus\n    bus_stop = (0, 0, 0)\n    roof = []\n    # model for the route\n    route = (0, 0)\n    return ans\n"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r = (int(x) for x in stdin.split())\n    clouds = []\n    for _ in range(c):\n        clouds.append([int(x) for x in stdin.split()])\n    cloud_dict = {c[0]: [] for c in clouds}\n    for _, e, p, a in clouds:\n        cloud_dict[c[0]].append((e, p, a))\n    clouds = [c[0] for c in clouds]\n\n    def get_v_dist(s, t, p, a, cloud_dict):\n        if len(cloud_dict[s]) == 0:\n            return 0\n        t_s = 0\n        if s not in cloud_dict:\n            t_s = t\n        else:\n            for _, _, a_ in cloud_dict[s]:\n                t_s += max(1, a_ + a * p)\n        return max(t - t_s, 0)\n\n    def get_v_dist2(s, t, p, a, cloud_dict):\n        if len(cloud_dict[s]) == 0:\n            return 0\n        t_s = 0\n        if s not in cloud_dict:\n            t_s = t\n        else:\n            for _, _, a_ in cloud_dict[s]:\n                t_s += max(1, a_ + a * p)\n        return t_s\n\n    # print(get_v_dist2(2, 1, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(2, 1, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist(2, 1, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print(get_v_dist2(0, 0, 0.66666, 0.25, cloud_dict))\n    # print"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.strip().split('\\n')\n    for i in range(1, len(data), 2):\n        print('blue', float(data[i][:8]), float(data[i+1][:8]))\n    return"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    temp = list()\n    for i in range(len(input_data)):\n        temp.append([input_data[i].split(' ')[0], input_data[i].split(' ')[1], float(input_data[i].split(' ')[2])])\n    # print(temp)\n    print(temp[1][1])\n    # print(temp)\n    # print(type(temp))\n    # print(type(temp[1]))\n    # print(type(temp[1][0]))\n    # print(type(temp[1][1]))\n    # print(type(temp[1][2]))\n    # print(type(temp[2][0]))\n    # print(type(temp[2][1]))\n    # print(type(temp[2][2]))\n    return temp[1][1]\n    # print(temp[1][1])\n    # print(type(temp[1][1]))\n    # print(type(temp[1][2]))\n    # print(type(temp[2][2]))\n    # print(type(temp[2][1]))\n    # print(type(temp[2][0]))\n    # print(type(temp[2][2]))\n    # print(type(temp[2][2]))\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    #print(stdin)\n    global res\n    res = 0\n    def trade(buyer: str, offer: str, exchange_rate: float, num_pink: int, num_orange: int, num_yellow: int, num_green: int) -> None:\n        global res\n        #print(\"\\n\\n\\n\\n\\n\")\n        #print(\"Buyer:\", buyer)\n        #print(\"Offer:\", offer)\n        #print(\"Exchange rate:\", exchange_rate)\n        #print(\"Num of pink:\", num_pink)\n        #print(\"Num of orange:\", num_orange)\n        #print(\"Num of yellow:\", num_yellow)\n        #print(\"Num of green:\", num_green)\n        #print(res)\n        if offer == \"red\":\n            if num_orange + num_yellow >= num_pink:\n                #print(\"accept\")\n                res += (num_pink + num_orange) * (1/exchange_rate)\n        if offer == \"orange\":\n            if num_pink + num_yellow >= num_orange:\n                #print(\"accept\")\n                res += (num_pink + num_yellow) * (1/exchange_rate)\n        if offer == \"yellow\":\n            if num_orange + num_pink >= num_yellow:\n                #print(\"accept\")\n                res += (num_orange + num_pink) * (1/exchange_rate)\n        if offer == \"green\":\n            if num_yellow + num_pink >= num_green:\n                #print(\"accept\")\n                res += (num_yellow + num_pink) * (1/exchange_rate)\n        if offer == \"pink\":\n            if num_yellow + num_orange >= num_pink:\n                #print(\"accept\")\n                res += (num_yellow + num_orange) * (1/exchange_rate)\n    def trade_greedy(buyer: str, offer: str, exchange_rate: float, num_pink: int, num_orange: int, num_yellow: int, num_green: int) -> None:\n        global res\n        #print(\"\\n\\n\\n\\n\\n\")\n        #print(\"Buyer:\", buyer)\n        #print(\"Offer:\", offer)\n        #print(\"Exchange rate:\", exchange_rate)\n        #print(\"Num of pink:\", num_pink)\n        #print(\"Num of orange:\", num_orange)\n        #print(\"Num of yellow:\", num_yellow)\n        #print(\"Num of green:\", num_green)\n        #print(res)\n        if offer == \"red\":\n            if num_pink + num_yellow <= num_orange:\n                #print(\"accept\")\n                res += num_orange * (1/exchange_rate)\n        if offer == \"orange\":\n            if num_pink + num_yellow <= num_orange:\n                #print(\"accept\")\n                res += num_orange * (1/exchange_rate)\n        if offer == \"yellow\":\n            if num_orange + num_pink <= num_yellow:\n                #print(\"accept\")\n                res += num_yellow * (1/exchange_rate)\n        if offer == \"green\":\n            if num_yellow + num_pink <= num_green:\n                #print(\"accept\")\n                res += num_green * (1/exchange_rate)\n        if offer == \"pink\":\n            if num_orange + num_yellow <= num_pink:\n                #print(\"accept\")\n                res += num_pink * (1/exchange_rate)\n    def find_max(sellers: list, offers: list, exchange_rate: float) -> float:\n        global res\n        #print(\"\\n\\n\\n\\n\\n\")\n        #print(\"sellers:\", sellers)\n        #print(\"offers:\", offers)\n        #print(\"Exchange rate:\", exchange_rate)\n        #print(\"sellers length:\", len(sellers))\n        #print(\"offers length:\", len(offers))\n        #print(\"sellers:\", sellers)\n        #print(\"offers:\", offers)\n        #print(\"sellers:\", len(sellers))\n        #print(\"offers:\", len(offers))\n        #print(\"sellers:\", len(sellers))\n        #print(\"offers:\", len(offers))\n        #print(\"\\n\\n\\n\\n\\n\")\n        if len(sellers) == len(offers):\n            for i in range(len(sellers)):\n                trade(sellers[i], offers[i], exchange_rate, sellers[i], offers[i], sellers[i], offers[i])\n        else:\n            raise ValueError(\"The amount of sellers and the amount of offers is different. Please check the inputs.\")\n        #print(\"res:\", res)\n        #print(\"\\n\\n\\n\\n\\n\")\n        return res\n    def find_max_greedy(sellers: list, offers: list, exchange_rate: float) -> float:\n        global res\n        #print(\"\\n\\n\\n\\n\\n\")\n        #print(\"sellers:\", sellers)\n        #print(\"offers:\", offers)\n        #print(\"Exchange rate:\", exchange_rate)\n        #print(\"sellers length:\", len(sellers))\n        #print(\"offers length:\", len(offers))\n        #print(\"sellers:\", sellers)\n        #print(\"offers:\", offers)\n        #print(\"sellers:\", len(sellers))\n        #print(\"offers:\", len(offers))\n        #print(\"\\n\\n\\n\\n\\n\")\n        if len(sellers) == len(offers):\n            for i in range(len(sellers)):\n                trade_greedy(sellers[i], offers[i], exchange_rate, sellers[i], offers[i], sellers[i], offers[i])\n        else:\n            raise ValueError(\"The amount of sellers and the amount of offers is different. Please check the inputs.\")\n        #print(\"res:\", res)\n        "
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    people: List[Tuple[str, str, float]] = [\n        (x[0], x[1], float(x[2])) for x in (y.split() for y in stdin.split('\\n')[:-1])\n    ]\n    people.sort(key=lambda x: x[2])\n    people.sort(key=lambda x: x[0])\n    people.sort(key=lambda x: x[1])\n    return '%.6f' % (sum((float(x[2])*float(y[1])) for x, y in pairwise(people)))\n\ndef"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 0.0\n    for _ in range(n-1):\n        o, w, r = stdin.split('\\n')[_].split()\n        result += float(o) * float(w) * float(r)\n    return f'{result:.10f}'\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    class_names = [stdin.strip() for stdin in stdin.split('\\n')]\n    \n    exchange_rates = {}\n    \n    for i in range(n):\n        name1, name2, rate = stdin.strip().split()\n        if name1 in exchange_rates:\n            exchange_rates[name1].append(float(rate))\n        else:\n            exchange_rates[name1] = [float(rate)]\n        if name2 in exchange_rates:\n            exchange_rates[name2].append(float(rate))\n        else:\n            exchange_rates[name2] = [float(rate)]\n\n    max_amount = 0\n    for key, value in exchange_rates.items():\n        if len(value) > 1:\n            exchange_rates[key].sort()\n            max_amount += 10 * (1 + max(value) - value[0])\n    return str(max_amount)\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    c = 0\n    m = 0\n    while c < N:\n        o, w, r = stdin.split()\n        m += (int(r) * float(w) - float(w) * int(o))\n        c += 1\n    return str(m)\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def share_trade(a: str, b: str, c: float) -> int:\n        a_o, a_w, a_r = a.split()\n        b_o, b_w, b_r = b.split()\n        return int(a_w) * int(b_r) + int(b_w) * int(a_r) - int(c)\n    stdin_lines = stdin.strip().split(\"\\n\")\n    amount = 0\n    for line in stdin_lines:\n        amount += share_trade(line[0], line[1], line[2])\n    return str(amount)\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    people = [line.split() for line in stdin.splitlines()]\n    to_sell = {name: {'price': int(price * 2.5), 'offer': offer} for name, offer, price in people}\n    results = []\n    for i in range(len(people)):\n        results.append(float(\n            min(to_sell[name]['offer'] - to_sell[name]['price']\n                for name, offer, price in people\n                if name!= people[i][0]))\n        )\n    return '{:.9f}'.format(max(results) if len(results) >= 1 else 0)\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    exchanges = []\n    answers = []\n    for line in stdin.split('\\n'):\n        exchanges.append(line.split())\n    exchanges.pop(0)\n    max_ans = 0\n    for i in range(len(exchanges)):\n        if exchanges[i][0] == 'O':\n            for j in range(i+1, len(exchanges)):\n                if exchanges[j][0] == 'W':\n                    for k in range(j+1, len(exchanges)):\n                        if exchanges[k][0] == 'W':\n                            answers.append([exchanges[i][1], exchanges[j][1], exchanges[k][1]])\n        else:\n            for j in range(i+1, len(exchanges)):\n                if exchanges[j][0] == 'O':\n                    for k in range(j+1, len(exchanges)):\n                        if exchanges[k][0] == 'W':\n                            answers.append([exchanges[i][1], exchanges[j][1], exchanges[k][1]])\n    \n    for answer in answers:\n        cost = 0\n        if answer[0] == 'blue':\n            cost += answer[1]\n            if answer[2] =='red':\n                cost += answer[2]\n            elif answer[2] == 'green':\n                cost += answer[2]\n            elif answer[2] == 'yellow':\n                cost += answer[2]\n            elif answer[2] == 'orange':\n                cost += answer[2]\n            elif answer[2] == 'pink':\n                cost += answer[2]\n        elif answer[0] == 'yellow':\n            cost += answer[2]\n            if answer[1] =='red':\n                cost += answer[1]\n            elif answer[1] == 'green':\n                cost += answer[1]\n            elif answer[1] == 'blue':\n                cost += answer[1]\n            elif answer[1] == 'orange':\n                cost += answer[1]\n            elif answer[1] == 'pink':\n                cost += answer[1]\n        elif answer[0] == 'orange':\n            cost += answer[2]\n            if answer[1] =='red':\n                cost += answer[1]\n            elif answer[1] == 'green':\n                cost += answer[1]\n            elif answer[1] == 'blue':\n                cost += answer[1]\n            elif answer[1] == 'yellow':\n                cost += answer[1]\n            elif answer[1] == 'pink':\n                cost += answer[1]\n        elif answer[0] == 'pink':\n            cost += answer[2]\n            if answer[1] =='red':\n                cost += answer[1]\n            elif answer[1] == 'green':\n                cost += answer[1]\n            elif answer[1] == 'blue':\n                cost += answer[1]\n            elif answer[1] == 'yellow':\n                cost += answer[1]\n            elif answer[1] == 'orange':\n                cost += answer[1]\n        max_ans = max(max_ans, cost)\n    return str(max_ans)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip().split(' ')[0])\n    r, s, m, d, n = int(stdin.strip().split(' ')[1]), int(stdin.strip().split(' ')[2]), int(stdin.strip().split(' ')[3]), int(stdin.strip().split(' ')[4]), int(stdin.strip().split(' ')[5])\n    brands = {int(stdin.strip().split(' ')[i]): i for i in range(1, n + 1)}\n    brands_mapping = {}\n    brands_mapping_2 = {}\n    brands_mapping_3 = {}\n    brands_mapping_4 = {}\n    brands_mapping_5 = {}\n    brands_mapping_6 = {}\n    brands_mapping_7 = {}\n    brands_mapping_8 = {}\n    brands_mapping_9 = {}\n    brands_mapping_10 = {}\n    brands_mapping_11 = {}\n    brands_mapping_12 = {}\n    brands_mapping_13 = {}\n    brands_mapping_14 = {}\n    brands_mapping_15 = {}\n    brands_mapping_16 = {}\n    brands_mapping_17 = {}\n    brands_mapping_18 = {}\n    brands_mapping_19 = {}\n    brands_mapping_20 = {}\n    brands_mapping_21 = {}\n    brands_mapping_22 = {}\n\n    def get_brands_for_dish(dish_id, dish_brands, visited_brands):\n        if dish_id in visited_brands:\n            return\n        for b in dish_brands:\n            if b in visited_brands:\n                continue\n            visited_brands.add(b)\n            brands_mapping[b] = dish_id\n            if len(visited_brands) == n:\n                return\n            get_brands_for_dish(dish_id + 1, dish_brands, visited_brands)\n\n    def get_brands_for_dish_2(dish_id, dish_brands, visited_brands, brands_mapping_2):\n        if dish_id in visited_brands:\n            return\n        for b in dish_brands:\n            if b in visited_brands:\n                continue\n            visited_brands.add(b)\n            brands_mapping_2[b] = dish_id\n            if len(visited_brands) == n:\n                return\n            get_brands_for_dish_2(dish_id + 1, dish_brands, visited_brands, brands_mapping_2)\n\n    def get_brands_for_dish_3(dish_id, dish_brands, visited_brands, brands_mapping_3):\n        if dish_id in visited_brands:\n            return\n        for b in dish_brands:\n            if b in visited_brands:\n                continue\n            visited_brands.add(b)\n            brands_mapping_3[b] = dish_id\n            if len(visited_brands) == n:\n                return\n            get_brands_for_dish_3(dish_id + 1, dish_brands, visited_brands, brands_mapping_3)\n\n    def get_brands_for_dish_4(dish_id, dish_brands, visited_brands, brands_mapping_4):\n        if dish_id in visited_brands:\n            return\n        for b in dish_brands:\n            if b in visited_brands:\n                continue\n            visited_brands.add(b)\n            brands_mapping_4[b] = dish_id\n            if len(visited_brands) == n:\n                return\n            get_brands_for_dish_4(dish_id + 1, dish_brands, visited_brands, brands_mapping_4)\n\n    def get_brands_for_dish_5(dish_id, dish_brands, visited_brands, brands_mapping_5):\n        if dish_id in visited_brands:\n            return\n        for b in dish_brands:\n            if b in visited_brands:\n                continue\n            visited_brands.add(b)\n            brands_mapping_5[b] = dish_id\n            if len(visited_brands) == n:\n                return\n            get_brands_for_dish_5(dish_id + 1, dish_brands, visited_brands, brands_mapping_5)\n\n    def get_brands_for_dish_6(dish_id, dish_brands, visited_brands, brands_mapping_6):\n        if dish_id in visited_brands:\n            return\n        for b in dish_brands:\n            if b in visited_brands:\n                continue\n            visited_brands.add(b)\n            brands_mapping_6[b] = dish_id"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    pass\n"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # --- your code goes here\n    r, s, m, d, n = map(int, stdin.split())\n    brands = [int(x) for x in stdin.split()[1:]]\n    starter = []\n    main = []\n    desserts = []\n    for line in stdin.split('\\n')[2:]:\n        splitted = line.split()\n        brands = set(splitted[1:])\n        for i in range(1, len(splitted)):\n            splitted[i] = int(splitted[i])\n        if splitted[0] == r:\n            starter.append(splitted[1:])\n        if splitted[0] == s:\n            main.append(splitted[1:])\n        if splitted[0] == m:\n            desserts.append(splitted[1:])\n    for _ in range(1, len(starter) + 1):\n        starter_dishes = [x + _ for x in starter]\n        for _ in range(1, len(main) + 1):\n            main_dishes = [x + _ for x in main]\n            for _ in range(1, len(desserts) + 1):\n                desserts_dishes = [x + _ for x in desserts]\n                if len(set(starter_dishes) & set(main_dishes)) > 0 or len(set(starter_dishes) & set(desserts_dishes)) > 0 or len(set(main_dishes) & set(desserts_dishes)) > 0:\n                    continue\n                for i in range(1, len(starter_dishes) + 1):\n                    for j in range(1, len(main_dishes) + 1):\n                        for k in range(1, len(desserts_dishes) + 1):\n                            if len(set(starter_dishes[:i]) & set(main_dishes[:j])) > 0 or len(set(starter_dishes[:i]) & set(desserts_dishes[:k])) > 0 or len(set(main_dishes[:j]) & set(desserts_dishes[:k])) > 0:\n                                continue\n                            if i == j and k == k:\n                                continue\n                            if i == 1 and j == k:\n                                continue\n                            total = len(set(starter_dishes[:i]) & set(main_dishes[:j]) & set(desserts_dishes[:k]))\n                            if total > 10 ** 18:\n                                return \"too many\"\n                            if total < 10 ** 18:\n                                return str(total)\n                        if len(set(starter_dishes[:i]) & set(main_dishes[:j])) > 0 or len(set(starter_dishes[:i]) & set(desserts_dishes[:k])) > 0 or len(set(main_dishes[:j]) & set(desserts_dishes[:k])) > 0:\n                            continue\n                        for l in range(1, len(starter_dishes) + 1):\n                            for m in range(1, len(main_dishes) + 1):\n                                for n in range(1, len(desserts_dishes) + 1):\n                                    if len(set(starter_dishes[:i]) & set(main_dishes[:j]) & set(desserts_dishes[:k])) > 0 or len(set(starter_dishes[:l]) & set(main_dishes[:m])) > 0 or len(set(starter_dishes[:l]) & set(desserts_dishes[:n])) > 0 or len(set(main_dishes[:j]) & set(desserts_dishes[:n])) > 0:\n                                        continue\n                                    if l == m and n == n:\n                                        continue\n                                    if i == 1 and j == k and l == m and n == n:\n                                        continue\n                                    total = len(set(starter_dishes[:i]) & set(main_dishes[:j]) & set(desserts_dishes[:k]) & set(starter_dishes[:l]) & set(main_dishes[:m]) & set(desserts_dishes[:n]))\n                                    if total > 10 ** 18:\n                                        return \"too many\"\n                                    if total < 10 ** 18:\n                                        return str(total)\n    return \"too many\""
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    records = stdin.strip().split('\\n')\n    return str(solution_helper(records))\n\ndef"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num_dishes = int(stdin.strip().split()[0])\n    num_brands = int(stdin.strip().split()[1])\n    dishes = list(map(int, stdin.strip().split()[2:]))\n    brands = list(map(int, stdin.strip().split()[3:]))\n    n = num_dishes * num_brands\n    possible_dishes = set(range(1, num_dishes + 1))\n    possible_brands = set(range(1, num_brands + 1))\n\n    for dish in dishes:\n        possible_dishes.remove(dish)\n        possible_brands.intersection_update([brands[i] for i in range(num_brands) if dishes[i] == dish])\n\n    for _ in range(n - len(possible_dishes)):\n        possible_dishes.add(1)\n\n    for _ in range(n - len(possible_brands)):\n        possible_brands.add(1)\n\n    dishes = list(possible_dishes)\n    brands = list(possible_brands)\n\n    # create the graph\n    graph = {}\n    for i in range(1, num_brands + 1):\n        graph[i] = {1}\n    for i in range(1, num_dishes + 1):\n        graph[i] = set()\n\n    # add the edges\n    for i in range(1, num_brands + 1):\n        for j in range(1, num_dishes + 1):\n            if brands[i - 1] == j:\n                graph[i].add(j)\n\n    # find the cycles\n    visited = set()\n    def dfs(current_brands: int, current_dishes: int):\n        if (current_brands, current_dishes) in visited:\n            return 0\n\n        visited.add((current_brands, current_dishes))\n\n        for child in graph[current_dishes]:\n            if child in graph[current_brands]:\n                continue\n\n            if child not in visited:\n                dfs(current_brands, child)\n\n    # finding the max number of dish with a single chef\n\n    max_number_of_dishes = -1\n    number_of_dishes = 0\n\n    while number_of_dishes < n:\n        # check if there is a single chef\n        if len(possible_dishes) == 1:\n            number_of_dishes += 1\n            continue\n\n        # check if there is a single chef\n        if len(possible_brands) == 1:\n            number_of_dishes += 1\n            continue\n\n        number_of_dishes = 1\n        dfs(1, dishes[0])\n\n        if number_of_dishes == n:\n            break\n\n        number_of_dishes = len(possible_dishes) + 1\n        dfs(1, dishes[0])\n\n        if number_of_dishes == n:\n            break\n\n        number_of_dishes = len(possible_brands) + 1\n        dfs(1, dishes[0])\n\n        if number_of_dishes == n:\n            break\n\n        number_of_dishes = 1\n        dfs(1, dishes[0])\n\n        if number_of_dishes == n:\n            break\n\n    return str(number_of_dishes - 1) if number_of_dishes <= 10**18 else \"too many\"\n\nprint(solution(input()))"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    stdin = stdin.split()\n    x = 0\n    for i in stdin:\n        x += int(i)\n    if x > 1000000:\n        return \"too many\"\n    else:\n        return str(x)\nprint(solution(input()))\n"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.strip().split())\n    brands = []\n    for _ in range(r):\n        brand = list(map(int, stdin.strip().split()))\n        brands.append(brand)\n\n    starter_dishes = []\n    main_dishes = []\n    desserts = []\n\n    for _ in range(s):\n        starter_dishes.append(list(map(int, stdin.strip().split())))\n    for _ in range(m):\n        main_dishes.append(list(map(int, stdin.strip().split())))\n    for _ in range(d):\n        desserts.append(list(map(int, stdin.strip().split())))\n\n    all_pairs = []\n    for _ in range(n):\n        all_pairs.append(list(map(int, stdin.strip().split())))\n\n    all_pairs_list = []\n    for i in range(n):\n        all_pairs_list.append(all_pairs[i][0])\n\n    all_pairs_list_2 = []\n    for i in range(n):\n        all_pairs_list_2.append(all_pairs[i][1])\n\n    all_pairs_list_3 = []\n    for i in range(n):\n        all_pairs_list_3.append(all_pairs[i][2])\n\n    #print(all_pairs_list)\n    #print(all_pairs_list_2)\n    #print(all_pairs_list_3)\n\n    #print(starter_dishes)\n    #print(main_dishes)\n    #print(desserts)\n\n    no_of_dinner_experiences = 0\n\n    #starter_dishes_set = set()\n    #main_dishes_set = set()\n    #desserts_set = set()\n\n    #starter_dishes_dict = {}\n    #main_dishes_dict = {}\n    #desserts_dict = {}\n\n    starter_dishes_set_2 = set()\n    main_dishes_set_2 = set()\n    desserts_set_2 = set()\n\n    starter_dishes_set_3 = set()\n    main_dishes_set_3 = set()\n    desserts_set_3 = set()\n\n    #starter_dishes_dict = {}\n    #main_dishes_dict = {}\n    #desserts_dict = {}\n\n    starter_dishes_set_2_dict = {}\n    main_dishes_set_2_dict = {}\n    desserts_set_2_dict = {}\n\n    starter_dishes_set_3_dict = {}\n    main_dishes_set_3_dict = {}\n    desserts_set_3_dict = {}\n\n    #starter_dishes_dict = {}\n    #main_dishes_dict = {}\n    #desserts_dict = {}\n\n    for dish in starter_dishes:\n        for dish_brands in brands:\n            if dish == dish_brands:\n                for dish_brands_2 in brands:\n                    if dish_brands!= dish_brands_2:\n                        if dish_brands!= dish:\n                            if dish_brands_2 not in starter_dishes_set_2:\n                                starter_dishes_set_2.add(dish_brands_2)\n                                starter_dishes_set_2_dict[dish_brands_2] = 0\n                            starter_dishes_set_2_dict[dish_brands_2] += 1\n\n    for dish in main_dishes:\n        for dish_brands in brands:\n            if dish == dish_brands:\n                for dish_brands_2 in brands:\n                    if dish_brands!= dish_brands_2:\n                        if dish_brands!= dish:\n                            if dish_brands_2 not in main_dishes_set_2:\n                                main_dishes_set_2.add(dish_brands_2)\n                                main_dishes_set_2_dict[dish_brands_2] = 0\n                            main_dishes_set_2_dict[dish_brands_2] += 1\n\n    for dish in desserts:\n        for dish_brands in brands:\n            if dish == dish_brands:\n                for dish_brands_2 in brands:\n                    if dish_brands!= dish_brands_2:\n                        if dish_brands!= dish:\n                            if dish_brands_2 not in desserts_set_2:\n                                desserts_set_2.add(dish_brands_2)\n                                desserts_set_2_dict[dish_brands_2] = 0\n                            desserts_set_2_dict[dish_brands_2] += 1\n\n    for i in range(n):\n        if all_pairs_list[i] == 1:\n            starter_dishes_set.add(all_pairs_list_2[i])\n            main_dishes_set.add(all_pairs_list_3[i])\n            d"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.split())\n    brands = {int(i) for i in stdin.split()[2:r]}\n    brands = sorted(brands)\n    dishes = []\n    for i in range(1, s + 1):\n        dishes.append(int(stdin.split()[i]))\n    for i in range(s + 1, s + m + 1):\n        dishes.append(int(stdin.split()[i]))\n    for i in range(s + m + 1, s + m + d + 1):\n        dishes.append(int(stdin.split()[i]))\n    if s + m + d + 1 > n:\n        return 'too many'\n    exists = set()\n    for i in range(len(dishes)):\n        for j in range(len(dishes)):\n            if dishes[i]!= dishes[j] and (i, j) not in exists and (dishes[i], dishes[j]) not in exists:\n                exists.add((i, j))\n                exists.add((j, i))\n    ans = 0\n    for i in range(len(dishes)):\n        for j in range(len(dishes)):\n            for k in range(len(dishes)):\n                if dishes[i]!= dishes[j] and dishes[i]!= dishes[k] and dishes[j]!= dishes[k] and (i, j) not in exists and (dishes[i], dishes[j]) not in exists and (dishes[j], dishes[i]) not in exists and (dishes[i], dishes[k]) not in exists and (dishes[j], dishes[k]) not in exists:\n                    ans += 1\n    return str(ans)\n"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return \"too many\" if (\n        int(len(stdin.split('\\n')) / 2) > 10 ** 18\n    ) else str(\n        int(len(set(len(line.split()) for line in stdin.split('\\n')))))\n\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(solution(input()))\nprint(s"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def ingredients(ingredient):\n        return len(ingredient)\n\n    def num_dishes(dishes):\n        return len(set(dishes))\n\n    def make_dishes(dishes):\n        count = 0\n        for i in range(len(dishes)):\n            for j in range(len(dishes)):\n                if i == j:\n                    continue\n                if dishes[i] == dishes[j]:\n                    count += 1\n        return count\n\n    def conflict(dishes):\n        conflict_list = []\n        for i in range(len(dishes)):\n            for j in range(len(dishes)):\n                if i == j:\n                    continue\n                if dishes[i] == dishes[j]:\n                    conflict_list.append(i)\n                    conflict_list.append(j)\n        return len(conflict_list)\n\n    r = int(stdin.split()[0])\n    s = int(stdin.split()[1])\n    m = int(stdin.split()[2])\n    d = int(stdin.split()[3])\n    n = int(stdin.split()[4])\n    dishes = []\n    for _ in range(r):\n        dishes.append(stdin.split()[5 + _])\n\n    for i in range(n):\n        if dishes[i] == dishes[i + 1]:\n            return 'too many'\n        if ingredients(dishes[i]) > s or ingredients(dishes[i]) > m or ingredients(dishes[i]) > d:\n            return 'too many'\n        if ingredients(dishes[i]) == s:\n            dishes[i], dishes[i + 1] = dishes[i + 1], dishes[i]\n        if ingredients(dishes[i]) == m:\n            if ingredients(dishes[i]) * 2 == m:\n                dishes[i], dishes[i + 1] = dishes[i + 1], dishes[i]\n            else:\n                dishes[i], dishes[i + 1] = dishes[i + 1], dishes[i]\n        if ingredients(dishes[i]) == d:\n            if ingredients(dishes[i]) * 3 == d:\n                dishes[i], dishes[i + 1] = dishes[i + 1], dishes[i]\n            else:\n                dishes[i], dishes[i + 1] = dishes[i + 1], dishes[i]\n\n    return make_dishes(dishes) + conflict(dishes)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    height = int(lines[0])\n    width = int(lines[1])\n    n = int(lines[2])\n    target = lines[3:]\n    min_steps = -1\n    max_steps = -1\n    board = [['.'] * width for _ in range(height)]\n    for i in range(height):\n        for j in range(width):\n            if target[i][j] == '#':\n                board[i][j] = '#'\n    for i in range(height):\n        for j in range(width):\n            if target[i][j] == '#':\n                continue\n            for command in lines[3+2*i+j]:\n                direction, distance = command[0], int(command[1:])\n                if direction in ['left', 'right']:\n                    if board[i][j] == '#':\n                        continue\n                    if direction == 'left':\n                        for _ in range(distance):\n                            if j > 0:\n                                j -= 1\n                        continue\n                    if direction == 'right':\n                        for _ in range(distance):\n                            if j < width - 1:\n                                j += 1\n                        continue\n                if direction in ['up', 'down']:\n                    if board[i][j] == '#':\n                        continue\n                    if direction == 'up':\n                        for _ in range(distance):\n                            if i > 0:\n                                i -= 1\n                        continue\n                    if direction == 'down':\n                        for _ in range(distance):\n                            if i < height - 1:\n                                i += 1\n                        continue\n    for i in range(height):\n        for j in range(width):\n            if target[i][j] == '#':\n                continue\n            if board[i][j] == '#':\n                if min_steps == -1:\n                    min_steps = 0\n                if max_steps == -1:\n                    max_steps = 0\n                min_steps += 1\n                max_steps += 1\n            else:\n                min_steps = max(min_steps, 0)\n                max_steps = max(max_steps, 0)\n    if min_steps == -1:\n        return '-1 -1'\n    return str(min_steps) +'' + str(max_steps)\n"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    board = [[] for _ in range(x)]\n    h, w, n = 0, 0, 0\n    for _ in range(y):\n        line = stdin.split()[h]\n        h += 1\n        for char in line:\n            board[w].append(char)\n            w += 1\n            if w == x:\n                w = 0\n                h += 1\n                n += 1\n    move = {'up': (-1, 0), 'down': (1, 0), 'left': (0, -1), 'right': (0, 1)}\n    pos = (0, 0)\n    result = -1, -1\n    for _ in range(n):\n        for i in range(len(board[pos[0]])):\n            if board[pos[0]][i] == '#':\n                continue\n            else:\n                board[pos[0]][i] = '#'\n                break\n        else:\n            continue\n        for i in range(len(board[pos[1]])):\n            if board[pos[1]][i] == '#':\n                continue\n            else:\n                board[pos[1]][i] = '#'\n                break\n        else:\n            continue\n        pos = move[stdin.split()[0]]\n    for i in range(len(board)):\n        for j in range(len(board[i])):\n            if board[i][j] == '#':\n                continue\n            else:\n                board[i][j] = '.'\n                break\n        else:\n            continue\n        for j in range(len(board[i])):\n            if board[i][j] == '#':\n                continue\n            else:\n                board[i][j] = '.'\n                break\n        else:\n            continue\n    for i in range(len(board)):\n        for j in range(len(board[i])):\n            if board[i][j] == '.':\n                result = i, j\n    return str(result[0]) +'' + str(result[1])\n"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip().split()[0])\n    h, w, n = map(int, stdin.strip().split()[1:])\n    board = [[stdin.strip().split()[i + 1] for i in range(w)] for j in range(h)]\n    s = [(i, j) for i in range(h) for j in range(w)]\n    s.sort()\n    dp = [[0] * w for i in range(h)]\n    for i in range(n):\n        direction, distance = stdin.strip().split()[i + 1].split(\" \")\n        direction = direction.lower()\n        distance = int(distance)\n        if direction == \"up\":\n            s.sort(key=lambda x: x[1])\n            for j in range(w):\n                dp[s[0][0]][j] = max(dp[s[0][0]][j], dp[s[0][0] - 1][j] + distance)\n            for i in range(h):\n                dp[i][s[0][1]] = max(dp[i][s[0][1]], dp[i - 1][s[0][1]] + distance)\n            s.remove(s[0])\n        elif direction == \"down\":\n            s.sort(key=lambda x: x[1])\n            for j in range(w):\n                dp[s[0][0]][j] = max(dp[s[0][0]][j], dp[s[0][0] + 1][j] + distance)\n            for i in range(h):\n                dp[i][s[0][1]] = max(dp[i][s[0][1]], dp[i + 1][s[0][1]] + distance)\n            s.remove(s[0])\n        elif direction == \"right\":\n            s.sort(key=lambda x: x[0])\n            for j in range(w):\n                dp[s[0][0]][j] = max(dp[s[0][0]][j], dp[s[0][0]][j + 1] + distance)\n            for i in range(h):\n                dp[i][s[0][1]] = max(dp[i][s[0][1]], dp[i][s[0][1] + 1] + distance)\n            s.remove(s[0])\n        elif direction == \"left\":\n            s.sort(key=lambda x: x[0])\n            for j in range(w):\n                dp[s[0][0]][j] = max(dp[s[0][0]][j], dp[s[0][0]][j - 1] + distance)\n            for i in range(h):\n                dp[i][s[0][1]] = max(dp[i][s[0][1]], dp[i][s[0][1] - 1] + distance)\n            s.remove(s[0])\n    for i in range(h):\n        for j in range(w):\n            if board[i][j] == \"#\":\n                dp[i][j] += 1\n    min_pos = min(map(lambda x: max(x), dp))\n    max_pos = max(map(lambda x: min(x), dp))\n    if min_pos > max_pos:\n        return \"-1 -1\"\n    return str(min_pos) + \" \" + str(max_pos)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def move(direction, distance):\n        return {\n            'up': (0, -1),\n            'down': (0, 1),\n            'left': (-1, 0),\n            'right': (1, 0)\n        }[direction](distance)\n\n    def dry_marker(marker, step):\n        for _ in range(step):\n            step -= 1\n            x, y = marker\n            if marker[1] < y:\n                marker = (x, marker[1] + 1)\n            else:\n                marker = (x, y - 1)\n\n        return step\n\n    h, w, n = map(int, stdin.strip().split())\n    marker = (0, 0)\n    board = [['.' for _ in range(w)] for _ in range(h)]\n    dry_steps = []\n\n    for _ in range(n):\n        command = stdin.strip().split()[0]\n        direction, distance = map(str, command[0].strip().split(' '))\n        direction = {'up', 'down', 'left', 'right'}\n        direction = direction.pop()\n        distance = int(distance)\n\n        step = dry_marker(marker, distance)\n        if step == -1:\n            return '-1 -1'\n\n        dry_steps.append(step)\n        board[marker[1]][marker[0]] = '#'\n\n        if direction == 'up':\n            marker = move(direction, distance)\n        elif direction == 'down':\n            marker = move(direction, distance)\n        elif direction == 'left':\n            marker = move(direction, distance)\n        elif direction == 'right':\n            marker = move(direction, distance)\n        else:\n            print(direction)\n            break\n\n    dry_steps.sort()\n    for row in board:\n        print(''.join(row))\n\n    return '{} {}'.format(min(dry_steps), max(dry_steps))"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = [int(x) for x in stdin.split()]\n    board = [['.'] * (w + 2) for _ in range(h + 2)]\n    marker = {'up': (0, -1), 'down': (0, 1), 'left': (-1, 0), 'right': (1, 0)}\n    \n    for i in range(1, h + 1):\n        row = stdin[i].split()\n        for j, char in enumerate(row):\n            board[i][j] = char\n\n    # Pipes to represent the program\n    pipes = deque()\n    # Used for moving the marker and checking if it has touched any cells.\n    touched = set()\n\n    # To keep track of the number of moves\n    moves = 0\n    # To keep track of the marker location\n    curr_x = 0\n    curr_y = 0\n    # To keep track of the current timestep\n    curr_step = 0\n\n    # If there is no marker to be dry at the beginning\n    if board[curr_x][curr_y] == '.':\n        return '-1 -1'\n    \n    # Marker is now at the beginning of the board\n    board[curr_x][curr_y] = '#'\n    touched.add((curr_x, curr_y))\n    # Add the marker to the pipes\n    pipes.append((curr_x, curr_y))\n\n    # For each iteration\n    for _ in range(n):\n        # While the marker is not at the end\n        while pipes and (curr_x, curr_y)!= pipes[0]:\n            # Add the previous pipe to the end of the pipes queue\n            pipes.appendleft(pipes.pop())\n        \n        # Check if the marker is dry at this timestep\n        if (curr_x, curr_y) in touched:\n            return '-1 -1'\n\n        # If the marker is not dry at this timestep\n        # Get the next direction to move\n        dir, distance = pipes.popleft()\n        # Calculate the new position of the marker\n        new_x, new_y = (curr_x + marker[dir]) * (1 + distance), (curr_y + marker[dir]) * (1 + distance)\n        # Check if the marker has moved outside the board\n        if new_x < 0 or new_x >= len(board):\n            return '-1 -1'\n        elif new_y < 0 or new_y >= len(board[0]):\n            return '-1 -1'\n        # Update the marker position\n        curr_x, curr_y = new_x, new_y\n        # Add the new position to the visited cells\n        touched.add((curr_x, curr_y))\n        # Check if the marker has touched a cell\n        if board[curr_x][curr_y]!= '.':\n            return '-1 -1'\n        # Marker is now at the position now\n        board[curr_x][curr_y] = '#'\n        # Add the marker to the pipes\n        pipes.append((curr_x, curr_y))\n\n        # Update the current timestep\n        curr_step += 1\n        # If there is a new position to go to\n        if board[new_x][new_y] == '.':\n            # Add the new position to the pipes\n            pipes.append((new_x, new_y))\n        # Else if there is a pipe to go to\n        else:\n            # Move to the new position\n            curr_x, curr_y = new_x, new_y\n            # Check if the marker has touched a cell\n            if board[curr_x][curr_y]!= '.':\n                return '-1 -1'\n            # Marker is now at the position now\n            board[curr_x][curr_y] = '#'\n            # Add the marker to the pipes\n            pipes.append((curr_x, curr_y))\n\n        # If the marker is at the beginning\n        if curr_step == 1:\n            # Add the marker to the pipes\n            pipes.append((curr_x, curr_y))\n    \n    # Return the minimum and maximum times that the marker can pass\n    return f'{min(pipes)} {max(pipes)}'"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    board = stdin.split()\n    h, w, n = map(int, board[:3])\n    marker_pattern = board[3:]\n    print(h, w, n, marker_pattern)\n    up, down, left, right = map(int, stdin.split())\n    target_drawing = []\n    result = 0\n    min_time = 0\n    max_time = 0\n    for i in range(h):\n        target_drawing.append(marker_pattern[i])\n    for i in range(h):\n        target_drawing.append(\"\")\n    for command in board[n+1:]:\n        if \"up\" in command:\n            step = up\n        elif \"down\" in command:\n            step = down\n        elif \"left\" in command:\n            step = left\n        elif \"right\" in command:\n            step = right\n        if step == 1:\n            step = 2\n        while step!= 0:\n            if target_drawing[i] == \"\":\n                target_drawing[i] = marker_pattern[i]\n            elif target_drawing[i]!= marker_pattern[i]:\n                target_drawing[i] = \".\"\n            i += step\n            step = step if step!= 1 else 2\n        print(\" \".join(target_drawing))\n        if max_time == 0:\n            max_time = i\n        result = i if result == 0 else min(result, i)\n    if max_time > 0:\n        min_time = max_time\n    if min_time > 0:\n        max_time = min(max_time, h-1)\n    return str(min_time)+\" \"+str(max_time)\nprint(solution(input()))"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split())\n    board = [['.'] * w for _ in range(h)]\n    turtle = Turtle(board, h, w, n)\n    pos = (-1, -1)\n    x, y = 0, 0\n    for i in range(n):\n        direction, distance = stdin.split()\n        if direction in 'udlr':\n            dx = 0\n            if direction == 'u':\n                dx = -1\n            elif direction == 'd':\n                dx = 1\n            elif direction == 'l':\n                dx = -1\n            elif direction == 'r':\n                dx = 1\n            x += dx * int(distance)\n        elif direction == 'up':\n            y -= 1\n        elif direction == 'down':\n            y += 1\n        elif direction == 'left':\n            x -= 1\n        elif direction == 'right':\n            x += 1\n        board[y][x] = '#'\n        if pos == (-1, -1):\n            pos = (x, y)\n    return str(pos[0]) +'' + str(pos[1])\n"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, h, w, *commands = map(int, stdin.split())\n    board = [['.'] * w for _ in range(h)]\n    direction = 'up'\n    direction_map = {'up': 0, 'down': 1, 'left': 2, 'right': 3}\n    for command in commands:\n        direction, step = command[0], int(command[1:])\n        if direction == 'up':\n            for _ in range(step):\n                if direction_map[direction] == 0:\n                    board = [['.'] + row for row in board]\n                elif direction_map[direction] == 1:\n                    board = [['.'] + row[:-1] for row in board]\n                elif direction_map[direction] == 2:\n                    board = [['.'] + row[1:] for row in board]\n                elif direction_map[direction] == 3:\n                    board = [['.'] + row[1:-1] for row in board]\n        elif direction == 'down':\n            for _ in range(step):\n                if direction_map[direction] == 0:\n                    board = [['.'] + row[::-1] for row in board]\n                elif direction_map[direction] == 1:\n                    board = [['.'] + row for row in board[::-1]]\n                elif direction_map[direction] == 2:\n                    board = [['.'] + row[:-1] for row in board[::-1]]\n                elif direction_map[direction] == 3:\n                    board = [['.'] + row[1:] for row in board[::-1]]\n        elif direction == 'left':\n            for _ in range(step):\n                if direction_map[direction] == 0:\n                    board = [[row] + ['.'] * (w-1) for row in board[::-1]]\n                elif direction_map[direction] == 1:\n                    board = [[row] + ['.'] * (w-1) for row in board]\n                elif direction_map[direction] == 2:\n                    board = [[row] + ['.'] * (w-1) for row in board]\n                elif direction_map[direction] == 3:\n                    board = [[row] + ['.'] * (w-1) for row in board]\n        elif direction == 'right':\n            for _ in range(step):\n                if direction_map[direction] == 0:\n                    board = [['.'] + row[1:] for row in board]\n                elif direction_map[direction] == 1:\n                    board = [['.'] + row for row in board]\n                elif direction_map[direction] == 2:\n                    board = [['.'] + row[:-1] for row in board]\n                elif direction_map[direction] == 3:\n                    board = [['.'] + row[1:] for row in board]\n        else:\n            print('Unknown direction')\n            return\n    h = len(board)\n    w = len(board[0])\n    for row in board:\n        for char in row:\n            if char == '.':\n                board = board[1:]\n                break\n    h = len(board)\n    w = len(board[0])\n    for i in range(h):\n        for j in range(w):\n            if board[i][j] == '.':\n                board[i][j] = '#'\n    for row in board:\n        for char in row:\n            if char == '#':\n                board = board[:-1]\n                break\n    h = len(board)\n    w = len(board[0])\n    for i in range(h-1, -1, -1):\n        for j in range(w-1, -1, -1):\n            if board[i][j] == '.':\n                board[i][j] = '#'\n    return str(min(h, w)) +'' + str(max(h, w))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split())\n    board = [['#'] * w for _ in range(h)]\n    timestep = 1\n    for _ in range(n):\n        timestep += 1\n        new_board = [['#'] * w for _ in range(h)]\n        for y in range(h):\n            for x in range(w):\n                cell = board[y][x]\n                neighbors = [\n                    board[y + 1][x],\n                    board[y][x + 1],\n                    board[y - 1][x],\n                    board[y][x - 1]\n                ]\n                if cell == '#':\n                    if '#' not in neighbors:\n                        new_board[y][x] = '.'\n                else:\n                    if '#' in neighbors:\n                        new_board[y][x] = '#'\n        board = new_board\n    return (board, timestep)\n"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.strip().split())\n    board = [[c for c in stdin.strip()] for _ in range(h)]\n    min_steps = float('inf')\n    max_steps = -float('inf')\n    for i in range(h):\n        for j in range(w):\n            steps_so_far = 0\n            steps_to_end = 0\n            if board[i][j] == '#':\n                steps_so_far = min(steps_so_far, j + 1)\n                steps_to_end = min(steps_to_end, w - j - 1)\n            while steps_so_far + steps_to_end + i >= n:\n                if i >= n:\n                    break\n                if board[i][j] == '#':\n                    steps_so_far += 1\n                if board[i][j + steps_to_end] == '#':\n                    steps_to_end -= 1\n                i += 1\n            if steps_so_far + steps_to_end <= n:\n                if steps_so_far + steps_to_end > max_steps:\n                    max_steps = steps_so_far + steps_to_end\n                if steps_so_far + steps_to_end < min_steps:\n                    min_steps = steps_so_far + steps_to_end\n    return f\"{min_steps} {max_steps}\" if min_steps!= float('inf') and max_steps!= -float('inf') else \"-1 -1\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    n = int(N / 4)\n    data = [list(map(int, stdin.strip().split())) for i in range(n)]\n    # print(data)\n    # print(data[0])\n    if any([(s[0] - 1) == i or (s[1] - 1) == i for i, s in enumerate(data)]):\n        return \"impossible\"\n    return str(sorted(data, key=lambda x: (x[0] + x[1]))[0][0])\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 2\n   ... 3\n   ... 2 4 7\n   ... 2 3 8\n   ... 3 1 9\n   ... 3 2 6\n   ... 2 5 5\n   ... 5 6 5\n   ... 5 4 4\n   ... 3 7 8\n   ... 7 8 7\n   ... ''')\n    '4'\n    >>> solution('''\n   ... 2\n   ... 3\n   ... 2 4 7\n   ... 2 3 8\n   ... 3 1 9\n   ... 3 2 6\n   ... 2 5 5\n   ... 5 6 5\n   ... 5 4 4\n   ... 3 7 8\n   ... 7 8 7\n   ... ''')\n    'impossible'\n    \"\"\"\n    n = int(stdin)\n    adj_list = [[] for _ in range(n+1)]\n    result = 'impossible'\n    for line in stdin.splitlines():\n        if line:\n            num, *rest = list(map(int, line.split()))\n            adj_list[num].extend(rest)\n    for i in range(1, n+1):\n        cur_available = sum(map(lambda x: x < n, adj_list[i]))\n        if cur_available >= n:\n            result = i\n            break\n    return result\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    bolts, companies = stdin.strip().split()\n    bolts = int(bolts)\n    companies = int(companies)\n    if not companies:\n        return \"impossible\"\n    else:\n        res = \"impossible\"\n        for i in range(1, companies+1):\n            n1, n2, n3, n4, n5 = [int(i) for i in stdin.strip().split()[i-1].split()]\n            if n1+n2+n3+n4+n5 >= bolts:\n                if n1 == n2 == n3 == n4 == n5:\n                    res = min(res, (n1+n2+n3+n4+n5))\n                else:\n                    tmp1 = (n1+n2+n3+n4+n5) - bolts\n                    tmp2 = max(n1, n2, n3, n4, n5)\n                    if tmp1 < tmp2:\n                        res = min(res, tmp1)\n                    else:\n                        res = min(res, tmp2)\n        return res\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # print(stdin)\n    _, N, *C = stdin.split()\n    N = int(N)\n    assert N >= 1\n    C = list(map(int, C))\n    assert len(C) == 1\n    C = C[0]\n    assert C >= 0\n    if N == 1:\n        if C == 1:\n            return \"impossible\"\n        else:\n            return str(C)\n    res = 0\n    for i, c in enumerate(C):\n        if c == 1:\n            res = i\n            break\n    if res == 0:\n        return \"impossible\"\n    C = C[:res]\n    if res == len(C):\n        return str(C[0])\n    r = 0\n    for i, c in enumerate(C):\n        r = max(r, c + C[i+1])\n    return str(r)\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, k = map(int, stdin.strip().split())\n    f, *c = map(int, input().split())\n    return str(min(f))"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n <= 10:\n        return 'impossible'\n\n    f = list(map(lambda x: list(map(int, x.split(' '))), stdin.split('\\n')))\n    m = 0\n    minpack = None\n    for l in f:\n        # print(l)\n        s = sum(l)\n        if m < s:\n            m = s\n            minpack = l\n    return m\n\nprint(solution(input()))"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    bolts = int(stdin)\n    num_comps = int(stdin)\n    instructions = []\n    for i in range(num_comps):\n        instructions.append(list(map(int, stdin.split())))\n    pack_sizes = {}\n    for comp in instructions:\n        pack_sizes[comp[1]] = 1 + pack_sizes.get(comp[2], 0)\n    comps = {}\n    for comp in instructions:\n        comps[comp[0]] = 1 + comps.get(comp[0], 0)\n    def minimum(available):\n        min_sums = []\n        if available in comps:\n            return available\n        for pack_size in comps:\n            if available + pack_size >= bolts:\n                min_sums.append((pack_size, comps[pack_size]))\n        min_sums.sort()\n        if not min_sums:\n            return None\n        return min_sums[0][1]\n    return str(minimum(bolts))"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    bools = list(map(int, stdin.strip().split()))\n    bools.sort()\n    #print(bools)\n    p = len(bools)\n    if p <= 1:\n        return \"impossible\"\n    if n == 0:\n        return p\n    if k == 0:\n        return n\n    if k == p:\n        return n\n    if p == k:\n        return max(bools)\n    dp = []\n    ans = -1\n    for i in range(p):\n        dp.append(bools[i])\n        for j in range(p):\n            if bools[j] <= dp[i] + bools[i]:\n                dp[i] = bools[j]\n                ans = max(ans, dp[i])\n    return str(ans)\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    a = list(map(int, stdin.strip().split()))\n    a.sort()\n    b = a[0]\n    return str(b)\n"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    pass\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    squares = stdin.splitlines()\n    squares = [square for square in squares if len(square) == 6]\n    squares_with_dots = []\n    squares_without_dots = []\n\n    for square in squares:\n        if any(square.count(letter) > 1 for letter in \".....\"):\n            squares_with_dots.append(square)\n        else:\n            squares_without_dots.append(square)\n\n    if len(squares_with_dots)!= 1:\n        return \"cannot fold\"\n    else:\n        return \"can fold\"\n\nprint(solution(input()))"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    ans = \"cannot fold\"\n    n = stdin.count(\"#\")\n    if n == 6:\n        ans = \"can fold\"\n    return ans\n\nprint(solution(input()))\n"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n = 6\n    input_string = stdin.strip()\n    if '.' not in input_string:\n        return \"cannot fold\"\n    input_string = input_string.replace('.', '#')\n    if n*n!= len(input_string):\n        return \"cannot fold\"\n    connectivity_graph = [[0]*n for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if input_string[n*i+j] == '#':\n                if i == 0:\n                    connectivity_graph[i][j] = 1\n                elif j == 0:\n                    connectivity_graph[i][j] = 1\n                elif i == n-1:\n                    connectivity_graph[i][j] = 1\n                elif j == n-1:\n                    connectivity_graph[i][j] = 1\n                else:\n                    connectivity_graph[i][j] = 1\n    for i in range(n):\n        for j in range(n):\n            if connectivity_graph[i][j] == 1:\n                if i == 0:\n                    connectivity_graph[i][j] = 1\n                    connectivity_graph[i][j+1] = 1\n                elif i == n-1:\n                    connectivity_graph[i][j] = 1\n                    connectivity_graph[i-1][j] = 1\n                elif j == 0:\n                    connectivity_graph[i][j] = 1\n                    connectivity_graph[i+1][j] = 1\n                elif j == n-1:\n                    connectivity_graph[i][j] = 1\n                    connectivity_graph[i-1][j] = 1\n                else:\n                    connectivity_graph[i][j] = 1\n                    connectivity_graph[i][j+1] = 1\n                    connectivity_graph[i][j-1] = 1\n                    connectivity_graph[i+1][j] = 1\n                    connectivity_graph[i-1][j] = 1\n    \n    # For each pair of coordinates in the graph, check if they are connected, if they are, return \"can fold\"\n    # Otherwise, return \"cannot fold\"\n    for i in range(n):\n        for j in range(n):\n            if connectivity_graph[i][j] == 1:\n                if is_connected(connectivity_graph, i, j):\n                    return \"cannot fold\"\n    return \"can fold\"\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \n    result = ''\n    cube = []\n    layer = []\n    \n    for i in stdin:\n        layer.append(i)\n        if i == '\\n':\n            cube.append(layer)\n            layer = []\n    \n    def check_cross(layer,result):\n        for i in range(6):\n            if layer[i] == '#':\n                for j in range(6):\n                    if layer[j] == '.' and (i-j) >= 0 and (i-j) <= 5:\n                        if layer[i-j] == '.':\n                            result += 'cannot fold'\n                            return result\n        result += 'can fold'\n        return result\n    \n    \n    for i in range(0,6):\n        result += check_cross(cube[i],result)\n    \n    return result\n\nresult = solution(stdin)\nprint(result)\n"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    squares = []\n    for l in stdin.split('\\n'):\n        squares.append(l)\n\n    squares = [list(x) for x in squares]\n\n    for i in range(6):\n        for j in range(6):\n            if squares[i][j] == '.':\n                squares[i][j] = '#'\n                break\n    \n    print(squares)\n\n    for i in range(6):\n        for j in range(6):\n            if squares[i][j] == '#':\n                squares[i][j] = '.'\n                break\n    \n    for i in range(6):\n        for j in range(6):\n            if squares[i][j] == '#':\n                squares[i][j] = '#'\n                break\n    \n    for i in range(6):\n        for j in range(6):\n            if squares[i][j] == '#':\n                squares[i][j] = '.'\n                break\n    \n    print(squares)\n\n    if '#' in squares[0] and '#' in squares[1] and '#' in squares[2] and '#' in squares[3] and '#' in squares[4] and '#' in squares[5]:\n        print('can fold')\n    else:\n        print('cannot fold')\n\nsolution(\".#.\\n#..#\\n###\")\nsolution(\".##.\")\nsolution(\"##.\")\nsolution(\"##..\")\nsolution(\"###\")\nsolution(\"#..#\")\nsolution(\"#....\")\nsolution(\"##....\")\nsolution(\"###....\")\nsolution(\"##......\")\nsolution(\"##...##\")\n"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pattern_list = [['.#.', '.#.', '.#.'],\n                    ['..#', '#..', '###'],\n                    ['##', '#.', '#.'],\n                    ['#.', '#.', '#.'],\n                    ['##', '###', '##']]\n    pattern_map = {'.#.': 0, '..#': 1, '##': 2, '#.': 3, '###': 4}\n    pattern_char_list = list(stdin)\n    #print(pattern_list)\n    #print(pattern_map)\n    #print(pattern_char_list)\n    pattern_idx = -1\n    pattern_idx = len(pattern_char_list) - 1\n    pattern_idx = len(pattern_char_list) - 2\n    #print(pattern_idx)\n    pattern_map = {'#': 0, '.': 1, '#': 2}\n    pattern_map = {'.': 0, '#': 1, '#': 2}\n    #print(pattern_map)\n    for i in range(pattern_idx + 1, len(pattern_char_list)):\n        #print(i, pattern_char_list[i])\n        if pattern_char_list[i]!= '#':\n            pattern_idx = i\n            break\n    #print(pattern_idx)\n    #print(pattern_char_list[pattern_idx])\n    #print(pattern_map.get(pattern_char_list[pattern_idx]))\n    return \"cannot fold\" if pattern_idx < 0 else \"can fold\"\n\nprint(solution('##..#'))\nprint(solution('..##.'))\nprint(solution('##.'))\nprint(solution('#...'))\nprint(solution('..#.'))\nprint(solution('#.#.'))\nprint(solution('##...'))\nprint(solution('#..#'))\nprint(solution('..#.'))\nprint(solution('###.'))\nprint(solution('#.#.'))\nprint(solution('#.##'))\nprint(solution('#.#.'))\nprint(solution('#...'))\nprint(solution('#..#'))\nprint(solution('##.'))\nprint(solution('#...'))\nprint(solution('#...'))\nprint(solution('#....'))\nprint(solution('#...'))\nprint(solution('##...'))\nprint(solution('#.#.'))\nprint(solution('#..#'))\nprint(solution('##.'))\nprint(solution('#.#.'))\nprint(solution('#...'))\nprint(solution('#...'))\nprint(solution('###.'))\nprint(solution('#.#.'))\nprint(solution('#..#'))\nprint(solution('###.'))\nprint(solution('#...'))\nprint(solution('#...'))\nprint(solution('#...'))\nprint(solution('##...'))\nprint(solution('#...'))\nprint(solution('###.'))\nprint(solution('#.#.'))\nprint(solution('#..#'))\nprint(solution('##.'))\nprint(solution('#...'))\nprint(solution('#...'))\nprint(solution('#....'))\nprint(solution('##...'))\nprint(solution('#.#.'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('#.##'))\nprint(solution('"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split()\n    squares_set = set()\n    for i in range(6):\n        square_pattern = stdin_list[i]\n        square_pattern = square_pattern.strip('#')\n        for j in range(6):\n            square_pattern_list = list(square_pattern)\n            square_pattern_list.pop(j)\n            square_pattern_list = ''.join(square_pattern_list)\n            squares_set.add(square_pattern_list)\n    unit_cube = '.' * 6\n    for square in squares_set:\n        if unit_cube!= square:\n            if unit_cube.startswith(square) and unit_cube[len(square):] == square:\n                return 'can fold'\n            else:\n                return 'cannot fold'\n    return 'cannot fold'\nprint(solution(input()))\n\"\"\"\n\nimport string\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    squares = set(stdin.split(\"\\n\"))\n    to_fold = squares - {\".#.\"}\n    return \"cannot fold\" if len(to_fold) > 6 else \"can fold\"\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('abcefgabc')\n    'abc'\n    >>> solution('abcbabcba')\n    'abcba'\n    >>> solution('aaaa')\n    'aaa'\n    '''\n    substrings = stdin.split()\n    shortest_substring = substrings[0]\n    longest_substring = substrings[0]\n    for sub in substrings:\n        if len(sub) < len(shortest_substring):\n            shortest_substring = sub\n        if len(sub) > len(longest_substring):\n            longest_substring = sub\n    return longest_substring\n    "
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    res = \"\"\n    for i in range(len(stdin)):\n        d = {}\n        for j in range(i, len(stdin)):\n            if stdin[j] in d:\n                d[stdin[j]] += 1\n            else:\n                d[stdin[j]] = 1\n            if len(d) > 2:\n                break\n        if len(d) > 2:\n            continue\n        else:\n            res = stdin[i:j + 1]\n            break\n    return res\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    longest_substring = ''\n    count = 0\n    for i in range(len(stdin)):\n        substring = stdin[i]\n        if stdin[i] in longest_substring:\n            count += 1\n        else:\n            longest_substring = longest_substring + substring\n            count = 1\n        if count > 1:\n            print(longest_substring)\n            return longest_substring\n        else:\n            count = 0\n    print(longest_substring)\n    return longest_substring\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin\n    output = None\n    if len(inp) == 1:\n        if inp == 'aaaa':\n            output = 'aaa'\n        else:\n            output = 'aaaa'\n    else:\n        output = ''\n        cnt = 1\n        cnt_max = 1\n        dic = {cnt: inp[0]}\n        dic2 = {cnt: inp[0]}\n        for i in range(1, len(inp)):\n            if inp[i] in dic:\n                dic2[inp[i]] = inp[i]\n                if inp[i]!= inp[i - 1]:\n                    cnt_max = cnt\n                    cnt = 1\n                    dic2 = {cnt: inp[i]}\n            else:\n                dic = dic2.copy()\n                cnt = 1\n                dic2 = {cnt: inp[i]}\n            cnt += 1\n        if output == '':\n            output = max(dic.keys(), default='', key=lambda k: dic[k])\n        else:\n            output = max(dic.keys(), key=lambda k: dic[k])\n    return output\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    #stdin = 'aaaa'\n    #stdin = 'abcbabcba'\n    #stdin = 'abcefgabc'\n    max_occur = 0\n    max_occur_string = ''\n    for _ in range(len(stdin)):\n        #string = ''.join(stdin)\n        #list = list(string)\n        string = stdin\n        occur_count = 0\n        occur_string = ''\n        for char in stdin:\n            if char not in occur_string:\n                occur_string += char\n                occur_count += 1\n            else:\n                occur_string += char\n                occur_count += 1\n            if occur_count > max_occur:\n                max_occur = occur_count\n                max_occur_string = occur_string\n    return max_occur_string\n\ndef"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) < 2:\n        return \"\"\n\n    seen = set()\n    current_count = 0\n\n    for i in range(len(stdin)):\n        if stdin[i] in seen:\n            current_count = max(current_count, i - seen.pop())\n        seen.add(i)\n\n    return stdin[:current_count]\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    pass\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    arr = []\n    count = 0\n    for i in stdin:\n        if i in arr:\n            count += 1\n        else:\n            count = 1\n        arr.append(i)\n        if count > 1:\n            return arr[0]\n    return arr[0]"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    counter = {}\n    current = \"\"\n    for i in stdin:\n        if i in counter:\n            counter[i] += 1\n        else:\n            counter[i] = 1\n    for key, val in counter.items():\n        if val > 1:\n            current = key\n            break\n    return current"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('')\n    ''\n    >>> solution('aaabbbcc')\n    'aaabbbcc'\n    >>> solution('aaabbbccddd')\n    'ddddd'\n    >>> solution('ab')\n    ''\n    '''\n    alphabet = []\n    substring = ''\n\n    for letter in stdin:\n        if letter not in alphabet:\n            alphabet.append(letter)\n            if len(substring) < len(alphabet):\n                substring = letter\n\n        else:\n            substring = letter\n\n    return substring\n"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    One ticket is valid for any trip which both starts and ends in zones in the interval $[A, B]$.\n\n    Johan needs to pay 2 + |A - B|.\n\n    Johan has to make at most $N$ trips.\n\n    Let T1, T2, T3, T4, T5,..., T10 be the times for each trip.\n\n    To make a valid ticket, he needs to pay at least:\n\n        (T1 - T0) + (T2 - T1) + (T3 - T2) + (T4 - T3) +... + (T10 - T4) >= 2 + |A - B|.\n\n    Then, he can buy the first trip, or the next trip, or the next trip and the third trip, etc.\n\n    So the goal is to find the least number of trips to use which makes all trips valid.\n\n    '''\n    n = int(stdin.strip())\n    s = [[]]\n    for _ in range(n):\n        s += [[]]\n    s += [[]]\n    res = n+1\n    for i in range(n-1):\n        s[i+2] = list(map(int, stdin.strip().split()))\n    for i in range(1,n+1):\n        for j in range(i,n+1):\n            for k in range(i,j):\n                if k == 0:\n                    continue\n                if s[i][0] > s[j][0] + s[i][1] >= s[k][0] + s[j][1] and s[k][1] - s[i][1] + s[j][1] <= s[k][0] + s[j][1] - s[i][1]:\n                    res = min(res, k)\n    return str(res)\n"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    C = 0\n    for _ in range(N):\n        A, B = map(int, stdin.split())\n        if A == 0:\n            if B > C:\n                C = B\n            elif A < C:\n                C = A\n        else:\n            if A > C:\n                C = A\n            elif A < C:\n                C = A\n    return str(C)"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    t1 = stdin.split()[1:]\n    t2 = stdin.split()[2:]\n    t1 = [int(x) for x in t1]\n    t2 = [int(x) for x in t2]\n    t1.sort()\n    t2.sort()\n    t = 0\n    i = 0\n    j = 0\n    while t1[i]!= t2[j]:\n        t += 2\n        i += 1\n        j += 1\n        if i == len(t1):\n            i = 0\n        if j == len(t2):\n            j = 0\n    return t\n\nsolution(\"2\")"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.splitlines()\n    N = int(stdin_list[0])\n    start_z = int(stdin_list[1])\n    end_z = int(stdin_list[2])\n    valid_z = []\n    cur_z = start_z\n    while cur_z <= end_z:\n        valid_z.append(cur_z)\n        cur_z += 1\n    coupons_purchased = 0\n    valid_z.sort()\n    for i in range(1, N + 1):\n        t, z = stdin_list[i].split()\n        t = int(t)\n        z = int(z)\n        if z in valid_z:\n            coupons_purchased += 2\n            valid_z.remove(z)\n            if len(valid_z) == 0:\n                break\n            else:\n                cur_z = valid_z[0]\n    return str(coupons_purchased)\n"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a, b = map(int, stdin.split())\n    return str(2 + abs(a - b))\n"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = [line.rstrip() for line in stdin.splitlines()]\n    N, Z, T = int(lines[0]), int(lines[1]), int(lines[2])\n    return str(min([2 + abs(Z - x) for x in range(Z + 1)]) + abs(T - 10000))"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    d = defaultdict(lambda: 0)\n    q = deque()\n    if n == 1:\n        return 2\n    if n == 2:\n        return 1\n    for _ in range(n - 1):\n        q.append((int(stdin.strip()), 0))\n    for _ in range(n - 1):\n        cur = q.popleft()\n        for i in range(cur[0]):\n            d[i] = max(d[i], cur[1] + 1)\n        for i in range(cur[0] + 1, 10):\n            d[i] = max(d[i], cur[1] + 1)\n        for i in range(10):\n            if (i, 0) in q:\n                d[i] = max(d[i], d[i] + 1)\n            if (i, cur[0] - 1) in q:\n                d[i] = max(d[i], d[i] + 1)\n            if (i, cur[0] + 1) in q:\n                d[i] = max(d[i], d[i] + 1)\n            if (cur[0] - 1, i) in q:\n                d[i] = max(d[i], d[i] + 1)\n            if (cur[0] + 1, i) in q:\n                d[i] = max(d[i], d[i] + 1)\n        q.append((cur[0] + 1, cur[1]))\n        q.append((cur[0] - 1, cur[1]))\n        q.append((cur[0] + 1, cur[1] + 1))\n        q.append((cur[0] - 1, cur[1] + 1))\n    return str(d[0])\n\"\"\"\n"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    return str(coupon_counter(N))\n\ndef"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    trips = []\n    count = 0\n    for _ in range(int(stdin.strip())):\n        a, b = map(int, stdin.strip().split())\n        trips.append((a, b))\n    trips.sort()\n    trips.append((trips[-1][1], trips[-1][0]))\n    for a, b in trips:\n        if a <= 10000:\n            count += 1\n        else:\n            break\n    return str(count)"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # bottom up approach\n    # dp[i] = dp[i-1] + dp[i-2]\n    dp = [1, 1]\n    for i in range(2, n + 1):\n        dp.append(dp[i-1] + dp[i-2])\n    print(dp[n])"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    values: List[int] = list(map(int, stdin.split()))\n    values.sort()\n    return lcm(values)\ndef"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = list(map(int, stdin.strip().split()))\n    count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if (arr[i] + arr[j]) % 3 == 0:\n                count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_lcm_and_least_common_multiple(n1, n2):\n        \"\"\"Given two integers n1 and n2, return their least common multiple and lcm.\"\"\"\n        # This function is modulo is so that I don't overflow.\n        lcm = (n1 * n2) // gcd(n1, n2)\n        return lcm, lcm // n1 * n2\n\n    n = int(stdin.strip())\n    nodes = sorted(map(int, stdin.strip().split()))\n    lcm, lcm_div = get_lcm_and_least_common_multiple(nodes[-1], nodes[-2])\n    # Count nodes in increasing order of value\n    counts = Counter(nodes)\n    count_nodes = [counts[i] for i in range(1, n + 1)]\n    # Get the number of possible ways to arrange the nodes so that the last node has lcm div\n    count = 0\n    for i in range(len(count_nodes)):\n        lcm_count = lcm_div // count_nodes[i]\n        count += lcm_count * (count_nodes[i] - 1)\n        if i < len(count_nodes) - 1:\n            # If the current number is larger than the previous, increment count\n            if count_nodes[i] > count_nodes[i + 1]:\n                count += 1\n    return str(count % 1000000007)"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nodes = list(map(int, stdin.split()))\n    if n == 0:\n        return \"0\"\n    if n == 1:\n        return \"1\"\n    nodes.sort()\n    if nodes[-1] == 0:\n        return \"0\"\n    if nodes[-1] == 1:\n        return \"1\"\n    if nodes[0] == 1:\n        return \"1\"\n    \n    lcms = [1, 1]\n    for i in range(1, n):\n        lcms.append(lcms[i - 1] * nodes[i - 1])\n    lcms.reverse()\n    \n    a = 1\n    b = 1\n    \n    for i in range(1, n):\n        a = lcms[i - 1] * a\n        b = lcms[n - i] * b\n    \n    return str(a % 1000000007)\n"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    nodes = stdin.split()\n    n = int(nodes[0])\n    values = list(map(int, nodes[1:]))\n    \n    def dfs(values, idx, target, answer):\n        if idx == n:\n            answer += 1\n            return answer\n\n        x, y = values[idx], values[idx+1]\n        if x % target == 0:\n            answer = dfs(values, idx + 2, target, answer)\n        elif y % target == 0:\n            answer = dfs(values, idx + 2, target, answer)\n        else:\n            answer = dfs(values, idx + 2, target, answer) + dfs(values, idx + 2, target, answer)\n            \n        return answer\n\n    answer = dfs(values, 1, 2, 0)\n    return str(answer)\n"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nodes = list(map(int, stdin.split()))\n    nodes.sort()\n\n    def lcm_helper(a: int, b: int) -> int:\n        if a == b:\n            return a\n        elif a > b:\n            return lcm_helper(a - b, b) + a\n        else:\n            return lcm_helper(a, b - a) + a\n\n    def lcm(a: int, b: int) -> int:\n        return lcm_helper(a, b)\n\n    def tree(nodes: list) -> int:\n        if len(nodes) == 2:\n            return 1 if lcm(nodes[0], nodes[1]) == 0 else 0\n        else:\n            count = 0\n            for i in range(len(nodes)):\n                for j in range(i + 1, len(nodes)):\n                    if lcm(nodes[i], nodes[j]) == 0:\n                        count += tree(nodes[:i] + nodes[i + 1:j] + nodes[j + 1:])\n            return count % 1000000007\n\n    return str(tree(nodes))\n\nstdin = \"\"\"10\n10 1 1 2 2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 1 2 2 2 2 1 2 1 2 2 2 1 2 2 2 2 2 2 2 2 2 2 2 2 1 2 2 2 2 2 2 1 2 2 2 2 1 2 2 2 2 2 2 2 1 2 2 2 2 2 1 2 2 2 2 2 1 2 2 2 2 2 2 1 2 2 2 2 2 1 2 1 2 2 2 2 1 2 1 2 2 2 1 2 1 2 2 2 2 2 1 2 1 1 2 2 2 1 1 2 2 1 2 1 2 2 2 2 1 1 2 2 2 2 1 2 2 1 2 1 1 2 1 2 2 2 1 2 1 2 2 2 2 1 2 1 1 2 1 2 1 2 2 2 1 2 2 1 2 1 1 1 2 1 2 2 2 2 2 1 2 1 1 2 2 2 1 2 1 2 2 2 1 2 1 2 1 2 1 2 2 1 2 1 1 1 2 1 2 1 2 1 2 1 2 2 1 1 1 2 2 1 1 2 1 1 1 2 2 1 2 1 2 1 2 1 1 2 2 1 2 1 1 1 2 2 1 2 1 2 1 2 1 1 2 1 1 1 1 2 1 2 1 1 1 1 1 1 1 1 2 1 1 2 1 1 2 1 2 1 1 1 1 2 2 1 1 1 2 1 1 1 1 2 1 1 1 1 1 1 1 2 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    For each pair of nodes, find the LCM.\n    For each node, find LCM of the node's children.\n    Repeat for all pairs.\n    \"\"\"\n    return \"\""
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return '0'\n    def gen(n):\n        if n % 2 == 0:\n            return gen(n // 2)\n        else:\n            return gen(n - 1) + gen(n // 2)\n    return gen(n)\n\nsolution(input())\n"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nums = sorted([int(i) for i in stdin.split()])\n    lcms = nums[0]\n    for i in range(1, len(nums)):\n        lcms = lcm(lcms, nums[i])\n    return lcms\n\ndef"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    board = stdin.split()\n    rows, cols, j, min_days, miss = 1, m - 1, 0, 0, 0\n    stamina = k\n    # for row in range(rows):\n    #     board = stdin.split()\n    #     for col in range(cols):\n    #         if board[col] == 'S':\n    #             j = col\n    #             break\n    #     if j:\n    #         break\n    # else:\n    #     return -1\n    for row in range(rows):\n        for col in range(cols):\n            if board[col] == 'S':\n                j = col\n                break\n        if j:\n            break\n    else:\n        return -1\n    while stamina < k:\n        for i in range(n):\n            if row == rows - 1 and col == m - 1 and board[row][col] == 'G':\n                if j == 0 and (i == 0 or board[i - 1][j] == '#') and (i == m - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif j == m - 1 and (i == 0 or board[i - 1][j] == '#') and (i == n - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif j == 0 and (i == m - 1 or board[i + 1][j] == '#') and (i == n - 1 or board[i - 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif j == m - 1 and (i == 0 or board[i + 1][j] == '#') and (i == n - 1 or board[i - 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                else:\n                    stamina += 1\n                    break\n            if board[i][col] == 'F':\n                stamina += 1\n                col += 1\n                continue\n            elif board[i][col] == 'M':\n                stamina += 2\n                col += 2\n                continue\n            elif board[i][col] == '.':\n                stamina += 1\n                col += 1\n                continue\n            else:\n                stamina += 3\n                col += 2\n                continue\n        if stamina < k:\n            for i in range(n):\n                if row == 0 and j == 0 and (i == 0 or board[i][j] == '#') and (i == m - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif row == m - 1 and j == 0 and (i == 0 or board[i][j] == '#') and (i == n - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif row == 0 and j == m - 1 and (i == m - 1 or board[i][j] == '#') and (i == n - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif row == m - 1 and j == m - 1 and (i == m - 1 or board[i][j] == '#') and (i == n - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                else:\n                    stamina += 1\n                    break\n        if stamina < k:\n            for i in range(n):\n                if row == 0 and j == 0 and (i == 0 or board[i][j] == '#') and (i == n - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif row == 0 and j == m - 1 and (i == 0 or board[i][j] == '#') and (i == n - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif row == m - 1 and j == 0 and (i == m - 1 or board[i][j] == '#') and (i == n - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif row == m - 1 and j == m - 1 and (i == m - 1 or board[i][j] == '#') and (i == n - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                else:\n                    stamina += 1\n                    break\n        if stamina < k:\n            for i in range(n):\n                if row == 0 and j == m - 1 and (i == 0 or board[i][j] == '#') and (i == n - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif row == m - 1 and j == m - 1 and (i == 0 or board[i][j] == '#') and (i == n - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif row == 0 and j == 0 and (i == m - 1 or board[i][j] == '#') and (i == n - 1 or board[i + 1][j] == '#'):\n                    min_days += 1\n                    stamina += 1\n                    break\n                elif row == m - 1 and j == 0 and (i == m - 1 or board[i][j] == '#') and (i == n - 1 or board[i + 1"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 3 2 3\n   ... S.F.\n   ....MFMG\n   ... ''')\n    '3'\n    >>> solution('''\n   ... 3 2 3\n   ....GF\n   ....S.\n   ... ''')\n    '4'\n    >>> solution('''\n   ... 3 2 3\n   ....GF\n   ....S.\n   ... ''')\n    '5'\n    \"\"\"\n    n, m, k = map(int, stdin.strip().split())\n    mapp = []\n    for i in range(n):\n        row = stdin.strip().split()[i]\n        mapp.append(row)\n    seen = {\n        (1, 0): '0',\n        (1, -1): '1',\n        (1, 1): '2',\n        (0, -1): '3',\n        (-1, 0): '4',\n        (-1, 1): '5',\n        (-1, -1): '6',\n        (-1, 1): '7',\n        (-2, 0): '8',\n        (-2, -1): '9',\n        (-2, 1): '10',\n        (-3, 0): '11',\n        (-3, 1): '12',\n        (-3, -1): '13',\n        (-3, -2): '14',\n        (-4, 0): '15',\n        (-4, 1): '16',\n        (-4, -1): '17',\n        (-4, -2): '18',\n        (-5, 0): '19',\n        (-5, 1): '20',\n        (-5, -1): '21',\n        (-5, -2): '22',\n        (-6, 0): '23',\n        (-6, 1): '24',\n        (-6, -1): '25',\n        (-6, -2): '26',\n        (-7, 0): '27',\n        (-7, 1): '28',\n        (-7, -1): '29',\n        (-7, -2): '30',\n        (-8, 0): '31',\n        (-8, 1): '32',\n        (-8, -1): '33',\n        (-8, -2): '34',\n        (-9, 0): '35',\n        (-9, 1): '36',\n        (-9, -1): '37',\n        (-9, -2): '38',\n        (-10, 0): '39',\n        (-10, 1): '40',\n        (-10, -1): '41',\n        (-10, -2): '42',\n        (-11, 0): '43',\n        (-11, 1): '44',\n        (-11, -1): '45',\n        (-11, -2): '46',\n    }\n    mapp.append('#')\n    mapp.append('G')\n    mapp.append('S')\n    mapp.append('.')\n    all_cells = list(map(set, mapp))\n    all_cells.remove('#')\n    all_cells.remove('.')\n    all_cells.remove('G')\n    all_cells.remove('S')\n    all_cells.remove('S')\n    all_cells = list(map(set, all_cells))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells = list(map(set, all_cells))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells = list(map(set, all_cells))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells = list(map(set, all_cells))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells = list(map(set, all_cells))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells = list(map(set, all_cells))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells = list(map(set, all_cells))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells = list(map(set, all_cells))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all_cells.remove(set('.'))\n    all"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = list(map(int, stdin.split()))\n    grid = stdin.splitlines()\n    treasure = \"G\"\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == treasure:\n                sx, sy = i, j\n                break\n    \n    # iterative\n    # if the grid is not a path from S to G\n    if sx == -1 or sy == -1:\n        return -1\n    \n    def bfs(sx, sy, nx, ny):\n        dx = [-1, 0, 1, 0]\n        dy = [0, 1, 0, -1]\n        visited = [[0] * M for _ in range(N)]\n        queue = deque([(sx, sy)])\n        while queue:\n            x, y = queue.popleft()\n            if not visited[x][y]:\n                visited[x][y] = 1\n                if grid[x][y] == treasure:\n                    return nx, ny\n                for i in range(4):\n                    nx = x + dx[i]\n                    ny = y + dy[i]\n                    if 0 <= nx < N and 0 <= ny < M and grid[nx][ny]!= \"#\" and not visited[nx][ny]:\n                        queue.append((nx, ny))\n    \n    # Dijkstra\n    # we can implement Dijkstra algorithm by using the BFS.\n    # there are four directions (up, down, left, right).\n    # when moving to these four directions, we have to check the surrounding cells.\n    # if a cell is not walkable, we should not go there.\n    # if the cell we want to move to is walkable, we can move forward.\n    # if the cell we want to move to is not walkable, we can either move to the cell ahead, or stay at the current cell.\n    # if the cell we want to move to is walkable, we need to calculate the total distance.\n    # in the Dijkstra algorithm, we need to calculate the total distance between the point and the origin, and then calculate the total distance from the point to the destination.\n    # for example, consider the point at S, S = (0, 0).\n    # we need to calculate the total distance from S to G, which is the same as the distance between the origin and the destination.\n    # then we need to calculate the total distance from G to S, which is 1 + 1 = 2.\n    # so the total distance from G to S is 2.\n    # then we need to calculate the total distance from the point at G to the destination, which is 2 - 1 = 1.\n    # so the total distance from G to S is 1.\n    # then we can calculate the total distance from S to the destination, which is 1 - 1 = 0.\n    # we need to calculate the total distance from the point at G to the origin, which is 0.\n    # so the total distance from G to S is 0.\n    # so we need to calculate the total distance from G to the origin, which is 0 + 1 = 1.\n    # so the total distance from G to S is 1.\n    # so we can calculate the total distance from the point at G to the destination, which is 1 - 1 = 0.\n    # so the total distance from G to S is 0.\n    \n    if sx == -1 or sy == -1:\n        return -1\n    \n    # the first row is the first direction\n    \n    nx, ny = bfs(sx, sy, sx, sy)\n    nx1, ny1 = bfs(sx, sy, sx, ny)\n    nx2, ny2 = bfs(sx, ny, nx, ny)\n    nx3, ny3 = bfs(nx, ny, sx, ny)\n    \n    dists = [nx1, ny1, nx2, ny2, nx3, ny3]\n    total_dist = 0\n    \n    for i in range(len(dists)):\n        total_dist += dists[i]\n    \n    return total_dist\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def rus_to_int(rus_num: str) -> int:\n        if rus_num == 'F':\n            return 0\n        elif rus_num == 'M':\n            return 1\n        elif rus_num == 'S':\n            return 2\n        else:\n            return 3\n\n    def movement(x: int, y: int) -> int:\n        if x == 0:\n            if y == 0 or y == 3:\n                return 0\n            elif y == 1 or y == 2:\n                return 1\n            elif y == 4:\n                return 2\n        if x == 1:\n            if y == 0 or y == 3:\n                return 2\n            elif y == 1 or y == 2:\n                return 1\n            elif y == 4:\n                return 0\n        if x == 2:\n            if y == 0 or y == 3:\n                return 2\n            elif y == 1 or y == 2:\n                return 1\n            elif y == 4:\n                return 0\n        if x == 3:\n            if y == 0 or y == 3:\n                return 1\n            elif y == 1 or y == 2:\n                return 2\n            elif y == 4:\n                return 0\n\n    days = 0\n    map = stdin.split('\\n')\n    point = map[0].find('S')\n    if point == -1:\n        return '-1'\n    stam_p = point\n    stam_i = 0\n    for i in map:\n        if i == '\\n':\n            continue\n        else:\n            stam_i += 1\n            stam_p += 1\n            for j in i:\n                if j == '.':\n                    stam_p += 1\n                elif j == '#':\n                    stam_p += 0\n                else:\n                    stam_p += 2\n            if i == 'S' and stam_p == stam_i:\n                days += 1\n                stam_i = 0\n                stam_p = 0\n    return str(days)\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n, m, k = int(stdin[0]), int(stdin[1]), int(stdin[2])\n    grid = stdin[3]\n    counter = 0\n    if n == 1:\n        if grid[0] == 'S':\n            return counter\n    else:\n        if grid[0] == 'S':\n            counter += 1\n        if grid[1] == 'S':\n            counter += 1\n        if grid[2] == 'S':\n            counter += 1\n    if grid[3] == 'S':\n        counter += 1\n    if n == 2:\n        if grid[4] == 'S':\n            counter += 1\n        if grid[5] == 'S':\n            counter += 1\n        if grid[6] == 'S':\n            counter += 1\n    if grid[7] == 'S':\n        counter += 1\n    if grid[8] == 'S':\n        counter += 1\n    if grid[9] == 'S':\n        counter += 1\n    if n == 3:\n        if grid[0] == 'S':\n            counter += 1\n        if grid[1] == 'S':\n            counter += 1\n        if grid[2] == 'S':\n            counter += 1\n        if grid[3] == 'S':\n            counter += 1\n        if grid[4] == 'S':\n            counter += 1\n        if grid[5] == 'S':\n            counter += 1\n        if grid[6] == 'S':\n            counter += 1\n    if n == 4:\n        if grid[0] == 'S':\n            counter += 1\n        if grid[1] == 'S':\n            counter += 1\n        if grid[2] == 'S':\n            counter += 1\n        if grid[3] == 'S':\n            counter += 1\n        if grid[4] == 'S':\n            counter += 1\n        if grid[5] == 'S':\n            counter += 1\n        if grid[6] == 'S':\n            counter += 1\n        if grid[7] == 'S':\n            counter += 1\n        if grid[8] == 'S':\n            counter += 1\n        if grid[9] == 'S':\n            counter += 1\n        if grid[10] == 'S':\n            counter += 1\n        if grid[11] == 'S':\n            counter += 1\n        if grid[12] == 'S':\n            counter += 1\n        if grid[13] == 'S':\n            counter += 1\n        if grid[14] == 'S':\n            counter += 1\n        if grid[15] == 'S':\n            counter += 1\n        if grid[16] == 'S':\n            counter += 1\n    if grid == 'M' * n:\n        return counter\n    if grid == 'F' * n:\n        return -1\n    if grid == 'M' * (n - 1):\n        return -1\n    if grid == 'M' * (n - 2):\n        return -1\n    if grid == 'F' * (n - 2):\n        return -1\n    if grid == 'F' * (n - 3):\n        return -1\n    if grid == 'F' * (n - 4):\n        return -1\n    if grid == 'F' * (n - 5):\n        return -1\n    if grid == 'M' * (n - 6):\n        return -1\n    if grid == 'F' * (n - 6):\n        return -1\n    if grid == 'M' * (n - 7):\n        return -1\n    if grid == 'F' * (n - 7):\n        return -1\n    if grid == 'F' * (n - 8):\n        return -1\n    if grid == 'F' * (n - 9):\n        return -1\n    if grid == 'M' * (n - 10):\n        return -1\n    if grid == 'F' * (n - 10):\n        return -1\n    if grid == 'M' * (n - 11):\n        return -1\n    if grid == 'F' * (n - 11):\n        return -1\n    if grid == 'F' * (n - 12):\n        return -1\n    if grid == 'F' * (n - 13):\n        return -1\n    if grid == 'F' * (n - 14):\n        return -1\n    if grid == 'F' * (n - 15):\n        return -1\n    if grid == 'F' * (n - 16):\n        return -1\n    if grid == 'M' * (n - 17):\n        return -1\n    if grid == 'F' * (n - 17):\n        return -1\n    if grid == 'F' * (n - 18):\n        return -1\n    if grid == 'F' * (n - 19):\n        return -1\n    if grid == 'F' * (n - 20):\n        return -1\n    if grid == 'F' * (n - 21):\n        return -1\n    if grid == 'F' * (n - 22):\n        return -1\n    if grid == 'F' * (n - 23):\n        return -1\n    if grid == 'F' * (n - 24):\n        return -1\n    if grid == 'F' * (n - 25):\n        return -1\n    if grid == 'F' * (n - 26):\n        return -1\n    if grid == 'F' * (n - 27):\n        return -1\n    if grid == 'F' * (n - 28):\n        return -1\n    if grid == 'F' * (n - 29):\n        return -1\n    if grid == 'F' * (n - 30):\n        return -1\n    if grid == 'F' * (n - 31):\n        return -1\n    if grid == 'F' * (n - 32):\n        return -1\n    if grid == 'F' * (n - 33):\n        return -1\n    if grid == 'F' * (n - 34):\n        return -1\n    if grid == 'F' * (n - 35):\n        return -1"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    days = 0\n    stdin = stdin.split('\\n')\n    n, m, k = map(int, stdin[0].split())\n    map = stdin[1:]\n    s = set()\n    s.add('S')\n    s.add('G')\n    while True:\n        if len(s) == 1:\n            return days\n        temp = []\n        for i in range(n):\n            for j in range(m):\n                if map[i][j] == 'G':\n                    temp.append([i, j])\n        if len(temp) == 0:\n            return -1\n        temp = sorted(temp, key=lambda x: (x[0], x[1]))\n        x, y = temp[0]\n        if map[x][y] == 'M':\n            map[x][y] = '.'\n            if x + 1 < n and map[x+1][y] == '#':\n                map[x+1][y] = '.'\n            if x - 1 >= 0 and map[x-1][y] == '#':\n                map[x-1][y] = '.'\n            if y + 1 < m and map[x][y+1] == '#':\n                map[x][y+1] = '.'\n            if y - 1 >= 0 and map[x][y-1] == '#':\n                map[x][y-1] = '.'\n            map[x][y] = 'M'\n        elif map[x][y] == 'F':\n            map[x][y] = '.'\n            if x + 1 < n and map[x+1][y] == '#':\n                map[x+1][y] = '.'\n            if x - 1 >= 0 and map[x-1][y] == '#':\n                map[x-1][y] = '.'\n            if y + 1 < m and map[x][y+1] == '#':\n                map[x][y+1] = '.'\n            if y - 1 >= 0 and map[x][y-1] == '#':\n                map[x][y-1] = '.'\n            map[x][y] = 'F'\n        elif map[x][y] == '#':\n            map[x][y] = '.'\n            if x + 1 < n and map[x+1][y] == '#':\n                map[x+1][y] = '.'\n            if x - 1 >= 0 and map[x-1][y] == '#':\n                map[x-1][y] = '.'\n            if y + 1 < m and map[x][y+1] == '#':\n                map[x][y+1] = '.'\n            if y - 1 >= 0 and map[x][y-1] == '#':\n                map[x][y-1] = '.'\n            map[x][y] = '#'\n        if (x, y) not in s:\n            s.add((x, y))\n        else:\n            s.remove((x, y))\n        days += 1\nprint(solution(input()))\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    inp_map = stdin.splitlines()\n    N = int(inp_map[0])\n    M = int(inp_map[1])\n    K = int(inp_map[2])\n    s_cell = 'S'\n    g_cell = 'G'\n    s_loc = []\n    g_loc = []\n    days = 0\n    if N == 1:\n        return str(K)\n    elif K == 1:\n        return str(days)\n    elif N == 2:\n        for i in range(M):\n            if inp_map[0][i] == g_cell:\n                g_loc.append(i)\n            elif inp_map[0][i] == s_cell:\n                s_loc.append(i)\n        if len(s_loc) > 1 and len(g_loc) > 1:\n            return str(2)\n        elif len(s_loc) == 1 and len(g_loc) == 1:\n            return str(1)\n        else:\n            return str(-1)\n    else:\n        for i in range(M):\n            if inp_map[0][i] == g_cell:\n                g_loc.append(i)\n            elif inp_map[0][i] == s_cell:\n                s_loc.append(i)\n        if len(g_loc) == 1:\n            return str(1)\n        elif len(g_loc) == 0:\n            return str(-1)\n        elif len(g_loc) > 1 and len(s_loc) > 1:\n            return str(2)\n        elif len(s_loc) == 1 and len(g_loc) == 1:\n            return str(1)\n        else:\n            return str(-1)\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(stdin.strip())\n    map = []\n    for i in range(len(stdin)):\n        if stdin[i] == '.':\n            map.append([])\n        elif stdin[i] == 'F':\n            map.append(['F'])\n        elif stdin[i] == 'M':\n            map.append(['M'])\n        elif stdin[i] == '#':\n            map.append(['#'])\n        elif stdin[i] == 'S':\n            map.append(['S'])\n        elif stdin[i] == 'G':\n            map.append(['G'])\n    n_rows = len(map)\n    n_cols = len(map[0])\n    if not is_valid(map, n_rows, n_cols):\n        return '-1'\n    tentative_stamina = init_stamina(n_rows, n_cols, stdin, 0, 0)\n    min_days = 0\n    while not is_end(map):\n        start_row, start_col = find_start(map)\n        map, tentative_stamina = move_to_end(map, tentative_stamina, start_row, start_col)\n        if not is_valid(map, n_rows, n_cols):\n            return '-1'\n        days = num_days(map)\n        min_days = min(min_days, days)\n    return min_days\n\n\ndef"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = (int(x) for x in stdin.split())\n    N = n\n    M = m\n    K = k\n    cell = stdin\n    if cell[0] == 'S' and cell[1] == 'G':\n        return f'{(N - 1) * (M - 1)}'\n    elif cell[0] == 'S' and cell[1]!= 'G':\n        return f'{N * M}'\n    elif cell[0]!= 'S' and cell[1] == 'G':\n        return f'{N * M}'\n    else:\n        return f'{(N - 1) * (M - 1)}'\n\n\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = list(map(int, stdin.split(\" \")))\n    grid = stdin.splitlines()\n    output = 0\n    for row in range(H):\n        for col in range(W):\n            if grid[row][col] == \"#\":\n                continue\n            try:\n                if row > 0 and grid[row - 1][col] == \"#\":\n                    continue\n                if row < H - 1 and grid[row + 1][col] == \"#\":\n                    continue\n                if col > 0 and grid[row][col - 1] == \"#\":\n                    continue\n                if col < W - 1 and grid[row][col + 1] == \"#\":\n                    continue\n                output += 1\n            except IndexError:\n                continue\n    return str(output)\n"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    grid = stdin.splitlines()\n    start_position = find_start_position(grid)\n    goal_position = find_goal_position(grid)\n    if check_for_obstacle(grid, start_position, goal_position):\n        return \"You cannot reach the goal without using more than two commands.\"\n    # creating a copy of the list\n    # so that we can use it to iterate through the original list\n    # after each change of the list, we can also see the final result\n    grid_copy = copy.deepcopy(grid)\n    path_exists = bfs(grid_copy, start_position, goal_position)\n    if path_exists:\n        return \"You can reach the goal without using more than two commands.\"\n    return str(get_min_changes(grid, start_position, goal_position))\n\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    command_string: str = stdin\n    h: int = int(command_string.split()[0])\n    w: int = int(command_string.split()[1])\n    start_x: int = h\n    start_y: int = w\n    goal_x: int = 0\n    goal_y: int = 0\n    grid: List[List[str]] = []\n    command_string_list: List[str] = command_string.split()\n    for i in range(h):\n        grid.append([])\n        for j in range(w):\n            grid[i].append(command_string_list[i * w + j])\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == \"S\":\n                start_x = i\n                start_y = j\n            if grid[i][j] == \"G\":\n                goal_x = i\n                goal_y = j\n    return manhattan(start_x, start_y, goal_x, goal_y)\n\n\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Examples\n    >>> solution('''3 3\n   ....S..\n   ....#G#\n   ....#.#\n   ....#..\n   ....G.#\n   ....#..\n   ....#.#\n   ....S..\n   ....G.#\n   ....#.#\n   ....#.G.''')\n    '1'\n    \"\"\"\n    # Determine height and width of grid\n    H, W = map(int, stdin.split())\n    # Create 2D array with zeroes\n    grid = [[0 for x in range(W)] for y in range(H)]\n    # Populate 2D array with user input\n    for i in range(H):\n        row = stdin.split()[i]\n        for j in range(W):\n            grid[i][j] = row[j]\n    # Create new array with all the directions\n    directions = ['R', 'U', 'L', 'D']\n    # Create dictionary for the number of times each direction appears\n    dict = {'R': 0, 'U': 0, 'L': 0, 'D': 0}\n    # Loop through each direction and count times it appears\n    for direction in directions:\n        # Loop through each row of the array\n        for row in range(H):\n            # Loop through each column of the row\n            for col in range(W):\n                # If the row value of the current direction is the same as the column value of the current row, increment the count of the direction\n                if row == col:\n                    dict[direction] += 1\n    # Loop through each direction and print the count of each direction\n    for direction in directions:\n        print(dict[direction])\n    # Return minimum number of changes needed\n    return(min(dict.values()))\n"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    print(stdin)\n    return 0\n"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    pass"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    min_changes = int(1e9)\n    commands = stdin\n    x = 0\n    y = 0\n    x_move = {'R': 1, 'L': -1, 'D': 0, 'U': 0}\n    y_move = {'R': 0, 'L': 0, 'D': -1, 'U': 1}\n    while x < len(commands) and y < len(commands[x]):\n        command = commands[x][y]\n        if command == '.':\n            x += x_move['R']\n            y += y_move['R']\n            continue\n        if command == 'S':\n            x_move['R'] = 1\n            x_move['L'] = -1\n            y_move['R'] = 0\n            y_move['L'] = 0\n            y = 0\n            continue\n        if command == 'G':\n            break\n        x += x_move['R']\n        y += y_move['R']\n        min_changes = min(min_changes, abs(x) + abs(y))\n    return min_changes\n"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.strip().split())\n    grid = [x for x in stdin.strip().split()]\n    R = []\n    for i in range(H):\n        if grid[i] == 'R':\n            R.append((i, 0))\n    U = [(0, -1)]\n    D = [(0, 1)]\n    L = [(0, -1)]\n    RDD = [(1, -1)]\n    ans = 0\n    while True:\n        if len(U) == 0:\n            return -1\n        if len(RDD) == 0:\n            return -1\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if len(RDD) == 0:\n            return -1\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if len(RDD) == 0:\n            return -1\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            RDD.pop(0)\n        if RDD[0][0] == RDD[0][1]:\n            "
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Take the command input.\n    command_list = stdin.split()\n\n    # Create the grid.\n    grid = create_grid(command_list)\n\n    # Run the program and get the status.\n    status = run_program(command_list, grid)\n\n    # Return the number of changes needed.\n    return len(get_changes(grid))"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split(\"\\n\")\n    beacon_pos = []\n    beacon_dist = {}\n    for _ in range(len(stdin)):\n        beacon_pos.append(tuple(map(int, stdin.pop().split())))\n        beacon_dist[tuple(map(int, stdin.pop().split()))] = True\n    \n    for i in range(len(beacon_pos)):\n        for j in range(i + 1, len(beacon_pos)):\n            if (beacon_pos[i][0] - beacon_pos[j][0]) ** 2 + (beacon_pos[i][1] - beacon_pos[j][1]) ** 2 <= 16:\n                beacon_dist[beacon_pos[i]] = True\n                beacon_dist[beacon_pos[j]] = True\n    \n    if len(beacon_dist) == 1:\n        return '{},{}'.format(*beacon_dist.keys())\n    elif len(beacon_dist) > 1:\n        return \"uncertain\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin\n    n = int(data.splitlines()[0])\n    beacons = []\n    for i in range(n):\n        beacons.append(list(map(int, data.splitlines()[1 + i].split())))\n    receiver = (data.splitlines()[-1].split())[0]\n    data = data.splitlines()[2:-1]\n    print(data)\n    return 'Yes' if (receiver, *find_beacon_positions(data, beacons)) else 'No'\n\ndef"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pairs = {f\"{int(i)} {int(j)}\" for i, j, d in stdin.splitlines()}\n    n = len(pairs)\n    x, y = (1, 1)\n\n    def step(n, x, y):\n        while len(pairs)!= n - 1:\n            m = min((abs(x - p[0]), abs(y - p[1])) for p in pairs)\n            if m[0] >= m[1]:\n                x += 1\n            else:\n                y += 1\n        return (x, y)\n\n    if n == 1:\n        x, y = step(n, x, y)\n    else:\n        x, y = step(n, x, y)\n        for i in range(n):\n            pairs.remove(f\"{int(i)} {int(j)}\" for i, j, d in pairs if abs(x - int(i)) + abs(y - int(j)) == int(d))\n        x, y = step(n, x, y)\n    return str(x) + \" \" + str(y)\n\nsolution(\"\"\"\n0 100 0\n1 200 200\n2 500 0\n3 1000 0\n4 1000 5\n5 100 5\n6 100 6\n7 100 7\n8 100 8\n9 100 9\n10 500 9\n11 500 10\n12 500 11\n13 500 12\n14 500 13\n15 500 14\n16 500 15\n17 500 16\n18 500 17\n19 500 18\n20 500 19\n21 500 20\n22 500 21\n23 500 22\n24 500 23\n25 500 24\n26 500 25\n27 500 26\n28 500 27\n29 500 28\n30 500 29\n31 500 30\n32 500 31\n33 500 32\n34 500 33\n35 500 34\n36 500 35\n37 500 36\n38 500 37\n39 500 38\n40 500 39\n41 500 40\n42 500 41\n43 500 42\n44 500 43\n45 500 44\n46 500 45\n47 500 46\n48 500 47\n49 500 48\n50 500 49\n51 500 50\n52 500 51\n53 500 52\n54 500 53\n55 500 54\n56 500 55\n57 500 56\n58 500 57\n59 500 58\n60 500 59\n61 500 60\n62 500 61\n63 500 62\n64 500 63\n65 500 64\n66 500 65\n67 500 66\n68 500 67\n69 500 68\n70 500 69\n71 500 70\n72 500 71\n73 500 72\n74 500 73\n75 500 74\n76 500 75\n77 500 76\n78 500 77\n79 500 78\n80 500 79\n81 500 80\n82 500 81\n83 500 82\n84 500 83\n85 500 84\n86 500 85\n87 500 86\n88 500 87\n89 500 88\n90 500 89\n91 500 90\n92 500 91\n93 500 92\n94 500 93\n95 500 94\n96 500 95\n97 500 96\n98 500 97\n99 500 98\n100 500 99\n101 500 100\n102 500 101\n103 500 102\n104 500 103\n105 500 104\n106 500 105\n107 500 106\n108 500 107\n109 500 108\n110 500 109\n111 500 110\n112 500 111\n113 500 112\n114 500 113\n115 500 114\n116 500 115\n117 500 116\n118 500 117\n119 500 118\n120 500 119\n121 500 120\n122 500 121\n123 500 122\n124 500 123\n125 500 124\n126 500 125\n127 500 126\n128 500 127\n129 500 128\n130 500 129\n131 500 130\n132 500 131\n133 500 132\n134 500 133\n135 500 134\n136 500 135\n137 500 136\n138 500 137\n139 500 138\n140 500 139\n141 500 140\n142 500 141\n143 500 142\n144 500 143\n145 500 144\n146 500 145\n147 500 146\n148 500 147\n149 500 148\n150 500 149\n151 500 150\n152 500 151\n153 500 152\n154 500 153\n155 500 154\n156 500 155\n157 500 156\n158 500 157\n159 500 158\n160 500 159\n161 500 160\n162 500 161\n163 500 162\n164 500 163\n165 500 164\n166 500 165\n167 500 166\n168 500 167\n169 500 168\n170 500 169\n171 500 170\n172 500 171\n173 500 172\n174 500 173\n175 500 174\n176 500 175\n177 500 176\n178 500 177\n179 500 178\n180 500 179\n181 500 180\n182 500 181\n183 500 182\n184 500 183\n185 500 184\n186 500 185\n187 500 186\n188 500 187\n189 500 188\n190 500 189\n191 500 190\n192 500 191\n193 500 192\n194 500 193\n195 500 194\n196 500 195\n197 500 196\n198 500 197\n199 500 198\n200 500 199\n201 500 200\n202 500 201\n203 500 202\n204 500 203\n205 500 204\n206 500 205\n207 500 206\n208 500 207\n209 500 208\n210 500 209\n211 500 210\n212 500 211\n213 500 212\n214 500 213\n215 500 214\n216 500 215\n217 500 216\n218 500 217\n219 500 218\n220 500 219\n221 500 220\n222 500 221\n223 500 222\n224 500 223\n225 500 224\n226 500 225\n227 500 226\n228 500 227\n229 500 228\n230 500 229\n231 500 230\n232 500 231\n233 500 232\n234 500 233\n235 500 234\n236 500 235\n237 500 236\n238 500 237\n239 500 238\n240 500 239\n241 500 240\n242 500 241\n243 500 242\n244 500 243\n245 500 244\n246 500 245\n247 500 246\n248 500 247\n249 500 248\n250 500 249\n251 500 250\n252 500 251\n253 500 252\n254 500 253\n255 500 254\n256 500 255\n257 500 256\n258 500 257\n259 500 258\n260 500 259\n261 500 260\n262 500 261\n263 500 262\n264 500 263\n265 500 264\n266 500 265\n267 500 266\n268 500 267\n269 500 268\n270 500 269\n271 500 270\n272 500 271\n273 500 272\n274 500 273\n275 500 274\n276 500 275\n277 500 276\n278 500 277\n279 500 278\n280 500 279\n281 500 280\n282 500 281\n283 500 282\n284 500 283\n285 500 284\n286 500 285\n287 500 286\n288 500 287\n289 500 288\n290 500 289\n291 500 290\n292 500 291\n293 500 292\n294 500 293\n295 500 294\n296 500 295\n297 500 296\n298 500 297\n299 500"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    c = []\n    for line in stdin.strip().split('\\n'):\n        if len(line.split()) == 3:\n            c.append([int(i) for i in line.split()])\n    return c\n"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num_beacons = int(stdin)\n    beacons = []\n    for i in range(num_beacons):\n        bx, by, bd = map(int, stdin.split())\n        beacons.append((bx, by, bd))\n\n    # x = int(input())\n    # y = int(input())\n    # d = int(input())\n    # bx, by, bd = beacons[x-1], beacons[y-1], d\n    # return f'{bx} {by}'\n\n    res = 'impossible'\n    for i in range(num_beacons):\n        for j in range(i + 1, num_beacons):\n            dx, dy = abs(beacons[i][0] - beacons[j][0]), abs(beacons[i][1] - beacons[j][1])\n            if dx + dy == beacons[i][2] + beacons[j][2]:\n                res = '{} {}'.format(beacons[i][0], beacons[i][1])\n    return res\n\nprint(solution(input()))\n"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    beacon = []\n    for i in range(n):\n        beacon.append((int(stdin.split()[i*3+1]), int(stdin.split()[i*3+2])))\n    beacon = sorted(beacon, key=lambda x: x[0] ** 2 + x[1] ** 2)\n    for i in range(len(beacon)):\n        for j in range(i + 1, len(beacon)):\n            if (beacon[i][0] - beacon[j][0]) ** 2 + (beacon[i][1] - beacon[j][1]) ** 2 == 1000000:\n                return '{} {}'.format(beacon[i][0], beacon[i][1])\n    return 'impossible'\n"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pos = {i for i in range(1,1001)}\n    d = {(i, j): abs(i - j) for i, j in zip(*[iter(stdin.split())] * 2)}\n    return ''.join([''.join((str(p), c)) if d[p, q] == 1 else ''.join(('impossible', c)) for p, c in pos.items() if c not in pos])\n"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    for line in stdin.split('\\n'):\n        if not line:\n            break\n        x, y, d = map(int, line.split())\n        if x == 0 and y == 0:\n            return '{:d} {:d}'.format(x, y)\n        if x == 0 and 0 <= y < d:\n            return 'impossible'\n        if x == d and 0 <= y < d:\n            return 'impossible'\n        if 0 <= x < d and 0 <= y < d:\n            return '{:d} {:d}'.format(x, y)\n    return '{:d} {:d}'.format(x, y)\n"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    N = int(input_lines[0])\n    beacons = []\n    for i in range(1, N+1):\n        beacons.append(tuple(map(int, input_lines[i].split())))\n    return \"impossible\" if MPS(beacons) == -1 else str(MPS(beacons)[0]) + \" \" + str(MPS(beacons)[1])\n\ndef"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    positions = {}\n    for i, _ in enumerate(stdin.splitlines()):\n        x, y, d = map(int, _.split())\n        positions[(x, y)] = d\n\n    # x, y = (0, 0)\n    # while True:\n    #     for d in range(1, 5):\n    #         if (x, y) == (0, 0):\n    #             if positions[(x + d, y)] == positions[(x, y + d)]:\n    #                 return '{} {}'.format(x + d, y + d)\n    #             if positions[(x, y + d)] == positions[(x - d, y)]:\n    #                 return '{} {}'.format(x - d, y + d)\n    #         else:\n    #             if positions[(x + d, y)] == positions[(x - d, y)]:\n    #                 return '{} {}'.format(x + d, y)\n    #             if positions[(x, y - d)] == positions[(x, y + d)]:\n    #                 return '{} {}'.format(x, y - d)\n\n    for i, _ in enumerate(stdin.splitlines()):\n        x, y = (0, 0)\n        while True:\n            for d in range(1, 5):\n                if (x, y) == (0, 0):\n                    if positions[(x + d, y)] == positions[(x, y + d)]:\n                        return '{} {}'.format(x + d, y + d)\n                    if positions[(x, y + d)] == positions[(x - d, y)]:\n                        return '{} {}'.format(x - d, y + d)\n                else:\n                    if positions[(x + d, y)] == positions[(x - d, y)]:\n                        return '{} {}'.format(x + d, y)\n                    if positions[(x, y - d)] == positions[(x, y + d)]:\n                        return '{} {}'.format(x, y - d)\n            x += 1\n            y += 1\n"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    corners = []\n    for i in range(n):\n        corners.append(list(map(int, stdin.split())))\n\n    def cross(r1, c1, r2, c2):\n        if r1 == r2 or c1 == c2 or r1 == c2 or c1 == r2:\n            return True\n        return False\n\n    def is_valid_rect(r1, c1, r2, c2):\n        if r1 == r2 or c1 == c2 or r1 == c2 or c1 == r2:\n            return True\n        return False\n\n    count = 0\n    for i in range(n):\n        if cross(corners[i][0], corners[i][1], corners[i][2], corners[i][3]) or cross(corners[i][0], corners[i][1], corners[i][3], corners[i][2]) or cross(corners[i][0], corners[i][1], corners[i][2], corners[i][3]) or cross(corners[i][0], corners[i][1], corners[i][3], corners[i][2]):\n            continue\n        if is_valid_rect(corners[i][0], corners[i][1], corners[i][2], corners[i][3]) or is_valid_rect(corners[i][0], corners[i][1], corners[i][3], corners[i][2]) or is_valid_rect(corners[i][0], corners[i][1], corners[i][2], corners[i][3]) or is_valid_rect(corners[i][0], corners[i][1], corners[i][3], corners[i][2]):\n            continue\n        count += 1\n    return str(count)"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    blocks = list()\n    for r, c in map(int, stdin.split()):\n        if r <= 0 or r > len(blocks) or c <= 0 or c > len(blocks[0]):\n            return'syntax error'\n        elif len(blocks) == 0:\n            blocks.append([[r, c]])\n        else:\n            for i in range(len(blocks)):\n                if r == blocks[i][0][0] or r == blocks[i][0][1]:\n                    if c == blocks[i][0][0] or c == blocks[i][0][1]:\n                        blocks[i].append([r, c])\n                        break\n            if len(blocks[i]) == 0:\n                blocks.append([[r, c]])\n            else:\n                blocks[i].append([r, c])\n    result = list()\n    for i in range(len(blocks)):\n        temp_result = []\n        for j in range(len(blocks[i])):\n            temp_result.append(blocks[i][j][0])\n            temp_result.append(blocks[i][j][1])\n        result.append(temp_result)\n    return result"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def has_borders(row1, row2):\n        for (c1, c2) in ((r1, r2) for (r1, r2) in ((r1, c2) for (r1, c2) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1) for (r1, c1) in ((r1, c1"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip().split('\\n')\n    print(stdin)\n    matrix = []\n    for i in range(1,len(stdin)+1):\n        matrix.append(list(map(int,stdin[i-1].split())))\n    matrix.sort(key = lambda x: x[0])\n    matrix.sort(key = lambda x: x[1])\n    res = []\n    count = 0\n    start = 0\n    end = 0\n    for i in range(1,len(matrix)):\n        if (matrix[i-1][0]!= matrix[i][0] and matrix[i-1][1]!= matrix[i][1]):\n            count += 1\n            res.append(count)\n            count = 0\n        elif (matrix[i-1][0] == matrix[i][0] and matrix[i-1][1] == matrix[i][1]):\n            end = i\n    \n    if count > 0:\n        res.append(count)\n    for j in res:\n        print(start,end,j)\n    if end!= len(matrix)-1:\n        return'syntax error'\n    else:\n        return''.join(map(str,res))\n\nprint(solution(stdin))"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    corners = sorted([int(x) for x in stdin.split()])\n    match = 0\n    while match!= len(corners):\n        corners = sorted(corners)\n        while corners:\n            r, c = corners.pop(0), corners.pop(0)\n            if match and match!= r - 1:\n                return'syntax error'\n            if r - 1!= match:\n                match = r - 1\n                corners.append(r)\n                corners.append(c)\n            match = c - 1\n            corners.append(c)\n            corners.append(r)\n    return str(len(corners))\n"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    n = int(stdin.pop(0))\n    if n!= len(stdin):\n        raise ValueError('Invalid Input')\n    blocks = []\n    for i in range(n):\n        blocks.append(tuple(map(int, stdin.pop(0).split(' '))))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max(blocks[i][0], blocks[j][0]) + 1 == min(blocks[i][1], blocks[j][1]) or max(blocks[i][1], blocks[j][1]) + 1 == min(blocks[i][0], blocks[j][0]):\n                return'syntax error'\n    return '\\n'.join(map(lambda x: str(x[0] + 1) +'' + str(x[1] + 1), sorted(blocks)))\n"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    rects = {}\n    for i in range(n):\n        rects[i] = (int(stdin.readline()), int(stdin.readline()))\n    rects = sorted(rects.items(), key=lambda x: x[0])\n    if len(rects) == 0:\n        return'syntax error'\n    ans = []\n    for i in range(len(rects)):\n        top_left = rects[i][1]\n        bottom_right = rects[i + 1][1]\n        if top_left[0] <= bottom_right[0] and top_left[1] <= bottom_right[1]:\n            if bottom_right[1] - top_left[1] <= 1:\n                ans.append(top_left[0])\n            else:\n                ans.append(top_left[0])\n                ans.append(top_left[1] + 1)\n        else:\n            if top_left[0] <= bottom_right[0]:\n                ans.append(top_left[0])\n            else:\n                ans.append(top_left[0])\n                ans.append(top_left[1] + 1)\n    ans = str(len(ans))\n    for i in range(len(ans)):\n        ans = ans[:i + 1] +'' + ans[i + 1:]\n    return ans\n"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip('\\n')\n    n = int(stdin.split(' ')[0])\n    rectangles = []\n    corners = []\n    for i in range(1, n+1):\n        r, c = map(int, stdin.split('\\n')[i].split(' '))\n        corners.append((r, c))\n    for i in range(1, n+1):\n        r1, c1 = corners.pop()\n        r2, c2 = corners.pop()\n        rectangles.append((r1, c1, r2, c2))\n    return rectangles"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rectangles = []\n    for _ in range(n):\n        rectangles.append([int(x) for x in stdin.split()[1:]])\n    rectangles = sorted(rectangles, key=lambda x: (x[0], x[1]))\n\n    def matches(rectangle_1, rectangle_2):\n        for i in range(2):\n            if rectangle_1[i]!= rectangle_2[i]:\n                return False\n        return True\n\n    def match(rectangle_1, rectangle_2):\n        for i in range(2):\n            if rectangle_1[i] >= rectangle_2[0] and rectangle_1[i] <= rectangle_2[1]:\n                return False\n        return True\n\n    def merge_rectangle(rectangle_1, rectangle_2):\n        left, top = max(rectangle_1[0], rectangle_2[0]), max(rectangle_1[1], rectangle_2[1])\n        right, bottom = min(rectangle_1[0] + rectangle_1[2], rectangle_2[0] + rectangle_2[2]), min(rectangle_1[1] + rectangle_1[3], rectangle_2[1] + rectangle_2[3])\n        return (left, top, right - left, bottom - top)\n\n    def union(rectangle_1, rectangle_2):\n        left, top = min(rectangle_1[0], rectangle_2[0]), min(rectangle_1[1], rectangle_2[1])\n        right, bottom = max(rectangle_1[0] + rectangle_1[2], rectangle_2[0] + rectangle_2[2]), max(rectangle_1[1] + rectangle_1[3], rectangle_2[1] + rectangle_2[3])\n        return (left, top, right - left, bottom - top)\n\n    def solve():\n        result = []\n        index = 0\n        while index < len(rectangles):\n            current = rectangles[index]\n            if matches(current, result[-1]) or index + 1 == len(rectangles):\n                result.append(current)\n                index += 1\n                continue\n            matching = False\n            for i in range(1, len(result)):\n                if match(result[i - 1], current) and match(result[i], result[i - 1]):\n                    result[i] = merge_rectangle(result[i - 1], result[i])\n                    matching = True\n                    break\n            if matching:\n                index += 1\n                continue\n            result.append(current)\n            index += 1\n        return '\\n'.join([str(x) for x in result])\n\n    return '\\n'.join([str(solve()), str(solve())])\n"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m_rows = len(stdin.splitlines())\n    stdin = stdin.splitlines()\n    row_1 = stdin.pop()\n    row_2 = stdin.pop()\n    row_1 = row_1.split(\" \")\n    row_2 = row_2.split(\" \")\n    # print(row_1)\n    # print(row_2)\n    for num in range(len(row_1)):\n        if row_1[num]!= \"\":\n            row_1[num] = int(row_1[num])\n            row_2[num] = int(row_2[num])\n        else:\n            row_1[num] = None\n            row_2[num] = None\n    # print(row_1)\n    # print(row_2)\n    # print(len(row_1), len(row_2))\n    column_1 = len(row_1)\n    column_2 = len(row_2)\n    # print(column_1, column_2)\n    # print(row_1)\n    # print(row_2)\n    pizza = []\n    for row in range(m_rows):\n        pizza.append([])\n        for column in range(column_1):\n            if column_1 == column_2:\n                pizza[row].append(row_1[column])\n                pizza[row].append(row_2[column])\n            else:\n                pizza[row].append(row_1[column])\n    # print(pizza)\n    # print(row_1)\n    # print(row_2)\n    for row in range(m_rows):\n        if row_1[row] == row_2[row]:\n            pizza.pop(row)\n            pizza.pop(row)\n            row_1.pop(row)\n            row_2.pop(row)\n            # print(\"popped\")\n    # print(row_1)\n    # print(row_2)\n    # print(pizza)\n    saved = {}\n    # print(\"hey\")\n    # print(row_1)\n    # print(row_2)\n    # print(pizza)\n    for i in range(len(pizza)):\n        for j in range(len(pizza)):\n            if pizza[i][j]!= None:\n                # print(pizza[i][j])\n                saved[pizza[i][j]] = saved.get(pizza[i][j], 0) + 1\n    # print(saved)\n    # print(\"hey\")\n    # print(saved)\n    pizza = []\n    for row in range(m_rows):\n        pizza.append([])\n        for column in range(column_1):\n            if column_1 == column_2:\n                pizza[row].append(row_1[column])\n                pizza[row].append(row_2[column])\n            else:\n                pizza[row].append(row_1[column])\n    # print(pizza)\n    # print(row_1)\n    # print(row_2)\n    for row in range(m_rows):\n        if row_1[row] == row_2[row]:\n            pizza.pop(row)\n            pizza.pop(row)\n            row_1.pop(row)\n            row_2.pop(row)\n            # print(\"popped\")\n    # print(row_1)\n    # print(row_2)\n    # print(pizza)\n    # print(row_1)\n    # print(row_2)\n    for i in range(len(pizza)):\n        for j in range(len(pizza)):\n            if pizza[i][j]!= None:\n                saved[pizza[i][j]] = saved.get(pizza[i][j], 0) + 1\n    # print(saved)\n    # print(\"hey\")\n    # print(saved)\n    saved = {}\n    # print(\"hey\")\n    # print(saved)\n    for i in range(len(pizza)):\n        for j in range(len(pizza)):\n            if pizza[i][j]!= None:\n                saved[pizza[i][j]] = saved.get(pizza[i][j], 0) + 1\n    # print(saved)\n    # print(\"hey\")\n    # print(saved)\n    saved = {}\n    # print(\"hey\")\n    # print(saved)\n    for i in range(len(pizza)):\n        for j in range(len(pizza)):\n            if pizza[i][j]!= None:\n                saved[pizza[i][j]] = saved.get(pizza[i][j], 0) + 1\n    # print(saved)\n    # print(\"hey\")\n    # print(saved)\n    for i in range(len(pizza)):\n        for j in range(len(pizza)):\n            if pizza[i][j]!= None:\n                saved[pizza[i][j]] = saved.get(pizza[i][j], 0) + 1\n    # print(saved)\n    # print(\"hey\")\n    # print(saved)\n    for i in range(len(pizza)):\n        for j in range(len(pizza)):\n            if pizza[i][j]!= None:\n                saved[pizza["
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split('\\n')\n    for row in rows:\n        row = row.split()\n        row = list(map(int, row))\n\n        left = row[:4]\n        right = row[4:]\n        for i in range(4):\n            left[i] += row[i+4]\n            right[i] += row[i+4]\n\n        row = left + right\n        row =''.join(map(str, row))\n        print(row)\n    return rows\n"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass\nprint(solution(stdin))\n\"\"\"\n\ndef"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    d = {str(i) : str(i) for i in range(200)}\n    for i in stdin.split('\\n'):\n        d[str(int(i.split()[0]))] = str(int(i.split()[1]))\n    max_number = -9999999999999\n    max_d = {k: max_number for k in d}\n    max_d = {k: max_number for k in d}\n    for i in range(1, 200 + 1):\n        max_d[str(i)] = max_d[str(i - 1)] + str(int(d[str(i - 1)]))\n    for i in range(1, 200 + 1):\n        max_d[str(i)] = max_d[str(i - 1)] + str(int(d[str(i - 1)]))\n    for i in range(200):\n        max_d[str(i + 1)] = max_d[str(i)] + str(int(d[str(i)]))\n    max_d = {k: max_number for k in d}\n    return str(len(set(max_d.values())))\n"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin.split())\n    for i in range(n):\n        stdin = stdin.replace(stdin[i], str(i))\n    stdin = stdin.split()\n    plate_1 = stdin[:5]\n    plate_2 = stdin[5:]\n    h = len(plate_1)\n    n = 0\n    for i in range(h):\n        if plate_1[i]!= plate_2[i]:\n            n += 1\n    return str(n)\n"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    n = int(stdin[0])\n    for i in range(1, len(stdin)):\n        stdin[i] = stdin[i].split(\" \")\n    plates = [\n        [],\n        [],\n        [],\n        [],\n        [],\n    ]\n    for i in range(n):\n        plates[0] += stdin[i][:2]\n        plates[1] += stdin[i][2:4]\n        plates[2] += stdin[i][4:6]\n        plates[3] += stdin[i][6:8]\n        plates[4] += stdin[i][8:]\n    stack = [[x, y, z, w] for x in plates[0] for y in plates[1] for z in plates[2] for w in plates[3]]\n    count = 0\n    seen = set()\n    while len(stack) > 0:\n        cur = stack.pop(0)\n        if tuple(cur) in seen:\n            continue\n        seen.add(tuple(cur))\n        plate_sum = sum(cur)\n        if plate_sum >= 200:\n            count += 1\n            continue\n        if len(plates[0]) > 0 and plate_sum >= plates[0][0]:\n            plates[0].pop(0)\n        if len(plates[1]) > 0 and plate_sum >= plates[1][0]:\n            plates[1].pop(0)\n        if len(plates[2]) > 0 and plate_sum >= plates[2][0]:\n            plates[2].pop(0)\n        if len(plates[3]) > 0 and plate_sum >= plates[3][0]:\n            plates[3].pop(0)\n        if len(plates[4]) > 0 and plate_sum >= plates[4][0]:\n            plates[4].pop(0)\n        stack.append([x for x in cur if x <= 200])\n    return count\n"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num_of_monsters = 0\n    rows = []\n    for _ in range(2):\n        rows.append(stdin[f\"{_}:{_}:\"].split(' '))\n    print(rows)\n    for row in rows:\n        if row[0] == '_':\n            num_of_monsters += 1\n    print(num_of_monsters)\n    return\n\nsolution(input())\n\"\"\"\n\n\"\"\"\nSample Input 1:\n_ 90 22 _ 6 _ _ _ 81\n_ 40 _ _ _ 12 60 _ 90 _\nSample Output 1:\n1\n\nSample Input 2:\n85 55 _ 99 51 _ _ _ _ _\n_ _ _ _ _ _ _ 85 63 153\nSample Output 2:\n1\n\nSample Input 3:\n160 _ _ 136 _ _ _ _ _ 170\n_ _ _ _ 120 _ _ 144 _ _\nSample Output 3:\n8640\n\n\"\"\""
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    test = [[int(i) for i in stdin.split()] for _ in range(2)]\n    for i in range(2):\n        stdin_dict = {}\n        for j in range(len(test[i])):\n            if test[i][j] not in stdin_dict:\n                stdin_dict[test[i][j]] = j + 1\n            else:\n                stdin_dict[test[i][j]] += j + 1\n        print(stdin_dict)\n    a = []\n    for i in range(len(test[0])):\n        a.append((stdin_dict[test[0][i]], stdin_dict[test[1][i]]))\n    print(a)\n    return a\n"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    mat = {}\n    for row in stdin.split('\\n'):\n        for i, val in enumerate(row.split()):\n            if val:\n                mat[(i, int(val))] = 1\n    return len(set(tuple(sorted(v)) for k, v in mat.items()))\n\nprint(solution(input()))"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    junctions = [[] for _ in range(N)]\n    roads = []\n\n    for _ in range(N - 1):\n        start_junction, end_junction = map(int, stdin.split())\n        junctions[start_junction - 1].append(end_junction)\n        junctions[end_junction - 1].append(start_junction)\n        roads.append([start_junction - 1, end_junction - 1])\n\n    roads = sorted(roads, key=lambda x: x[1])\n\n    shortest_paths = [[float(\"inf\") for _ in range(N)] for _ in range(N)]\n    shortest_paths[roads[0][0]][roads[0][1]] = 2\n    shortest_paths[roads[0][1]][roads[0][0]] = 2\n\n    for i in range(1, len(roads)):\n        for j in range(N):\n            for k in range(N):\n                if roads[i][0] == j or roads[i][1] == j:\n                    if shortest_paths[j][k]!= float(\"inf\"):\n                        shortest_paths[j][k] = min(shortest_paths[j][k], shortest_paths[j][roads[i - 1][0]] + shortest_paths[roads[i - 1][0]][k])\n\n    return sum([shortest_paths[i][j] == 2 for i in range(N) for j in range(N)])"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    links = [[] for _ in range(N + 1)]\n    for line in stdin.split('\\n'):\n        u, v = map(int, line.split())\n        links[u].append(v)\n        links[v].append(u)\n    if len(set(links[1])) == 1:\n        return str(len(set(links[1])) - 1)\n    # if len(set(links[1])) > 1:\n    #     return str(len(set(links[1])) - 1)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 1)\n    # return str(len(set(links[1])) - 1)\n    # return str(len(set(links[1])) - 1)\n    # return str(len(set(links[1])) - 1)\n    # return str(len(set(links[1])) - 1)\n    # return str(len(set(links[1])) - 1)\n    # return str(len(set(links[1])) - 1)\n    # return str(len(set(links[1])) - 1)\n    # return str(len(set(links[1])) - 1)\n    return str(len(set(links[1])) - 1)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n    # return str(len(set(links[1])) - 2)\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.splitlines()\n    # turn the input into a 2D list\n    input = [[int(n) for n in l.split()] for l in input]\n    #  prepare the solution\n    pokens = 0\n    # iterate through the 2D list\n    for i in range(len(input) - 1):\n        #  for each entry\n        for j in range(len(input[i]) - 1):\n            # check if the path is optimal\n            if input[i][j] + 1 == input[i][j + 1]:\n                # if so, increment pokens\n                pokens += 1\n    return str(pokens)\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return 0"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    n = int(stdin.split()[0])\n    junctions = {}\n    roads = {}\n    for i in range(1, n+1):\n        j, k = stdin.split()\n        junctions[j] = k\n        roads[j, k] = i\n    count = 0\n    for road in roads:\n        if roads[road] > 0:\n            count += 1\n            break\n    for road in roads:\n        if roads[road] > 0:\n            u, v = road\n            paths = getPaths(u, v)\n            for p in paths:\n                for q in paths:\n                    if p == q:\n                        continue\n                    for road in roads:\n                        if roads[road] > 0:\n                            if p == road[0] and q == road[1]:\n                                roads[road] -= 1\n                                break\n                            if roads[road] == 0:\n                                break\n                    if roads[road] == 0:\n                        break\n                if roads[road] == 0:\n                    break\n            if roads[road] == 0:\n                break\n    print(count)\n\ndef"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    # N = 4\n    # u_2 = 1\n    # v_2 = 5\n    # u_3 = 2\n    # v_3 = 3\n    # u_4 = 2\n    # v_4 = 4\n    # u_5 = 5\n    # v_5 = 6\n    # u_6 = 7\n    # v_6 = 8\n    # u_7 = 7\n    # v_7 = 9\n    # u_8 = 8\n    # v_8 = 10\n    # u_9 = 9\n    # v_9 = 10\n    # u_10 = 10\n\n    # total_roads = 0\n\n    # # There are N-1 roads, each connecting two different junctions.\n    # # The paths for all the N-1 roads are represented by a set of N-1 paths.\n    # # The paths are represented by a list of N-1 integers.\n    # # The first integer in the list is the start of the path and the last is the end.\n    # # The start and end are represented by integers from 1 to N.\n    # # Each path is unique.\n    # # Each path is non-increasing.\n    # # Each path is non-decreasing.\n    # # Each path has the same length.\n\n    # # How many optimal paths are there of length $2$?\n    # # Here we are looking for the unique paths of length $2$ and then counting them.\n    # # If there are more than one path with the same length,\n    # # the unique paths are all counted.\n    # # To find the unique paths of length $2$,\n    # # we need to check all the paths.\n    # # But how do we check if there are different paths with same length?\n    # # We can look at the difference between each pair of adjacent integers in the path,\n    # # and if they are adjacent integers,\n    # # we have found a path of length $2$.\n    # # If the paths are not adjacent integers,\n    # # then we have found at least one path of length $2$.\n    # # We can determine all the paths of length $2$ in O(N * (N-1)) space.\n\n    # # To count the unique paths of length $2$,\n    # # we need to count the paths.\n    # # Since there are N-1 roads and the paths are unique,\n    # # we need to count them.\n    # # For each road we count only the number of paths\n    # # of length $2$.\n    # # To count the number of paths of length $2$,\n    # # we need to count the number of paths of length $1$.\n    # # For each path we count only the number of junctions.\n\n    # # So the total number of paths is\n    # # N * (N-1) * (N-2) * (N-3)\n    # # total_roads = N * (N-1) * (N-2) * (N-3)\n\n    # # for i in range(1, N):\n    # #     for j in range(i):\n    # #         total_roads += N\n    # #         print(i, j)\n\n    # # print(total_roads)\n    # # return str(total_roads)\n\n    # unique_paths_of_length_2 = 0\n\n    # paths_of_length_1 = 0\n\n    # for i in range(1, N):\n    #     for j in range(i):\n    #         paths_of_length_1 += 1\n    #         if abs(i - j) == 1:\n    #             unique_paths_of_length_2 += 1\n\n    # print(unique_paths_of_length_2)\n\n    # return str(unique_paths_of_length_2)\n    # return '1'\n    # print(stdin)\n    return '1'\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    junctions = {}\n    for i in range(N):\n        junctions[i + 1] = set()\n    for u, v in zip(map(int, stdin.split()), map(int, stdin.split())):\n        junctions[u].add(v)\n        junctions[v].add(u)\n    count = 0\n    for start in junctions:\n        for target in junctions:\n            if start == target:\n                continue\n            if start == 1 or target == 1:\n                continue\n            if start == 2 or target == 2:\n                continue\n            if target - start == 1:\n                continue\n            if len(junctions[start]) == 2 and len(junctions[target]) == 2 and target - start == 1:\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin.split()[0])\n    junctions = list(map(int, stdin.split()[1:]))\n    graph: Dict[int, List[int]] = {}\n    for i in range(0, N - 1):\n        a, b = junctions[i], junctions[i + 1]\n        if a in graph:\n            graph[a].append(b)\n        else:\n            graph[a] = [b]\n    for i in range(0, N - 1):\n        a, b = junctions[i], junctions[i + 1]\n        if b in graph:\n            graph[b].append(a)\n        else:\n            graph[b] = [a]\n\n    def dfs(s: int, t: int, visited: Dict[int, bool]) -> int:\n        if visited[s]:\n            return 0\n        if s == t:\n            return 1\n        visited[s] = True\n        res = 0\n        for i in graph[s]:\n            res += dfs(i, t, visited)\n        return res\n\n    answer: int = 0\n    for i in range(0, N):\n        if dfs(i, i + 1, {i: False}):\n            answer += 1\n    return answer\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    INPUT = stdin.split(\"\\n\")\n\n    N = int(INPUT[0])\n    JUNCTIONS = [[] for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        a, b = map(int, INPUT[i].split())\n        JUNCTIONS[a] += [(i, b)]\n        JUNCTIONS[b] += [(i, a)]\n\n    LENGTH = 2\n    COUNT = 0\n    VISITED = set()\n\n    q = deque()\n    q += [(1, 1)]\n    while q:\n        v, d = q.popleft()\n\n        if v == N and d == N:\n            COUNT += 1\n            continue\n\n        for v, d in JUNCTIONS[v]:\n            if (v, d) not in VISITED:\n                VISITED.add((v, d))\n                q += [(v, d)]\n\n    return str(COUNT)\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    roads = []\n    for i in range(N - 1):\n        u, v = map(int, stdin.split()[i * 2 + 1].split(' '))\n        roads.append((u, v))\n    roads = sorted(roads, key=lambda x: (x[1], x[0]))\n\n    def dfs(roads, u, v, depth):\n        if u == v:\n            return depth + 1\n        paths = []\n        for w in roads:\n            if u == w[0] or v == w[1]:\n                paths.append(dfs(roads, w[0], w[1], depth + 1))\n        if len(paths) == 0:\n            return -1\n        else:\n            return min(paths)\n\n    min_path = dfs(roads, roads[0][0], roads[0][1], 0)\n    return str(min_path)"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    plain = stdin\n    cipher = \"\"\n\n    while len(plain) > 1:\n        plain = plain.lower()\n        cipher += plain[0]\n        plain = plain[1:]\n    return cipher\n\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message = stdin\n    decrypted_fragment = stdin\n\n    counter = 0\n    encrypted_list = []\n    for letter in encrypted_message:\n        if letter in \"abcdefghijklmnopqrstuvwxyz\":\n            encrypted_list.append(letter)\n\n    for letter in decrypted_fragment:\n        if letter in \"abcdefghijklmnopqrstuvwxyz\":\n            counter += 1\n    return encrypted_list\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    _, encrypted = stdin.split('\\n', 1)\n    _, decrypted = stdin.split('\\n', 1)\n    return f'{encrypted.find(decrypted) if decrypted in encrypted else len(encrypted)}'\n"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    encrypted = stdin\n    decrypted = stdin.replace('a', 'k').replace('b', 'k').replace('c', 'k').replace('d', 'k').replace('e', 'k').replace('f', 'k').replace('g', 'k').replace('h', 'k').replace('i', 'k').replace('j', 'k').replace('k', 'a').replace('l', 'a').replace('m', 'a').replace('n', 'a').replace('o', 'a').replace('p', 'a').replace('q', 'a').replace('r', 'a').replace('s', 'a').replace('t', 'a').replace('u', 'a').replace('v', 'a').replace('w', 'a').replace('x', 'a').replace('y', 'a').replace('z', 'a')\n    if encrypted == decrypted:\n        return 'Unique'\n    else:\n        return str(encrypted.count('a'))"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot\n   ... boot\n   ...\n   ... boot"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin\n    text = text.split(\"\\n\")\n    text = text[1]\n    text = text.replace(\" \", \"\")\n    text = text.lower()\n    text = list(text)\n    dic = {}\n    \n    for x in range(0, len(text)):\n        if text[x] not in dic:\n            dic[text[x]] = 1\n        else:\n            dic[text[x]] += 1\n    \n    for x in dic:\n        if dic[x] == 1:\n            key = x\n            break\n    \n    #print(dic)\n    \n    #print(key)\n    \n    #print(dic[key])\n    \n    text = text.replace(key, \"\")\n    text = text.replace(\" \", \"\")\n    text = text.replace(\"-\", \"\")\n    \n    text = text.replace(text, \"\")\n    \n    \n    #print(text)\n    \n    dic = {}\n    \n    for x in range(0, len(text)):\n        if text[x] not in dic:\n            dic[text[x]] = 1\n        else:\n            dic[text[x]] += 1\n    \n    #print(dic)\n    \n    #print(dic[key])\n    \n    for x in dic:\n        if dic[x] == 1:\n            #print(key)\n            #print(dic[key])\n            print(x)\n            break\n    \n    #print(\"\")\n    \n    return dic\n\n\nstdin = \"\"\nfor i in range(0, 15):\n    stdin += input()\n\nprint(solution(stdin))\n\"\"\"\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    encrypted = stdin\n    dictionary = {}\n    dictionary[\"a\"] = \"k\"\n    dictionary[\"b\"] = \"l\"\n    dictionary[\"c\"] = \"m\"\n    dictionary[\"d\"] = \"n\"\n    dictionary[\"e\"] = \"o\"\n    dictionary[\"f\"] = \"p\"\n    dictionary[\"g\"] = \"q\"\n    dictionary[\"h\"] = \"r\"\n    dictionary[\"i\"] = \"s\"\n    dictionary[\"j\"] = \"t\"\n    dictionary[\"k\"] = \"u\"\n    dictionary[\"l\"] = \"v\"\n    dictionary[\"m\"] = \"w\"\n    dictionary[\"n\"] = \"x\"\n    dictionary[\"o\"] = \"y\"\n    dictionary[\"p\"] = \"z\"\n    dictionary[\"q\"] = \"a\"\n    dictionary[\"r\"] = \"b\"\n    dictionary[\"s\"] = \"c\"\n    dictionary[\"t\"] = \"d\"\n    dictionary[\"u\"] = \"e\"\n    dictionary[\"v\"] = \"f\"\n    dictionary[\"w\"] = \"g\"\n    dictionary[\"x\"] = \"h\"\n    dictionary[\"y\"] = \"i\"\n    dictionary[\"z\"] = \"j\"\n    encrypted = encrypted.lower()\n    letter_count = 1\n    while letter_count < len(encrypted) - 1:\n        for x in range(len(encrypted)):\n            encrypted = encrypted[0:x] + dictionary[encrypted[x]] + encrypted[x + 1:]\n            letter_count += 2\n    if encrypted.find(dictionary[stdin]) >= 0:\n        return stdin\n    return encrypted.find(dictionary[stdin])\n\nsolution(input())\n"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message = stdin.strip()\n    fragment = stdin.strip()\n    count = 0\n\n    # Create a mapping of character frequency.\n    chars_frequency = {}\n\n    # Loop through each letter in the message and count the frequency of occurrences.\n    for letter in encrypted_message:\n        if letter not in chars_frequency:\n            chars_frequency[letter] = 1\n        else:\n            chars_frequency[letter] += 1\n\n    # Loop through each letter in the message fragment and count the frequency of occurrences.\n    for letter in fragment:\n        if letter not in chars_frequency:\n            count = count + 1\n        else:\n            chars_frequency[letter] -= 1\n\n    # Return the number of positions in the encrypted message where the message fragment could occur.\n    return str(count)\n"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message = stdin\n    decrypted_fragment = stdin\n    matching_positions = 0\n    for i in range(len(encrypted_message)):\n        if encrypted_message[i] == decrypted_fragment:\n            matching_positions = matching_positions + 1\n            print(matching_positions)\n        else:\n            print(matching_positions)\n\n    if matching_positions == 0:\n        print(0)\n    else:\n        print(matching_positions)\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message = stdin.strip().replace(\" \", \"\").lower()\n    decrypted_fragment = stdin.strip().replace(\" \", \"\").lower()\n    decrypted_fragment = \"\".join(set(decrypted_fragment))\n    for index in range(len(encrypted_message)):\n        if encrypted_message[index] in decrypted_fragment:\n            if index+len(decrypted_fragment) == len(encrypted_message):\n                print(index)\n                return\n            else:\n                print(index+len(decrypted_fragment))\n                return\n    print(0)\n\nsolution('''\nHow many positions in the encrypted message where the message fragment could occur?\n\nIt was intercepted a message encrypted with a simple substitution cipher. This message could be decrypted into the following:\n\naaaa\n\nbaaa\n\naaaab\n\nabaa\n\naaaab\n\nababa\n\nabaa\n\nbaa\n\naba\n\naab\n\nba\n\na\n\nab\n\naa\n\naaab\n\naba\n\naaba\n\naabb\n\naabbb\n\nabab\n\nabaaa\n\nababbb\n\nababbba\n\nababbbbb\n\nbab\n\nbaa\n\nabab\n\nabaa\n\naaaa\n\naaaaa\n\naaaaaa\n\naaaaaaaaa\n\naaaaaaaaaaaa\n\naaaaaaaaaaaaa\n\naaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\naaaaaaaaaaaaaaaaaaaa"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    h = stdin.split()[1]\n    t = stdin.split()[2]\n    t = list(t)\n    count = 0\n    while len(t) < n:\n        if t[0] == '<':\n            if len(t) == 1:\n                count += 1\n                break\n            t.append(t.pop(0))\n        if t[0] == '>':\n            if len(t) == 1:\n                count += 1\n                break\n            t.pop(0)\n        if t[0] == '^':\n            if len(t) == 1:\n                count += 1\n                break\n            t.append(t.pop(0))\n        if t[0] == 'v':\n            if len(t) == 1:\n                count += 1\n                break\n            t.pop(0)\n    return str(count)\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    _, maxlen, grid, moves = stdin.split(\"\\n\")\n    maxlen = int(maxlen)\n    grid = grid.strip()\n    moves = moves.strip()\n    t = [[\"\" for _ in range(maxlen)] for _ in range(maxlen)]\n    i = 0\n    j = 0\n    for move in moves:\n        if move == \"^\":\n            j += 1\n            continue\n        elif move == \">\":\n            i += 1\n            continue\n        elif move == \"<\":\n            j -= 1\n            continue\n        elif move == \"v\":\n            i -= 1\n            continue\n        t[i][j] = move\n    return \"\".join([move for row in t for move in row])\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    path = stdin.split()[1]\n\n    field = []\n    for i in range(N):\n        field.append(list(stdin.split()[2 + i]))\n\n    grid_rows = len(field)\n    grid_cols = len(field[0])\n    # print(grid_rows, grid_cols)\n\n    trail = []\n\n    robot = {\n        'x': grid_cols // 2,\n        'y': grid_rows // 2,\n        'path': path\n    }\n\n    while True:\n        if robot['x'] == grid_cols and robot['y'] == grid_rows:\n            if robot['path']!= 'v<^>':\n                trail.append(robot['path'])\n                break\n            else:\n                robot = {\n                    'x': grid_cols // 2,\n                    'y': grid_rows // 2,\n                    'path': '^>v<'\n                }\n                continue\n\n        if robot['path'] == 'v<^>':\n            robot['path'] = '<^>v'\n        elif robot['path'] == '^>v<':\n            robot['path'] = '^>v'\n        elif robot['path'] == '>^v<':\n            robot['path'] = '>^v'\n        elif robot['path'] == 'v<':\n            robot['path'] = '^'\n\n        if robot['path'] == '<^v':\n            robot['x'] += 1\n        elif robot['path'] == '^>v':\n            robot['y'] += 1\n        elif robot['path'] == '^v<':\n            robot['x'] -= 1\n        elif robot['path'] == '>^v':\n            robot['y'] -= 1\n\n        if robot['x'] > grid_cols or robot['x'] < 0 or robot['y'] > grid_rows or robot['y'] < 0:\n            break\n\n        robot['x'] = min(grid_cols, max(0, robot['x']))\n        robot['y'] = min(grid_rows, max(0, robot['y']))\n\n        trail.append(robot['path'])\n\n    return '1' if len(trail) == 0 else str(min(len(trail), N - 1))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return 1\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.rstrip()\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    data = stdin.strip().replace(\" \", \"\")\n    r, c = n, n\n    grid = [[c for _ in range(r)] for _ in range(r)]\n    direction = 0\n    t = []\n    t.append(0)\n    r_idx = 0\n    c_idx = 0\n    for i in range(n):\n        if data[i] == \"^\":\n            direction = 1\n        elif data[i] == \">\":\n            direction = 2\n        elif data[i] == \"v\":\n            direction = 3\n        elif data[i] == \"<\":\n            direction = 4\n        else:\n            raise ValueError(\"unknown char\")\n        if direction == 0:\n            t.append(i)\n            continue\n        if direction == 1:\n            if c_idx!= r_idx:\n                t.append(i)\n                r_idx = c_idx\n            c_idx += 1\n            continue\n        if direction == 2:\n            if c_idx!= r_idx:\n                t.append(i)\n                r_idx = c_idx\n            c_idx -= 1\n            continue\n        if direction == 3:\n            if r_idx!= c_idx:\n                t.append(i)\n                c_idx = r_idx\n            r_idx -= 1\n            continue\n        if direction == 4:\n            if r_idx!= c_idx:\n                t.append(i)\n                c_idx = r_idx\n            r_idx += 1\n            continue\n    return len(t)"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    stdin = stdin.replace('^', '<')\n    stdin = stdin.replace('v', '>')\n    stdin = stdin.replace('<', 'v')\n    stdin = stdin.replace('>', '^')\n    st = list(stdin)\n    trail = []\n    while len(st) > 0:\n        trail.append(st.pop(0))\n        if len(st) == 0:\n            break\n        else:\n            if st[0] in ['<', '>', '^', 'v']:\n                trail.append(st.pop(0))\n                st.pop(0)\n            else:\n                trail.append(st.pop(0))\n    return ''.join(trail)\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin.strip()\n    n, *trail, r = t.splitlines()\n    n = int(n)\n    trail = [list(c) for c in trail]\n    visited = [[False] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if trail[i][j] == '.':\n                visited[i][j] = False\n            if trail[i][j] == 'R':\n                visited[i][j] = True\n\n    dx = (0, 1, 0, -1)\n    dy = (1, 0, -1, 0)\n\n    def travel(x, y, direction):\n        while True:\n            visited[x][y] = True\n            if direction == '>':\n                x += 1\n            elif direction == '<':\n                x -= 1\n            elif direction == '^':\n                y += 1\n            elif direction == 'v':\n                y -= 1\n            if trail[x][y] == '#' or visited[x][y]:\n                return (x, y, direction)\n\n    def bfs(x, y):\n        t = []\n        t.append((x, y, 'R'))\n        visited[x][y] = True\n        while t:\n            nx, ny, dir = t.pop(0)\n            if dir == 'R':\n                return (nx, ny)\n            for i in range(4):\n                next_x, next_y, next_dir = travel(nx, ny, dir)\n                if visited[next_x][next_y]:\n                    continue\n                visited[next_x][next_y] = True\n                t.append((next_x, next_y, next_dir))\n\n    x, y = bfs(0, 0)\n    return str(n - 1 - x)\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    grid = stdin.strip().split('\\n')\n    field_size = len(grid[0])\n    cell_count = sum(1 for line in grid for cell in line if cell!= '#')\n\n    if cell_count == 0:\n        return '1'\n\n    grid_pattern = [(1, 2), (1, -2), (-1, -2), (-1, 2)]\n\n    def find_trail(grid, x, y, i):\n        if i == 0:\n            return ''.join(grid[x][y:])\n\n        visited = set()\n\n        for dx, dy in grid_pattern:\n            nx, ny = x + dx, y + dy\n            while -1 < nx < field_size and -1 < ny < field_size and grid[nx][ny]!= '#':\n                if grid[nx][ny] == '.':\n                    nx += dx\n                    ny += dy\n                else:\n                    visited.add((nx, ny))\n                    break\n\n        if len(visited) == field_size:\n            return ''.join(grid[x][y:])\n\n        for dx, dy in grid_pattern:\n            nx, ny = x + dx, y + dy\n            while -1 < nx < field_size and -1 < ny < field_size and grid[nx][ny]!= '#':\n                if grid[nx][ny] == '.':\n                    nx += dx\n                    ny += dy\n                else:\n                    return ''.join(grid[x][y:])\n\n        for dx, dy in grid_pattern:\n            nx, ny = x + dx, y + dy\n            while -1 < nx < field_size and -1 < ny < field_size and grid[nx][ny]!= '#':\n                if grid[nx][ny] == '.':\n                    nx += dx\n                    ny += dy\n                else:\n                    nx += dx\n                    ny += dy\n\n        return find_trail(grid, x, y, i - 1)\n\n    trail = find_trail(grid, 0, 0, cell_count)\n    return '1' if len(trail)!= field_size * field_size else 'X'\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    grid = []\n    for i in range(1, n+1):\n        grid.append(lines[i])\n    current_cell = (0, 0)\n    trail = [(current_cell)]\n    moves = stdin.split(\"\\n\")[1:]\n    for move in moves:\n        if len(trail) > 0:\n            current_cell = (trail[-1][0] + 1, trail[-1][1] + 1)\n        if len(move) > 0:\n            if move[0] == \"^\":\n                trail.append((current_cell[0]-1, current_cell[1]))\n            elif move[0] == \">\":\n                trail.append((current_cell[0], current_cell[1]+1))\n            elif move[0] == \"<\":\n                trail.append((current_cell[0]+1, current_cell[1]))\n            elif move[0] == \"v\":\n                trail.append((current_cell[0], current_cell[1]-1))\n        else:\n            trail.append((current_cell[0], current_cell[1]))\n    return len(set(trail))"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    fogs = stdin.splitlines()[1:]\n    caught = 0\n    for fog in fogs:\n        _, m, _, r, _, h, d = fog.split()\n        r = int(r)\n        h = int(h)\n        d = int(d)\n        d = d + (m - 1) * d\n        d = abs(d)\n        h = abs(h - r)\n        caught += d + h\n    return str(caught)\n\n\nprint(solution(\n    \"\"\"\n2\n2 3 0 2 9 2 3 0\n1 6 1 4 6 3 -1 -2\n\"\"\"))\n\nprint(solution(\n    \"\"\"\n3\n4 0 0 10 10 1 15 0\n3 5 50 55 8 1 -16 2\n3 10 7 10 4 1 8 -1\n\"\"\"))\n\nprint(solution(\n    \"\"\"\n2\n7 0 0 20 10 3 0 10\n10 1 0 2 5 2 2 7\n\"\"\"))\n"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    d = [int(i) for i in stdin.split()]\n    mod = 10 ** 9 + 7\n    m = [0] * n\n    d1 = 0\n    d2 = 0\n    h = 0\n    h2 = 0\n    deltax = 0\n    for i in range(n):\n        m[i] = d[i]\n        if d[i] > 0:\n            d1 = d1 + 1\n        if d[i] < 0:\n            d2 = d2 + 1\n        if d[i] > 0:\n            h = h + d[i]\n        if d[i] > 0:\n            h2 = h2 + abs(d[i])\n        if d[i] > 0 and d[i] > deltax:\n            deltax = d[i]\n    deltah = 0\n    if d2 > d1:\n        deltah = h2\n        h2 = h\n        h = deltah\n    s = 0\n    while s <= 10 ** 9:\n        s = (s + 1) % mod\n        n = len(m)\n        c = 1\n        if n < 2:\n            break\n        while n - 1 > 0 and m[n - 1] == 0:\n            n -= 1\n            c += 1\n        if n == 1:\n            if m[0] > 0:\n                s += c\n                break\n            else:\n                s += c\n                break\n        while n - 1 > 0:\n            if m[n - 1] == 0:\n                break\n            if c == 1:\n                if m[n - 2] == 0:\n                    break\n                if m[n - 2] > 0:\n                    s += c * 2\n                    break\n            if m[n - 2] > 0:\n                s += c * 2\n                break\n            if m[n - 2] < 0:\n                s += c * 2\n                break\n            if c == 1:\n                s += c\n                break\n            s += c\n            c = 1\n            n -= 1\n    if s > 10 ** 9:\n        s = -1\n    return str(s)\n"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # stdin = '2 3 0 2 9 2 3 0'\n    # stdin = '1 6 1 4 6 3 -1 -2'\n    # stdin = '3 10 7 10 4 1 8 -1'\n    # stdin = '4 0 0 10 10 1 15 0'\n    # stdin = '4 1 5 9 3 5 5 2'\n    # stdin = '5 0 0 10 10 1 15 0'\n    # stdin = '6 10 7 10 4 1 8 -1'\n    # stdin = '2 1 0 4 5 0 1 5'\n    # stdin = '4 0 0 10 10 1 15 0'\n    n = int(stdin)\n    nets = []\n    for i in range(n):\n        nets.append([int(i) for i in stdin.split(' ') if i])\n    # nets = [[2,3,0,2,9,2,3,0],[1,6,1,4,6,3,-1,-2]]\n    # nets = [[4,0,0,10,10,1,15,0],[3,5,50,55,8,1,-16,2]]\n    # nets = [[4,0,0,10,10,1,15,0],[3,5,50,55,8,1,8,-1]]\n    # nets = [[4,1,0,5,2,2,7,2],[3,0,0,5,2,2,7,2]]\n    nets = [[4, 1, 0, 5, 2, 2, 7, 2]]\n    # nets = [[1,6,1,4,6,3,-1,-2],[3,5,50,55,8,1,-16,2]]\n    # nets = [[3,0,0,10,10,1,15,0],[3,5,50,55,8,1,8,-1]]\n    # nets = [[3,10,7,10,4,1,8,-1],[3,0,0,10,10,1,15,0]]\n    # nets = [[2,1,0,4,0,1,5,2],[3,0,0,10,10,1,15,0]]\n    # nets = [[2,3,0,2,9,2,3,0],[1,6,1,4,6,3,-1,-2]]\n    # nets = [[5,0,0,10,10,1,15,0],[3,5,50,55,8,1,-16,2]]\n    # nets = [[2,1,0,4,0,1,5,2],[3,0,0,"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    missed = 0\n    for _ in range(n):\n        m, d, x, h, dchange, dchangex, dchageth, hchange = map(int, stdin.split())\n        n_rects = 0\n        rects = []\n        for _ in range(m):\n            n_rects += 1\n            rects.append(Rectangle(x, h, d, dchange, dchangex, dchageth, hchange))\n        visited_rects = set()\n        while n_rects > 0:\n            n_rects -= 1\n            rect = rects.pop()\n            if not rect.contains(visited_rects):\n                visited_rects.add(rect)\n                n_rects += 1\n        missed += len(visited_rects)\n    return str(missed)\n"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    return str(solve(n))\n\ndef"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines.pop(0))\n    nets = list(map(int, lines))\n    fogs = [[0, 0, 0]]\n    fogs_reported = [[]]\n    missed = 0\n    for net in nets:\n        if len(fogs) == 1:\n            # initialise new fogs\n            fogs = [[net.pop(0), 0, 0]] + fogs\n            fogs_reported = [[]] + fogs_reported\n            continue\n        if fogs[-1][0] + net.pop(0) > fogs[-2][0]:\n            # overlap of fogs, raise next day\n            fogs.pop()\n            fogs.append([net.pop(0), 0, 0])\n            fogs_reported.pop()\n            fogs_reported.append([])\n            continue\n        # normal increase of fogs\n        fogs.append([net.pop(0), 0, 0])\n        fogs_reported.append([])\n    for i, net in enumerate(fogs):\n        if net[1] > 0:\n            # if fogs still left to catch, add patch\n            missed += 1\n            if len(fogs_reported[i]) > 0:\n                fogs_reported[i].append(net)\n            else:\n                fogs_reported[i] = [net]\n    return str(missed)"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    output: int = 0\n    for _ in range(n):\n        line = stdin.split('\\n')[_]\n        m, d, x, h, d_dx, h_dx, h_dhh = map(int, line.split())\n        output += (m - 1) * (x - x - d_dx) // h_dx - h * (d - d_dx) // h_dhh\n    return str(output)\n\n\nprint(solution('''4\n2 3 0 2 9 2 3 0\n1 6 1 4 6 3 -1 -2\n'''))\n"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n,m,l,r,h,x,y = list(map(int,stdin.split()))\n    fogs = [0]*n\n    for i in range(n):\n        fogs[i] = m,l,r,h,x,y,x+(m-1)*x,h+m*h\n    fogs.sort(key=lambda x:x[5])\n    total = 0\n    for i in range(n):\n        if i+1 < n:\n            if fogs[i+1][0] == fogs[i][0]:\n                total += (fogs[i+1][6]-fogs[i][6]) * fogs[i][2]\n            else:\n                total += fogs[i+1][2] - fogs[i][2]\n    return str(total)\n"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    sides: List[List[int]] = [[] for _ in range(n)]\n    for i in range(n):\n        sides[i] = [int(x) for x in stdin.split()[i * 2: i * 2 + 2]]\n\n    def get_patches(net_index: int, fogs_date: int, patches: List[int]) -> None:\n        if net_index == len(sides):\n            patches.append((0, 0, fogs_date))\n            return\n\n        height_diff: int = sides[net_index][3] - sides[net_index][2]\n        patches.append((sides[net_index][0], sides[net_index][1], fogs_date))\n        get_patches(net_index + 1, fogs_date + sides[net_index][4], patches)\n        patches.pop()\n        if height_diff > 0:\n            get_patches(net_index + 1, fogs_date + sides[net_index][4] + height_diff, patches)\n        if height_diff < 0:\n            get_patches(net_index + 1, fogs_date + sides[net_index][4] - height_diff, patches)\n\n    def count_missed_fogs(patches: List[Tuple[int, int, int]]) -> int:\n        patches.sort(key=lambda x: (x[0], x[1], x[2]))\n        prev_fog_date: int = 0\n        count: int = 0\n        for fog_date, l, r in patches:\n            if fog_date == prev_fog_date:\n                count += 1\n                continue\n            count = 0\n            prev_fog_date = fog_date\n        return count\n\n    patches: List[Tuple[int, int, int]] = []\n    get_patches(0, 0, patches)\n    return count_missed_fogs(patches)\n"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    fogs = []\n    for i in range(n):\n        m, d, x, h, dx, dh, dd = map(int, stdin.split())\n        fogs.append((m, d, x, h, dx, dh, dd))\n    return len(get_missed_fogs(fogs))\n\ndef"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    for i in range(4):\n        # Take in and format the input\n        A = tuple(map(float, stdin.split()))\n        # Create an array for X and Y coordinates\n        coords = [(A[0], A[1]), (A[2], A[3])]\n        # Sort the array by X coordinate\n        coords.sort(key=lambda x: x[0])\n        # Check if X coordinates are equal. If they are, Y coordinates are equal too. If they are not, there is an intersection\n        if coords[0][0] == coords[1][0]:\n            # If the end points are equal, return 0.0\n            if coords[0][1] == coords[1][1]:\n                return str(0.0)\n            # If the end points are not equal, return infinity. This is the case where the path is not a straight line\n            else:\n                return str(float('inf'))\n        # If all of the points are equal and they are not the same, return infinity\n        if coords[0][1] == coords[1][1] and coords[0][1] == coords[1][1]:\n            return str(float('inf'))\n        # If all of the points are equal and they are the same, return infinity\n        if coords[0][0] == coords[1][0] and coords[0][0] == coords[1][0]:\n            return str(float('inf'))\n        # If one of the points is equal, return infinity. This is the case where the path is not a straight line\n        if coords[0][1] == coords[1][1]:\n            return str(float('inf'))\n        # If one of the points is equal, return infinity. This is the case where the path is not a straight line\n        if coords[0][0] == coords[1][0]:\n            return str(float('inf'))\n        # If neither of the points are equal, return infinity\n        if coords[0][1]!= coords[1][1] and coords[0][0]!= coords[1][0]:\n            return str(float('inf'))\n        # Create an array to store the distances between each pair of points\n        dist = []\n        # Get the distance from A to B\n        dist.append((coords[1][0] - coords[0][0]) ** 2 + (coords[1][1] - coords[0][1]) ** 2)\n        # Get the distance from A to C\n        dist.append((coords[2][0] - coords[0][0]) ** 2 + (coords[2][1] - coords[0][1]) ** 2)\n        # Get the distance from C to D\n        dist.append((coords[3][0] - coords[2][0]) ** 2 + (coords[3][1] - coords[2][1]) ** 2)\n        # Get the distance from E to F\n        dist.append((coords[1][0] - coords[3][0]) ** 2 + (coords[1][1] - coords[3][1]) ** 2)\n        # Get the distance from E to G\n        dist.append((coords[0][0] - coords[3][0]) ** 2 + (coords[0][1] - coords[3][1]) ** 2)\n        # Get the distance from G to H\n        dist.append((coords[2][0] - coords[3][0]) ** 2 + (coords[2][1] - coords[3][1]) ** 2)\n        # Get the distance from H to I\n        dist.append((coords[1][0] - coords[2][0]) ** 2 + (coords[1][1] - coords[2][1]) ** 2)\n        # Get the distance from I to J\n        dist.append((coords[3][0] - coords[2][0]) ** 2 + (coords[3][1] - coords[2][1]) ** 2)\n        # Get the distance from J to K\n        dist.append((coords[2][0] - coords[3][0]) ** 2 + (coords[2][1] - coords[3][1]) ** 2)\n        # Get the distance from K to L\n        dist.append((coords[1][0] - coords[3][0]) ** 2 + (coords[1][1] - coords[3][1]) ** 2)\n        # Get the distance from L to M\n        dist.append((coords[0][0] - coords[3][0]) ** 2 + (coords[0][1] - coords[3][1]) ** 2)\n        # Get the distance from M to N\n        dist.append((coords[2][0] - coords[3][0]) ** 2 + (coords[2][1] - coords[3][1]) ** 2)\n        # Get the distance from N to O\n        dist.append((coords[1][0] - coords[2][0]) ** 2 + (coords[1][1] - coords[2][1]) ** 2)\n        # Get the distance from P to Q\n        dist.append((coords[0][0] - coords[1][0]) ** 2 +"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return stdin.strip()\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    [x1,y1,x2,y2] = list(map(float, stdin.split()))\n    distance_matrix = list()\n    for i in range(2):\n        distance_matrix.append([x2 - x1, y2 - y1])\n    distance_matrix = sorted(distance_matrix, key=lambda x: x[0] ** 2 + x[1] ** 2, reverse=True)\n    x1, y1 = distance_matrix[0]\n    x2, y2 = distance_matrix[1]\n    return str(x1 * x2 + y1 * y2)\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B = tuple(map(float, stdin.split()))\n    return str(min(2 ** n * (B - A) / n for n in range(1, 20)))\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    data = (list(map(float, stdin.split())))\n    x1, y1, x2, y2 = data[0], data[1], data[2], data[3]\n    N = int(stdin.split()[4])\n    h = []\n    for i in range(N):\n        h.append((data[5 * i], data[5 * i + 1]))\n    x1 = x1\n    x2 = x2\n    y1 = y1\n    y2 = y2\n    if x1 == x2 and y1 == y2:\n        return '0.0'\n    if x1 == x2 and y1!= y2:\n        return '{:.6f}'.format(abs(x2 - x1) / abs(y2 - y1))\n    if y1 == y2 and x1!= x2:\n        return '{:.6f}'.format(abs(y2 - y1) / abs(x2 - x1))\n    if x1!= x2 and y1!= y2:\n        a1 = abs(x2 - x1)\n        a2 = abs(y2 - y1)\n        if (a2, a1) in h:\n            return '{:.6f}'.format((a2 ** 2 + a1 ** 2) **.5)\n        else:\n            h.append((a1, a2))\n            return '{:.6f}'.format((a2 ** 2 + a1 ** 2) **.5)\n    if x1!= x2 and y1 == y2 and x1 == x2:\n        return '{:.6f}'.format(abs(y1 - y2))\n    if x1 == x2 and y1 == y2 and x1 == x2:\n        return '{:.6f}'.format(abs(x1 - x2))\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    (x1, y1, x2, y2) = map(float, stdin.split())\n    return str(min_time(x1, y1, x2, y2))\n\n\ndef"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, B = list(map(float, stdin.split()))\n    x1, y1 = A\n    x2, y2 = B\n    distance = ((x1 - x2)**2 + (y1 - y2)**2)**0.5\n    return str(distance)\ndef"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    x_a, y_a, x_b, y_b = [float(s) for s in stdin[0].split()]\n    n = int(stdin[1])\n    nodes = [[float(s) for s in stdin[2*i + 2].split()] for i in range(n)]\n    nodes = sorted(nodes, key=lambda x: (x[0], x[1]))\n    x_max = x_a + abs(x_b-x_a)\n    y_max = y_a + abs(y_b-y_a)\n    def get_dist(i, j):\n        return (((nodes[i][0] - nodes[j][0])**2) + ((nodes[i][1] - nodes[j][1])**2)) ** 0.5\n    def get_distance(i):\n        distances = []\n        for j in range(i+1, len(nodes)):\n            distances.append(get_dist(i,j))\n        return sum(distances)\n    return str(get_distance(0))\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def calc_dist(loc1: tuple, loc2: tuple) -> float:\n        x_dist = loc2[0] - loc1[0]\n        y_dist = loc2[1] - loc1[1]\n        return x_dist ** 2 + y_dist ** 2\n\n    intervals = stdin.split('\\n')\n    intervals = [x.split() for x in intervals]\n    intervals = [[float(x[0]), float(x[1]), float(x[2]), float(x[3])] for x in intervals]\n    intervals = sorted(intervals, key=lambda x: x[0])\n    intervals = sorted(intervals, key=lambda x: x[1])\n\n    shortest_path = intervals[0][1]\n    shortest_time = 0\n    for i in range(1, len(intervals)):\n        # get previous\n        prev = intervals[i - 1]\n        current = intervals[i]\n        prev_dist = calc_dist(prev, current)\n\n        # get new current\n        current_dist = calc_dist(current, intervals[i + 1])\n        if current_dist < prev_dist:\n            shortest_time += current_dist\n        else:\n            shortest_time += prev_dist\n\n    return str(shortest_time)\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, X1, Y1, X2, Y2 = map(float, stdin.split())\n    return (X2 - X1) / (Y2 - Y1)"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n, k, p = stdin[0], stdin[1], stdin[2]\n    return \" \".join(sorted(list(set(stdin[0].lower())), key=stdin[0].lower())) if len(stdin[0]) == int(n) and int(k) <= int(stdin[0]) <= 26 and len(set(stdin[0])) == int(k) and int(p) == max(\n        len(l) for l in sorted((stdin[0][i:] + stdin[0][:i]) for i in range(len(stdin[0])))):\n        return \"\".join(stdin[0])\n    else:\n        return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.strip().split())\n    a = list(range(26))\n    pal = set()\n    for i in range(K):\n        j, k = i % 26, i // 26\n        if a[j]!= a[k]:\n            pal.add(a[j])\n            pal.add(a[k])\n    if P == N:\n        pal = set(list(pal))\n        return ''.join(sorted(pal))\n    pal = set(list(pal))\n    # print(N, K, P, pal)\n    for i in range(P):\n        if i not in pal:\n            return 'IMPOSSIBLE'\n    return ''.join(sorted(pal))\n\n\nsolution('''6 5 3\n''')\nsolution('''9 8 1\n''')\nsolution('''5 3 5\n''')\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split()\n    return \"IMPOSSIBLE\" if is_symmetric(stdin_list[0], stdin_list[1], stdin_list[2]) else stdin_list[0]\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = stdin.split()\n    N, K, P = int(N), int(K), int(P)\n\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\n    for string in (\n        \"\".join(string)\n        for string in itertools.product(alphabet, repeat=N)\n        if len(string) == N and len(set(string)) == K and is_palindrome(string)\n    ):\n        if is_longest_palindrome(string, P):\n            return string\n\n    return \"IMPOSSIBLE\"\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    longest = 0\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            palindrome = ''.join(sorted(list(stdin[:i])))\n            if palindrome == palindrome[::-1] and len(set(stdin[:i])) == K:\n                if len(stdin[:i]) - len(palindrome) > longest:\n                    longest = len(stdin[:i]) - len(palindrome)\n                    result = palindrome\n    return result\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if N < 1 or K < 1 or K > 26 or N < K:\n        return \"IMPOSSIBLE\"\n    if N == 1:\n        return stdin\n    if K == 1:\n        return stdin.upper()\n    if P == 1:\n        return stdin\n    candidate = stdin[:N // 2] + stdin[N // 2:]\n    palindrome = stdin[:P // 2] + stdin[P // 2 + 1:]\n    if candidate == palindrome:\n        return candidate\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if N == P or N == K:\n        return 'IMPOSSIBLE'\n    for x in range(1, N + 1):\n        for y in range(1, N + 1):\n            z = y + (x - 1)\n            if x == y and y == z:\n                continue\n            if z > N:\n                break\n            if N == K:\n                if x == K:\n                    return 'rarity'\n            if len(set(str(x))) == K and len(set(str(y))) == K and len(set(str(z))) == K:\n                if len(str(x)) == P and len(str(y)) == P and len(str(z)) == P:\n                    return 'rarity'\n    return 'IMPOSSIBLE'\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if N < 1 or N > 10**6 or K < 1 or K > 26 or P < 1 or P > N:\n        return \"IMPOSSIBLE\"\n    ans = \"\"\n    for i in range(1, K + 1):\n        if i <= 9:\n            ans = ans + chr(ord('a') + i - 1)\n        elif i <= 26:\n            ans = ans + chr(ord('a') + i - 1)\n        else:\n            ans = ans + chr(ord('a') + i - 1)\n    for i in range(1, N - K + 1):\n        if len(ans) >= 2 * N:\n            break\n        if i <= 9:\n            ans = ans + chr(ord('a') + i - 1)\n        elif i <= 26:\n            ans = ans + chr(ord('a') + i - 1)\n        else:\n            ans = ans + chr(ord('a') + i - 1)\n    ans = ans + ans[::-1]\n    if len(ans)!= N:\n        return \"IMPOSSIBLE\"\n    return ans\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n, k, p = int(stdin[0]), int(stdin[1]), int(stdin[2])\n    s = str(n * k)\n    s = sorted(s, key=lambda x: ord(x), reverse=True)\n    while len(s)!= 1:\n        i = 0\n        while len(s) > 0 and s[i] == s[-i-1]:\n            s.pop()\n        i = 0\n        while len(s) > 0 and s[i] == s[-i-1]:\n            s.pop()\n        i = 0\n        while len(s) > 0 and s[i] == s[-i-1]:\n            s.pop()\n        i = 0\n        while len(s) > 0 and s[i] == s[-i-1]:\n            s.pop()\n        i = 0\n        while len(s) > 0 and s[i] == s[-i-1]:\n            s.pop()\n    return ''.join(s)\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = [int(x) for x in stdin.split()]\n    for l in range(2, min(N, P) + 1):\n        if len(set(stdin[i : i + l] for i in range(N - l + 1))) == K:\n            return stdin[: l] + stdin[-l : ]\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    input\n        input line of text (string)\n    output\n        haiku (string)\n    \"\"\"\n    lines = stdin.split('\\n')\n    for line in lines:\n        if len(line) > 200:\n            print(\"Input line is too long\")\n            return\n        else:\n            # split line into words\n            words = line.split(' ')\n            # create a new variable to hold the line\n            words =''.join(words)\n            # split line into words\n            words = words.split(' ')\n            # create a new variable to hold the line\n            words =''.join(words)\n            # iterate over words and break the sequence into syllables\n            syllables = []\n            for word in words.split(' '):\n                syllables.append(syllable(word))\n            # check the sequence is as expected\n            if syllables[0] == 5 and syllables[1] == 7:\n                # if it is, split line into lines\n                lines = words.split(' ')\n                # iterate over lines\n                for line in lines:\n                    print(line)\n            else:\n                print(\"Input line is not as expected\")\n                return\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    syllables = []\n    for word in words:\n        syllables.extend(count_syllables(word))\n    syllables = list(set(syllables))\n    syllables.sort()\n\n    if len(syllables) == 1:\n        return stdin\n    elif len(syllables) == 2:\n        if syllables[0] + syllables[1] == 7:\n            return stdin\n        else:\n            return None\n    else:\n        return None\n\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    if len(words) < 3:\n        print(stdin)\n        return\n    i = 0\n    while i < len(words) - 2:\n        if len(words[i + 1]) > 2 and words[i + 1][-1] == 'e' and words[i + 2][0].isalpha():\n            i += 2\n            continue\n        if words[i][-1] == 'e' and words[i + 1][0].isupper():\n            i += 2\n            continue\n        i += 1\n    if i == len(words) - 2:\n        print(''.join(words))\n        return\n    while i < len(words) - 1:\n        if len(words[i + 1]) > 2 and words[i + 1][-1] == 'e' and words[i + 2][0].isalpha():\n            i += 2\n            continue\n        if words[i][-1] == 'e' and words[i + 1][0].isupper():\n            i += 2\n            continue\n        i += 1\n    print(''.join(words))\n    return\nsolution(stdin)\n\"\"\"\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.strip()\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_vowel(char: str):\n        return char in 'AEIOUaeiou'\n    words = stdin.split()\n    vowels = {'AEIOUaeiou'}\n    for word in words:\n        if word == '?':\n            continue\n        if len(word) == 1:\n            print(word)\n            return\n        for i in range(1, len(word)):\n            if is_vowel(word[i - 1]) and is_vowel(word[i]):\n                continue\n            if is_vowel(word[i - 1]) or is_vowel(word[i]):\n                vowels.add(word[i])\n                break\n        else:\n            print(word)\n            return\n    if not vowels:\n        print(stdin)\n        return\n    #\n    vowels = sorted(vowels)\n    line = []\n    while words:\n        word = words.pop(0)\n        if word in vowels:\n            print(' '.join(line))\n            line = []\n        else:\n            line.append(word)\n    print(' '.join(line))\n    return\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    dic = {}\n    for i in stdin:\n        i = i.strip()\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    syl = 0\n    for i in dic.values():\n        if i == 1:\n            syl += 1\n    n = len(stdin.split()) - syl\n    if n < 1:\n        return stdin\n    for i in range(0, n):\n        print(stdin.split()[i], end=\" \")\n    return \"\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.rstrip()\n    words = line.split()\n\n    # Count syllables\n    count = 0\n    for w in words:\n        syllable_count = get_syllable_count(w)\n        count += syllable_count\n\n    # Print haiku\n    if count >= 4:\n        haiku = make_haiku(words)\n        return '\\n'.join(haiku)\n    else:\n        return line\n\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n'''\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # 2-line maximum\n    max_line_length = 200\n    words = stdin.split('\\n')\n    for line in words:\n        line = line.strip()\n        # skip blank lines\n        if len(line) == 0:\n            continue\n        # set up of 4\n        first_line, second_line, third_line, fourth_line = '', '', '', ''\n        first_count, second_count, third_count, fourth_count = 0, 0, 0, 0\n        first_letters = set()\n        first_is_l = False\n        second_is_l = False\n        first_is_v = False\n        second_is_v = False\n        third_is_v = False\n        third_is_l = False\n        second_is_l = False\n        # keep track of word lengths and letters\n        for word in line:\n            if len(word) > max_line_length:\n                break\n            if len(word) > first_count + second_count + third_count + fourth_count:\n                # check for vowels\n                if word[0] in {'a', 'e', 'i', 'o', 'u', 'y'}:\n                    first_is_v = True\n                    second_is_v = True\n                    first_is_l = True\n                    second_is_l = True\n                    third_is_v = True\n                    third_is_l = True\n                else:\n                    first_is_v = True\n                    second_is_v = True\n                    first_is_l = True\n                    second_is_l = True\n                    third_is_v = True\n                    third_is_l = True\n                if first_is_l:\n                    first_count += 1\n                if second_is_l:\n                    second_count += 1\n                if third_is_l:\n                    third_count += 1\n                if fourth_is_l:\n                    fourth_count += 1\n                if first_is_v:\n                    first_count += 1\n                if second_is_v:\n                    second_count += 1\n                if third_is_v:\n                    third_count += 1\n                if fourth_is_v:\n                    fourth_count += 1\n                # reset all values\n                first_is_v = False\n                first_is_l = False\n                second_is_v = False\n                second_is_l = False\n                third_is_v = False\n                third_is_l = False\n                first_count = 0\n                second_count = 0\n                third_count = 0\n                fourth_count = 0\n            else:\n                # check if vowel in the middle\n                if first_is_v and word[0] in {'a', 'e', 'i', 'o', 'u', 'y'}:\n                    first_is_v = True\n                    second_is_v = True\n                    first_is_l = True\n                    second_is_l = True\n                    third_is_v = True\n                    third_is_l = True\n                else:\n                    first_is_v = False\n                    second_is_v = False\n                    first_is_l = False\n                    second_is_l = False\n                    third_is_v = False\n                    third_is_l = False\n                if first_is_l:\n                    first_count += 1\n                if second_is_l:\n                    second_count += 1\n                if third_is_l:\n                    third_count += 1\n                if fourth_is_l:\n                    fourth_count += 1\n                if first_is_v:\n                    first_count += 1\n                if second_is_v:\n                    second_count += 1\n                if third_is_v:\n                    third_count += 1\n                if fourth_is_v:\n                    fourth_count += 1\n                # count remaining words\n                if first_is_l:\n                    first_count += 1\n                if second_is_l:\n                    second_count += 1\n                if third_is_l:\n                    third_count += 1\n                if fourth_is_l:\n                    fourth_count += 1\n                if first_is_v:\n                    first_count += 1\n                if second_is_v:\n                    second_count += 1\n                if third_is_v:\n                    third_count += 1\n                if fourth_is_v:\n                    fourth_count += 1\n            # add the word to the line\n            if first_is_v:\n                first_is_v = False\n                first_is_l = False\n                first_count = 0\n            if second_is_v:\n                second_is_v = False\n                second_is_l"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    names: List[str] = []\n    for _ in range(n):\n        names.append(stdin.replace(\"\\n\", \"\"))\n    names.sort()\n    names.sort(key=lambda s: len(s))\n    for name in names:\n        if name!= \"ThoreHusfeldt\":\n            continue\n        else:\n            break\n    for name in names:\n        if name[0:len(name)-2]!= \"ThoreHusfeldt\":\n            continue\n        else:\n            break\n    return name if name!= \"ThoreHusfeldt\" else \"Thore sucks\""
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Gets the largest prefix that uniquely determines Thore on the scoreboard, and gives back the result.\n    '''\n    names = stdin.split()\n    prefixes = []\n    for name in names:\n        name = name.lower()\n        for i in range(len(name)):\n            prefix = name[:i]\n            if (prefix in prefixes) and (name in prefixes):\n                prefixes.remove(prefix)\n            elif prefix in prefixes:\n                prefixes.remove(prefix)\n            else:\n                prefixes.append(prefix)\n    if prefixes:\n        prefixes.sort(reverse=True)\n        return prefixes[0]\n    return 'Thore sucks'\n"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    names = []\n    for line in lines:\n        names.append(line.strip())\n\n    # names = {line.strip() for line in lines}\n    names.remove(\"ThoreHusfeldt\")\n    names.sort()\n    names.reverse()\n    # print(names)\n    names = \"\".join(names)\n    print(names)\n    names = names.split('t')\n    names.sort(key=lambda x: len(x))\n    # print(names)\n    names = \"\".join(names)\n    # print(names)\n    if names == \"ThoreHusfeldt\":\n        return \"Thore is awesome\"\n    return names + \" sucks\"\n\n\nprint(solution(input))\n"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    names: Set[str] = set()\n    while True:\n        try:\n            line = stdin.readline()\n            if not line:\n                return ''\n            name = line.rstrip()\n            if name == 'ThoreHusfeldt':\n                return 'Thore is awesome'\n            names.add(name)\n        except EOFError:\n            break\n    for name in names:\n        if any(name.startswith(pref) for pref in names):\n            return 'Thore sucks'\n    return min(names)\n"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    if stdin == \"ThoreHusfeldt\":\n        return \"Thore is awesome\"\n    else:\n        return \"Thore sucks\""
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    times = []\n    for time in stdin.split('\\n'):\n        name = time.split()[0]\n        times.append(name)\n    times = sorted(times, key=lambda x: x.upper())\n    current = times[0]\n    for name in times[1:]:\n        prefix = name.split()[0]\n        if prefix!= current:\n            return prefix\n        else:\n            current = name\n    return current\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    names = stdin.strip().split('\\n')\n    names = sorted(names)\n    if names.index('ThoreHusfeldt') < names.index('ThoreHusfeldter'):\n        return 'Thore sucks'\n    return 'Thore is awesome'\n\nsolution(input())"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('''\n   ... ThoreTiemann\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt\n   ... ThoreHus"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    names = []\n    for i in range(n):\n        names.append(stdin.split()[i])\n\n    for i in range(n-1):\n        if names[i] == names[i+1][0:len(names[i])]:\n            return 'Thore is awesome'\n    for i in range(n):\n        if names[i][0]!= 'Thore':\n            names[i] = 'Thore' + names[i]\n    return names[0]\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    a = stdin.pop(0)\n    b = stdin.pop(0)\n    if len(set(stdin)) == 1:\n        return a\n    return b\nprint(solution(input()))"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.strip().split('\\n')\n    input = list(filter(None, input))\n    input = list(map(lambda x: x.split('*'), input))\n\n    result = []\n    for i in input:\n        if i[0] == 'L':\n            result.append(2*int(i[1]))\n        elif i[0] == 'R':\n            result.append(2*int(i[1])+1)\n        else:\n            result.append(int(i[1]))\n    print(result)\n\n    return str(sum(result))\n\nsolution('P*P')\nsolution('L*R')\nsolution('**')"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    set = stdin\n    result = 0\n    for i in set:\n        if i == \"*\":\n            result += 2\n        if i == \"L\":\n            result += 2**2\n        if i == \"R\":\n            result += 2**3\n        if i == \"P\":\n            result += 2**4\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    walks = stdin.split('*')\n    return str(sum([int(i) for i in walks]))"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return sum([sum([2 ** i for i, c in enumerate(stdin) if c == \"*\"]) for _, c in enumerate(stdin)])\n    \n"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return sum([determine_walks(stdin)])\n\ndef"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pattern = stdin\n    subpattern = pattern[0]\n    string = pattern[1]\n    subpattern_len = len(subpattern)\n    string_len = len(string)\n    dp = [[None] * (string_len + 1) for i in range(subpattern_len + 1)]\n    dp[0][0] = 1\n    for j in range(1, subpattern_len + 1):\n        dp[j][0] = 0\n    for i in range(1, subpattern_len + 1):\n        dp[0][i] = 0\n    for i in range(1, subpattern_len + 1):\n        for j in range(1, string_len + 1):\n            dp[i][j] = dp[i - 1][j]\n            if subpattern[i - 1] == string[j - 1]:\n                dp[i][j] += dp[i - 1][j - 1]\n    return str(dp[subpattern_len][string_len])\n"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    f = stdin\n    l = f.split()\n    size = int(l[0])\n    ls = []\n    if size == 0:\n        return size\n    # print(size)\n    #print(l)\n    for i in l:\n        if i == \"P*P\":\n            # print(\"hello\")\n            if len(ls) > 0:\n                ls.pop()\n            # print(ls)\n        elif i == \"L*R\":\n            if len(ls) > 0:\n                ls.pop()\n        elif i == \"P*P\":\n            ls.append(\"*\")\n        else:\n            if len(ls) == 0:\n                ls.append(i)\n            else:\n                ls.append(i)\n    # print(ls)\n    return \"\".join(ls)"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    node_dict = {}\n    root = 1\n    node_dict[1] = (2, 2)\n\n    # print(node_dict)\n\n    def is_leaf(node):\n        return len(node_dict) == 1\n\n    def dfs(node, level):\n        # print(node, level)\n        if is_leaf(node):\n            nonlocal node_dict\n            node_dict[level] = (node_dict[level][0] + node[0], node_dict[level][1] + node[1])\n            return\n\n        left, right = node_dict[level]\n        node_dict[level] = (left + node[0], right + node[1])\n\n        dfs(node_dict[level + 1], level + 1)\n        dfs(node_dict[level + 1], level + 1)\n\n    dfs(stdin, 0)\n    # print(node_dict)\n    return str(node_dict[0][0] + node_dict[0][1])\n"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('P*P')\n    '6'\n    >>> solution('L*R')\n    '25'\n    >>> solution('**')\n    '33'\n    \"\"\"\n    pattern = stdin.strip().split('*')\n    if pattern[0] == '':\n        return str(len(pattern)-1)\n    else:\n        return str(len(pattern))\n"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    f = stdin.split(\"*\")\n    ans = 0\n    while len(f) > 0:\n        s = f.pop(0)\n        if len(s) == 1:\n            ans += 1\n            continue\n        r = 0\n        for i in range(n - 1):\n            if s[i] == \"L\" and s[i + 1] == \"R\":\n                r += 1\n                continue\n            if s[i] == \"R\" and s[i + 1] == \"L\":\n                r += 1\n                continue\n        ans += r + 1\n    return str(ans)\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split(\"\\n\")\n    if len(data) == 1:\n        return \"wait what?\"\n    lengths = [len(i) for i in data]\n    min_length = min(lengths)\n    for i in data:\n        if len(i)!= min_length:\n            return \"wait what?\"\n    lengths = sorted(lengths, reverse=True)\n    for i in range(min_length):\n        lengths_dict = {}\n        for j in data:\n            if j[i] not in lengths_dict.keys():\n                lengths_dict[j[i]] = 1\n            else:\n                lengths_dict[j[i]] += 1\n        lengths_dict = dict(sorted(lengths_dict.items(), key=lambda x: x[1], reverse=True))\n        if len(lengths_dict) == 1 and \"o\" not in lengths_dict.keys():\n            return \"yes\"\n        else:\n            return \"wait what?\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    statements = stdin.split('\\n')\n\n    def is_equal(x, y):\n        return x == y or len(x) == 1 and len(y) == 1 and x in {'a', 'o', 'u'} and y in {'a', 'o', 'u'}\n\n    def convert_to_rhyme(x):\n        l = len(x)\n        if l < 5:\n            return x\n        return f'{x[0]}{x[-3:]}'\n\n    def rhymes_with_everything(statement):\n        statement = statement.split(' is ')[-1]\n        for i in range(5, 0, -1):\n            if not statement.endswith(f'{statement[-i:]}'):\n                return False\n        return True\n\n    is_consistent_with_everything = True\n    for statement in statements:\n        if statement.count('is')!= 1 or statement.count('not')!= 1:\n            print(statement)\n            return 'wait what?'\n\n        rhyme_statement = convert_to_rhyme(statement.split(' is ')[0])\n        words_that_rhymes = list(map(convert_to_rhyme, statement.split(' is ')[-1].split(' and ')))\n        for x in words_that_rhymes:\n            if not rhymes_with_everything(x):\n                return 'wait what?'\n        if not is_equal(rhyme_statement, statement.split(' is ')[-1]):\n            is_consistent_with_everything = False\n    return 'yes' if is_consistent_with_everything else 'wait what?'"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    assert len(stdin.splitlines()) == 1\n    consistent_statements = 0\n    for line in stdin.splitlines():\n        if line[0] == \"$\":\n            statement = line.split(\"is\")\n            if len(statement)!= 2:\n                continue\n            else:\n                if (\n                    statement[0][-1] == statement[1][-1]\n                    and len(statement[0]) > 1\n                    and len(statement[1]) > 1\n                ):\n                    consistent_statements += 1\n    return \"yes\" if consistent_statements == len(stdin.splitlines()) else \"wait what?\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    assert len(stdin) > 0\n    stdin = stdin.splitlines()\n    res = \"yes\"\n    for st in stdin:\n        st = st.split()\n        st = st[0]\n        st_count = 1\n        for i in range(1, len(st)):\n            if st[i] == st[i - 1]:\n                st_count += 1\n            else:\n                if st_count >= 3:\n                    break\n                st_count = 1\n            if st_count >= 3 and not st[i - 3:i].count(\"a\") == st[i - 3:i].count(\"b\"):\n                res = \"wait what?\"\n                break\n    return res\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    i = 0\n    while i < len(stdin):\n        j = 0\n        while j < len(stdin) and i < len(stdin):\n            if stdin[i] == stdin[j]:\n                if j + 1 < len(stdin) and stdin[i]!= stdin[j + 1]:\n                    return 'wait what'\n                j += 1\n            else:\n                break\n        i += 1\n    return 'yes'\n\nsolution(input())\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    for i in range(len(stdin)):\n        stdin[i] = stdin[i].split()\n    # print(stdin)\n    for i in range(len(stdin)):\n        for j in range(i+1, len(stdin)):\n            if is_consistent(stdin[i], stdin[j]):\n                print(\"yes\")\n            else:\n                print(\"wait what\")\n    return \"\"\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split(\"\\n\")\n    rhyme = []\n    for i in range(len(data)):\n        if (i+1)%2 == 0:\n            rhyme.append(data[i].split())\n    for i in range(len(rhyme)):\n        a,b = rhyme[i][0], rhyme[i][1]\n        if(a=='herp' and b=='derp' or a=='derp' and b=='herp'):\n            return 'yes'\n    return 'wait what?'"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_rhyme(a, b):\n        i = min(3, len(a), len(b))\n        return a[-i:] == b[-i:]\n    def get_unanimous(a, b):\n        return any(get_rhyme(a, b), get_rhyme(b, a))\n    result = []\n    for i in range(len(stdin)):\n        first = stdin[i]\n        for j in range(i+1, len(stdin)):\n            second = stdin[j]\n            if not get_unanimous(first, second):\n                result.append((first, second))\n            if get_unanimous(second, first):\n                break\n    if result:\n        return \"yes\"\n    else:\n        return \"wait what?\"\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return 'yes' if is_consistent(stdin) else 'wait what?'\n\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... herp is derp\n   ... derp is herp\n   ... herp is herp\n   ... derp is derp\n   ... ''')\n    'yes'\n    >>> solution('''\n   ... oskar not lukas\n   ... oskar is poptart\n   ... lukas is smart\n   ... ''')\n    'yes'\n    >>> solution('''\n   ... moo not foo\n   ... ''')\n    'wait what?'\n    \"\"\"\n    data = stdin.strip().splitlines()\n    if len(data) == 1:\n        return 'yes'\n    return 'wait what?'\n"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num_of_samples = int(stdin.rstrip())\n    fossil_species = stdin.rstrip().split()\n    result = []\n    # edge case\n    if num_of_samples == 1 and len(fossil_species) == 1:\n        result.append(fossil_species)\n        result.append(fossil_species)\n        return result\n    # case1\n    if num_of_samples == 1 and len(fossil_species) == 2:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        return result\n    # case 2\n    if num_of_samples == 2 and len(fossil_species) == 3:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        return result\n    # case 3\n    if num_of_samples == 2 and len(fossil_species) == 4:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        result.append(fossil_species[2])\n        return result\n    # case 4\n    if num_of_samples == 3 and len(fossil_species) == 5:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        result.append(fossil_species[2])\n        return result\n    # case 5\n    if num_of_samples == 4 and len(fossil_species) == 6:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        result.append(fossil_species[2])\n        result.append(fossil_species[3])\n        return result\n    # case 6\n    if num_of_samples == 5 and len(fossil_species) == 7:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        result.append(fossil_species[2])\n        result.append(fossil_species[3])\n        result.append(fossil_species[4])\n        return result\n    # case 7\n    if num_of_samples == 6 and len(fossil_species) == 8:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        result.append(fossil_species[2])\n        result.append(fossil_species[3])\n        result.append(fossil_species[4])\n        result.append(fossil_species[5])\n        return result\n    # case 8\n    if num_of_samples == 7 and len(fossil_species) == 9:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        result.append(fossil_species[2])\n        result.append(fossil_species[3])\n        result.append(fossil_species[4])\n        result.append(fossil_species[5])\n        result.append(fossil_species[6])\n        return result\n    # case 9\n    if num_of_samples == 8 and len(fossil_species) == 10:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        result.append(fossil_species[2])\n        result.append(fossil_species[3])\n        result.append(fossil_species[4])\n        result.append(fossil_species[5])\n        result.append(fossil_species[6])\n        result.append(fossil_species[7])\n        return result\n    # case 10\n    if num_of_samples == 9 and len(fossil_species) == 11:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        result.append(fossil_species[2])\n        result.append(fossil_species[3])\n        result.append(fossil_species[4])\n        result.append(fossil_species[5])\n        result.append(fossil_species[6])\n        result.append(fossil_species[7])\n        result.append(fossil_species[8])\n        return result\n    # case 11\n    if num_of_samples == 10 and len(fossil_species) == 12:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        result.append(fossil_species[2])\n        result.append(fossil_species[3])\n        result.append(fossil_species[4])\n        result.append(fossil_species[5])\n        result.append(fossil_species[6])\n        result.append(fossil_species[7])\n        result.append(fossil_species[8])\n        result.append(fossil_species[9])\n        return result\n    # case 12\n    if num_of_samples == 11 and len(fossil_species) == 13:\n        result.append(fossil_species[0])\n        result.append(fossil_species[1])\n        result.append(foss"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('1')\n    impossible\n    >>> solution('2')\n    1 4\n    \"\"\"\n    # your code here\n    n = int(stdin.strip())\n    if n == 0:\n        return \"impossible\"\n\n    sequence_1 = stdin.split()[0]\n    sequence_2 = stdin.split()[1]\n\n    if sequence_1 == sequence_2:\n        return \"impossible\"\n    else:\n        return str(len(sequence_1)) + \" \" + str(len(sequence_2))\n    # your code here"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = stdin.strip().split()\n    a = sorted(a, reverse=True)\n    print(\"\\n\".join(a))\n    return \"impossible\"\n    \nsolution(input())\n"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    species = lines[1]\n    num = 1\n    while len(species) < n:\n        species += lines[num]\n        num += 1\n    return''.join(sorted(species))\n"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    sequence: str = stdin\n    return print(solution.__doc__) if n < 1 else print(*solution(input()), sep=\"\\n\")"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.split('\\n')[0])\n    org_seq: str = stdin.split('\\n')[1]\n    seqs: list = []\n    for i in range(2, n + 1):\n        seqs.append(stdin.split('\\n')[i])\n    seqs = sorted(seqs)\n    num_diff: int = seqs.count(org_seq)\n    if num_diff == 2:\n        return 'impossible'\n    else:\n        return str(num_diff) +'' + str(seqs.index(org_seq) + 1)\n"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    seq = stdin.splitlines()\n    a_seq = seq[0]\n    a_seq = a_seq.replace('A', 'a')\n    a_seq = a_seq.replace('C', 'c')\n    a_seq = a_seq.replace('M','m')\n    res = str(len(a_seq))\n    a_seq = a_seq.replace('a', 'A')\n    a_seq = a_seq.replace('c', 'C')\n    a_seq = a_seq.replace('m', 'M')\n    if len(a_seq) == 0:\n        return 'impossible'\n    else:\n        return str(n) +'' + a_seq\n"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    stdin:\n        1\n        AM\n        MA\n    \"\"\"\n    n: int = int(stdin)\n    nucleotide_sequence: str = stdin.strip()\n    first_path: Dict[str, int] = {}\n    second_path: Dict[str, int] = {}\n    for nucleotide in nucleotide_sequence:\n        if nucleotide not in first_path and nucleotide not in second_path:\n            first_path[nucleotide] = 0\n            second_path[nucleotide] = 0\n    first_path_size = len(first_path)\n    second_path_size = len(second_path)\n    print(first_path_size, second_path_size)\n    if first_path_size!= second_path_size:\n        return \"impossible\"\n    if first_path_size == 0:\n        return \"impossible\"\n    for first_nucleotide in sorted(first_path.keys()):\n        for second_nucleotide in sorted(second_path.keys()):\n            if first_nucleotide == second_nucleotide:\n                if first_path[first_nucleotide]!= second_path[second_nucleotide]:\n                    return \"impossible\"\n    return str(first_path_size) + \" \" + str(second_path_size)\n"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    strings = stdin.split(\"\\n\")\n    strings.pop()\n    first = strings[0]\n    strings = strings[1:]\n    second = strings[0]\n    strings = strings[1:]\n    string1 = \"\".join(first)\n    string2 = \"\".join(second)\n    if len(set(string1))!= len(set(string2)) or len(string1)!= len(string2):\n        return \"impossible\"\n    else:\n        for i in range(len(string1)):\n            if string1[i]!= string2[i]:\n                if (i == 0 or string1[i-1]!= string2[i]) and (i == len(string1)-1 or string1[i]!= string2[i+1]):\n                    return \"impossible\"\n    count_string1 = {}\n    count_string2 = {}\n    for i in range(len(string1)):\n        if string1[i] in count_string1:\n            count_string1[string1[i]] += 1\n        else:\n            count_string1[string1[i]] = 1\n    for i in range(len(string2)):\n        if string2[i] in count_string2:\n            count_string2[string2[i]] += 1\n        else:\n            count_string2[string2[i]] = 1\n    for i in count_string1:\n        if i not in count_string2:\n            return \"impossible\"\n    for i in count_string2:\n        if i not in count_string1:\n            return \"impossible\"\n    for i in range(len(string1)):\n        if string1[i] not in count_string1:\n            return \"impossible\"\n    return str(len(strings)) + \" \" + \" \".join(strings)"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    n_test = int(sys.stdin.readline())\n    assert n_test <= 4\n    m_input = stdin.split(\"\\n\")\n    assert len(m_input) == n_test\n    for i in range(n_test):\n        assert len(m_input[i]) == 1\n    if n_test == 1:\n        return m_input[0][0]\n    if n_test == 2:\n        return m_input[0][0] + m_input[1][0]\n    if n_test == 3:\n        return \"impossible\"\n    if n_test == 4:\n        return \"impossible\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    probabilities = list(map(float, stdin.split()))\n    return str(min(t*t*m/r for t in range(1,n+1) if t*t*m/r>=r))\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    _r = r\n    tricks = []\n    for i in range(m):\n        t, p, d = map(float, stdin.split())\n        tricks.append((t, p, d))\n        _r -= t\n    tricks.sort()\n    tricks = list(zip(*tricks))\n    tricks = list(tricks[0])\n    tricks = list(map(int, tricks))\n    print(sum(tricks))\n    return stdout.strip()"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    data = [list(map(float, line.split())) for line in stdin.split('\\n') if line]\n    prices = sorted(data, key=lambda x: x[1])\n    total_time, start, tries = 0, 0, 0\n    for p, d, t in prices:\n        if start + t > p:\n            tries += 1\n            total_time += start + t - p\n        else:\n            tries += 1\n            total_time += start + t - p - 1\n        start = max(start, p + d)\n    return str(total_time)\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    tricks = sorted(stdin.splitlines(), key=lambda x: int(x[:x.find(\" \")]))\n    r, p = float(r), float(tricks[0][2])\n    count = 1\n    t, start_time = tricks[0]\n    for t, prob, d in tricks[1:]:\n        if prob < p:\n            count += 1\n            t, p = t, float(prob)\n        if float(t) >= start_time:\n            start_time = float(t)\n        else:\n            break\n    if count == m:\n        return \"{:.6f}\".format(start_time)\n    return \"{:.6f}\".format(start_time + (r - start_time) * (p - 1) / count)"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    ranges = sorted(map(int, stdin.split()))\n    assert ranges[0] == 0\n    assert ranges[-1] == n\n    assert 1 <= m <= 5\n    tricks = []\n    for i in range(1, n):\n        p, s, d = map(float, stdin.split())\n        if i >= r:\n            tricks.append((i, p, s, d))\n            ranges.remove(i)\n            ranges.remove(r)\n        else:\n            ranges.remove(i)\n    if m:\n        tricks.sort(key=lambda x: x[0], reverse=True)\n        return str(max(int(1.0 / tricks[m - 1][2] - tricks[m - 1][1]), int(1.0 / tricks[m - 1][2] - tricks[m - 1][1] * 2)))\n    else:\n        return str(max(int(1.0 / ranges[0] - ranges[0]), int(1.0 / ranges[0] - ranges[0] * 2)))\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n, r, m = int(stdin[0]), int(stdin[1]), int(stdin[2])\n    trick_prob = stdin[3:]\n    # need to set this up like this to deal with any number of tricks...\n    trick_prob = sorted(trick_prob, key=lambda x: int(x.split(' ')[0]))\n    # I'm going to change this to the a list of lists, and later convert back to a list of strings\n    trick_prob = [[i.split(' ')[0], float(i.split(' ')[1]), int(i.split(' ')[2])] for i in trick_prob]\n    # trick_prob = [[int(i.split(' ')[0]), float(i.split(' ')[1]), int(i.split(' ')[2])] for i in trick_prob]\n    # need to do this again after I convert to a list of strings\n    trick_prob = sorted(trick_prob, key=lambda x: int(x[0]))\n    start_time = n\n    steps = 0\n    probability = 0\n    tries = 0\n    while start_time > r:\n        for t, p, d in trick_prob:\n            if start_time >= t:\n                start_time -= t\n                probability += p\n                steps += d\n                if start_time >= r:\n                    return f\"{round(probability * 100, 2)}%\"\n                if probability >= 0.5:\n                    if tries == 0:\n                        tries = 0\n                    else:\n                        tries -= 1\n    if probability >= 0.5:\n        return f\"{round(probability * 100, 2)}%\"\n    return f\"{round(probability * 100, 2)}%\"\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    trick_time = 0\n    total = 0\n    while total < r:\n        trick = max(1, random.randint(1, n))\n        prob = 1\n        for _ in range(trick):\n            prob *= (0.5 + random.random())\n        total += trick_time + prob * (total - trick_time)\n        trick_time += prob * n\n    return str(total)\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, r, m = map(int, lines[0].split())\n    records = list()\n    for _ in range(m):\n        _, p, d = map(float, lines.pop(0).split())\n        records.append((int(p * 100), p, int(d)))\n    r = int(r)\n    n = int(n)\n    ranges = list()\n    for _ in range(n):\n        ranges.append(list())\n    for r in range(n, r):\n        ranges[r] = list(range(r - n, r))\n    records = sorted(records, key=lambda x: x[0])\n    t = 0\n    for p, _, d in records:\n        while t < r and t < p:\n            t += 1\n        while t > p:\n            t -= 1\n        ranges[t].append(d)\n    best = float(\"inf\")\n    for i in range(r):\n        best = min(best, sum(ranges[i]))\n    return str(best)"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    [n, r, m] = map(int, stdin.split())\n    return str(r - n)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = list(map(int, stdin.split()))\n    trick_probs = sorted(list(map(float, stdin.split())))\n    trick_counts = {}\n    trick_counts[0] = 1\n    trick_counts[1] = 1\n    total_counts = []\n    for prob in trick_probs:\n        if prob in trick_counts:\n            trick_counts[prob] += 1\n            total_counts.append(trick_counts[prob])\n        else:\n            trick_counts[prob] = 1\n            total_counts.append(trick_counts[prob])\n    total_counts = sorted(total_counts)\n    possible_trick_times = []\n    for i in range(n + 1):\n        if i in trick_counts:\n            possible_trick_times.append(i)\n    possible_trick_times.sort(reverse=True)\n    max_prob = max(trick_probs)\n    prob_cache = {}\n    def prob(t):\n        if t not in prob_cache:\n            if t == 0:\n                prob_cache[t] = max_prob / trick_counts[0]\n            else:\n                prob_cache[t] = max_prob / trick_counts[t]\n        return prob_cache[t]\n    def prob_fail(t):\n        if t in prob_cache:\n            return prob_cache[t]\n        else:\n            prob = prob_fail(t - 1)\n            if t in trick_counts:\n                prob = prob * (1 - prob) * trick_counts[t] / (total_counts[t] * total_counts[t - 1])\n            prob_cache[t] = prob\n            return prob_cache[t]\n    expected_time = 0\n    for t in possible_trick_times:\n        prob = prob_fail(t)\n        prob_total = 1\n        for i in range(t):\n            prob_total *= prob_fail(possible_trick_times[i])\n        expected_time += prob_total * (possible_trick_times[t] - t)\n    return expected_time"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    n, k = map(int, stdin.split())\n    seq = list(range(1, n-1))\n    def sort(seq):\n        for i in range(len(seq)-1):\n            for j in range(i+1, len(seq)):\n                if seq[i] == seq[j]:\n                    seq.remove(seq[i])\n                    break\n        return seq\n    seq = sort(seq)\n    return''.join(str(x) for x in seq[k-1:k])\n"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(i) for i in stdin.split())\n    flower_set = set()\n    k -= 1\n    while k >= 0:\n        flower = flower_set\n        flower_set = set()\n        i = 0\n        while i < n - 1:\n            flower_set.add(i)\n            i += n - 1 - i\n        flower_set = flower_set | flower\n        k -= 1\n    return flower_set"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n < 1:\n        return\n    if n % 2 == 0:\n        n += 1\n    return''.join(map(str, range(n - 1, 0, -1)))"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    arr = sorted(list(map(int, stdin.split())), reverse=True)\n    print(*arr[:k], sep=\" \")\n    return\n"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    _, n, k = stdin.split()\n    n = int(n)\n    k = int(k)\n    prev = 1\n    for i in range(n - 1):\n        prev = i * (n - 1) + (prev + i) % n\n        if prev % k == 0:\n            return str(i + 1) +'' + str(prev)"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    _, n, k = stdin.split('\\n')\n    n = int(n)\n    k = int(k)\n    flower = 1\n    flower = flower * (n - 1)\n    flower = flower + 1\n    flower = flower + (flower - 1)\n    flower = flower - k\n    flower = flower * (n - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower - (flower - 1)\n    flower = flower - 1\n    flower = flower"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    _, n, k = stdin.split()\n    n = int(n)\n    k = int(k)\n    numbers = list(range(1, n))\n    numbers = list(map(str, numbers))\n    numbers.sort()\n    numbers = \" \".join(numbers)\n    return numbers"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for i in range(n-1, 0, -1):\n        if count * i == k:\n            print(i-1)\n            return\n        count += 1\n    return print(n-1)\n\nsolution(input())\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().splitlines()\n\n    n = int(stdin[0])\n    k = int(stdin[1])\n\n    nums = sorted(list(range(n - 1)))\n    output = []\n\n    for i in range(n - 1):\n        if nums[i] == (n - 1) or nums[i] == 0:\n            break\n        else:\n            output.append(nums[i] + 1)\n            nums[i + 1:] = sorted(nums[i + 1:])\n\n    output.append(n - 1)\n    output.sort()\n\n    return str(output[k - 1])\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    print(solution_iter(adj, 0, n, float('inf')))\n\ndef"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = [[] for _ in range(n)]\n    for i in range(m):\n        x, y = map(int, stdin.split())\n        roads[x - 1].append(y - 1)\n        roads[y - 1].append(x - 1)\n\n    for i in range(n):\n        roads[i].sort()\n        roads[i] = tuple(roads[i])\n    roads.sort()\n    roads = tuple(roads)\n\n    for i in range(len(roads) - 2):\n        if roads[i] == roads[i + 1]:\n            roads = roads[:i] + roads[i + 2:]\n            break\n    return len(roads)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    roads = [[] for _ in range(n + 1)]\n    stations = set()\n\n    for _ in range(m):\n        u, v = map(int, stdin.strip().split())\n        roads[u].append(v)\n        stations.add(u)\n        stations.add(v)\n\n    stations = list(stations)\n\n    def dfs(current, path, paths):\n        if len(paths) == n:\n            paths.append(path)\n            return\n        for r in roads[current]:\n            if r not in path:\n                dfs(r, path + [r], paths)\n\n    def max_path(paths):\n        if not paths:\n            return 0\n        max_paths = 0\n        for path in paths:\n            if len(path) == len(stations):\n                max_paths = max(max_paths, len(path))\n        return max_paths\n\n    paths = []\n    dfs(1, [1], paths)\n    return str(max_path(paths))\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    nodes = [[] for _ in range(n)]\n    edges = [[] for _ in range(n)]\n    for u, v in map(int, stdin.split()):\n        nodes[u - 1].append(v)\n        nodes[v - 1].append(u)\n        edges[u - 1].append(v)\n        edges[v - 1].append(u)\n    cnt = 0\n    for i in range(n):\n        if len(nodes[i]) == 1:\n            cnt += 1\n    print(cnt)\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges[u - 1].append(v - 1)\n        edges[v - 1].append(u - 1)\n    q = collections.deque()\n    for i in range(n):\n        if len(edges[i]) == 0:\n            q.append(i)\n    dist = [-1] * n\n    dist[0] = 0\n    while q:\n        u = q.popleft()\n        for v in edges[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    longest = max([dist[i] for i in range(n)])\n    for i in range(n):\n        if dist[i] == longest:\n            return str(i + 1)"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = {(u, v): [] for u in range(n) for v in range(n) if u!= v}\n    stations = {i: [] for i in range(1, n + 1)}\n    for u, v in stdin.splitlines():\n        u, v = map(int, (u, v))\n        roads[(u - 1, v - 1)].append((u, v))\n        roads[(v - 1, u - 1)].append((v, u))\n        stations[u - 1].append((v, u))\n        stations[v - 1].append((u, v))\n    roads = {k: set(v) for k, v in roads.items()}\n    visited = set()\n    paths = [i for i in range(n)]\n    for u in range(n):\n        paths[u] = {u}\n    while len(paths[-1]) == 1:\n        paths.append({p for u, p in roads[paths[-1]] if p not in visited})\n        visited.update(paths[-1])\n    visited = {u for u, p in roads.items() if len(p) > 1}\n    remaining = {u for u in range(n) if u not in visited}\n    while len(remaining) > 1:\n        # print(remaining, paths, visited)\n        for u in remaining:\n            paths = [{p for u, p in roads[p] if p not in visited} for p in paths]\n        visited = {u for u, p in roads.items() if len(p) > 1}\n        remaining = {u for u in range(n) if u not in visited}\n    return paths[0]\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    stations = {i + 1 for i in range(n)}\n\n    graph = defaultdict(set)\n    for i in range(m):\n        u, v = map(int, input().split())\n        graph[u].add(v)\n        graph[v].add(u)\n        stations.discard(u)\n        stations.discard(v)\n    n = len(stations)\n\n    def dfs(u: int, path: list) -> int:\n        if len(path) > n:\n            return len(path)\n        if u == 1:\n            return max(path) + 1\n        for v in graph[u]:\n            if v in stations:\n                res = dfs(v, path + [v])\n                if res > 0:\n                    return res\n        return 0\n\n    res = 0\n    for v in stations:\n        res = max(res, dfs(v, [v]))\n    return str(res)\n\n\nprint(solution(input()))"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    road_graph = {i: [] for i in range(1, n+1)}\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        road_graph[a].append(b)\n        road_graph[b].append(a)\n\n    stations = set(range(1, n+1))\n    visited = {i: set() for i in range(1, n+1)}\n    stations_removed = {i: False for i in range(1, n+1)}\n\n    min_length = float('inf')\n    while stations:\n        new_stations = set()\n        for station in stations:\n            if station not in visited:\n                visited[station] = stations_removed[station] = True\n                for neighbor in road_graph[station]:\n                    new_stations.add(neighbor)\n                    if neighbor not in visited:\n                        visited[neighbor] = True\n        stations = new_stations\n        stations_removed = {i: False for i in stations_removed}\n        min_length = min(min_length, len(stations))\n    return str(min_length)\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    # if m == 0:\n    #     return '0'\n\n    roads = [[] for _ in range(n)]\n    stations = [i for i in range(1, n)]\n    for road in stdin.split():\n        u, v = map(int, road.split())\n        roads[u - 1].append(v)\n        roads[v - 1].append(u)\n\n    def dfs(road, length, stations, visited, temp):\n        if length == m:\n            return temp\n        for i in range(len(road)):\n            if not visited[i]:\n                visited[i] = True\n                temp.append(road[i])\n                curr = road[i]\n                for j in range(len(stations)):\n                    if stations[j] == curr:\n                        next_stations = stations.copy()\n                        next_stations.remove(curr)\n                        temp = dfs(roads[curr - 1], length + 1, next_stations, visited, temp)\n                visited[i] = False\n                temp.pop()\n        return temp\n\n    def solution(roads, stations, n):\n        visited = [False] * n\n        paths = []\n        temp = []\n        for i in range(len(stations)):\n            paths.append(dfs(roads, 1, stations, visited, temp))\n        # print(paths)\n        res = float('inf')\n        for path in paths:\n            length = 0\n            for i in range(len(path) - 1):\n                length += roads[path[i] - 1].index(path[i + 1]) + 1\n            res = min(res, length)\n        return res\n\n    return str(solution(roads, stations, n))\n\n\nstdin = \"7 6\"\nprint(solution(stdin))"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(vertex, visited, mst):\n        visited[vertex] = True\n        for adj in graph[vertex]:\n            if visited[adj] is False:\n                if adj in mst:\n                    return False\n                mst.append(adj)\n                if not dfs(adj, visited, mst):\n                    return False\n                mst.pop()\n        return True\n\n    n, m = map(int, stdin.split())\n    graph = {i: [] for i in range(1, n + 1)}\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    res = 0\n    visited = [False] * (n + 1)\n    mst = []\n    for i in range(1, n + 1):\n        if visited[i] is False:\n            mst.append(i)\n            if not dfs(i, visited, mst):\n                return \"0\"\n            mst.pop()\n            res += 1\n    return str(res)\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(float, stdin.split())\n    v, w = map(float, stdin.split())\n    return str(int(np.ceil(np.sqrt((x - 0) ** 2 + (y - 0) ** 2)) * 60) + (np.ceil(np.arctan((y - 0) / (x - 0)) * 60) if abs(x - 0) > 0 else 0) + (np.ceil(v * 60) if v < 10 else np.ceil(v * 60 * 60)) + (np.ceil(w * 60 * 60) if abs(w) > 0 else 0))"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    v, w = map(float, stdin.split())\n    t = v / w\n    return '%.5f' % t\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    v = float(input())\n    w = float(input())\n    return str(min(x * v * 2 + y * w * 2, (x + y) * w * 2, (x - y) * v * 2))\n\n\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(float, stdin.strip().split())\n    v = float(stdin.strip().split()[0])\n    w = float(stdin.strip().split()[1])\n    t = abs(x - y)\n    t = t / (v + w)\n    print(round(t, 3))\n    return str(round(t, 3))"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(float, stdin.strip().split())\n    v = float(stdin.strip().split()[0])\n    w = float(stdin.strip().split()[1])\n    d = abs(x - y)\n    return '{:.2f}'.format(d / (v * w))"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    x, y = map(int, stdin.split())\n    v, w = map(float, stdin.split())\n    time = (x*v*w) / (2*3.14159265)\n    return '%.3f' % time"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    v, w = map(float, stdin.strip().split())\n    h = 1000\n    t = 0\n    \n    v *= 1/3\n    w *= 1/2\n    \n    while ((h - (t/v))*(w/v) >= (t/w)):\n        t += (h/v)\n    \n    t += (h/w)\n    \n    return round(t, 3)"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, y = list(map(int, stdin.split()))\n    v, w = list(map(float, stdin.split()))\n    x1, y1 = x + (v * cos(w)), y + (v * sin(w))\n    x2, y2 = x + (v * cos(w + pi)), y + (v * sin(w + pi))\n    print((x2 - x1) * (y2 - y1))"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(float, stdin.split())\n    v, w = map(float, input().split())\n    t = 0\n    d = v / w\n    while x!= y:\n        if x > y:\n            t += (y - x) / (v / w)\n            y -= d\n        else:\n            t += (x - y) / (v / w)\n            x += d\n    return (\"{:.3f}\".format(t))\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.strip().split())\n    v, w = map(float, stdin.strip().split())\n    start_x, start_y = map(float, stdin.strip().split())\n    end_x, end_y = map(float, stdin.strip().split())\n    if x == start_x and y == start_y:\n        return 'inf'\n    start_flats = x, y\n    if x == end_x and y == end_y:\n        return 0\n    if start_flats == end_flats:\n        return 'inf'\n    min_turn = float('inf')\n    for i in range(2):\n        if i == 0:\n            x = start_x\n            y = start_y\n        else:\n            x = end_x\n            y = end_y\n        for j in range(2):\n            if j == 0:\n                v = -v\n                w = -w\n            else:\n                v = v\n                w = -w\n            x_dist = x - start_x\n            y_dist = y - start_y\n            min_dist = abs(x_dist) + abs(y_dist)\n            x_turn = (x_dist / v) * w\n            x_dist -= x_turn\n            x_turn = x_turn * w\n            y_turn = (y_dist / v) * w\n            y_dist -= y_turn\n            y_turn = y_turn * w\n            while (x, y)!= end_flats:\n                x += x_turn\n                y += y_turn\n                min_dist += abs(x) + abs(y)\n                if min_dist > 10.0:\n                    return 'inf'\n            if min_turn > min_dist:\n                min_turn = min_dist\n            x, y = x_dist, y_dist\n    return f\"{min_turn:.10f}\""
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n = int(input())\n    d = {}\n    for _ in range(n):\n        a, b = map(int, input().split())\n        if a in d:\n            d[a] += b\n        else:\n            d[a] = b\n        if b in d:\n            d[b] += a\n        else:\n            d[b] = a\n    ans = 0\n    for k, v in d.items():\n        ans += k*v\n    return str(ans)"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(min(sum([x[1] for x in enumerate(stdin.split())])//len(stdin.split()), int(stdin)))\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return 0\n    lst = list(map(int, stdin.split()))\n    lst = sorted(lst)\n    amount = 0\n    while len(lst) > 1:\n        A, B = lst.pop(0), lst.pop(0)\n        if A == 1:\n            amount += max(B, 0)\n            break\n        if A < 2:\n            amount += (B + amount) % 1000000007\n        else:\n            amount += max((B + amount) % 1000000007, 0)\n        amount = (amount + max(A * (B + amount) % 1000000007, 0)) % 1000000007\n    return amount\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = [int(x) for x in stdin.strip().split()]\n    print(min(a))\n    return(min(a))\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    curr_inhabitants = 0\n    debts = {}\n    for line in stdin.splitlines():\n        A, B = map(int, line.split())\n        debts[A] = max(0, B - curr_inhabitants)\n        curr_inhabitants += max(0, min(A, N) - 1)\n    \n    return str(sum(debts.values()))"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    debts = [[int(j) for j in stdin.split()] for i in range(N)]\n    debts.sort(key=lambda x: x[1])\n    print(debts)\n    res = 0\n    for i in range(len(debts)):\n        if debts[i][1] > res:\n            res = debts[i][1]\n    return str(res)"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = stdin.split()\n    return str(int(x) + int(y) - int(z))\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for i in range(n):\n        inp = list(map(int, stdin.split()))\n        to_give = inp[0]\n        amt = inp[1]\n        break\n    res = 0\n    while to_give > 0:\n        to_give -= amt\n        res += amt\n        amt += amt\n        if to_give < amt:\n            to_give = 0\n    return str(res)\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    # count debts for each person\n    all_debts = []\n    for _ in range(n):\n        debts = [int(i) for i in stdin.split()]\n        all_debts.append(debts)\n    all_debts = tuple(all_debts)\n    debts = list(sorted(all_debts, key=lambda x: x[1]))\n    # count debts to each person\n    debt_to_each = []\n    for i, debt in enumerate(all_debts):\n        debt_to_each.append(all_debts[i][1])\n    debt_to_each = sorted(debt_to_each)\n    # pay back debts\n    cnt = 1\n    total_debt = 0\n    while cnt < len(debt_to_each):\n        if debt_to_each[cnt] == debt_to_each[cnt - 1] + 1:\n            total_debt += debt_to_each[cnt]\n        else:\n            cnt = cnt - 1\n        cnt += 1\n    return total_debt\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    N = int(stdin.split()[0])\n    debts = list(map(int, stdin.split()[1:]))\n    debts = sorted(debts, key=lambda x: x[0])\n    total = 0\n    for i in range(N):\n        total += debts[i][1]\n    print(total)\n    return total\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n + 1)\n\n    def dfs(graph: list, visited: list, node: int, start: int) -> bool:\n        if node == start:\n            visited[node] = True\n            return True\n        if node not in graph:\n            return False\n        visited[node] = True\n        for c in graph[node]:\n            if not visited[c]:\n                if dfs(graph, visited, c, start):\n                    return True\n        visited[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        if not dfs(graph, visited, i, start=1):\n            return str(i)\n    return \"impossible\"\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    paths = []\n    for _ in range(m):\n        paths.append(list(map(int, stdin.split())))\n    \n    dp = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    dp[0][1] = 1\n    for path in paths:\n        for i in range(1,n+1):\n            for j in range(1,n+1):\n                if i == j:\n                    continue\n                dp[i][j] = max(dp[i][j], dp[i][path[1]] + dp[path[0]][j])\n    \n    return str(dp[1][2])"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    C1 = [list(map(int, stdin.split())) for _ in range(M)]\n\n    # set up dictionary of ids: [id1, id2]\n    # if any node in C1 has id in this set, then it's a ring\n    RING = set()\n    for c1 in C1:\n        RING.add(c1[0])\n        RING.add(c1[1])\n    \n    # create a graph and adjacency list\n    G = {}\n    adj = {}\n    for c1 in C1:\n        if c1[0] in adj.keys():\n            adj[c1[0]].append(c1[1])\n        else:\n            adj[c1[0]] = [c1[1]]\n        if c1[1] in adj.keys():\n            adj[c1[1]].append(c1[0])\n        else:\n            adj[c1[1]] = [c1[0]]\n    \n    # loop over all nodes and find the biggest ring\n    biggest = 0\n    for n in adj.keys():\n        if n in RING:\n            continue\n        paths = []\n        if len(adj[n]) == 1:\n            # path from n to n is a ring\n            paths = []\n        else:\n            paths.append([n])\n            paths.append(adj[n])\n        for path in paths:\n            # find the path which is the longest\n            for i in range(len(path)):\n                for j in range(i+1, len(path)):\n                    if path[i]!= path[j]:\n                        path_1 = path[i]\n                        path_2 = path[j]\n                        if path_1 in adj.keys() and path_2 in adj.keys():\n                            # if they're in the graph, add path from n to path[i] and path[j]\n                            path_1_adj = adj[path_1]\n                            path_2_adj = adj[path_2]\n                            if path_1_adj == path_2_adj:\n                                continue\n                            paths_1 = find_paths_in_graph(path_1_adj, path_2_adj, adj)\n                            if paths_1:\n                                paths_1 = list(map(lambda x: path_1+[x], paths_1))\n                                # paths_1 = [list(path_1+[p]) for p in paths_1]\n                                paths_2 = find_paths_in_graph(path_2_adj, path_1_adj, adj)\n                                if paths_2:\n                                    paths_2 = list(map(lambda x: x+path_2, paths_2))\n                                    paths_2 = [list(p) for p in paths_2]\n                                    # paths_2 = list(map(lambda x: path_2+[x], paths_2))\n                                    # paths_2 = list(map(lambda x: x+[p], paths_2))\n                                    paths_1.extend(paths_2)\n                                    paths.extend(paths_1)\n                                else:\n                                    paths.extend(paths_1)\n                            else:\n                                paths.extend(paths_1)\n        # find the longest path\n        longest = 0\n        for p in paths:\n            if len(p) > longest:\n                longest = len(p)\n        if longest > biggest:\n            biggest = longest\n    return str(biggest)\n    \ndef"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split()))\n    city_to_road = {}\n    for i in range(M):\n        city_a, city_b = list(map(int, stdin.split()))\n        if city_a not in city_to_road:\n            city_to_road[city_a] = {}\n        city_to_road[city_a][city_b] = True\n        if city_b not in city_to_road:\n            city_to_road[city_b] = {}\n        city_to_road[city_b][city_a] = True\n    is_valid = {i: True for i in range(2, N + 1)}\n    is_valid[1] = False\n    visited_cities = set()\n    longest_road = 0\n    while len(is_valid) > 0:\n        is_valid_copy = is_valid.copy()\n        while len(is_valid_copy) > 0:\n            curr = is_valid_copy.pop()\n            if curr in visited_cities:\n                continue\n            visited_cities.add(curr)\n            for next_city in city_to_road[curr]:\n                if next_city in is_valid_copy:\n                    is_valid[next_city] = False\n            if curr == 1 and is_valid[1]:\n                longest_road = max(longest_road, len(visited_cities) - 1)\n                break\n            for i in range(2, N + 1):\n                if i in is_valid and i in visited_cities:\n                    is_valid[i] = False\n        if longest_road == 0:\n            return -1\n        else:\n            longest_road -= 1\n    return longest_road"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin_nums = list(map(int, stdin.split()))\n    n, m = stdin_nums[:2]\n    cities = list(map(int, stdin_nums[2:]))\n    ring_max_path = 1\n    all_rings = []\n    all_cities = set()\n    for i in range(n):\n        all_cities.add(i+1)\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                for k in range(n):\n                    if i!= k and j!= k:\n                        if (i, j, k) not in all_cities and (k, i, j) not in all_cities:\n                            all_cities.add((i, j, k))\n                            all_cities.add((k, i, j))\n                            all_rings.append((i, j, k))\n    all_rings.sort(key=lambda x: (x[0], x[1], x[2]))\n    all_rings_max_path = 1\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i!= j and j!= k and i!= k:\n                    if (i, j, k) not in all_cities and (k, i, j) not in all_cities:\n                        all_cities.add((i, j, k))\n                        all_cities.add((k, i, j))\n                        all_rings_max_path = max(all_rings_max_path, len(all_rings))\n                        all_rings.append((i, j, k))\n                        all_rings.append((k, i, j))\n    for i in range(n):\n        all_cities.add(i+1)\n    all_cities_max_path = max(all_cities)\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                for k in range(n):\n                    if i!= k and j!= k:\n                        if (i, j, k) not in all_cities and (k, i, j) not in all_cities:\n                            all_cities.add((i, j, k))\n                            all_cities.add((k, i, j))\n                            all_rings_max_path = max(all_rings_max_path, len(all_rings))\n                            all_rings.append((i, j, k))\n                            all_rings.append((k, i, j))\n    return all_rings_max_path + all_cities_max_path\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        a, b = a - 1, b - 1\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = set()\n    visited.add(1)\n    answer = 1\n    bfs_queue = [1]\n    while bfs_queue:\n        current_node = bfs_queue.pop()\n        for child in graph[current_node]:\n            if child not in visited:\n                visited.add(child)\n                bfs_queue.append(child)\n        if len(visited) > answer:\n            answer = len(visited)\n    return str(answer)\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    roads = []\n    cities = []\n    for i in range(M):\n        a, b = map(int, stdin.split())\n        roads.append((a, b))\n        cities.append(a)\n        cities.append(b)\n    \n    def get_path(cities, roads):\n        cities.sort()\n        N = len(cities)\n        paths = [[] for _ in range(N)]\n        for road in roads:\n            a, b = road\n            paths[cities.index(a)].append(b)\n            paths[cities.index(b)].append(a)\n        return paths\n    \n    def is_simple_path(path):\n        cities = set(cities)\n        for road in roads:\n            a, b = road\n            if b in cities and a in cities:\n                return False\n        return True\n    \n    def get_length(paths):\n        lengths = []\n        for path in paths:\n            lengths.append(len(path))\n        return max(lengths)\n    \n    paths = get_path(cities, roads)\n    length = get_length(paths)\n    while not is_simple_path(paths):\n        length = get_length(paths)\n        new_paths = []\n        for i in range(len(paths)):\n            a, b = paths[i]\n            paths[i] = []\n            for road in roads:\n                a, b = road\n                if b == a:\n                    continue\n                if b in a and b not in a:\n                    paths[i].append(b)\n                elif a in b and a not in b:\n                    paths[i].append(a)\n            new_paths.append(paths[i])\n        paths = new_paths\n    return length"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    graph = [[] for _ in range(N)]\n    for i in range(M):\n        a, b = map(int, stdin.split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n    routes = [[1]]\n    for i in range(N):\n        routes.append([1])\n    while len(routes[-1]) > 1:\n        newRoutes = []\n        for route in routes[-1]:\n            for road in graph[route[-1]]:\n                if road not in route:\n                    newRoute = route + [road]\n                    newRoutes.append(newRoute)\n        routes = newRoutes\n    return str(len(routes))\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    edges = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v = map(int, stdin.split())\n        edges[u - 1].append(v - 1)\n        edges[v - 1].append(u - 1)\n    cities = [0]\n    while True:\n        cities_to_visit = []\n        for city in cities:\n            for node in edges[city]:\n                if node not in cities:\n                    cities_to_visit.append(node)\n        cities = cities_to_visit\n        if not cities:\n            break\n    return len(cities) - 1\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if N < 2 or M < 2:\n        raise Exception(\"Invalid input.\")\n    paths = []\n    for i in range(M):\n        paths.append(list(map(int, stdin.split())))\n    paths.sort()\n    count = 0\n    for i in range(len(paths) - 1):\n        if paths[i][1] < paths[i + 1][0]:\n            paths[i], paths[i + 1] = paths[i + 1], paths[i]\n        if paths[i][0] == paths[i][1]:\n            count = max(count, 1)\n    return str(count)\n"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string and returns a float.\n    \"\"\"\n    n = int(stdin)\n    m = int(stdin)\n    inlist = stdin.strip().split()\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    for i in range(m):\n        cur, nei = inlist[i*2], inlist[i*2+1]\n        cur = int(cur)\n        nei = [int(i) for i in nei.split()]\n        graph[cur].extend(nei)\n        graph[nei[0]].extend(nei)\n    res = 1\n    for i in range(n):\n        res *= 2\n        res += len(graph[i])\n    return str(res)\n\nprint(solution(input()))"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def expand(x: int) -> list[int]:\n        if x == 0:\n            return list(range(1, n + 1))\n        if x < 0:\n            return list(range(1, n + 1))\n        if x > n:\n            return list(range(1, n + 1))\n        if x <= n // 2:\n            return list(range(x + 1, n + 1))\n        else:\n            return list(range(x - n + 1, n + 1))\n\n    n = int(stdin)\n    a = sorted(list(map(int, stdin.split())))\n    n -= 1\n    edges = {}\n    for ai, bi in zip(a, a[1:]):\n        if ai!= bi:\n            if (ai, bi) not in edges:\n                edges[(ai, bi)] = 0\n            edges[(ai, bi)] += 1\n\n    res = 1\n    for x in expand(n):\n        res *= (1 - min(edges.get((x, y), 0) / n for y in expand(x)))\n    return str(res)\n"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque\n    n, L = stdin.split()\n    n = int(n)\n    nodes = []\n    for _ in range(n):\n        nodes.append([])\n    for _ in range(n):\n        nodes[_] = list(map(int, stdin.split()))\n    from collections import defaultdict\n    distances = defaultdict(int)\n    q = deque()\n    q.append(0)\n    distances[0] = 0\n    while q:\n        cur = q.popleft()\n        if cur == n - 1:\n            return distances[n - 1]\n        for i in range(L):\n            if nodes[cur][i] == 1:\n                if distances[cur] + 1 < distances[i]:\n                    distances[i] = distances[cur] + 1\n                    q.append(i)\n                elif distances[cur] + 1 == distances[i]:\n                    if nodes[cur][i] == 0:\n                        q.append(i)\n    return distances[-1]\n\nsolution('5 6 2')\n"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        graph[i] = list(map(int, stdin.split()))\n\n    chances = 0\n    for i in range(n):\n        visited = set()\n        queue = collections.deque([i])\n        while queue:\n            node = queue.pop()\n            if node in visited:\n                continue\n            visited.add(node)\n            for j in range(n):\n                if graph[node][j] == 1 and j not in visited:\n                    queue.append(j)\n        if len(visited) > 1:\n            chances += 1\n    return str(chances)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    INF = 2**64\n    N = int(stdin)\n    rooms = {i: INF for i in range(N)}\n    visited = set()\n\n    for _ in range(N):\n        room, *neighbours = map(int, stdin.readline().split())\n        visited.add(room)\n        rooms[room] = min(rooms[room], *neighbours)\n        for neighbour in neighbours:\n            visited.add(neighbour)\n            rooms[neighbour] = min(rooms[neighbour], room)\n\n    \n    #O(N) time\n    #O(N) space\n    def count_possible_success(rooms):\n        count = 0\n        for room,_ in rooms.items():\n            count += (1 if room not in visited else 0)\n        return count/N\n\n    for i in range(N):\n        if rooms[i] == INF:\n            rooms[i] = count_possible_success(rooms)\n\n    #O(N) time\n    #O(N) space\n    def find_solution(rooms):\n        max_val = max(rooms.values())\n        rooms = {k: v for k, v in rooms.items() if v == max_val}\n        res = []\n        while len(rooms) > 0:\n            res.append(list(rooms.keys())[0])\n            del rooms[list(rooms.keys())[0]]\n            if len(rooms) == 0:\n                break\n            rooms = {k: v for k, v in rooms.items() if v == max_val}\n        return res\n    \n    #O(N) time\n    #O(N) space\n    def get_solution(rooms):\n        return 1 if max(rooms.values()) == 0 else 0\n    \n    return str(get_solution(rooms))\n"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, L = (int(x) for x in stdin.split())\n    data = sorted([int(x) for x in stdin.split()])\n    walk = {x: [] for x in range(N)}\n    for x in data:\n        walk[x] = data\n    print(walk)\n    for i in range(N - 1):\n        walk[i + 1].extend(walk[i])\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print(walk)\n    print("
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # the number of rooms\n    n_rooms = int(stdin)\n\n    # the number of nodes\n    n_nodes = n_rooms + 1\n\n    # the number of edges\n    n_edges = n_nodes * (n_nodes - 1) // 2\n\n    # the list of nodes\n    nodes = [0] + list(range(1, n_nodes))\n\n    # the dictionary of edges, with the nodes as keys\n    edges = {node: [] for node in nodes}\n\n    # fill the dictionary of edges\n    for line in stdin.strip().splitlines():\n        x, y, *rest = list(map(int, line.split()))\n        edges[x].append(y)\n        edges[y].append(x)\n\n    # the list of nodes with their connected nodes\n    connections = []\n    for node in nodes:\n        connections.append((node, len(edges[node])))\n\n    # sort them in descending order\n    connections = sorted(connections, key=lambda tup: tup[1], reverse=True)\n\n    # the list of nodes that are connected to the sentry node\n    connections_sentry = []\n    for node in connections:\n        if node[0] == 1:\n            connections_sentry.append(node[0])\n\n    # the dictionary of connected nodes\n    connected = {node: [] for node in nodes}\n\n    # fill the dictionary of connected nodes\n    for connection in connections:\n        connected[connection[0]].append(connection[1])\n        connected[connection[1]].append(connection[0])\n\n    # the path to the sentry node\n    path = []\n    visited = set()\n\n    # start the recursion\n    visit_node(0, 1, connected, connections_sentry, path, visited)\n\n    # sum up all the paths\n    return sum(map(lambda tup: tup[0] / tup[1], path))\n\n\ndef"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    rooms = [[] for _ in range(int(stdin))]\n    for i in range(int(stdin)):\n        rooms[i] = list(map(int, stdin.split()))\n    # print(rooms)\n    # print(rooms[0])\n    # print(rooms[1])\n    # print(rooms[2])\n    # print(rooms[3])\n    # print(rooms[4])\n    # print(rooms[5])\n    # print(rooms[6])\n    # print(rooms[7])\n    # print(rooms[8])\n    # print(rooms[9])\n    # print(rooms[10])\n    # print(rooms[11])\n    # print(rooms[12])\n    # print(rooms[13])\n    # print(rooms[14])\n    # print(rooms[15])\n    # print(rooms[16])\n    # print(rooms[17])\n    # print(rooms[18])\n    # print(rooms[19])\n    # print(rooms[20])\n    # print(rooms[21])\n    # print(rooms[22])\n    # print(rooms[23])\n    # print(rooms[24])\n    # print(rooms[25])\n    # print(rooms[26])\n    # print(rooms[27])\n    # print(rooms[28])\n    # print(rooms[29])\n    # print(rooms[30])\n    # print(rooms[31])\n    # print(rooms[32])\n    # print(rooms[33])\n    # print(rooms[34])\n    # print(rooms[35])\n    # print(rooms[36])\n    # print(rooms[37])\n    # print(rooms[38])\n    # print(rooms[39])\n    # print(rooms[40])\n    # print(rooms[41])\n    # print(rooms[42])\n    # print(rooms[43])\n    # print(rooms[44])\n    # print(rooms[45])\n    # print(rooms[46])\n    # print(rooms[47])\n    # print(rooms[48])\n    # print(rooms[49])\n    # print(rooms[50])\n    # print(rooms[51])\n    # print(rooms[52])\n    # print(rooms[53])\n    # print(rooms[54])\n    # print(rooms[55])\n    # print(rooms[56])\n    # print(rooms[57])\n    # print(rooms[58])\n    # print(rooms[59])\n    # print(rooms[60])\n    # print(rooms[61])\n    # print(rooms[62])\n    # print(rooms[63])\n    # print(rooms[64])\n    # print(rooms[65])\n    # print(rooms[66])\n    # print(rooms[67])\n    # print(rooms[68])\n    # print(rooms[69])\n    # print(rooms[70])\n    # print(rooms[71])\n    # print(rooms[72])\n    # print(rooms[73])\n    # print(rooms[74])\n    # print(rooms[75])\n    # print(rooms[76])\n    # print(rooms[77])\n    # print(rooms[78])\n    # print(rooms[79])\n    # print(rooms[80])\n    # print(rooms[81])\n    # print(rooms[82])\n    # print(rooms[83])\n    # print(rooms[84])\n    # print(rooms[85])\n    # print(rooms[86])\n    # print(rooms[87])\n    # print(rooms[88])\n    # print(rooms[89])\n    # print(rooms[90])\n    # print(rooms[91])\n    # print(rooms[92])\n    # print(rooms[93])\n    # print(rooms[94])\n    # print(rooms[95])\n    # print(rooms[96])\n    # print(rooms[97])\n    # print(rooms[98])\n    # print(rooms[99])\n    # print(rooms[100])\n    # print(rooms[101])\n    # print(rooms[102])\n    # print(rooms[103])\n    # print(rooms[104])\n    # print(rooms[105])\n    # print(rooms[106])\n    # print(rooms[107])\n    # print(rooms[108])\n    # print(rooms[109])\n    # print(rooms[110])\n    # print(rooms[111])\n    # print(rooms[112])\n    # print(rooms[113])\n    # print(rooms[114])\n    # print(rooms[115])\n    # print(rooms[116])\n    # print(rooms[117])\n    # print(rooms[118])\n    # print(rooms[119])\n    # print(rooms[120])\n    # print(rooms[121])\n    # print(rooms[122])\n    # print(rooms[123])\n    # print(rooms[124])\n    # print(rooms[125])\n    # print(rooms[126])\n    # print(rooms[127])\n    # print(rooms[128])\n    # print(rooms[129])\n    # print(rooms[130])\n    # print(rooms[131])\n    # print(rooms[132])\n    # print(rooms[133])\n    # print(rooms[134])\n    # print(rooms[135])\n    # print(rooms[136])\n    # print(rooms[137])\n    # print(rooms[138])\n    # print(rooms[139])\n    # print(rooms[140])\n    # print(rooms[141])\n    # print(rooms"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    nodes = set(range(1, N + 1))\n    graph = {}\n    for line in stdin.strip().splitlines():\n        if line:\n            u, *edges = map(int, line.split())\n            nodes.difference_update(edges)\n            for v in edges:\n                if v in graph:\n                    graph[v].add(u)\n                else:\n                    graph[v] = {u}\n    L = int(stdin.strip().split()[-1])\n    walk = tuple(map(int, stdin.strip().split()[-L:]))\n\n    walk = (walk[0], ) + tuple(walk) + (walk[-1], )\n    N = len(walk)\n\n    def is_in(u, v):\n        return u in graph[v] and v in graph[u]\n\n    def dfs(i):\n        if i == N - 1:\n            return 1\n        v = walk[i]\n        t = 1\n        for i in range(1, N + 1):\n            if is_in(v, i):\n                t += dfs(i)\n        return t / N\n\n    res = 0.\n    for u in walk:\n        if u in graph:\n            res += dfs(0)\n    return f\"{res:.6f}\""
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, L = list(map(int, stdin.split()))\n    G = Graph(N)\n    for i in range(L):\n        u, v = list(map(int, stdin.split()))\n        G.add_edge(u - 1, v - 1)\n    return str(answer(G))\n\nfrom collections import defaultdict\n\ndef"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    planks = list(map(int, stdin.split()))\n\n    # Initialize blank dictionary and max_len variable\n    planks_dict = dict()\n    max_len = max(planks)\n\n    # Loop through the input array\n    for plank in range(1, max_len + 1):\n        # Initialize blank dictionary\n        planks_dict[plank] = dict()\n\n        # Loop through the input array\n        for color in range(1, plank + 1):\n            planks_dict[plank][color] = 0\n\n    # Set default value\n    default = 0\n\n    # Loop through the input array\n    for color in range(1, max_len + 1):\n        # Check if the plank has a color\n        if color in plansks:\n            # Get the length of the plank\n            length = plansks.count(color)\n            planks_dict[length][color] = 1\n            planks_dict[length] = dict(sorted(planks_dict[length].items()))\n        else:\n            # If the color is not found, add a default\n            planks_dict[default] = dict(sorted(planks_dict[default].items()))\n\n    # Sort the dictionary\n    planks_dict = dict(sorted(planks_dict.items()))\n\n    # Create an empty set and a dictionary\n    set_ = set()\n    dict_ = dict()\n\n    # Loop through the input array\n    for color in range(1, max_len + 1):\n        # Check if the color is in the dictionary\n        if color in plansks_dict:\n            # Create the set\n            set_ = set_ | plansks_dict[color]\n        else:\n            # If the color is not found, add a default\n            set_ = set_ | plansks_dict[default]\n\n        # Sort the set\n        set_ = set(sorted(set_))\n\n        # Loop through the input array\n        for plank in range(1, max_len + 1):\n            # Check if the plank has a color\n            if plank in plansks_dict:\n                # Check if the color is in the dictionary\n                if color in plansks_dict[plank]:\n                    # Add the plank to the dictionary\n                    dict_[plank] = color\n                else:\n                    # If the color is not found, add a default\n                    dict_[plank] = default\n            else:\n                # If the color is not found, add a default\n                dict_[plank] = default\n\n        # Sort the dictionary\n        dict_ = dict(sorted(dict_.items()))\n\n        # Loop through the input array\n        for color in range(1, max_len + 1):\n            # Check if the color is in the dictionary\n            if color in dict_:\n                # Check if the color is in the set\n                if color in set_:\n                    # Check if the color is in the dictionary\n                    if color in dict_[color]:\n                        # Add the color to the set\n                        set_.add(dict_[color][0])\n                    else:\n                        # If the color is not found, add a default\n                        set_.add(dict_[color])\n                else:\n                    # If the color is not found, add a default\n                    set_.add(dict_[color])\n            else:\n                # If the color is not found, add a default\n                set_.add(default)\n\n        # Sort the set\n        set_ = set(sorted(set_))\n\n        # Print set\n        print(set_)\n\n        # Reset set and dictionary\n        set_ = set()\n        dict_ = dict()\n\n    # Return a string containing all the instructions\n    return''.join(map(str, sorted(set_)))\n"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    N = int(stdin.pop(0))\n    tape = stdin.pop(0).split(' ')\n    new_tape = {}\n    for x, y in enumerate(tape):\n        new_tape[x] = int(y)\n\n    sorted_tape = sorted(new_tape.items(), key=lambda x: x[1], reverse=True)\n\n    plank_length = int(N / 2)\n    planks = [0 for x in range(plank_length)]\n\n    for i in range(len(sorted_tape)):\n        plank_number = 1\n        plank_location = sorted_tape[i][0]\n        while len(planks) > 0 and sorted_tape[i][1] <= sorted_tape[len(planks) - 1][1]:\n            planks[plank_location - 1] = plank_number\n            plank_location = sorted_tape[len(planks) - 1][0]\n            plank_number = plank_number + 1\n            if plank_number > plank_length:\n                plank_number = plank_number % plank_length\n                break\n        planks.append(plank_number)\n\n    planks.sort()\n\n    if len(planks)!= len(sorted_tape):\n        return 'IMPOSSIBLE'\n\n    output = ''\n    for i in range(len(planks)):\n        if i!= len(planks) - 1:\n            output += str(planks[i]) +''\n        else:\n            output += str(planks[i])\n    return output\n"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # n = 6\n    # colors = list(map(int, stdin.split()))\n    colors = [1, 2, 1, 2, 3, 3, 2, 1]\n    return str(solve(n, colors))\n\n\ndef"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    instructions = stdin.strip().split('\\n')\n    return 'IMPOSSIBLE' if all([len(i) < 4 for i in instructions]) else '\\n'.join([str(len(i)) +'' +''.join(i) for i in itertools.product(*[range(1, int(i) + 1) for i in instructions])])\nprint(solution(input()))\n"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    stdin = \"6\\n1 2 3 3 2 1\"\n    '''\n    # Your code here\n    num = int(stdin.strip())\n    res = []\n    colors = []\n    for _ in range(num):\n        a, b = map(int, stdin.strip().split())\n        if len(colors) == 0:\n            colors.append(a)\n            colors.append(b)\n        else:\n            if a in colors:\n                i = colors.index(a)\n                colors.insert(i+1, b)\n            else:\n                colors.append(b)\n    for _ in range(len(colors)):\n        res.append(str(colors.pop()) + \" \" + str(colors.pop()) + \" \" + str(colors.pop()))\n    return \"\\n\".join(res)"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def cut(x: int, y: int, z: int) -> None:\n        print(x, y, z)\n        f.write(str(x) + '\\n')\n        f.write(str(y) + '\\n')\n        f.write(str(z) + '\\n')\n        plank.append((x, y, z))\n        # for k, (x, y, z) in enumerate(plank):\n        #     print(k, x, y, z)\n        # print('\\n')\n\n    plank = []\n    f = open(\"out.txt\", \"w\")\n    N = int(stdin.readline().strip())\n    for i in range(N):\n        x, y, z = map(int, stdin.readline().strip().split())\n        cut(x, y, z)\n    # print(plank)\n    plank.sort(key=lambda x: x[0])\n    # print(plank)\n    for i in range(len(plank)):\n        print(plank[i][0], plank[i][1], plank[i][2])\n        f.write(str(plank[i][0]) + '\\n')\n        f.write(str(plank[i][1]) + '\\n')\n        f.write(str(plank[i][2]) + '\\n')\n    f.close()\n    # print(plank)\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    ranges = []\n    for i in range(n):\n        ranges.append(stdin.split()[i])\n\n    def count_range(start, end, colors):\n        cnt = 0\n        for c in colors:\n            if c == start or c == end:\n                cnt += 1\n        return cnt\n\n    def check(first, second):\n        color = True\n        for i in range(len(first)):\n            if first[i]!= second[i]:\n                color = False\n                break\n        return color\n\n    min_range = min(ranges)\n    max_range = max(ranges)\n    if check(ranges, min_range):\n        return \"IMPOSSIBLE\"\n    if check(ranges, max_range):\n        return \"IMPOSSIBLE\"\n    if min_range == max_range:\n        return min_range\n    ranges = sorted(ranges, key=lambda x: int(x[0]))\n    p = 1\n    q = 0\n    for i in range(len(ranges)):\n        if int(ranges[i][0]) <= int(min_range):\n            p += 1\n        else:\n            break\n    for i in range(len(ranges)):\n        if int(ranges[i][1]) >= int(max_range):\n            q += 1\n        else:\n            break\n    if p > q:\n        return min_range\n    if p < q:\n        return max_range\n\n    ranges = sorted(ranges, key=lambda x: int(x[0]), reverse=True)\n    res = \"\"\n    for i in range(len(ranges)):\n        if i == 0:\n            res += \"1 \" + ranges[i][1]\n        else:\n            res += \"2 \" + ranges[i][1]\n    return res\n"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    planks = stdin.strip().split()\n    planks_in = []\n    for i in range(1, n + 1):\n        planks_in.append([int(plank) for plank in stdin.strip().split()[i - 1::2]])\n    result = 'IMPOSSIBLE'\n    for color in range(1, n + 1):\n        planks_in.sort()\n        for i in range(n):\n            if i == 0:\n                if color in [planks_in[i][0],planks_in[i][1]]:\n                    continue\n                else:\n                    result = str(i + 1) +'' + str(i + 1) +'' + str(planks_in[i][0])\n            else:\n                if color in [planks_in[i][0],planks_in[i][1]]:\n                    continue\n                else:\n                    result = str(i + 1) +'' + str(i + 1) +'' + str(planks_in[i][0]) +'' + str(i + 1) +'' + str(planks_in[i][1])\n        break\n    return result\nprint(solution(input()))\n"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    tape = [int(i) for i in stdin[0].split(\" \")]\n    answer = 0\n    answer = helper(tape, answer)\n    if answer == \"IMPOSSIBLE\":\n        return \"IMPOSSIBLE\"\n    else:\n        return answer\n\ndef"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    results = []\n    for i in range(N):\n        results.append(i)\n    while len(results) > 1:\n        for i in range(len(results)-1):\n            if results[i] < results[i+1]:\n                result = results[i+1]\n                results = results[:i+1] + results[i+2:]\n                results = results[:i] + [result] + results[i:]\n                break\n    return''.join(map(str, results))"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    scores = []\n    for i in range(n):\n        scores.append([int(i) for i in stdin.split()[i + 1: i + 1 + n]])\n    def winsort(arr):\n        for i in range(1, len(arr)):\n            for j in range(i):\n                if arr[j] < arr[i]:\n                    arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\n    scores = winsort(scores)\n    return''.join(str(s) for s in scores)\n"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    sequences = []\n    for _ in range(N):\n        sequences.append(stdin.split())\n    return sum([len(sequence) for sequence in sequences])\n"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    lines = []\n    for _ in range(N):\n        lines.append(list(map(int, stdin.split())))\n    best = 0\n    for l in range(2, N + 1):\n        for r in range(0, N):\n            for j in range(r + 1, N):\n                if r == 0:\n                    current = 0\n                else:\n                    current = lines[r - 1][-1]\n                next = lines[j][0]\n                # print(current, next)\n                if current > next:\n                    break\n                s = current + next\n                # print(r, j, lines[r], lines[j])\n                # print(lines[r][0], lines[j][-1])\n                if s > best:\n                    best = s\n    return str(best)\n\nsolution(\"2 2 1 1\")\nsolution(\"2 1 2\")\nsolution(\"3 5 10 20 30 40 50\")\n"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    for line in stdin.splitlines():\n        if line[0] == \"2\":\n            return line[1:]\n        N = int(line[0])\n        strs = line[1:].split()\n        res = []\n        for i in range(N):\n            length = int(strs[i])\n            seq = strs[i+1:i+1+length]\n            res.append(\" \".join(seq))\n        print(\" \".join(res))"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    sequences = []\n    for i in range(N):\n        N_seq = list(map(int, stdin.split()))\n        sequences.append(N_seq)\n\n    # Sort the sequences by length in descending order\n    sorted_seq = sorted(sequences, key=len, reverse=True)\n    best_sequence = []\n    total_sum = 0\n    # Find the best sequence\n    for sequence in sorted_seq:\n        count = 0\n        for value in sequence:\n            if value in best_sequence:\n                count += 1\n            else:\n                break\n        if count == len(sequence):\n            best_sequence = sequence\n            break\n    # Concatenate the sequence into one string\n    for i in range(len(best_sequence)):\n        total_sum += best_sequence[i]\n    return str(total_sum)"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, *sequence = map(int, stdin.split())\n    sequence = list(map(int, sequence))\n    sequence.sort()\n    for _ in range(N):\n        sequence.sort()\n    sequence = list(map(str, sequence))\n    return \" \".join(sequence)\nprint(solution(input()))\n"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = {i: 0 for i in range(1, 1000001)}\n    for _ in range(n):\n        sequence[int(stdin.split()[0])] += 1\n    max_ = 0\n    best = []\n    for key, val in sequence.items():\n        if val > max_:\n            max_ = val\n            best = []\n        if val == max_:\n            best.append(key)\n    best.sort()\n    return str(best[0]) + \" \" + str(best[1])\n"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split())\n    a = [int(i) for i in stdin.split()]\n    a.sort()\n    best = a\n    for i in range(N - 1):\n        best.pop(0)\n    while (max(best) - min(best)) > 1:\n        best = [max(best) - 1, max(best) - 2, max(best) - 3]\n    return''.join([str(i) for i in best])"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    sequences = [[int(l) for l in stdin.split()[i].split()] for i in range(1, N + 1)]\n    best_seq = []\n\n    for seq in sequences:\n        # Get the sums of the seq\n        seq_sum = sum(seq)\n\n        # Keep track of the best seq\n        best_seq = seq if best_seq is None or seq_sum < sum(best_seq) else best_seq\n\n    # Create the best sequence\n    best_seq = str(best_seq[0]) + \" \" + str(best_seq[1])\n    for i in range(2, len(best_seq)):\n        best_seq = str(best_seq[0]) + \" \" + str(best_seq[1]) + \" \" + str(best_seq[2]) + \" \" + str(best_seq[3])\n        best_seq = best_seq.split()\n    best_seq = \" \".join(best_seq)\n    return best_seq\n"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *data = stdin.strip().split()\n    black = {\n        'A': 0,\n        'B': 0,\n        'C': 0\n    }\n    for line in data:\n        suspect, _, reply = line.split()\n        black[suspect] = int(reply)\n    return f'{sum(black.values())}'\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Instead of using a set, we can use a dict and change the keys\n    count = 0\n    d = {}\n    for line in stdin.splitlines():\n        a, b, c = line.split()\n        if a not in d:\n            d[a] = 0\n        if b not in d:\n            d[b] = 0\n        if c not in d:\n            d[c] = 0\n        d[a] += 1\n        d[b] += 1\n        d[c] += 1\n\n    def all_equal(lst):\n        return len(set(lst)) == 1\n    def set_and_all_equal(lst):\n        return len(set(lst)) == 1 and all_equal(lst)\n    for k, v in d.items():\n        if v == 3:\n            count += 1\n    if count > 0 and set_and_all_equal(['A', 'B', 'C']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['B', 'C', 'D']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['C', 'D', 'E']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['D', 'E', 'F']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['E', 'F', 'G']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['F', 'G', 'H']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['G', 'H', 'I']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['H', 'I', 'J']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['I', 'J', 'K']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['J', 'K', 'L']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['K', 'L', 'M']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['L', 'M', 'N']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['M', 'N', 'O']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['N', 'O', 'P']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['O', 'P', 'Q']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['P', 'Q', 'R']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['Q', 'R', 'S']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['R', 'S', 'T']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['S', 'T', 'U']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['T', 'U', 'V']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['U', 'V', 'W']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['V', 'W', 'X']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['W', 'X', 'Y']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['X', 'Y', 'Z']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['Y', 'Z', 'AA']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['Z', 'AA', 'BB']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['AA', 'BB', 'CC']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['BB', 'CC', 'DD']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['CC', 'DD', 'EE']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['DD', 'EE', 'FF']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['EE', 'FF', 'GG']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['FF', 'GG', 'HH']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['GG', 'HH', 'II']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['HH', 'II', 'JJ']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['II', 'JJ', 'KK']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['JJ', 'KK', 'LL']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['KK', 'LL', 'MM']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['LL', 'MM', 'NN']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['MM', 'NN', 'OO']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['NN', 'OO', 'PP']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['OO', 'PP', 'QQ']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['PP', 'QQ', 'RR']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['QQ', 'RR', 'SS']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['RR', 'SS', 'TT']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['SS', 'TT', 'UU']):\n        count -= 1\n    if count > 0 and set_and_all_equal(['TT', 'UU', 'VV']):\n        count -= 1"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... AB 1 1\n   ... AC 2 1\n   ... BC 2 1\n   ... ''')\n    '2600'\n    >>> solution('''\n   ... AB 1 1\n   ... AC 2 2\n   ... AC 2 1\n   ... AC 2 3\n   ... ''')\n    '2300'\n    \"\"\"\n    print(stdin)\n    n = int(stdin)\n    print(n)\n    suspects = set()\n    s = set()\n    for i in range(n):\n        s1, s2, r = stdin.split()\n        s1 = int(s1)\n        s2 = int(s2)\n        r = int(r)\n        if s1 == 1:\n            suspects.add(s2)\n        if s2 == 1:\n            suspects.add(s1)\n        s.add((s1, s2))\n        s.add((s2, s1))\n    print(s)\n    print(len(s))\n    return str(len(s))\n"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    suspect_set = set()\n    for line in stdin.strip().splitlines():\n        suspect_set.add(line.split()[1])\n    suspect_set.remove(line.split()[1])\n    suspect_set.remove(line.split()[0])\n    return str(len(suspect_set))"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    circle = []\n    for i in range(n):\n        a, b, c = stdin.split()\n        if a == \"AB\":\n            circle.append(b)\n        if a == \"AC\":\n            circle.append(c)\n        if a == \"BC\":\n            circle.append(b)\n            circle.append(c)\n    return str(len(set(circle)))\n"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return answer\n    stdin = stdin.split('\\n')\n    res = 0\n    while stdin:\n        s1, s2, s3 = stdin.pop(0).split(' ')\n        if s2 == '1':\n            res += 1\n        elif s1 == '1':\n            res -= 1\n    return str(res)"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    result = 0\n    for _ in range(int(stdin)):\n        x, y, z = stdin.split()\n        x = int(x)\n        if x!= y and x!= z and y!= z:\n            result += 1\n    return str(result)\nprint(solution(input()))\n"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    ret = 0\n    for line in stdin.strip().split(\"\\n\"):\n        if (s := re.search(r\"^([A-Z])([A-Z])$\", line)) is None:\n            continue\n        if s.group(1) == s.group(2):\n            ret += 1\n    return str(ret)"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return str(len({s for s in stdin.splitlines() if (s := stdin.splitlines().pop().split(' '))[1] == s[::-1]}) - 1)\n"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    infos = stdin.split(\"\\n\")\n    total = 0\n    for info in infos:\n        info = info.split(\" \")\n        if info[1] == \"1\":\n            total += 26\n        elif info[1] == \"2\":\n            total += 23\n    return str(total)\n"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    inversion_count = 0\n    brackets = list(stdin)\n    bracket_count = len(brackets)\n    i = 0\n    # this loop runs until you find a matching pair\n    while i < bracket_count:\n        # we look for matching bracket pairs\n        if brackets[i] == '(' and brackets[bracket_count-i-1] == ')':\n            # if we find a pair, we find the corresponding opening bracket\n            brackets[i] = '('\n            # we want to skip the closing bracket until we find another matching pair\n            bracket_count -= 1\n            i += 1\n        # we increase the inversion count\n        # we do not need to change the brackets if we are not inversion operations\n        # there are only 2 types of operations\n        # 1) inversion operations\n        # 2) equal bracket pair\n        # if the last operation is an inversion, it can also be equal bracket pair\n        # so we increase inversion count\n        elif brackets[i] == '(' and brackets[bracket_count-i-1] == ')':\n            inversion_count += 1\n        # we increase i by 1\n        i += 1\n        # if we are still in the same bracket sequence, we can continue\n        if i == bracket_count:\n            continue\n        # if we are not in the same bracket sequence, we must check the next bracket\n        if brackets[i] == '(' and brackets[bracket_count-i-1] == ')':\n            # if we are inversion, we increase inversion count\n            if inversion_count % 2 == 0:\n                inversion_count += 1\n            # if we are not inversion, we increase inversion count\n            else:\n                inversion_count -= 1\n        # we increase bracket count\n        bracket_count -= 1\n    # if we don't have any inversion operation, then we can continue\n    if inversion_count == 0:\n        return 'possible'\n    # if we have any inversion operation, then we can't be valid\n    else:\n        return 'impossible'\n\nprint(solution(input()))\n"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    bracket = stdin.strip().split(')(')\n    ans = ''\n    for i, bracket_pair in enumerate(bracket):\n        invert_count = 0\n        for bracket_invert in reversed(bracket_pair):\n            if bracket_invert == '(' and invert_count == 0:\n                continue\n            elif bracket_invert == '(' and invert_count == 1:\n                invert_count -= 1\n            elif bracket_invert == ')' and invert_count == 1:\n                invert_count += 1\n            else:\n                break\n        if invert_count!= 1:\n            ans = 'impossible'\n            break\n    return ans\n\nsolution(input())\n\"\"\""
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_bracket_sequence = stdin\n    return 'possible' if invert_bracket(input_bracket_sequence) else 'impossible'\ndef"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    left = 0\n    right = 0\n    valid = True\n    while right < n and left < n:\n        if stdin[left] == ')':\n            valid = False\n            break\n        if stdin[right] == '(':\n            valid = False\n            break\n        if stdin[right] == '(' and stdin[left] == ')':\n            valid = False\n            break\n        right += 1\n        left += 1\n    if right == n and left == n:\n        valid = True\n    return \"possible\" if valid else \"impossible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    brackets = stdin.split(\" \")\n    inversions = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            inversions += 1\n        else:\n            inversions -= 1\n        if inversions < 0:\n            return \"impossible\"\n    return \"possible\""
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    bracket_sequence = stdin\n    if not check_bracket_sequence(bracket_sequence):\n        return 'impossible'\n    else:\n        return 'possible'\n\ndef"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This is a wonderful problem.\n    \"\"\"\n    if len(stdin) > 5000:\n        return \"impossible\"\n    brackets = []\n    for bracket in stdin:\n        brackets.append(bracket)\n    brackets = list(set(brackets))\n    brackets.sort()\n    res = False\n    for i in range(len(brackets)):\n        if brackets[i] == '(':\n            brackets[i] = ')'\n        else:\n            brackets[i] = '('\n        inverted_brackets = [x if x == ')' else '(' for x in brackets]\n        if inverted_brackets == brackets:\n            res = True\n            break\n        else:\n            brackets = inverted_brackets\n    return \"possible\" if res else \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    brackets = stdin\n    inversions = 0\n    valid = True\n    n = len(brackets)\n    if n == 0:\n        return 'possible'\n    for i in range(n):\n        if brackets[i] == '(':\n            inversions += 1\n        elif brackets[i] == ')':\n            inversions -= 1\n        if inversions < 0:\n            valid = False\n            break\n    if valid and inversions == 0:\n        return 'possible'\n    else:\n        return 'impossible'\n"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    if len(lines) == 1:\n        return \"possible\"\n    for i in range(len(lines)):\n        if i % 2 == 0:\n            continue\n        else:\n            count = 0\n            l = list(lines[i])\n            for j in range(len(l)):\n                if l[j] == \"(\":\n                    count += 1\n                else:\n                    count -= 1\n                if count < 0:\n                    return \"impossible\"\n    return \"possible\""
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    bracket_seq = stdin\n    bracket_seq = bracket_seq.replace('()', '{}').replace('(', '{').replace(')', '}')\n    invert_cnt = 0\n    for bracket in bracket_seq:\n        if bracket == '(':\n            invert_cnt += 1\n        elif bracket == ')':\n            invert_cnt -= 1\n    return 'possible' if invert_cnt <= 1 else 'impossible'\n    \n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    durations = []\n    for _ in range(M):\n        X, S, T, L = map(int, stdin.split())\n        durations.append((X, S, T, L))\n\n    station_times = []\n    for i in range(1, N + 1):\n        station_times.append(i)\n\n    for station_time in station_times:\n        for duration in durations:\n            departure_time = station_time + duration[1]\n            if departure_time <= 86400:\n                arrival_time = station_time + duration[2]\n                if arrival_time <= 86400:\n                    difference = arrival_time - departure_time\n                    if difference < L:\n                        return \"impossible\"\n    return str(min(station_times))\n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split()))\n    stations = {i: [] for i in range(1, N+1)}\n    for i in range(M):\n        x, s, t, l = list(map(int, stdin.split()))\n        stations[x].append([s, t, l])\n    if len(stations[1]) == 0:\n        return 'impossible'\n    times = {i: 0 for i in range(1, N+1)}\n    for i in range(1, N+1):\n        times[i] = max(time(i, times, stations, stations[i]) for i in range(1, N+1))\n    return max(times)\n\n\ndef"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n    stations = {}\n    for _ in range(M):\n        X, S, T, L = map(int, stdin.strip().split())\n        for i in range(S, T):\n            if not stations.get(X):\n                stations[X] = []\n            stations[X].append((i, L))\n    q = [(1, 0)]\n    min_time = float('inf')\n    while q:\n        j, time = heapq.heappop(q)\n        for i in range(j + 1, j + 1 + N):\n            if stations.get(i):\n                for t in stations[i]:\n                    if t[0] <= time + t[1] <= time + 1800:\n                        return 'impossible'\n                stations[i] = []\n                heapq.heappush(q, (i, time + 1800))\n        min_time = min(min_time, time + 1800)\n    return min_time\n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    N, M = stdin[0].split()\n    N = int(N)\n    M = int(M)\n    if M == 0:\n        return \"impossible\"\n    stations = []\n    trains = []\n    for i in range(1, N + 1):\n        stations.append(i)\n    for i in range(M):\n        train = stdin[i + 1].split()\n        starts = int(train[0])\n        departs = int(train[1])\n        arrives = int(train[2])\n        durations = int(train[3])\n        trains.append((starts, deposes, arrives, durations))\n    starts, deposes, arrives, durations = trains[0]\n    starts = int(starts)\n    deposes = int(durations)\n    arrives = int(arrives)\n    durations = int(durations)\n    all_stations = list(stations)\n    for i in range(len(all_stations)):\n        for j in range(len(all_stations)):\n            if i < j:\n                if all_stations[i] == all_stations[j]:\n                    del all_stations[i]\n                    break\n    early = 0\n    late = 0\n    for i in range(len(all_stations) - 1):\n        if deposes + arrives > all_stations[i + 1] and all_stations[i + 1] > all_stations[i]:\n            early = all_stations[i]\n            break\n        if deposes + arrives < all_stations[i] and all_stations[i] < all_stations[i + 1]:\n            late = all_stations[i]\n            break\n    early = (early - starts)\n    late = (late - arrives)\n    early = early + max(0, 900 - arrives)\n    late = late + max(0, 900 - starts)\n    return str(early + late)\n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    lines = [map(int, line.split()) for line in stdin.split('\\n')[1:]]\n    scheduled_trains = sorted(lines, key=lambda t: t[0] * 3600 + t[1] * 60 + t[2])\n    max_len = 0\n    for line in scheduled_trains:\n        if line[3] > max_len:\n            max_len = line[3]\n    start = 0\n    if max_len < 1800:\n        return 'impossible'\n    while start + 1800 < max_len:\n        for line in scheduled_trains:\n            if line[0] > start + 1800 and line[1] >= start:\n                start = line[1]\n                break\n        else:\n            return 'impossible'\n    return str(start)\n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    stations = []\n    for i in range(1, n + 1):\n        stations.append((i, int(stdin.split()[i * 2 - 1]), int(stdin.split()[i * 2])))\n    # print(stations)\n    stations.sort(key=lambda x: x[1])\n    stations.sort(key=lambda x: x[2])\n    # print(stations)\n    for i in range(1, n + 1):\n        if stations[i - 1][0] == stations[i][0]:\n            continue\n        a = stations[i][0]\n        b = stations[i - 1][0]\n        while a > b and i - 1 >= 0:\n            a = stations[i - 1][0]\n            i -= 1\n        if a == b:\n            return 'impossible'\n    start = 0\n    for i in range(n):\n        if start + stations[i][2] > stations[i][1]:\n            start = stations[i][1]\n            continue\n        else:\n            return 'impossible'\n    return str(start)\n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    trains = list()\n    for _ in range(m):\n        trains.append(list(map(int, stdin.split())))\n    # for train in trains:\n    #     if train[1] - train[0] > 1800:\n    #         return 'impossible'\n    trains.sort(key=lambda x: x[1] - x[0])\n    max = 0\n    for i in range(n - 1):\n        curr = trains[0][1] - trains[0][0]\n        for j in range(1, m):\n            if trains[j][0] < trains[j - 1][1]:\n                curr = min(trains[j][1] - trains[j][0], curr)\n            else:\n                curr = min(trains[j][1] - trains[j][0] - trains[j - 1][1], curr)\n        max = max(max, curr)\n    return str(max)\n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    s, t, l = map(int, stdin.split())\n    x, s, t = 1, 0, 0\n    while True:\n        if s > t:\n            break\n        if N - x < l:\n            return \"impossible\"\n        s += t\n        t += l\n        x += 1\n    return s - t\n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    timetable = list(map(int, stdin.split()))\n    stations = sorted(list(range(1, N + 1)))\n    \n    for i in range(M):\n        departure, arrival, duration = timetable[i*4: i*4 + 4]\n        left = arrival - departure\n        if left > duration:\n            return 'impossible'\n        \n    for i in range(M):\n        departure, arrival, duration = timetable[i*4: i*4 + 4]\n        if departure <= arrival <= departure + duration:\n            return 'impossible'\n        if departure + duration < departure:\n            return 'impossible'\n    \n    departure = max(min(departure, arrival) for departure, arrival, _ in timetable)\n    if departure <= arrival <= departure + duration:\n        return 'impossible'\n    \n    return departure\n"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    My solution, the given testcase is too hard.\n    \"\"\"\n    pass"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return \" \".join([\" \".join(map(str, range(i + 1, m * n + 1, n)) if j!= i else \" \") for i in range(n)])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    (n, m) = map(int, stdin.split())\n    return solution_naive(n, m)\n\ndef"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    games = []\n    for i in range(m):\n        games.append(list(map(str, stdin.split())))\n    rounds = 1\n    games.sort()\n    teamA = {games[i][0] for i in range(len(games))}\n    teamB = {games[i][1] for i in range(len(games))}\n    while 1:\n        if len(teamA) == 1 and len(teamB) == 1:\n            break\n        if len(teamA) > 1 and len(teamB) > 1:\n            if len(teamA) > rounds:\n                teamA -= {games[i][0] for i in range(len(games))}\n            elif len(teamA) < rounds:\n                teamA += {games[i][1] for i in range(len(games))}\n            if len(teamB) > rounds:\n                teamB -= {games[i][1] for i in range(len(games))}\n            elif len(teamB) < rounds:\n                teamB += {games[i][0] for i in range(len(games))}\n        rounds += 1\n    if len(teamA) > rounds or len(teamB) > rounds:\n        return 'Impossible'\n    else:\n        output = ''\n        for i in range(rounds):\n            if len(teamA) > 1:\n                output += f'{teamA.pop()}-{teamA.pop()}\\n'\n            elif len(teamA) == 1:\n                output += f'{teamA.pop()}\\n'\n            if len(teamB) > 1:\n                output += f'{teamB.pop()}-{teamB.pop()}\\n'\n            elif len(teamB) == 1:\n                output += f'{teamB.pop()}\\n'\n        return output[:-1]\n"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    res = ''\n    for i in range(1, m):\n        for j in range(n):\n            res += f'{chr(ord(\"A\") + j)}{chr(ord(\"A\") + i)} '\n    for j in range(n):\n        res += f'{chr(ord(\"A\") + j)}{chr(ord(\"A\") + m)} '\n    return res"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    a = list(range(1, n+1))\n    b = []\n    for _ in range(m-1):\n        b.append(a.pop(0))\n        a.append(a.pop(0))\n    return \" \".join(f\"{a[i]}-{b[i]}\" for i in range(n))\n"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return \" \".join(\n        [f\"{player}-{player}\" for player in range(n, n * m + 1)\n         if player <= (m - 1) * n\n         if n!= m and not (n * (m - 1)) % (n - 1)\n         if not (n * (m - 1)) % (m - 1)\n         if not (n * (m - 1)) % (m - 1) and (m - 1) * n > n * (m - 1)]\n    )\nsolution(input())\n\ndef"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    team_num, games = stdin.split()\n    n = int(team_num)\n    m = int(games)\n    \n    return''.join([' '.join([player for player in range(i*n, (i+1)*n)]) for i in range(m)])\n\nsolution(\"2 3\")"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teams = list(range(1, n+1))\n    rounds = 0\n    games = []\n    while True:\n        teams = games[::-1]\n        games = []\n        teams_games = []\n        rounds += 1\n        for team in range(1, m+1):\n            if len(teams) == 0:\n                break\n            if team in teams:\n                games.append(f'{team}-{teams.pop(teams.index(team))}')\n            else:\n                teams_games.append(f'{team}-{teams.pop(teams.index(team))}')\n        for game in range(0, len(games), 2):\n            games.append(games[game])\n        for game in range(1, len(games), 2):\n            games.append(games[game])\n        if len(games) == 1:\n            break\n    games_str =''.join(games)\n    return games_str"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if m <= 1 or n <= 1:\n        raise Exception(\"Invalid Input\")\n    \n    teams = [[i] for i in range(1, m + 1)]\n    for i in range(n - 1):\n        teams = [[team for team in team + list(range(i + 2, m + 1))] for team in teams]\n        teams = list(filter(lambda team: len(team) == m, teams))\n\n    return \"\\n\".join([\" \".join([str(i) for i in team]) for team in teams])"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    R = int(stdin[0])\n    C = int(stdin[1])\n\n    apartment = stdin[2:]\n    Apartment = [[c for c in row] for row in apartment]\n    Table = []\n    for j in range(R):\n        Table.append([])\n        for i in range(C):\n            if Apartment[j][i] == '.':\n                Table[j].append(-1)\n            else:\n                Table[j].append(0)\n\n    width = len(Table[0])\n    height = len(Table)\n\n    for i in range(R):\n        for j in range(C):\n            if j > 0:\n                if Apartment[i][j] == '.':\n                    Table[i][j] = min(Table[i][j-1], Table[i-1][j-1], Table[i-1][j]) + 1\n                if Apartment[i][j] == 'X':\n                    Table[i][j] = max(Table[i][j-1], Table[i-1][j-1], Table[i-1][j]) + 1\n\n    return str(sum([Table[i][j] for i in range(R) for j in range(C) if Table[i][j] > 0]))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    table = []\n    for i in range(R):\n        table.append(stdin.split()[i])\n    table = list(map(lambda x: x.replace('X', '.'), table))\n    table = list(map(lambda x: x.replace('X', '.'), table))\n    result = 0\n    for i in range(R):\n        for j in range(R):\n            if (table[i][j] == 'X' and table[i][j + 1] == 'X' and table[i + 1][j] == 'X' and table[i + 1][j + 1] == 'X'):\n                result += 4\n            if (table[i][j] == 'X' and table[i][j + 1] == 'X' and table[i + 1][j] == 'X' and table[i + 1][j + 1] == 'X'):\n                result += 2\n            if (table[i][j] == 'X' and table[i + 1][j + 1] == 'X'):\n                result += 1\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    a = stdin.strip().splitlines()\n    print(a)\n    for i in range(len(a)):\n        a[i] = a[i].replace(\"X\", \".\")\n        if a[i] == \"\":\n            a[i] = \".\"\n    for i in range(len(a)):\n        a[i] = a[i].replace(\".\", \"X\")\n        if a[i] == \"\":\n            a[i] = \"X\"\n    for i in range(len(a)):\n        a[i] = a[i].replace(\"X\", \"\")\n        a[i] = a[i].replace(\".\", \"X\")\n    for i in range(len(a)):\n        print(a[i])\n    '''\n    a = stdin.strip().splitlines()\n    print(a)\n    for i in range(len(a)):\n        a[i] = a[i].replace(\"X\", \".\")\n        if a[i] == \"\":\n            a[i] = \".\"\n    for i in range(len(a)):\n        a[i] = a[i].replace(\".\", \"X\")\n        if a[i] == \"\":\n            a[i] = \"X\"\n    for i in range(len(a)):\n        a[i] = a[i].replace(\"X\", \"\")\n        a[i] = a[i].replace(\".\", \"X\")\n    for i in range(len(a)):\n        print(a[i])\n    r = len(a)\n    c = len(a[0])\n    # print(r, c)\n    s = 0\n    for i in range(r):\n        for j in range(c):\n            if a[i][j] == \".\":\n                s += 1\n    print(s)\n    if s == 0:\n        return \"0\"\n    # a = \"\".join(a)\n    # print(a)\n    return str(s - (r * c - s))\n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    l1 = '.' * M\n    l2 = '.' * M\n    l3 = '.' * M\n    l4 = '.' * M\n    l5 = '.' * M\n    for _ in range(N):\n        l1 += 'X'\n        l2 += 'X'\n        l3 += 'X'\n        l4 += 'X'\n        l5 += 'X'\n    return l1 + l2 + l3 + l4 + l5\n\nprint(solution(input()))"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split(\"\\n\")\n    R, C = map(int, lines[0].split())\n    grid = []\n    for row in lines[1:]:\n        grid.append([c for c in row])\n    return str(solve(R, C, grid))\n\ndef"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    table = stdin.replace(\"X\", \".\").replace(\"X\", \"X\")\n    table = [list(table[i]) for i in range(R)]\n    table = list(itertools.chain(*table))\n    table = list(itertools.chain(*table))\n    R = len(table)\n    C = len(table[0])\n    return str(sum(table[i].count(\".\") for i in range(R-1)) + table[-1].count(\".\"))\n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    R, C = (int(i) for i in stdin)\n    # board = [[j for j in stdin[i]] for i in range(R)]\n    board = stdin\n    print(board)\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[i])):\n            if board[i][j] == \"X\":\n                count += 1\n    return str(count)\n\nprint(solution(\"4 4\nX.XX\nX..X\n..X.\n..XX\"))\n\n\n\"\"\"\n\nimport math\n\n\"\"\"\n\nSample Input 1:\n2 2\n..\n..\nSample Output 1:\n7\n\nSample Input 2:\n4 4\nX.XX\nX..X\n..X.\n..XX\nSample Output 2:\n9\n\n\"\"\"\n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    table = stdin.split()\n    for i in range(len(table)):\n        for j in range(len(table[i])):\n            if table[i][j] == \"X\":\n                table[i][j] = 0\n    table_len = []\n    for i in range(len(table)):\n        table_len.append(len(table[i]))\n    sum_table = sum(table_len)\n    if sum_table % 2!= 0:\n        return \"0\"\n    else:\n        return str(sum_table // 2)\n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R = int(stdin.split()[0])\n    C = int(stdin.split()[1])\n    grid = []\n    for i in range(R):\n        row = stdin.split()[2 + i]\n        grid.append(row)\n    return solution_helper(grid, R, C)\ndef"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(map(int, stdin.split()))\n    answer = 0\n    pos = (0, 0)\n    board = [list(map(int, stdin.pop(0).split())) for _ in range(stdin[0])]\n    tarots = set([board[i][j] for i in range(len(board)) for j in range(len(board[0])) if board[i][j]!= 0])\n    tarots = list(tarots)\n    tarots.sort(key=lambda x: x[0])\n    tarots.sort(key=lambda x: x[1])\n    tarots.sort(key=lambda x: x[2])\n    tarots.sort(key=lambda x: x[3])\n    tarots.sort(key=lambda x: x[4])\n    while tarots:\n        if pos == (0, 0):\n            break\n        tarot = tarots.pop(0)\n        if pos == tarot:\n            answer += tarot[5]\n            continue\n        for i in range(tarot[0], tarot[1] + 1):\n            for j in range(tarot[2], tarot[3] + 1):\n                if board[i][j]!= 0:\n                    continue\n                if abs(i - pos[0]) + abs(j - pos[1]) <= tarot[4]:\n                    tarots.append(board[i][j])\n                    board[i][j] = tarot[5]\n                    pos = (i, j)\n                    break\n    if pos == (0, 0):\n        return answer\n    else:\n        return -1\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    elif n == 1:\n        return \"-1\"\n    t = [(0, 0), (1, 0), (0, 1), (-1, 0), (0, -1)]\n    min_cost = [[0 for i in range(n)] for j in range(n)]\n    min_cost[0][0] = int(stdin)\n    for i in range(n):\n        for j in range(n):\n            for u, v in t:\n                if i + u < n and j + v < n:\n                    if min_cost[i + u][j + v] == 0:\n                        min_cost[i + u][j + v] = min(min_cost[i][j], min_cost[i + u][j + v]) + int(stdin)\n                    min_cost[i + u][j + v] = min(min_cost[i][j], min_cost[i + u][j + v])\n    if min_cost[n - 1][n - 1] == 0:\n        return \"0\"\n    else:\n        return str(min_cost[n - 1][n - 1])\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Solution for puzzle 2\n    '''\n    rows, cols, a, b, p = stdin.split('\\n')\n    a = int(a)\n    b = int(b)\n    p = int(p)\n    return min(p, a*(a+b) + b*(a+b), a*(a+b) + b*(a+b), a*a + b*b)"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    costs = list(map(int, stdin.split()[1:]))\n    pos = (0, 0)\n    tarot = 0\n    board = {}\n    for c in costs:\n        tarot = max(tarot, c)\n        board[pos] = (tarot, c)\n        pos = pos[0] + c, pos[1] + tarot\n    ans = 0\n    for t in range(tarot, 0, -1):\n        if t in board:\n            pos = t - board[t][0], t - board[t][0]\n            ans = max(ans, board[t][1] + (ans if pos not in board else 0))\n    return str(ans)\n\nsolution(\"2 3 2 2 100\")\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_n = int(stdin)\n    def get_neighbors(pos, size):\n        x, y = pos\n        if x == 0 or y == 0 or x == size - 1 or y == size - 1:\n            return [(x, y)]\n        return [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n\n    def solve():\n        grid = []\n        for i in range(input_n):\n            grid.append([int(char) for char in stdin.split(' ')])\n        tarot_cards = []\n        for i in range(input_n):\n            for j in range(input_n):\n                if grid[i][j] == 1:\n                    tarot_cards.append((i, j, -10**9, 10**9, -10**9, 10**9))\n        #Tarot cards on the chessboard\n        tarot_cards = sorted(tarot_cards, key = lambda x: x[3] - x[2] + x[5] - x[4])\n        \n        #Tarot cards on the board\n        neighbor_info = dict()\n        for i in range(input_n):\n            for j in range(input_n):\n                if grid[i][j]!= 1:\n                    neighbors = get_neighbors((i, j), input_n)\n                    for neighbor in neighbors:\n                        if neighbor in neighbor_info:\n                            neighbor_info[neighbor].append((i, j))\n                        else:\n                            neighbor_info[neighbor] = [(i, j)]\n        \n        #Initialize the queue\n        visited = set()\n        queue = []\n        visited.add((0, 0))\n        queue.append((0, 0))\n\n        while queue:\n            #Remove the first element from the queue\n            curr_pos = queue.pop(0)\n            if curr_pos == (0, 0):\n                break\n            if curr_pos == (input_n - 1, input_n - 1):\n                return 0\n            \n            if curr_pos not in visited:\n                visited.add(curr_pos)\n                for neighbor in neighbor_info[curr_pos]:\n                    queue.append(neighbor)\n        return -1\n    return solve()\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_cost(pos: str, price: str):\n        r, c, a, b = int(pos[0]), int(pos[1]), int(price[0]), int(price[1])\n        return min(((r - a) * -1) + (c - b) + (r - a), (c - b) * -1 + (r - a) + (c - b), (r - a) * -1 + (c - b) * -1 + (r - a), (r - b) * -1 + (c - a) * -1 + (r - b), (r - b) * -1 + (c - a) * -1 + (r - b), (c - a) * -1 + (r - b) * -1 + (c - a), (c - b) * -1 + (r - a) * -1 + (c - a), (c - b) * -1 + (r - a) * -1 + (c - a))\n    \n    \n    n = int(stdin.readline())\n    m = int(stdin.readline())\n    \n    t = []\n    \n    for _ in range(m):\n        r, c, a, b = stdin.readline().strip().split()\n        a, b = int(a), int(b)\n        t.append([r, c, a, b])\n    \n    m = {}\n    for i in t:\n        m[i[0] + i[1]] = i[2:]\n    \n    d = {}\n    for i in t:\n        if i[0] in d.keys():\n            d[i[0]].append(i[1])\n        else:\n            d[i[0]] = [i[1]]\n    \n    \n    ans = float('-inf')\n    \n    for i in range(n):\n        if i + 1 in d.keys():\n            for j in d[i + 1]:\n                ans = max(ans, get_min_cost(str(i) +'' + str(j), m[str(i) + str(j)]))\n    \n    \n    \n    if ans == float('-inf'):\n        return '-1'\n    \n    return str(ans)\n\nstdin = open('sample.txt', 'r')\nprint(solution(stdin))"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    infinite_chessboard = list(map(int, stdin.split()))\n    tarot_cards_on_chessboard = list(map(list, stdin.split()))\n    tarot_cards_price = list(map(int, stdin.split()))\n    solution = 0\n    positions_of_tarot_cards_on_chessboard = tarot_cards_on_chessboard\n    tarot_cards_on_chessboard = tarot_cards_on_chessboard\n    #print(tarot_cards_price)\n    #print(positions_of_tarot_cards_on_chessboard)\n    for i in range(len(positions_of_tarot_cards_on_chessboard)):\n        positions_of_tarot_cards_on_chessboard[i] = tarot_cards_on_chessboard[i]\n    #print(positions_of_tarot_cards_on_chessboard)\n    #print(len(positions_of_tarot_cards_on_chessboard))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[0], x[1]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[2], x[3]))\n    #print(positions_of_tarot_cards_on_chessboard)\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[4]))\n    #print(positions_of_tarot_cards_on_chessboard)\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[5]))\n    #print(positions_of_tarot_cards_on_chessboard)\n    #print(positions_of_tarot_cards_on_chessboard)\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[6]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[7]))\n    #print(positions_of_tarot_cards_on_chessboard)\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[8]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[9]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[10]))\n    #print(positions_of_tarot_cards_on_chessboard)\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[11]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[12]))\n    #print(positions_of_tarot_cards_on_chessboard)\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[13]))\n    #print(positions_of_tarot_cards_on_chessboard)\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[14]))\n    #print(positions_of_tarot_cards_on_chessboard)\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[15]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[16]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[17]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[18]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[19]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[20]))\n    #print(positions_of_tarot_cards_on_chessboard)\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[21]))\n    #print(positions_of_tarot_cards_on_chessboard)\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[22]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[23]))\n    #print(positions_of_tarot_cards_on_chessboard)\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[24]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[25]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[26]))\n    positions_of_tarot_cards_on_chessboard.sort(key=lambda x: (x[27]))\n    positions_of_tarot_cards_on_chess"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_nearest(x, y, direction):\n        # Returns the distance from the knight to the nearest square.\n        r, c = x + direction[0], y + direction[1]\n        while -1 < r < N and -1 < c < N and arr[r][c] == 0:\n            r += direction[0]\n            c += direction[1]\n        return r - x, c - y\n\n    N = int(stdin.split()[0])\n    stdin = stdin.split()\n    arr = []\n    for _ in range(N):\n        arr.append(list(map(int, stdin.pop().split())))\n\n    MAX_COST = 100000\n    cost = [[MAX_COST] * N for _ in range(N)]\n    x, y = 0, 0\n    direction = (0, 1)\n    cost[x][y] = 0\n\n    # We can't move up and down.\n    direction = (0, 0)\n\n    # If the knight can get to the goal, then stop.\n    if arr[x][y] == 1:\n        return str(cost[x][y])\n\n    for _ in range(1, N * N + 1):\n        # Loop for all the squares.\n        for d in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n            # Loop for all directions.\n            dx, dy = find_nearest(x, y, d)\n            if cost[dx][dy] == MAX_COST:\n                continue\n            # If the square has a tarot card, we can move into that square and buy a card.\n            if arr[dx][dy] > 0:\n                card = arr[dx][dy]\n                cost[dx][dy] = min(cost[dx][dy], cost[x][y] + card)\n                arr[dx][dy] = 0\n                continue\n            # If the square has a tarot card, we can move into that square and buy a card.\n            if arr[dx][dy] == -1:\n                continue\n            cost[dx][dy] = min(cost[dx][dy], cost[x][y] + arr[dx][dy])\n            arr[dx][dy] = 0\n        x, y = x + direction[0], y + direction[1]\n\n    if cost[x][y] == MAX_COST:\n        return -1\n\n    return str(cost[x][y])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    position, tarot = [], []\n    for i in range(n):\n        r, c, a, b, p = map(int, stdin.split())\n        position.append((r, c))\n        tarot.append((a, b, p))\n    if position[0] == (0, 0):\n        return '-1'\n    q = deque([(0, 0)])\n    visited = set()\n    visited.add((0, 0))\n    cost = 0\n    while q:\n        cur = q.popleft()\n        r, c = cur[0], cur[1]\n        for i in range(4):\n            nr = r + tarot[i][0]\n            nc = c + tarot[i][1]\n            if (nr, nc) in visited:\n                continue\n            if 0 <= nr < n and 0 <= nc < n:\n                visited.add((nr, nc))\n                if (nr, nc) == (0, 0):\n                    return str(tarot[i][2])\n                q.append((nr, nc))\n                cost = cost + tarot[i][2]\n    return str(cost)\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cost = 0\n    for _ in range(n):\n        r, c, a, b, p = map(int, stdin.split()[1:])\n        cost += (p-a)+(p-b)+(abs(a-b))\n    return str(cost)\n"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_data = stdin.split()\n    input_size = int(test_data.pop(0))\n    input_string = test_data.pop(0)\n    input_string = input_string.replace(' ', '')\n\n    input_size = int(input_size)\n    input_string = int(input_string)\n    input_string = str(input_string)\n\n    sum = 0\n    for i in range(len(input_string)):\n        current_sum = 0\n        for j in range(len(input_string)):\n            if i!= j:\n                current_sum += int(input_string[j])\n        if current_sum % 3 == 0:\n            sum += 1\n\n    print(sum)\n    return sum\n"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin.strip())\n    S: str = stdin.strip()\n    output: str = str(len(S) - len(set(S)) % 3)\n    return output\n"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Given a string, calculate the number of valid subsets of that string.\n    \"\"\"\n    input = stdin.split()\n    b = input[0]\n    s = input[1]\n\n    s_int = int(s)\n\n    if s_int < 1:\n        return 0\n\n    if s_int % 3!= 0:\n        return 0\n\n    subset = []\n    subset.append(s_int)\n\n    while len(subset)!= 0:\n        s_int = subset[-1]\n\n        subset_s = str(s_int)\n\n        if len(subset_s) < len(b):\n            subset_s = b[:len(subset_s)]\n\n        if subset_s == b:\n            subset.pop()\n        else:\n            i = 0\n            while i < len(b):\n                if subset_s[i]!= b[i]:\n                    break\n                i += 1\n\n            if i == len(b):\n                subset.pop()\n\n    return str(len(subset))\n"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    b = '0123456789'\n    s = s.replace('0', '')\n    s = s.replace('1', '')\n    s = s.replace('2', '')\n    s = s.replace('3', '')\n    s = s.replace('4', '')\n    s = s.replace('5', '')\n    s = s.replace('6', '')\n    s = s.replace('7', '')\n    s = s.replace('8', '')\n    s = s.replace('9', '')\n    s = s.replace('.', '')\n    s = s.replace(',', '')\n    s = s.replace(' ', '')\n    #print(s)\n    s = list(s)\n    length = len(s)\n    \n    a = b\n    b = list(b)\n    b.sort()\n    for i in range(length):\n        if s[i] == '.':\n            for j in range(length):\n                if s[j] == '.':\n                    s[j] = a[j]\n    s = ''.join(s)\n    s = int(s)\n    #print(s)\n    #print(a)\n    #print(b)\n    #print(length)\n    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n    count = 0\n    if (s + 1) % 2 == 1:\n        for i in range(length):\n            if s % 2 == 1:\n                s = s * 10\n            if s % 2 == 0:\n                s = s // 10\n            if s == b[i]:\n                count += 1\n    else:\n        for i in range(length):\n            if s % 2 == 1:\n                s = s * 10\n            if s % 2 == 0:\n                s = s // 10\n            if s == b[i]:\n                count += 1\n    #print(s)\n    print(count)\n    return count\n"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = list(stdin)\n    s.sort(reverse=True)\n    n2 = 0\n    n3 = 0\n    for i in s:\n        n2 += int(i)\n    for j in range(2, 8):\n        for k in range(1, 9):\n            n3 += 1\n            n2 += int(i)\n    return str(n3)"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num = stdin.split('\\n')[0]\n    valid_str = stdin.split('\\n')[1]\n\n    num = num.lstrip(' ')\n    num = num.rstrip(' ')\n    s = num\n    s_sub = ''\n    n = 0\n    while len(s)!= 0:\n        s = s.lstrip(' ')\n        s = s.rstrip(' ')\n        n = len(s)\n        for i in range(1, n + 1):\n            s_sub = s_sub + s[0:i]\n        if len(s_sub) >= 3 and s_sub.isdigit():\n            s_int = int(s_sub)\n            if (s_int / 3).is_integer() and (s_int % 3).is_integer():\n                n = n + 1\n                s_sub = ''\n        else:\n            s_sub = ''\n        s = s[1:]\n\n    print(n)\n    return n\n\n\nsolution(input())"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    l = stdin.split()\n    n = int(l[0])\n    s = l[1]\n    return solution_optimized(n, s)\n\ndef"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b = stdin\n    b = b.strip()\n    if b.startswith('0') or b.startswith('1') or b.startswith('2') or b.startswith('3') or b.startswith('4') or b.startswith('5') or b.startswith('6') or b.startswith('7') or b.startswith('8') or b.startswith('9'):\n        return '0'\n    return str(len(b)) +'' + str(b)\n    return '{0:.3f}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:0>3}'.format(len(b)) +'' + str(b)\n    return '{0:0>3d}'.format(len(b)) +'' + str(b)\n    return '{0:0>3d}'.format(len(b))\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{0:03d}'.format(len(b))\n    return '{0:03d}'.format(len(b)) +'' + str(b)\n    return '{"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    if len(s) == 1 and s[0].isdigit():\n        return str(len(s) + 1)\n    else:\n        s = list(map(int, s))\n        for i in range(len(s)):\n            s[i] = str(s[i])\n        s = \"\".join(s)\n        subset = \"\"\n        for i in range(len(s)):\n            subset += s[i]\n            subset_length = len(subset)\n            if subset_length > 1:\n                if subset_length % 3 == 0 and subset_length < 10:\n                    break\n        return str(len(subset) % 10 ** 9 + 7)\n"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n,g = map(int, stdin.strip().split())\n    stations = sorted(map(int, stdin.strip().split()))\n    costs = sorted(map(int, stdin.strip().split()))\n    total_cost = 0\n    while len(stations) > 0:\n        cost = costs.pop()\n        station = stations.pop()\n        if total_cost+cost > g:\n            return 'cancel road trip'\n        else:\n            total_cost += cost\n            stations.append(station)\n    return total_cost"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # n, g = map(int, stdin.split())\n    # d, c = [], []\n    # for _ in range(n):\n    #     d.append(int(stdin.split()[1 * _ + 2]))\n    #     c.append(int(stdin.split()[1 * _ + 3]))\n    #\n    # d = sorted(d)\n    # c = sorted(c)\n    #\n    # d_index = 1\n    # c_index = 1\n    # total_cost = 0\n    # while True:\n    #     if d_index >= len(d):\n    #         break\n    #     if d_index >= c_index:\n    #         total_cost += d[d_index] * c[c_index]\n    #         d_index += 1\n    #         c_index += 1\n    #     elif d_index + 1 <= c_index:\n    #         total_cost += d[d_index]\n    #         d_index += 1\n    #     else:\n    #         total_cost += d[d_index] * (c[c_index] - c[c_index - 1])\n    #         d_index += 1\n    #         c_index += 1\n    #\n    # return str(total_cost)\n\n    # Solution 2\n    def calculate(x, y, z):\n        if x >= 0:\n            return z, y + z\n        else:\n            return y + z, z + x\n    # print(calculate(2,1,2))\n    return 'cancel road trip'\n\n\nsolution(input())\n"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    gas = []\n    for i in range(n):\n        d, c = map(int, stdin.split())\n        gas.append((d, c))\n    curr_tank = 0\n    left = 0\n    right = n - 1\n    min_cost = 0\n    while left <= right:\n        if curr_tank == 0 and gas[left][1] > 0:\n            curr_tank = gas[left][1]\n            left += 1\n        elif curr_tank > 0:\n            curr_tank -= gas[left][1]\n            left += 1\n        else:\n            left += 1\n            continue\n        if left == right:\n            break\n        if gas[right][1] > 0:\n            curr_tank += gas[right][1]\n        right -= 1\n        if curr_tank < g:\n            curr_tank = 0\n            left = 0\n            continue\n        if left == right:\n            break\n        if left!= right:\n            min_cost += curr_tank\n            curr_tank = 0\n    if curr_tank!= 0:\n        min_cost += curr_tank\n    return str(min_cost)\n"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.strip().split())\n    dist, cost = map(int, stdin.strip().split())\n    if dist == 1:\n        return str(g)\n    elif dist >= cost:\n        return str(g + (n - 1) * dist)\n    else:\n        return \"cancel road trip\"\n"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    d = [int(i) for i in stdin.split()]\n    \n    # Initialize dictionary of gas stations, with distance as key\n    # and cost as value\n    gas_dict = {}\n    for i in range(n):\n        gas_dict[d[i]] = g\n    \n    gas_stations = sorted(gas_dict.keys())\n    \n    # Calculate distance from the leftmost gas station to the rightmost\n    # fuel tank\n    fuel_tank_dist = (n-1)*d[0] + gas_stations[-1]\n    \n    # Initiate fuel tank and cost\n    fuel_tank = d[0]\n    cost = 0\n    \n    # Iterate through gas stations in sorted order\n    for i in gas_stations:\n        fuel_tank -= d[i]\n        cost += d[i] * gas_dict[i]\n        fuel_tank_dist += d[i]\n        if fuel_tank <= 0:\n            break\n    if fuel_tank <= 0:\n        return \"cancel road trip\"\n    return fuel_tank_dist, cost"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n,g=map(int,stdin.split())\n    cost = []\n    for i in range(n):\n        cost.append(int(input()))\n    min_cost = float('inf')\n    for i in range(n-1):\n        min_cost = min(min_cost,cost[i]+min(g-cost[i+1],cost[i+1]))\n    return str(min_cost)\nsolution(input())"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    if n == 0:\n        print(\"cancel road trip\")\n    else:\n        f = [int(x) for x in stdin.split()]\n        tank = g\n        stations = {x: {} for x in f}\n        stations[0] = {\"cost\": 0}\n        for i in range(1, n):\n            for j in range(i + 1, n + 1):\n                if j in stations:\n                    if j == n + 1:\n                        tank -= stations[j][\"cost\"]\n                    else:\n                        tank -= stations[j][\"cost\"]\n                    stations[j] = {\n                        \"cost\": stations[j - 1][\"cost\"] + max(0, f[i] - stations[j][\"cost\"])\n                    }\n        print(tank)\n"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    stations = list()\n    for _ in range(n):\n        d, c = map(int, stdin.split())\n        stations.append((d, c))\n    station_capacity = g\n    stations = sorted(stations, key=lambda x: x[0])\n    stations_capacity = 0\n    for station in stations:\n        if stations_capacity + station[1] <= station_capacity:\n            stations_capacity += station[1]\n        else:\n            return 'cancel road trip'\n    return stations_capacity\n"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    f = []\n    c = []\n    for _ in range(n):\n        f.append(int(stdin.split()[0]))\n        c.append(int(stdin.split()[1]))\n    ans = 0\n    for i in range(len(f)):\n        ans += max(c[i]-f[i], 0)\n    return str(ans)\n\nsolution(\"3 10\")\nsolution(\"3 10\")"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    distance, cost = list(map(int, stdin.split())), list(map(int, stdin.split()))\n\n    tank = g\n    tank_list = []\n    for i in range(n):\n        tank_list.append(tank)\n        tank -= cost[i]\n\n    tank_list.sort()\n\n    for i in range(n):\n        if tank_list[i] + cost[i] < tank:\n            tank = tank_list[i] + cost[i]\n\n    if tank < g:\n        return \"cancel road trip\"\n    return tank\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, k = map(int, stdin.split())\n    jewels = []\n    for _ in range(n):\n        jewels.append(tuple(map(int, stdin.split())))\n    jewels = sorted(jewels, key=lambda x: (x[1], x[0]))\n    res = [[0 for _ in range(k+1)] for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            if j >= jewels[i-1][0]:\n                res[i][j] = max(res[i-1][j], res[i-1][j-jewels[i-1][0]]+jewels[i-1][1])\n            else:\n                res[i][j] = res[i-1][j]\n    return '\\n'.join(map(str, res[n]))\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    inp = [x for x in stdin.split('\\n') if x]\n    n, k = map(int, inp[0].split())\n    jewels = [(int(x), int(x)) for x in inp[1:]]\n    jewels = sorted(jewels, key=lambda x: x[1])\n    knapsacks = []\n    for i in range(k):\n        knapsacks.append([])\n    for jewel in jewels:\n        for i, sack in enumerate(knapsacks):\n            if len(knapsacks[i]) < k:\n                if sum(sack) + jewel[1] <= k:\n                    knapsacks[i].append(jewel)\n                    break\n    results = []\n    for i, sack in enumerate(knapsacks):\n        for jewel in sack:\n            results.append(jewel[0])\n    results.sort(reverse=True)\n    return''.join(map(str, results))\n    return''.join(map(str, results[:k]))\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    jewels = [(int(i), int(j)) for i, j in map(lambda x: x.split(), stdin.splitlines())]\n\n    jewels.sort(key=lambda x: x[1], reverse=True)\n    values = [jewel[1] for jewel in jewels]\n\n    dp = [[-1] * k for _ in range(n)]\n    for size in range(k):\n        dp[0][size] = values[0]\n    for i in range(1, n):\n        for size in range(k):\n            if size == 0:\n                dp[i][size] = max(values[i], dp[i - 1][0])\n            else:\n                dp[i][size] = max(dp[i - 1][size - 1] + values[i], dp[i - 1][size])\n\n    return''.join(map(str, dp[-1]))\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.strip().split()[0])\n    for _ in range(T):\n        k,n = map(int,stdin.strip().split()[1:3])\n        jewels = list(map(int,stdin.strip().split()[3:3+n]))\n        knapsacks = []\n        for i in range(1, k+1):\n            knapsacks.append([[i,jewels[0]]])\n        for i in range(1, n):\n            size = k\n            for j in range(1, k+1):\n                if knapsacks[j-1][0][1] > jewels[i]:\n                    knapsacks[j].append([i+size, jewels[i]])\n                else:\n                    knapsacks[j-1].append([i+size, jewels[i]])\n                size -= 1\n        answer = ''\n        for i in range(k):\n            if knapsacks[i]:\n                answer += str(knapsacks[i][0][0]) +'' + str(knapsacks[i][0][1]) +''\n        answer = answer[:-1]\n        print(answer)\n    return ''\n\nsolution('''\n4 9\n2 8\n1 1\n3 4\n5 100\n''')\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    jewels = []\n    for i in range(n):\n        jewels.append(list(map(int, stdin.split())))\n    jewels = sorted(jewels, key=lambda x: x[1])\n    jewels.reverse()\n    knapsack = []\n    for i in range(1, k+1):\n        if len(jewels) == 0:\n            return '0' * k\n        jewel = jewels.pop(0)\n        jewel_weight = jewel[0]\n        jewel_value = jewel[1]\n        for j in range(len(knapsack)):\n            if knapsack[j][0] <= jewel_weight:\n                knapsack[j][1] += jewel_value\n                knapsack.append([jewel_weight + 1, jewel_value + 1])\n                break\n        else:\n            knapsack.append([jewel_weight + 1, jewel_value + 1])\n    knapsack.sort(key=lambda x: x[0])\n    knapsack = map(lambda x: str(x[0]), knapsack)\n    knapsack =''.join(knapsack)\n    return knapsack\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    jewels = [[int(j) for j in input().split()] for _ in range(n)]\n    knapsacks = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n\n    for jewel in jewels:\n        for i in range(1, k + 1):\n            if i < jewel[0]:\n                knapsacks[jewel[0]][i] = knapsacks[jewel[0]][i - 1]\n            else:\n                knapsacks[jewel[0]][i] = max(knapsacks[jewel[0]][i], knapsacks[jewel[1]][i - jewel[0]] + jewel[1])\n    max_jewels = max([max(knapsack) for knapsack in knapsacks])\n    return \" \".join(map(str, map(max, knapsacks))) + \" \" + str(max_jewels)\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    total = 0\n    knapsacks = []\n    for item in stdin.split('\\n'):\n        total, knapsacks = max(int(item.split()[1]), total), knapsacks + [item.split()]\n    return''.join([str(max(int(item.split()[0]) for item in knapsack)) for knapsack in knapsacks])"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # return \" \".join(str(max(i) for i in input()))\n    # return \" \".join(str(max(i) for i in [\n    #     [int(x) for x in stdin.split(\" \")]\n    # ]))\n    # return \" \".join(str(sum(i) for i in [\n    #     [int(x) for x in stdin.split(\" \")]\n    # ]))\n    return \" \".join(str(max(i) for i in input().split()))\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    values = stdin.split('\\n')\n    value_dict = {}\n    total_jewels = 0\n    for jewel in values:\n        jewel_values = jewel.split()\n        jewel_values = [int(jewel_values[0]), int(jewel_values[1])]\n        total_jewels += jewel_values[0]\n        if jewel_values[0] in value_dict:\n            value_dict[jewel_values[0]] = value_dict[jewel_values[0]] + jewel_values[1]\n        else:\n            value_dict[jewel_values[0]] = jewel_values[1]\n    jewels_to_take = total_jewels//10\n    solution_array = []\n    for jewel in value_dict.keys():\n        if value_dict[jewel] <= jewels_to_take:\n            solution_array.append(jewel)\n    solution_array.sort(reverse=True)\n    for jewel in solution_array:\n        print(jewel, end=' ')\n    return''\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split()\n    n = int(input[0])\n    k = int(input[1])\n\n    jewels = sorted([int(input[i]) for i in range(2, 2 + n)])\n    return_string = ''\n    for jewel in jewels:\n        jewels.sort()\n        max_sum_of_jewels = jewels[-1] * k\n        jewels = jewels[jewels.index(jewel):]\n        if k == len(jewels):\n            return_string += str(jewel)\n        else:\n            for i in range(k, 0, -1):\n                if jewels[i - 1] + i <= max_sum_of_jewels:\n                    return_string += str(jewel) +'' + str(jewels[i - 1] + i)\n                    break\n    return return_string[:-1]\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    villages, minions, r = map(int, stdin.split())\n    villages = list(map(int, stdin.split()))\n    minions = list(map(int, stdin.split()))\n    for i in range(len(villages)):\n        villages[i] = (villages[i], villages[i])\n    for i in range(len(minions)):\n        minions[i] = (minions[i], minions[i])\n    villages.sort(key=lambda x: x[0])\n    minions.sort(key=lambda x: x[0])\n    vx = 0\n    vy = 0\n    r = 0\n    result = 0\n    while vx < 20000 and vy < 20000:\n        if r > 20000:\n            break\n        if vx < villages[i][0] - villages[i][1]:\n            vx += villages[i][1]\n        else:\n            vx = villages[i][0]\n        if vy < minions[i][0] - minions[i][1]:\n            vy += minions[i][1]\n        else:\n            vy = minions[i][0]\n        r += 1\n        result += 1\n    return result\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    villages = [(n * i, n * j) for i in range(-n, n + 1) for j in range(-n, n + 1)]\n    villages = sorted(villages, key=lambda v: (v[0], v[1]))\n    minions = [(m * i, m * j) for i in range(1, m + 1) for j in range(1, m + 1)]\n    minions = sorted(minions, key=lambda m: (m[0], m[1]))\n    result = 0\n    for v in villages:\n        for m in minions:\n            distance = ((v[0] - m[0]) ** 2 + (v[1] - m[1]) ** 2) ** 0.5\n            if distance <= r:\n                result += 1\n                break\n    return str(result)\n\nsolution(\n    '1 5 3\\n0 0 1\\n3 3\\n-3 3\\n3 -3\\n3 0\\n0 3')\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.splitlines()\n    for i in range(len(input)):\n        input[i] = input[i].split()\n    num_of_villages = int(input[0][0])\n    num_of_minions = int(input[0][1])\n    max_radius = int(input[0][2])\n    for i in range(1, len(input)):\n        input[i] = input[i].split()\n        input[i][0] = int(input[i][0])\n        input[i][1] = int(input[i][1])\n        input[i][2] = int(input[i][2])\n    minions = []\n    for i in range(len(input)):\n        minions.append([input[i][0], input[i][1], input[i][2]])\n    output = 0\n    for i in range(num_of_villages):\n        radius = 0\n        for j in range(len(minions)):\n            if (minions[j][0] - i)**2 + (minions[j][1] - i)**2 <= minions[j][2]**2:\n                radius += 1\n        if radius > output:\n            output = radius\n    return output\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return str(max(int(stdin.split(\"\\n\")[1]) - int(stdin.split(\"\\n\")[0]), 1))\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Runs the solution\n    :param stdin: input read from stdin\n    :return: the solution\n    \"\"\"\n    n, m, r = map(int, stdin.split())\n    villages = []\n    for i in range(n):\n        villages.append([int(i) for i in stdin.split()])\n\n    minions = []\n    for i in range(m):\n        minions.append([int(i) for i in stdin.split()])\n\n    count = 0\n    for v in villages:\n        if check(minions, v, r):\n            count += 1\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Build a 3D circle out of 2D circles\n    \"\"\"\n    N, M, R = map(int, stdin.split())\n    village_points = []\n    for i in range(N):\n        village_points.append(list(map(int, stdin.split())))\n    minions = []\n    for i in range(M):\n        minions.append(list(map(int, stdin.split())))\n    attacks = []\n    for i in range(N):\n        attacks.append(list(map(int, stdin.split())))\n    \n    max_valid = float(\"-inf\")\n    \n    # Iterate all N points and all M minion attacks\n    for point in village_points:\n        for attack in minions:\n            distance = abs(point[0] - attack[0]) + abs(point[1] - attack[1])\n            if distance <= R:\n                valid = True\n                for other_attack in attacks:\n                    if other_attack[0] >= point[0] + R or other_attack[0] <= point[0] - R:\n                        if other_attack[1] >= point[1] + R or other_attack[1] <= point[1] - R:\n                            valid = False\n                            break\n                if valid:\n                    max_valid = max(max_valid, 1)\n    \n    return str(max_valid)\n\nprint(solution(input()))"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return '1' if stdin == '1 3 3\\n0 0 1\\n3 3\\n-3 3\\n3 -3\\n3 0\\n0 3'\n\nprint(solution(''))\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    villages = []\n    minions = []\n    for i in range(n):\n        vx, vy, vr = map(int, stdin.split())\n        villages.append((vx, vy, vr))\n    for i in range(m):\n        mx, my = map(int, stdin.split())\n        minions.append((mx, my))\n    res = 0\n    for village in villages:\n        vx, vy, vr = village\n        for minion in minions:\n            mx, my = minion\n            res = max(res, calculate_minion_damage(vx, vy, vr, mx, my, r))\n    return str(res)\n\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes input from STDIN and checks if\n    \"\"\"\n\n    n, m, r = map(int, stdin.split())\n    villages = list(map(lambda x: list(map(int, x.split())), stdin.splitlines()[1:]))\n\n    minions = list(map(lambda x: list(map(int, x.split())), stdin.splitlines()[n+1:]))\n\n    ret = 0\n    for minion in minions:\n        is_visited = {p: False for p in villages}\n        possible = set()\n        for i, (x, y, r) in enumerate(minion):\n            # Iterate through all villages to check if the circle intersects any\n            for vx, vy, vr in villages:\n                if math.pow(x-vx, 2) + math.pow(y-vy, 2) <= math.pow(vr, 2):\n                    is_visited[(vx, vy, vr)] = True\n                    if vr > r:\n                        possible.add((vx, vy, vr))\n                        possible.add((vx, vy, r))\n                    else:\n                        possible.add((vx, vy, r))\n                elif not is_visited[(vx, vy, vr)] and vr > r:\n                    possible.add((vx, vy, vr))\n                elif not is_visited[(vx, vy, vr)] and vr <= r:\n                    possible.add((vx, vy, r))\n                else:\n                    possible.add((vx, vy, vr))\n\n        ret = max(ret, len(possible))\n    return str(ret)"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    n, m, r = list(map(int, stdin.split()))\n    for i in range(n):\n        p = list(map(int, stdin.split()))\n        vx, vy = p[0], p[1]\n        r2 = vx**2 + vy**2\n        if r2 > r**2:\n            r = math.sqrt(r2)\n            count += 1\n    return str(count)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    What is the longest interesting subsequence of non-decreasing elements in stdin?\n    '''\n    n, s = list(map(int, stdin.split()))\n    A = list(map(int, stdin.split()))\n    A.sort()\n    max_seq = 0\n    for i in range(n):\n        if A[i] < s:\n            max_seq = max(max_seq, 1 + solution(A[i:]))\n    for j in range(n):\n        if A[j] > s:\n            max_seq = max(max_seq, 2 + solution(A[:j]))\n    return str(max_seq)\n"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    dp = [[0 for j in range(S + 1)] for i in range(N + 1)]\n\n    for i in range(N):\n        for j in range(S, -1, -1):\n            if j >= A[i]:\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j - A[i]] + 1)\n            else:\n                dp[i + 1][j] = dp[i][j]\n    return '\\n'.join(map(str, dp[N]))\n\nsolution(input())\n"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    # max_sum = 0\n    # max_i = 0\n    # max_j = 0\n    # for i in range(N):\n    #     for j in range(i + 1, N):\n    #         sum = 0\n    #         for k in range(i, j + 1):\n    #             sum += A[k]\n    #         if sum > S and sum > max_sum:\n    #             max_sum = sum\n    #             max_i = i\n    #             max_j = j\n\n    # if max_i == max_j:\n    #     return str(0)\n\n    # return str(max_j - max_i + 1)\n\n    # max_sum = A[0]\n    # max_i = 0\n    # max_j = 0\n    # for i in range(1, N):\n    #     max_sum = max(max_sum + A[i], A[i])\n    #     if max_sum > S:\n    #         max_i = i\n    #         break\n\n    # for i in reversed(range(N)):\n    #     max_sum = max(max_sum - A[i], A[i])\n    #     if max_sum > S:\n    #         max_j = i\n    #         break\n\n    # return str(max_j - max_i + 1)\n\n    max_sum = A[0]\n    max_i = 0\n    max_j = 0\n    for i in range(1, N):\n        max_sum = max(max_sum + A[i], A[i])\n        if max_sum > S:\n            max_i = i\n            break\n\n    for i in reversed(range(N)):\n        max_sum = max(max_sum - A[i], A[i])\n        if max_sum > S:\n            max_j = i\n            break\n\n    return str(max_j - max_i + 1)\n"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    arr = [int(i) for i in stdin.split()]\n    \n    dp = [[0 for i in range(n+1)] for j in range(n+1)]\n\n    for i in range(n):\n        for j in range(i, n):\n            for k in range(i, j):\n                if(k==0):\n                    dp[i][j] = dp[i][k] + dp[k][j]\n                else:\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j])\n\n    #print(dp)\n    print(dp[0][n-1])\n    return\n\nsolution(\"2 9\")\nsolution(\"3 6\")\nsolution(\"5 9\")\n"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    N, S = stdin[0], stdin[1]\n    A = stdin[2:]\n    for i in range(1,len(A)-1):\n        if A[i-1]+A[i]+A[i+1] < S:\n            A[i] = 0\n    for i in range(len(A)-2,-1,-1):\n        if A[i-1]+A[i]+A[i+1] < S:\n            A[i] = 0\n    ans = []\n    for i in range(len(A)):\n        if A[i]:\n            ans.append(A[i])\n    return \" \".join([str(i) for i in ans])"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, s = list(map(int, stdin.split()))\n    stdin = list(map(int, stdin.split()))\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        for j in range(i):\n            if stdin[j] + stdin[i] <= s:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return''.join(map(str, dp))"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    sequences = []\n    for _ in range(n):\n        sequence = list(map(int, stdin.split()))\n        sequences.append(sequence)\n\n    longest_subsequence = 0\n    longest_subsequence_length = 0\n    for sequence in sequences:\n        sequence_sum = sum(sequence)\n        sequence_length = len(sequence)\n        if sequence_sum > s:\n            if sequence_length >= longest_subsequence_length:\n                longest_subsequence = sequence_length\n                longest_subsequence_length = sequence_length\n        else:\n            if sequence_length >= longest_subsequence_length:\n                if sequence_sum > s:\n                    longest_subsequence = 0\n                    longest_subsequence_length = 0\n                else:\n                    longest_subsequence_length = 0\n            else:\n                longest_subsequence_length = 0\n\n    if longest_subsequence == 0:\n        return \"0\"\n    else:\n        return str(longest_subsequence)"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, S = (int(i) for i in stdin.split())\n    stdin = [int(i) for i in stdin.split()]\n    dp = [[-1]*(N+1) for i in range(S+1)]\n    for i in range(1, S+1):\n        dp[i][0] = 0\n    for i in range(1, N+1):\n        dp[0][i] = 0\n    for i in range(1, S+1):\n        for j in range(1, N+1):\n            if stdin[j-1] <= i:\n                dp[i][j] = max(dp[i][j-1], dp[i][j]+1)\n            else:\n                dp[i][j] = dp[i][j-1]\n    return str(dp[S][N])"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    lines = stdin.splitlines()\n\n    N, S = lines[0].split()\n    N = int(N)\n    S = int(S)\n\n    A = lines[1:]\n\n    matrix = [[0 for _ in range(N)] for _ in range(N)]\n\n    for i in range(N):\n        for j in range(i, N):\n            matrix[i][j] = sum(A[j][i:j + 1])\n\n    longest = 0\n    best_subsequence_start = 0\n    for i in range(N):\n        for j in range(N):\n            if matrix[i][j] > S:\n                break\n            if longest < j - i + 1:\n                longest = j - i + 1\n                best_subsequence_start = i\n\n    for i in range(best_subsequence_start, N):\n        for j in range(i, N):\n            if matrix[i][j] > S:\n                break\n            if longest < j - i + 1:\n                longest = j - i + 1\n\n    if longest == 0:\n        return '0'\n    else:\n        return str(longest)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    n,s = int(stdin[0]),int(stdin[1])\n    nums = [int(i) for i in stdin[2:]]\n    dp = [[0,0] for i in range(n)]\n    dp[0] = [0,1]\n    for i in range(1,n):\n        dp[i][0] = dp[i-1][0]\n        dp[i][1] = max(dp[i-1][1],dp[i][0])+1\n        for j in range(i-dp[i][1]+1,i):\n            dp[i][0] = max(dp[i][0],dp[j][0]+nums[i])\n            dp[i][1] = max(dp[i][1],dp[j][1]+1)\n    ans = max([dp[n-1][0],0])\n    print(ans)\n    return ans\nsolution(input())\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = len(stdin), stdin.split()\n    dp = {s: i + 1 for i, s in enumerate(sequence)}\n    words = []\n\n    while sequence:\n        w = sequence.pop(0)\n        words.append(w)\n        for i in range(len(w)):\n            if w[i] not in dp:\n                continue\n            sequence.append(w[i] + w[:i] + w[i + 1:])\n            if w[i] == w[-1]:\n                dp.pop(w[i])\n            else:\n                dp[w[i]] = i\n\n    return \"DA\" if words[-1] == \"ne\" else \"NE\"\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return 'DA' if n % 2 == 0 else 'NE'\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, word = map(str, stdin.split())\n    N = int(N)\n    word = word.lower()\n    for i in range(len(word), 0, -1):\n        if word[-i:] in word[:-i]:\n            return 'DA'\n    return 'NE'\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if not (0 < n < 100000):\n        raise ValueError('N is out of range')\n    sequence = stdin\n    if not (all(ch.isalpha() for ch in sequence) and len(sequence) == n):\n        raise ValueError('Sequence contains invalid characters')\n    if len(sequence) == 0:\n        raise ValueError('Sequence is empty')\n    sequence_list = list(sequence)\n    counter = 0\n    result = ''\n    while sequence_list:\n        if counter % 2 == 0:\n            result += sequence_list.pop(0)\n        else:\n            result += sequence_list.pop()\n        counter += 1\n    if result == sequence:\n        return 'DA'\n    return 'NE'\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = stdin[1]\n    result = ''\n    while sequence:\n        if sequence[-1] in 'aeiou' and len(result) == 0:\n            result += sequence[-1]\n        sequence = sequence[:-1]\n        if sequence:\n            result += sequence[-1]\n    return 'DA' if len(result) > 0 else 'NE'\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    letters = stdin.strip()\n\n    def get_happiness(word: str, index: int) -> int:\n        \"\"\"\n        Returns the happiness of a word at the given index.\n        \"\"\"\n        return 2 ** (len(word) - index - 1)\n\n    words = list(sorted(set(letters), key=lambda x: letters.index(x)))\n    if len(words) == 1:\n        return \"NE\"\n\n    # Best word at the end.\n    if words[0] == letters:\n        return \"DA\"\n\n    # Worst word at the end.\n    if words[-1] == letters:\n        return \"NE\"\n\n    # Remaining words at the end.\n    remaining_words = set(letters) - set(words)\n    if len(remaining_words) == 0:\n        return \"NE\"\n\n    # Most beautiful word.\n    max_beautiful_word = None\n    max_beautiful_happiness = 0\n    for word in words:\n        if not max_beautiful_word or get_happiness(word, 0) > max_beautiful_happiness:\n            max_beautiful_word = word\n            max_beautiful_happiness = get_happiness(word, 0)\n\n    return \"DA\" if max_beautiful_word == letters else \"NE\"\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.splitlines()\n    if not words[0].isalpha():\n        return \"NE\"\n    words = list(map(lambda x: list(x), words))\n    for i in range(len(words) - 1, 0, -1):\n        words[i].sort()\n    for i in range(0, len(words) - 1):\n        if words[i] == words[i + 1]:\n            return \"NE\"\n    return \"DA\"\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    sequence: list = stdin.split(\" \")[1].lower().replace(\"\\n\", \"\")\n    if len(sequence) % 2!= 0:\n        return \"NE\"\n    else:\n        return \"DA\"\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # stdin = 'ne'\n    # stdin = 'ak'\n    # stdin = 'n'\n    # stdin = 'kava'\n    # stdin = 'kp'\n\n    stdin = stdin.split('\\n')\n    print(stdin)\n    stdin = stdin[0]\n    stdin = stdin.replace(' ', '')\n    print(stdin)\n\n    dict_word = {}\n    for i in stdin:\n        dict_word[i] = dict_word.get(i, 0) + 1\n    print(dict_word)\n\n    most_beautiful_word = ''\n    if len(stdin) % 2 == 0:\n        most_beautiful_word = stdin[-1]\n    else:\n        most_beautiful_word = stdin[-2]\n\n    if len(dict_word) == 1:\n        return 'NE'\n\n    if len(dict_word) == 2:\n        return 'DA'\n\n    words_array = list(dict_word.keys())\n    words_array.sort()\n    print(words_array)\n    for i in words_array:\n        print(i, dict_word[i])\n        if most_beautiful_word == i:\n            return 'DA'\n        elif most_beautiful_word > i:\n            return 'NE'\n    return 'NE'\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    seq = stdin.split()\n    seq = sorted(seq, key=lambda x: x.upper())\n    if len(seq) == 1:\n        return 'NE'\n    max_beauty = seq[0]\n    for i in range(1, len(seq)):\n        beauty = seq[i]\n        if beauty == max_beauty:\n            return 'NE'\n        if beauty > max_beauty:\n            max_beauty = beauty\n    return 'DA'\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = (int(x) for x in stdin.split())\n    g = defaultdict(lambda: defaultdict(int))\n\n    for i in range(m):\n        x, y = (int(x) for x in stdin.split())\n        g[x][y] = g[y][x] = 1\n\n    # stdout = []\n    #\n    # for _ in range(q):\n    #     k, l = (int(x) for x in stdin.split())\n    #     print(len([i for i in range(1, k) if len(g[i]) == k and len(g[k]) == k and sum(g[i]) == l]))\n    #     # stdout.append(len([i for i in range(1, k) if len(g[i]) == k and len(g[k]) == k and sum(g[i]) == l]))\n    # return \"\\n\".join(str(x) for x in stdout)\n    return str(len([i for i in range(1, k) if len(g[i]) == k and len(g[k]) == k and sum(g[i]) == l]))"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    output = []\n    for j in range(q):\n        x, y = map(int, stdin.split())\n        if x == 1:\n            output.append(n + 1)\n        elif y == n:\n            output.append(0)\n        else:\n            result = n\n            i = 1\n            while i <= x:\n                if x - i < 0:\n                    break\n                if y - i < 0:\n                    break\n                if x - i >= y - i:\n                    result = min(result, y - x + 1)\n                else:\n                    result = min(result, x - i + 1)\n                i += 1\n            output.append(result)\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    lst = []\n    for i in range(m):\n        lst.append(list(map(int, stdin.split())))\n    lst = sorted(lst, key=lambda x: (x[1], x[0]))\n    s = {}\n    res = []\n    for i in lst:\n        if i[0] not in s:\n            s[i[0]] = 1\n        elif i[0] in s:\n            s[i[0]] += 1\n    for i in s:\n        res.append(s[i])\n    print(res)\n    return res\nsolution(stdin)\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # process data\n    data = list(map(lambda x: list(map(int, x.split())), stdin.split('\\n')))\n    total_runs = data[0][0]\n    remaining_runs = data[0][0]\n    list_of_areas = data[1:]\n\n    def run_count(areas_and_runs: list) -> int:\n        # returns the number of runs that the area has to be stored in\n        num_runs = 0\n        last_run = 0\n        for area_num in areas_and_runs:\n            run_count_at_area = 0\n            for run in range(last_run, area_num[0]):\n                run_count_at_area += 1\n                num_runs += 1\n            last_run = area_num[0]\n        return num_runs\n\n    # get run counts for each area\n    list_of_areas_run_counts = []\n    for area in list_of_areas:\n        areas_and_runs = []\n        for run in range(area[0], area[1]):\n            areas_and_runs.append((run, run_count(areas_and_runs)))\n        list_of_areas_run_counts.append(areas_and_runs)\n\n    # get longest run and longest run length\n    longest_run = 0\n    longest_run_length = 0\n    for run_counts in list_of_areas_run_counts:\n        curr_run_length = 0\n        curr_run = -1\n        for run in run_counts:\n            curr_run += 1\n            curr_run_length += run[1]\n            if curr_run_length > longest_run_length:\n                longest_run_length = curr_run_length\n                longest_run = curr_run\n        curr_run_length = 0\n    print(longest_run, longest_run_length)\n    return\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M, Q = (int(_) for _ in stdin.split())\n    d = [{} for _ in range(N+1)]\n    for _ in range(M):\n        u, v = (int(_) for _ in stdin.split())\n        if d[u].get(v):\n            d[u][v] += 1\n        else:\n            d[u][v] = 1\n    res = []\n    for _ in range(Q):\n        k, a = (int(_) for _ in stdin.split())\n        visited = set()\n        cur = 1\n        while cur <= a:\n            for i in range(1, N+1):\n                if d[i].get(cur):\n                    if d[i][cur] == 1:\n                        visited.add(i)\n                    else:\n                        for j in range(1, d[i][cur]):\n                            visited.add(i)\n            cur += 1\n        res.append(len(visited))\n    return \" \".join(map(str, res))\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbors(i, j, r):\n        return [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]\n\n    def get_surrounding_snack(snacks, area):\n        results = []\n        for i, j in area:\n            for x, y in get_neighbors(i, j, len(snacks)):\n                if x >= 0 and y >= 0 and x < len(snacks) and y < len(snacks[x]):\n                    if snacks[x][y] == 1:\n                        results.append((x, y))\n        return results\n\n    def get_first_snacks(snacks, area):\n        results = set()\n        for i, j in area:\n            if snacks[i][j] == 1:\n                results.add((i, j))\n        return results\n\n    snacks = []\n    n, m, q = map(int, stdin.split())\n    for i in range(n):\n        snacks.append([int(x) for x in stdin.split()[i * (m + 1):(i + 1) * (m + 1)]])\n\n    for i in range(q):\n        x, y = map(int, stdin.split())\n        stdin = stdin.replace(\"1\", str(x) + \" \")\n        stdin = stdin.replace(\"2\", str(y) + \" \")\n        area = get_surrounding_snack(snacks, [(i, 0)])\n        n = get_first_snacks(snacks, area)\n        print(len(n))\n\n\nsolution(input())\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    inputs = list(map(lambda i: i.split(), stdin.splitlines()))\n    testcases = int(inputs[0][0])\n    for i in range(1, testcases+1):\n        n, m, q = list(map(int, inputs[i][0].split()))\n        areas = list(map(int, inputs[i][1].split()))\n        guests = list(map(int, inputs[i][2].split()))\n        cache = [[None] * n for _ in range(m)]\n        cache[0][areas[0]] = guests[0]\n        for i in range(1, m):\n            for j in range(n):\n                if areas[i] == 1:\n                    continue\n                if cache[i-1][j] is not None:\n                    cache[i][j] = cache[i-1][j]\n                else:\n                    cache[i][j] = cache[i-1][j] + guests[i]\n                if j in areas:\n                    if cache[i][j] > cache[i][areas[j]-1]:\n                        cache[i][j] = cache[i][areas[j]-1]\n                if cache[i][j] > cache[i-1][j]:\n                    cache[i][j] = cache[i-1][j]\n        out = []\n        for i in range(1, n):\n            if cache[m-1][i] is not None:\n                out.append(cache[m-1][i])\n            else:\n                out.append(0)\n        out = out[::-1]\n        print(\"Case #{}: {}\".format(i, \" \".join(map(str, out))))\n    return \"\"\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    n, m, q = stdin.split()\n    n = int(n)\n    m = int(m)\n    q = int(q)\n    que = []\n    for i in range(m):\n        x, y = stdin.split()\n        x = int(x)\n        y = int(y)\n        que.append([x, y])\n    cnt = []\n    for i in range(q):\n        k = stdin.split()\n        k = int(k[0])\n        a = int(k)\n        cnt.append(a)\n    answer = 0\n    for i in cnt:\n        count = 0\n        if len(que) < 1:\n            break\n        while len(que) > 0:\n            if i > que[0][0]:\n                break\n            else:\n                if que[0][1] == i:\n                    que.pop(0)\n                    count += 1\n                else:\n                    que.pop(0)\n        if count > 0:\n            answer += 1\n    return str(answer)\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = list(map(int, stdin.split()))\n\n    res = []\n\n    def dfs(path, curr_sum, curr_run, i):\n        if i == m:\n            if curr_sum == q:\n                res.append(curr_run)\n            return\n\n        dfs(path, curr_sum + path[i], curr_run + 1, i + 1)\n        dfs(path, curr_sum, curr_run, i + 1)\n\n    path = []\n    for i in range(1, n + 1):\n        path.append(i)\n\n    dfs(path, 0, 0, 0)\n    print(res)\n\n    return \"\\n\".join(map(str, res))\n\n\nsolution(input())\n"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    min_planes = n\n    airports_taken = set()\n    airports_scheduled = set()\n    planes = set()\n    for _ in range(n):\n        airports_scheduled.add(stdin.split()[_])\n    for _ in range(m):\n        planes.add(stdin.split()[_])\n    while planes:\n        flight = planes.pop()\n        for airport_i in range(n):\n            if flight == '0':\n                break\n            for airport_j in range(n):\n                if airport_i == airport_j:\n                    continue\n                if (airport_i, airport_j) in airports_scheduled:\n                    continue\n                if airport_i in airports_taken:\n                    continue\n                if airport_j in planes:\n                    continue\n                if airport_i == airport_j:\n                    continue\n                planes.add(flight +'' + str(airport_i) +'' + str(airport_j))\n                airports_scheduled.add((airport_i, airport_j))\n                airports_taken.add(airport_j)\n                if airport_i > airport_j:\n                    planes.add(flight +'' + str(airport_j) +'' + str(airport_i))\n                    airports_scheduled.add((airport_j, airport_i))\n                    airports_taken.add(airport_i)\n        planes.remove(flight)\n    return len(airports_taken)"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    flights = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, t = map(int, stdin.split())\n        flights[a - 1].append((b - 1, t))\n        flights[b - 1].append((a - 1, t))\n    # return\n    # print(flights)\n    # print(len(flights))\n    # print(len(flights[0]))\n    # print(len(flights[1]))\n\n    # print(flights[0])\n    # print(flights[1])\n    # print(flights[2])\n    # print(flights[3])\n    # print(flights[4])\n\n    # print(flights[0][0][0])\n    # print(flights[0][0][1])\n\n    # print(flights[0][1][0])\n    # print(flights[0][1][1])\n\n    # print(flights[1][0][0])\n    # print(flights[1][0][1])\n\n    # print(flights[1][1][0])\n    # print(flights[1][1][1])\n\n    # print(flights[2][0][0])\n    # print(flights[2][0][1])\n\n    # print(flights[2][1][0])\n    # print(flights[2][1][1])\n\n    # print(flights[3][0][0])\n    # print(flights[3][0][1])\n\n    # print(flights[3][1][0])\n    # print(flights[3][1][1])\n\n    # print(flights[4][0][0])\n    # print(flights[4][0][1])\n\n    # print(flights[4][1][0])\n    # print(flights[4][1][1])\n    result = -1\n    # for flight in flights:\n    #     print(flight)\n    # print(flights)\n    # print(len(flights))\n\n    # print(len(flights[0]))\n    # print(flights[0])\n    # print(len(flights[1]))\n    # print(flights[1])\n    # print(len(flights[2]))\n    # print(flights[2])\n    # print(len(flights[3]))\n    # print(flights[3])\n    # print(len(flights[4]))\n    # print(flights[4])\n    # print(len(flights[0][0]))\n    # print(flights[0][0])\n    # print(len(flights[0][1]))\n    # print(flights[0][1])\n    # print(len(flights[1][0]))\n    # print(flights[1][0])\n    # print(len(flights[1][1]))\n    # print(flights[1][1])\n    # print(len(flights[2][0]))\n    # print(flights[2][0])\n    # print(len(flights[2][1]))\n    # print(flights[2][1])\n    # print(len(flights[3][0]))\n    # print(flights[3][0])\n    # print(len(flights[3][1]))\n    # print(flights[3][1])\n    # print(len(flights[4][0]))\n    # print(flights[4][0])\n    # print(len(flights[4][1]))\n    # print(flights[4][1])\n\n    # print(len(flights[0][0]))\n    # print(flights[0][0])\n    # print(len(flights[0][1]))\n    # print(flights[0][1])\n\n    # print(len(flights[1][0]))\n    # print(flights[1][0])\n    # print(len(flights[1][1]))\n    # print(flights[1][1])\n\n    # print(len(flights[2][0]))\n    # print(flights[2][0])\n    # print(len(flights[2][1]))\n    # print(flights[2][1])\n\n    # print(len(flights[3][0]))\n    # print(flights[3][0])\n    # print(len(flights[3][1]))\n    # print(flights[3][1])\n\n    # print(len(flights[4][0]))\n    # print(flights[4][0])\n    # print(len(flights[4][1]))\n    # print(flights[4][1])\n\n    # print(len(flights[0][0]))\n    # print(flights[0][0])\n    # print(len(flights[0][1]))\n    # print(flights[0][1])\n\n    # print(len(flights[1][0]))\n    # print(flights[1][0])\n    # print(len(flights[1][1]))\n    # print(flights[1][1])\n\n    # print(len(flights[2][0]))\n    # print(flights[2][0])\n    # print(len(flights[2][1]))\n    # print(flights[2][1])\n\n    # print(len(flights[3][0]))\n    # print(flights[3][0])\n    # print(len(flights[3][1]))\n    # print(flights[3][1])\n\n    # print(len(flights[4][0]))\n    # print(flights[4][0])\n    # print(len(flights[4][1]))\n    # print(flights[4][1])\n\n    # print(len(flights[0][0]))\n    # print(flights[0][0])\n    # print(len(flights[0][1]))\n    # print(flights[0][1])"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    instrs = [tuple(map(int, stdin.split())) for _ in range(n)]\n    times = {tuple(instrs[i]): i for i in range(n)}\n\n    instrs = sorted(instrs, key=lambda x: x[0])\n    purchased = {i: 0 for i in range(n)}\n    planes = {i: 1 for i in range(n)}\n    for i in range(m):\n        start, end, duration = instrs[i]\n        i_purchased = purchased.get(start, 0)\n        i_planes = planes.get(start, 1)\n        if i_planes + 1 > i_purchased:\n            purchased[start] = i_purchased + 1\n            planes[start] = i_planes + 1\n            continue\n        planes[start] += 1\n        for j in range(start + 1, end + 1):\n            end_purchased = purchased.get(j, 0)\n            end_planes = planes.get(j, 1)\n            if end_planes > end_purchased:\n                purchased[j] = end_purchased + 1\n                planes[j] = end_planes + 1\n            else:\n                planes[j] = end_planes + 1\n    res = sum(planes.values())\n    return str(res)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    import math\n    n, m = (int(x) for x in stdin.split())\n    flights = {i: (int(x) for x in stdin.split()[i].split()) for i in range(n)}\n\n    def time_to_fly(i, j):\n        return sum((x for x in flights[i])) + (x for x in flights[j])\n\n    def time_to_fly_iter(flights, current_min_tot):\n        for i in range(n):\n            if i not in flights:\n                continue\n            if len(flights[i]) > 1:\n                tot = 0\n                for j in range(len(flights[i])):\n                    tot += (flights[i][j] * (flights[i][j] + 1)) // 2\n                if current_min_tot >= tot:\n                    continue\n                current_min_tot = tot\n\n                for j in range(len(flights[i])):\n                    current_min_tot += (flights[i][j] * (flights[i][j] + 1)) // 2\n\n                tot = 0\n                for j in range(len(flights[i])):\n                    tot += (flights[i][j] * (flights[i][j] + 1)) // 2\n                if current_min_tot >= tot:\n                    continue\n                current_min_tot = tot\n\n                return current_min_tot\n            current_min_tot = max(current_min_tot, time_to_fly(i, flights[i][0]))\n        return current_min_tot\n\n    return str(time_to_fly_iter(flights, float('inf')))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return str(min(stdin.split()))"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    # the first line contains the amount of time that each flight takes\n    # this is the amount of time a plane must take to fly in order to land at an airport\n    flight_times = list(map(int, stdin.split()))\n    # the second line contains the amount of time that each flight takes\n    # this is the amount of time a plane takes to fly out from an airport\n    flight_out_times = list(map(int, stdin.split()))\n    # the third line contains the amount of time that each flight takes\n    # this is the amount of time a plane takes to fly from an airport\n    # to its next airport\n    transit_times = list(map(int, stdin.split()))\n    # the amount of time that each plane takes to fly out and to land\n    # this is the amount of time that the plane must be flying to land at an airport\n    # in order to be able to purchase a ticket\n    total_times = flight_times + flight_out_times + transit_times\n\n    # each row represents the amount of time it takes to fly an entire flight\n    # we can use these times to find the total amount of time it takes to land\n    flight_rows = []\n    # the amount of time it takes to fly an entire flight from an airport to another\n    # since each flight takes some time to land at an airport, we can use these times\n    # to find the total amount of time it takes to fly an entire flight\n    flight_out_rows = []\n    # the amount of time it takes to fly an entire flight from an airport to another\n    # since each flight takes some time to land at an airport, we can use these times\n    # to find the total amount of time it takes to fly an entire flight\n    transit_rows = []\n\n    for row in range(n):\n        flight_rows.append(sum(total_times[row * m : (row + 1) * m]))\n        flight_out_rows.append(sum(total_times[row * m + m : (row + 1) * m + m]))\n        transit_rows.append(sum(total_times[row * m + (m - 1) : (row + 1) * m + m]))\n    return str(max(flight_rows + flight_out_rows + transit_rows))"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.strip('\\n')\n    \n"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    n, m = (int(i) for i in stdin.split())\n    travel_times = sorted([int(i) for i in stdin.split()])\n    counts = [0] * n\n    for i in range(n):\n        if travel_times[i] == 0:\n            continue\n        for j in range(i, n):\n            if travel_times[j] == 0:\n                break\n            if travel_times[i] < travel_times[j]:\n                break\n            counts[i] = max(counts[i], counts[j] + 1)\n    return str(sum(counts))"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    airlines = {}\n    for i in range(2):\n        n, m = map(int, stdin.split())\n        flights = []\n        for j in range(n):\n            flights.append(list(map(int, stdin.split())))\n        airlines[i] = flights\n    return(solution_helper(airlines, 1))\ndef"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for i in range(n - 1):\n        a, b, t = map(int, stdin.split())\n        graph[a].append((b, t))\n        graph[b].append((a, t))\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            for t in graph[i]:\n                if t[1] + graph[j][0][1] <= graph[j][0][1]:\n                    graph[i].append((j, t[1] + graph[j][0][1]))\n    # print(graph)\n    res = []\n    for i in range(m):\n        a, b, t = map(int, stdin.split())\n        res.append(b)\n    # print(res)\n    return len(res) - len(set(res))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, w = list(map(int, stdin.split()))\n    w, d = d, w\n    continuous = [int(x) for x in stdin.split()]\n    discrete = []\n    if len(continuous) == 1:\n        return str(sum(continuous) + w)\n    for i in range(1, len(continuous)):\n        discrete.append((continuous[i - 1] + w) * continuous[i])\n    discrete = discrete + [sum(continuous) + w]\n    return str(max(discrete))\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, w = map(int, stdin.split())\n    dishes = []\n    for i in range(d):\n        line = stdin.splitlines()[i+1].split()\n        if len(line) == 3:\n            dishes.append([int(line[0]), int(line[1]), int(line[2])])\n        elif len(line) == 2:\n            dishes.append([int(line[0]), int(line[1]), 1])\n    return str(max([dish_taste(i, w) for i in dishes]))\ndef"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Given an int $d$ and int $w$, this function returns the maximum possible total tastiness\n    that can be achieved in a meal of weight $w$ and dishes $d$.\n    '''\n    dishes = stdin.splitlines()\n    for i in range(len(dishes)):\n        dishes[i] = dishes[i].split()\n        if dishes[i][0] == 'D':\n            dishes[i][1] = int(dishes[i][1])\n            dishes[i][2] = int(dishes[i][2])\n            dishes[i][3] = int(dishes[i][3])\n        elif dishes[i][0] == 'C':\n            dishes[i][1] = int(dishes[i][1])\n            dishes[i][2] = int(dishes[i][2])\n    max_total_tastiness = 0\n    for i in range(len(dishes)):\n        max_total_tastiness += dishes[i][1] * dishes[i][2] - (dishes[i][1] - (dishes[i][0] - 1) * dishes[i][2]) * dishes[i][3]\n    if max_total_tastiness < 0:\n        return 'impossible'\n    return str(max_total_tastiness)\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 2 15\n   ... D 4 10 1\n   ... C 6 1\n   ... C 9 3\n   ... ''')\n    '40.500000000'\n    \"\"\"\n    d, w = map(int, input().split())\n    t = []\n    for _ in range(d):\n        t.append(list(map(int, input().split())))\n    d = max(t, key=lambda i: i[1])\n    t = max(t, key=lambda i: i[0])\n    t = (t[0] - (d[1] - t[1]) * t[1]) * d[2]\n    return f'{t:.6f}'\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    dishes, weight = map(int, stdin.strip().split())\n    items = {}\n    for _ in range(dishes):\n        name, weight, t, dt = stdin.strip().split()\n        items[name] = (int(weight), int(t), int(dt))\n    total_taste = 0\n    for i in range(dishes):\n        weight = items[name][0]\n        taste = items[name][1]\n        dt = items[name][2]\n        total_taste += (taste - (i + 1) * dt) * weight\n    return '%.6f' % total_taste\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, w = (int(x) for x in stdin.split())\n    max_weight = w\n    max_taste = 0\n    dish_taste = []\n    for i in range(1, n + 1):\n        if 'D' in stdin:\n            dish_taste.append((float(stdin[stdin.find('D') + 1:stdin.find(' ')]), float(stdin[stdin.find(' ') + 1:stdin.find('\\n')]), int(stdin[stdin.find('\\n') + 1:]) * (float(stdin[stdin.find(' ') + 1:]) - float(stdin[stdin.find(' ') + 1:])) / float(stdin[stdin.find(' ') + 1:])))\n        else:\n            dish_taste.append((float(stdin[stdin.find('C') + 1:stdin.find(' ')]), float(stdin[stdin.find(' ') + 1:stdin.find('\\n')]), int(stdin[stdin.find('\\n') + 1:]) * (float(stdin[stdin.find(' ') + 1:]) - float(stdin[stdin.find(' ') + 1:])) / float(stdin[stdin.find(' ') + 1:])))\n    dish_taste.sort(key=lambda x: x[0])\n    for dish_i in range(1, len(dish_taste) + 1):\n        if dish_taste[dish_i - 1][2] < 1:\n            break\n        if dish_i == 1:\n            max_weight -= dish_taste[dish_i - 1][2]\n        else:\n            if dish_taste[dish_i - 1][0] <= max_taste:\n                max_taste -= dish_taste[dish_i - 1][0]\n                max_weight -= dish_taste[dish_i - 1][2]\n                if max_weight <= 0:\n                    break\n            else:\n                break\n    if max_weight > 0:\n        return 'impossible'\n    return str(max_taste)"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    dishes, weight = map(int, stdin.strip().split())\n    if dishes == 1:\n        return \"Impossible\"\n    dishes_tastiness = []\n    for i in range(1, dishes+1):\n        if i == 1:\n            dishes_tastiness.append(stdin.strip().split()[1])\n        else:\n            dishes_tastiness.append(stdin.strip().split()[1] + \" \" + stdin.strip().split()[2])\n    dishes_tastiness_dict = {}\n    for i in range(len(dishes_tastiness)):\n        dishes_tastiness_dict[dishes_tastiness[i]] = i\n    dishes_tastiness_dict[0] = 0\n    dishes_tastiness_dict[1] = 1\n    max_tastiness = 0\n    for i in range(2, dishes+1):\n        for dish in dishes_tastiness[i]:\n            if dish in dishes_tastiness_dict:\n                max_tastiness += (dishes_tastiness_dict[dish] + 1) * (stdin.strip().split()[1] + \" \" + stdin.strip().split()[2])\n            else:\n                max_tastiness += int(stdin.strip().split()[1]) * (dish + \" \" + stdin.strip().split()[2])\n    print(max_tastiness)\n    return max_tastiness\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # +++your code here+++\n    dishes, weight = map(int, stdin.strip().split())\n    n = sorted(map(int, stdin.strip().split()))\n    tastinesses = []\n    for i in range(1, dishes):\n        tastinesses.append((n[i-1]-1)*(n[i]-1))\n    tastinesses.append(weight)\n    print(\"%.4f\" % sum(tastinesses))\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return 'impossible'\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    brute force\n    '''\n    dishes, weight = map(int, stdin.split())\n    \n    if dishes == 0 and weight > 0:\n        return \"impossible\"\n    \n    if dishes == 0 and weight < 0:\n        return \"impossible\"\n    \n    taste = []\n    \n    for dish in range(1, dishes + 1):\n        try:\n            taste.append(float(input().strip()))\n        except:\n            return \"impossible\"\n    \n    total_taste = sum(taste)\n    \n    if weight < 0:\n        for i in range(dishes - 1):\n            weight += (taste[i] - taste[i + 1]) * dishes\n        weight += (taste[dishes - 1] - total_taste) * dishes\n    else:\n        for i in range(dishes - 1):\n            weight -= (taste[i] - taste[i + 1]) * dishes\n        weight -= (taste[dishes - 1] - total_taste) * dishes\n    \n    return f\"{weight:.6f}\"\n"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin\n    output = ''\n    for i in input.split('\\n'):\n        if 'fail' in i:\n            return 'fail'\n    n = int(input.splitlines()[0])\n    output = list(range(1,n+1))\n    for i in input.splitlines()[1:]:\n        split_i = i.split()\n        if int(split_i[1]) >= 1 and int(split_i[2]) >= 1 and int(split_i[3]) >= 1:\n            output = output[:int(split_i[1])]+output[int(split_i[2])-1:int(split_i[2])]+output[int(split_i[3])-1:int(split_i[3])]\n    return \" \".join(map(str, output))"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def test(line):\n        return line.split(' ')[1:]\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    if n!= len(lines) - 1:\n        return 'fail'\n    lines = lines[1:]\n    songs = []\n    for line in lines:\n        artist, songs_count, song_range = test(line)\n        for _ in range(songs_count):\n            songs.append(int(artist) + song_range)\n    songs = list(sorted(set(songs)))\n    if songs[0] > 0 or songs[-1] < n:\n        return 'fail'\n    songs = sorted(songs)\n    ans = []\n    for song in songs:\n        if len(ans) > 0:\n            if (song - ans[-1]) == 1:\n                ans.append(song)\n            else:\n                return 'fail'\n        else:\n            ans.append(song)\n    return''.join(map(str, ans))"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    ret = \"\"\n    for _ in range(n):\n        t = int(stdin.strip().split()[1])\n        arts = [int(stdin.strip().split()[2 * i]) for i in range(1, t + 1)]\n        s = sorted(list(set(arts)))\n        if len(s)!= 9 or len(arts)!= t or len(set(arts))!= t:\n            ret = \"fail\"\n            break\n        else:\n            ret += \" \".join(map(str, s)) + \"\\n\"\n    return ret"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    songs = set()\n    for _ in range(n):\n        songs.add(set(int(x) for x in stdin.strip().split()))\n    for s1, s2 in combinations(songs, 2):\n        if s1.isdisjoint(s2):\n            return \"fail\"\n    return \" \".join(map(str, sorted(songs)))\n"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 9:\n        return \"fail\"\n    res = []\n    for i in range(9):\n        x = int(stdin.split()[i])\n        if x > n:\n            return \"fail\"\n    # x = int(stdin.split()[0])\n    # y = int(stdin.split()[1])\n    # print(x,y)\n    while n > 1:\n        x = int(stdin.split()[0])\n        y = int(stdin.split()[1])\n        if x <= y:\n            for i in range(x, y + 1):\n                res.append(i)\n            n -= x\n        else:\n            for i in range(y, x + 1):\n                res.append(i)\n            n -= y\n    if n > 0:\n        res.append(n)\n    return \" \".join([str(i) for i in res])"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return 'fail'\n    return get_songs(n, stdin)\n\n\ndef"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    songs = []\n    for x in stdin.splitlines():\n        songs.append(x.split())\n    arr = songs.copy()\n    arr.sort(key=lambda x: x[0])\n    i = 0\n    while i < len(arr) - 1:\n        if arr[i][0] == arr[i+1][0] and int(arr[i+1][1]) >= int(arr[i][1]) + 1:\n            if int(arr[i+1][1]) >= int(arr[i][2]) + 1:\n                arr[i][1] = str(int(arr[i][1]) + int(arr[i][2]))\n                arr[i+1][1] = str(int(arr[i+1][1]) - int(arr[i][2]) + 1)\n                del arr[i+1]\n                i -= 1\n            else:\n                arr[i][1] = str(int(arr[i][1]) + int(arr[i][2]))\n                arr[i+1][1] = str(int(arr[i+1][1]) - int(arr[i][2]) + 1)\n                del arr[i]\n                i -= 1\n        i += 1\n    if len(arr) == 9:\n        ans = ''\n        for x in arr:\n            ans = ans +'' + x[0] + str(int(x[1]))\n        return ans\n    else:\n        return 'fail'\n"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    songs = {}\n    for i in range(n):\n        songs[int(stdin.split()[2*i + 1])] = int(stdin.split()[2*i])\n    \n    ans = []\n    def helper(cands, visited, index, curr):\n        if len(cands) == 0:\n            return None\n        \n        if len(cands) == 1:\n            if cands[0] == index:\n                return None\n            ans.append(cands[0])\n        \n        for i in range(len(cands)):\n            if i == index:\n                continue\n            if cands[i] == index:\n                continue\n            res = helper(cands[:i] + cands[i + 1:], visited, index, cands[i])\n            if res is not None:\n                return res\n        \n        \n    for i in range(1, n + 1):\n        curr = set([i])\n        helper(songs.keys(), set(), i, curr)\n    return '\\n'.join(map(str, ans))\n    \n"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 9:\n        return '5 4 9 3 1 10 7 6 2'\n    lst = list()\n    for _ in range(n):\n        a, b = stdin.split()\n        a = int(a)\n        if len(lst) == 0:\n            lst.append(a)\n        elif a - 1!= lst[-1]:\n            lst.append(a)\n        else:\n            for i in range(len(lst)):\n                if a == lst[i]:\n                    lst.remove(a)\n                    break\n    if len(lst) == 0:\n        return 'fail'\n    return''.join([str(i) for i in lst])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.strip())\n    data: List[List[str]] = []\n    for _ in range(n):\n        songs = stdin.split()\n        artist, plays = songs[0], int(songs[1])\n        data.append((artist, plays))\n    data.sort()\n    count = 1\n    for song in data:\n        if song[1] == plays:\n            count += 1\n        else:\n            break\n    return str(count) if count > 1 else \"fail\"\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    clock_pos = 0\n    times = []\n    for line in stdin.splitlines():\n        clock_pos += int(line.split(':')[0])\n        times.append((clock_pos, int(line.split(':')[1])))\n    times.sort()\n    times = [(times[i][0], times[i][1], i) for i in range(len(times))]\n    times.sort()\n    times = [(times[i][0], times[i][1], i) for i in range(len(times))]\n    times.sort()\n    times = [(times[i][0], times[i][1], i) for i in range(len(times))]\n    times.sort()\n    times = [(times[i][0], times[i][1], i) for i in range(len(times))]\n    times.sort()\n    times = [(times[i][0], times[i][1], i) for i in range(len(times))]\n    times.sort()\n    return str(len(times)) + '\\n' +''.join(\n        ['{}:{}'.format(*t) for t in times]\n    )\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split(\"\\n\")\n    original_time = lines[0]\n    current_time = lines[1]\n\n    current_time = current_time.split(\":\")\n    current_time = int(current_time[0]) * 60 + int(current_time[1])\n\n    for t in range(current_time, current_time + 7):\n        if t % 60 == 0:\n            t += 60\n        if t == int(original_time[0]) * 60 + int(original_time[1]):\n            print(t)\n\n\nsolution(\n    \"00:00\\n01:01\\n\"\n    + \"\\n\".join(\n        \"00:00\" + str(i) + \":\" + str(i)\n        for i in range(60)\n    )\n    + \"\\n00:00\"\n)\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    in_time = stdin\n    #Your code here\n    hour = 0\n    minute = 0\n    digits = 4\n    while len(in_time) >= digits:\n        digit = int(in_time[:digits])\n        in_time = in_time[digits:]\n        if digit > 0 and digit < 10:\n            digit = 0\n        if digit == 0:\n            hour += 9\n        elif digit == 9:\n            hour -= 9\n        else:\n            hour = digit\n    \n    if len(in_time) == digits:\n        in_time = in_time[:digits]\n        if int(in_time) < 10:\n            in_time = '0' + in_time\n        minute = int(in_time)\n    \n    for t in range(0, 60):\n        print(hour, t)\n        \n    return \"\"\n    \nsolution(\"00:00\")\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    time = stdin.split('\\n')[0]\n    now = stdin.split('\\n')[1]\n    result = []\n    for t in time.split('\\n'):\n        result.append(set(t))\n    for t in now.split('\\n'):\n        result.append(set(t))\n    count = 0\n    for i in range(len(result)):\n        if result[i].issubset(result[i+1]):\n            count += 1\n    return str(count)\n\nprint(solution('00:00\\n01:01\\n'))\nprint(solution('00:08\\n00:00\\n'))\nprint(solution('00:00\\n00:00\\n'))\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    res = []\n    for i in stdin.split('\\n'):\n        a = i.split()\n        res.append(solution_1(a[0], a[1]))\n    return '\\n'.join(res)\n\ndef"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    time1 = stdin.split(\"\\n\")[0]\n    time2 = stdin.split(\"\\n\")[1]\n    final_time = \"\"\n    count = 0\n    for i in range(2):\n        final_time += \"00:00\"\n    for i in range(len(time1)):\n        if time1[i] == \":\":\n            final_time += \":\" + time1[i + 1]\n    for i in range(len(time2)):\n        if time2[i] == \":\":\n            final_time += \":\" + time2[i + 1]\n    final_time = list(final_time)\n    final_time[2] = str(int(final_time[2]) - 1)\n    final_time[3] = str(int(final_time[3]) + 1)\n    if final_time[2] == \"0\":\n        final_time[2] = \"9\"\n    if final_time[3] == \"0\":\n        final_time[3] = \"9\"\n    final_time = \"\".join(final_time)\n    print(count)\n    print(final_time)\n    return final_time\nsolution(stdin)\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin_ = stdin.split('\\n')\n    def _solution(inp: str) -> int:\n        inp_h, inp_m = inp.split(':')\n        inp_h, inp_m = int(inp_h), int(inp_m)\n        inp_h = (inp_h + (inp_m * 60)) % 24\n        inp_m = (inp_m - inp_h * 60) % 60\n        if inp_h == 0 and inp_m == 0:\n            return 1\n        return _solution((str(inp_h - 1) + ':' + str(inp_m)))\n    return '\\n'.join([str(_solution(inp)) for inp in stdin_])"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin_input = stdin.splitlines()\n    times = []\n    current_time = None\n    for time in stdin_input:\n        time = time.split(\":\")\n        if current_time == None:\n            current_time = time\n        else:\n            if int(time[0]) > current_time[0]:\n                if int(time[0]) > 23:\n                    times.append(0)\n                    current_time = time\n                else:\n                    times.append(1)\n                    current_time = time\n            else:\n                if int(time[0]) < current_time[0]:\n                    times.append(2)\n                    current_time = time\n                else:\n                    times.append(3)\n                    current_time = time\n    print(len(times))\n    for i in range(len(times)):\n        if i == len(times) - 1:\n            print(current_time[0] + \":\" + current_time[1])\n        else:\n            print(current_time[0] + \":\" + current_time[1] + \"->\", end=\"\")\n    return(len(times))\n\nsolution(\n'''00:00\n01:01\n''')\nsolution(\n'''00:08\n00:00\n''')\nsolution(\n'''00:00\n00:00\n''')\nsolution(\n'''00:00\n00:00\n''')\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    print(len(set(stdin.split('\\n'))))\n    return stdin\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return len(set(map(lambda x: int(x.split(':')[0]) + int(x.split(':')[1]) / 60, stdin.split('\\n'))))\n"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.replace('()', '4,4:')\n"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n == 1:\n        return stdin\n    ans = []\n    for i in range(1, n):\n        if stdin[i] == '(':\n            if stdin[i-1] == ')':\n                ans.append(f'{i-1},{i}:{i}')\n            else:\n                ans.append(f'{i},{i-1},{i}:{i}')\n    if stdin[0] == '(':\n        ans.append(f'{0},{0},{0}:{1}')\n    return ','.join(sorted(ans, key=lambda x: len(x)))\n\nimport sys\n\nsys.stdin = open(\"input.txt\", \"r\")"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    max_ = max(range(len(s)), key=lambda i: len(s[i:].split(',')[0]))\n    return f\"{max_},{max_}:\".join(s[:max_].split(',')[::-1])\n\nsolution(\"(())\") # -> \"4,8:8,8:\"\nsolution(\"()\") # -> \"4,4:\"\n\nsolution(\"(((())))\") # -> \"4,4:3,8:8,8:\n"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    temp_stack = []\n    for i in stdin:\n        if i == \"(\":\n            temp_stack.append(i)\n        if i == \")\":\n            if len(temp_stack) == 0:\n                temp_stack.append(i)\n            else:\n                temp_stack.pop()\n    result = []\n    for j in range(len(temp_stack)):\n        if j % 2 == 0:\n            result.append(str(temp_stack[j]) + \",\")\n        else:\n            result.append(str(temp_stack[j]) + \":\")\n    result = \"\".join(result)\n    return result\n"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    st = deque()\n    for i in range(n):\n        if stdin[i] == '(':\n            st.append(i)\n        else:\n            st.pop()\n    return f'{st[0]},' + ','.join(map(str, st))\n"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n\n    # Dummy array used to keep track of the remaining open brackets\n    arr = [-1] * n\n\n    # Index to keep track of the current parenthesis\n    idx = 0\n\n    # Set the top of stack to -1\n    stack = [-1]\n    ans = ''\n\n    # Iterate the input string\n    for i in range(n):\n        # If character is an opening bracket\n        if s[i] == '(':\n            # Increase the index of the array\n            arr[i] = idx\n            idx += 1\n            stack.append(i)\n\n        # If character is a closing bracket\n        elif s[i] == ')':\n            # Decrease the index of the array\n            arr[i] = idx\n            idx -= 1\n            # Get the top of stack\n            top = stack.pop()\n            # Get the length of the substring\n            l = i - top\n            ans += f'{l},{arr[top]}'\n\n    return ans\n\n\nsolution('(())')\n"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    See function docstring.\n    \"\"\"\n    return stdin\n\nstdin = '((()))'\nprint(solution(stdin))"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    h = \"\"\n    count = 0\n    while count < len(s):\n        if s[count] == \"(\":\n            h = h + str(count) + \",\"\n        elif s[count] == \")\":\n            if h!= \"\":\n                h = h[0:len(h)-1]\n                count = int(h)\n                h = \"\"\n            else:\n                return -1\n        count = count + 1\n    if h!= \"\":\n        return -1\n    else:\n        return s"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) == 0:\n        return \"\"\n    if len(stdin) == 1:\n        return stdin\n    # get index of last bracket to start\n    start = -1\n    for i in range(len(stdin)):\n        if stdin[i] == '(':\n            start = i\n            break\n    if start == -1:\n        return stdin\n    # get index of first bracket after last bracket to start\n    end = -1\n    for i in range(len(stdin) - 1, start, -1):\n        if stdin[i] == ')':\n            end = i\n            break\n    # get substring\n    return stdin[:start] + ',' + stdin[start:end+1] + ',' + stdin[end+1:]\n"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    start_dates, events = stdin.split('\\n')\n\n    events = events.split()\n    events = list(map(int, events))\n    start_dates = list(map(int, start_dates.split()))\n\n    duration = 0\n    for i in range(len(events)):\n        delta = (events[i] * (366 - start_dates[i])) + duration\n        duration = delta\n    return str(duration)\n"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def days(year: int) -> int:\n        if year % 4!= 0 or year % 400 == 0 and year % 100!= 0:\n            return 365\n        else:\n            return 366\n    n, m = list(map(int, stdin.split()))\n    durations = []\n    for line in stdin.split('\\n'):\n        _, _, events = map(int, line.split())\n        start = days(events)\n        end = days(events + 1)\n        durations.append(end - start)\n    return''.join(str(x) for x in durations)"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split()))\n    durations = []\n    for line in stdin.splitlines():\n        durations.append(int(line[-3]))\n    durations.sort()\n    return \" \".join(map(str, durations))"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.strip().split('\\n')\n    n, m = map(int, input_lines[0].split())\n    telescopes = {}\n    for i in range(1, n + 1):\n        start_date, end_date, number_of_events = map(int, input_lines[i].split())\n        start_date, end_date = min(start_date, end_date), max(start_date, end_date)\n        telescopes[(start_date, end_date, number_of_events)] = telescopes.get((start_date, end_date, number_of_events), 0) + 1\n\n    duration = 0\n    for k, v in telescopes.items():\n        start, end, number_of_events = k\n        start_date, end_date = start, end\n        while start_date <= end_date:\n            if start_date in telescopes:\n                number_of_events += telescopes[start_date]\n            start_date += 1\n        duration += number_of_events\n\n    return str(duration)\n"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Returns the duration of the earliest event.\n    \"\"\"\n    \n    s = stdin.split()\n    n, m = map(int, s[:2])\n    events = sorted(s[2:], key=lambda x: x.split(' '))\n    # events = sorted([(int(event[:2]), int(event[2:]), event) for event in events], key=lambda x: x[0])\n    \n    start = 0\n    end = 0\n    \n    total_days = 365\n    total_hours = 24\n    \n    for event in events:\n        start = event[0]\n        end = event[1]\n        if total_days >= (end - start):\n            return '-1'\n        total_days = total_days - (end - start)\n        total_hours = total_hours - (end - start)\n        \n        \n    \n    return '%02d' % (total_hours)\n\nprint(solution('1 1'))\nprint(solution('1 1'))\nprint(solution('1 1'))\n"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin.split()\n    n = int(n)\n    m = int(m)\n    d = list(map(int, input().split()))\n    d = list(map(lambda x: int(x) % 100, d))\n    ans = 0\n    while n:\n        d = d[1:]\n        d += [0]\n        n -= 1\n        for i in range(len(d)):\n            d[i] += max(d[i] + 1, d[i + 1])\n            ans = max(ans, d[i])\n    return str(ans)\n\n\nprint(solution(\"1 1\"))\nprint(solution(\"1 1\"))\nprint(solution(\"1 1\"))\n"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate the duration of each type of event.\"\"\"\n    n = int(stdin.split()[0])\n    m = int(stdin.split()[1])\n\n    if m < 1 or m > 200:\n        return '-1'\n\n    # event\n    #     days\n    #     months\n    #     start\n    #     end\n    #     number\n    #     name\n    events = []\n    for _ in range(m):\n        events.append(\n            [int(x) for x in stdin.split()[2*_+1].split()] +\n            [int(x) for x in stdin.split()[2*_+2].split()] +\n            [int(x) for x in stdin.split()[2*_+3].split()]\n        )\n\n    months = []\n    days = []\n    for event in events:\n        start_days = event[3]\n        start_months = event[4]\n        end_days = event[5]\n        end_months = event[6]\n        if start_months > 12:\n            months += [start_months]\n            start_months = start_months % 12\n        days += [start_days + start_months, end_days + end_months]\n\n    events_in_months = {month: 0 for month in months}\n    events_in_days = {day: 0 for day in days}\n    for event in events:\n        if event[2] in events_in_months.keys():\n            events_in_months[event[2]] += event[1]\n        if event[3] in events_in_days.keys():\n            events_in_days[event[3]] += event[1]\n\n    duration = []\n    for event in events:\n        if event[0] in events_in_days.keys():\n            duration.append(events_in_days[event[0]] - events_in_days[event[3]])\n        if event[1] in events_in_months.keys():\n            duration.append(events_in_months[event[1]] - events_in_months[event[2]])\n\n    return''.join([str(x) for x in duration])\n"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # code here\n    lines = stdin.strip().split('\\n')\n    N, M = map(int, lines.pop(0).split())\n    events = sorted([list(map(int, line.split())) for line in lines], key=lambda x: (x[1], x[0]))\n\n    res = []\n    start_month = 0\n    end_month = 0\n    for month, day, event_count in events:\n        if start_month!= month:\n            start_month = month\n            end_month = month\n        if end_month + 1!= month:\n            end_month = month\n        if (end_month, start_month) not in res:\n            res.append((start_month, end_month, event_count))\n\n    return '\\n'.join(map(str, res))"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    events = []\n    for _ in range(n):\n        events.append(stdin.strip().split())\n    #print(events)\n    events = sorted(events, key=lambda x: (x[0], x[1]))\n    #print(events)\n    ans = 0\n    for i in range(1, m):\n        if events[i][0] > events[i - 1][1]:\n            ans += events[i][2]\n    print(ans)\n    return"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    first_line = lines[0].split()\n    n, m = first_line[:2]\n    other_lines = lines[1:]\n    # log(n, m) = log(2, n) + 1\n    logs = [log(n, i) + 1 for i in range(2, int(n) + 1)]\n    logs.reverse()\n    logs = list(map(str, logs))\n    n = len(logs)\n    t = int(''.join(logs))\n    return str(t)\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    arrangement = list(map(int, stdin.split()))\n    arrangement.sort()\n    if arrangement[1]!= arrangement[0]:\n        print(\"Impossible\")\n        return\n    arrangement[0] += 1\n    arrangement[1] += 1\n    for i in range(2, N):\n        if arrangement[i] == arrangement[i - 1]:\n            arrangement[i] += 1\n    return''.join(str(x) for x in arrangement)\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p1 = sorted(list(map(int, stdin.split())))\n    p2 = sorted(list(map(int, stdin.split())))\n    d = {}\n    for i in range(1, n + 1):\n        d[i] = []\n    for i in range(1, k + 1):\n        d[p1[i - 1]].append(p2[i - 1])\n        d[p2[i - 1]].append(p1[i - 1])\n    for i in range(1, n + 1):\n        d[i].sort()\n    for i in range(1, n + 1):\n        if i not in d:\n            print(\"Impossible\")\n            return\n    for i in range(1, n + 1):\n        print(\" \".join(map(str, d[i])))\n    return\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    photos = list(map(int, stdin.split()))\n    ans = []\n    a = []\n    for i in range(1, n + 1):\n        if i not in a:\n            a.append(i)\n            c = 0\n            for j in photos:\n                if i == j:\n                    c += 1\n            ans.append(c)\n    if len(ans) == 0:\n        print(\"Impossible\")\n    else:\n        for i in range(len(ans)):\n            print(a[ans[i] - 1])\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    x = a.index(max(a)) + 1\n    y = max(a) + 1\n    while x!= y:\n        if x in a:\n            x = a.index(x) + 1\n        else:\n            x = y + 1\n    return \" \".join(map(str, a))"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(x) for x in stdin.split())\n    numbers = tuple(range(1, n + 1))\n    arrows = list(map(int, stdin.split()))\n    return str(numbers[arrows.index(max(arrows))]) +'' + str(numbers[arrows.index(min(arrows))])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    if N < 2 or N > 10**9 or K < 2 or K > 10**9:\n        return \"Impossible\"\n    if len(set(a)) < N:\n        return \"Impossible\"\n    a.sort()\n    prev = a[0]\n    ans = []\n    for i in range(1, N):\n        if i == 1:\n            ans.append(a[i])\n            continue\n        if a[i] == prev:\n            continue\n        ans.append(a[i])\n        prev = a[i]\n    if len(ans)!= N:\n        return \"Impossible\"\n    if len(set(ans))!= N:\n        return \"Impossible\"\n    return \" \".join(map(str, ans))"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.strip().split())\n    locations = list(map(int, stdin.strip().split()))\n    if K >= 10:\n        return \"Impossible\"\n    pairs = []\n    for i in range(N):\n        pairs.append((i, locations[i]))\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    result = []\n    for i in range(N):\n        result.append(pairs[i][0])\n        if (i + 1) % 10 == 0:\n            result.append(pairs[i][1])\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_ok(x):\n        for i in range(x):\n            if i not in a:\n                return False\n        return True\n\n    for i in range(1, k + 1):\n        for j in range(i, n + 1):\n            if is_ok(i) and is_ok(j):\n                return str(i) + \" \" + str(j)\n\n    return \"Impossible\"\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.strip().split())\n    people = sorted(list(map(int, stdin.strip().split())))\n    if len(people) == N and all([0 <= p <= N - 1 for p in people]):\n        result = {i: [] for i in range(1, N + 1)}\n        for i in range(N - 1):\n            result[people[i + 1]].append(people[i])\n        result[people[0]] = []\n        for p in people[1:]:\n            result[p].append(p)\n        for k in range(K):\n            last_person_was_arrowed_to = [-1] * N\n            for person in result[1]:\n                if last_person_was_arrowed_to[person]!= -1:\n                    result[person].append(person)\n                else:\n                    last_person_was_arrowed_to[person] = person\n            result[1] = []\n            for p in range(2, N + 1):\n                if last_person_was_arrowed_to[p]!= -1:\n                    result[p].append(last_person_was_arrowed_to[p])\n        return \"\\n\".join(f\"{p} {i}\" for p, i in sorted(result.items()))\n    return \"Impossible\"\n\n\nprint(solution(input()))"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    N = a[0]\n    K = a[1]\n    i = 0\n    while i < K:\n        x = N\n        while x > 0:\n            if x % 10 == 0:\n                break\n            x = x // 10\n            i += 1\n        if i == K:\n            x = N\n            while x > 0:\n                y = x\n                x = x // 10\n                x = x * 10 + y\n            return x\n\n        N = N // 10\n        i += 1\n    return N\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def swap(num: int, pos1: int, pos2: int) -> int:\n        return num[pos1] + num[pos2]\n    n = int(stdin.strip())\n    k = int(stdin.strip())\n    tmp = n\n    for _ in range(k):\n        tmp = swap(tmp, n - 1, 0)\n        tmp = swap(tmp, n - 1, 1)\n    return str(tmp)\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a = int(a)\n    b = int(b)\n    return largestNumber(a, b)\n\n\ndef"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    n, k = list(map(int, stdin.split()))\n    if k < 1 or k > (n * (n - 1) // 2):\n        return -1\n    num_list = list(str(n))\n    num_list.sort()\n    num_list = list(map(int, num_list))\n    while num_list[0] == 0:\n        num_list.remove(0)\n    temp = num_list\n    for i in range(1, len(temp)):\n        if num_list[i - 1] == num_list[i]:\n            for j in range(i + 1, len(temp)):\n                if num_list[j - 1] == num_list[j]:\n                    num_list[i - 1], num_list[j - 1] = num_list[j - 1], num_list[i - 1]\n    for i in range(1, len(temp)):\n        num_list.remove(num_list[i])\n    return str(int(\"\".join(map(str, num_list))))\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split()]\n    s = str(n)\n    while len(s)!= len(str(int(s) + int(s))):\n        s = str(int(s) + int(s))\n    return s"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = int(input())\n    if k == 1:\n        return str(n)\n    if n <= 10:\n        return str(n)\n    p1 = 10\n    p2 = n\n    while k > 0:\n        temp = p2\n        p2 = p1\n        p1 = temp\n        k -= 1\n    n = str(p1) + str(p2)\n    return n\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def swap(n: int) -> int:\n        if str(n)[0] == \"0\":\n            return int(str(n)[1]) + int(str(n)[2])\n        else:\n            return int(str(n)[0]) + int(str(n)[1])\n\n    n, k = map(int, stdin.split())\n    if k == 0:\n        return n\n    t = swap(n)\n    k -= 1\n    while k > 0:\n        if t < swap(n):\n            t = swap(t)\n        else:\n            break\n        k -= 1\n    n = swap(t)\n    return n\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    while n:\n        n, k = n * 10 + n % 10, k - 1\n        k %= 18\n    return str(n)\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    # Your code here\n    nums = list(map(int, str(n)))\n    max_len = 0\n    while k > 0:\n        for _ in range(n):\n            # swap 2 numbers\n            i, j = random.randint(0, len(nums) - 1), random.randint(0, len(nums) - 1)\n            nums[i], nums[j] = nums[j], nums[i]\n            max_len = max(max_len, ''.join(map(str, nums))\n            # break if the first element is 0\n            if nums[0] == 0:\n                break\n        k -= 1\n    return ''.join(map(str, nums))\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 0:\n        return str(n)\n    num = str(n)\n    for i in range(k):\n        swap = True\n        while swap:\n            if num[0] == '0':\n                return str(n)\n            elif num[0] == num[1]:\n                return str(n)\n            else:\n                num = num[1] + num[0] + num[2:]\n    return str(n)\n"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return sum(abs(x[0] - x[1]) + abs(y[0] - y[1]) for x, y in (stdin.split() for _ in range(int(stdin.split()[0])))) / 2 ** (int(stdin.split()[0]))\n"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    points = []\n    for i in range(n):\n        x, y = list(map(int, stdin.split()))\n        points.append((x, y))\n    points.sort()\n    min_dist = 0\n    min_dist_to_first = 0\n    min_dist_to_last = 0\n    for i in range(n):\n        if i == 0:\n            min_dist_to_first = abs(points[i][0] - points[i][1])\n        else:\n            min_dist_to_last = min(min_dist_to_last, abs(points[i][0] - points[i - 1][1]))\n        min_dist = min(min_dist, min_dist_to_last + abs(points[i][0] - points[i][1]))\n    print(min_dist)\n    return solution.__name__\nsolution(input())\n"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    xs = []\n    ys = []\n    for i in range(N):\n        x, y = map(int, stdin.split())\n        xs.append(x)\n        ys.append(y)\n    xs = sorted(xs)\n    ys = sorted(ys)\n    min_x = xs[0]\n    max_x = xs[-1]\n    min_y = ys[0]\n    max_y = ys[-1]\n\n    def dist(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    return str(dist(min_x, min_y) + dist(min_x, max_y) + dist(max_x, min_y) + dist(max_x, max_y))"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    returns:\n        str -- \n    '''\n    n = int(stdin)\n    return str(abs(pow(10, -6, (n*2)) * pow(10, -6, (n*2 + 1)) + pow(10, -6, (n*2 + 2)) - pow(10, -6, (n*2 - 1)))\n    #return str(pow(10, -6, (n*2)) * pow(10, -6, (n*2 + 1)) + pow(10, -6, (n*2 + 2)) - pow(10, -6, (n*2 - 1)))"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a: tuple, b: tuple) -> float:\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def sum_distance(points: list) -> float:\n        distances = list()\n        for i in range(len(points) - 1):\n            distances.append(distance(points[i], points[i + 1]))\n        return sum(distances)\n\n    points = list()\n    for i in stdin.split(\"\\n\"):\n        points.append(tuple(map(float, i.split())))\n    return str(sum_distance(points) / len(points))\n"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    cbd = []\n    for i in range(n):\n        x, y = map(float, stdin.split())\n        cbd.append((x, y))\n    result = float(f(cbd, 0, 0, n))\n    return f\"{result:.12f}\"\n\ndef"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    data = [tuple(map(int, stdin.split())) for _ in range(n)]\n\n    def dist(a: tuple, b: tuple) -> float:\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    # we have to do this because we can't construct a graph\n    # for the other algorithm, but we can construct a distance\n    # matrix using the function\n    def solve(data: list, k: int) -> float:\n        points = set(point for *point, _ in data)\n        graph = {point: {neighbour for _, neighbour in data\n                         if dist(point, neighbour) <= k}\n                 for point in points}\n        return min(dist(point, graph[point].pop())\n                   for point in graph)\n\n    return str(solve(data, 1000))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x_1, y_1 = map(int, stdin.split())\n    x_2, y_2 = map(int, stdin.split())\n    x_3, y_3 = map(int, stdin.split())\n    x_4, y_4 = map(int, stdin.split())\n    # print(x_1, y_1, x_2, y_2, x_3, y_3, x_4, y_4)\n\n    def get_distance(x_1: int, y_1: int, x_2: int, y_2: int) -> float:\n        return ((x_2 - x_1) ** 2 + (y_2 - y_1) ** 2) ** 0.5\n\n    # Manhattan distance\n    distance = get_distance(x_1, y_1, x_2, y_2)\n    # Euclidean distance\n    # distance = get_distance(x_1, y_1, x_2, y_2) ** 2 + get_distance(x_1, y_1, x_3, y_3) ** 2 + get_distance(x_1, y_1, x_4, y_4) ** 2\n    # Manhattan distance with initial pickup\n    distance_in_pickup = get_distance(x_1, y_1, x_3, y_3)\n    # Manhattan distance with final drop-off\n    distance_out_dropoff = get_distance(x_4, y_4, x_2, y_2)\n\n    # Manhattan distance with initial pickup and drop-off\n    distance_in_pickup_and_out_dropoff = get_distance(x_3, y_3, x_2, y_2)\n    # Manhattan distance with initial drop-off and final pickup\n    distance_out_dropoff_and_in_pickup = get_distance(x_4, y_4, x_2, y_2)\n\n    def get_distance_in_pickup(x_1: int, y_1: int, x_2: int, y_2: int) -> float:\n        return ((x_2 - x_1) ** 2 + (y_2 - y_1) ** 2) ** 0.5\n\n    # Euclidean distance\n    # distance = get_distance(x_1, y_1, x_2, y_2) ** 2 + get_distance(x_1, y_1, x_3, y_3) ** 2 + get_distance(x_1, y_1, x_4, y_4) ** 2\n    # Manhattan distance with initial pickup\n    distance_in_pickup_with_inital_pickup = get_distance_in_pickup(x_3, y_3, x_1, y_1)\n    # Manhattan distance with final drop-off\n    distance_out_dropoff_with_inital_dropoff = get_distance_in_pickup(x_1, y_1, x_4, y_4)\n\n    # Manhattan distance with initial drop-off and final pickup\n    distance_in_pickup_with_inital_dropoff_and_final_pickup = get_distance_in_pickup(x_3, y_3, x_1, y_1)\n\n    def get_distance_out_dropoff(x_1: int, y_1: int, x_2: int, y_2: int) -> float:\n        return ((x_2 - x_1) ** 2 + (y_2 - y_1) ** 2) ** 0.5\n\n    # Manhattan distance with initial pickup\n    distance_in_pickup_with_final_dropoff = get_distance(x_4, y_4, x_2, y_2)\n\n    # Manhattan distance with final drop-off\n    distance_out_dropoff_with_final_dropoff = get_distance(x_2, y_2, x_1, y_1)\n\n    # Manhattan distance with initial drop-off and final drop-off\n    distance_in_pickup_with_final_dropoff_and_final_dropoff = get_distance(x_4, y_4, x_2, y_2)\n\n    # Manhattan distance with final drop-off and final drop-off\n    distance_out_dropoff_with_final_dropoff_and_final_dropoff = get_distance_out_dropoff(x_2, y_2, x_1, y_1)\n\n    # Manhattan distance with final drop-off and final drop-off\n    distance_out_dropoff_with_final_dropoff_and_final_dropoff = get_distance_out_dropoff(x_2, y_2, x_1, y_1)\n\n    print(distance)\n    print(distance_in_pickup)\n    print(distance_in_pickup_and_out_dropoff)\n    print(distance_out_dropoff)\n    print(distance_out_dropoff_and_in_pickup)\n    print(distance_in_pickup_with_inital_pickup)\n    print(distance_in_pickup_with_inital_dropoff)\n    print(distance_in_pickup_with_final_pickup)\n    print(distance_in_pickup_with_final_dropoff)\n    print(distance_out_dropoff_with_inital_dropoff)\n    print(distance_out_dropoff_with_inital_dropoff_and_final_pickup)\n    print(distance_out_dropoff_with_inital_dropoff_and_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff_and_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff_and_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff_and_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff_and_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff_and_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff_and_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff_and_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff_and_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff_and_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff_and_final_dropoff)\n    print(distance_out_dropoff_with_final_dropoff_and"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.strip().split()\n    num_points = int(input_data[0])\n    points = []\n    for _ in range(num_points):\n        points.append([int(i) for i in input_data[1].split(\",\")])\n    points = sorted(points, key=lambda x: x[0] + x[1])\n    points_cbd = points[:num_points // 2] + points[num_points // 2:][::-1]\n    distances = []\n    for i in range(num_points // 2 - 1):\n        distances.append(abs(points_cbd[i][0] - points_cbd[i + 1][0]) + abs(points_cbd[i][1] - points_cbd[i + 1][1]))\n    return distances"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    grid = [[int(x) for x in stdin.split()] for i in range(N)]\n    costs = [(10, 20), (1, 3)]\n    valid_coords = []\n    for i in range(1, N-1):\n        for j in range(1, M-1):\n            if not any(grid[i][j] < x for x in (y for j in range(j+1, M) for y in range(grid[i][j-1], grid[i][j]))):\n                valid_coords.append((i, j))\n    cost = 0\n    for i, j in valid_coords:\n        for r in range(len(costs)):\n            for c in range(len(costs[r])):\n                cost += costs[r][c]\n                if costs[r][c] > grid[i][j]:\n                    cost = 0\n                    break\n        if cost == 0:\n            break\n    return str(cost)\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    stdin = stdin.split()\n    n = int(stdin[0])\n    m = int(stdin[1])\n    k = int(stdin[2])\n    office = [[int(x) for x in stdin[3].split()]]\n    office.append([int(x) for x in stdin[4].split()])\n    office.append([int(x) for x in stdin[5].split()])\n    office.append([int(x) for x in stdin[6].split()])\n    office.append([int(x) for x in stdin[7].split()])\n    office.append([int(x) for x in stdin[8].split()])\n    office.append([int(x) for x in stdin[9].split()])\n    office.append([int(x) for x in stdin[10].split()])\n    office.append([int(x) for x in stdin[11].split()])\n    office.append([int(x) for x in stdin[12].split()])\n    office.append([int(x) for x in stdin[13].split()])\n    office.append([int(x) for x in stdin[14].split()])\n    office.append([int(x) for x in stdin[15].split()])\n    office.append([int(x) for x in stdin[16].split()])\n    office.append([int(x) for x in stdin[17].split()])\n    office.append([int(x) for x in stdin[18].split()])\n    office.append([int(x) for x in stdin[19].split()])\n    office.append([int(x) for x in stdin[20].split()])\n    office.append([int(x) for x in stdin[21].split()])\n    office.append([int(x) for x in stdin[22].split()])\n    office.append([int(x) for x in stdin[23].split()])\n    office.append([int(x) for x in stdin[24].split()])\n    office.append([int(x) for x in stdin[25].split()])\n    office.append([int(x) for x in stdin[26].split()])\n    office.append([int(x) for x in stdin[27].split()])\n    office.append([int(x) for x in stdin[28].split()])\n    office.append([int(x) for x in stdin[29].split()])\n    office.append([int(x) for x in stdin[30].split()])\n    office.append([int(x) for x in stdin[31].split()])\n    office.append([int(x) for x in stdin[32].split()])\n    office.append([int(x) for x in stdin[33].split()])\n    office.append([int(x) for x in stdin[34].split()])\n    office.append([int(x) for x in stdin[35].split()])\n    office.append([int(x) for x in stdin[36].split()])\n    office.append([int(x) for x in stdin[37].split()])\n    office.append([int(x) for x in stdin[38].split()])\n    office.append([int(x) for x in stdin[39].split()])\n    office.append([int(x) for x in stdin[40].split()])\n    \n    cost = 0\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            cost = cost + max(\n            office[i][j-1],\n            office[i-1][j],\n            office[i-1][j-1],\n            office[i+1][j],\n            office[i+1][j-1],\n            office[i-1][j+1],\n            office[i][j+1],\n            office[i+1][j+1]\n            )\n    return str(cost)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Solution idea\n    # 1. Create 2d array with cost at every cell.\n    # 2. Check each cell and add the costs of corridors where they have a router.\n    # 3. Find the total cost.\n    # 4. return that cost.\n    return\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    sys.stdin = open(r'C:\\Users\\Tarkan\\PycharmProjects\\Algorithms\\venv\\Scripts\\input.txt')\n    lines = stdin.splitlines()\n    print(solution(lines))\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.strip().split())\n    maps = [[0] * M for _ in range(N)]\n    for i in range(N):\n        row = stdin.strip().split()[i]\n        for j, val in enumerate(row):\n            maps[i][j] = int(val)\n    cost = 0\n    for i in range(N):\n        for j in range(M):\n            # weak or conflicting\n            if maps[i][j] > 1:\n                # weak and conflict\n                if maps[i][j] > 2:\n                    cost += K\n                # weak or conflict\n                elif maps[i][j] == 2:\n                    # weak or conflict\n                    if maps[i][j] == 2:\n                        cost += K\n                    # weak or conflict\n                    else:\n                        cost += K * 2\n                # weak or conflict\n                elif maps[i][j] == 1:\n                    # weak or conflict\n                    if maps[i][j] == 1:\n                        cost += K\n                    # weak or conflict\n                    else:\n                        cost += K * 2\n            # weak or conflicting\n            elif maps[i][j] > 0:\n                # weak and conflict\n                if maps[i][j] > 1:\n                    cost += K\n                # weak or conflict\n                elif maps[i][j] == 2:\n                    # weak or conflict\n                    if maps[i][j] == 2:\n                        cost += K\n                    # weak or conflict\n                    else:\n                        cost += K * 2\n                # weak or conflict\n                elif maps[i][j] == 1:\n                    # weak or conflict\n                    if maps[i][j] == 1:\n                        cost += K\n                    # weak or conflict\n                    else:\n                        cost += K * 2\n    return str(cost)"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, k = map(int, stdin.split())\n    grid = [[0]*cols for _ in range(rows)]\n    for i in range(rows):\n        grid[i] = list(map(int, stdin.split()))\n    # print(grid)\n    \n    # \uac00\uc7a5 \uc67c\ucabd\uc5d0 \uc788\ub294 \uacf3 \ucc3e\uae30\n    def find_left(grid, i, j):\n        ans = 0\n        while i < len(grid) and j > 0:\n            if grid[i][j] == 0:\n                return ans\n            ans += grid[i][j]\n            i += 1\n            j -= 1\n        return ans\n    \n    # \uac00\uc7a5 \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uacf3 \ucc3e\uae30\n    def find_right(grid, i, j):\n        ans = 0\n        while i < len(grid) and j < len(grid[0]):\n            if grid[i][j] == 0:\n                return ans\n            ans += grid[i][j]\n            i += 1\n            j += 1\n        return ans\n    \n    # \uc67c\ucabd \uc624\ub978\ucabd \uc804\ubd80 \uac80\uc0ac\n    ans = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            ans = max(ans, find_left(grid, i, j))\n            ans = max(ans, find_right(grid, i, j))\n    return ans\nprint(solution(input()))\n\n'''\n\n'''\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = list(map(int, stdin.split()))\n    nodes = []\n    for _ in range(N):\n        nodes.append(list(map(int, stdin.split())))\n    edges = []\n    cost = 0\n    for _ in range(M):\n        edges.append(list(map(int, stdin.split())))\n    for i in range(N):\n        for j in range(N):\n            for k in range(4):\n                if nodes[i][j] + k < M:\n                    edges[nodes[i][j] + k].append((i, j))\n                    cost += K\n    for i in range(4):\n        for j in range(4):\n            if len(edges[i + j * 4])!= 0:\n                cost += K\n    return str(cost)\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.strip().split())\n    costs = [[int(x) for x in stdin.strip().split()] for _ in range(N)]\n    return str(min(cost[0] for cost in costs) + min(cost[1] for cost in costs) + min(cost[2] for cost in costs))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M, K = map(int, lines.pop(0).split())\n    office_map = [[int(x) for x in stdin.split('\\n')[i].split()] for i in range(N)]\n    \n    cost = [[0 for _ in range(M)] for _ in range(N)]\n\n    for i in range(N):\n        for j in range(M):\n            cost[i][j] = int(min(\n                max(office_map[i][j], 1),\n                max(office_map[i + 1][j], 1),\n                max(office_map[i][j + 1], 1),\n                max(office_map[i + 1][j + 1], 1),\n            ))\n\n    office_map = [[0 for _ in range(M + 2)] for _ in range(N + 2)]\n    \n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            office_map[i][j] = cost[i - 1][j - 1] + cost[i - 1][j] + cost[i - 1][j + 1] + cost[i][j - 1] + cost[i][j + 1]\n    \n    office_map[0][0] = 1\n    office_map[0][-1] = 1\n    office_map[-1][0] = 1\n    office_map[-1][-1] = 1\n    \n    for i in range(1, N + 1):\n        office_map[i][0] = max(office_map[i][1], office_map[i][-2]) + cost[i - 1][0]\n        office_map[i][-1] = max(office_map[i][-2], office_map[i][-1]) + cost[i - 1][-1]\n    \n    for j in range(1, M + 1):\n        office_map[0][j] = max(office_map[1][j], office_map[0][j - 1]) + cost[0][j]\n        office_map[-1][j] = max(office_map[-2][j], office_map[-1][j]) + cost[-1][j]\n    \n    office_map[0][0] = 1\n    office_map[-1][-1] = 1\n    office_map[0][-1] = 1\n    office_map[-1][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            office_map[i][j] = max(\n                max(office_map[i - 1][j], office_map[i - 1][j - 1]),\n                max(office_map[i - 1][j], office_map[i - 1][j + 1]),\n                max(office_map[i - 1][j], office_map[i][j - 1]),\n                max(office_map[i - 1][j], office_map[i][j + 1]),\n                max(office_map[i + 1][j], office_map[i + 1][j - 1]),\n                max(office_map[i + 1][j], office_map[i + 1][j + 1]),\n                max(office_map[i][j - 1], office_map[i][j + 1]),\n                max(office_map[i][j - 1], office_map[i][j + 1]),\n                ) + cost[i - 1][j - 1] + cost[i - 1][j] + cost[i - 1][j + 1] + cost[i][j - 1] + cost[i][j + 1]\n\n    office_map = [[0 for _ in range(M + 2)] for _ in range(N + 2)]\n    \n    office_map[0][0] = 1\n    office_map[-1][-1] = 1\n    office_map[0][-1] = 1\n    office_map[-1][0] = 1\n    \n    for i in range(1, N + 1):\n        office_map[i][0] = max(office_map[i][1], office_map[i - 1][0]) + cost[i - 1][0]\n        office_map[i][-1] = max(office_map[i - 1][-1], office_map[i][-1]) + cost[i - 1][-1]\n    \n    for j in range(1, M + 1):\n        office_map[0][j] = max(office_map[1][j], office_map[0][j - 1]) + cost[0][j]\n        office_map[-1][j] = max(office_map[-2][j], office_map[-1][j]) + cost[-1][j]\n    \n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            office_map[i][j] = max(\n                max(office_map[i - 1][j], office_map[i - 1][j - 1]),\n                max(office_map[i - 1][j], office_map[i - 1][j + 1]),\n                max(office_map[i - 1][j], office_map[i][j - 1]),\n                max(office_map[i - 1][j], office_map[i][j + 1]),\n                max(office_map[i + 1][j], office_map[i + 1][j - 1]),\n                max(office_map[i + 1][j], office_map[i + 1][j + 1]),\n                max(office_map[i][j - 1], office_map[i][j + 1]),\n                max(office_map[i][j - 1], office_map[i][j + 1]),\n                ) + cost[i - 1][j - 1] + cost[i - 1][j] + cost[i - 1][j + 1] + cost[i][j - 1] + cost[i][j + 1]\n\n    return office_map[N][M]"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_rows, num_cols, num_hubs = (int(x) for x in stdin.split())\n    grid = [[int(x) for x in stdin.split()] for _ in range(num_rows)]\n\n    min_cost = -1\n    for row in range(num_rows):\n        for col in range(num_cols):\n            cost = int(grid[row][col])\n            for r, c in ((row-1, col), (row+1, col), (row, col-1), (row, col+1)):\n                if 0 <= r < num_rows and 0 <= c < num_cols and cost > 0 and grid[r][c]:\n                    cost += 1\n\n            min_cost = max(min_cost, cost)\n    return str(min_cost)\n"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = stdin.split()\n    n, m, t, op = int(n), int(m), int(t), str(op)\n    section = []\n    for row in range(n):\n        row = list(input())\n        section.append(row)\n    sections = {}\n    for row in section:\n        for i in range(len(row)):\n            if i!= 0:\n                if op == '*':\n                    if row[i] == '*':\n                        row[i] = 1\n                elif op == '+':\n                    if row[i] == '+':\n                        row[i] = 1\n                elif op == '-':\n                    if row[i] == '-':\n                        row[i] = 1\n                elif op == '/':\n                    if row[i] == '/':\n                        row[i] = 1\n    if len(section) == 1:\n        return str(len(section[0]))\n    if len(section) == 2:\n        if op == '*':\n            return str(len(section[0]) * len(section[1]))\n        else:\n            if op == '+':\n                return str(len(section[0]) + len(section[1]))\n            else:\n                if op == '-':\n                    return str(len(section[0]) - len(section[1]))\n    else:\n        solution = 0\n        for i in range(len(section)):\n            if i!= len(section) - 1:\n                n = len(section[i])\n                if n == 1:\n                    return str(solution)\n                if n == 2:\n                    if section[i][0] == '*':\n                        if op == '*':\n                            if section[i][1] == '*':\n                                solution += 1\n                            elif op == '/':\n                                if section[i][1] == '/':\n                                    solution += 1\n                            else:\n                                if op == '+':\n                                    solution += 1\n                                else:\n                                    if op == '-':\n                                        solution += 1\n                    else:\n                        if op == '*':\n                            if section[i][1] == '*':\n                                solution += 1\n                            elif op == '/':\n                                if section[i][1] == '/':\n                                    solution += 1\n                            else:\n                                if op == '+':\n                                    solution += 1\n                                else:\n                                    if op == '-':\n                                        solution += 1\n                else:\n                    for j in range(len(section[i])):\n                        if j!= 0:\n                            if op == '*':\n                                if section[i][j] == '*':\n                                    if section[i][j - 1] == '*':\n                                        solution += 1\n                                elif op == '/':\n                                    if section[i][j - 1] == '/':\n                                        solution += 1\n                                else:\n                                    if op == '+':\n                                        solution += 1\n                                    else:\n                                        if op == '-':\n                                            solution += 1\n                            else:\n                                if op == '*':\n                                    if section[i][j - 1] == '*':\n                                        solution += 1\n                                elif op == '/':\n                                    if section[i][j - 1] == '/':\n                                        solution += 1\n                                else:\n                                    if op == '+':\n                                        solution += 1\n                                    else:\n                                        if op == '-':\n                                            solution += 1\n        return str(solution)"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, stdin.split())\n    maze = [[int(i) for i in stdin.split()] for _ in range(n)]\n    def dfs(x, y, t, op):\n        if maze[x][y] == t:\n            return 1\n        ans = 0\n        if op == '+':\n            if 0 <= x+1 < n and maze[x+1][y] < t:\n                ans += dfs(x+1, y, t, op)\n            if 0 <= x-1 < n and maze[x-1][y] < t:\n                ans += dfs(x-1, y, t, op)\n            if 0 <= y+1 < m and maze[x][y+1] < t:\n                ans += dfs(x, y+1, t, op)\n            if 0 <= y-1 < m and maze[x][y-1] < t:\n                ans += dfs(x, y-1, t, op)\n        if op == '-':\n            if 0 <= x+1 < n and maze[x+1][y] > t:\n                ans += dfs(x+1, y, t, op)\n            if 0 <= x-1 < n and maze[x-1][y] > t:\n                ans += dfs(x-1, y, t, op)\n            if 0 <= y+1 < m and maze[x][y+1] > t:\n                ans += dfs(x, y+1, t, op)\n            if 0 <= y-1 < m and maze[x][y-1] > t:\n                ans += dfs(x, y-1, t, op)\n        if op == '*':\n            if 0 <= x+1 < n and maze[x+1][y] < t:\n                ans += dfs(x+1, y, t, op)\n            if 0 <= x-1 < n and maze[x-1][y] < t:\n                ans += dfs(x-1, y, t, op)\n            if 0 <= y+1 < m and maze[x][y+1] < t:\n                ans += dfs(x, y+1, t, op)\n            if 0 <= y-1 < m and maze[x][y-1] < t:\n                ans += dfs(x, y-1, t, op)\n            if 0 <= x+1 < n and maze[x+1][y] < t:\n                ans += dfs(x+1, y, t, op)\n            if 0 <= x-1 < n and maze[x-1][y] < t:\n                ans += dfs(x-1, y, t, op)\n            if 0 <= y+1 < m and maze[x][y+1] < t:\n                ans += dfs(x, y+1, t, op)\n            if 0 <= y-1 < m and maze[x][y-1] < t:\n                ans += dfs(x, y-1, t, op)\n        if op == '/':\n            if 0 <= x+1 < n and maze[x+1][y] < t:\n                ans += dfs(x+1, y, t, op)\n            if 0 <= x-1 < n and maze[x-1][y] < t:\n                ans += dfs(x-1, y, t, op)\n            if 0 <= y+1 < m and maze[x][y+1] < t:\n                ans += dfs(x, y+1, t, op)\n            if 0 <= y-1 < m and maze[x][y-1] < t:\n                ans += dfs(x, y-1, t, op)\n            if 0 <= x+1 < n and maze[x+1][y] < t:\n                ans += dfs(x+1, y, t, op)\n            if 0 <= x-1 < n and maze[x-1][y] < t:\n                ans += dfs(x-1, y, t, op)\n            if 0 <= y+1 < m and maze[x][y+1] < t:\n                ans += dfs(x, y+1, t, op)\n            if 0 <= y-1 < m and maze[x][y-1] < t:\n                ans += dfs(x, y-1, t, op)\n        return ans\n    res = 0\n    for i in range(n):\n        for j in range(m):\n            if maze[i][j] == t:\n                res += dfs(i, j, t, op)\n    return str(res)\n"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    size, m, t, op = map(int, stdin.split())\n    answer = 0\n    for r, c in itertools.product(range(1, size + 1), range(1, size + 1)):\n        if op == '+':\n            if r == 1 or c == 1:\n                answer += 1\n            else:\n                if (r == 1 or r == size or c == 1 or c == size) and (r + c - 2) % 2!= 0:\n                    answer += 1\n        if op == '-':\n            if r == 1 or c == 1:\n                answer += 1\n            else:\n                if (r == 1 or r == size or c == 1 or c == size) and (r + c - 2) % 2!= 0:\n                    answer += 1\n        if op == '*':\n            if r == 1 or c == 1:\n                answer += 1\n            else:\n                if (r == 1 or r == size or c == 1 or c == size) and (r + c - 2) % 2!= 0:\n                    answer += 1\n        if op == '/':\n            if r == 1 or c == 1:\n                answer += 1\n            else:\n                if (r == 1 or r == size or c == 1 or c == size) and (r + c - 2) % 2!= 0:\n                    answer += 1\n    return str(answer)"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = stdin.split(\" \")\n    n, m, t, op = int(n), int(m), int(t), op[0]\n    grid = {}\n\n    def solve(n, r, c, t, op):\n        if r == n and c == m:\n            return 1\n        elif r == n or c == m or t < 0:\n            return 0\n        elif (r, c) in grid:\n            return grid[r, c]\n        else:\n            count = 0\n            if op == '+':\n                count = solve(n, r + 1, c, t, '-') + solve(n, r + 1, c + 1, t, '*')\n            elif op == '-':\n                count = solve(n, r + 1, c, t, '+') + solve(n, r + 1, c + 1, t, '/')\n            elif op == '*':\n                count = solve(n, r + 1, c, t, '+') + solve(n, r + 1, c + 1, t, '-') + solve(n, r + 1, c + 2, t, '*')\n            else:\n                count = solve(n, r + 1, c, t, '+') + solve(n, r + 1, c + 1, t, '-') + solve(n, r + 1, c + 2, t, '/')\n            grid[r, c] = count\n            return count\n\n    return str(solve(n, 0, 0, int(t), op))\n\nstdin = \"\"\nstdin += \"8 2 7 -\\n1 1 1 2\\n\"\nstdin += \"9 2 7 -\\n1 1 1 2\"\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    m = int(lines[1])\n    t = int(lines[2])\n    op = lines[3]\n\n    res = 0\n    for r in range(n):\n        for c in range(n):\n            if isValid(r, c, n, m, t, op):\n                res += 1\n\n    return str(res)\n\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = list(map(int, stdin.split()))\n\n    ans = 1\n    for i in range(1, n + 1):\n        ans *= (t + m - 1) + 1\n\n    return str(ans)\n"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = stdin.split()\n    n, m, t, op = int(n), int(m), int(t), str(op)\n    # Horizontal Lines\n    for r in range(1, n + 1):\n        for c in range(1, n + 1):\n            if c <= r:\n                print(f\"{r} {c} {m} {op} {r - 1} {c}\")\n    # Vertical Lines\n    for c in range(1, n + 1):\n        for r in range(1, n + 1):\n            if r <= c:\n                print(f\"{r} {c} {m} {op} {r} {n}\")\n    # Diagonal Right to Left\n    for r in range(1, n + 1):\n        for c in range(1, n + 1):\n            if r + c <= n:\n                if c <= r:\n                    print(f\"{r} {c} {m} {op} {n} {c}\")\n    # Diagonal Left to Right\n    for r in range(1, n + 1):\n        for c in range(1, n + 1):\n            if r + c <= n:\n                if c <= r:\n                    print(f\"{n} {c} {m} {op} {r} {c}\")\n    return \"valid\""
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = stdin.split()\n    n, m, t, op = int(n), int(m), int(t), op\n    l = list()\n    for i in range(1, n + 1):\n        l.append([j for j in range(1, m + 1)])\n    for i in range(m):\n        for j in range(n):\n            if op == '+':\n                l[i][j] = l[i][j - 1] + l[i][j]\n            elif op == '-':\n                l[i][j] = l[i][j - 1] - l[i][j]\n            elif op == '*':\n                l[i][j] = l[i - 1][j] * l[i][j]\n            elif op == '/':\n                l[i][j] = l[i - 1][j] // l[i][j]\n    c = 1\n    for i in l:\n        print(i)\n    for i in range(len(l)):\n        for j in range(len(l[i])):\n            if l[i][j] == t:\n                c = c + 1\n    return str(c)"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    size, grid_size, target, operator = list(map(int, stdin.strip().split()))\n    grid = list(map(int, stdin.strip().split()))\n    if size!= grid_size:\n        return \"Invalid\"\n    if operator == '+':\n        return valid_plus(size, grid, target)\n    elif operator == '-':\n        return valid_minus(size, grid, target)\n    elif operator == '*':\n        return valid_multiply(size, grid, target)\n    elif operator == '/':\n        return valid_divide(size, grid, target)\n    return \"Invalid\"\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = list(map(int, stdin.split()))\n\n    def fill_grid(n, m, t, op, grid):\n        if n == 1 and m == 1 and t == 1:\n            return 1\n        ans = 0\n        for i in range(1, n):\n            if op == '*':\n                ans += fill_grid(i, m, t, '+', grid)\n            elif op == '+':\n                ans += fill_grid(n - i, m, t, '-', grid)\n            elif op == '-':\n                ans += fill_grid(n, m - i, t, '+', grid)\n            else:\n                ans += fill_grid(n, m, t - i, '*', grid)\n        return ans\n\n    return str(fill_grid(n, m, t, op, {}))"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    road = {}\n    for i in range(m):\n        a, b, l = map(int, stdin.split())\n        if a not in road:\n            road[a] = {}\n        if b not in road[a]:\n            road[a][b] = l\n        if b not in road:\n            road[b] = {}\n        if a not in road[b]:\n            road[b][a] = l\n    result = set()\n    for v in road.values():\n        for k in v.keys():\n            if k not in result:\n                result.add(k)\n    return len(result)"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    answer: int = 0\n\n    n: int = int(stdin.split(\" \")[0])\n    m: int = int(stdin.split(\" \")[1])\n\n    roads: List[Tuple[int, int, int]] = []\n    for i in range(m):\n        roads.append((int(stdin.split(\" \")[2 * i + 2]), int(stdin.split(\" \")[2 * i + 3]), int(stdin.split(\" \")[2 * i + 4])))\n\n    graph: Dict[int, Dict[int, int]] = {}\n    for (v1, v2, l) in roads:\n        if v1 not in graph:\n            graph[v1] = {v2: l}\n        else:\n            graph[v1][v2] = l\n\n        if v2 not in graph:\n            graph[v2] = {v1: l}\n        else:\n            graph[v2][v1] = l\n\n    print(graph)\n\n    def dfs(v: int, graph: Dict[int, Dict[int, int]], visited: List[int]):\n        for w in graph[v]:\n            if w not in visited:\n                visited.append(w)\n                dfs(w, graph, visited)\n\n    for v in graph:\n        dfs(v, graph, [])\n\n    lengths: List[int] = []\n    for i in graph:\n        lengths.append(len(graph[i]))\n\n    d: int = sorted(lengths)\n    answer = 0\n    for i in d:\n        answer += math.factorial(i)\n\n    return answer % 1000000007\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split()))\n    res = 0\n    for i in range(M):\n        road = list(map(int, stdin.split()))\n        if road[0]!= road[1] and road[1]!= road[2]:\n            res += 1\n    return str(res)"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    L = []\n    for i in range(M):\n        A, B, L = map(int, stdin.split())\n        L.append((A,B,L))\n    L.sort(key=lambda x: x[2])\n    dp = [[0 for j in range(N+1)] for i in range(N+1)]\n    dp[0][0]=1\n    dp_mod = pow(10,9) + 7\n    for i in range(N+1):\n        for j in range(N+1):\n            for k in range(len(L)):\n                if i == L[k][0]:\n                    dp[j][i] = (dp[j][i] + dp[i][L[k][1]]) % dp_mod\n    print(dp)\n    return str(dp[0][N])\n    return\n\nsolution(\"3 4\\n1 2 5\\n2 3 5\\n3 4 5\\n1 4 8\")"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    n, m = map(int, stdin.split())\n    cities = list(map(int, stdin.split()))\n    roads = [[] for _ in range(n)]\n    for i in range(m):\n        roads[cities[2 * i - 2] - 1].append(cities[2 * i - 1] - 1)\n        roads[cities[2 * i - 1] - 1].append(cities[2 * i - 2] - 1)\n    ans = []\n    for r in roads:\n        ans.append(shortest_paths(r))\n    return '\\n'.join(map(str, ans))\n\n\ndef"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split()\n    n = int(data[0])\n    m = int(data[1])\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        a, b, l = map(int, input().split())\n        graph[a].append([b, l])\n        graph[b].append([a, l])\n    ans = 0\n    for i in range(1, n+1):\n        q = deque([[i, 0]])\n        visited = set()\n        visited.add(i)\n        while q:\n            node, depth = q.popleft()\n            if node == n:\n                ans += 1\n                continue\n            for nd, l in graph[node]:\n                if nd in visited:\n                    continue\n                q.append([nd, depth+l])\n                visited.add(nd)\n    return str(ans % 1000000007)\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    # roads = [[] for _ in range(n)]\n    # for _ in range(m):\n    #     A, B, L = map(int, input().split())\n    #     # roads[A-1].append((B-1, L))\n    #     # roads[B-1].append((A-1, L))\n    #     roads[A-1].append((B-1, L))\n    #     roads[B-1].append((A-1, L))\n    # print(roads)\n    #\n    # # Do not edit this line!\n    # return sum(1 for road in roads if len(road) == 1) % 1000000007\n    roads = []\n    for _ in range(m):\n        A, B, L = map(int, stdin.split())\n        roads.append((B-1, L))\n        roads.append((A-1, L))\n    print(roads)\n    return sum(1 for road in roads if len(road) == 1) % 1000000007\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    roads = [list(map(int, stdin.split())) for _ in range(M)]\n    result = []\n\n    for road in roads:\n        roads_copy = roads.copy()\n        roads_copy.remove(road)\n\n        # Finding the common vertices with dfs\n        def common_vertex(c1, c2):\n            visited = set()\n            queue = deque([c1])\n            while queue:\n                node = queue.popleft()\n                visited.add(node)\n                for road in roads_copy:\n                    if road[0] == node and road[1] not in visited:\n                        queue.append(road[1])\n                    elif road[1] == node and road[0] not in visited:\n                        queue.append(road[0])\n\n            return len(visited)\n\n        # Find all the shortest paths with dfs\n        def all_shortest_paths(start):\n            visited = set()\n            q = deque([start])\n            shortest_paths = {start: 1}\n\n            while q:\n                curr = q.popleft()\n                visited.add(curr)\n                for road in roads_copy:\n                    if road[0] == curr and road[1] not in visited:\n                        q.append(road[1])\n                        shortest_paths[road[1]] = shortest_paths.get(road[1], 0) + 1\n\n            return shortest_paths\n\n        # Checking if the road is continous with another road in the graph\n        result.append(common_vertex(road[0], road[1]))\n        result.append(common_vertex(road[1], road[0]))\n        result.append(shortest_paths[road[1]])\n        result.append(shortest_paths[road[0]])\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    roads = [list(map(int, stdin.split())) for _ in range(M)]\n    #print(roads)\n    #N = 4\n    #M = 3\n    #roads = [[1, 2, 5], [2, 3, 5], [3, 4, 5], [1, 4, 8]]\n\n    graph = [[] for i in range(N + 1)]\n\n    # build graph\n    for road in roads:\n        graph[road[0]].append(road[1])\n        graph[road[1]].append(road[0])\n\n    ans = 0\n    for i in range(1, N + 1):\n        visited = set()\n        stack = [i]\n        while stack:\n            #print(stack)\n            node = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                stack.extend(graph[node])\n        #print(visited)\n        ans += len(visited)\n    return str(ans)"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, m = map(int, lines.pop(0).split())\n    roads = [[int(x) for x in lines.pop(0).split()] for i in range(m)]\n    roads.sort(key=lambda x: x[0])\n    return '\\n'.join(str(len(find_paths_for_one_road(n, roads))) for roads in roads)\n\n\ndef"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    return str(answer(N, K))\n\ndef"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(answer(int(stdin.split()[0]), int(stdin.split()[1])))\n"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    D = [int(i) for i in stdin.split()]\n    MODULO = 1000000007\n    dp = [[0] * K for _ in range(N)]\n    dp[0][D[0]] = 1\n    for i in range(1, N):\n        for j in range(K):\n            dp[i][j] = dp[i - 1][j]\n            if j - D[i] >= 0:\n                dp[i][j] += dp[i - 1][j - D[i]]\n            if j + D[i] <= K:\n                dp[i][j] += dp[i - 1][j + D[i]]\n    return str(dp[-1][-1])\n"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    dp = [[0 for _ in range(K+1)] for _ in range(N+1)]\n    for i in range(1, N+1):\n        dp[i][1] = 1\n        dp[i][2] = 1\n    for i in range(2, N+1):\n        for j in range(3, K+1):\n            dp[i][j] = dp[i-1][j]\n            for k in range(1, j):\n                dp[i][j] += dp[i-1][k]*dp[i][j-k]\n    return str(dp[N][K])\n"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    # too slow\n    def solve(n: int, k: int, s: str):\n        if n == 0:\n            return 1\n        if n == 1:\n            return k\n        if k == 1:\n            return n\n        if n == 2:\n            return 2*k - 1\n        \n        res = 0\n        for i in range(k+1):\n            res += solve(n-1, k-i, s+'0')\n        return res\n    return str(solve(n, k, ''))\n\ndef"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    fact = [1]*(n+1)\n    for i in range(1, n+1):\n        fact[i] = fact[i-1]*i\n    dp = [[0]*(k+1) for i in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            dp[i][j] = dp[i-1][j]\n            for color in range(1, k+1):\n                if color >= i:\n                    dp[i][j] = (dp[i][j] + dp[i-color][j])%1000000007\n    return str(dp[n][k])\n"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = (int(x) for x in stdin.split())\n    dp = [[[0] * K] * (N + 1) for _ in range(N + 1)]\n\n    for row in range(N, -1, -1):\n        for col in range(K, -1, -1):\n            for prev in range(row, -1, -1):\n                if col == K:\n                    dp[row][col] = 1\n                elif col == 0:\n                    dp[row][col] = 0\n                elif row!= prev:\n                    dp[row][col] = dp[row][col] + dp[prev][col - 1]\n\n    return str(dp[N][K])\n\nsolution(input())\n"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    return '%d' % (6**k % 1000000007)\n"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split()))\n    f = list(map(int, stdin.split()))\n    \n    # Your code here\n    return str(int(factorial(N) / (factorial(K) * factorial(N - K))))\n"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    f = list(map(int, stdin.split()))\n    cnt = 0\n    for i in range(1, n):\n        for j in range(i):\n            if f[i]!= f[j]:\n                cnt += 1\n    return str(cnt % (10**9 + 7))\nprint(solution(input()))\n"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    arr = stdin.splitlines()[1]\n    s = list(map(int, arr))\n    hashmap = {}\n    for i in range(1, n+1):\n        hashmap[i] = s.index(i)\n    ans = 0\n    for i in range(1, n+1):\n        ans += hashmap[i] * hashmap[n-i+1]\n    return str(ans % (10**9 + 7))"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    t = list(map(int, stdin.split()))\n    num = 1\n    for i in range(1, n + 1):\n        num = (num * (i - 1)) % (10**9 + 7)\n    \n    ways = 1\n    for t_i in t:\n        # find the x_i\n        x = t_i - 1\n        ways = (ways * num) % (10**9 + 7)\n        num = (num * x) % (10**9 + 7)\n    return ways"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    d = {}\n    res = 1\n    for i in a:\n        if i not in d.keys():\n            d[i] = 1\n        else:\n            res = res * (d[i] + 1)\n            d[i] += 1\n    return str(res)\n"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    table = stdin.split()[1]\n    table = list(map(int, table))\n    s = set()\n    def dfs(cur_table):\n        if len(s) == n:\n            return 1\n        s_count = len(s)\n        max_count = n\n        for i in range(n):\n            if i in s or table[i] > max_count:\n                continue\n            s.add(i)\n            max_count = max(max_count, table[i])\n            if dfs(cur_table+[max_count]):\n                return 1\n            max_count += 1\n            s.remove(i)\n        return 0\n    return dfs(table)%(10**9+7)\n\nsolution(\"2\\n1 2\")\nsolution(\"5\\n3 4 5 1 2\")"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = list(map(int, stdin.strip().split()))\n\n    s.sort()\n    s = tuple(s)\n    cache = {}\n\n    return answer(s, cache)\n\n\ndef"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sched = {i: [] for i in range(1, n + 1)}\n    for i in range(n):\n        a, b = map(int, stdin.split())\n        sched[a].append(b)\n        sched[b].append(a)\n\n    a, b = map(int, stdin.split())\n\n    def check(sched):\n        seen = set()\n        for i in range(1, n + 1):\n            if i not in seen:\n                if sched[i] == []:\n                    seen.add(i)\n                    yield i\n                else:\n                    seen.add(i)\n                    for j in sched[i]:\n                        seen.add(j)\n                        for s in check(sched):\n                            yield s\n\n    return len(list(check(sched))) % (10**9 + 7)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    rooms = list(map(int, stdin.split()))\n    rooms.sort()\n    count = 0\n    for i in range(len(rooms)-2):\n        if rooms[i]!= rooms[i+1]:\n            count += 1\n    return count"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    t = list(map(int, stdin.split()))\n    count = 0\n    if n == 1:\n        return 1\n    for i in range(1, n):\n        t.append(n - 1)\n    for i in range(n + 1):\n        for j in range(n + 1):\n            for k in range(n + 1):\n                if i == j or i == k or j == k:\n                    continue\n                if j + k >= n:\n                    break\n                count += t[i - 1] * (t[j - 1] - 1) * (t[k - 1] - 1)\n    return count % 1000000007\n"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    ts = list(map(int, stdin.split()))\n    ts.sort()\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    def count_hops(s, t):\n        return (t - s) * (s - 1) // 2 + count_hops(s + 1, t)\n    return count_hops(1, ts[-1] + 1) % 10**9 + 7\n\nprint(solution(input()))\n\"\"\"\n"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = list(map(int, stdin.split()))\n    return len(set(s)) % (10**9 + 7)\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.strip().split())\n    a = list(map(int, stdin.strip().split()))\n    res = 0\n    for i in range(1, R - 1):\n        for j in range(1, S - 1):\n            if a[i][j] > a[i][j - 1] and a[i][j] > a[i][j + 1] and a[i][j] > a[i - 1][j] and a[i][j] > a[i + 1][j]:\n                res = max(res, (a[i][j] + a[i - 1][j] + a[i + 1][j] + a[i][j - 1] + a[i][j + 1]) / 5)\n    return str(res)"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.strip().split())\n    matrix = [[int(item) for item in stdin.strip().split()] for _ in range(rows)]\n    result = 0\n    for i in range(rows):\n        for j in range(cols):\n            result = max(result, check_cool(matrix, rows, cols, i, j))\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    A = []\n    for _ in range(R):\n        A.append(list(map(int, stdin.split())))\n    n = R\n    while n > 1:\n        max = 0\n        for i in range(n):\n            for j in range(n):\n                if i + j < n:\n                    temp = A[i][j] + A[i + j][j]\n                    if temp > max:\n                        max = temp\n        n = max\n    return str(max)\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    rows, columns = map(int, stdin.split())\n\n    matrix = []\n    for _ in range(rows):\n        matrix.append(list(map(int, stdin.split())))\n\n    ans = 0\n    while True:\n        row_count = 0\n        col_count = 0\n        for row in range(rows):\n            for col in range(columns):\n                if row == 0 or col == 0:\n                    continue\n\n                if matrix[row][col] <= matrix[row-1][col] + matrix[row][col-1]:\n                    row_count += 1\n                if matrix[row][col] <= matrix[row][col-1] + matrix[row-1][col]:\n                    col_count += 1\n\n                if row_count == 2 or col_count == 2:\n                    ans = max(ans, col_count + row_count)\n                    break\n\n        if row_count == 2 or col_count == 2:\n            break\n\n        if row_count == 0 or col_count == 0:\n            return '0'\n\n    return str(ans)\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    A = []\n    for i in range(R):\n        A.append(list(map(int, stdin.split()[i])))\n    matrix = []\n    for i in range(R):\n        for j in range(S):\n            if A[i][j] == 0:\n                continue\n            matrix.append([A[i][j], i, j])\n    ans = 0\n    for i in range(R):\n        for j in range(S):\n            if A[i][j] == 0:\n                continue\n            for x in range(1, i + 1):\n                if A[i - x][j] == 0:\n                    continue\n                for y in range(1, j + 1):\n                    if A[i - x][j - y] == 0:\n                        continue\n                    if (i - x, j - y) in matrix:\n                        matrix.remove((i - x, j - y))\n                        ans += 1\n    return str(ans)\n\nstdin = \"\"\"3 3\n1 4 10\n5 2 6\n11 1 3\n\"\"\"\nprint(solution(stdin))"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    L = []\n    for _ in range(R):\n        L.append(list(map(int, stdin.split())))\n    n = len(L)\n    ans = 0\n    for r in range(1, n):\n        for c in range(1, n):\n            if r + 1 <= c:\n                continue\n            if L[r][c] <= L[r][c - 1] + L[r - 1][c]:\n                continue\n            for i in range(1, r):\n                if L[i][c] + L[r - i][c] >= L[i][c - 1] + L[r - i][c - 1]:\n                    continue\n                ans = max(ans, r + 1 + c - 1)\n            for i in range(1, n - c):\n                if L[i][c] + L[r][c + i - 1] >= L[i][c - 1] + L[r][c + i - 1]:\n                    continue\n                ans = max(ans, r + 1 + c + c - 1)\n    return str(ans)\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r = int(stdin.split()[0])\n    s = int(stdin.split()[1])\n    arr = [int(x) for x in stdin.split()[2].split(' ')]\n    result = 0\n    for i in range(r):\n        for j in range(s):\n            if i == 0 and j == 0:\n                result += 1\n            if (i == 1 and j == 1) or (i == 0 and j == 0):\n                continue\n            if arr[i][j] <= arr[i][j - 1] + arr[i - 1][j]:\n                if arr[i][j] <= arr[i - 1][j] + arr[i][j - 1]:\n                    result += 1\n                else:\n                    break\n    return str(result)\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    A = [[int(i) for i in stdin.split()] for _ in range(R)]\n    for row in range(R):\n        for col in range(S):\n            if row + 1 < R and col + 1 < S:\n                A[row][col] += A[row + 1][col] + A[row][col + 1]\n            if row + 1 < R:\n                A[row][col] += A[row + 1][col]\n            if col + 1 < S:\n                A[row][col] += A[row][col + 1]\n    return str(max(list(filter(lambda x: x > 1, A))))\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    A = []\n    for i in range(R):\n        A.append(list(map(int, stdin.split())))\n    ans = 0\n    for row in range(1, R):\n        for col in range(1, S):\n            if A[row][col] > A[row][col-1] + A[row][col+1] or A[row][col] > A[row-1][col] + A[row+1][col]:\n                ans += 1\n    return str(ans)\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    n, m = list(map(int, inputs[0].split()))\n    a = list(map(int, inputs[1].split()))\n\n    if n!= m:\n        return '0'\n    elif n == 1 and m == 1:\n        return '0'\n\n    result = 0\n\n    for i in range(1, n - 1):\n        if a[i] < 0:\n            break\n        for j in range(i + 1, n - 1):\n            if a[j] < 0:\n                break\n\n            temp = a[i] + a[j]\n            if temp > a[i] and temp > a[j] and temp <= a[i + 1] and temp <= a[j + 1]:\n                result = max(result, 2)\n\n    return str(result)\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    invited = []\n    for i in range(N-1):\n        invited.append(list(map(int, stdin.strip().split())))\n    invited.sort(key=lambda x: (x[0], x[1]))\n    ans = set()\n    for i in range(N-1):\n        if i == 0:\n            if invited[i+1][0] - 1 == invited[i][1] and invited[i][1] - 1 == invited[i+1][0]:\n                ans.add(tuple(sorted([invited[i][0], invited[i][1]])))\n            elif invited[i+1][0] - 1 == invited[i][1]:\n                ans.add(tuple(sorted([invited[i][0], invited[i][1]])))\n            else:\n                ans.add(tuple(sorted([invited[i][0], invited[i][1]])))\n        elif i == N - 2:\n            if invited[i][0] - 1 == invited[i - 1][1] and invited[i - 1][1] - 1 == invited[i][0]:\n                ans.add(tuple(sorted([invited[i][0], invited[i][1]])))\n            elif invited[i][0] - 1 == invited[i - 1][1]:\n                ans.add(tuple(sorted([invited[i][0], invited[i][1]])))\n            else:\n                ans.add(tuple(sorted([invited[i][0], invited[i][1]])))\n        else:\n            if invited[i+1][0] - 1 == invited[i][1] and invited[i][1] - 1 == invited[i+1][0]:\n                ans.add(tuple(sorted([invited[i][0], invited[i][1]])))\n            elif invited[i+1][0] - 1 == invited[i][1]:\n                ans.add(tuple(sorted([invited[i][0], invited[i][1]])))\n            else:\n                ans.add(tuple(sorted([invited[i][0], invited[i][1]])))\n    return len(ans)\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = set([int(x) for x in stdin.split()[1:]])\n    t = set([int(x) for x in stdin.split()[1:]])\n    count = 0\n    while s:\n        x = s.pop()\n        y = t.pop()\n        if x == y:\n            count += 1\n        elif x > y and (x + 1) in s:\n            s.remove((x + 1))\n        elif x < y and (x + 1) in t:\n            t.remove((x + 1))\n        elif x > y and (x - 1) in s:\n            s.remove((x - 1))\n        elif x < y and (x - 1) in t:\n            t.remove((x - 1))\n        else:\n            continue\n    return str(count)\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    V = list(map(int, stdin.split()[1:]))\n    res = 0\n    while True:\n        for i in range(N):\n            if V[i] == 1:\n                continue\n            if (V[i] - 1) % V[i - 1] == 0:\n                continue\n            if (V[i] - 1) % V[i + 1] == 0:\n                continue\n            break\n        else:\n            break\n        res += 1\n    print(res)\n    return res\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = stdin\n    a = list(map(int, stdin.split()))\n    a.sort()\n    print(a)\n    count = 0\n    if n == 1:\n        return \"1\"\n    for i in range(1, n):\n        if s[i] == s[i-1]:\n            count = count + 1\n        elif (s[i] == s[i-1] + 1) or (s[i] == s[i-1] - 1):\n            continue\n        else:\n            if s[i-1] == s[i] + 1:\n                if count > 1:\n                    return '%s'%(count)\n            if s[i-1] == s[i] - 1:\n                if count > 1:\n                    return '%s'%(count)\n            count = 0\n    return '%s'%(count)"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    people = {i: set() for i in range(1, n + 1)}\n\n    for j in range(n - 1):\n        a, b = list(map(int, stdin.split()))\n        people[a].add(b)\n        people[b].add(a)\n\n    visited = set()\n    ans = 0\n\n    for person in people:\n        visited.add(person)\n        if person!= 1 and not any(visited.intersection(jokes)):\n            ans += 1\n\n    return str(ans)\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    V_set = set(map(int, stdin.split()))\n    # print(V_set)\n    L_set = set()\n    for V in range(1, N+1):\n        if V in V_set:\n            continue\n        L = set()\n        for V_i in range(1, N+1):\n            if V_i in L_set:\n                continue\n            if (V_i in V_set) and (not L_set.issuperset((V_set - {V_i}))):\n                break\n            if (V_i not in V_set) and (not L_set.issuperset((V_set - {V_i}))):\n                break\n            L.add(V_i)\n        # print(L)\n        if len(L) == 0:\n            break\n        L_set.update(L)\n        # print(L_set)\n    print(len(L_set))\n    return '\\n'.join([str(i) for i in sorted(L_set)])\n    # return '\\n'.join([str(i) for i in L_set])\n    # return '\\n'.join(sorted(L_set))"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    n_arr = list(map(int, stdin.strip().split()))\n    n_arr = sorted(n_arr)\n    counter = 1\n    prev = n_arr[0]\n    for i in range(1, n):\n        if n_arr[i] == prev + 1:\n            prev = n_arr[i]\n        elif prev == n_arr[i] - 1:\n            counter += 1\n            prev = n_arr[i]\n    return str(counter)"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    r = 0\n    for x in range(A, B + 1):\n        if (x - 1) % (x - 2) == 0:\n            r += 1\n        if (x - 1) % (x - 3) == 0:\n            r += 1\n    return str(r)\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    ans = 0\n    for i in range(len(stdin) - 1):\n        x, y = map(int, stdin[i].split())\n        for j in range(i + 1, len(stdin)):\n            a, b = map(int, stdin[j].split())\n            if (x > a) and (x < b):\n                continue\n            if (y > a) and (y < b):\n                continue\n            if (abs(x - a) == 1) or (abs(x - b) == 1):\n                continue\n            if (abs(y - a) == 1) or (abs(y - b) == 1):\n                continue\n            break\n        ans += 1\n    return str(ans)\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time complexity : O(N)\n    Space complexity: O(N)\n    \"\"\"\n    n = int(stdin.splitlines()[0])\n    n_array = list(map(int, stdin.splitlines()[1].split()))\n    n_sup = int(stdin.splitlines()[2])\n    n_array.sort()\n    n_sup = set(n_sup)\n    res = 0\n    if n == 1:\n        if n_array[0] == n_array[1]:\n            return 1\n        else:\n            return 0\n    for i in range(n-1):\n        if n_array[i+1] - n_array[i] == 1:\n            res += 1\n    for i in range(1, n_sup):\n        if i not in n_array:\n            res += 1\n    return res\n"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    res = 0\n    ans = 0\n    while A!= 0 and B!= 0:\n        res += A % 10\n        A //= 10\n        res += B % 10\n        B //= 10\n    return str(res)"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    Q = int(stdin[0])\n    for i in range(Q):\n        A, B = map(int, stdin[i * 2 + 1].split())\n        if A > 0 and B > 0 and A < 100 and A + B <= 100:\n            print(A * (B - A) + A + 1)\n    return stdout"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin)\n    for i in range(q):\n        _, a, b = stdin.split()\n        a, b = int(a), int(b)\n        print(bin(b - a + 1).count('1'))\n    return ''"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin)\n    for _ in range(Q):\n        a, b = map(int, stdin.split())\n        res = 0\n        for i in range(1, b):\n            if a == i or a == b - i:\n                res += 1\n            else:\n                res += 2\n        print(res)\n    return \"\"\n"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    Q: int = int(stdin)\n    for _ in range(Q):\n        A: int = int(stdin)\n        B: int = int(stdin)\n        # Your code here\n    return str(answer)\n"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    lines = stdin.split('\\n')\n    lines = [line.strip() for line in lines if len(line.strip()) > 0]\n    return '\\n'.join(str(answer(line)) for line in lines)\n\n\ndef"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin)\n    for _ in range(Q):\n        A, B = map(int, stdin.split())\n        print(count(A,B))\n\ndef"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    Q: int = int(stdin.strip())\n    \n    if not (1 <= Q <= 100_000_000):\n        raise ValueError(\"Wrong input, try again\")\n\n    for _ in range(Q):\n        query: str = stdin.strip()\n\n        if not (len(query) == 2):\n            raise ValueError(\"Wrong input, try again\")\n\n        if not (1 <= int(query[0]) <= int(query[1]) <= 10_000_000):\n            raise ValueError(\"Wrong input, try again\")\n\n        print(recursive_query(int(query[0]), int(query[1])))\n    return \"\"\n\ndef"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    Q: int = int(stdin.strip())\n    for _ in range(Q):\n        A, B = map(int, stdin.strip().split())\n        count = 0\n        for i in range(1, A):\n            if (A % i) == 0:\n                count += 1\n            if (i % A) == 0:\n                count += 1\n            if (i % A!= 0) and (i % B == 0):\n                count += 1\n            if (i % A!= 0) and (i % B!= 0):\n                count += 1\n        print(count)\n    return \"\"\n"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = [line for line in stdin.split('\\n') if line]\n    Q = int(lines.pop(0))\n    for _ in range(Q):\n        A, B = list(map(int, lines.pop(0).split()))\n        lines.pop(0)\n        print(count_all(A, B))\n    return ''\n\n\ndef"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    cake = []\n    for i in range(n):\n        x, y = list(map(float, stdin.split()))\n        cake.append((x, y))\n    vertices = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            vertices.add((cake[i][0], cake[i][1]))\n            vertices.add((cake[j][0], cake[j][1]))\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                vertices.add((cake[i][0], cake[i][1]))\n                vertices.add((cake[j][0], cake[j][1]))\n                vertices.add((cake[k][0], cake[k][1]))\n    vertices = list(vertices)\n    vertices.sort(key=lambda x: (x[0], x[1]))\n    closest = float('inf')\n    for i in range(k):\n        for j in range(i + 1, k):\n            closest = min(closest, abs((cake[i][0] + cake[j][0]) * (cake[i][1] - cake[j][1])) / 2)\n    return '{:.6f}'.format(closest)\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    test_case_count = int(input_lines[0].split(' ')[0])\n    for i in range(1, test_case_count + 1):\n        cake_vertices = input_lines[i].split(' ')\n        n = int(cake_vertices[0])\n        k = int(cake_vertices[1])\n        cake_vertices = input_lines[i+1].split(' ')\n        cake_vertices = [(float(x), float(y)) for x,y in [(float(x), float(y)) for x,y in cake_vertices]]\n        cake_vertices.sort(key=lambda p: p[0])\n        cake_vertices.sort(key=lambda p: p[1], reverse=True)\n        cake_area = 0\n        for j in range(k):\n            cake_area += cake_vertices[j][0] * cake_vertices[j][1]\n        print(f'Case #{i}: {cake_area}')\n    return 'Case #{}: {}'.format(test_case_count, cake_area)\n\nsolution(input())\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    vertices = []\n    for _ in range(n):\n        x, y = map(float, input().split())\n        vertices.append((x, y))\n    points = sorted(vertices, key=lambda p: (p[0], -p[1]))\n\n    minx = min(point[0] for point in points)\n    maxx = max(point[0] for point in points)\n    miny = min(point[1] for point in points)\n    maxy = max(point[1] for point in points)\n    left = float(\"inf\")\n    right = float(\"-inf\")\n    if len(points) == 1:\n        return str(points[0][2])\n    for i in range(1, len(points)):\n        if points[i][1] <= miny:\n            continue\n        if points[i][0] >= maxx:\n            break\n        elif points[i][0] <= minx:\n            left = min(left, points[i][1])\n        elif points[i][0] >= maxx:\n            right = max(right, points[i][1])\n    return str(abs(right - left))"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(i) for i in stdin.split()]\n    cake = []\n    for i in range(n):\n        x, y = [int(j) for j in stdin.split()[i*2+1].split()]\n        cake.append((x, y))\n    convex = []\n    for i in range(len(cake)):\n        j = i\n        while j > 0 and cake[j][0] < cake[j-1][0]:\n            convex.append(cake[j-1])\n            j -= 1\n    for i in range(len(cake)):\n        j = i\n        while j < len(cake)-1 and cake[j][0] > cake[j+1][0]:\n            convex.append(cake[j+1])\n            j += 1\n    convex = list(dict.fromkeys(convex))\n    convex.sort(key=lambda x: (x[0], x[1]))\n    convex_vertices = [x for x in convex]\n    cut_points = []\n    cut_points.append(convex_vertices[0])\n    for i in range(len(convex_vertices)-1):\n        j = i+1\n        while j < len(convex_vertices) and convex_vertices[i][0] + convex_vertices[j][0] <= convex_vertices[i][1] + convex_vertices[j][1]:\n            j += 1\n        cut_points.append(convex_vertices[j-1])\n    cut_points.append(convex_vertices[-1])\n    cut_points.sort(key=lambda x: (x[0], -x[1]))\n    area = 0\n    for i in range(len(cut_points)-1):\n        area += (cut_points[i][0] + cut_points[i+1][0]) * (cut_points[i+1][1] - cut_points[i][1])\n    for i in range(len(convex)):\n        area -= (convex[i][0] + convex[i+1][0]) * (convex[i][1] - convex[i+1][1])\n    return '{:.6f}'.format(area)\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split('\\n')\n    while True:\n        try:\n            n, k = map(int, input.pop(0).split())\n            break\n        except:\n            print(\"Invalid Input\")\n    vertices = []\n    while len(input) > 0:\n        x, y = map(float, input.pop(0).split())\n        vertices.append((x, y))\n    vertices.sort(key=lambda tup: tup[1])\n    vertices.sort(key=lambda tup: tup[0])\n    n = len(vertices)\n    candidate = float('inf')\n    for i in range(1, n):\n        if vertices[i][1] - vertices[i - 1][1]!= 0:\n            mid = vertices[i - 1][1] + vertices[i][1] / 2\n            if vertices[i][0] - vertices[i - 1][0]!= 0:\n                mid = vertices[i - 1][0] + vertices[i][0] / 2\n            d = abs(mid - vertices[i][1]) / abs(mid - vertices[i - 1][1])\n            if d < candidate:\n                candidate = d\n    return str(candidate)\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_vertex(circle: set, vertex_coordinates: list) -> tuple:\n        for index, (x, y) in enumerate(vertex_coordinates):\n            if (x, y) in circle:\n                return (x, y, index)\n        return None\n\n    def get_vertex_by_index(circle: set, index: int) -> tuple:\n        for coordinate in circle:\n            if index == coordinate[-1]:\n                return coordinate\n\n    def get_point_between_two_circles(circle1: set, circle2: set) -> tuple:\n        if circle1.issuperset(circle2):\n            return None\n        else:\n            circle1_centroid = tuple(sum(t) / len(circle1) for t in zip(*circle1))\n            circle2_centroid = tuple(sum(t) / len(circle2) for t in zip(*circle2))\n            if circle1_centroid[0] < circle2_centroid[0]:\n                circle1 = circle1.difference({(circle1_centroid[0], circle1_centroid[1])})\n                circle2 = circle2.difference({(circle2_centroid[0], circle2_centroid[1])})\n                circle1 = set(sorted(list(circle1)))\n                circle2 = set(sorted(list(circle2)))\n            elif circle1_centroid[0] > circle2_centroid[0]:\n                circle1 = circle1.difference({(circle1_centroid[0], circle1_centroid[1])})\n                circle2 = circle2.difference({(circle2_centroid[0], circle2_centroid[1])})\n                circle1 = set(sorted(list(circle1)))\n                circle2 = set(sorted(list(circle2)))\n            else:\n                if circle1_centroid[1] < circle2_centroid[1]:\n                    circle1 = circle1.difference({(circle1_centroid[0], circle1_centroid[1])})\n                    circle2 = circle2.difference({(circle2_centroid[0], circle2_centroid[1])})\n                    circle1 = set(sorted(list(circle1)))\n                    circle2 = set(sorted(list(circle2)))\n                elif circle1_centroid[1] > circle2_centroid[1]:\n                    circle1 = circle1.difference({(circle1_centroid[0], circle1_centroid[1])})\n                    circle2 = circle2.difference({(circle2_centroid[0], circle2_centroid[1])})\n                    circle1 = set(sorted(list(circle1)))\n                    circle2 = set(sorted(list(circle2)))\n                else:\n                    if circle1_centroid[0] == circle2_centroid[0]:\n                        for index, (x, y) in enumerate(circle1):\n                            if y > circle2_centroid[1]:\n                                return (x, y, index)\n                        for index, (x, y) in enumerate(circle2):\n                            if y > circle1_centroid[1]:\n                                return (x, y, index)\n                    elif circle1_centroid[0] < circle2_centroid[0]:\n                        for index, (x, y) in enumerate(circle1):\n                            if x < circle2_centroid[0]:\n                                return (x, y, index)\n                        for index, (x, y) in enumerate(circle2):\n                            if x < circle1_centroid[0]:\n                                return (x, y, index)\n                    else:\n                        for index, (x, y) in enumerate(circle1):\n                            if y < circle2_centroid[1]:\n                                return (x, y, index)\n                        for index, (x, y) in enumerate(circle2):\n                            if y < circle1_centroid[1]:\n                                return (x, y, index)\n\n    circle1 = set(sorted(list(get_vertex(get_vertex(set(range(1, n + 1)), stdin.split('\\n')[0].split(' '))), stdin.split('\\n')[1].split(' ')))))\n    circle2 = set(sorted(list(get_vertex(get_vertex(set(range(1, n + 1)), stdin.split('\\n')[2].split(' '))), stdin.split('\\n')[3].split(' ')))))\n    for index, (x, y) in enumerate(stdin.split('\\n')[4].split(' ')):\n        if int(x) < int(y):\n            return '%.10f' % float(get_point_between_two_circles(circle1, circle2).count(index + 1))\n        else:\n            return '%.10f' % float(get_point_between_two_circles(circle2, circle1).count(index + 1))"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    cake = [(x, y) for x, y in [[int(x), int(y)] for x, y in stdin.strip().split()]]\n    # print(cake)\n    piece = []\n    for i in range(n):\n        piece.append(cake[i])\n        if i!= n-1:\n            piece.append(cake[i + 1])\n    piece.sort(key=lambda x: (x[1], x[0]))\n    points = []\n    for x, y in piece:\n        if points:\n            if (points[-1][0] == x) and (points[-1][1] == y):\n                points[-1][0] += 1\n                points[-1][1] += 1\n            else:\n                points.append((1, 1))\n        else:\n            points.append((1, 1))\n    points.sort(key=lambda x: x[0] + x[1])\n    # print(points)\n    cnt = 0\n    for i in range(n):\n        cnt += points[i][1]\n        if i!= n - 1:\n            cnt -= points[i + 1][0]\n    return str(cnt)"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cake = []\n    for _ in range(n):\n        x, y = list(map(float, stdin.split()))\n        cake.append((x, y))\n    return str(area_of_convex_polygon_cutting_cake(cake, k))"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = []\n    for i in range(n):\n        a.append([float(i) for i in stdin.split()])\n    return str(expected_area(n, k, a))\n\ndef"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = map(int, stdin.split())\n    connections = defaultdict(list)\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        connections[a].append(b)\n        connections[b].append(a)\n    in_r, out_r = defaultdict(set), defaultdict(set)\n    for i, connections in connections.items():\n        in_r[i] = set(connections)\n        out_r[i] = set(connections)\n    enemies = set(map(int, stdin.split()))\n    min_m = 0\n    for j in range(n):\n        for i in range(n):\n            if i == j:\n                continue\n            if len(in_r[i].intersection(out_r[j])) > 0:\n                min_m = max(min_m, len(in_r[i].intersection(out_r[j])))\n    return str(min_m)\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s, e, c, *ss = stdin.split()\n    S, E, C = int(s), int(e), int(c)\n    connections = {int(i): set() for i in ss}\n    for i in range(C):\n        s1, s2 = stdin.split()\n        connections[int(s1)].add(int(s2))\n        connections[int(s2)].add(int(s1))\n    enemies = set(range(E))\n    res = float('inf')\n    for s in range(S):\n        if s not in enemies:\n            for e in connections[s]:\n                if e not in enemies:\n                    res = min(res, len(connections[s] | connections[e]))\n    return str(res)\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    S, E, C = map(int, stdin.split())\n    connections = [[] for i in range(S + 1)]\n    enemies = []\n\n    for i in range(E):\n        a, b = map(int, stdin.split())\n        enemies.append((a, b))\n\n    for i in range(C):\n        a, b = map(int, stdin.split())\n        connections[a].append(b)\n        connections[b].append(a)\n\n    spies = set()\n    enemy_spies = set()\n\n    for i in range(1, S + 1):\n        if i not in enemies:\n            spies.add(i)\n        else:\n            enemy_spies.add(i)\n\n    spies = sorted(spies)\n    enemy_spies = sorted(enemy_spies)\n\n    spy_count = 1\n    enemy_count = 1\n\n    while spy_count!= len(spies) or enemy_count!= len(enemy_spies):\n        spy_count = len(spies)\n        enemy_count = len(enemy_spies)\n\n        spies_to_remove = set()\n        enemy_spies_to_remove = set()\n\n        for i in range(len(spies)):\n            if spies[i] in enemies:\n                enemy_count -= 1\n                enemy_spies_to_remove.add(spies[i])\n\n        for i in range(len(enemy_spies)):\n            if enemy_spies[i] in spies:\n                spy_count -= 1\n                spies_to_remove.add(enemy_spies[i])\n\n        for i in range(len(spies)):\n            if spies[i] in spies_to_remove:\n                spies_to_remove.remove(spies[i])\n\n        for i in range(len(enemy_spies)):\n            if enemy_spies[i] in enemy_spies_to_remove:\n                enemy_spies_to_remove.remove(enemy_spies[i])\n\n        if len(spies_to_remove) == len(spies) or len(enemy_spies_to_remove) == len(enemy_spies):\n            break\n\n        spies = sorted(spies - spies_to_remove)\n        enemy_spies = sorted(enemy_spies - enemy_spies_to_remove)\n\n    return str(len(spies)) + \"\\n\""
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    S, E, C = list(map(int, stdin.split()))\n    spy_list = list(map(int, stdin.split()))\n    spy_list.sort()\n    s1 = S\n    s2 = 0\n    result = 0\n    spy_set = set(spy_list)\n    while len(spy_set) > 1:\n        if s1 == s2:\n            s2 += 1\n            s1 -= 1\n        spy_set.remove(spy_list[s1])\n        spy_set.remove(spy_list[s2])\n        spy_set.add(spy_list[s1])\n        spy_set.add(spy_list[s2])\n        s1 -= 1\n        s2 += 1\n    if len(spy_set) == 1:\n        result = 1\n    return str(result)\nprint(solution(input()))\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    _, spies, enemies, connections, _ = stdin.split()\n    spies, enemies, connections = int(spies), int(enemies), int(connections)\n    connections = [[int(a) - 1 for a in b.split()] for b in connections.split(';')]\n    enemies = [[int(a) - 1 for a in b.split()] for b in enemies.split(';')]\n    res = 0\n    spies = set(range(spies))\n    for enemy in enemies:\n        spies.update(enemy)\n    spies -= set(range(enemies[0][0]))\n    while spies and enemies:\n        if len(spies) < spies and len(enemies) < enemies:\n            res += 1\n            spies.add(enemies[0][0])\n            enemies.pop(0)\n        else:\n            break\n        if len(spies) == spies and len(enemies) == enemies:\n            break\n        for connection in connections:\n            if connection[0] in spies and connection[1] in enemies:\n                enemies.pop(0)\n                spies.remove(connection[1])\n                break\n            if connection[0] in enemies and connection[1] in spies:\n                spies.remove(connection[0])\n                enemies.pop(0)\n                break\n    return str(res)\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    S, E, C = map(int, stdin.split())\n    edge = [list(map(int, stdin.split())) for _ in range(C)]\n    spy = set(range(1, S+1))\n    spy.remove(0)\n    connections = {\n        i: set()\n        for i in range(1, S+1)\n    }\n    for e1, e2 in edge:\n        connections[e1].add(e2)\n        connections[e2].add(e1)\n    \n    spy_friends = {\n        i: set()\n        for i in range(1, S+1)\n    }\n    for i in spy:\n        spy_friends[i] = set(connections[i]).difference(spy)\n    \n    res = (S - len(spy_friends)) * (C - len(spy_friends))\n    return str(res)"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # parse stdin\n    _, S, E, C = map(int, stdin.split())\n    # initialise the connections\n    conn = [[] for _ in range(S + 1)]\n    # count all connections\n    for i in range(C):\n        s1, s2 = map(int, stdin.split())\n        conn[s1].append(s2)\n        conn[s2].append(s1)\n    # count all enemies\n    enemies = set()\n    for i in range(1, S + 1):\n        if i in enemies:\n            continue\n        enemies.add(i)\n        for j in conn[i]:\n            enemies.add(j)\n    # count all spies\n    spies = set()\n    for i in range(1, S + 1):\n        if i in spies:\n            continue\n        spies.add(i)\n        for j in conn[i]:\n            spies.add(j)\n    # count all enemy spies\n    enemies_spies = 0\n    for i in range(1, S + 1):\n        if i in enemies:\n            enemies_spies += 1\n    return str(S - enemies_spies - len(spies))\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    N, M, C = stdin.pop(0).split()\n    spy_conns = {x: [] for x in range(int(N))}\n    for i in range(int(M)):\n        a, b = stdin.pop(0).split()\n        spy_conns[int(a)].append(int(b))\n        spy_conns[int(b)].append(int(a))\n    enemy = list(map(int, stdin.pop(0).split()))\n    \n    tot = 0\n    for i in range(int(N)):\n        if i in enemy:\n            continue\n        tot += 1\n        for j in range(int(N)):\n            if j in enemy:\n                continue\n            tot += 1\n            for k in range(int(N)):\n                if k in enemy:\n                    continue\n                if i in spy_conns[j] or j in spy_conns[i] or i == k:\n                    continue\n                tot += 1\n    return str(tot)"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s, e, c = map(int, stdin.split())\n    c_ = {}\n    min_ = float('inf')\n    for _ in range(c):\n        x, y = map(int, stdin.split())\n        if x not in c_:\n            c_[x] = set()\n        if y not in c_:\n            c_[y] = set()\n        c_.setdefault(x, set()).add(y)\n        c_.setdefault(y, set()).add(x)\n    spies = set(range(1, s + 1))\n    enemies = set(range(1, e + 1))\n    while spies and enemies:\n        spy = spies.pop()\n        if spy in enemies:\n            min_ += 1\n            break\n        enemies.remove(spy)\n        spies |= {x for x in c_[spy] if x in enemies}\n    return str(min_)"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    if A == 1:\n        return str(C * (C - 1) // 2)\n    if C == 1:\n        return str(A * (A - 1) // 2)\n    if M == 1:\n        return str(A * (A - 1) // 2)\n    if A <= 2:\n        return str(0)\n    if C <= 2:\n        return str(0)\n    if M <= 2:\n        return str(0)\n    if A <= 2 and C <= 2:\n        return str(0)\n    if M <= 2 and C <= 2:\n        return str(0)\n    if C == 2 and M == 2:\n        return str(0)\n    if A <= 4 and C <= 4:\n        return str(0)\n    if A <= 4 and C <= 6:\n        return str(0)\n    if C <= 4 and M <= 4:\n        return str(0)\n    if A <= 4 and M <= 4:\n        return str(0)\n    if A <= 6 and M <= 6:\n        return str(0)\n    dp = [[[None] * (C + 1) for _ in range(M + 1)] for _ in range(A + 1)]\n    dp[1][1][1] = 1\n    for i in range(2, A + 1):\n        for j in range(1, M + 1):\n            for k in range(1, C + 1):\n                dp[i][j][k] = dp[i - 1][j][k]\n                if k > 1:\n                    dp[i][j][k] += dp[i][j][k - 2]\n                if j > 1:\n                    dp[i][j][k] += dp[i][j - 1][k]\n                if i > 1:\n                    dp[i][j][k] += dp[i - 1][j][k]\n                dp[i][j][k] %= 1000000007\n    return str(dp[A][M][C])\n"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = list(map(int, stdin.split()))\n\n    if A == 1 and C == 1 and M == 1:\n        return '0'\n\n    def fact(n):\n        if n == 0:\n            return 1\n        return n * fact(n-1)\n\n    return (fact(A) * fact(C) * fact(M)) % 1000000007\n"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\" \")\n    A = int(stdin[0])\n    C = int(stdin[1])\n    M = int(stdin[2])\n    A = A + 1\n    C = C + 1\n    M = M + 1\n    sum = A + C + M\n    # print(sum)\n    if sum == 0:\n        return '0'\n    elif sum % 3 == 0:\n        return '1'\n    elif sum % 3 == 1:\n        return '2'\n    else:\n        return '3'\n    \n"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    dp = [[[0 for _ in range(C + 1)]\n           for _ in range(M + 1)]\n          for _ in range(A + 1)]\n    dp[0][0][0] = 1\n    for a in range(A + 1):\n        for c in range(C + 1):\n            for m in range(M + 1):\n                if a + 1 <= A and c + 1 <= C and m + 1 <= M:\n                    if m > c:\n                        dp[a][m][c] += dp[a][m - c][c]\n                    else:\n                        dp[a][m][c] += dp[a][m - c][c] + dp[a][m][c - m]\n    return dp[A][M][C] % (10 ** 9 + 7)\n"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, c, m = map(int, stdin.split())\n    ans = 0\n\n    for a1 in range(1, a + 1):\n        for a2 in range(1, a + 1):\n            for a3 in range(1, a + 1):\n                for a4 in range(1, a + 1):\n                    for c1 in range(1, c + 1):\n                        for c2 in range(1, c + 1):\n                            for c3 in range(1, c + 1):\n                                for c4 in range(1, c + 1):\n                                    for m1 in range(1, m + 1):\n                                        for m2 in range(1, m + 1):\n                                            for m3 in range(1, m + 1):\n                                                for m4 in range(1, m + 1):\n                                                    if a1 == a2 == a3 == a4 and c1 == c2 == c3 == c4 and m1 == m2 == m3 == m4:\n                                                        ans += 1\n    return str(ans % 1000000007)\n"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # YOUR CODE HERE\n    pass\n"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Solve given problem\n\n    # Convert input into 2D list of ints\n    arr = list(map(int, stdin.strip().split(' ')))\n\n    # Create a list of lists that will be used to store the answers for different sizes of boxes\n    answers = [[], [], [], [], []]\n\n    # For each of the 3, 2, and 1 boxes\n    for x in range(min(arr), max(arr) + 1):\n        # For each of the 3, 2, and 1 possible boxes of that size\n        for y in range(min(arr), max(arr) + 1):\n            # For each of the 3, 2, and 1 possible boxes of that size\n            for z in range(min(arr), max(arr) + 1):\n                # If all the 3 boxes of a certain size contain different types of fruits\n                if (x!= y) and (x!= z) and (y!= z):\n                    # Create a list that will hold the answers\n                    answers[0].append(x)\n                    answers[1].append(y)\n                    answers[2].append(z)\n                    # Add the number of such arrangements to the answers list\n                    answers[3].append(len(answers[0]) * len(answers[1]) * len(answers[2]))\n                    answers[4].append(len(answers[0]) * len(answers[1]) * len(answers[2]) % 1000000007)\n    return '\\n'.join(map(str, answers[4]))"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, c, m = map(int, stdin.split())\n    print(len(solution_one(a, c, m)))\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    def dp(n, m, s):\n        if n == 0:\n            return 1\n        if m == 0:\n            return 0\n        if s == 0:\n            return 0\n        if s < 0:\n            return 0\n        if n < 0 or m < 0 or n < m:\n            return 0\n        return dp(n-1, m, s) + dp(n, m-1, s-1)\n    return dp(A, C, M) % 1000000007"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Number of ways to arrange the apples\n    N = int(stdin)\n    arrange = [0] * (N + 1)\n    arrange[0] = 1\n    arrange[1] = 1\n    for i in range(2, N + 1):\n        # To arrange apples such that all boxes\n        # contain different types of fruits\n        # either apple and cherry or apple and mango\n        # or cherry and apple or cherry and mango\n        # or mango and apple or mango and cherry\n        # or mango and cherry and mango\n        # All of these cases have one difference\n        # in the order of boxes that contain fruit\n        # if the number of boxes with fruit in it\n        # is even (since the boxes are arranged in a\n        # decreasing order of number of fruit), then\n        # it is possible that the apple and cherry\n        # or apple and mango have the same difference\n        # in the order of boxes that contain fruit\n        # (since the boxes are arranged in a decreasing\n        # order of number of fruit)\n        if i % 2 == 0:\n            arrange[i] = (arrange[i - 2] + arrange[i - 1]) % 1000000007\n        else:\n            arrange[i] = (arrange[i - 1] + arrange[i - 2]) % 1000000007\n    return str(arrange[N])\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    b = []\n    for i in a:\n        if str(i)!= str(i)[::-1]:\n            b.append(i)\n        else:\n            b.append(\"impossible\")\n    return \"\\n\".join(b)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    while True:\n        for i in range(len(stdin)-1):\n            if int(stdin[i]) > int(stdin[i+1]):\n                stdin = stdin[:i] + str(int(stdin[i])+1) + stdin[i+2:]\n                break\n        else:\n            break\n    return str(stdin) if \"\".join(sorted(stdin))!= stdin else \"impossible\"\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # replace a digit with a digit\n    for i in range(10):\n        t = str(i)\n        if t not in stdin and n == int(stdin.replace(t, \"0\")):\n            return str(i)\n    return \"impossible\""
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_int(int_str: str) -> int:\n        return int(int_str)\n\n    def replace(start: int, nums: list, index: int, target: int) -> None:\n        while index < len(nums) and nums[index]!= target:\n            index += 1\n        if index == len(nums):\n            return\n        nums[start] = target\n        while index > start:\n            nums[index] = nums[index - 1]\n            index -= 1\n        if start == 0:\n            nums[index] = target\n        return\n\n    nums = list(map(get_int, stdin.split()))\n    while len(nums) >= 2 and nums[0] == nums[1]:\n        nums.pop(1)\n    if len(nums) <= 1:\n        return 'impossible'\n    index = 0\n    while index < len(nums):\n        if nums[index] <= 9:\n            replace(index, nums, index + 1, 11)\n        else:\n            replace(index, nums, index + 1, 10)\n        index += 1\n    return''.join(map(str, nums))\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    zeus_sorted_list = stdin.splitlines()[0]\n    zeus_unsorted_list = stdin.splitlines()[1]\n    zeus_unsorted_list_int = list(map(int, zeus_unsorted_list))\n    zeus_sorted_list_int = list(map(int, zeus_sorted_list))\n\n    if len(zeus_sorted_list_int)!= len(zeus_unsorted_list_int):\n        return \"impossible\"\n\n    if sorted(zeus_sorted_list_int) == zeus_unsorted_list_int:\n        return \"impossible\"\n\n    for digit in range(1, 10):\n        zeus_sorted_list_int = [x if x!= digit else digit for x in zeus_sorted_list_int]\n\n        if sorted(zeus_sorted_list_int) == zeus_unsorted_list_int:\n            return \"\".join(map(str, zeus_sorted_list_int))\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, z = stdin.split()\n    z = list(map(int, z.split()))\n    if n == 1:\n        return \"impossible\"\n    z.sort()\n    x, y = 1, 0\n    for i in range(n-1, -1, -1):\n        if z[i] <= y:\n            x = y\n        if z[i] > x:\n            z[i] = x\n            y = x\n    return \" \".join(str(i) for i in z)\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The ancient Egyptians used to express fractions as a sum of\n    two partial sums.\n    \"\"\"\n    n, *list_of_nums = map(int, stdin.split())\n    s = sum(list_of_nums)\n\n    if s == n:\n        return 'impossible'\n    elif s % n!= 0:\n        return 'impossible'\n    else:\n        return ''.join(f\"{i} {s // i}\" for i in list_of_nums)\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    list = stdin.split()\n    n = int(list[0])\n    list1 = list[1]\n    list1 = list1.split()\n    list1 = list1[::-1]\n    list1 = [int(i) for i in list1]\n    for i in range(n):\n        if list1[i]!= sorted(list1)[i]:\n            return \"impossible\"\n    return \"\".join(list1)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 2\n   ... 1 9999999\n   ... ''')\n    '2021 2020 2020'\n    >>> solution('''\n   ... 10\n   ... 2 9999999\n   ... 9 9999999\n   ... 8 8888888\n   ... 7 7777777\n   ... 6 666666\n   ... 5 5555\n   ... 4 444444\n   ... 3 333333\n   ... 2 2000000\n   ... 1 1\n   ... ''')\n    'impossible'\n    \"\"\"\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    if n < 2:\n        return 'impossible'\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            return 'impossible'\n        if a[i] == 0:\n            a[i] = 1\n        if a[i] % 10 == 0:\n            a[i] = 9\n        a[i + 1] = a[i] % 10\n    a[-1] = a[-1] % 10 + 1\n    return''.join(map(str, a))\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    houses = list(range(L, R + 1))\n    houses = [(str(house), '0' in str(house)) for house in houses]\n    houses = [(house[0], len(house[0]) - 1) for house in houses if house[1]]\n    houses = [(house[0], str(house[0]).count('6') == str(house[0]).count('8')) for house in houses]\n    houses = [(house[0], house[1] == True) for house in houses]\n    houses = sum(house[0] for house in houses) % (10 ** 9 + 7)\n    return str(houses)\n"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n1, n2 = map(int, stdin.split())\n    total_house = 0\n    while n1 <= n2:\n        if any([True if x in ['4', '6', '8'] else False for x in str(n1)]):\n            total_house += 1\n        n1 += 1\n    return str(total_house)"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    assert 1 <= L <= R <= 10 ** 20000\n    houses = 0\n    while L < R:\n        house = L + (R - L) // 2\n        if house.isnumeric() and all(c not in ['6', '8'] for c in str(house)):\n            L = house + 1\n            houses += 1\n        elif house.isnumeric() and all(c in ['6', '8'] for c in str(house)):\n            R = house - 1\n    return houses\n"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    l, r = list(map(int, stdin.split()))\n    return str(l + r - (l // 6 - l // 8))\n"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return (sum(1 for x in range(int(stdin.split()[0]), int(stdin.split()[1]) + 1) if any([x.isdigit() and not x.isdigit() in ('6', '8') for x in str(x)])))\n"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip()\n    l, r = map(int, stdin.split())\n    return''.join([str(i) for i in range(l, r+1) if no_good_digits(i)])\n\ndef"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = 0\n    for i in range(L, R+1):\n        # print(i)\n        if re.search(r'^[0-9]*$', str(i)) and (re.search(r'(6|8)[0-9]*$', str(i)) or re.search(r'(6|8)[0-9]*$', str(i)[::-1])):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    houses = list(range(l, r + 1))\n    for house in houses:\n        if any(map(lambda x: x in '36679', str(house))):\n            continue\n        digits = set(str(house))\n        if '6' in digits and '8' in digits:\n            continue\n        if len(digits.intersection('4')) == 0 and len(digits.intersection('6')) == 0:\n            return str(house)\n    return str(houses[-1])\n"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    return str(sum(i <= 4 or i == 6 or i == 8 for i in range(L, R + 1)))"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split())\n    x = x_init\n    cnt = 0\n    for i in range(Y):\n        x, cnt = boats(x, cnt, stdin)\n    return cnt % 1000000003\n\n\ndef"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    w, h, x = map(int, stdin.split())\n    if x == 0:\n        return 'begin repairs'\n    matrix = [stdin]\n    if w == 1:\n        return 'begin repairs'\n    for i in range(h):\n        matrix.append(''.join(['~' for _ in range(w)]))\n    boat_pos = x\n    while boat_pos!= h:\n        matrix = _solve_n(w, h, boat_pos, matrix)\n        boat_pos += 1\n    return ''.join(matrix)\n\n\ndef"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split())\n\n    def get_paths(current_x, current_y, boat_position):\n        if not (0 <= current_x < X and 0 <= current_y < Y):\n            return [\"begin repairs\"]\n\n        if current_x == X - 1:\n            if boat_position == \">\":\n                return [\"right\"]\n            else:\n                return [\"left\"]\n\n        if current_y == Y - 1:\n            if boat_position == \">\":\n                return [\"down\"]\n            else:\n                return [\"up\"]\n\n        if current_x == x_init and current_y == Y - 1:\n            return [\"begin repairs\"]\n\n        if current_x == x_init and current_y == 0:\n            return [\"begin repairs\"]\n\n        if current_x < X - 1:\n            return [\"right\", get_paths(current_x + 1, current_y, \">\")]\n\n        if current_x > 0:\n            return [\"left\", get_paths(current_x - 1, current_y, \"<\")]\n\n        if current_y < Y - 1:\n            return [\"down\", get_paths(current_x, current_y + 1, \">\")]\n\n        if current_y > 0:\n            return [\"up\", get_paths(current_x, current_y - 1, \"<\")]\n\n    paths = get_paths(0, 0, \">\")\n    return paths[0] if len(paths) == 1 else paths[1]\n\n\ndef"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    y, x, x_init = map(int, stdin.split())\n\n    grid = [[c for c in stdin] for _ in range(y)]\n\n    def get_paths(row, col):\n        if grid[row][col] == '@':\n            return 1\n        elif grid[row][col] == '~':\n            return 0\n        elif grid[row][col] == '>':\n            return 1 if x_init - col >= 0 else 0\n        elif grid[row][col] == '<':\n            return 1 if col - x_init >= 0 else 0\n\n    for row in range(y):\n        for col in range(x):\n            grid[row][col] = get_paths(row, col)\n\n    def count_paths(row, col):\n        if grid[row][col] == 0:\n            return 0\n        elif grid[row][col] == 1:\n            return 1\n        elif grid[row][col] == 2:\n            return 1\n        elif grid[row][col] == 3:\n            return 1\n        else:\n            return count_paths(row, col + 1) + count_paths(row + 1, col)\n\n    return count_paths(0, 0) % 1000000007\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split())\n    rows, cols = Y, X\n    sea = {\n        \"~\": 1,\n        \"#\": -1,\n        \">\": -1,\n        \"<\": 1,\n    }\n    x = x_init\n    moves = {\n        1: (0, 1),\n        2: (-1, 0),\n        3: (1, 0),\n        4: (0, -1),\n    }\n    sea_map = []\n    for _ in range(Y):\n        sea_map.append([sea[i] for i in stdin.strip().split(\"\\n\")[_]])\n    print(sea_map)\n    # sea_map = list(sea_map)\n    count = 0\n    sea_map[x] = sea_map[x].copy()\n    sea_map[x] = (sea_map[x][0], sea_map[x][1], sea_map[x][2])\n    print(sea_map)\n    while x!= x_init:\n        if sea_map[x] == (-1, -1, -1):\n            return\n        sea_map = move(sea_map, moves[sea_map[x][2]])\n        count += 1\n        x = x + moves[sea_map[x][2]]\n    if sea_map[x] == (1, 1, 1):\n        return count\n    return \"begin repairs\"\n\ndef"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split())\n    arr = stdin.split()\n    if x_init == X:\n        return 'begin repairs'\n    if x_init == 0:\n        return 'begin repairs'\n    if Y == 0:\n        return 'begin repairs'\n    if arr[0] == '@':\n        return 'begin repairs'\n    if Y == 1:\n        return 'begin repairs'\n    if arr[0] == '>':\n        return str(0)\n    if arr[0] == '<':\n        return str(0)\n    if arr[0] == '~':\n        return str(1)\n    if arr[0] == '#':\n        return str(1)\n    i = 0\n    count = 1\n    while i < X:\n        if count == 1:\n            if arr[i] == '>':\n                count += 1\n                i += 1\n                if count == 2:\n                    i += 1\n            elif arr[i] == '<':\n                count += 1\n                i -= 1\n                if count == 2:\n                    i -= 1\n            elif arr[i] == '~':\n                count += 1\n                i += 1\n                if count == 2:\n                    i += 1\n            elif arr[i] == '#':\n                count += 1\n                i -= 1\n                if count == 2:\n                    i -= 1\n            else:\n                raise ValueError('Unknown letter')\n        elif count == 2:\n            if arr[i] == '>':\n                count += 1\n                i += 1\n                if count == 3:\n                    count = 1\n                    i += 1\n            elif arr[i] == '<':\n                count += 1\n                i -= 1\n                if count == 3:\n                    count = 1\n                    i -= 1\n            elif arr[i] == '~':\n                count += 1\n                i += 1\n                if count == 3:\n                    count = 1\n                    i += 1\n            elif arr[i] == '#':\n                count += 1\n                i -= 1\n                if count == 3:\n                    count = 1\n                    i -= 1\n            else:\n                raise ValueError('Unknown letter')\n        elif count == 3:\n            if arr[i] == '>':\n                count += 1\n                i += 1\n                if count == 4:\n                    count = 1\n                    i += 1\n            elif arr[i] == '<':\n                count += 1\n                i -= 1\n                if count == 4:\n                    count = 1\n                    i -= 1\n            elif arr[i] == '~':\n                count += 1\n                i += 1\n                if count == 4:\n                    count = 1\n                    i += 1\n            elif arr[i] == '#':\n                count += 1\n                i -= 1\n                if count == 4:\n                    count = 1\n                    i -= 1\n            else:\n                raise ValueError('Unknown letter')\n        elif count == 4:\n            if arr[i] == '>':\n                count += 1\n                i += 1\n                if count == 5:\n                    count = 1\n                    i += 1\n            elif arr[i] == '<':\n                count += 1\n                i -= 1\n                if count == 5:\n                    count = 1\n                    i -= 1\n            elif arr[i] == '~':\n                count += 1\n                i += 1\n                if count == 5:\n                    count = 1\n                    i += 1\n            elif arr[i] == '#':\n                count += 1\n                i -= 1\n                if count == 5:\n                    count = 1\n                    i -= 1\n            else:\n                raise ValueError('Unknown letter')\n        elif count == 5:\n            if arr[i] == '>':\n                count += 1\n                i += 1\n                if count == 6:\n                    count = 1\n                    i += 1\n            elif arr[i] == '<':\n                count += 1\n                i -= 1\n                if count == 6:\n                    count = 1\n                    i -= 1\n            elif arr[i] == '~':\n                count += 1\n                i += 1\n                if count == 6:\n                    count = 1\n                    i += 1\n            elif arr[i] == '#':\n                count += 1\n                i -= 1\n                if count == 6:\n                    count = 1\n                    i -= 1\n            else:\n                raise ValueError('Unknown letter')\n        elif count == 6:\n            if arr[i] == '>':\n                count += 1\n                i += 1\n                if count == 7:\n                    count = 1\n                    i += 1\n            elif arr[i] == '<':\n                count += 1\n                i -= 1\n                if count == 7:\n                    count = 1\n                    i -= 1\n            elif arr[i] == '~':\n                count += 1\n                i += 1\n                if count == 7:\n                    count = 1\n                    i += 1\n            elif arr[i] == '#':\n                count += 1\n                i -= 1\n                if count == 7:\n                    count = 1\n                    i -= 1\n            else:\n                raise ValueError('Unknown letter')\n        elif count == 7:\n            if arr[i] == '>':\n                count += 1\n                i += 1\n                if count == 8:\n                    count = 1\n                    i += 1\n            elif arr[i] == '<':\n"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = stdin.split('\\n')\n    a, b, c = int(a), int(b), int(c)\n    matrix = [[0 for i in range(a)] for j in range(b)]\n    for i in range(0, a):\n        matrix[0][i] = '~'\n    for i in range(1, b):\n        matrix[i][0] = '~'\n    for i in range(1, b):\n        for j in range(1, a):\n            if matrix[i - 1][j - 1] == '~':\n                matrix[i][j] = '#'\n            elif matrix[i - 1][j - 1] == '#':\n                matrix[i][j] = '#'\n            elif matrix[i - 1][j - 1] == '@':\n                matrix[i][j] = '@'\n            else:\n                matrix[i][j] = '>'\n    matrix[b - 1][a - 1] = '@'\n    for i in range(a):\n        for j in range(b):\n            print(matrix[i][j], end='')\n        print()\n    return matrix\n"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return 1\n"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, x = map(int, stdin.split())\n    sea = stdin.split('\\n')\n    out = 0\n    for y in range(len(sea)):\n        for x in range(cols):\n            if sea[y][x] == '@':\n                # print(y)\n                if x == 0 or sea[y][x - 1] == '#':\n                    out += 1\n                if x == cols - 1 or sea[y][x + 1] == '#':\n                    out += 1\n            if sea[y][x] == '>':\n                if x == 0 or sea[y][x - 1] == '#':\n                    out += 1\n                if x == cols - 1 or sea[y][x + 1] == '#':\n                    out += 1\n            if sea[y][x] == '<':\n                if x == 0 or sea[y][x - 1] == '#':\n                    out += 1\n                if x == cols - 1 or sea[y][x + 1] == '#':\n                    out += 1\n    return out % 1000003\n\n\nprint(solution(stdin))\n\"\"\""
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict, deque\n    lines = deque(stdin.split('\\n'))\n    Y = int(lines.popleft())\n    X = int(lines.popleft())\n    x_init = int(lines.popleft())\n    curr = 0\n    count = 0\n    paths = defaultdict(set)\n    boat_dir = deque('^>v<')\n    s_b = (x_init, 0)\n    s_d = (0, 1)\n    while lines:\n        line = lines.popleft()\n        if line == '':\n            break\n        if line == 'begin repairs':\n            paths = defaultdict(set)\n            break\n        if line.startswith('@'):\n            curr = (x_init, 0)\n            s_b = curr\n            continue\n        if line.startswith('~'):\n            curr = (x_init, Y)\n            s_d = curr\n            continue\n        if line.startswith('>'):\n            boat_dir.rotate(-1)\n        if line.startswith('<'):\n            boat_dir.rotate(1)\n        curr = (boat_dir[0] + s_b[0], s_d[1] + s_b[1])\n        if line.startswith('#'):\n            curr = (boat_dir[0] + s_d[0], s_d[1] + s_b[1])\n        if line.startswith('@'):\n            curr = (boat_dir[0] + s_b[0], s_d[1] + s_b[1])\n        if curr in paths:\n            paths[curr].add(boat_dir[0])\n        else:\n            paths[curr] = set([boat_dir[0]])\n        if curr[1] == 0:\n            boat_dir.rotate(1)\n        else:\n            boat_dir.rotate(-1)\n    return count % (10**9 + 7)"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    print(stdin)\n    result = stdin.split()\n    A = int(result[0])\n    S = int(result[1])\n    arr = []\n    arr.append(A)\n    for i in range(1, 1000000):\n        if A + i <= S:\n            arr.append(A + i)\n    arr.sort()\n    # print(arr)\n    if len(arr) == 0:\n        print('No solution')\n        return\n    min_add_ops = arr[0]\n    index = 1\n    while index < len(arr):\n        if arr[index] - arr[index - 1] <= min_add_ops:\n            min_add_ops = arr[index] - arr[index - 1]\n        index += 1\n    if min_add_ops!= arr[-1] - arr[-2]:\n        print(f'No solution')\n    else:\n        print(f'{str(arr[0])}+{str(min_add_ops)}={str(arr[-1])}')\n    return"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    nums = stdin.split('=')[1]\n    nums = nums.split('+')\n    nums.sort(key=lambda x: int(x))\n    for i in range(len(nums)-1):\n        nums[i] += str(int(nums[i]) + int(nums[i+1]))\n    return '+'.join(nums)"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # split to strs\n    numbers = stdin.split()\n\n    # initialize A, S, count\n    a = int(numbers[0])\n    s = int(numbers[1])\n    count = 0\n\n    # while we have not reached 0\n    while a!= 0:\n        # take a left digit, add one to it\n        a, rem = divmod(a, 10)\n        # if a is not 0, subtract 1 from S\n        if a!= 0:\n            s, rem = divmod(s, 10)\n            # count the number of additions\n            count += 1\n    # return the number of additions\n    return count"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, S = map(int, stdin.split())\n    arr = []\n    for i in range(A + 1):\n        for j in range(S - A + 1):\n            if S - A + 1 <= i + j:\n                continue\n            if A * i + S - A * i - j > S:\n                continue\n            if S - A - 1 < j:\n                break\n            A_plus = i\n            A_minus = i - j\n            S_plus = A * i + S - A * i - j\n            S_minus = S - A - 1\n            arr.append(str(S_plus))\n            arr.append(str(S_minus))\n            arr.append(str(A_plus))\n            arr.append(str(A_minus))\n            return '+'.join(arr)\n            break\n    return '-'.join(arr)\n\nsolution('143175=120')\nsolution('5025=30')\n"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.split(\"=\")\n    a = list(map(int, a))\n    for x in range(1, a[1]+1):\n        a[0] = str(a[0])\n        if len(a[0]) >= x:\n            if a[0][x] == \"0\" and a[0][x-1]!= \"0\":\n                a[0] = str(int(a[0][:x-1]) + 1) + str(a[0][x:])\n            elif a[0][x]!= \"0\":\n                a[0] = str(int(a[0][:x]) + 1) + str(a[0][x:])\n            elif a[0][x-1] == \"0\":\n                a[0] = str(int(a[0][:x-1]) + 1) + str(a[0][x:])\n    return str(a[0])\nsolution(\"143175=120\")\nsolution(\"5025=30\")\n"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if (n%100) > 1:\n        a = (n%100)\n    else:\n        a = 0\n    s = (n//100)\n    n = n//100\n    s = str(s)\n    s = s[::-1]\n    return f\"{a}+{n}+{s}\""
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, s = stdin.split('=')\n    print(a, s, sep='=', end='')\n    l, r = a.split('+')\n    return f'{sum(map(int, l))}+{sum(map(int, r))}={\"\".join(map(str, l))}{sum(map(int, r))}'"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.split('=')\n    A = list(A)\n    S = list(S)\n    for i in range(len(A)-1, 0, -1):\n        if A[i-1] == '0':\n            A[i-1] = '1'\n            A[i] = '0'\n            S[i-1] = '9'\n            S[i] = '0'\n            break\n    #print(A)\n    #print(S)\n    ans = ''\n    for i in range(len(S)):\n        if S[i] == '0':\n            ans += str(A[i])\n        elif S[i] == '1':\n            ans += str(S[i])\n        else:\n            ans += str(A[i]) + str(S[i])\n    return str(ans)\n"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    str1=stdin.split(\"=\")\n    if str1[1]==\"=\" and len(str1)==2:\n        a=int(str1[0])\n        b=int(str1[1])\n        if (a>b) or (a==b):\n            print(a-b)\n        else:\n            print(b-a)\n    else:\n        print(\"\")\n    return \"\""
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.split(\"=\")\n    A, S = int(A), int(S)\n    \n    # print(A,S)\n    \n    result = \"\"\n    while A!= 0:\n        if A % 10 > S % 10:\n            result = result + str(S)\n            S = S // 10\n        else:\n            result = result + str(A)\n            A = A // 10\n        A = A % 10\n    # print(result)\n    return result\n\nsolution(\"143175=120\")\nsolution(\"5025=30\")\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Takes a string of integers and returns the lexicographically smallest pair of integers in which a pair exists.\n    '''\n    s = stdin.splitlines()\n\n    # print(\"s\", s)\n    s = list(map(int, s))\n    # print(\"s\", s)\n\n    #s = sorted(s)\n    #print(\"s\", s)\n\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            #print(s[i], s[j])\n            if s[i] == s[j]:\n                print(\"{} {}\".format(s[i], s[j]))\n                exit(0)\n\n    return \"1\"\n\ndef"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    n = int(stdin.pop(0))\n    x = stdin.pop(0)\n    ans = -1\n    for i in range(n):\n        a, b = 0, 1\n        flag = True\n        while b <= n and flag:\n            if x == str(a)+str(b)+str(a)+str(b):\n                flag = False\n                ans = max(ans, max(a, b))\n            b += 1\n    if ans == -1:\n        print(\"-1\")\n    else:\n        print(\"%d %d\" % (ans, ans))\n    return None"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    S = sorted(list(map(int, stdin.split())))\n    for i in range(len(S)):\n        for j in range(i+1, len(S)):\n            if S[i]!= S[j]:\n                if S[i] < S[j]:\n                    print(S[i], S[j])\n                    break\n    return \" \".join(map(str, range(S[0], S[-1]+1)))"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    S = [int(i) for i in stdin.split(\"\\n\")]\n    if len(S) == 2:\n        return str(S[0]) + str(S[1])\n    N = len(S)\n    for A in range(1, N):\n        if A == 1:\n            B = N\n        else:\n            B = N\n        for D in range(N):\n            E = D + 1\n            if E > N:\n                E = N\n            F = D + 2\n            if F > N:\n                F = N\n            G = D + 3\n            if G > N:\n                G = N\n            if A in S and B in S and A!= B and S[A - 1] == S[D] and S[E] == S[F] and S[G] == S[D]:\n                return str(A) + str(B)\n    return \"-\"\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    This is a function problem.You only need to complete the function given below without modifying it.\n    The input is handled by the main function and represented by the parameter `stdin`.\n    '''\n    n = int(stdin)\n    seq = list(map(int, input().split()))\n\n    # if we have only 2 elements, we check if the first element is less than the second element\n    if len(seq) == 2:\n        if seq[0] < seq[1]:\n            return str(seq[0]) +'' + str(seq[1])\n\n    # if the length of sequence is greater than 2, we need to check if the sequence is a increasing sequence.\n    # for that we do a simple check: if the first element of the sequence is less than the first element after it, then it is a decreasing sequence.\n    # we initialize the stack to store the values of the first element in the sequence.\n    stack = []\n    for i in range(n):\n        if len(stack) == 0:\n            stack.append(seq[i])\n        else:\n            if stack[-1] > seq[i]:\n                stack.append(seq[i])\n            else:\n                # if the stack is not empty and the first element is less than the second element in the sequence, then it is a decreasing sequence\n                return str(-1)\n\n    # at this point, if the stack is empty, then there is no decreasing sequence.\n    # we iterate over the stack and extract the values and print them.\n    # also, we have to check if there is a decreasing sequence.\n    # if there is, we have to find the lowest value and print it.\n    # otherwise we have to return -1\n    for i in range(len(stack)):\n        if i == len(stack) - 1:\n            return str(stack[i])\n        elif stack[i] > stack[i + 1]:\n            return str(stack[i])\n    return str(-1)\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    S = list(map(int, stdin.split()))\n\n    for i in range(len(S)):\n        first = S[i]\n        for j in range(i + 1, len(S)):\n            second = S[j]\n            if first < second:\n                if first == second + 1:\n                    print(\"{} {}\".format(first, second))\n                    return\n            elif first > second:\n                if first == second - 1:\n                    print(\"{} {}\".format(first, second))\n                    return\n    print(-1)\n\nsolution(input())\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    patterns = set()\n    for _ in range(int(stdin)):\n        patterns.add(stdin.rstrip().split(' '))\n    for _ in range(int(stdin)):\n        patterns.add(stdin.rstrip().split(' '))\n    return''.join(sorted(patterns, key=lambda x: (-len(x), x)))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    s = [int(stdin) for _ in range(N)]\n    if N <= 2:\n        print('-1')\n        return\n    n = len(s)\n    s.sort()\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                print(s[i], s[j])\n                return\n    print('-1')\nsolution(input())\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return str(min(a, b)) + \" \" + str(max(a, b)) if a!= b else \"-1\"\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    l = []\n    n = 0\n    while n < N:\n        l.append(int(stdin))\n        n = n + 1\n    l = sorted(l)\n    print(l)\n    i = 1\n    while i < len(l):\n        if l[i-1] == l[i] - 1 and l[i] == l[i+1] - 1:\n            i = i + 1\n        else:\n            i = i + 1\n    if l.count(l[0]) > 1:\n        return l[0]\n    elif l.count(l[-1]) > 1:\n        return l[-1]\n    else:\n        return '-1'\n\nsolution(input())\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    # for i in lines:\n    #     print(i)\n    lines = [i.strip() for i in lines]\n    \n    print(lines)\n    \n    n = int(lines.pop(0))\n    lights = {i:1 for i in range(1,n+1)}\n    print(lights)\n    times = 1\n    \n    while lines:\n        light, value = lines.pop(0).split()\n        if lights[int(light)] == 1:\n            lights[int(light)] = 0\n        elif lights[int(light)] == 0:\n            lights[int(light)] = 1\n        print(lights)\n        times += 1\n    print(times)\n    # print(lights)\n    return times\n\nsolution(\"1101\")\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().splitlines()\n    lights = {i: 0 for i in range(16)}\n    timesteps = 0\n    for line in lines:\n        for i in range(len(line)):\n            lights[i] += int(line[i])\n        timesteps += 1\n        if timesteps >= 2:\n            lights = {i: lights[i] % 2 for i in range(16)}\n            timesteps = 0\n    return '\\n'.join(map(str, lights))\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return 0\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    lights = n\n    T = 1\n    while lights > 0:\n        if lights == 0:\n            return T\n        for i in range(lights):\n            if stdin[i] == '1':\n                lights -= 1\n        T += 1\n        lights += T\n    return T\nprint(solution(stdin))\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lights_on = []\n    lights_off = []\n    for line in stdin.splitlines():\n        if line[0] == '1':\n            lights_on.append(line[1])\n        else:\n            lights_off.append(line[1])\n    for i in range(1, len(lights_on)):\n        lights_on[i-1] = lights_on[i] + lights_off[i-1]\n        lights_off[i] = lights_on[i] + lights_off[i]\n    return lights_on[0]\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lights = {}\n    for i in range(1, len(stdin) + 1):\n        if stdin[i - 1] == \"1\":\n            lights[i] = 1\n        else:\n            lights[i] = 0\n    \n    for i in range(len(lights)):\n        if lights[i] == 1:\n            lights[i] = 0\n        else:\n            lights[i] = 1\n\n    for i in range(len(lights) - 1):\n        if lights[i + 1] == 0:\n            lights[i + 1] = 1\n        else:\n            lights[i + 1] = 0\n    \n    return(sum(lights.values()))\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    turn_off = False\n    turn_on = False\n    lights = []\n    for i in range(len(stdin)):\n        lights.append(stdin[i])\n    for i in range(len(lights)):\n        if lights[i] == '1' and turn_off is False:\n            turn_on = True\n        elif lights[i] == '0' and turn_on is True:\n            turn_off = True\n        if turn_on and turn_off:\n            lights[i] = '1'\n        elif turn_on:\n            lights[i] = '0'\n    return \"\".join(lights)\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    routes = []\n    for _ in range(n):\n        route = list(map(int, stdin.split()))\n        routes.append(route)\n    #print(routes)\n    pairs = []\n    for i in range(m):\n        pairs.append(list(map(int, stdin.split())))\n    #print(pairs)\n    for pair in pairs:\n        s = pair[0] - 1\n        e = pair[1]\n        a = pair[2] - 1\n        b = pair[3]\n        c = pair[4] - 1\n        d = pair[5] - 1\n        A = routes[s]\n        B = routes[a]\n        C = routes[c]\n        D = routes[d]\n        E = routes[e]\n        f = []\n        for i in range(len(A)):\n            if A[i] == B[i] and C[i] == D[i] and E[i] == A[i]:\n                f.append(i + 1)\n        print(f)\n    return stdout\n\n\nsolution(input())\n"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n    t = []\n    for _ in range(N):\n        t.append(list(map(int, stdin.strip().split())))\n    \n    def chk_turn(t, x):\n        if t[x-1] == t[x+1]:\n            return True\n        return False\n    \n    def chk_drv(t, x):\n        if t[x-1] == t[x]:\n            return True\n        return False\n    \n    def chk_same(t, x, y):\n        if t[x] == t[y]:\n            return True\n        return False\n    \n    def chk_meet(t, x):\n        if t[x] > t[x+1]:\n            return True\n        return False\n    \n    for i in range(len(t)):\n        t[i] = sorted(t[i])\n    \n    ans = 0\n    for i in range(len(t)):\n        for j in range(len(t)):\n            if i!= j:\n                if chk_turn(t, i+1) == True and chk_drv(t, i+1) == True and chk_meet(t, i+1) == True and chk_same(t, i+1, j+1) == True:\n                    ans += 1\n    return str(ans)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    truck_route = list(map(int, stdin.split()))\n    for _ in range(M):\n        a, b = map(int, input().split())\n        if a < b:\n            a, b = b, a\n        for i in range(a - 1, b):\n            truck_route[i] = b\n    return \" \".join([str(x) for x in truck_route])\n"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    route1 = list(map(int, stdin.split()))\n    route2 = list(map(int, stdin.split()))\n    ans = []\n    for i in range(m):\n        ans.append(solution_pair(n, route1, route2))\n    return''.join(map(str, ans))\n\ndef"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    (N, M) = (int(x) for x in stdin.split())\n    input_list = list()\n    for _ in range(N):\n        input_list.append(tuple(map(int, input().split())))\n    \n    output_list = list()\n    for i in range(M):\n        pair_list = list()\n        for j in range(i+1):\n            pair_list.append(input_list[i][j])\n            pair_list.append(input_list[j][i])\n        pair_list = sorted(pair_list)\n        output_list.append(pair_list.count(pair_list[0]))\n    return \"\\n\".join(map(str, output_list))"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    res = []\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if i!= j:\n                l = a[i - 1]\n                r = a[j - 1]\n                if l < r:\n                    res.append(2)\n                else:\n                    res.append(1)\n    return str(res)\n\nprint(solution(input()))\n\n----------------------------------------------------------------------------------------\n\nPython program to find the minimum number of moves to align two strings of equal length"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    n, m = 1, 1\n    res = []\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        a -= 1\n        b -= 1\n        n = max(n, a) + max(n, b)\n        res.append(n)\n    return''.join(map(str, res))\n"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    in_list = stdin.split(\"\\n\")\n    n = int(in_list[0])\n    m = int(in_list[1])\n\n    trucks = []\n    for i in range(2, 2 + n):\n        trucks.append(int(in_list[i]))\n\n    n_routes = {}\n    for i in range(n):\n        n_routes[trucks[i]] = []\n\n    for i in range(2 + n, 2 + n + m):\n        n_routes[trucks[0]].append(int(in_list[i]))\n\n    for i in range(1, n):\n        n_routes[trucks[i]].append(trucks[i - 1])\n\n    for i in range(n):\n        n_routes[trucks[i]].sort()\n\n    pairs = {}\n    for i in range(m):\n        pairs[int(in_list[2 + n + i])] = int(in_list[2 + n + i + 1])\n\n    ans = []\n    for i in range(m):\n        ans.append(len([a for a in n_routes[pairs[i]] if a in n_routes[pairs[i + 1]]]))\n\n    return \"\\n\".join([str(x) for x in ans])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return '\\n'.join([str(solution_one(stdin))] +\n                     [str(solution_two(stdin))])"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    ans = -1\n    currSum = 0\n    for i in range(N):\n        currSum += arr[i]\n        if i < K - 1:\n            continue\n        currSum -= arr[i - K + 1]\n        if currSum > ans:\n            ans = currSum / (K - 1)\n    return str(ans)"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    arr.sort()\n\n    avg = sum(arr[i] for i in range(k)) / k\n\n    for i in range(k, n):\n        avg -= arr[i - k]\n        avg += arr[i]\n        if avg / k > avg:\n            break\n    else:\n        return '{:.7f}'.format(avg / k)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n    max_avg = a[0]\n    min_avg = a[0]\n    summ = 0\n    for i in range(1, N):\n        summ += a[i]\n        if i >= K:\n            summ -= a[i - K]\n            summ /= K\n        max_avg = max(max_avg, summ)\n        min_avg = min(min_avg, summ)\n        summ = 0\n    return \"{:.3f}\".format(max_avg)\n"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split()))\n    A = list(map(int, stdin.split()))\n    avg = sum(A[i - K + 1:i + 1] for i in range(K, N)) / K\n    if abs(avg - float(avg)) < 0.001:\n        return str(avg)\n    return str(avg + float(avg) * 0.001)\n"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    avg = sum(a) / len(a)\n    best = -1\n    curr_avg = avg\n    for i in range(n - k + 1):\n        curr_avg = sum(a[i : i + k]) / k\n        if curr_avg > avg:\n            best = curr_avg\n            curr_avg = avg\n    return \"{:.4f}\".format(best)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    # max_sequence_length = float('-inf')\n    # max_sequence = []\n    # total_sum = 0\n    # max_sum = float('-inf')\n    # max_sum_index = 0\n    # for i in range(N):\n    #     if i + K <= N:\n    #         if sum(A[i:i+K]) > max_sum:\n    #             max_sum = sum(A[i:i+K])\n    #             max_sum_index = i\n    #             max_sequence = A[max_sum_index:max_sum_index+K]\n    #     else:\n    #         break\n    # if max_sum == float('-inf'):\n    #     return '0'\n    # else:\n    #     total_sum = sum(max_sequence)\n    #     return f'{total_sum/max_sum:.8f}'\n    max_sequence_length = float('-inf')\n    max_sequence = []\n    total_sum = 0\n    max_sum = float('-inf')\n    max_sum_index = 0\n    for i in range(N):\n        if i + K <= N:\n            if sum(A[i:i+K]) > max_sum:\n                max_sum = sum(A[i:i+K])\n                max_sum_index = i\n                max_sequence = A[max_sum_index:max_sum_index+K]\n        else:\n            break\n    if max_sum == float('-inf'):\n        return '0'\n    else:\n        total_sum = sum(max_sequence)\n        return f'{total_sum/max_sum:.8f}'\n"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    avg = sum(arr[:k]) / k\n    for i in range(1, n - k + 1):\n        if sum(arr[i:i + k]) / k > avg:\n            avg = sum(arr[i:i + k]) / k\n    return str(avg)"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(x) for x in stdin.split())\n    arr = [int(x) for x in stdin.split()]\n    max_avg = sum(arr[:k]) / k\n    best_avg = sum(arr[:k]) / k\n    for i in range(len(arr) - k + 1):\n        avg = sum(arr[i:i + k]) / k\n        if avg > max_avg:\n            max_avg = avg\n            best_avg = avg\n    return str(best_avg)\n    # s = solution(input())\n    # print(s)\n    return max_avg\n"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.strip().split())\n    nums = list(map(int, stdin.strip().split()))\n    \n    avgs = []\n    for i in range(0, N-K+1):\n        avgs.append(sum(nums[i:i+K]) / K)\n    return str(max(avgs))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split()))\n    arr = list(map(int, stdin.split()))\n    pivot = sum(arr[:K])/K\n    def part(low, high):\n        avg = sum(arr[low:high])/K\n        for i in range(low, high):\n            if arr[i] > avg:\n                return part(low, i-1)\n        return avg\n    print(max(part(0, K), part(K, N)))\n    return max(part(0, K), part(K, N))\n    # print(part(0, K), part(K, N))"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = map(int, stdin.split())\n    min_vals = list(map(float, stdin.split()))\n    max_vals = list(map(float, stdin.split()))\n    min_vals.sort()\n    max_vals.sort()\n    min_vals = [min(x, w * h) for x in min_vals]\n    max_vals = [max(x, w * h) for x in max_vals]\n    max_vals.reverse()\n    min_vals.reverse()\n    return '{:.3f}'.format(min(max_vals) - max(min_vals))\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = list(map(int, stdin.strip().split()))\n    sand_volumes = list(map(float, stdin.strip().split()))\n    max_sand = []\n    min_sand = []\n    for i in range(n - 1):\n        min_sand.append(sand_volumes[i])\n        max_sand.append(sand_volumes[i])\n    for i in range(1, n - 1):\n        max_sand[i - 1] = max_sand[i]\n    max_sand[n - 1] = sand_volumes[n - 1]\n    min_sand[0] = sand_volumes[0]\n    min_sand[n - 2] = sand_volumes[n - 2]\n    for i in range(1, n - 1):\n        min_sand[i] = min(min_sand[i - 1], sand_volumes[i])\n    for i in range(n - 1, 0, -1):\n        max_sand[i - 1] = max(max_sand[i], sand_volumes[i])\n    min_sand = list(map(lambda x: x + h, min_sand))\n    max_sand = list(map(lambda x: x + h, max_sand))\n    sand_colors = list(zip(min_sand, max_sand))\n    sand_colors.sort(key=lambda x: x[1] - x[0], reverse=True)\n    solutions = []\n    for i in range(1, m + 1):\n        max_sand_val = sand_colors[i - 1][1]\n        min_sand_val = sand_colors[i - 1][0]\n        max_sand_val = sand_colors[i - 1][1]\n        min_sand_val = sand_colors[i - 1][0]\n        min_sand_val = sand_colors[i - 1][0]\n        if min_sand_val < 0:\n            continue\n        min_val = min(min_sand_val, max_sand_val)\n        max_val = max(min_sand_val, max_sand_val)\n        diff = max_val - min_val\n        solutions.append(diff)\n    return str(min(solutions))\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    input = stdin\n    n, m, w, h = list(map(int, input.split()))\n\n    sand = list(map(float, input.split()))\n\n    divs = []\n    for _ in range(n - 1):\n        divs.append(list(map(float, input.split())))\n\n    divs.sort(key=lambda x: x[0])\n\n    def max_sand(sand, divs):\n        return max(sand)\n\n    def min_sand(sand, divs):\n        return min(sand)\n\n    def sand_heights(sand, divs):\n        return len(sand)\n\n    def sort_sand(sand, divs):\n        return min_sand(sand, divs)\n\n    def num_sand_colors(sand, divs):\n        num = 0\n        sand = sand.copy()\n        for num, sand_color in enumerate(sand):\n            sand_color = sand_color\n            for color, max_color in divs:\n                if color <= sand_color <= max_color:\n                    break\n            else:\n                return num\n        return num\n\n    def color_sand_vol(sand, divs):\n        vol = 0\n        sand = sand.copy()\n        for divs_i in divs:\n            sand_vol = sand_vol_i = 0\n            for sand_i, divs_i_j in zip(sand, divs_i):\n                sand_vol_i += sand_i\n                if sand_vol_i >= divs_i_j:\n                    break\n            else:\n                return sand_vol\n        return 0\n\n    def sand_height(sand, divs):\n        sand = sand.copy()\n        sand_heights = sand_heights(sand, divs)\n        for divs_i in divs:\n            sand_height_i = sand_height_i_j = 0\n            for sand_i, divs_i_j in zip(sand, divs_i):\n                sand_height_i_j += sand_i\n                if sand_height_i_j >= divs_i_j:\n                    break\n            else:\n                return sand_height_i\n        return sand_heights\n\n    sand_max = max_sand(sand, divs)\n    sand_min = min_sand(sand, divs)\n    sand_height = sand_height(sand, divs)\n    sand_vol = color_sand_vol(sand, divs)\n\n    diff = sand_max - sand_min\n    if diff == 0:\n        return str(diff)\n    else:\n        return str(round(diff, 3))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = map(int, stdin.split())\n    arr = [[0] * w for _ in range(h)]\n    mins = list(map(float, stdin.split()[1:]))\n    maxs = list(map(float, stdin.split()[1:]))\n    for i in range(n - 1):\n        for j in range(m):\n            arr[i][i * 2 + j] = min(arr[i][i * 2 + j - 1] + maxs[j], arr[i][i * 2 + j - 1] + mins[j])\n            arr[i][i * 2 + j + 1] = min(arr[i][i * 2 + j + 1] + maxs[j], arr[i][i * 2 + j + 1] + mins[j])\n    ans = float('inf')\n    for i in range(1, h - 1):\n        ans = min(ans, arr[0][i] - arr[0][i - 1], arr[n - 1][i] - arr[n - 1][i - 1])\n    return '{:.3f}'.format(ans)"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h, *_ = list(map(int, stdin.split()))\n    sand_volume = list(map(float, stdin.split()[2:]))\n    sections = [[] for i in range(n)]\n    section_sand_levels = [[] for i in range(n)]\n    highest_level = 0\n    minimum_level = float('inf')\n    for i, sand in enumerate(sand_volume):\n        sections[0].append(i + 1)\n        section_sand_levels[0].append(sand)\n        if i == 0:\n            highest_level = sand\n            minimum_level = sand\n        else:\n            highest_level = max(highest_level, sand)\n            minimum_level = min(minimum_level, sand)\n    for i in range(1, n):\n        sections[i].append(sections[i - 1][-1] + w)\n        section_sand_levels[i].append(section_sand_levels[i - 1][-1] + section_sand_levels[i - 1][-1])\n    total_vol = 0\n    for i in range(n - 1):\n        start = sections[i][0]\n        end = sections[i][1]\n        minimum = section_sand_levels[i][0]\n        maximum = section_sand_levels[i][-1]\n        for j in range(i, n - 1):\n            start = min(start, sections[j][0])\n            end = max(end, sections[j][1])\n            if minimum == maximum:\n                break\n            for k in range(i, j):\n                minimum = min(minimum, section_sand_levels[k][0])\n                maximum = max(maximum, section_sand_levels[k][-1])\n            if minimum == maximum:\n                break\n        total_vol += end - start\n    total_vol -= (w * h)\n    return str(total_vol - minimum_level)\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n,m,w,h=map(int,stdin.split())\n    sand=map(float,stdin.split())\n    minMax=map(int,stdin.split())\n    maxMin=map(int,stdin.split())\n    minMax=list(map(float,minMax))\n    maxMin=list(map(float,maxMin))\n    maxS=0.0\n    minS=0.0\n    for i in range(n):\n        minS+=minMax[i]\n        maxS+=maxMin[i]\n    maxS=maxS*h\n    minS=minS*h\n    maxMax=maxS\n    minMin=minS\n    for i in range(n):\n        maxMax=max(maxMax,maxMin[i]*h+maxMin[i]*h)\n        minMin=min(minMin,maxMin[i]*h+minMax[i]*h)\n    maxS=maxS-maxMax\n    minS=minS-minMin\n    return str(round(maxS-minS,3))"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = [int(x) for x in stdin.split()]\n    v = [float(x) for x in stdin.split()[1:]]\n    l = sorted(stdin.split()[2:], key=float)\n    return str(min([abs(h - max(y[0] for y in zip(l, v))), abs(h - min(y[0] for y in zip(l, v)))]) / h)\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = map(int, stdin.strip().split())\n    v = list(map(float, stdin.strip().split()))\n    x = list(map(int, stdin.strip().split()))\n    min_ = list(map(float, stdin.strip().split()))\n    max_ = list(map(float, stdin.strip().split()))\n\n    sand = sorted([[v[i], x[i]] for i in range(m)], key=lambda x: x[0])\n    res = 0\n    for i in range(n-1):\n        sand_max = sand[-1]\n        sand_min = sand[0]\n        res += sand_max[0] - sand_min[0]\n        sand.pop(-1)\n\n    print(res)\n    return \"\""
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = map(int, stdin.split())\n    sand = [float(x) for x in stdin.split()[1:]]\n    mx = max(sand)\n    mn = min(sand)\n    def d(x): return max(x, mn) - min(x, mx)\n    dv = d(sand)\n    if dv > w*h:\n        return 0\n    r = dv / (w*h)\n    return \"{:.3f}\".format(r)\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = list(map(int, stdin.split()))\n    sand = list(map(float, stdin.split()))\n    lines = []\n    for i in range(n):\n        lines.append([])\n        for j in range(m):\n            lines[i].append(sand[i * m + j])\n    s1 = []\n    s2 = []\n    s3 = []\n    for i in range(n):\n        s1.append(0)\n        s2.append(0)\n        s3.append(0)\n    for i in range(n):\n        s1[i] = max(0, min(sand[i * m:i * m + m], key=lambda x: x - lines[i][0]) - lines[i][0])\n        s2[i] = max(0, min(sand[i * m:i * m + m], key=lambda x: x - lines[i][-1]) - lines[i][-1])\n        s3[i] = max(0, min(sand[i * m:i * m + m], key=lambda x: x - lines[n - 1][i]) - lines[n - 1][i])\n    return str(min(max(s1) - min(s2), max(s2) - min(s3)))"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def to_grid(text: str) -> list:\n        rows = stdin.split()\n        size = len(rows[0])\n        for row in rows:\n            if len(row)!= size:\n                raise ValueError(f\"row {row} has not {size} integers\")\n\n        return rows\n    \n    def to_matrix(rows: list) -> list:\n        matrix = []\n        for i in range(len(rows)):\n            row = rows[i]\n            matrix.append(list(map(int, row.split())))\n            for j in range(len(row)):\n                if row[j] == 0:\n                    row[j] = '0'\n        return matrix\n    \n    def get_code(i: int, j: int) -> list:\n        matrix = to_matrix(rows)\n        code = matrix[i]\n        n = len(code)\n        if i > 0:\n            code[0] = str(int(code[0]) * int(matrix[i-1][j]))\n        if i < n-1:\n            code[n-1] = str(int(code[n-1]) * int(matrix[i+1][j]))\n        if j > 0:\n            code[0] = str(int(code[0]) * int(matrix[i][j-1]))\n        if j < n-1:\n            code[n-1] = str(int(code[n-1]) * int(matrix[i][j+1]))\n        return code\n    \n    def can_be_processed(code: list, visited: list, row: int, col: int) -> bool:\n        code_length = len(code)\n        if row in visited:\n            return False\n        if code[row] == '0':\n            return True\n        \n        visited.append(row)\n        if row == 0 or row == code_length-1 or col == 0 or col == code_length-1:\n            return False\n        if code[row] == '0':\n            return True\n\n        if int(code[row]) * int(code[row+1]) == int(code[row+1]) * int(code[row]):\n            return can_be_processed(code, visited, row+1, col) or can_be_processed(code, visited, row, col+1)\n        if int(code[row]) * int(code[row+1]) == int(code[row+1]) * int(code[row]):\n            return can_be_processed(code, visited, row, col+1) or can_be_processed(code, visited, row+1, col)\n        if int(code[row+1]) * int(code[row]) == int(code[row]) * int(code[row+1]):\n            return can_be_processed(code, visited, row+1, col) or can_be_processed(code, visited, row, col-1)\n        if int(code[row+1]) * int(code[row]) == int(code[row]) * int(code[row+1]):\n            return can_be_processed(code, visited, row, col-1) or can_be_processed(code, visited, row+1, col)\n        return False\n    \n    def get_size_from_matrix(matrix):\n        size = len(matrix)\n        return size * size\n    \n    def get_valid_code_number(matrix, rows: int, cols: int) -> int:\n        code_number = 0\n        for i in range(rows):\n            for j in range(cols):\n                if can_be_processed(get_code(i, j), [], i, j) == True:\n                    code_number += 1\n        return code_number\n    \n    rows = to_grid(stdin)\n    matrix = to_matrix(rows)\n    size = get_size_from_matrix(matrix)\n    code_number = get_valid_code_number(matrix, rows[0], rows[1])\n    print(code_number)"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    s = str(m * n)\n    total = 0\n    while len(s) > 2:\n        for x in range(len(s)):\n            if x == 0:\n                total += sum(int(y) for y in s[1:])\n            elif x == len(s) - 1:\n                total += sum(int(y) for y in s[:-1])\n            else:\n                total += sum(int(y) for y in s[x - 1:x + 2])\n        s = str(total)\n        total = 0\n    return total\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.strip().split())\n    if m == n == 0:\n        return '0'\n    cells = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            cells[i][j] = int(stdin.strip()) if stdin.strip() else 0\n    #print(cells)\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    res = set()\n    def bfs(i, j, d):\n        queue = deque([(i, j)])\n        while queue:\n            x, y = queue.popleft()\n            if x == m - 1 and y == n - 1:\n                return d\n            for k in range(4):\n                x2, y2 = x + dx[k], y + dy[k]\n                if 0 <= x2 < m and 0 <= y2 < n:\n                    if cells[x2][y2] == 0:\n                        cells[x2][y2] = d\n                        queue.append((x2, y2))\n                    else:\n                        if (d == 0 and x2 == 0 and y2 == n - 1) or (d == 1 and x2 == m - 1 and y2 == 0):\n                            cells[x2][y2] = 1\n                        elif (d == 0 and x2 == 0 and y2 == n - 1) or (d == 1 and x2 == m - 1 and y2 == 0):\n                            cells[x2][y2] = 2\n                        elif (d == 0 and x2 == m - 1 and y2 == 0) or (d == 1 and x2 == 0 and y2 == m - 1):\n                            cells[x2][y2] = 3\n                        elif (d == 0 and x2 == m - 1 and y2 == 0) or (d == 1 and x2 == 0 and y2 == m - 1):\n                            cells[x2][y2] = 4\n    for i in range(m):\n        for j in range(n):\n            if cells[i][j] == 0:\n                if bfs(i, j, 0):\n                    res.add(str(d))\n    return '\\n'.join(res)\nprint(solution(stdin))\n"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    m, n = list(map(int, stdin.split()))\n    s = 0\n    for _ in range(m):\n        l = stdin.split()\n        for i in range(n):\n            if len(l[i]) > 1:\n                for j in range(len(l[i]) - 1):\n                    if l[i][j]!= 0 or l[i][j] == l[i][j + 1]:\n                        pass\n                    else:\n                        l[i] = l[i][:j] + str(int(l[i][j]) * int(l[i][j + 1])) + l[i][j + 2:]\n        s += len(l)\n    return str(s)"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    n_ones = sum(1 for i in range(m) if stdin[i] == \"1\")\n    if n_ones == 0 or n_ones >= (m*n) / 2:\n        return \"0\"\n    codes = []\n    for row in stdin.split():\n        codes.append(int(row))\n    return \"37\"\n"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return '%s' % solve(list(map(int, stdin.split())))\n\ndef"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    codes = []\n    for i in range(m):\n        codes.append([int(x) for x in stdin.split()[i*n:(i+1)*n]])\n    print(solve(codes, m, n))\n\n\ndef"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    codes = []\n    for _ in range(m):\n        codes.append([int(x) for x in stdin.split()[_]])\n    \n    possible = []\n    for i in range(m):\n        for j in range(n):\n            if not codes[i][j] == 0:\n                if codes[i][j] == 1:\n                    if i!= 0 and j!= 0 and codes[i-1][j-1] == 1:\n                        codes[i][j] *= codes[i-1][j-1]\n                    if i!= 0 and codes[i-1][j] == 1:\n                        codes[i][j] *= codes[i-1][j]\n                    if i!= 0 and codes[i-1][j+1] == 1:\n                        codes[i][j] *= codes[i-1][j+1]\n                    if j!= 0 and codes[i][j-1] == 1:\n                        codes[i][j] *= codes[i][j-1]\n                    if j!= 0 and codes[i][j+1] == 1:\n                        codes[i][j] *= codes[i][j+1]\n                if codes[i][j] == 2:\n                    if i!= 0 and j!= 0 and codes[i-1][j-1] == 2:\n                        codes[i][j] += codes[i-1][j-1]\n                    if i!= 0 and codes[i-1][j] == 2:\n                        codes[i][j] += codes[i-1][j]\n                    if i!= 0 and codes[i-1][j+1] == 2:\n                        codes[i][j] += codes[i-1][j+1]\n                    if j!= 0 and codes[i][j-1] == 2:\n                        codes[i][j] += codes[i][j-1]\n                    if j!= 0 and codes[i][j+1] == 2:\n                        codes[i][j] += codes[i][j+1]\n                if codes[i][j] == 3:\n                    if i!= 0 and j!= 0 and codes[i-1][j-1] == 3:\n                        codes[i][j] -= codes[i-1][j-1]\n                    if i!= 0 and codes[i-1][j] == 3:\n                        codes[i][j] -= codes[i-1][j]\n                    if i!= 0 and codes[i-1][j+1] == 3:\n                        codes[i][j] -= codes[i-1][j+1]\n                    if j!= 0 and codes[i][j-1] == 3:\n                        codes[i][j] -= codes[i][j-1]\n                    if j!= 0 and codes[i][j+1] == 3:\n                        codes[i][j] -= codes[i][j+1]\n    \n    for i in range(m):\n        for j in range(n):\n            if codes[i][j] == 0:\n                if i!= 0 and j!= 0 and codes[i-1][j-1] == 1:\n                    codes[i][j] *= codes[i-1][j-1]\n                if i!= 0 and codes[i-1][j] == 1:\n                    codes[i][j] *= codes[i-1][j]\n                if i!= 0 and codes[i-1][j+1] == 1:\n                    codes[i][j] *= codes[i-1][j+1]\n                if j!= 0 and codes[i][j-1] == 1:\n                    codes[i][j] *= codes[i][j-1]\n                if j!= 0 and codes[i][j+1] == 1:\n                    codes[i][j] *= codes[i][j+1]\n                if i!= 0 and j!= 0 and codes[i-1][j-1] == 2:\n                    codes[i][j] += codes[i-1][j-1]\n                if i!= 0 and codes[i-1][j] == 2:\n                    codes[i][j] += codes[i-1][j]\n                if i!= 0 and codes[i-1][j+1] == 2:\n                    codes[i][j] += codes[i-1][j+1]\n                if j!= 0 and codes[i][j-1] == 2:\n                    codes[i][j] += codes[i][j-1]\n                if j!= 0 and codes[i][j+1] == 2:\n                    codes[i][j] += codes[i][j+1]\n                if i!= 0 and j!= 0 and codes[i-1][j-1] == 3:\n                    codes[i][j] -= codes[i-1][j-1]\n                if i!= 0 and codes[i-1][j] == 3:\n                    codes[i][j] -= codes[i-1][j]\n                if i!= 0 and codes[i-1][j+1] == 3:\n                    codes[i][j] -= codes[i-1][j+1]\n                if j!= 0 and codes[i][j-1] == 3:\n                    codes[i][j] -= codes[i][j-1]\n                if j!= 0 and codes[i][j+1] == 3:\n                    codes[i][j] -= codes[i][j+1]\n    \n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if codes[i][j]!= 0:\n                count += 1\n    \n    return count"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = list(map(lambda line: list(map(int, line.split(\" \"))), stdin.splitlines()))\n    m = lines[0][0]\n    n = lines[0][1]\n\n    def _gen_code(m, n, d):\n        code = []\n        for i in range(m):\n            row = list(map(int, str(d)))\n            if any(map(lambda x: x, row)):\n                return None\n            code.append(row)\n        return code\n\n    def _check_code(code):\n        for r, row in enumerate(code[:-1]):\n            for c, val in enumerate(row):\n                if c == 0:\n                    continue\n                for i in range(r + 1, len(code)):\n                    if code[i][c]!= 0:\n                        break\n                else:\n                    return False\n        return True\n\n    d = {}\n    for i in range(1, n + 1):\n        d[i] = {}\n        for j in range(1, m + 1):\n            d[i][j] = _gen_code(m, n, i * j)\n\n    codes = []\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if d[j][i]:\n                codes.append(_gen_code(m, n, j * i))\n\n    solutions = set()\n    for code in codes:\n        if _check_code(code):\n            solutions.add(str(code))\n\n    return len(solutions)\n"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Runs the solution function as a pytest fixture\n    \"\"\"\n    import sys\n    import pytest\n\n    sys.stdin = open(__file__.replace(os.path.basename(__file__), 'input.txt'))\n    sol = answer(stdin)\n    sys.stdin = open(__file__.replace(os.path.basename(__file__), 'test.txt'))\n    return str(sol)\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    dials = list(map(int, stdin.split()))\n    book = dict()\n    max_digit = max(dials)\n    for i in range(max_digit + 1):\n        book[i] = 0\n    for dial in dials:\n        book[dial] += 1\n    print(book)\n    for i in range(N - 1):\n        print('Enter digit')\n        digit = int(input())\n        print('Enter range')\n        range_a, range_b = list(map(int, input().split()))\n        print(range_a, range_b)\n        print(book)\n        book[range_a] -= 1\n        book[range_b] += 1\n        print(book)\n        print('Enter the number of changes')\n        changes = int(input())\n        for j in range(changes):\n            a, b = list(map(int, input().split()))\n            print(a, b)\n            print(range_a, range_b)\n            print(book)\n            book[a] += 1\n            book[b] -= 1\n            print(book)\n    print(book)\n    return''.join(map(str, sorted(book.values())))\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    numbers = stdin.split()\n    start_numbers = []\n    for i in range(len(numbers)):\n        start_numbers.append(int(numbers[i]))\n    assert len(start_numbers) == n\n    if n == 1:\n        return str(n)\n\n    numbers = []\n    for i in range(n):\n        numbers.append(n)\n\n    matrix = []\n    for _ in range(n):\n        matrix.append([])\n        for _ in range(n):\n            matrix[_].append(0)\n\n    for i in range(n):\n        matrix[0][i] = start_numbers[i]\n\n    for i in range(1, n):\n        for j in range(n):\n            if j == 0:\n                matrix[i][j] = matrix[i - 1][j] + numbers[i]\n            elif j == n - 1:\n                matrix[i][j] = matrix[i - 1][j - 1] + numbers[i]\n            else:\n                matrix[i][j] = max(matrix[i - 1][j - 1], matrix[i - 1][j]) + numbers[i]\n\n    answer = []\n    for i in range(n):\n        if matrix[n - 1][i] > 0:\n            answer.append(matrix[n - 1][i])\n    answer.sort()\n    return''.join(map(str, answer))"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    stdin = list(map(int, stdin.split()))\n    dials = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, stdin.pop(0).split())\n        dials[a - 1].append(b)\n        dials[b - 1].append(a)\n    result = 0\n    while len(dials[0]) > 1:\n        result += sum(sorted(dials[0])[1:])\n        for dial in dials:\n            for digit in dial:\n                if digit == max(dial):\n                    index = dial.index(digit)\n                    digit = dial[0]\n                    del dial[index]\n                    break\n        dials[0].remove(digit)\n    return str(result)\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    arr = [int(x) for x in stdin.split()]\n    sheet1 = arr[:n]\n    sheet2 = arr[n:]\n    print(*sheet1)\n    print(*sheet2)\n    print()\n    for _ in range(m):\n        temp_sum = 0\n        arr = sheet1.copy()\n        for i in range(n):\n            temp_sum += arr[i]\n            if i < n - 1:\n                arr[i] = sheet2[i]\n            else:\n                arr[i] = sheet2[0]\n        print(*arr)\n    return \"\"\n\nprint(solution(input()))\n\"\"\"\ndef"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin.split('\\n')\n    n = int(n)\n    m = int(m)\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = []\n    c = []\n    for i in range(n):\n        b.append(i + 1)\n    for i in range(n):\n        c.append(i + 1)\n    for i in range(m):\n        a[0] = max(0, a[0] - 1)\n        a[1] = max(0, a[1] - 1)\n        b[0] = max(0, b[0] - 1)\n        b[1] = max(0, b[1] - 1)\n        c[0] = max(0, c[0] - 1)\n        c[1] = max(0, c[1] - 1)\n        b[0] = max(b[0], c[0])\n        b[1] = max(b[1], c[1])\n    return '\\n'.join(map(str, b))\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin_n, stdin_m, stdin_dial_config, stdin_dials = stdin.split(\"\\n\")\n    stdin_n, stdin_m, stdin_dial_config, stdin_dials = int(stdin_n), int(stdin_m), stdin_dial_config.strip(), stdin_dials.strip().split()\n    stdin_dials = list(map(int, stdin_dials))\n    stdin_dials = tuple(stdin_dials)\n    print(stdin_dials)\n    # TODO: write your code here\n\n    return stdout"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    (n, m) = stdin.split()\n    n = int(n)\n    m = int(m)\n    dials = [int(x) for x in stdin.split()]\n    allnums = range(1, n + 1)\n    sums = []\n    for i in range(0, m):\n        a = dials[i * 2]\n        b = dials[i * 2 + 1]\n        d = a + b\n        s = d in allnums\n        sums.append(s)\n    return \"\\n\".join(sums)\n\n\nprint(solution(input()))\n\n\"\"\"\n\n\"\"\"\nCreate two arrays, one of length n with 1s and 0s, and the other of length m.\nMake the initial sum = 1.\nfor i = 2,..., n, do\n    Select a pair of indices p and q with 0 < p < q < n.\n    Sum all the values in the arrays.\n    Increment the sum by 1.\nfor i = m,..., 2, do\n    Select a pair of indices p and q with 0 < p < q < n.\n    Sum all the values in the arrays.\n    Decrement the sum by 1.\nreturn the final sum.\n\"\"\"\n\ndef"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split()\n    n, m = int(stdin_list[0]), int(stdin_list[1])\n    configuration = list(map(int, stdin_list[2].split()))\n    starting_configuration = configuration.copy()\n    sum = 0\n    for _ in range(m):\n        configuration = [configuration[i] + 1 for i in range(n)]\n        # print(configuration)\n        for i in range(n - 1):\n            if configuration[i] + configuration[i + 1] > 9:\n                configuration[i] = 1\n            else:\n                configuration[i] += 1\n        sum += sum(configuration)\n        # print(configuration)\n    return str(sum)\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        A -= 1\n        B -= 1\n        print(sum(range(A, B + 1)))\n    return \"\"\n\nsolution(input())\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    n, k, m = map(int, stdin.split())\n    arr = []\n    for i in range(m):\n        arr.append(tuple(map(int, stdin.split())))\n\n    ans = 0\n\n    for i in range(len(arr)):\n        if not (arr[i][0] == arr[i][1] or arr[i][0] == arr[i][1] + 1):\n            ans = -1\n            break\n    print(ans)\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    if K > N:\n        return '0'\n    edges = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        edges[a].append(b)\n        edges[b].append(a)\n    count = 0\n    for k in range(1, N + 1):\n        if edges[k]:\n            if K < K and K > 1:\n                count += 1\n            else:\n                count = max(count, K)\n    return str(count)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    N, K, M = map(int, stdin.split())\n    edges = collections.defaultdict(list)\n    for _ in range(M):\n        u, v = map(int, stdin.split())\n        edges[u].append(v)\n        edges[v].append(u)\n    \n    def solve(edges, N, K):\n        if len(edges) == N:\n            return len(edges) - 1\n        \n        nodes = sorted(edges.keys())\n        for u in nodes:\n            if len(edges[u]) > 1:\n                edges[u] = sorted(edges[u])\n                for v in edges[u]:\n                    if v!= u:\n                        edges[v].remove(u)\n                return max(solve(edges, N, K), len(edges) - 1)\n        \n        return len(edges) - 1\n\n    return str(solve(edges, N, K))"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    graph = defaultdict(list)\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n    # print(graph)\n    producers = []\n    for _ in range(K):\n        producers.append(set())\n    routes = set()\n    for k, v in graph.items():\n        producers[v[0]-1].add(v[1])\n    # print(producers)\n    def run_producers(producers, routes):\n        for idx in range(len(producers)):\n            # print(idx, producers[idx])\n            if len(producers[idx]) == 1:\n                return False\n        if len(routes) > 0:\n            if routes.intersection(producers[0]) == routes:\n                return False\n        for idx in range(len(producers)):\n            if idx!= len(producers)-1:\n                producers[idx].update(producers[idx+1])\n            else:\n                producers[idx].update(producers[0])\n            if idx!= 0:\n                producers[idx].remove(producers[idx-1])\n        # print(producers)\n        return True\n    for i in range(N):\n        if run_producers(producers, set()):\n            routes.add(i)\n    return str(len(routes))\n\nprint(solution(\"\"\"4 2 3\n1 3\n2 3\n3 4\n\"\"\".strip()))\nprint(solution(\"\"\"5 2 4\n1 3\n3 4\n2 4\n4 5\n\"\"\".strip()))\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N, K, M = int(lines[0]), int(lines[1]), int(lines[2])\n    junctions = {j: set() for j in range(1, N + 1)}\n    for i in range(K + 1):\n        junctions[i] = set()\n    for i in range(M):\n        x, y = list(map(int, lines[3 + 2 * i].split()))\n        junctions[x].add(y)\n        junctions[y].add(x)\n    all_producers = {i for i in range(1, K + 1)}\n    already_running = set()\n    running = all_producers\n    while len(running) > 1:\n        next_to_run = set()\n        for p in running:\n            for j in junctions[p]:\n                if j in already_running:\n                    continue\n                if len(junctions[j]) > 1:\n                    for q in junctions[j]:\n                        if q in already_running:\n                            continue\n                        if len(junctions[q]) > 1:\n                            next_to_run.add(p)\n                            break\n        running = next_to_run\n    return len(running)\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_junctions, num_producers, num_belt_edges = map(int, stdin.split())\n    junctions = []\n    belt_connections = []\n    max_producers = 0\n    for _ in range(num_producers):\n        junction, belt_connection = map(int, stdin.split())\n        junctions.append(junction)\n        belt_connections.append(belt_connection)\n        max_producers = max(max_producers, junction)\n    num_conveyor_belt_connections = num_producers + num_belt_edges - num_producers - 1\n    print(num_conveyor_belt_connections)\n    return ''\n\nsolution(input())\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    conveyor = {}\n    producers = {}\n    for i in range(n):\n        conveyor[i + 1] = []\n    for i in range(m):\n        conveyor[int(stdin.split()[2 * i + 1])].append(int(stdin.split()[2 * i]))\n    for i in conveyor:\n        producers[i] = set()\n    for j in conveyor:\n        producers[j].add(i)\n    remaining = set(producers.keys())\n    remaining.remove(1)\n    while len(remaining) > 1:\n        max_prod = max([len(producers[x]) for x in remaining])\n        remaining_to_go = set()\n        for x in remaining:\n            if len(producers[x]) == max_prod:\n                remaining_to_go.add(x)\n        remaining = remaining_to_go\n    return str(max(len(remaining) - 1, 1))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    mapping = {0: 1}\n    visited = set()\n    q = [(1, 1)]\n    while len(q) > 0:\n        current_node, current_route = q.pop()\n        visited.add(current_node)\n        for i in range(2, N + 1):\n            if i not in visited:\n                if current_route + 1 <= K and mapping.get(current_node) is not None:\n                    mapping[i] = mapping.get(current_node) + 1\n                    q.append((i, current_route + 1))\n                if mapping.get(current_node) is None:\n                    mapping[i] = 1\n                    q.append((i, 1))\n        if current_route + M == N:\n            return current_node\n    return 'ERROR'\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    \n    edge = set()\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        edge.add((a, b))\n        edge.add((b, a))\n    \n    L = int(math.ceil(math.log2(len(edge))))\n    \n    routing = [None]*(N + 1)\n    routing[1] = [i for i in range(1, K + 1)]\n    routing[2] = list(range(1, K + 1))\n    \n    for _ in range(L):\n        new_routing = [-1]*(N + 1)\n        for i in range(1, N + 1):\n            if not routing[i]:\n                continue\n            for j in routing[i]:\n                if j in routing[i]:\n                    continue\n                if i + 1 <= N and (j, i + 1) in edge:\n                    if not new_routing[i + 1] or new_routing[i + 1] > routing[i][j] + 1:\n                        new_routing[i + 1] = routing[i][j] + 1\n        routing = new_routing\n    \n    prod = 0\n    producers = set()\n    for i in range(1, N + 1):\n        if routing[i] == 0:\n            continue\n        prod += routing[i]\n        for j in range(1, K + 1):\n            if j not in producers:\n                producers.add(j)\n    \n    producers = list(producers)\n    producers.sort()\n    return str(producers[0])\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    edges = [[] for i in range(n)]\n    for _ in range(m):\n        x, y = map(int, input().split())\n        edges[x - 1].append(y - 1)\n        edges[y - 1].append(x - 1)\n    res = max_prod(n, k, edges)\n    return str(res)\n\n\ndef"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cloud_1, cloud_2 = set(), set()\n    for _ in range(n):\n        x1, y1, x2, y2, x3, y3 = map(int, stdin.split())\n        cloud_1.add((x1, y1))\n        cloud_1.add((x2, y2))\n        cloud_1.add((x3, y3))\n    for _ in range(m):\n        x1, y1, x2, y2, x3, y3 = map(int, stdin.split())\n        cloud_2.add((x1, y1))\n        cloud_2.add((x2, y2))\n        cloud_2.add((x3, y3))\n    return 'yes' if not cloud_1.intersection(cloud_2) else 'no'\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    Garry = set()\n    Jerry = set()\n    for i in range(n):\n        Garry.add((int(stdin.strip().split()[i * 6]), int(stdin.strip().split()[i * 6 + 1]),\n                   int(stdin.strip().split()[i * 6 + 2]), int(stdin.strip().split()[i * 6 + 3]),\n                   int(stdin.strip().split()[i * 6 + 4]), int(stdin.strip().split()[i * 6 + 5])))\n    for i in range(n):\n        Jerry.add((int(stdin.strip().split()[i * 6]), int(stdin.strip().split()[i * 6 + 1]),\n                   int(stdin.strip().split()[i * 6 + 2]), int(stdin.strip().split()[i * 6 + 3]),\n                   int(stdin.strip().split()[i * 6 + 4]), int(stdin.strip().split()[i * 6 + 5])))\n    return 'yes' if len(Garry.intersection(Jerry)) == 0 else 'no'\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    Garry_cloud = set()\n    Jerry_cloud = set()\n    for _ in range(n):\n        line = stdin.splitlines()\n        Garry_cloud.add((int(line[0]), int(line[1]), int(line[2]), int(line[3]), int(line[4]), int(line[5])))\n        line = stdin.splitlines()\n        Jerry_cloud.add((int(line[0]), int(line[1]), int(line[2]), int(line[3]), int(line[4]), int(line[5])))\n    \n    return \"yes\" if Garry_cloud == Jerry_cloud else \"no\""
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    Garry_triangles = set()\n    Jerry_triangles = set()\n    for _ in range(n):\n        a, b, c, d, e, f = list(map(int, stdin.split()))\n        Garry_triangles.add((a,b,c))\n        Garry_triangles.add((d,e,f))\n    for _ in range(m):\n        a, b, c, d, e, f = list(map(int, stdin.split()))\n        Jerry_triangles.add((a,b,c))\n        Jerry_triangles.add((d,e,f))\n    if len(Garry_triangles.intersection(Jerry_triangles)) > 0 or len(Garry_triangles.difference(Jerry_triangles)) > 0 or len(Jerry_triangles.difference(Garry_triangles)) > 0:\n        return 'no'\n    return 'yes'\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.split()[0])\n    stdin = stdin.split('\\n')[1:]\n    m: int = int(stdin.pop(0))\n    stdin = [list(map(int, stdin[i].split())) for i in range(m)]\n\n    Garry: List[List[int]] = []\n    Jerry: List[List[int]] = []\n    for i in stdin:\n        Garry.append(i[:4])\n        Jerry.append(i[4:])\n\n    Garry = sorted(Garry, key=lambda x: x[0])\n    Jerry = sorted(Jerry, key=lambda x: x[0])\n\n    x, y = 0, 0\n    Garry_idx = 0\n    Jerry_idx = 0\n    while x < n or y < n:\n        if x >= n or y >= n:\n            break\n\n        Garry_len = len(Garry)\n        if x >= Garry_len:\n            Garry_idx = 0\n            continue\n\n        Garry_len = len(Garry)\n        if x >= Garry_len:\n            Garry_idx = 0\n            continue\n\n        Garry_idx = 0\n        while Garry_idx < Garry_len and (Garry[Garry_idx][0] <= x and x <= Garry[Garry_idx][2] or x <= Garry[Garry_idx][0] and x >= Garry[Garry_idx][2]):\n            Garry_idx += 1\n\n        if x >= n or Garry[Garry_idx - 1][2] >= n:\n            break\n\n        if Garry[Garry_idx - 1][0] <= y and y <= Garry[Garry_idx - 1][3] or y <= Garry[Garry_idx - 1][0] and y >= Garry[Garry_idx - 1][3]:\n            Garry_idx = 0\n            continue\n\n        Garry_idx = 0\n        while Garry_idx < Garry_len and (Garry[Garry_idx][0] <= y and y <= Garry[Garry_idx][2] or y <= Garry[Garry_idx][0] and y >= Garry[Garry_idx][2]):\n            Garry_idx += 1\n\n        if y >= n or Garry[Garry_idx - 1][2] >= n:\n            break\n\n        if Garry[Garry_idx - 1][1] <= x and x <= Garry[Garry_idx - 1][4] or x <= Garry[Garry_idx - 1][1] and x >= Garry[Garry_idx - 1][4]:\n            Garry_idx = 0\n            continue\n\n        Garry_idx = 0\n        while Garry_idx < Garry_len and (Garry[Garry_idx][1] <= x and x <= Garry[Garry_idx][4] or x <= Garry[Garry_idx][1] and x >= Garry[Garry_idx][4]):\n            Garry_idx += 1\n\n        if x >= n or Garry[Garry_idx - 1][4] >= n:\n            break\n\n        if Garry[Garry_idx - 1][0] <= y and y <= Garry[Garry_idx - 1][3] or y <= Garry[Garry_idx - 1][0] and y >= Garry[Garry_idx - 1][3]:\n            Garry_idx = 0\n            continue\n\n        Garry_idx = 0\n        while Garry_idx < Garry_len and (Garry[Garry_idx][0] <= y and y <= Garry[Garry_idx][3] or y <= Garry[Garry_idx][0] and y >= Garry[Garry_idx][3]):\n            Garry_idx += 1\n\n        if y >= n or Garry[Garry_idx - 1][3] >= n:\n            break\n\n        if Garry[Garry_idx - 1][1] <= x and x <= Garry[Garry_idx - 1][4] or x <= Garry[Garry_idx - 1][1] and x >= Garry[Garry_idx - 1][4]:\n            Garry_idx = 0\n            continue\n\n        Garry_idx = 0\n        while Garry_idx < Garry_len and (Garry[Garry_idx][1] <= x and x <= Garry[Garry_idx][4] or x <= Garry[Garry_idx][1] and x >= Garry[Garry_idx][4]):\n            Garry_idx += 1\n\n        if x >= n or Garry[Garry_idx - 1][4] >= n:\n            break\n\n        if Garry[Garry_idx - 1][0] <= y and y <= Garry[Garry_idx - 1][3] or y <= Garry[Garry_idx - 1][0] and y >= Garry[Garry_idx - 1][3]:\n            Garry_idx = 0\n            continue\n\n        Garry_idx = 0\n        while Garry_idx < Garry_len and (Garry[Garry_idx][0] <= y and y <= Garry[Garry_idx][3] or y <= Garry[Garry_idx][0] and y >= Garry[Garry_idx][3]):\n            Garry_idx += 1\n\n        if y >= n or Garry[Garry_idx - 1][3] >= n:\n            break\n\n        if Garry[Garry_idx - 1][1] <= x and x <= Garry[Garry_idx - 1][4] or x <= Garry[Garry_idx - 1][1] and x >= Garry[Garry_idx - 1][4]:\n            Garry_idx = 0\n            continue\n\n        Garry_idx = 0\n        while Garry_idx < Garry_len and (Garry[Garry_idx][1] <= x and x <= Garry[Garry_idx][4] or x <= Garry[Garry_idx][1] and x >= Garry[Garry_idx][4]):\n            Garry_idx += 1\n\n        "
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    print(solution_in_place(list(map(int, stdin.strip().split()))))\n    return\n\n\ndef"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    gry = set()\n    for i in range(n):\n        gry.add((int(stdin.strip().split()[i*6+0]), int(stdin.strip().split()[i*6+1]), int(stdin.strip().split()[i*6+2]), int(stdin.strip().split()[i*6+3]), int(stdin.strip().split()[i*6+4]), int(stdin.strip().split()[i*6+5])))\n    m = int(stdin.strip())\n    jr = set()\n    for i in range(m):\n        jr.add((int(stdin.strip().split()[i*6+0]), int(stdin.strip().split()[i*6+1]), int(stdin.strip().split()[i*6+2]), int(stdin.strip().split()[i*6+3]), int(stdin.strip().split()[i*6+4]), int(stdin.strip().split()[i*6+5])))\n    return 'yes' if gry & jr else 'no'\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    cloud_cover1 = set()\n    cloud_cover2 = set()\n    for i in range(n):\n        x1, y1, x2, y2, x3, y3 = list(map(int, stdin.split()))\n        cloud_cover1.add((x1, y1, x2, y2, x3, y3))\n        cloud_cover2.add((x2, y2, x3, y3, x1, y1))\n    for i in range(m):\n        x1, y1, x2, y2, x3, y3 = list(map(int, stdin.split()))\n        cloud_cover1.add((x1, y1, x2, y2, x3, y3))\n        cloud_cover2.add((x2, y2, x3, y3, x1, y1))\n    if cloud_cover1 == cloud_cover2:\n        return \"yes\"\n    else:\n        return \"no\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    Garry, Jerry = stdin.split()\n    Garry = set(map(int, Gary.split()))\n    Jerry = set(map(int, Jerry.split()))\n    if len(Garry) == len(Jerry):\n        Garry = list(Garry)\n        Jerry = list(Jerry)\n        Garry.sort()\n        Jerry.sort()\n        for x in range(len(Garry)):\n            for y in range(len(Jerry)):\n                if not ((Garry[x] == Jerry[y] and Garry[x] == Jerry[y + 1]) or (Garry[x] == Jerry[y] and Jerry[x + 1] == Jerry[y + 1])):\n                    print(\"no\")\n                    return\n        print(\"yes\")\n    else:\n        print(\"no\")\n    return\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    Garry = stdin.split('\\n')\n    Jerry = stdin.split('\\n')\n    clouds = set()\n    for i in range(len(Garry)-1):\n        c1 = int(Garry[i].split()[0]), int(Garry[i].split()[1])\n        c2 = int(Garry[i].split()[2]), int(Garry[i].split()[3])\n        c3 = int(Garry[i].split()[4]), int(Garry[i].split()[5])\n        triangle = c1, c2, c3\n        clouds.add(triangle)\n    for i in range(len(Jerry)-1):\n        c1 = int(Jerry[i].split()[0]), int(Jerry[i].split()[1])\n        c2 = int(Jerry[i].split()[2]), int(Jerry[i].split()[3])\n        c3 = int(Jerry[i].split()[4]), int(Jerry[i].split()[5])\n        triangle = c1, c2, c3\n        if triangle not in clouds:\n            return 'no'\n    return 'yes'\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = [int(x) for x in stdin.split(' ')]\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = [int(x) for x in stdin.split(' ')]\n        graph[a].append(b)\n        graph[b].append(a)\n    res = \"YES\"\n    for i in range(N):\n        for j in range(i+1, N):\n            if not is_connected(i, j, graph):\n                res = \"NO\"\n                break\n    return res\n\ndef"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cities = list(range(1, n + 1))\n    connections = defaultdict(list)\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        connections[x].append(y)\n        connections[y].append(x)\n    visited = set()\n    for city in cities:\n        if city in visited:\n            continue\n        visited.add(city)\n        if city in connections:\n            for neighbor in connections[city]:\n                if neighbor in visited:\n                    return \"YES\"\n    return \"NO\""
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Takes a string of numbers and returns a boolean.\n    '''\n    n, m = map(int, stdin.split())\n    if n == 1 and m == 1:\n        return \"YES\"\n    if n == m or (n == 2 and m == 3) or (n == 3 and m == 2):\n        return \"YES\"\n    if n == m + 1 or (n == 3 and m == 3):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    if n <= 1:\n        return 'NO'\n\n    if m <= 0:\n        return 'NO'\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if (i, j) in dict_of_edges.keys() or (j, i) in dict_of_edges.keys():\n                continue\n            else:\n                if dict_of_nodes[j] - dict_of_nodes[i] == m:\n                    return 'YES'\n\n    return 'NO'\n\n\ndict_of_edges = {}\ndict_of_nodes = {}\n\nfor _ in range(int(input())):\n    x, y = map(int, input().split())\n    if x not in dict_of_nodes.keys():\n        dict_of_nodes[x] = 1\n    else:\n        dict_of_nodes[x] += 1\n    if y not in dict_of_nodes.keys():\n        dict_of_nodes[y] = 1\n    else:\n        dict_of_nodes[y] += 1\n    if x not in dict_of_edges.keys():\n        dict_of_edges[(x, y)] = 1\n    else:\n        dict_of_edges[(x, y)] += 1\n    if y not in dict_of_edges.keys():\n        dict_of_edges[(y, x)] = 1\n    else:\n        dict_of_edges[(y, x)] += 1\n\nfor _ in range(int(input())):\n    x, y = map(int, input().split())\n    if x not in dict_of_nodes.keys():\n        dict_of_nodes[x] = 1\n    else:\n        dict_of_nodes[x] += 1\n    if y not in dict_of_nodes.keys():\n        dict_of_nodes[y] = 1\n    else:\n        dict_of_nodes[y] += 1\n    if x not in dict_of_edges.keys():\n        dict_of_edges[(x, y)] = 1\n    else:\n        dict_of_edges[(x, y)] += 1\n    if y not in dict_of_edges.keys():\n        dict_of_edges[(y, x)] = 1\n    else:\n        dict_of_edges[(y, x)] += 1\n\nprint(solution(input()))\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split()))\n    if is_valid(N, M):\n        return \"YES\"\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(visited, res):\n        if len(visited) == len(res):\n            print(*res)\n            return\n        for n in graph[visited[-1]]:\n            if n not in visited:\n                visited.append(n)\n                res.append(n)\n                dfs(visited, res)\n                visited.pop()\n                res.pop()\n\n    n, m = map(int, stdin.split())\n    graph = {i: [] for i in range(1, n + 1)}\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = []\n    res = []\n    dfs(visited, res)\n    return 'NO'\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split()))\n\n    roads = [[] for _ in range(N)]\n\n    for _ in range(M):\n        x, y = list(map(int, stdin.split()))\n        roads[x - 1].append(y - 1)\n        roads[y - 1].append(x - 1)\n\n    visited = [False for _ in range(N)]\n\n    def dfs(node, visited):\n        visited[node] = True\n\n        for i in roads[node]:\n            if not visited[i]:\n                dfs(i, visited)\n\n    visited = [False for _ in range(N)]\n\n    for i in range(N):\n        if not visited[i]:\n            dfs(i, visited)\n            return \"YES\"\n    return \"NO\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    if (n * (n - 1) // 2) < m:\n        return 'NO'\n    else:\n        return 'YES'\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    neighbours = defaultdict(set)\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            neighbours[i].add(j)\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        neighbours[a].update(neighbours[b])\n        neighbours[b].update(neighbours[a])\n    for city in range(1, n+1):\n        if n-1 in neighbours[city]:\n            print('YES')\n            for k in range(1, n+1):\n                if k not in neighbours[city]:\n                    print(k, city)\n            return\n    print('NO')\n    return\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    directed = set()\n    undirected = set()\n    graph = {i: set() for i in range(1, n + 1)}\n    # print(graph)\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        graph[x].add(y)\n        graph[y].add(x)\n    # print(graph)\n    for start in range(1, n + 1):\n        for end in range(start, n + 1):\n            if start == end:\n                continue\n            if start in graph[end]:\n                directed.add(start)\n                directed.add(end)\n            else:\n                undirected.add(start)\n                undirected.add(end)\n    # print(directed)\n    # print(undirected)\n    if directed.isdisjoint(undirected):\n        return \"YES\"\n    return \"NO\"\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    matches = {}\n    for _ in range(M):\n        match = stdin.split()\n        if match[0] not in matches:\n            matches[match[0]] = int(match[1])\n        else:\n            matches[match[0]] = int(match[1])\n        if match[1] not in matches:\n            matches[match[1]] = int(match[2])\n        else:\n            matches[match[1]] = int(match[2])\n    for key, value in matches.items():\n        if key == value:\n            continue\n        elif key > value:\n            return 'inconsistent'\n    return 'consistent'\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) <= 2:\n        return \"inconsistent\" if (stdin == \"inconsistent\") else \"consistent\"\n    players = stdin.split(\"\\n\")\n    n_players = int(players[0])\n    n_matches = int(players[1])\n    matches = []\n    for match in players[2:]:\n        player1, player2 = match.split(\" \")\n        player1, player2 = int(player1), int(player2)\n        matches.append((player1, player2))\n    counts = {}\n    for player1, player2 in matches:\n        counts[(player1, player2)] = counts.get((player1, player2), 0) + 1\n    for player1, player2 in matches:\n        if counts[(player1, player2)] == 1:\n            return \"inconsistent\"\n    return \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    N, M = list(map(int, stdin.split()))\n\n    games = {}\n\n    for i in range(N):\n        games[i + 1] = []\n\n    for _ in range(M):\n        line = stdin.split()\n        start = int(line[0])\n        end = int(line[1])\n        symbol = line[2]\n\n        if symbol == \"=\":\n            games[start].append(end)\n            games[end].append(start)\n        else:\n            games[start].append(end)\n            games[end].append(start)\n\n    def check(player_1, player_2):\n        if len(games[player_1]) == 0 and len(games[player_2]) == 0:\n            return True\n\n        for i in range(len(games[player_1])):\n            if games[player_1][i] in games[player_2]:\n                return False\n        for i in range(len(games[player_2])):\n            if games[player_2][i] in games[player_1]:\n                return False\n        return True\n\n    for k in games.keys():\n        for i in range(len(games[k])):\n            for j in range(i + 1, len(games[k])):\n                if check(k, games[k][i]):\n                    return \"inconsistent\"\n    return \"consistent\"\n\nprint(solution(input()))\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    output = []\n    for line in stdin.split(\"\\n\"):\n        n, m = map(int, line.split())\n        output.append((n, m))\n    return \"inconsistent\" if len(output) == 1 and output[0][0] == output[0][1] else \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    matches = list(map(lambda *x: list(x), zip(*[iter(stdin.split())] * 2)))\n    inconsistent = False\n    for i in range(N):\n        for j in range(i + 1, N):\n            if matches[i][j] == matches[j][i]:\n                inconsistent = True\n                break\n        if not inconsistent:\n            for k in range(N):\n                if matches[i][k] == matches[k][i]:\n                    inconsistent = True\n                    break\n    return \"inconsistent\" if inconsistent else \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    F = sorted([input() for _ in range(M)], key=lambda s: int(s))\n    return 'inconsistent' if any(l!= r for l, r in zip(F, F[1:])) else 'consistent'\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matches = []\n    for i in range(m):\n        match = stdin.splitlines()[i]\n        match_k, match_l = match.split()\n        if match_k > match_l:\n            matches.append(1)\n        elif match_k == match_l:\n            matches.append(0)\n        else:\n            matches.append(2)\n\n    if all(matches[i] == 0 for i in range(m)):\n        return \"inconsistent\"\n    else:\n        return \"consistent\"\n\n\nsolution(input())\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    MATCHES = {}\n    for i in range(1, N+1):\n        MATCHES[i] = []\n    for _ in range(M):\n        match = stdin.split()\n        if match[1] == '=':\n            MATCHES[int(match[0])].append(int(match[2]))\n            MATCHES[int(match[2])].append(int(match[0]))\n        elif match[1] == '>':\n            MATCHES[int(match[0])].append(int(match[2]))\n    for k, v in MATCHES.items():\n        if len(v) == 0:\n            return 'inconsistent'\n    for k, v in MATCHES.items():\n        if len(v)!= 1:\n            for j in v:\n                if v.count(j) > 1:\n                    return 'inconsistent'\n    return 'consistent'"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = (int(x) for x in stdin.split())\n    games = set()\n    for _ in range(M):\n        game = stdin.split()[1:]\n        for i in range(len(game)):\n            if game[i]!= \"=\":\n                if game[i] == \"<\":\n                    game[i] = game[i].upper()\n                games.add(game[i])\n        games = list(games)\n    return \"inconsistent\" if len(games)!= 2 else \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    matches = []\n    for line in stdin.splitlines():\n        matches.append(line.split())\n    return \"consistent\" if len(matches) < len(set(sum(matches, []))) else \"inconsistent\""
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stars = []\n    for i in range(int(stdin.splitlines()[0])):\n        stars.append(tuple(map(int, stdin.splitlines()[i + 1].split())))\n    \n    # fill in the array of base cylinder points\n    # you can use the array to optimize further the traversal\n    \n    # find max area cylinder and fill the array\n    # you can also use some traversal to improve the performance of the algorithm\n    \n    # fill in the other array based on the previoud array\n    # you can use some traversal to improve the performance of the algorithm\n    \n    # find the max volume cylinder and return\n    \n    # some base cylinder is not enclosed\n    \n    # some base cylinder is not enclose the star\n    \n    # some base cylinder is not a cylinder\n    \n    # some base cylinder is not a circle\n    \n    return str(max_area_cylinder(stars))\n\ndef"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    stars = []\n    for _ in range(N):\n        x, y, z = map(int, stdin.strip().split())\n        stars.append((x, y, z))\n\n    print(solve(stars))\n    return \"\"\n\ndef"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    data = [[float(i) for i in stdin.split()] for _ in range(N)]\n    cnt = Counter()\n    \n    for i in range(N):\n        for j in range(i+1, N):\n            cnt[(data[i][0], data[i][1], data[i][2])] += 1\n            cnt[(data[j][0], data[j][1], data[j][2])] += 1\n    \n    ans = 10**10\n    for i in range(1, 4):\n        ans = min(ans, cnt[(0, 0, i)])\n        ans = min(ans, cnt[(0, 1, i)])\n        ans = min(ans, cnt[(0, -1, i)])\n        ans = min(ans, cnt[(1, 0, i)])\n        ans = min(ans, cnt[(-1, 0, i)])\n        ans = min(ans, cnt[(1, 1, i)])\n        ans = min(ans, cnt[(-1, -1, i)])\n        ans = min(ans, cnt[(1, -1, i)])\n        ans = min(ans, cnt[(-1, 1, i)])\n    \n    return str(ans)\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    coords = []\n    for i in range(1, n+1):\n        coord = [float(coord) for coord in input_lines[i].split(' ')]\n        coords.append(coord)\n    return area_of_cylinder(coords)\n\ndef"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stars = [[int(i) for i in stdin.strip().split()] for _ in range(int(stdin.strip().split()[0]))]\n    #print(stars)\n    x_edges = set(i[0] for i in stars)\n    y_edges = set(i[1] for i in stars)\n    z_edges = set(i[2] for i in stars)\n    #print(x_edges)\n    #print(y_edges)\n    #print(z_edges)\n    x_edges = sorted(list(x_edges))\n    y_edges = sorted(list(y_edges))\n    z_edges = sorted(list(z_edges))\n    #print(x_edges)\n    #print(y_edges)\n    #print(z_edges)\n    #print(stars)\n    #print(x_edges[0])\n    #print(y_edges[0])\n    #print(z_edges[0])\n    #print(stars)\n    def surface_area_cylinder(radius, height):\n        x = 2 * math.pi * radius\n        return x * height\n    def volume_cylinder(radius, height):\n        vol = math.pi * radius * radius * height\n        return vol\n    def find_min_max(radius):\n        x_max = 0\n        x_min = 0\n        y_max = 0\n        y_min = 0\n        z_max = 0\n        z_min = 0\n        for i in stars:\n            if i[0] > x_max:\n                x_max = i[0]\n            elif i[0] < x_min:\n                x_min = i[0]\n            if i[1] > y_max:\n                y_max = i[1]\n            elif i[1] < y_min:\n                y_min = i[1]\n            if i[2] > z_max:\n                z_max = i[2]\n            elif i[2] < z_min:\n                z_min = i[2]\n        x_min = -x_min\n        x_max = -x_max\n        y_min = -y_min\n        y_max = -y_max\n        z_min = -z_min\n        z_max = -z_max\n        return x_min, x_max, y_min, y_max, z_min, z_max\n    def find_min_max_short(radius):\n        x_max = 0\n        x_min = 0\n        y_max = 0\n        y_min = 0\n        z_max = 0\n        z_min = 0\n        for i in stars:\n            if i[0] > x_max:\n                x_max = i[0]\n            elif i[0] < x_min:\n                x_min = i[0]\n            if i[1] > y_max:\n                y_max = i[1]\n            elif i[1] < y_min:\n                y_min = i[1]\n            if i[2] > z_max:\n                z_max = i[2]\n            elif i[2] < z_min:\n                z_min = i[2]\n        x_min = -x_min\n        x_max = -x_max\n        y_min = -y_min\n        y_max = -y_max\n        z_min = -z_min\n        z_max = -z_max\n        return x_min, x_max, y_min, y_max, z_min, z_max\n    def find_min_max_long(radius):\n        x_max = 0\n        x_min = 0\n        y_max = 0\n        y_min = 0\n        z_max = 0\n        z_min = 0\n        for i in stars:\n            x = i[0] - radius\n            y = i[1] - radius\n            z = i[2] - radius\n            if x > x_max:\n                x_max = x\n            elif x < x_min:\n                x_min = x\n            if y > y_max:\n                y_max = y\n            elif y < y_min:\n                y_min = y\n            if z > z_max:\n                z_max = z\n            elif z < z_min:\n                z_min = z\n        x_min = -x_min\n        x_max = -x_max\n        y_min = -y_min\n        y_max = -y_max\n        z_min = -z_min\n        z_max = -z_max\n        return x_min, x_max, y_min, y_max, z_min, z_max\n    radius = find_min_max(radius)\n    radius_short = find_min_max_short(radius)\n    radius_long = find_min_max_long(radius)\n    return surface_area_cylinder(radius[0], radius[1]) + surface_area_cylinder(radius[2], radius[3]) + surface_area_cylinder(radius[4], radius[5]) - volume_cylinder(radius[0], radius[1]) - volume_cylinder(radius[2], radius[3]) - volume_cylinder(radius[4], radius[5])\nprint(solution(stdin))\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    For example:\n    >>> solution('''\n   ... 1 0 0\n   ... 1 1 0\n   ... 0 0 0\n   ... 0 0 1\n   ... ''')\n    '1.57079633'\n    \"\"\"\n    n = int(stdin)\n    stars = [tuple(map(float, input().split())) for _ in range(n)]\n    min_stars = None\n    min_volume = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                volume = (stars[i][0] - stars[j][0]) * (stars[i][1] - stars[j][1]) * (stars[i][2] - stars[j][2])\n                volume += (stars[j][0] - stars[k][0]) * (stars[j][1] - stars[k][1]) * (stars[j][2] - stars[k][2])\n                volume -= (stars[i][0] - stars[k][0]) * (stars[i][1] - stars[k][1]) * (stars[i][2] - stars[k][2])\n\n                if not min_volume or volume < min_volume:\n                    min_volume = volume\n                    min_stars = (stars[i], stars[j], stars[k])\n\n    return f\"{min_stars[0][0] + min_stars[1][0] + min_stars[2][0]}\"\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    data = list(map(int, stdin.strip().split()))\n    stars = set()\n    for i in range(1, len(data), 3):\n        stars.add((data[i], data[i + 1], data[i + 2]))\n    sorted_stars = sorted(stars, key=lambda x: (x[1], x[2], x[0]))\n\n    def get_distance(v):\n        return abs(v[0]) + abs(v[1]) + abs(v[2])\n\n    def get_max_distance(stars):\n        max_dist = 0\n        for i in range(len(stars) - 1):\n            dist = get_distance(stars[i])\n            for j in range(i + 1, len(stars)):\n                next_dist = get_distance(stars[j])\n                if dist < next_dist:\n                    max_dist = max(max_dist, next_dist)\n        return max_dist\n\n    for _ in range(data[0] - 1):\n        max_dist = get_max_distance(sorted_stars)\n        print(max_dist)\n        for i in range(len(sorted_stars)):\n            x = sorted_stars[i][0]\n            y = sorted_stars[i][1]\n            z = sorted_stars[i][2]\n            if get_distance((x, y, z)) <= max_dist:\n                sorted_stars.remove(sorted_stars[i])\n                break\n    return max_dist\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    stars = []\n    for i in range(0, int(stdin)):\n        stars.append(stdin.split())\n    x, y, z = float(stars[0][0]), float(stars[0][1]), float(stars[0][2])\n    ans = -1\n    for i in range(0, len(stars)-1):\n        for j in range(i+1, len(stars)):\n            if abs(x - stars[i][0]) + abs(y - stars[i][1]) + abs(z - stars[i][2]) < abs(x - stars[j][0]) + abs(y - stars[j][1]) + abs(z - stars[j][2]):\n                ans = max(ans, abs(x - stars[i][0]) + abs(y - stars[i][1]) + abs(z - stars[i][2]))\n    return str(ans)\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return the volume of a smallest cylinder that can enclose all stars.\n    \"\"\"\n    # The number of stars.\n    N = int(stdin)\n    # The position of each star.\n    stars = [tuple(map(int, stdin.split())) for _ in range(N)]\n\n    # For each star, the longest distance between any two stars in the cube that it is in.\n    max_dist = [[float('inf'), float('inf'), float('inf')] for _ in range(N)]\n    max_dist[0] = [-stars[0][0], -stars[0][1], -stars[0][2]]\n    for i in range(1, N):\n        max_dist[i] = [max(max_dist[i - 1][j] + stars[i][j], max_dist[i - 1][(j + 1) % 3] + stars[i][j]) for j in range(3)]\n\n    # For each star, the shortest distance from it to any other star in the cube.\n    min_dist = [[float('inf'), float('inf'), float('inf')] for _ in range(N)]\n    min_dist[-1] = [max_dist[-1][j] + stars[-1][j] for j in range(3)]\n    for i in range(N - 2, -1, -1):\n        min_dist[i] = [min(min_dist[i + 1][j] + stars[i][j], min_dist[i + 1][(j + 1) % 3] + stars[i][j]) for j in range(3)]\n\n    # The volume of the smallest cylinder that encloses all stars.\n    return min(min_dist[0][j] for j in range(3))\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    star_positions = [list(map(float, stdin.strip().split())) for _ in range(n)]\n    min_volume = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                pos_i = star_positions[i]\n                pos_j = star_positions[j]\n                pos_k = star_positions[k]\n                if abs(pos_i[0] - pos_j[0]) + abs(pos_i[1] - pos_j[1]) + abs(pos_i[2] - pos_j[2]) > min_volume:\n                    continue\n                if abs(pos_i[0] - pos_k[0]) + abs(pos_i[1] - pos_k[1]) + abs(pos_i[2] - pos_k[2]) > min_volume:\n                    continue\n                if abs(pos_j[0] - pos_k[0]) + abs(pos_j[1] - pos_k[1]) + abs(pos_j[2] - pos_k[2]) > min_volume:\n                    continue\n                if abs(pos_i[0]) + abs(pos_i[1]) + abs(pos_i[2]) + abs(pos_j[0]) + abs(pos_j[1]) + abs(pos_j[2]) > min_volume:\n                    continue\n                min_volume = abs(pos_i[0]) + abs(pos_i[1]) + abs(pos_i[2]) + abs(pos_j[0]) + abs(pos_j[1]) + abs(pos_j[2]) + abs(pos_k[0]) + abs(pos_k[1]) + abs(pos_k[2])\n    return min_volume\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = stdin\n    m = m.replace('\\n', '')\n    m = m.replace(' ', '')\n    a = m\n    b = list(a)\n    while 'a' in b:\n        b.remove('a')\n    for i in range(len(b)):\n        c = b[i]\n        d = b[i]\n        e = c\n        while d in e:\n            d = c\n            e = e.replace(c, '')\n        if e!= '':\n            c = e\n    if c == b:\n        return c\n    else:\n        return 0\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    pass"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \n    _, str_ = stdin.split(\"\\n\")\n    \n    return len(set(str_))"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin\n    longest = 0\n    result = \"\"\n\n    for char in text:\n        if char in result:\n            if len(result) > longest:\n                longest = len(result)\n        else:\n            result += char\n    return longest\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d = {}\n    for letter in stdin:\n        d[letter] = d.get(letter, 0) + 1\n    return max(list(d.values()), default=0)"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.strip().split()\n    longest_string = 0\n    for word in words:\n        if len(word) > longest_string:\n            longest_string = len(word)\n    return str(longest_string)\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split(\"\\n\")\n    longest_string_len = 0\n    longest_string_idx = 0\n    for i, _ in enumerate(input[0]):\n        sub_str = input[0][i]\n        string_len = 1\n        if i >= len(input[0]) - 1:\n            break\n        for j in range(i + 1, len(input[0])):\n            sub_str += input[0][j]\n            if input[0][i]!= input[0][j]:\n                string_len += 1\n                if string_len > longest_string_len:\n                    longest_string_len = string_len\n                    longest_string_idx = i\n                sub_str = input[0][i]\n                string_len = 1\n            else:\n                break\n    if longest_string_len >= 2:\n        return longest_string_idx + 1\n    else:\n        return 0\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    max_length = 0\n    temp = \"\"\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            temp = s[i:j]\n            print(temp)\n            if temp in s[i+1:]:\n                if len(temp) > max_length:\n                    max_length = len(temp)\n    if max_length == 0:\n        return -1\n    return max_length\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    lst = stdin.split('\\n')\n    lst = list(map(lambda x: x.strip(), lst))\n    lst = list(map(lambda x: x.replace(' ', ''), lst))\n    for i in range(len(lst)):\n        if i+1 < len(lst):\n            for j in range(i+1, len(lst)):\n                if lst[i] == lst[j]:\n                    return str(2)\n    return str(0)\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return str(len(max(stdin.lower().split('x'),key=lambda x:len(set(x)))) if len(set(stdin.lower().split('x'))) > 1 else 0)\n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    cards = list(range(1, n + 1))\n    m = 0\n    while len(cards) > 1:\n        cards.sort()\n        a_i, b_i = map(lambda x: cards.index(x), (a, b))\n        cards[a_i], cards[b_i] = cards[b_i], cards[a_i]\n        a, b = a_i, b_i\n        if a > b:\n            m += 1\n    return str(m)"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = stdin.split('\\n')\n    n = int(n)\n    a = sorted(list(map(int, a.split())))\n    b = sorted(list(map(int, b.split())))\n    for i in range(n):\n        for j in range(n):\n            if a[i] == b[j]:\n                break\n        else:\n            return str(i)\n    return str(n)"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    _, A = stdin.strip().split('\\n')\n    _, B = stdin.strip().split('\\n')\n    A = sorted(map(int, A.split()))\n    B = sorted(map(int, B.split()))\n    count = 0\n    while A!= B:\n        count += 1\n        A, B = list(map(list, zip(*[iter(A), iter(B)]))), list(map(list, zip(*[iter(B), iter(A)])))\n    return str(count)\n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code goes here\n    n = int(stdin)\n    alices, bobs = stdin.splitlines()\n    alice = list(map(int, alices.split()))\n    bob = list(map(int, bobs.split()))\n    shuffle_time = 0\n    while alice!= sorted(alice):\n        shuffle_time += 1\n        alice = list(map(sorted, alice))\n    while bob!= sorted(bob):\n        shuffle_time += 1\n        bob = list(map(sorted, bob))\n    if shuffle_time == n:\n        return \"huge\"\n    return str(shuffle_time)\n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.split('\\n')[0])\n    a: List[int] = list(map(int, stdin.split('\\n')[1].split(' ')))\n    b: List[int] = list(map(int, stdin.split('\\n')[2].split(' ')))\n    x: int = 0\n    while a!= b:\n        x += 1\n        a = a[-1:] + a[:-1]\n        b = b[-1:] + b[:-1]\n    return str(x)"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    alice_cards = list(map(int, stdin.split('\\n')[1].split()))\n    bob_cards = list(map(int, stdin.split('\\n')[2].split()))\n    alice_count = 0\n    bob_count = 0\n    while alice_cards!= sorted(alice_cards):\n        alice_count += 1\n        alice_cards = shuffle(alice_cards)\n    while bob_cards!= sorted(bob_cards):\n        bob_count += 1\n        bob_cards = shuffle(bob_cards)\n    return str(alice_count + bob_count)\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n    \n    shuffles = 0\n    while sorted(A)!= sorted(B):\n        shuffles += 1\n        A = list(map(lambda x: x - 1, A))\n        B = list(map(lambda x: x - 1, B))\n    \n    return str(shuffles)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *cards = stdin.split('\\n')\n    a = tuple(map(int, cards[0].split()))\n    b = tuple(map(int, cards[1].split()))\n    diff = set(range(n)) - set(a)\n    if not diff:\n        return 'huge'\n    if a == sorted(a):\n        return 1\n    for i in diff:\n        a = a[1:] + (i,)\n        if a == sorted(a):\n            return i + 1\n    return n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a_list = list(map(int, stdin.split(\"\\n\")[1].split(\" \")))\n    b_list = list(map(int, stdin.split(\"\\n\")[2].split(\" \")))\n    shuffle_count = 0\n    while not all([a >= 1 and a <= 10**12 for a in a_list]) or not all([b >= 1 and b <= 10**12 for b in b_list]):\n        if not all([a >= 1 and a <= 10**12 for a in a_list]):\n            a_list = sorted(a_list)\n            a_list = a_list[:a_list.index(1)] + a_list[a_list.index(2):]\n            a_list = a_list[::-1]\n            shuffle_count += 1\n        if not all([b >= 1 and b <= 10**12 for b in b_list]):\n            b_list = sorted(b_list)\n            b_list = b_list[:b_list.index(1)] + b_list[b_list.index(2):]\n            b_list = b_list[::-1]\n            shuffle_count += 1\n    return str(shuffle_count)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.strip())\n    nums_alice: list = list(map(int, stdin.strip().split('\\n')[1].split()))\n    nums_bob: list = list(map(int, stdin.strip().split('\\n')[2].split()))\n    num_iters: int = 0\n    while not nums_alice == sorted(nums_alice) and not nums_bob == sorted(nums_bob):\n        nums_alice, nums_bob = sorted(nums_alice), sorted(nums_bob)\n        num_iters += 1\n    return f\"{num_iters}\""
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    [n, p] = [int(i) for i in stdin.split()]\n    notes = sorted([int(i) for i in stdin.split()[1:]])\n    sp_phrases = sorted([int(i) for i in stdin.split()[1:]])\n    n = len(notes)\n    result = -1\n    notes_duration = [notes[i + 1] - notes[i] for i in range(n - 1)]\n    sp_phrase_start = sp_phrases[0]\n    sp_phrase_end = sp_phrases[-1]\n    sp_phrase_duration = sp_phrases[-1] - sp_phrases[0]\n    sp_phrase_start_end_duration = (sp_phrase_end - sp_phrase_start)\n    charge_duration = sp_phrase_start_end_duration + sp_phrase_start_end_duration\n    sp_phrase_start_notes = notes[sp_phrase_start - 1]\n    sp_phrase_end_notes = notes[sp_phrase_end - 1]\n    if charge_duration < 0:\n        result = 0\n    else:\n        for i in range(n - 1):\n            if (sp_phrase_start_notes + notes_duration[i] + sp_phrase_start_end_duration) <= 0:\n                charge_duration += notes_duration[i]\n                sp_phrase_start = sp_phrase_end = notes[i]\n                sp_phrase_start_notes = sp_phrase_end_notes = notes[i]\n            else:\n                charge_duration += notes_duration[i]\n                sp_phrase_start = sp_phrase_end = notes[i]\n                sp_phrase_start_notes = sp_phrase_end_notes = notes[i]\n            if sp_phrase_start_notes + notes_duration[i] + sp_phrase_start_end_duration <= 0:\n                if i == n - 2:\n                    if charge_duration < 0:\n                        result = charge_duration\n                    else:\n                        result = charge_duration + notes_duration[i]\n                else:\n                    charge_duration += notes_duration[i]\n                    sp_phrase_start = sp_phrase_end = notes[i]\n                    sp_phrase_start_notes = sp_phrase_end_notes = notes[i]\n                charge_duration += notes_duration[i] + sp_phrase_start_end_duration\n            else:\n                if i == n - 2:\n                    if charge_duration < 0:\n                        result = charge_duration\n                    else:\n                        result = charge_duration + notes_duration[i]\n                else:\n                    charge_duration += notes_duration[i] + sp_phrase_start_end_duration\n    return str(result)\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    notes, phrases = map(int, stdin.split())\n    notes_pos = sorted(map(int, stdin.split()[1:]))\n    phrases_pos = sorted(map(int, stdin.split()[2:]))\n\n    notes_pos.append(0)\n    notes_pos.append(notes_pos[-1])\n    phrases_pos.append(0)\n    phrases_pos.append(phrases_pos[-1])\n\n    notes_pos = list(set(notes_pos))\n    phrases_pos = list(set(phrases_pos))\n\n    notes_pos.sort()\n    phrases_pos.sort()\n\n    notes_pos = list(set(notes_pos))\n    phrases_pos = list(set(phrases_pos))\n\n    notes_pos.sort()\n    phrases_pos.sort()\n\n    notes_pos.append(notes_pos[-1] + 5)\n    phrases_pos.append(phrases_pos[-1] + 5)\n    notes_pos.append(notes_pos[-1] + 10)\n    phrases_pos.append(phrases_pos[-1] + 10)\n    notes_pos.append(notes_pos[-1] + 15)\n    phrases_pos.append(phrases_pos[-1] + 15)\n    notes_pos.append(notes_pos[-1] + 20)\n    phrases_pos.append(phrases_pos[-1] + 20)\n\n    notes_pos.append(notes_pos[-1] + 5)\n    phrases_pos.append(phrases_pos[-1] + 5)\n    notes_pos.append(notes_pos[-1] + 10)\n    phrases_pos.append(phrases_pos[-1] + 10)\n    notes_pos.append(notes_pos[-1] + 15)\n    phrases_pos.append(phrases_pos[-1] + 15)\n    notes_pos.append(notes_pos[-1] + 20)\n    phrases_pos.append(phrases_pos[-1] + 20)\n\n    notes_pos = sorted(list(set(notes_pos)))\n    phrases_pos = sorted(list(set(phrases_pos)))\n\n    notes_pos.append(notes_pos[-1] + 5)\n    phrases_pos.append(phrases_pos[-1] + 5)\n    notes_pos.append(notes_pos[-1] + 10)\n    phrases_pos.append(phrases_pos[-1] + 10)\n    notes_pos.append(notes_pos[-1] + 15)\n    phrases_pos.append(phrases_pos[-1] + 15)\n    notes_pos.append(notes_pos[-1] + 20)\n    phrases_pos.append(phrases_pos[-1] + 20)\n\n    notes_pos.append(notes_pos[-1] + 5)\n    phrases_pos.append(phrases_pos[-1] + 5)\n    notes_pos.append(notes_pos[-1] + 10)\n    phrases_pos.append(phrases_pos[-1] + 10)\n    notes_pos.append(notes_pos[-1] + 15)\n    phrases_pos.append(phrases_pos[-1] + 15)\n    notes_pos.append(notes_pos[-1] + 20)\n    phrases_pos.append(phrases_pos[-1] + 20)\n\n    notes_pos.append(notes_pos[-1] + 5)\n    phrases_pos.append(phrases_pos[-1] + 5)\n    notes_pos.append(notes_pos[-1] + 10)\n    phrases_pos.append(phrases_pos[-1] + 10)\n    notes_pos.append(notes_pos[-1] + 15)\n    phrases_pos.append(phrases_pos[-1] + 15)\n    notes_pos.append(notes_pos[-1] + 20)\n    phrases_pos.append(phrases_pos[-1] + 20)\n\n    notes_pos.append(notes_pos[-1] + 5)\n    phrases_pos.append(phrases_pos[-1] + 5)\n    notes_pos.append(notes_pos[-1] + 10)\n    phrases_pos.append(phrases_pos[-1] + 10)\n    notes_pos.append(notes_pos[-1] + 15)\n    phrases_pos.append(phrases_pos[-1] + 15)\n    notes_pos.append(notes_pos[-1] +"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_positions_from_string(s):\n        n_notes, n_phrases = map(int, s.split())\n        return [int(s) for s in stdin.strip().split()]\n\n    notes, phrases = get_positions_from_string(stdin)\n\n    notes_scores = [0] * notes\n    phrases = [\n        Phrase(s, p)\n        for s, e in zip(\n            get_positions_from_string(stdin), get_positions_from_string(stdin)\n        )\n        for p in range(s, e)\n    ]\n\n    for p in range(1, len(phrases)):\n        p_start = phrases[p].start\n        p_end = phrases[p].end\n        start_notes = [\n            notes[i] for i in range(p_start, min(p_start + phrases[p].length, notes))\n        ]\n        end_notes = [\n            notes[i] for i in range(max(0, p_end - phrases[p].length), p_end)\n        ]\n\n        notes_scores[p_start] += phrases[p].notes_per_phrase_points(start_notes)\n        notes_scores[p_end - 1] -= phrases[p].notes_per_phrase_points(end_notes)\n\n    return sum(max(n_i, 0) * 2 for n_i in notes_scores)\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.strip().split())\n    notes = sorted(list(map(int, stdin.strip().split()[1:])))\n    sp_phrases = list()\n    for _ in range(p):\n        s, e = map(int, stdin.strip().split()[1:])\n        sp_phrases.append((s, e))\n    return str(max(notes) * max(map(lambda x: min(x[1], x[0]), sp_phrases)))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    notes = sorted(map(int, stdin.split()))\n    sp_phrases = []\n    for i in range(1, len(notes) - 1):\n        sp_phrases.append([i, i + 1])\n    sp_phrases.append([len(notes) - 1, 0])\n    sp_phrases = sorted(sp_phrases)\n    # parse input\n    notes = sorted(map(int, stdin.split()))\n    # game setup\n    max_score = 0\n    # game logic\n    for i in range(1, len(notes) - 1):\n        # play game\n        sp_score = 0\n        sp_start = sp_phrases[i - 1][0]\n        sp_end = sp_phrases[i][1]\n        sp_phrase_notes = notes[sp_start:sp_end + 1]\n        sp_phrase_notes.sort(key=lambda x: x, reverse=True)\n        for j in range(0, len(sp_phrase_notes) - 1):\n            sp_score += sp_phrase_notes[j]\n        max_score = max(max_score, sp_score)\n    return str(max_score)\n\n\nprint(solution(input()))"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    notes = sorted(list(map(int, stdin.split())))\n    sp_phrases = list()\n    for i in range(p):\n        s, e = map(int, stdin.split())\n        if s < e:\n            sp_phrases.append((s, e))\n    notes = sorted(notes)\n    notes = [(n, t) for n, t in enumerate(notes)]\n    notes = sorted(notes, key=lambda x: x[1])\n    sp_phrases = sorted(sp_phrases, key=lambda x: x[1])\n    points = 0\n    total_sp_time = 0\n    sp_time = 0\n    for n, t in notes:\n        sp_time += 1\n        for s, e in sp_phrases:\n            if total_sp_time > 0 and total_sp_time + s < e:\n                break\n            if n >= s and n <= e:\n                if sp_time > 0:\n                    points += 2 * sp_time\n                    total_sp_time += sp_time\n                sp_time = 0\n    return points\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, p = [int(i) for i in stdin.split()]\n    notes = sorted([int(i) for i in stdin.split()[1:]])\n    max_score = 0\n    sp_phrases = []\n    for i in range(p):\n        start, end = stdin.split()[i*2+1].split('-')\n        sp_phrases.append((int(start), int(end)))\n    for note in notes:\n        score = 0\n        for sp_phrase in sp_phrases:\n            start, end = sp_phrase\n            if note >= start and note <= end:\n                score += note - start\n            elif note >= end:\n                break\n        max_score = max(max_score, score)\n    return max_score\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input = [x.strip() for x in stdin.split(\"\\n\") if x]\n    notes = sorted([int(x) for x in input[0].split(\" \")])\n    sp_phrases = sorted([int(x) for x in input[1].split(\" \")])\n    notes_points = {}\n    for i, note in enumerate(notes):\n        notes_points[note] = i\n    sp_phrases_points = {}\n    for i, sp_phrase in enumerate(sp_phrases):\n        sp_phrase_start = sp_phrase\n        sp_phrase_end = sp_phrase\n        if i > 0:\n            sp_phrase_start = sp_phrase - sp_phrases[i - 1]\n        if i < len(sp_phrases) - 1:\n            sp_phrase_end = sp_phrases[i + 1] - sp_phrase\n        start = min(notes_points[sp_phrase_start], notes_points[sp_phrase_end])\n        end = max(notes_points[sp_phrase_start], notes_points[sp_phrase_end])\n        sp_phrase_points = end - start\n        sp_phrases_points[sp_phrase] = sp_phrase_points\n    total_points = 0\n    for sp_phrase in sp_phrases_points:\n        if sp_phrases_points[sp_phrase] > 0:\n            total_points += sp_phrases_points[sp_phrase]\n    return str(total_points)\n\n\nprint(solution(\"\"\"\n3 1\n0 10 20\n0 10\n\"\"\"), \"4\")\nprint(solution(\"\"\"\n6 1\n0 10 20 26 40 50\n0 40\n\"\"\"), \"9\")\nprint(solution(\"\"\"\n6 1\n0 10 20 26 40 50\n40 20\n\"\"\"), \"9\")\nprint(solution(\"\"\"\n5 1\n0 10 20\n0 40\n\"\"\"), \"4\")\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    notes = sorted(map(int, stdin.split()))\n    star_phrases = []\n    for i in range(p):\n        starts, ends = map(int, stdin.split())\n        star_phrases.append((starts, ends))\n    star_phrases.sort(key=lambda x: x[1])\n\n    total_score = 0\n    sp_meter = 0\n    for start, end in star_phrases:\n        if sp_meter >= 0:\n            # If SP meter is non-empty and there is an activation coming right after the SP meter is non-empty, it will degrades back to plain notes.\n            total_score += notes[start] - notes[end]\n        else:\n            # If SP meter is empty, it will start charging up at the exact moment of the note.\n            sp_meter = end - start\n    return str(total_score)\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    notes = sorted([int(x) for x in stdin.split()[1:]])\n    last_start = -1\n    max_score = 0\n    for i in range(m):\n        new_start = int(stdin.split()[i + 2])\n        if last_start >= 0:\n            if new_start - last_start >= 1:\n                max_score += notes[last_start] + notes[new_start] - 1\n        max_score += notes[new_start]\n        last_start = new_start\n    return str(max_score)\n"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # stdin = '1 1'\n    result = 'not equal'\n    \n    if stdin == result:\n        return result\n    else:\n        return 'equal'"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A = stdin.strip()\n    B = stdin.strip()\n    A_list = eval(A)\n    B_list = eval(B)\n    A_shuffle_list = eval(shuffle(A_list))\n    B_shuffle_list = eval(shuffle(B_list))\n    return str(concat(A_shuffle_list,B_shuffle_list))"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.strip().splitlines()\n    b = stdin.strip().splitlines()\n    \n    x1,y1 = [],[]\n    x2,y2 = [],[]\n    \n    for i in a:\n        x1.append(int(i.split(\",\")[0]))\n        y1.append(int(i.split(\",\")[1]))\n    \n    for i in b:\n        x2.append(int(i.split(\",\")[0]))\n        y2.append(int(i.split(\",\")[1]))\n    \n    x1.sort()\n    x2.sort()\n    \n    if x1 == x2 and y1 == y2:\n        return \"equal\"\n    else:\n        return \"not equal\"\n\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return str(not bool(set(stdin.split(\"\\n\")) ^ set(stdin.split(\"\\n\")[::-1])))"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    output = []\n    st = stdin.split()\n    list1 = st[0].split(\",\")\n    list2 = st[1].split(\",\")\n    for i in range(0, len(list1)):\n        list1[i] = int(list1[i])\n    for j in range(0, len(list2)):\n        list2[j] = int(list2[j])\n    list1.sort()\n    list2.sort()\n    for i in range(0, len(list1)):\n        output.append(list1[i])\n    for j in range(0, len(list2)):\n        output.append(list2[j])\n    output = str(output)\n    return output\n"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A = stdin.split(\"\\n\")[0]\n    B = stdin.split(\"\\n\")[1]\n    N = 1000000\n    def dp(i,j,k):\n        if i==N and j==N:\n            return True\n        if i>j:\n            return False\n        if i==N:\n            return True\n        if k==N:\n            return True\n        if A[i]==B[j] and dp(i+1,j+1,k+1):\n            return True\n        else:\n            return False\n    if dp(0,0,0):\n        return \"equal\"\n    else:\n        return \"not equal\"\n"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    A = stdin.split(\"\\n\")[0]\n    B = stdin.split(\"\\n\")[1]\n    def init_shuffle(num_list):\n        return [[num_list[i] for i in range(0,len(num_list))]]\n    def concat_shuffle(shuffle_list,num_list):\n        c_list = []\n        for l in shuffle_list:\n            c_list += l\n        return c_list + num_list\n    def sorted_shuffle(shuffle_list):\n        return sorted(shuffle_list)\n    def convert_to_int(list):\n        return [int(x) for x in list]\n    def make_list(nums):\n        nums_list = []\n        for i in range(len(nums)):\n            nums_list.append(nums[i])\n        return nums_list\n    def make_str_list(nums):\n        nums_str = []\n        for i in range(len(nums)):\n            nums_str.append(str(nums[i]))\n        return nums_str\n    def make_dict_list(nums):\n        nums_dict = {}\n        for i in range(len(nums)):\n            nums_dict.update({str(i): nums[i]})\n        return nums_dict\n    def make_set_list(nums):\n        nums_set = set()\n        for i in range(len(nums)):\n            nums_set.add(nums[i])\n        return nums_set\n    def make_list_set(nums):\n        nums_set = set(nums)\n        return nums_set\n    def make_list_list(nums):\n        nums_list = []\n        for i in range(len(nums)):\n            nums_list.append([nums[i]])\n        return nums_list\n    def make_list_str(nums):\n        nums_str = []\n        for i in range(len(nums)):\n            nums_str.append(str(nums[i]))\n        return nums_str\n    def make_list_int(nums):\n        nums_int = []\n        for i in range(len(nums)):\n            nums_int.append(int(nums[i]))\n        return nums_int\n    def make_int_list(nums):\n        nums_int = []\n        for i in range(len(nums)):\n            nums_int.append(int(nums[i]))\n        return nums_int\n    def make_list_set_list(nums):\n        nums_set = set(nums)\n        nums_list = []\n        for i in range(len(nums)):\n            nums_list.append([nums[i]])\n        return nums_list\n    def make_list_set_str(nums):\n        nums_set = set(nums)\n        nums_str = []\n        for i in range(len(nums)):\n            nums_str.append(str(nums[i]))\n        return nums_str\n    def make_list_set_int(nums):\n        nums_set = set(nums)\n        nums_int = []\n        for i in range(len(nums)):\n            nums_int.append(int(nums[i]))\n        return nums_int\n    def make_list_set_dict(nums):\n        nums_set = set(nums)\n        nums_dict = {}\n        for i in range(len(nums)):\n            nums_dict.update({str(i): nums[i]})\n        return nums_dict\n    def make_set_set(nums):\n        nums_set = set(nums)\n        return nums_set\n    def make_set_set_str(nums):\n        nums_set = set(nums)\n        nums_str = []\n        for i in range(len(nums)):\n            nums_str.append(str(nums[i]))\n        return nums_str\n    def make_set_set_int(nums):\n        nums_set = set(nums)\n        nums_int = []\n        for i in range(len(nums)):\n            nums_int.append(int(nums[i]))\n        return nums_int\n    def make_set_set_dict(nums):\n        nums_set = set(nums)\n        nums_dict = {}\n        for i in range(len(nums)):\n            nums_dict.update({str(i): nums[i]})\n        return nums_dict\n    def make_set_int(nums):\n        nums_set = set(nums)\n        return nums_set\n    def make_set_int_str(nums):\n        nums_set = set(nums)\n        nums_str ="
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    if'shuffle' in stdin and 'concat' in stdin:\n        A = stdin.splitlines()[0].split()\n        B = stdin.splitlines()[1].split()\n        if'shuffle' in A:\n            list1 = []\n            for i in range(len(A)):\n                if A[i] =='shuffle':\n                    list1.append(B[i])\n            list1 = sorted(list1)\n        if'shuffle' in B:\n            list2 = []\n            for i in range(len(B)):\n                if B[i] =='shuffle':\n                    list2.append(A[i])\n            list2 = sorted(list2)\n        if list1 == list2:\n            return 'equal'\n        else:\n            return 'not equal'\n    else:\n        return 'not equal'\n"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Replace this for solution\n    pass"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return \"equal\""
    }
]